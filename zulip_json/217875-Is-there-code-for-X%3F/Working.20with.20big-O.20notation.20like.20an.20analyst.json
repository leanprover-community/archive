[
    {
        "content": "<p><code>Mathlib.Analysis.Asymptotics.Asymptotics</code> supports a concept <code>f =O[l] g</code> of big-O notation, where for sake of discussion we can take <code>f g :  ℕ → ℝ</code> and <code>l := Filter.atTop ℕ</code>.  But I don't see how to easily use this notation to implement the type of calculations one often does in analysis, a typical one of which is</p>\n<blockquote>\n<p>(n+1)^{e^{1/n}} = (n+1)^{1 + O(1/n)}<br>\n= exp((log 𝑛 + 𝑂(1/𝑛))(1+𝑂(1/𝑛)) <br>\n=  exp(  log n + O(log n/n) ) <br>\n= n (1 + O(log n/n)) <br>\n= n + O(log n).</p>\n</blockquote>\n<p>Ideally this should be set up as a <code>calc</code>, with some basic rules to manipulate expressions involving asymptotic notation (e.g., <code>x = O(1) → exp x = 1 + O(x)</code>) that one can insert into various Lean tactics such as <code>rw</code>).  But it is difficult to formalize this calculation either in the reals <code>ℝ</code> (where the O() notation makes no sense), or in the type of functions <code>ℕ→ℝ</code> (where O() does make sense, but many rules of algebra, e.g., <code>x^y = exp (y * log x)</code>, are not currently implemented, and also there isn't the framework to deal with unspecified functions like O()).  One can eventually prove the above result in Lean by repeatedly using <code>ext</code> and <code>rcases</code> and <code>use</code> at each point where the asymptotic notation appears, but it is quite tedious.</p>\n<p>For my immediate applications I think I can get by by simply defining one new explicit constant for each appearance of the O() notation, with each constant depending on previous ones in some (possibly non-constructive) fashion.  But I wonder whether there is a way to use the full power of dependent type theory to actually implement asymptotic notation as it is used by analysts.  It seems to me that one should view each expression such as <code>exp((log 𝑛 + 𝑂(1/𝑛))(1+𝑂(1/𝑛)) </code> appearing in the above as a type, built from a base type <code>n</code> which is not a natural number precisely, but rather a sort of \"formal natural number\" suitable for asymptotic analysis (in particular, formal natural numbers are allowed to be not fully deterministic, in order to accommodate the incompletely specified terms coming from O() notation).  One could imagine having Lean formalize some general transfer principle to the effect that any fact such as <code>x^y = exp( y * log x )</code> that is true for reals (ignoring for now the side hypothesis x&gt;0 for simplicity) would carry over to formal real types, and then there would be some sort of specialization theorem that asserts that any result such as \\( f n = O( g n ) \\) that was established for the base type \\(n\\) would imply the asymptotic bound \\( f =O[l] g \\) as defined in <code>Mathlib.Analysis.Asymptotics.Asymptotics</code>.  (I am not extremely familiar with topos theory, but perhaps what I am trying to describe here is some sort of \"asymptotic topos\".)  Is this remotely feasible to implement within Lean?</p>",
        "id": 397899082,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697943161
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Working.20with.20big-O.20notation.20like.20an.20analyst/near/397899082\">said</a>:</p>\n<blockquote>\n<p>It seems to me that one should view each expression such as <code>exp((log 𝑛 + 𝑂(1/𝑛))(1+𝑂(1/𝑛)) </code> appearing in the above as a type, built from a base type <code>n</code> which is not a natural number precisely, but rather a sort of \"formal natural number\" suitable for asymptotic analysis</p>\n</blockquote>\n<p>One way to try to write these \"formal natural numbers\" would be with a calculus like the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">FormalElementaryFunction</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">FormalElementaryFunction</span>\n  <span class=\"bp\">|</span> <span class=\"n\">const</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">FormalElementaryFunction</span>\n  <span class=\"bp\">|</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">FormalElementaryFunction</span> <span class=\"bp\">→</span> <span class=\"n\">FormalElementaryFunction</span> <span class=\"bp\">→</span> <span class=\"n\">FormalElementaryFunction</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">FormalElementaryFunction</span> <span class=\"bp\">→</span> <span class=\"n\">FormalElementaryFunction</span> <span class=\"bp\">→</span> <span class=\"n\">FormalElementaryFunction</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">FormalElementaryFunction</span> <span class=\"bp\">→</span> <span class=\"n\">FormalElementaryFunction</span>\n  <span class=\"bp\">|</span> <span class=\"n\">exp</span> <span class=\"o\">:</span> <span class=\"n\">FormalElementaryFunction</span> <span class=\"bp\">→</span> <span class=\"n\">FormalElementaryFunction</span>\n  <span class=\"bp\">|</span> <span class=\"n\">log</span> <span class=\"o\">:</span> <span class=\"n\">FormalElementaryFunction</span> <span class=\"bp\">→</span> <span class=\"n\">FormalElementaryFunction</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">FormalElementaryFunction</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">FormalElementaryFunction</span> <span class=\"n\">n</span> <span class=\"n\">where</span> <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"n\">const</span> <span class=\"n\">n</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Add</span> <span class=\"n\">FormalElementaryFunction</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">add</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Mul</span> <span class=\"n\">FormalElementaryFunction</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">mul</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Inv</span> <span class=\"n\">FormalElementaryFunction</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">inv</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Pow</span> <span class=\"n\">FormalElementaryFunction</span> <span class=\"n\">FormalElementaryFunction</span> <span class=\"n\">where</span> <span class=\"n\">pow</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">exp</span> <span class=\"o\">(</span><span class=\"n\">log</span> <span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Div</span> <span class=\"n\">FormalElementaryFunction</span> <span class=\"n\">where</span> <span class=\"n\">div</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">FormalElementaryFunction</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">exp</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">FormalElementaryFunction</span> <span class=\"o\">:=</span> <span class=\"n\">exp</span> <span class=\"o\">(</span><span class=\"n\">log</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">log</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>I haven't attempted to write this part<br>\n<span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Working.20with.20big-O.20notation.20like.20an.20analyst/near/397899082\">said</a>:</p>\n<blockquote>\n<p>in particular, formal natural numbers are allowed to be not fully deterministic, in order to accommodate the incompletely specified terms coming from O() notation</p>\n</blockquote>\n<p>or the transfer principle you describe ...</p>",
        "id": 397901727,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1697945747
    },
    {
        "content": "<p>Is there any attempt in any proof assistant at all that allows you to use the internal language of some topos, and later exit it and obtain a theorem in the external world automatically?</p>",
        "id": 397902696,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1697946756
    },
    {
        "content": "<p>On the other hand, maybe <code>O(f)</code> can be seen as a macro that lifts an existence quantifier to the toplevel: It becomes \"There exists a function F such that ...\" and replaces the <code>O(f)</code> with F. Macros can perform arbitrary transformations on the syntax so it is possible, but it looks difficult.</p>",
        "id": 397902818,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1697946925
    },
    {
        "content": "<p><code>O(x)</code> as a macro sounds like a great idea</p>",
        "id": 397903056,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697947201
    },
    {
        "content": "<p>I think the real challenge with the \"calc block\" that <span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> shows is that the equality isn't really an equality, it's an inclusion of sets with the most formalistic interpretation of O(_), and sometimes not even that (especially when multiple O(_) expressions start appearing in the term). It seems exceedingly difficult to make it more than a proof sketch with all the ambiguity in the notation</p>",
        "id": 397903395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697947423
    },
    {
        "content": "<p>I'm sure some logician has already done that right? There are some quirks like <code>1 + O(x) = O(x)</code>, which means \"For all F asymt. to x, there exists G asymt. to x, such that <code>1+F=G</code>\", note the quantifier difference</p>",
        "id": 397903954,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1697947983
    },
    {
        "content": "<p>right, that's not equality, that's subset</p>",
        "id": 397904033,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697948051
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"404479\">Trebor Huang</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Working.20with.20big-O.20notation.20like.20an.20analyst/near/397902696\">said</a>:</p>\n<blockquote>\n<p>Is there any attempt in any proof assistant at all that allows you to use the internal language of some topos, and later exit it and obtain a theorem in the external world automatically?</p>\n</blockquote>\n<p>That could potentially be very useful for advanced mathematics, though I really don't know if this is feasibly implementable in current proof assistants.  Just in analysis alone, I can think of several other topoi besides the \"asymptotic topos\" that we informally jump in and out of (even though most analysts are not trained in topos-theoretic language): the nonstandard topos (where every standard type <code>X</code> gets a nonstandard supertype <code>(* X)</code> with useful transfer principles), the probabilistic topos (where every deterministic type <code>X</code> gets a probabilistic supertype of <code>X</code>-valued random variables, again with useful transfer principles), the continuous topos (each topological type <code>X</code> gets a supertype of <code>X</code>-valued quantities varying continuously with respect to ambient parameters), the polynomial time topos, etc..   We <em>can</em> (and do) simulate all these topoi with set-theoretic functions (e.g., a random real number is modeled as a function from a probability space to the reals), but it isn't completely ideal (e.g., there are \"base change\" operations that are annoying to implement in a function-based framework, and in the absence of a good transfer principle one will be using function extensionality <code>ext</code> over and over and over again...).</p>",
        "id": 397904737,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697948848
    },
    {
        "content": "<p>There is enough structure there that you could have a calc block-like environment such that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">calc_asymp</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">l</span> <span class=\"k\">in</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">n</span><span class=\"o\">))</span>\n  <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">O</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n  <span class=\"bp\">=</span> <span class=\"n\">exp</span> <span class=\"o\">((</span><span class=\"n\">log</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">O</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"n\">O</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">n</span><span class=\"o\">)))</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n  <span class=\"bp\">=</span> <span class=\"n\">exp</span> <span class=\"o\">(</span><span class=\"n\">log</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">O</span><span class=\"o\">(</span><span class=\"n\">log</span> <span class=\"n\">n</span><span class=\"bp\">/</span><span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n  <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">O</span><span class=\"o\">(</span><span class=\"n\">log</span> <span class=\"n\">n</span><span class=\"bp\">/</span><span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n  <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">O</span><span class=\"o\">(</span><span class=\"n\">log</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>is sugar for something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">H1</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n  <span class=\"bp\">∀ᶠ</span> <span class=\"n\">n</span> <span class=\"k\">in</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n<span class=\"k\">have</span> <span class=\"n\">H2</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">g1</span><span class=\"o\">,</span> <span class=\"n\">g1</span> <span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">g2</span><span class=\"o\">,</span> <span class=\"n\">g2</span> <span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n  <span class=\"bp\">∀ᶠ</span> <span class=\"n\">n</span> <span class=\"k\">in</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">exp</span> <span class=\"o\">((</span><span class=\"n\">log</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">g1</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"n\">g2</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n<span class=\"k\">have</span> <span class=\"n\">H3</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">f1</span><span class=\"o\">,</span> <span class=\"n\">f1</span> <span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">f2</span><span class=\"o\">,</span> <span class=\"n\">f2</span> <span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">log</span> <span class=\"n\">n</span><span class=\"bp\">/</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n  <span class=\"bp\">∀ᶠ</span> <span class=\"n\">n</span> <span class=\"k\">in</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">exp</span> <span class=\"o\">((</span><span class=\"n\">log</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">f1</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"n\">f2</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">≤</span> <span class=\"n\">exp</span> <span class=\"o\">(</span><span class=\"n\">log</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n<span class=\"k\">have</span> <span class=\"n\">H4</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">log</span> <span class=\"n\">n</span><span class=\"bp\">/</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">log</span> <span class=\"n\">n</span><span class=\"bp\">/</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n  <span class=\"bp\">∀ᶠ</span> <span class=\"n\">n</span> <span class=\"k\">in</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">exp</span> <span class=\"o\">(</span><span class=\"n\">log</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n<span class=\"k\">have</span> <span class=\"n\">H5</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">log</span> <span class=\"n\">n</span><span class=\"bp\">/</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">log</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n  <span class=\"bp\">∀ᶠ</span> <span class=\"n\">n</span> <span class=\"k\">in</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n<span class=\"k\">show</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">log</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n  <span class=\"bp\">∀ᶠ</span> <span class=\"n\">n</span> <span class=\"k\">in</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">n</span>\n<span class=\"k\">from</span> <span class=\"n\">combine</span> <span class=\"n\">H1</span> <span class=\"n\">H2</span> <span class=\"n\">H3</span> <span class=\"n\">H4</span> <span class=\"n\">H5</span>\n</code></pre></div>\n<p>where <code>combine</code> is a proof done by the tactic</p>",
        "id": 397905128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697949287
    },
    {
        "content": "<p>The main challenge with things like this is to come up with a precise spec for what one wants the tactic to do and how it should accept input. Scope creep is a real thing here, you have to be careful not to just put all your hopes and dreams into a miracle tactic of the future because then no one can implement it, but with a clear spec a tactic that does what I have illustrated above could probably be done in a day</p>",
        "id": 397905318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697949492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"404479\">Trebor Huang</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Working.20with.20big-O.20notation.20like.20an.20analyst/near/397903954\">said</a>:</p>\n<blockquote>\n<p>I'm sure some logician has already done that right? There are some quirks like <code>1 + O(x) = O(x)</code>, which means \"For all F asymt. to x, there exists G asymt. to x, such that <code>1+F=G</code>\", note the quantifier difference</p>\n</blockquote>\n<p>Generally speaking one can indeed make asymptotic notation rigorous by</p>\n<ul>\n<li>treating all O() symbols as referring to subsets (or subtypes) of all functions of the ambient parameter(s)</li>\n<li>interpreting any relation R means \"for any expression X of the form of the LHS, there exists a Y of the form of the RHS such that X R Y\".  In particular, equality now becomes the subset relation.</li>\n<li>\n<p>extending all operations * to \"all expressions of the form X * Y, where X is of the form of the LHS and Y is of the form of the RHS\". <br>\n For instance A+B is now basically the <a href=\"https://en.wikipedia.org/wiki/Minkowski_addition\">Minkowski sum</a> of A and B.</p>\n</li>\n<li>\n<p>One can even now define O(A) when A is itself a type that involves asymptotic notation, to denote the subtype of all expressions that are of the form O(X) for some X of the form A.  For instance O(O(n)+O(n^2)) = O(n^2).</p>\n</li>\n</ul>\n<p>Presumably the equality sign is reserved in Lean, so I would be fine with replacing = with a slightly different symbol when dealing with asymptotic types if this is needed to be consistent with Lean syntax.</p>\n<p>So in principle one could asymptotic notation involving say one natural number parameter <code>ℕ</code> by a type of subtypes of functions from <code>ℕ</code> to <code>ℝ</code>, and then transferring operations and relations over to this type basically as suggested by Heather.  </p>\n<p>There are advanced versions of O() notation where there are multiple ambient parameters, e.g., n, d, k ..., and one could have quantites such as O_{d,k}(1) that are bounded by something that can depend on d,k but not on n, but I believe that any solution that could implement single-parameter O() notation in a usable fashion could be extended rigorously to the multi-parameter setting.  (o() notation comes with some additional minor subtleties but again I believe the main difficulty is first getting O() to work properly.)</p>",
        "id": 397905513,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697949722
    },
    {
        "content": "<p>We can do the multi-parameter version with filter shenanigans if I understand correctly</p>",
        "id": 397905617,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1697949805
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Working.20with.20big-O.20notation.20like.20an.20analyst/near/397905128\">said</a>:</p>\n<blockquote>\n<p>There is enough structure there that you could have a calc block-like environment such that</p>\n</blockquote>\n<p>I like this proposal!  (Incidentally the <code>≤</code> signs in your sugar should be <code>=</code> signs because that's what's in the <code>calc_asymp</code> block; but presumably the <code>calc_asymp</code> block would also be able to handle mixtures of <code>=</code>, <code>≤</code>, <code>&lt;</code>, and also the asymptotic symbol <code>&lt;&lt;</code> (which is a synonym for <code>=O[l]</code>.)  Each individual step in this block would then need a bunch of <code>rcases</code> and <code>ext</code> steps to establish, but one could conceivably develop additional tools later (formalising basic things like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>O</mi><mo stretchy=\"false\">(</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>O</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> O(f) + O(g) = O(f)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span></span></span></span> if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>=</mo><mi>O</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">g = O(f)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span></span></span></span>) to make this less painful.</p>",
        "id": 397905948,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697950154
    },
    {
        "content": "<p>Certainly this looks much more feasible to implement than the \"full topos support\" idea.</p>",
        "id": 397906175,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697950330
    },
    {
        "content": "<p>I think that you probably don't actually want those <code>have</code> goals to be your real subgoals, there are some basic cleanups you can do like <code>intro f hf</code>, although the syntax does not give these variables names and maybe that's annoying when you are in the proof</p>",
        "id": 397906609,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697950811
    },
    {
        "content": "<p>Yeah, that would be nice.  Is it possible to perform string operations on variable names?  So one can just supply the prefixes <code>with f g</code> in the tactic and it will generate <code>f1, f2, f3, ...</code> for the input functions and <code>g1, g2, g3, ...</code> for the output functions as necessary</p>",
        "id": 397906797,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697950985
    },
    {
        "content": "<p>alternatively, you can try to pack these expressions up into a definition, i.e. some variant on <code>IsLittleO</code> that better matches the form of the subgoals, but I am not sure it will be easy to do \"rewriting\" proofs, at least not without hiding the quantifiers first</p>",
        "id": 397906818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697950998
    },
    {
        "content": "<p>It's possible to do any kind of variable naming one prefers here, but it is considered \"good style\" to not invent names that the user didn't write (or if so, not to let the user reference them directly)</p>",
        "id": 397906908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697951065
    },
    {
        "content": "<p>Even just implementing <code>calc_asymp</code> along the lines you suggest would eliminate about half of the quantifier management because your <code>combine</code> tactic is doing some, though not all, of the heavy lifting.  It would certainly be better than nothing, and also lets one impose a conceptual high level strategy on the proof.</p>",
        "id": 397906912,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697951071
    },
    {
        "content": "<p>Besides the basic \"code hygiene\" reasons, a more immediate advantage of having the user write down variable names is that you can put type hovers and go-to-declaration sites on those variable identifiers</p>",
        "id": 397906965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697951123
    },
    {
        "content": "<p>Maybe the user provided labels <code>with f hf g hg</code> could be functions from <code>Fin a</code> and <code>Fin b</code> to the various functions and hypotheses, where <code>a</code> is the number of O() type objects on the LHS and <code>b</code> is the number of O() type objects on the RHS?  So one has to use <code>f 0</code> to refer to the first function, etc..</p>",
        "id": 397907139,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697951253
    },
    {
        "content": "<p>would it be too weird to try to stick a variable name on the <code>O(_)</code> expression? like <code>(f := O(_))</code> or something</p>",
        "id": 397907219,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697951312
    },
    {
        "content": "<p>Though <code>f 0</code>, <code>f 1</code>, etc., could all have slightly different types, I don't know if that would be a problem with the dependent type syntax</p>",
        "id": 397907232,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697951333
    },
    {
        "content": "<p>it would probably not result in clear goals</p>",
        "id": 397907250,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697951357
    },
    {
        "content": "<p>besides, numbers are not generally the easiest way for humans to understand variable names</p>",
        "id": 397907270,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697951396
    },
    {
        "content": "<p>these are sort of \"nonce\" functions, like <code>this</code> - intended for very temporary use only</p>",
        "id": 397907345,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697951426
    },
    {
        "content": "<p>If the <code>:= _</code> proofs are done by a rewriting style, it may be possible that you actually never even introduce them</p>",
        "id": 397907396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697951462
    },
    {
        "content": "<p>like you apply a lemma saying <code>1 + O(n) = O(n)</code> and all the quantifier handling is inside the lemma</p>",
        "id": 397907437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697951489
    },
    {
        "content": "<p>in which case maybe <code>intro f hf</code> is not a good preprocessing step</p>",
        "id": 397907532,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697951532
    },
    {
        "content": "<p>That would be desirable, though presumably the additional tools one would develop to rewrite O() type expressions would unpack the O() notation within the proof of the tool, but in a way that is invisible to the end user</p>",
        "id": 397907543,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697951543
    },
    {
        "content": "<p>Right, the question here is about what goals the user sees</p>",
        "id": 397907575,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697951566
    },
    {
        "content": "<p>we can make <code>combine</code> do pretty much anything as long as there are lemmas justifying it (what I have here is really just some basic transitivity and exists/forall matching so not hard)</p>",
        "id": 397907607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697951622
    },
    {
        "content": "<p>It's also possible they don't actually see a subgoal exactly, but rather there is another DSL for describing the proofs of these subgoals with customized versions of <code>rw</code> et al. That would be more complex though</p>",
        "id": 397907682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697951700
    },
    {
        "content": "<p>So one could imagine a two-stage deployment where first one implements a bare-bones calc_asymp tactic in which each step still requires quantifier management (but perhaps presented in a form in which the quantifiers are hidden from view even in the tactic goal state by some well chosen definitions), and later introduce rewriting tactics that can manipulate these steps in a way that hides the quantifiers from view completely.</p>",
        "id": 397907726,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697951738
    },
    {
        "content": "<p>One thing I like about your approach is that we don't have to manually re-interpret every operation (e.g., <code>exp</code>) and every type (natural numbers, real numbers, complex numbers, etc.) into the asymptotic framework - it looks like the tool should be able to interpret everything automatically (of course assuming the types have whatever structures are needed to define asymptotic notation).</p>",
        "id": 397908093,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697952144
    },
    {
        "content": "<p>Anyway, I would be interested in discussing this further (in particular in trying to work out a precise spec), though perhaps we should first see if anybody else would be interested in having such a tool besides myself.</p>",
        "id": 397908347,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697952312
    },
    {
        "content": "<p>Even if it's just for you I think we could probably find someone to work on it. We're really happy to have you here! But it's true that if other people also want this it might help round out the spec a bit and make sure it's not over-indexed on one particular use case (already above there was some stuff about probabilistic topoi and such, it's unclear whether this would or should cover those examples)</p>",
        "id": 397909760,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697952892
    },
    {
        "content": "<p>(To that end, it would be helpful to get some <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> here from others on whether they would use this tactic and/or would want it to do other things.)</p>",
        "id": 397910012,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697952996
    },
    {
        "content": "<p>I think people who reason with random variables (for instance) don't really need custom <code>calc</code> blocks.  I could imagine some feature requests there regarding \"base change\" operations where at some intermediate stage of the argument one flips some more coins and thus enlarges the ambient probability space, and has to drag all the previously established results about existing deterministic and random variables to this larger space, but that's a feature request for a different time.  <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 397910850,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697953397
    },
    {
        "content": "<p>There are a small number of other places in mathematics where non-deterministic notation like O() is used.  For instance the quadratic formula <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>=</mo><mfrac><mrow><mo>−</mo><mi>b</mi><mo>±</mo><msqrt><mrow><msup><mi>b</mi><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mi>c</mi></mrow></msqrt></mrow><mrow><mn>2</mn><mi>a</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">x = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.3845em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0395em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">a</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathnormal mtight\">b</span><span class=\"mbin mtight\">±</span><span class=\"mord sqrt mtight\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9221em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mtight\" style=\"padding-left:0.833em;\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7463em;\"><span style=\"top:-2.786em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">4</span><span class=\"mord mathnormal mtight\">a</span><span class=\"mord mathnormal mtight\">c</span></span></span><span style=\"top:-2.8821em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail mtight\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1179em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> has the indeterminate sign <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>±</mo></mrow><annotation encoding=\"application/x-tex\">\\pm</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">±</span></span></span></span>.  But again, it's rare that such indeterminate expressions are manipulated in large <code>calc</code> type blocks, they are usually isolated and so can be easily managed with standard quantifiers.</p>",
        "id": 397911052,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697953582
    },
    {
        "content": "<p>When manipulating formal power series one does sometimes see <code>calc</code> type blocks involving things like</p>\n<blockquote>\n<p>\\exp(f(x)) = \\exp( 1 + c_1 x + c_2 x^2 + &lt;higher order terms&gt; )<br>\n= 1 + c_1 x + (c_2 + c_1^2/2) x^2 + &lt;higher order terms&gt;</p>\n</blockquote>\n<p>in which one doesn't want to keep explicit track of all the higher order terms, but this can probably be dealt with either by some minor variant of the O() formalism, or else by quotienting out by a suitable ideal of higher order terms.   One could imagine having a narrow tool to begin with and generalizing/abstracting it later if other use cases show up.</p>",
        "id": 397911481,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697953997
    },
    {
        "content": "<p>I always interpreted <code>&lt;higher order terms&gt;</code> there as shorthand for <code>O(x^3)</code> (or possibly <code>o(x^2)</code> for the really weird stuff)</p>",
        "id": 397911640,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697954131
    },
    {
        "content": "<p>I would not usually use a notation like that unless I was actually doing a proof sketch (e.g. in a lecture), it seems like bad form for an actual proof</p>",
        "id": 397911711,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697954174
    },
    {
        "content": "<p>Yeah usually that's the case, though formal power series don't come with a norm and so strictly speaking it isn't O() notation as defined for instance in Mathlib.</p>",
        "id": 397911787,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697954250
    },
    {
        "content": "<p>I wouldn't consider it a use case that necessitates a major departure from the current Lean suite of tactics and tools.  (Many such manipulations in formal power series can be dealt with by existing algebraic tools for graded algebras, in particular quotient homomorphisms.  Analysis by contrast can't easily do things like \"quotient out by all negligible errors\" [unless one works in nonstandard analysis, or takes an asymptotic limit] and this is one reason why we rely so much on asymptotic notation instead.)</p>",
        "id": 397911857,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697954292
    },
    {
        "content": "<p>Actually there is another place where indeterminate constants show up in math - ODE, starting with the infamous <code>+C</code> in the fundamental theorem of calculus, thus for instance <code>deriv deriv f = fun x \\to x \\imp deriv f = fun x \\to x^2/2 + C \\imp f = fun x \\to x^3/6 + C x + D</code>.  But again, these constants aren't so numerous and interact with each other so much that a dedicated calc block is really needed; one can simply introduce each constant in turn with an appropriate existential quantifier, opened by an <code>rcases</code> as necessary.</p>",
        "id": 397951018,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697987349
    },
    {
        "content": "<p>This is something I'd also find very valuable, it's showed up for me in the <a href=\"https://b-mehta.github.io/unit-fractions/\">unit-fractions</a> project, in which many statements involved big-O (especially the analytic number theory estimates), in my work on Roth's theorem and its more recent stuff in the <a href=\"https://github.com/YaelDillies/LeanAPAP\">Kelley-Meka bound</a>, and again in my current project. My original approach for dealing with these was to make the big O constant explicit and unfold the definition of little o in each statement, but for more complicated expressions this is unsurprisingly not a great idea, so what I do now is say things like \"there exists a function g which is O(1/n), and for all n, f(n) = (1 + g(n)) h(n)\", where f and h would be explicit. Having a more convenient notation for writing this (and working with it) would be very useful</p>",
        "id": 397951427,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1697987688
    },
    {
        "content": "<p>Another thing which would be useful, and importantly distinct, would be automation to show certain things are big/little-O of each other. I found myself proving stuff like n^(1/2) log(n) is o(n) quite a few times, and <span class=\"user-mention\" data-user-id=\"458865\">@Thomas Bloom</span> cited this kind of proof as the most annoying part of our formalisation of his paper as well.</p>",
        "id": 397951577,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1697987798
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Working.20with.20big-O.20notation.20like.20an.20analyst/near/397951577\">said</a>:</p>\n<blockquote>\n<p>Another thing which would be useful, and importantly distinct, would be automation to show certain things are big/little-O of each other. I found myself proving stuff like n^(1/2) log(n) is o(n) quite a few times, and <span class=\"user-mention silent\" data-user-id=\"458865\">Thomas Bloom</span> cited this kind of proof as the most annoying part of our formalisation of his paper as well.</p>\n</blockquote>\n<p>I believe Manuel Eberl wrote such tactics for Isabelle as part of his PhD thesis, it would be worth a look to see if we could import this into Lean.</p>",
        "id": 397951693,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1697987884
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311453\">Frédéric Dupuis</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Working.20with.20big-O.20notation.20like.20an.20analyst/near/397951693\">said</a>:</p>\n<blockquote>\n<p>I believe Manuel Eberl wrote such tactics for Isabelle as part of his PhD thesis, it would be worth a look to see if we could import this into Lean.</p>\n</blockquote>\n<p>Definitely, I had a brief look at this a while ago and I believe they weren't quite strong enough to do the cases we needed, but it'd still be better than nothing! A particular example is in Appendix B2 here: <a href=\"https://arxiv.org/abs/2112.03726\">https://arxiv.org/abs/2112.03726</a></p>",
        "id": 397951735,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1697987921
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Working.20with.20big-O.20notation.20like.20an.20analyst/near/397951577\">said</a>:</p>\n<blockquote>\n<p>Another thing which would be useful, and importantly distinct, would be automation to show certain things are big/little-O of each other. I found myself proving stuff like n^(1/2) log(n) is o(n) quite a few times, and <span class=\"user-mention silent\" data-user-id=\"458865\">Thomas Bloom</span> cited this kind of proof as the most annoying part of our formalisation of his paper as well.</p>\n</blockquote>\n<p>I can envision eventually having four types of asymptotic notation support that would complement each other very well:</p>\n<ul>\n<li>A <code>calc_asymp</code> tactic as discussed above</li>\n<li>A <code>rw_asymp</code> tactic that can take asymptotic assertions such as <code>O(n ^ 2) + O(n) = O(n^2)</code> (which is some syntactic sugar for a lengthier thing involving quantification on various functions f(n), g(n), h(n)) and use them to rewrite expressions such as <code>X = Y + O(n ^ 2) + O(n)</code>.  [A key difference with <code>rw</code>: <code>rw_asymp</code> should only be able to affect the right-hand side of an asymptotic expression, not the left-hand side, and one is not able to apply a reverse rewrite <code>rw_asymp [&lt;- h]</code>.  This is due to the non-symmetric nature of asymptotic equality.]</li>\n<li>A library of basic theorems providing such assertions to feed into <code>rw_asymp</code>, like we have right now for the elementary arithmetic operations </li>\n<li>A <code>asymp_simp</code> tactic that can use these theorems iteratively to simplify a complex asymptotic assertion.</li>\n</ul>\n<p>But the first task seems to be the simplest and most feasible to write, and would already help out somewhat, so maybe one should start there.</p>",
        "id": 397952611,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697988598
    },
    {
        "content": "<p>Perhaps in order to support all of these tasks we need some new data structures.  I'm thinking of a data structure, call it say <code>AsympProp</code>, an instance <code>A : AsympProp</code> of which contains the following data:</p>\n<ul>\n<li>A filter <code>A.filter</code></li>\n<li>A string for the ambient parameter <code>A.parameter_name</code></li>\n<li>A string <code>A.proposition_string</code> for the proposition it is trying to encode</li>\n</ul>\n<p>and then a method <code>A.prop</code> that generates a <code>Prop</code>  that interprets <code>A.proposition_string</code> asymptotically using <code>A.filter</code> and <code>A.parameter_name</code> (it may also need to take as input some portion of the ambient tactic state).  For instance if <code>A.filter = l</code> for some filter <code>l</code>, <code>A.parameter_name = \"n\"</code>, and <code>A.proposition_string = \"O(n^2)+O(n)=1+O(n^3)\"</code>, then <code>A.prop</code> would be something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"n\">f1</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">f2</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">g1</span> <span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span><span class=\"bp\">^</span><span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n       <span class=\"bp\">∀ᶠ</span> <span class=\"n\">n</span> <span class=\"k\">in</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">f1</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">f2</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">g1</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and then all the tools mentioned above would reference this data structure.  [I guess if <code>A.proposition_string</code> could not be interpreted unambiguously, then <code>A.prop</code> should default to <code>False</code>.]</p>\n<p>One problem I see with this approach though is that often the interpretation of a proposition string would depend on the current tactic state, in particular what types are being assigned to various names that appear in the string.  So one may have to do this at a more \"meta\" level (I saw macros mentioned previously, perhaps those are expressive enough to implement this sort of functionality?).  Or maybe the data type doesn't statically remember the filter, parameter name, and proposition string, but only the final proposition, with some tool to then convert it back into an asymptotic form as needed for asymptotic rewrites etc.</p>",
        "id": 397955299,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697991228
    },
    {
        "content": "<p>Note that <code>rw_asymp</code> is a special case of \"generalised rewrite\" which allows one to rewrite not only by equality but also by any relation that is preserved by the current context. The typical example being that when proving <code>a * b * c * d * e ≤ a * b' * c * d * e</code> from <code>b ≤ b'</code> (and the relevant positivity assumptions), one does not reason \"<code>b ≤ b'</code>, so <code>a * b ≤ a * b'</code>, so <code>a * b * c ≤ a * b' * c</code>, so <code>a * b * c * d ≤ a * b' * c * d</code>, so <code>a * b * c * d * e ≤ a * b' * c * d * e</code>\" but rather \"I can substitute <code>b</code> with <code>b'</code> because the surrounding expression is monotone in the occurrence of <code>b</code> I want to replace\".</p>",
        "id": 397955559,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1697991525
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Working.20with.20big-O.20notation.20like.20an.20analyst/near/397955559\">said</a>:</p>\n<blockquote>\n<p>Note that <code>rw_asymp</code> is a special case of \"generalised rewrite\" which allows one to rewrite not only by equality but also by any relation that is preserved by the current context. The typical example being that when proving <code>a * b * c * d * e ≤ a * b' * c * d * e</code> from <code>b ≤ b'</code> (and the relevant positivity assumptions), one does not reason \"<code>b ≤ b'</code>, so <code>a * b ≤ a * b'</code>, so <code>a * b * c ≤ a * b' * c</code>, so <code>a * b * c * d ≤ a * b' * c * d</code>, so <code>a * b * c * d * e ≤ a * b' * c * d * e</code>\" but rather \"I can substitute <code>b</code> with <code>b'</code> because the surrounding expression is monotone in the occurrence of <code>b</code> I want to replace\".</p>\n</blockquote>\n<p>Morally I agree, but there is the wrinkle that an asymptotic expression such as <code>O(n^2)+O(n) = 1 + O(n^3)</code> cannot be interpreted directly as a type built up recursively from simpler types like <code>O(n^2)</code> and <code>O(n^3)</code>, but has to be converted via some meta syntactic sugar to the lengthier expression I described above involving several quantifiers before a rewrite can be applied.   I guess the question is whether a rewrite tactic can work with this sugar.</p>",
        "id": 397955875,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697991924
    },
    {
        "content": "<p>... actually, one could interpret big-O notation as describing a type directly, namely a subtype of functions from the parameter space to some normed space, in which case expressions such as <code>O(n^2)+O(n) = 1 + O(n^3)</code> can be interpreted as a recursively defined type (bearing in mind that <code>=</code> is now something closer to the subset/subtype relation).  So then maybe all one needs is a tool that shows that proposition is logically equivalent to a proposition that is the big mess of quantifiers as described above, and that way one could have the best of both worlds, interpreting O() notation as a first-class object while also being able to manipulate it with existing tools.</p>",
        "id": 397956599,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697992368
    },
    {
        "content": "<p>I remember discussing this with Thomas and <span class=\"user-mention\" data-user-id=\"252920\">@Alex Kontorovich</span> a while ago as well, I think we came to the same conclusion as this</p>",
        "id": 397956853,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1697992466
    },
    {
        "content": "<p>One nice thing about this approach is that it isn't specific to O() notation, it covers all types of indeterminate expressions that depend on parameters in a partially specified fashion.  O() and o() are still the biggest use cases, but the same framework could conceivably be used for other types of mathematics.</p>\n<p>The one \"meta\" thing one would still need to do with this approach is find some way to automatically extend operators and relations from the deterministic setting to the indeterminate setting.  For instance, the power operation <code>^</code> is defined on the reals,  so it would be nice to automatically have an operation on this indeterminate real type that makes expressions such as <code>O(n)^O(n)</code> well-defined without having to make an explicit definition for every single conceivable operation one would want to use.</p>",
        "id": 397957916,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697992738
    },
    {
        "content": "<p>With this approach one could basically use the existing <code>calc</code> tactic (possibly one has to replace the equality symbol by something else if equality is reserved for symmetric operations), and not need a separate <code>calc_asymp</code> variant.  Instead one would have another tactic, say <code>asymp_quantify</code>, which would replace a hypothesis or goal that involves O() types with their counterparts involving quantifiers, and one has the option at each calc step either of using this tactic to expand things out into quantifiers and work by hand, or else use some future tools to manipulate the asymptotic quantities directly.  (The type for asymptotic notation may need to remember a little bit more than just the subtype of functions it represents in order to make <code>asymp_quantify</code> well defined, though, i.e., it might not be 100% extensional.)</p>",
        "id": 397958441,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697993073
    },
    {
        "content": "<p>Note that, if <code>O f</code> designated the subset of functions that are O of f (there would have to be a filter in the notation too of course), then you could already <em>litteraly</em> write <code>O (id ^ 2) + O id ⊆ 1 + O (id ^ 3)</code>. Of course for more complicated expressions you'd need to write images, but I think the most reasonable approach is simply to add syntactic sugar and maybe some tactics for manipulating these inclusions.</p>",
        "id": 397958680,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1697993320
    },
    {
        "content": "<p>That ... actually looks like a workable solution to me</p>",
        "id": 397959021,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697993692
    },
    {
        "content": "<p>There is some casting issue in which one should identify a deterministic function <code>f</code> with its singleton subset <code>{f}</code> in order to interpret expressions such as <code>n^2 + n = 1 + O(n^3)</code> on equal footing with <code>O(n^2) + O(n) = 1 + O(n^3)</code> or <code>n^2 + n = n + n^2</code> but presumably the sugar can handle all of this.</p>",
        "id": 397959150,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697993853
    },
    {
        "content": "<p>The solution for emulating \"ambient parameters\" (I wouldn't like it personally, but that's mostly because I avoid computations in the first place) is really simple : you could just start a proof by <code>let Ω := ℕ × ℝ; let n : Ω → ℕ := Prod.fst, let x : Ω → ℝ := Prod.snd</code> and basically you can treat them as your ambiant variables. Of course that could be a one-line <code>declare_vars</code> or whatever. The main issue is that you'd have to write a lot of compositions, but this is again mostly a matter of notations.</p>\n<p>All of this is not to minimize the task (we still have to figure out clever notations), but I believe that we probably don't need some kind of extra-powered tactic mode keeping in mind a lot of things for us, because what we want to write isn't actually that far from what's happening mathematically.</p>",
        "id": 397959469,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1697994145
    },
    {
        "content": "<p>That's a workable solution in many contexts, particularly when the collection of ambient parameters can be set in advance.  The one task that remains a bit tricky with that formalism is \"base change\", when you want to change the ambient parameters.  For instance, if you know that a family <code>F</code> of functions on <code>ℝ</code> are equicontinuous, then you can choose your parameter space <code>Ω</code> to be <code>F × ℝ × ℝ</code> with coordinate functions <code>f</code>, <code>x</code>, <code>x0</code> and write equicontinuity in asymptotic form as <code>f x = f x0 + o(1)</code> where the filter is the one where <code>x</code> converges to <code>x0</code> while allowing <code>f</code> to vary freely.  (Other notions of continuity, such as uniform continuity or uniform equicontinuity, would correspond to other filters.)  But then suppose you want to combine this equicontinuity with some continuity property of some other function that uses a different parameter space <code>Ω'</code>.  Then often what you want to do is pass to a larger parameter space such as <code>Ω × Ω'</code> and lift up all the previous asymptotic results to this larger space.  This can in principle be done by hand, but potentially one could benefit from some well designed tactics to automate this.</p>",
        "id": 397961875,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697997069
    },
    {
        "content": "<p>Mathematically this should follow rather easily from our extensive API to manipulate filters (pullbacks, pushforwards, lattice structure), and lemmas such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Asymptotics.IsLittleO.mono#doc\">docs#Asymptotics.IsLittleO.mono</a>. But I don’t have enough examples of that in mind to be able to imagine how easy it would be to do by hand, or what would be needed to make it easier.</p>",
        "id": 397963323,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1697998859
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> I agree that being able to write <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mo>⋯</mo><mtext> </mtext><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\cdots)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mclose\">)</span></span></span></span> everywhere like we do on paper would be nice. However I think that we can already go a long way with the ternary relation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>=</mo><mi>g</mi><mo>+</mo><mi>O</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f = g + O(h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">h</span><span class=\"mclose\">)</span></span></span></span> and a good set of lemmas (we would say \"a good API\" in the software engineering jargon). Such lemmas would be needed anyway to power the fancier version you dream of. Mathlib currently only has the binary relation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>=</mo><mi>O</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f = O(h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">h</span><span class=\"mclose\">)</span></span></span></span>, but building the ternary one is straightforward. We also lack many elementary comparison lemmas because Mathlib is very weak on examples and concrete lemmas. Today I wrote <a href=\"https://gist.github.com/PatrickMassot/9619c317cd99bf9ea30696e48a5d9ac2\">https://gist.github.com/PatrickMassot/9619c317cd99bf9ea30696e48a5d9ac2</a> which starts with a bunch of elementary estimates that should go to Mathlib soon, then build the basic ternary BigO API and ends with your example with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><msup><mo stretchy=\"false\">)</mo><msup><mi>e</mi><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>n</mi></mrow></msup></msup></mrow><annotation encoding=\"application/x-tex\">(n+1)^{e^{1/n}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2897em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0397em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9667em;\"><span style=\"top:-2.9667em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5357em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1/</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>. You can drop this file into your project and have look, starting from Line 307.</p>",
        "id": 398195636,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698118192
    },
    {
        "content": "<p>Let me insist that the purpose of the above message is <em>not</em> to tell you what to do on paper, or even what to do in Lean. However notice there is no existential quantifier juggling in the above file, and no sequence of constant that you would need to track. So the worry you expressed in the first message of this thread is avoidable without new fancy tactics. What is still true is that things would be simpler with a moderately fancy tactic proving basic estimates that occur as side-conditions (there are comments about that in my file).</p>",
        "id": 398196131,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698118430
    },
    {
        "content": "<p>This looks like a workable solution for many basic use cases.  I might try to incorporate some of the tools here into my project, thanks.</p>",
        "id": 398197478,
        "sender_full_name": "Terence Tao",
        "timestamp": 1698119055
    },
    {
        "content": "<p>I forgot to say that some proofs in the first part of the file were written or improved by <span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span>, <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> and <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> when I shared my frustration of not finding those estimates in Mathlib.</p>",
        "id": 398200301,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698120559
    },
    {
        "content": "<p>How hard would it be to implement a tactic that goes from the inside of a formula, applies existing knowledge about terms and functions and gets an estimate on the whole formula?</p>",
        "id": 398204270,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1698123445
    },
    {
        "content": "<p>Something like what <code>positivity</code> does for <code>0 &lt; _</code>/<code>_ ≠ 0</code>.</p>",
        "id": 398204281,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1698123467
    },
    {
        "content": "<p>(clearly, we'll need more lemmas)</p>",
        "id": 398204336,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1698123493
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> What are you formalizing?</p>",
        "id": 398204350,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1698123514
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Working.20with.20big-O.20notation.20like.20an.20analyst/near/398204350\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> What are you formalizing?</p>\n</blockquote>\n<p><a href=\"https://arxiv.org/pdf/2310.05328.pdf\">https://arxiv.org/pdf/2310.05328.pdf</a> , at <a href=\"https://github.com/teorth/symmetric_project\">https://github.com/teorth/symmetric_project</a></p>",
        "id": 398204400,
        "sender_full_name": "Terence Tao",
        "timestamp": 1698123572
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Working.20with.20big-O.20notation.20like.20an.20analyst/near/398204400\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Working.20with.20big-O.20notation.20like.20an.20analyst/near/398204350\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> What are you formalizing?</p>\n</blockquote>\n<p><a href=\"https://arxiv.org/pdf/2310.05328.pdf\">https://arxiv.org/pdf/2310.05328.pdf</a> , at <a href=\"https://github.com/teorth/symmetric_project\">https://github.com/teorth/symmetric_project</a></p>\n</blockquote>\n<p>The <a href=\"https://github.com/teorth/symmetric_project/commit/05af1007594e5cfd48bc591e8e37ac481e7157ac\">last commit</a> is already a success story! (I just read the log message.)</p>",
        "id": 398277145,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1698149860
    },
    {
        "content": "<p>There is more detail at: <a href=\"https://mathstodon.xyz/@tao/111287749336059662\">https://mathstodon.xyz/@tao/111287749336059662</a>. Short version: there was an edge-case mistake in the paper that was found during formalization. Interestingly it seems the error was really detected when Lean asked to prove something that clearly didn't follow from the current assumptions (as opposed to detecting it while writing a more detailed version on paper before using Lean).</p>",
        "id": 398296648,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698156387
    },
    {
        "content": "<p>I'm going to give a talk about Lean at a dynamics conference in about a month. May I use this blog post as an example of \"why should we care about formal math\"?</p>",
        "id": 398368015,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1698185628
    },
    {
        "content": "<p>Yury, you should be careful when discussing this example. This is really a rather minor mistake which impacts only a rather non-interesting case of the theorem (low value of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>). More importantly, fixing this mistake brings no new insight about why the theorem is true.</p>",
        "id": 398368363,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698185853
    },
    {
        "content": "<p>Then I won't discuss it.</p>",
        "id": 398379021,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1698193285
    },
    {
        "content": "<p>(I know that it's hard for me to be careful about such things; that's why I asked)</p>",
        "id": 398379098,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1698193327
    },
    {
        "content": "<p>I'm still happy that Lean has been useful to Terry. One thing you can do if you want to be safe is to simply quote him, and avoid adding too many comments.</p>",
        "id": 398379773,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698193789
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Working.20with.20big-O.20notation.20like.20an.20analyst/near/398195636\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> I agree that being able to write <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mo>⋯</mo><mtext> </mtext><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\cdots)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mclose\">)</span></span></span></span> everywhere like we do on paper would be nice. However I think that we can already go a long way with the ternary relation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>=</mo><mi>g</mi><mo>+</mo><mi>O</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f = g + O(h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">h</span><span class=\"mclose\">)</span></span></span></span> and a good set of lemmas (we would say \"a good API\" in the software engineering jargon). Such lemmas would be needed anyway to power the fancier version you dream of. Mathlib currently only has the binary relation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>=</mo><mi>O</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f = O(h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">h</span><span class=\"mclose\">)</span></span></span></span>, but building the ternary one is straightforward. We also lack many elementary comparison lemmas because Mathlib is very weak on examples and concrete lemmas. Today I wrote <a href=\"https://gist.github.com/PatrickMassot/9619c317cd99bf9ea30696e48a5d9ac2\">https://gist.github.com/PatrickMassot/9619c317cd99bf9ea30696e48a5d9ac2</a> which starts with a bunch of elementary estimates that should go to Mathlib soon, then build the basic ternary BigO API and ends with your example with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><msup><mo stretchy=\"false\">)</mo><msup><mi>e</mi><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>n</mi></mrow></msup></msup></mrow><annotation encoding=\"application/x-tex\">(n+1)^{e^{1/n}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2897em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0397em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9667em;\"><span style=\"top:-2.9667em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5357em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1/</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>. You can drop this file into your project and have look, starting from Line 307.</p>\n</blockquote>\n<p>I'm now hitting the part of my formalization project where I actually would like to have O() notation, and I realize that I would really like support for using big-O notation while breaking into cases.  For instance, I might want to show that <code>F =O[l] G</code>, where <code>F</code>, <code>G</code> depend on two parameters <code>n k</code>, and I have one argument that works when <code>n ≤ k</code>, and another when <code>n &gt; k</code>, then I want to combine them.  With explicit quantifiers I can do it like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">10</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">k</span>  <span class=\"c1\">-- toy example only</span>\n<span class=\"kd\">def</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">n</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">k</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"c1\">-- toy example only</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">est1</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span> <span class=\"c1\">-- argue that 10 * n * k ≤  10 * k^2 ≤ 10 * (n^2 + k^2)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">est2</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span> <span class=\"c1\">-- argue that 10 * n * k &lt; 10 * n^2 ≤ 10 * (n^2 + k^2)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">est1</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span> <span class=\"n\">C1</span><span class=\"o\">,</span> <span class=\"n\">h1</span> <span class=\"o\">⟩</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">est2</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span> <span class=\"n\">C2</span><span class=\"o\">,</span> <span class=\"n\">h2</span> <span class=\"o\">⟩</span>\n  <span class=\"n\">use</span> <span class=\"n\">max</span> <span class=\"n\">C1</span> <span class=\"n\">C2</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span> <span class=\"n\">k</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">le_or_gt</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"bp\">|</span> <span class=\"n\">h</span>\n  <span class=\"bp\">.</span> <span class=\"n\">apply</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n    <span class=\"n\">gcongr</span>\n    <span class=\"n\">simp</span>\n  <span class=\"bp\">.</span> <span class=\"n\">apply</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n    <span class=\"n\">gcongr</span>\n    <span class=\"n\">simp</span>\n</code></pre></div>\n<p>What would be a civilized approach to doing it in Lean using O() notation?</p>",
        "id": 398518511,
        "sender_full_name": "Terence Tao",
        "timestamp": 1698249781
    },
    {
        "content": "<p>The <code>max</code> reasoning should be expressible using filters: for all sufficiently large <code>C</code> <code>est1</code> holds, and also <code>est2</code> holds, so they both hold</p>",
        "id": 398526345,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698252615
    },
    {
        "content": "<p>I'm not sure I understand your goal, do you need your estimates to hold everywhere or just for <code>(n, k)</code> large enough? If the former, then I'm not sure <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsBigO#doc\">docs#IsBigO</a> is that useful (but it should definitely work, see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Asymptotics.isBigO_top#doc\">docs#Asymptotics.isBigO_top</a> ).</p>",
        "id": 398527566,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1698253077
    },
    {
        "content": "<p>Terry, are you familiar yet with the <code>filter_upwards</code> tactic? This is an essential tactic for working with filters. (although maybe you don't need it here)</p>",
        "id": 398527680,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698253123
    },
    {
        "content": "<p>I don't think using filters on the constants is the right solution here, the API for <code>IsBigO</code> should allow you not to care about this. Instead I would suggest using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Asymptotics.isBigO_sup#doc\">docs#Asymptotics.isBigO_sup</a> to \"split\" your filter in two parts. I'll do an example to show what it would look like.</p>",
        "id": 398528037,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1698253250
    },
    {
        "content": "<p>(Side note: maybe a lot of the API could be golfed if we add a characterization of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsBigO#doc\">docs#IsBigO</a> with an <code>eventually</code> instead of an <code>exists</code> for the constant. But that should not be relevant here imo)</p>",
        "id": 398528236,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1698253308
    },
    {
        "content": "<p>Do we really have no norm on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> ?!?</p>",
        "id": 398528932,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1698253533
    },
    {
        "content": "<p>Why would we? You don't get any of the nice structure (from mathlib) since it isn't an additive group.</p>",
        "id": 398529046,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698253570
    },
    {
        "content": "<p>Well for being able to use asymptotics...</p>",
        "id": 398529078,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1698253586
    },
    {
        "content": "<p>Okay but it would be useless, like in <code>NNReal</code>. Forget my comment. But we need to fix that at some point (e.g assuming only <code>BoundedSMul</code> for asymptotics)</p>",
        "id": 398529190,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1698253633
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> had a plan, or at least ideas, for that at some point recently.</p>",
        "id": 398529299,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698253679
    },
    {
        "content": "<p>Here's a version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Filter</span> <span class=\"n\">Asymptotics</span> <span class=\"n\">Set</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">10</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">k</span>  <span class=\"c1\">-- toy example only</span>\n<span class=\"kd\">def</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">k</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"c1\">-- toy example only</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">est1</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span> <span class=\"c1\">-- argue that 10 * n * k ≤  10 * k^2 ≤ 10 * (n^2 + k^2)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">est2</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span> <span class=\"c1\">-- argue that 10 * n * k &lt; 10 * n^2 ≤ 10 * (n^2 + k^2)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">est1'</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"bp\">↿</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"bp\">𝓟</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">x.1</span> <span class=\"bp\">≤</span> <span class=\"n\">x.2</span><span class=\"o\">}]</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"bp\">↿</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">est1</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">hC</span><span class=\"o\">⟩</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">isBigO_principal</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">exact_mod_cast</span> <span class=\"n\">hC</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">est2'</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"bp\">↿</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"bp\">𝓟</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">x.1</span> <span class=\"bp\">&gt;</span> <span class=\"n\">x.2</span><span class=\"o\">}]</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"bp\">↿</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">est2</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">hC</span><span class=\"o\">⟩</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">isBigO_principal</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">exact_mod_cast</span> <span class=\"n\">hC</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"bp\">↿</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"bp\">⊤</span><span class=\"o\">]</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"bp\">↿</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">convert</span> <span class=\"n\">est1'.sup</span> <span class=\"n\">est2'</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">principal_univ</span><span class=\"o\">,</span> <span class=\"n\">sup_principal</span><span class=\"o\">,</span> <span class=\"n\">principal_eq_iff_eq</span><span class=\"o\">,</span> <span class=\"n\">eq_comm</span><span class=\"o\">,</span> <span class=\"n\">eq_univ_iff_forall</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">le_or_gt</span> <span class=\"n\">x.1</span> <span class=\"n\">x.2</span>\n</code></pre></div>\n<p>I'm not sure it's the cleanest option we have, and I'm sure someone else will think of a way to make it look like what we'd write on paper, but it has the advantage that it would work basically the same in more complicated settings (e.g if there is actually a limiting process).</p>",
        "id": 398531941,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1698254779
    },
    {
        "content": "<p><code>↿F</code> means \"<code>F</code> to which we feed both arguments at the same time\". You could also write <code>uncurry F</code>. The whole <code>((↑) ∘ ↿F : ℕ × ℕ → ℤ)</code> should just be <code>↿F</code>, but as mentioned above we currently need additive <em>groups</em> to work with asymptotics, so I'm moving everything to <code>ℤ</code>.</p>",
        "id": 398532258,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1698254910
    },
    {
        "content": "<p>I you need this a lot in cases where all filters are principals then it may be simpler to duplicate the BigO API. But maybe good notations and <code>simp</code> lemmas would be enough.</p>",
        "id": 398532938,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698255228
    },
    {
        "content": "<p>In Anatole's example, we can see we are going against the library because <code>principal_univ</code> is a simp lemma going in the wrong direction for our purposes.</p>",
        "id": 398533735,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698255601
    },
    {
        "content": "<p>The proof could be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">convert</span> <span class=\"n\">est1'.sup</span> <span class=\"n\">est2'</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">principal_univ</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">principal_univ</span><span class=\"o\">]</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">exact</span><span class=\"bp\">?</span>\n</code></pre></div>\n<p>which is rewriting using <code>prinipal_univ</code> backward and then excluding it from the <code>simp</code> call.</p>",
        "id": 398533859,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698255657
    },
    {
        "content": "<p>The goal after simp is <code>univ = {x | x.1 ≤ x.2} ∪ {x | x.2 &lt; x.1}</code> which means it is successfully translated to a problem involving Set only.</p>",
        "id": 398533927,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698255691
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Working.20with.20big-O.20notation.20like.20an.20analyst/near/398528932\">said</a>:</p>\n<blockquote>\n<p>Do we really have no norm on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> ?!?</p>\n</blockquote>\n<p>No because which prime <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> would you choose?</p>",
        "id": 398540872,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698258678
    },
    {
        "content": "<p>OK, I think I can sort of see how to reinterpret all these side conditions on parameters as modifications to the filter, and that in principle one can decouple the manipulation of the primary quantities <code>F</code> and <code>G</code> from manipulations of the filter.  My own project is small enough that it is close to the breakeven point where it would be quicker to just open and close the existential quantifiers at each step,  but I can believe that the filter-based approach will scale better, particularly with nice simp lemmas and syntactic sugar.</p>\n<p>Anyway, thanks for the sample code, I will have to study it more carefully when I have more time.</p>",
        "id": 398541089,
        "sender_full_name": "Terence Tao",
        "timestamp": 1698258762
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Working.20with.20big-O.20notation.20like.20an.20analyst/near/398540872\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Working.20with.20big-O.20notation.20like.20an.20analyst/near/398528932\">said</a>:</p>\n<blockquote>\n<p>Do we really have no norm on $\\mathbb{N}$ ?!?</p>\n</blockquote>\n<p>No because which prime $p$ would you choose?</p>\n</blockquote>\n<p>Well we already chose for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>…</p>",
        "id": 398542960,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1698259542
    },
    {
        "content": "<p>Regarding the asymptotic vs non-asymptotic issue.  For my application I would like an estimate that holds for all <code>n</code>, but a common technique is to first establish a result for sufficiently large <code>n</code>, and then treat the remaining bounded number of cases by an easier argument.  For instance, below is a sketch of a proof that <code>λ  n k, Nat.choose n k =O(⊤)  λ  n k,  (2:ℝ)^(n:ℝ) / (n+1 : ℝ)^((2:ℝ)⁻¹)</code> that proceeds by first establishing the claim asymptotically (using Stirling's formula), then treating the bounded cases by cruder methods.  As you can see, the proof I have in mind is quite lengthy, mostly due to all the opening and closing of existential quantifiers.  If there was some way to do this in a civilized fashion using =O[] notation that would be great.  <del>(Also, my proof that <code>n ≤ Nat.succ M → n ≤ M ∨ n = Nat.succ M</code> is embarrassingly long; would be happy to hear of a quicker way. I couldn't get <code>Order.le_succ_iff_eq_or_le</code> to work because lean would not recognize <code>Nat.succ</code> as an instance of <code>Order.succ</code>.)</del></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Nat.choose</span> <span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">((</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! the objective is to show that F(n,k) = O( G(n,k) ) for all n,k (not just asymptotically. )-/</span>\n\n<span class=\"sd\">/-- First, the asymptotic case --/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">est1</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">N</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>  <span class=\"c1\">-- use Stirling approximation</span>\n\n<span class=\"sd\">/-- Then, the base case n = 0 --/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">est2</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>  <span class=\"c1\">-- easy computation</span>\n\n<span class=\"sd\">/-- Then, the inductive case --/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">est3</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>  <span class=\"c1\">-- use Pascal identity</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">pos</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>  <span class=\"c1\">-- positivity</span>\n\n<span class=\"sd\">/-- Finally, the non-asymptotic case -/</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">N</span>\n    <span class=\"n\">induction'</span> <span class=\"n\">N</span> <span class=\"k\">with</span> <span class=\"n\">M</span> <span class=\"n\">hM</span>\n    <span class=\"bp\">.</span> <span class=\"n\">rcases</span> <span class=\"n\">est2</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span> <span class=\"n\">C2</span><span class=\"o\">,</span> <span class=\"n\">h2</span> <span class=\"o\">⟩</span>\n      <span class=\"n\">use</span> <span class=\"n\">C2</span>\n      <span class=\"n\">intro</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"n\">hn</span>\n      <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hn</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h2</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"n\">hn</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">hM</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span> <span class=\"n\">CM</span><span class=\"o\">,</span> <span class=\"n\">hCM</span> <span class=\"o\">⟩</span>\n    <span class=\"k\">have</span> <span class=\"n\">hCM'</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">M</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">M</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">use</span> <span class=\"n\">CM</span>\n      <span class=\"n\">intro</span> <span class=\"n\">k</span>\n      <span class=\"n\">exact</span> <span class=\"n\">hCM</span> <span class=\"n\">M</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">M</span> <span class=\"bp\">≤</span> <span class=\"n\">M</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">)</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">est3</span> <span class=\"n\">M</span> <span class=\"n\">hCM'</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span> <span class=\"n\">CMsucc</span><span class=\"o\">,</span> <span class=\"n\">hCMsucc</span> <span class=\"o\">⟩</span>\n    <span class=\"n\">use</span> <span class=\"n\">max</span> <span class=\"n\">CM</span> <span class=\"n\">CMsucc</span>\n    <span class=\"n\">intro</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"n\">hn</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">Nat.of_le_succ</span> <span class=\"n\">hn</span> <span class=\"k\">with</span> <span class=\"n\">hnM</span> <span class=\"bp\">|</span> <span class=\"n\">hnM</span>\n    <span class=\"bp\">.</span> <span class=\"n\">apply</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">hCM</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"n\">hnM</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n      <span class=\"n\">gcongr</span>\n      <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"n\">pos</span> <span class=\"n\">n</span> <span class=\"n\">k</span>\n      <span class=\"n\">simp</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hnM</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">hCMsucc</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n    <span class=\"n\">gcongr</span>\n    <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"n\">pos</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">k</span>\n    <span class=\"n\">simp</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">est1</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">C1</span><span class=\"o\">,</span> <span class=\"n\">h1</span> <span class=\"o\">⟩</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"n\">N</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">hC</span> <span class=\"o\">⟩</span>\n  <span class=\"n\">use</span> <span class=\"n\">max</span> <span class=\"n\">C1</span> <span class=\"n\">C</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span> <span class=\"n\">k</span>\n  <span class=\"n\">rcases</span> <span class=\"o\">(</span><span class=\"n\">le_or_gt</span> <span class=\"n\">n</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">hnN</span> <span class=\"bp\">|</span> <span class=\"n\">hnN</span>\n  <span class=\"bp\">.</span> <span class=\"n\">apply</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">hC</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"n\">hnN</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n    <span class=\"n\">gcongr</span>\n    <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"n\">pos</span> <span class=\"n\">n</span> <span class=\"n\">k</span>\n    <span class=\"n\">simp</span>\n  <span class=\"n\">apply</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"n\">hnN</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n  <span class=\"n\">gcongr</span>\n  <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"n\">pos</span> <span class=\"n\">n</span> <span class=\"n\">k</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 398549427,
        "sender_full_name": "Terence Tao",
        "timestamp": 1698262472
    },
    {
        "content": "<p>(I think you're looking for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.of_le_succ#doc\">docs#Nat.of_le_succ</a>)</p>",
        "id": 398550926,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1698263169
    },
    {
        "content": "<p>Here's a golf for hCM':</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"k\">have</span> <span class=\"n\">hCM'</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">M</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">M</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">CM</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">↦</span> <span class=\"n\">hCM</span> <span class=\"n\">M</span> <span class=\"n\">k</span> <span class=\"n\">le_rfl</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 398554628,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698264876
    },
    {
        "content": "<p>I really love filters but here I don't think they would make anything easier. Here is a more efficient version of your code, slightly restating your lemmas <code>est2</code> and <code>est3</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Nat.choose</span> <span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">((</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! the objective is to show that F(n,k) = O( G(n,k) ) for all n,k (not just asymptotically. )-/</span>\n\n<span class=\"sd\">/-- First, the asymptotic case --/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">est1</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">N</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>  <span class=\"c1\">-- use Stirling approximation</span>\n\n<span class=\"sd\">/-- Then, the base case n = 0 --/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">est2</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>  <span class=\"c1\">-- easy computation</span>\n\n<span class=\"sd\">/-- Then, the base case n = 0 --/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">est2'</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"mi\">0</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"mi\">0</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>  <span class=\"c1\">-- easy computation</span>\n\n<span class=\"sd\">/-- Then, the inductive case --/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">est3</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>  <span class=\"c1\">-- use Pascal identity</span>\n\n<span class=\"sd\">/-- Then, the inductive case --/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">est3'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">C</span> <span class=\"n\">hC</span> <span class=\"bp\">↦</span> <span class=\"n\">est3</span> <span class=\"n\">n</span> <span class=\"o\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">hC</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_by_induction</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₀</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"mi\">0</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">choose</span> <span class=\"n\">f₀</span> <span class=\"n\">hf₀</span> <span class=\"n\">using</span> <span class=\"n\">h₀</span>\n  <span class=\"n\">choose</span><span class=\"bp\">!</span> <span class=\"n\">F</span> <span class=\"n\">hF</span> <span class=\"n\">using</span> <span class=\"n\">ih</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.recOn</span> <span class=\"n\">n</span> <span class=\"n\">f₀</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.rec</span> <span class=\"n\">hf₀</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">hF</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"n\">ih</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">pos</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>  <span class=\"c1\">-- positivity</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span>\n\n<span class=\"sd\">/-- Finally, the non-asymptotic case -/</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">est1</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">C₁</span><span class=\"o\">,</span> <span class=\"n\">hC₁</span><span class=\"o\">⟩</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">exists_by_induction</span> <span class=\"n\">est2'</span> <span class=\"n\">est3'</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">hC</span><span class=\"o\">⟩</span>\n  <span class=\"c1\">-- Define `C₂` to be the maximum of the `C` function on `{0, ..., N}`.</span>\n  <span class=\"k\">let</span> <span class=\"n\">C₂</span> <span class=\"o\">:=</span> <span class=\"n\">max'</span> <span class=\"o\">(</span><span class=\"n\">image</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">Finset.nonempty_range_succ.image</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n  <span class=\"n\">use</span> <span class=\"n\">max</span> <span class=\"n\">C₁</span> <span class=\"n\">C₂</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span> <span class=\"n\">k</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">le_or_gt</span> <span class=\"n\">n</span> <span class=\"n\">N</span> <span class=\"k\">with</span> <span class=\"n\">hnN</span> <span class=\"bp\">|</span> <span class=\"n\">hnN</span>\n  <span class=\"bp\">.</span> <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">hC</span> <span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n    <span class=\"n\">gcongr</span>\n    <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"n\">pos</span> <span class=\"n\">n</span> <span class=\"n\">k</span>\n    <span class=\"n\">apply</span> <span class=\"n\">le_max_of_le_right</span>\n    <span class=\"n\">exact</span> <span class=\"n\">le_max'</span> <span class=\"o\">(</span><span class=\"n\">image</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mem_image_of_mem</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">mem_range_succ_iff.2</span> <span class=\"n\">hnN</span><span class=\"o\">))</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">hC₁</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"n\">hnN</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n    <span class=\"n\">gcongr</span>\n    <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"n\">pos</span> <span class=\"n\">n</span> <span class=\"n\">k</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 398559342,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698267351
    },
    {
        "content": "<p>We can abstract this some more, leading to an existence principle from base case, induction and low values. And then apply it to your example.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Nat.choose</span> <span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">((</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! the objective is to show that F(n,k) = O( G(n,k) ) for all n,k (not just asymptotically. )-/</span>\n\n<span class=\"sd\">/-- First, the asymptotic case --/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">est1</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">N</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>  <span class=\"c1\">-- use Stirling approximation</span>\n\n<span class=\"sd\">/-- Then, the base case n = 0 --/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">est2</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>  <span class=\"c1\">-- easy computation</span>\n\n<span class=\"sd\">/-- Then, the base case n = 0 --/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">est2'</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"mi\">0</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"mi\">0</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>  <span class=\"c1\">-- easy computation</span>\n\n<span class=\"sd\">/-- Then, the inductive case --/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">est3</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>  <span class=\"c1\">-- use Pascal identity</span>\n\n<span class=\"sd\">/-- Then, the inductive case --/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">est3'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">C</span> <span class=\"n\">hC</span> <span class=\"bp\">↦</span> <span class=\"n\">est3</span> <span class=\"n\">n</span> <span class=\"o\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">hC</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">pos</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>  <span class=\"c1\">-- positivity</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_by_induction</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₀</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"mi\">0</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">choose</span> <span class=\"n\">f₀</span> <span class=\"n\">hf₀</span> <span class=\"n\">using</span> <span class=\"n\">h₀</span>\n  <span class=\"n\">choose</span><span class=\"bp\">!</span> <span class=\"n\">F</span> <span class=\"n\">hF</span> <span class=\"n\">using</span> <span class=\"n\">ih</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.recOn</span> <span class=\"n\">n</span> <span class=\"n\">f₀</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.rec</span> <span class=\"n\">hf₀</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">hF</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"n\">ih</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">⟩</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_by_induction_and_low_vals</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">h₀</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"mi\">0</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">a'</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span><span class=\"n\">N</span> <span class=\"n\">a₁</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">low_vals</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"n\">a₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mono</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Monotone</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">exists_by_induction</span> <span class=\"n\">h₀</span> <span class=\"n\">ih</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span>\n  <span class=\"k\">let</span> <span class=\"n\">a₂</span> <span class=\"o\">:=</span> <span class=\"n\">max'</span> <span class=\"o\">(</span><span class=\"n\">image</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">Finset.nonempty_range_succ.image</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"n\">use</span> <span class=\"n\">max</span> <span class=\"n\">a₁</span> <span class=\"n\">a₂</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">le_or_gt</span> <span class=\"n\">n</span> <span class=\"n\">N</span> <span class=\"k\">with</span> <span class=\"n\">hnN</span> <span class=\"bp\">|</span> <span class=\"n\">hnN</span>\n  <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"n\">mono</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">le_max_of_le_right</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">le_max'</span> <span class=\"o\">(</span><span class=\"n\">image</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">mem_image_of_mem</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">mem_range_succ_iff.2</span> <span class=\"n\">hnN</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">mono</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">le_max_left</span> <span class=\"n\">a₁</span> <span class=\"n\">a₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">low_vals</span> <span class=\"n\">n</span> <span class=\"n\">hnN</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">est1</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">C₁</span><span class=\"o\">,</span> <span class=\"n\">hC₁</span><span class=\"o\">⟩</span>\n  <span class=\"c1\">-- The weird `fun n hn k ↦ hC₁ _ _ hn` comes from a discrepancy between the order of quantifiers</span>\n  <span class=\"c1\">-- In the example we have `∀ n : ℕ, ∀ k : ℕ, (N &lt; n) → F n k ≤ C * G n k` where the abstract lemma</span>\n  <span class=\"c1\">-- want `∀ n &gt; N, ∀ k : ℕ, F n k ≤ C * G n k`.</span>\n  <span class=\"n\">apply</span> <span class=\"n\">exists_by_induction_and_low_vals</span> <span class=\"n\">est2'</span> <span class=\"n\">est3'</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">hn</span> <span class=\"n\">k</span> <span class=\"bp\">↦</span> <span class=\"n\">hC₁</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hn</span><span class=\"o\">)</span>\n  <span class=\"n\">clear</span> <span class=\"n\">N</span> <span class=\"n\">C₁</span> <span class=\"n\">hC₁</span>\n  <span class=\"c1\">-- Now prove the monotonicity property</span>\n  <span class=\"n\">intro</span> <span class=\"n\">C</span> <span class=\"n\">N</span> <span class=\"n\">n</span> <span class=\"n\">hn</span> <span class=\"n\">hC</span> <span class=\"n\">k</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">hC</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n  <span class=\"n\">gcongr</span>\n  <span class=\"n\">apply</span> <span class=\"n\">pos</span>\n</code></pre></div>",
        "id": 398562819,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698269209
    },
    {
        "content": "<p>Note the slightly unusual assumption <code>Monotone (P n)</code> where <code>P</code> is a predicate on <code>α</code>. You need to know that Lean endows <code>Prop</code> with the order relation where <code>False &lt; True</code>, so that assumption means that <code>P n a</code> implies <code>P n a'</code> whenever <code>a ≤ a'</code>. This is the monotonicity property proved at the very end when applying the abstract lemma to your example.</p>",
        "id": 398563080,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698269339
    },
    {
        "content": "<p>Also worth a small note: I could have replaced <code>{N a₁} (low_vals : ∀ n &gt; N, P n a₁)</code> in the assumptions of <code>exists_by_induction_and_low_vals</code> by <code>(low_vals : ∃ N a₁, ∀ n &gt; N, P n a₁)</code>. This would be logically equivalent, but then the proof would start with a <code>rcases low_vals with ...</code> which is only noise, and the resulting lemma would also be very slightly less convenient to use.</p>",
        "id": 398563421,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698269532
    },
    {
        "content": "<p>Patrick's approach also shows the general principle that in a theorem prover a good approach to proving theorems is to break them down into several small blocks, rather than just going straight for that main result.</p>",
        "id": 398566812,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698271382
    },
    {
        "content": "<p>Yes, lemma <code>exists_by_induction_and_low_vals</code> is not something you would state and prove on paper. Doing it in a proof assistant allows decoupling the purely logical structure of the argument with what is specific to your application. We have a lot of those lemmas in formal math.</p>",
        "id": 398567081,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698271512
    },
    {
        "content": "<p>It helps even if you use it only once.</p>",
        "id": 398567111,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698271532
    },
    {
        "content": "<p>I'm trying to write a shorter proof.</p>",
        "id": 398567392,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1698271690
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Filter</span> <span class=\"n\">Asymptotics</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Nat.choose</span> <span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">((</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! the objective is to show that F(n,k) = O( G(n,k) ) for all n,k (not just asymptotically. )-/</span>\n\n<span class=\"sd\">/-- First, the asymptotic case --/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">est1</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">N</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>  <span class=\"c1\">-- use Stirling approximation</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Fnonneg</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.cast_nonneg</span> <span class=\"n\">_</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Gpos</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">G</span><span class=\"bp\">;</span> <span class=\"n\">positivity</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">est1</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n  <span class=\"k\">have</span> <span class=\"n\">hF₀</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"bp\">=ᶠ</span><span class=\"o\">[</span><span class=\"n\">atTop</span><span class=\"o\">]</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">eventually_gt_atTop</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mono</span> <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"n\">hk</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">Nat.choose_eq_zero_iff</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">Cn</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">Cn</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span>\n    <span class=\"k\">have</span> <span class=\"n\">hFO</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"n\">atTop</span><span class=\"o\">]</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">hF₀</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans_isBigO</span> <span class=\"o\">(</span><span class=\"n\">isBigO_zero</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">Cn</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">,</span> <span class=\"n\">hCn</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">bound_of_isBigO_nat_atTop</span> <span class=\"o\">(</span><span class=\"n\">hFO</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Real.norm_of_nonneg</span><span class=\"o\">,</span> <span class=\"n\">Fnonneg</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">Gpos</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hCn</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"bp\">⌈</span><span class=\"n\">Cn</span><span class=\"bp\">⌉₊</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">hCn</span> <span class=\"o\">(</span><span class=\"n\">Gpos</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">gcongr</span><span class=\"bp\">;</span> <span class=\"n\">exacts</span> <span class=\"o\">[(</span><span class=\"n\">Gpos</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"o\">,</span> <span class=\"n\">Nat.le_ceil</span> <span class=\"n\">_</span><span class=\"o\">]</span>\n  <span class=\"n\">choose</span> <span class=\"n\">Cn</span> <span class=\"n\">hCn</span> <span class=\"n\">using</span> <span class=\"n\">this</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">D</span> <span class=\"k\">in</span> <span class=\"n\">atTop</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"bp\">≤</span> <span class=\"n\">D</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">Cn</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">D</span> <span class=\"o\">:=</span>\n    <span class=\"o\">(</span><span class=\"n\">eventually_ge_atTop</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">and</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">eventually_all_finite</span> <span class=\"o\">(</span><span class=\"n\">Set.finite_le_nat</span> <span class=\"n\">N</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span>\n      <span class=\"o\">(</span><span class=\"n\">eventually_ge_atTop</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">this.exists</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">D</span><span class=\"o\">,</span> <span class=\"n\">hCD</span><span class=\"o\">,</span> <span class=\"n\">hCnD</span><span class=\"o\">⟩</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">D</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">le_or_lt</span> <span class=\"n\">n</span> <span class=\"n\">N</span> <span class=\"k\">with</span> <span class=\"n\">hn</span> <span class=\"bp\">|</span> <span class=\"n\">hn</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">hCn</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mul_le_mul_of_nonneg_right</span> <span class=\"o\">(</span><span class=\"n\">Nat.cast_le.2</span> <span class=\"o\">(</span><span class=\"n\">hCnD</span> <span class=\"n\">n</span> <span class=\"n\">hn</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Gpos</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">le</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"n\">hn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mul_le_mul_of_nonneg_right</span> <span class=\"o\">(</span><span class=\"n\">Nat.cast_le.2</span> <span class=\"n\">hCD</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Gpos</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">le</span>\n</code></pre></div>",
        "id": 398569966,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1698272585
    },
    {
        "content": "<p>Or this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Filter</span> <span class=\"n\">Asymptotics</span> <span class=\"n\">Set</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Nat.choose</span> <span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">((</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! the objective is to show that F(n,k) = O( G(n,k) ) for all n,k (not just asymptotically. )-/</span>\n\n<span class=\"sd\">/-- First, the asymptotic case --/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">est1</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">N</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>  <span class=\"c1\">-- use Stirling approximation</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Fnonneg</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.cast_nonneg</span> <span class=\"n\">_</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Gpos</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">G</span><span class=\"bp\">;</span> <span class=\"n\">positivity</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">eventually_forall_iff_cofinite</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀ᶠ</span> <span class=\"n\">p</span> <span class=\"k\">in</span> <span class=\"n\">l</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">cofinite</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">p.1</span> <span class=\"n\">p.2</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨(</span><span class=\"n\">h.prod_inl</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mono</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"n\">hp</span> <span class=\"bp\">↦</span> <span class=\"n\">hp</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">↦</span> <span class=\"n\">h.mono</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">↦</span> <span class=\"n\">hx</span> <span class=\"n\">y</span><span class=\"o\">⟩,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[(</span><span class=\"n\">l.basis_sets.prod</span> <span class=\"n\">hasBasis_cofinite</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eventually_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨⟨⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">hsl</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t.Finite</span><span class=\"o\">⟩,</span> <span class=\"n\">h₁</span><span class=\"o\">⟩,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">eventually_all_finite</span> <span class=\"n\">ht</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">h₂</span> <span class=\"n\">_</span>\n  <span class=\"n\">filter_upwards</span> <span class=\"o\">[</span><span class=\"n\">hsl</span><span class=\"o\">,</span> <span class=\"n\">this</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">hxs</span> <span class=\"n\">hxt</span> <span class=\"n\">y</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span>\n  <span class=\"n\">exacts</span> <span class=\"o\">[</span><span class=\"n\">hxt</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">h₁</span> <span class=\"o\">(</span><span class=\"n\">Set.mk_mem_prod</span> <span class=\"n\">hxs</span> <span class=\"n\">hy</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">eventually_forall_nat_iff_atTop</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀ᶠ</span> <span class=\"n\">p</span> <span class=\"k\">in</span> <span class=\"n\">l</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">atTop</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">p.1</span> <span class=\"n\">p.2</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eventually_forall_iff_cofinite</span><span class=\"o\">,</span> <span class=\"n\">Nat.cofinite_eq_atTop</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">suffices</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"k\">in</span> <span class=\"n\">atTop</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span>  <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"n\">G</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"k\">from</span> <span class=\"n\">this.exists</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">eventually_forall_nat_iff_atTop</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span><span class=\"o\">)]</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span><span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rcases</span> <span class=\"n\">est1</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">hNC</span><span class=\"o\">⟩</span>\n    <span class=\"n\">refine</span> <span class=\"o\">((</span><span class=\"n\">eventually_ge_atTop</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prod_mk</span> <span class=\"o\">(</span><span class=\"n\">eventually_gt_atTop</span> <span class=\"n\">N</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mono</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">hNC</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h.2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mul_le_mul_of_nonneg_right</span> <span class=\"o\">(</span><span class=\"n\">Nat.cast_le.2</span> <span class=\"n\">h.1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Gpos</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">le</span>\n  <span class=\"bp\">·</span> <span class=\"n\">refine</span> <span class=\"o\">((</span><span class=\"n\">eventually_gt_atTop</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prod_inr</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mono</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">Nat.choose_eq_zero_iff.2</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">Gpos</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">tendsto_nat_cast_atTop_atTop.atTop_mul_const</span> <span class=\"o\">(</span><span class=\"n\">Gpos</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">eventually_ge_atTop</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 398578288,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1698277653
    },
    {
        "content": "<p>This is nice but I hope my version is closer to being a general explanation instead of focusing on this specific example.</p>",
        "id": 398578507,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698277864
    },
    {
        "content": "<p>I was commenting the first version, I didn't see the second one which looks more promising.</p>",
        "id": 398578632,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698277975
    },
    {
        "content": "<p>It depends on what do you know for each particular <code>n</code>.</p>",
        "id": 398578652,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1698277996
    },
    {
        "content": "<p>If the best you can do is a proof by induction, then you're right.</p>",
        "id": 398578661,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1698278008
    },
    {
        "content": "<p>If you can prove that for each <code>n</code> there is an estimate (e.g., because <code>f n =O[atTop] g n</code>), then my version works fine.</p>",
        "id": 398578732,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1698278058
    },
    {
        "content": "<p>This is a neat approach, but different from the filter-based approach I was expecting.  My vague idea was to interpret <code>est1</code> as a <code>F =O[l] G</code> assertion for the filter corresponding to large <code>n</code>, <code>est2</code> as a similar assertion for the principal filter for <code>{0}</code>, <code>est3</code> as an inductive assertion that lets us control the principal filter for <code>{n}</code> for any <code>n</code>, and then one would conclude from the general properties of filters and their interaction with O() notation.  In particular it would be compatible with the filter approach to the previous example (in my actual application, the asymptotic case when <code>n</code> is large is dealt with by a further splitting into cases similar to <code>n ≤ k</code> and <code>k &lt; n</code> in the toy example).</p>",
        "id": 398590384,
        "sender_full_name": "Terence Tao",
        "timestamp": 1698287551
    },
    {
        "content": "<p>I'm just curious, are the above definitions of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>=</mo><mi>O</mi><mo stretchy=\"false\">(</mo><mi>g</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f  = O(g)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span></span></span></span> consistent with the <a href=\"https://en.wikipedia.org/wiki/Big_O_notation#Formal_definition\">Wikipedia definition</a> for big O notation, namely:</p>\n<p>Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>, the function to be estimated, be a real or complex valued function and let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span>, the comparison function, be a real valued function.  Let both functions be defined on some unbounded subset of the positive real numbers, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">g(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> be strictly positive for all large enough values of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>.  Then</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>O</mi><mo fence=\"true\" stretchy=\"true\" minsize=\"1.2em\" maxsize=\"1.2em\">(</mo><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo fence=\"true\" stretchy=\"true\" minsize=\"1.2em\" maxsize=\"1.2em\">)</mo><mspace width=\"1em\"/><mtext> as </mtext><mi>x</mi><mo>→</mo><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">f(x) = O\\bigl( g(x)\\bigr)\\quad\\text{ as }x\\to\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2em;vertical-align:-0.35em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\"><span class=\"delimsizing size1\">(</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mclose\"><span class=\"delimsizing size1\">)</span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\"> as </span></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord\">∞</span></span></span></span></p>\n<p>if there exists a positive real number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> and a real number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">x_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> such that</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∣</mi><mo>≤</mo><mi>M</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mspace width=\"1em\"/><mtext> for all </mtext><mi>x</mi><mo>≥</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">|f(x)| \\le M g(x) \\quad \\text{ for all } x \\ge x_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\"> for all </span></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></p>",
        "id": 398800207,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1698372263
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsBigOWith#doc\">docs#IsBigOWith</a> doesn't require <code>g</code> to be eventually positive, but we take the norm of <code>g(x)</code> instead.</p>",
        "id": 398804153,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698374012
    },
    {
        "content": "<p>So it's effectively the same</p>",
        "id": 398804193,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698374030
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Working.20with.20big-O.20notation.20like.20an.20analyst/near/398540872\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Working.20with.20big-O.20notation.20like.20an.20analyst/near/398528932\">said</a>:</p>\n<blockquote>\n<p>Do we really have no norm on $\\mathbb{N}$ ?!?</p>\n</blockquote>\n<p>No because which prime $p$ would you choose?</p>\n</blockquote>\n<p>What about the trivial nonarchimedean norm?</p>",
        "id": 398829191,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1698387287
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/8362\">#8362</a> I define some predicates (<code>ReflectsGrowth</code> and a few more restrictive versions). What do you think about it?</p>",
        "id": 401587361,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1699773615
    },
    {
        "content": "<p>Some examples are near the end of the <code>ReflectsGrowth</code> file.</p>",
        "id": 401587415,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1699773670
    },
    {
        "content": "<p>With these predicates, we can have combinators like <code>mul_lex</code> (to construct terms like <code>x ^ r * exp (a * x)</code>) and lemmas like \"a sum of these terms is equivalent to its leading term\".</p>",
        "id": 401587523,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1699773768
    },
    {
        "content": "<p>The reason why I don't assume <code>g = id</code> is that for a complex exponential <code>exp (a * z)</code> (as <code>re z → ∞</code> and <code>im z</code> is not too large), the right function is <code>re a</code>.</p>",
        "id": 401587634,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1699773862
    },
    {
        "content": "<p>I'm using this (dormant) thread to record one possible way to work with asymptotic notation in Lean \"like an analyst\" that might not be too unwieldy, inspired by an approach we came up with in the PFR project to encode various ambient parameters.  Namely, to create a structure (we called it <code>refPackage</code>) of various ambient parameters and the hypotheses placed upon them.  In the case of asymptotic notation, all of the implied asymptotic constants <code>C₁</code>, <code>C₂</code>, <code>C₃</code>, etc. could be viewed as components of the <code>refPackage</code>, and a single object <code>p: refPackage</code> can be passed to all of the lemmas in the argument, in order to make these constants available as needed (under names such as <code>p.C₁</code>, <code>p.C₂</code>, <code>p.C₃</code>, etc.).  (In some cases these constants will not be absolute, but will be functions of other parameters, but this is easily handled in Lean by selecting appropriate types for each constant.) To get from one asymptotic constant to another, one needs various relations between these constants (e.g., <code>C₃ ≥ C₂ + C₁</code>), instances of which one simply adds as additional components to the <code>refPackage</code> as needed, without disrupting the rest of the arguments with additional existential quantifiers etc.. Only at the very end of the proof will one need to show that at least one <code>refPackage</code> exists, i.e., that there exists a choice of parameters that obeys all the required hypotheses, and this can be done in one go (with some giant constructor or something).  The point though is that one can defer having to deal with this until all the rest of the proof is stable.  In the future one could even imagine a tactic (sort of analogous to <code>filter_upwards</code>) that could automatically break up the verification of existence of a <code>refPackage</code> into a sequence of small existential claims (e.g., given <code>C₁</code> and C₂, that <code>C₃ ≥ C₂ + C₁</code> for all sufficiently large <code>C₃</code>) that would make even this last step less tedious (and easier to maintain if the main body of the argument changes).</p>",
        "id": 408690627,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702935748
    },
    {
        "content": "<p>We already know what to do in this direction, see <a href=\"#narrow/stream/270676-lean4/topic/Assigning.20metavariables.20by.20unification/near/407350443\">here</a>.</p>",
        "id": 408691417,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1702936540
    },
    {
        "content": "<p>Great, having direct support for procrastinated side conditions would work nicely, but if we are still waiting for that to be deployed, bundling all these conditions into a single package seems to be a feasible workaround.</p>\n<p>Though in the absence of an explicit object to hold all the procrastinated conditions, I'm not sure how one would implement procrastination if the argument is split up across multiple lemmas, each with their own separate goal and tactic state.</p>",
        "id": 408693018,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702937331
    }
]