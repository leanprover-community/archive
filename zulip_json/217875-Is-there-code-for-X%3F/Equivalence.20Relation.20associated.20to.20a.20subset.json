[
    {
        "content": "<p>I don't know if something like this is already constructed</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">EquiS</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">):</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">s</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">=</span><span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It is an equivalence relation, the one generated by the subset s.</p>",
        "id": 409633101,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1703273596
    },
    {
        "content": "<p>isn't this the kernel of the indicator function of <code>S</code>?</p>",
        "id": 409633436,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1703273782
    },
    {
        "content": "<p>or rather the function which collapses <code>S</code> to a point</p>",
        "id": 409633528,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1703273859
    },
    {
        "content": "<p>Yes, it collapses <code>s</code> to a point. Except you should really use <code>Set</code> here instead of predicates.</p>",
        "id": 409634287,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1703274362
    },
    {
        "content": "<p>I guess it could therefore be modeled as the kernel of <code>Set.indicator S\\^c coe</code> where <code>coe</code> is the inclusion into <code>WithZero</code>, or something like that.</p>",
        "id": 409634547,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1703274533
    },
    {
        "content": "<p>I think I remember seeing something like in mathlib.</p>",
        "id": 409634797,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1703274696
    },
    {
        "content": "<p>I don't really know what's the kernel of a function in mathlib. May be something like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">):=</span> <span class=\"o\">((</span><span class=\"bp\">·=·</span><span class=\"o\">)</span> <span class=\"n\">on</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 409639918,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1703277838
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Setoid.ker#doc\">docs#Setoid.ker</a></p>",
        "id": 409699198,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703321535
    },
    {
        "content": "<p>Does <code>Setoid.ker (PLift.up ∘ s)</code>work?</p>",
        "id": 409699368,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703321691
    },
    {
        "content": "<p>Arguably Setoid.ker has bad universe assumptions</p>",
        "id": 409699446,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703321760
    },
    {
        "content": "<p>I guess, <code>Setoid.ker</code> will glue both <code>s</code> and its complement.</p>",
        "id": 409730071,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703348495
    },
    {
        "content": "<p>I think that we should add this definition to Mathlib. E.g., it appears in quite a few (counter)examples in topology.</p>",
        "id": 409730249,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703348649
    },
    {
        "content": "<p>... or in algebraic geometry, for homology computations</p>",
        "id": 409730265,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703348675
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315546\">@Xavier Xarles</span> Could you do this, please? E.g., in <code>Data.Setoid.Basic</code>.</p>",
        "id": 409730305,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703348736
    },
    {
        "content": "<p>Can be called <code>Set.toSetoid</code>.</p>",
        "id": 409730374,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703348787
    },
    {
        "content": "<p>I was hoping for a more visual name, something involving \"squash\".</p>",
        "id": 409730412,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703348836
    },
    {
        "content": "<p>Then it should be <code>Setoid.squash</code>.</p>",
        "id": 409730432,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703348866
    },
    {
        "content": "<p>I think I was confused, the PLift is not needed</p>",
        "id": 409730435,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703348871
    },
    {
        "content": "<p><code>Setoid.ker (· ∈ s)</code> alone works fine</p>",
        "id": 409730439,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703348876
    },
    {
        "content": "<p>Or for Xavier's original example without a set but a predicate, simply <code>Setoid.ker p</code> is enough</p>",
        "id": 409730501,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703348908
    },
    {
        "content": "<p>But it's not the relation we need here.</p>",
        "id": 409730508,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703348918
    },
    {
        "content": "<p>Whoops; <code>Setoid.map ⊤ ((↑) : s → α)</code> presumably is, right? Though it has a lousy defeq.</p>",
        "id": 409732396,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703349570
    },
    {
        "content": "<p>I agree that this construction (of the quotient squashing a set to a point) is important and should be added, but I think that we should just take the <code>Quot</code> by the (generally non-equiv) relation <code>x \\in S \\and y \\in S</code>, and develop an api around that</p>",
        "id": 409732568,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1703349665
    },
    {
        "content": "<p>Last time we had this discussion, <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/setoid.20.22glue.20this.20set.20into.20a.20pt.22/near/368983169\">something that I'd thought of</a> was having an API for generating a setoid with some collection of equivalence classes. If the equivalence classes don't cover the whole type, then the assumption could be that it is extended using singleton sets for the rest of the equivalence classes.</p>\n<p>This way, the \"collapse this set <code>s</code> to a point\" is using this with the collection <code>{s}</code>. If you want to collapse one set <code>s</code> to a point and another disjoint set <code>t</code> to another point, you could use the collection <code>{s, t}</code>.</p>",
        "id": 409732907,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703350079
    },
    {
        "content": "<p>If you have <code>S : Set (Set α)</code>, then you can define a setoid by <code>Setoid.map (.ker Sigma.fst) fun x : Σ i : S, i.1 =&gt; x.2.1</code></p>",
        "id": 409733081,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703350251
    },
    {
        "content": "<p>Then you can have lemmas for special cases like \"all sets in <code>S</code> are pairwise disjoint\" or \"<code>S</code> is a singleton\" or \"<code>S</code> is a partition of the whole space into disjoint sets\".</p>",
        "id": 409733113,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703350314
    },
    {
        "content": "<p>I really don't understand what your definition does. Given a \"collection\" of subsets of α, which equivalence relation it defines?</p>",
        "id": 410004981,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1703585601
    },
    {
        "content": "<p>A more readable version (not tested):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Setoid.fromSets</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">EqvGen.Setoid</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span>\n</code></pre></div>",
        "id": 410032501,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703601194
    },
    {
        "content": "<p>It defines the minimal equivalence relation that squashes each <code>s ∈ S</code>.</p>",
        "id": 410032550,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703601222
    },
    {
        "content": "<p>What are the use cases for taking a collection of sets instead of only one?<br>\nJust want to make sure we aren't generalizing unnecessarily.</p>",
        "id": 424467312,
        "sender_full_name": "Chris Wong",
        "timestamp": 1709435238
    },
    {
        "content": "<p>I had applications such as graph minors in mind, since it lets you relate a minor of a minor to a minor of the original graph.</p>",
        "id": 424467705,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709435659
    },
    {
        "content": "<p>I guess the advantage of the original <code>(x ∈ s ∧ y ∈ s) ∨ x = y</code> proposal is that it's already an equivalence - we don't need an extra <code>EqvGen</code> (and the induction dance that entails) to make it work.</p>",
        "id": 424467706,
        "sender_full_name": "Chris Wong",
        "timestamp": 1709435660
    },
    {
        "content": "<p>Or, more generally, if you collapse one subset and then another, it's convenient to be able to express collapsing both at once.</p>",
        "id": 424467755,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709435721
    },
    {
        "content": "<p>(Also, we only need <code>ReflTransGen</code>? Since it's already symmetric <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> )</p>",
        "id": 424468449,
        "sender_full_name": "Chris Wong",
        "timestamp": 1709436457
    },
    {
        "content": "<p>If we require the sets to be disjoint, then we only need <code>ReflGen</code>. That might be easier to work with as it's not recursive.</p>",
        "id": 424509254,
        "sender_full_name": "Chris Wong",
        "timestamp": 1709472755
    },
    {
        "content": "<p>I think it's better if we use the <code>EqvGen</code>/<code>ReflTransGen</code> version and then have lemmas that say if the sets are pairwise disjoint then you can use <code>ReflGen</code>.</p>\n<p>It's the principle of not requiring additional hypotheses in a definition when possible.</p>",
        "id": 424542283,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709498974
    },
    {
        "content": "<p>Something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Setoid.fromSets</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">EqvGen.Setoid</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Setoid.fromSets_r_iff</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S.Pairwise</span> <span class=\"n\">Disjoint</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">Setoid.fromSets</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hr</span>\n    <span class=\"n\">induction</span> <span class=\"n\">hr</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">rel</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hr</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">Or.inr</span> <span class=\"n\">hr</span>\n    <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"n\">symm</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">convert</span> <span class=\"n\">ih</span> <span class=\"n\">using</span> <span class=\"mi\">1</span>\n      <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_comm</span><span class=\"o\">]</span>\n      <span class=\"bp\">·</span> <span class=\"n\">congr</span><span class=\"bp\">!</span> <span class=\"mi\">3</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">and_comm</span><span class=\"o\">]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">trans</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">hxy</span> <span class=\"n\">hyz</span> <span class=\"n\">ih1</span> <span class=\"n\">ih2</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">ih1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ih1</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">obtain</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">ih2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ih2</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Or.inr</span> <span class=\"n\">ih2</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Or.inr</span> <span class=\"n\">ih1</span>\n      <span class=\"bp\">·</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">s1</span><span class=\"o\">,</span> <span class=\"n\">hs1</span><span class=\"o\">,</span> <span class=\"n\">hxs1</span><span class=\"o\">,</span> <span class=\"n\">hys1</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ih1</span>\n        <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">s2</span><span class=\"o\">,</span> <span class=\"n\">hs2</span><span class=\"o\">,</span> <span class=\"n\">hys2</span><span class=\"o\">,</span> <span class=\"n\">hzs2</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ih2</span>\n        <span class=\"n\">obtain</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">hne</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">eq_or_ne</span> <span class=\"n\">s1</span> <span class=\"n\">s2</span>\n        <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Or.inr</span> <span class=\"o\">⟨</span><span class=\"n\">s1</span><span class=\"o\">,</span> <span class=\"n\">hs1</span><span class=\"o\">,</span> <span class=\"n\">hxs1</span><span class=\"o\">,</span> <span class=\"n\">hzs2</span><span class=\"o\">⟩</span>\n        <span class=\"bp\">·</span> <span class=\"n\">exfalso</span>\n          <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">hs1</span> <span class=\"n\">hs2</span> <span class=\"n\">hne</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.disjoint_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n          <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">this</span> <span class=\"o\">⟨</span><span class=\"n\">hys1</span><span class=\"o\">,</span> <span class=\"n\">hys2</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">EqvGen.refl</span> <span class=\"n\">_</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">EqvGen.rel</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Setoid.fromSets_r_eq_of_disjoint</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S.Pairwise</span> <span class=\"n\">Disjoint</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">Setoid.fromSets</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">Relation.ReflGen</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Setoid.fromSets_r_iff</span> <span class=\"n\">S</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">hr</span><span class=\"o\">)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">constructor</span>\n      <span class=\"n\">exact</span> <span class=\"n\">hr</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hr</span>\n    <span class=\"n\">induction</span> <span class=\"n\">hr</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"n\">single</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">Or.inr</span> <span class=\"n\">ih</span>\n</code></pre></div>",
        "id": 424543762,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709500284
    },
    {
        "content": "<p>Thanks! That's a cool idea. I defined it with <code>ReflGen</code> in my code but dealing with the extra <code>(h : S.PairwiseDisjoint)</code> hypotheses was indeed annoying. Having those 2 lemmas instead makes sense to me.</p>",
        "id": 424555947,
        "sender_full_name": "Chris Wong",
        "timestamp": 1709511084
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Equivalence.20Relation.20associated.20to.20a.20subset/near/409730412\">said</a>:</p>\n<blockquote>\n<p>I was hoping for a more visual name, something involving \"squash\".</p>\n</blockquote>\n<p>Note that we already have a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Squash#doc\">docs#Squash</a>. (It's a near-duplicate of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Trunc#doc\">docs#Trunc</a> – perhaps we can remove one of them...)</p>",
        "id": 424576784,
        "sender_full_name": "Chris Wong",
        "timestamp": 1709527375
    },
    {
        "content": "<p>Here's my version using <code>ReflTransGen</code> instead. I think dropping the redundant <code>symm</code> case makes the <code>fromSets_r_iff</code> proof simpler. I also simplified the disjointness proof using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.PairwiseDisjoint.elim_set#doc\">docs#Set.PairwiseDisjoint.elim_set</a>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Relation</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Setoid.fromSets</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">ReflTransGen</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">refl</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"n\">ReflTransGen.refl</span>\n    <span class=\"n\">trans</span> <span class=\"o\">:=</span> <span class=\"n\">ReflTransGen.trans</span>\n    <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">↦</span> <span class=\"n\">ReflTransGen.symmetric</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">tauto</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n  <span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Setoid.fromSets_r_iff</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S.PairwiseDisjoint</span> <span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">Setoid.fromSets</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hr</span>\n    <span class=\"n\">induction</span> <span class=\"n\">hr</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"n\">tail</span> <span class=\"n\">_</span> <span class=\"n\">hs</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">rcases</span> <span class=\"n\">ih</span> <span class=\"k\">with</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">ht</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">hs</span>\n      <span class=\"bp\">·</span> <span class=\"n\">right</span>\n        <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">hbs</span><span class=\"o\">,</span> <span class=\"n\">hcs</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hs</span>\n        <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">hat</span><span class=\"o\">,</span> <span class=\"n\">hbt</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ht</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">h.elim_set</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span> <span class=\"n\">_</span> <span class=\"n\">hbs</span> <span class=\"n\">hbt</span>\n        <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">this</span> <span class=\"bp\">▸</span> <span class=\"n\">hat</span><span class=\"o\">,</span> <span class=\"n\">hcs</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">hr</span><span class=\"o\">)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"bp\">.</span><span class=\"n\">refl</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"bp\">.</span><span class=\"n\">single</span> <span class=\"n\">hr</span>\n</code></pre></div>",
        "id": 424664949,
        "sender_full_name": "Chris Wong",
        "timestamp": 1709561846
    },
    {
        "content": "<p>Here's what I've got so far:<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/commit/b01a0c03cd6db19775e13c8d454bb013d2df4141\">https://github.com/leanprover-community/mathlib4/commit/b01a0c03cd6db19775e13c8d454bb013d2df4141</a><br>\nI added the <code>fiber</code> lemmas because they were useful for my minor map definition.<br>\nIf there are no objections, I'll split this off the <code>minor</code> branch and send a PR.</p>",
        "id": 425301226,
        "sender_full_name": "Chris Wong",
        "timestamp": 1709817694
    },
    {
        "content": "<p>I wonder if it's worth trying the <code>\\forall s \\in S, x \\in s -&gt; y \\in s</code> definition used by <code>mkClasses</code>. That relation is reflexive and transitive but not symmetric. Unfortunately there's no <code>SymmGen</code> in mathlib.</p>",
        "id": 425333980,
        "sender_full_name": "Chris Wong",
        "timestamp": 1709825499
    },
    {
        "content": "<p>Even if <code>SymmGen</code> existed, it would not preserve transitivity, so it would be useless anyway. So I'll stick with the original definition with the existential.</p>",
        "id": 425427322,
        "sender_full_name": "Chris Wong",
        "timestamp": 1709861244
    },
    {
        "content": "<p>Coming back to this. <br>\nAnother possibility is </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Contract</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subtype</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>where the elements of <code>S</code> are mapped to <code>.none</code>.<br>\nAnd then we don't really need an API at this point, just manipulate the Subtype directly.</p>",
        "id": 491043305,
        "sender_full_name": "Chris Wong",
        "timestamp": 1735343405
    }
]