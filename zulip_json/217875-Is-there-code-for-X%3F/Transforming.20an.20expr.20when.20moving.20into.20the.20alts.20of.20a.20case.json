[
    {
        "content": "<p>Meta-programming question:</p>\n<p>I am traversing an expression (a function definition), and I also have an <code>e : Expr</code> of interest at hand. As I go into the alts of a <code>casesOn</code> combinator, if that case analysis looks at <code>e</code>, I want to get the “refined” expression.</p>\n<p>For example, say <code>e</code> is <code>(a, b)</code>, and I enter <code>PSigma.casesOn b (fun c d = …)</code>, then I want to know that instead of <code>(a, b)</code> I now have <code>(a (c, d))</code>.</p>\n<p>There is something very close to that in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Meta/CasesOn.html#Lean.Meta.CasesOnApp.addArg\"><code>Lean.Meta.CasesOnApp.addArg</code></a>, which I can use if <code>e</code> is a type and I have an actual value <code>v : e</code> around that I can thread though, and as part of that process, that function does infer the “refined” type of <code>v</code>. But what do I do if  I don’t have a value, and just the expression <code>e</code>  that I want to transform?</p>\n<p>(I tried cargo-culting <code>addArg</code>, but it doesn’t seem to work right.)</p>",
        "id": 401202586,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1699550374
    },
    {
        "content": "<p>This <em>seem</em> to be roughly doing what I think I need, but I have serious doubts that this is idiomatic good style…</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">  Given a `casesOn` application `c` of the form</span>\n<span class=\"sd\">  ```</span>\n<span class=\"sd\">  casesOn As (fun is x =&gt; motive[i, xs]) is major  (fun ys_1 =&gt; (alt_1 : motive (C_1[ys_1])) ... (fun ys_n =&gt; (alt_n : motive (C_n[ys_n]) remaining</span>\n<span class=\"sd\">  ```</span>\n<span class=\"sd\">  and a type `e : B[is, major]`, for every alternative `i`, construct the type</span>\n<span class=\"sd\">  ```</span>\n<span class=\"sd\">  B[C_i[ys_i]]</span>\n<span class=\"sd\">  ```</span>\n<span class=\"sd\">  (which `ys_i` as loose bound variable, ready to be `.instantiateRev`d)</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">_root_.Lean.Meta.CasesOnApp.transform</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">CasesOnApp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">lambdaTelescope</span> <span class=\"n\">c.motive</span> <span class=\"k\">fun</span> <span class=\"n\">motiveArgs</span> <span class=\"n\">_motiveBody</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">unless</span> <span class=\"n\">motiveArgs.size</span> <span class=\"bp\">==</span> <span class=\"n\">c.indices.size</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"k\">do</span>\n      <span class=\"n\">throwError</span> <span class=\"s2\">\"failed to add argument to `casesOn` application, motive must be lambda expression with #{c.indices.size + 1} binders\"</span>\n    <span class=\"k\">let</span> <span class=\"n\">discrs</span> <span class=\"o\">:=</span> <span class=\"n\">c.indices</span> <span class=\"bp\">++</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">c.major</span><span class=\"o\">]</span>\n    <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">eAbst</span> <span class=\"o\">:=</span> <span class=\"n\">e</span>\n    <span class=\"n\">for</span> <span class=\"n\">motiveArg</span> <span class=\"k\">in</span> <span class=\"n\">motiveArgs.reverse</span><span class=\"o\">,</span> <span class=\"n\">discr</span> <span class=\"k\">in</span> <span class=\"n\">discrs.reverse</span> <span class=\"k\">do</span>\n      <span class=\"n\">eAbst</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">kabstract</span> <span class=\"n\">eAbst</span> <span class=\"n\">discr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">instantiate1</span> <span class=\"n\">motiveArg</span>\n    <span class=\"c1\">-- Up to this point, this is cargo-culted from `CasesOn.App.addArg`</span>\n    <span class=\"c1\">-- Let's create something Prop-typed that mentions `e`, by writing `e = e`.</span>\n    <span class=\"k\">let</span> <span class=\"n\">eEq</span> <span class=\"bp\">←</span> <span class=\"n\">mkEq</span> <span class=\"n\">eAbst</span> <span class=\"n\">eAbst</span>\n    <span class=\"k\">let</span> <span class=\"n\">motive</span> <span class=\"bp\">←</span> <span class=\"n\">mkLambdaFVars</span> <span class=\"n\">motiveArgs</span> <span class=\"n\">eEq</span>\n    <span class=\"k\">let</span> <span class=\"n\">us</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">c.propOnly</span> <span class=\"k\">then</span> <span class=\"n\">c.us</span> <span class=\"k\">else</span> <span class=\"n\">levelZero</span> <span class=\"o\">::</span> <span class=\"n\">c.us.tail</span><span class=\"bp\">!</span>\n    <span class=\"c1\">-- Now instantiate the casesOn wth this synthetic motive</span>\n    <span class=\"k\">let</span> <span class=\"n\">aux</span> <span class=\"o\">:=</span> <span class=\"n\">mkAppN</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"n\">c.declName</span> <span class=\"n\">us</span><span class=\"o\">)</span> <span class=\"n\">c.params</span>\n    <span class=\"k\">let</span> <span class=\"n\">aux</span> <span class=\"o\">:=</span> <span class=\"n\">mkApp</span> <span class=\"n\">aux</span> <span class=\"n\">motive</span>\n    <span class=\"k\">let</span> <span class=\"n\">aux</span> <span class=\"o\">:=</span> <span class=\"n\">mkAppN</span> <span class=\"n\">aux</span> <span class=\"n\">discrs</span>\n    <span class=\"n\">check</span> <span class=\"n\">aux</span>\n    <span class=\"k\">let</span> <span class=\"n\">auxType</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">aux</span>\n    <span class=\"c1\">-- The type of the remaining arguments will mention `e` instantiated for each arg</span>\n    <span class=\"c1\">-- so extract them</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">altAuxs</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.Meta.forallMetaTelescope</span> <span class=\"n\">auxType</span>\n    <span class=\"k\">let</span> <span class=\"n\">altAuxTys</span> <span class=\"bp\">←</span> <span class=\"n\">altAuxs.mapM</span> <span class=\"n\">inferType</span>\n    <span class=\"k\">let</span> <span class=\"n\">res</span> <span class=\"bp\">←</span> <span class=\"n\">altAuxTys.mapM</span> <span class=\"k\">fun</span> <span class=\"n\">altAux</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">fvs</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">body</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.Meta.forallMetaTelescope</span> <span class=\"n\">altAux</span>\n      <span class=\"k\">let</span> <span class=\"n\">body</span> <span class=\"o\">:=</span> <span class=\"n\">body.getArg</span><span class=\"bp\">!</span> <span class=\"mi\">2</span>\n      <span class=\"c1\">-- and abstract over the parameters of the alternative again</span>\n      <span class=\"n\">Expr.abstractM</span> <span class=\"n\">body</span> <span class=\"n\">fvs</span>\n    <span class=\"n\">return</span> <span class=\"n\">res</span>\n</code></pre></div>",
        "id": 401207102,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1699552226
    },
    {
        "content": "<p>Besides the repeated <code>let aux :=</code> it doesn't seem crazy.</p>",
        "id": 401471517,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1699674174
    },
    {
        "content": "<p>Ha, and that's something I have carco-culted from the lean code:<br>\n<a href=\"https://github.com/leanprover/lean4/blob/baa4b68a71926a722b77d4ec2cba34bfc76cc5aa/src/Lean/Meta/CasesOn.lean#L74\">https://github.com/leanprover/lean4/blob/baa4b68a71926a722b77d4ec2cba34bfc76cc5aa/src/Lean/Meta/CasesOn.lean#L74</a></p>",
        "id": 401499626,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1699698237
    }
]