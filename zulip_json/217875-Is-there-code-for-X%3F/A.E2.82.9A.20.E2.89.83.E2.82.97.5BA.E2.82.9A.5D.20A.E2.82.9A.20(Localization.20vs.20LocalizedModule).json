[
    {
        "content": "<p>Suppose <code>p</code> is a prime ideal of <code>A</code>, do we have <code>LocalizedModule p.primeCompl A ≃ₗ[Localization p.primeCompl] Localization p.primeCompl</code>? i.e. <code>Aₚ ≃ₗ[Aₚ] Aₚ</code> but the first <code>Aₚ</code> is <code>LocalizedModule</code> while the second is <code>Localization</code>.</p>\n<p>It could be constructed by <code>LocalizedModule.equivTensorProduct p.primeCompl A ≪≫ₗ TensorProduct.AlgebraTensorModule.rid _ _ _</code>. But it's better if it is in mathlib and has more properties.</p>\n<p>For example, I need <code>Aₚ / pAₚ ≃ₗ[Aₚ] Aₚ / pAₚ</code> where the first <code>pAₚ</code> is <code>Submodule.localized p.primeCompl p</code> while the second is <code>IsLocalRing.maximalIdeal (Localization p.primeCompl)</code> (or something else equal to this). To do this I need to use the above isomorphism together with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.Quotient.equiv#doc\">docs#Submodule.Quotient.equiv</a>. Then I need to check some trivial but tedious things.</p>\n<p>This is happen in <a href=\"https://github.com/acmepjz/lean-iwasawa/blob/dca0cd3a332776e7b2aa232764b26d3cc4426d6a/Iwasawalib/RingTheory/CharacteristicIdeal/Basic.lean#L399\">https://github.com/acmepjz/lean-iwasawa/blob/dca0cd3a332776e7b2aa232764b26d3cc4426d6a/Iwasawalib/RingTheory/CharacteristicIdeal/Basic.lean#L399</a> and subsequent lines.</p>\n<p>Does anyone have better solution for this?</p>",
        "id": 513056948,
        "sender_full_name": "Jz Pan",
        "timestamp": 1744991966
    },
    {
        "content": "<p>I really wanted to make the two defeq but I gave up. If you need to you could try to redo <a href=\"https://github.com/leanprover-community/mathlib4/pull/13156\">#13156</a> (or I could try again if I have some time).</p>",
        "id": 513057533,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1744992169
    },
    {
        "content": "<p>From the current design they cannot be defeq since <code>Localization</code> is more general (it works for non-rings?).</p>\n<p>I think maybe one solution is add an <code>IsLocalizedModule</code> property to <code>Localization</code>, then one can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsLocalizedModule.mapEquiv#doc\">docs#IsLocalizedModule.mapEquiv</a> to construct this <code>Aₚ</code>-linear isomorphism (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsLocalizedModule.iso#doc\">docs#IsLocalizedModule.iso</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsLocalizedModule.linearEquiv#doc\">docs#IsLocalizedModule.linearEquiv</a> are similar but they are only <code>A</code>-linear).</p>",
        "id": 513058278,
        "sender_full_name": "Jz Pan",
        "timestamp": 1744992456
    },
    {
        "content": "<p>The current <code>Localization</code> (or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OreLocalization#doc\">docs#OreLocalization</a>) allows you to localize a set with a monoid acting on it and both localization of rings and modules are a specific instance of this.</p>",
        "id": 513058789,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1744992647
    },
    {
        "content": "<p>But currently the right way might be</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submonoid</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LocalizedModule</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">Localization</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Localization</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">IsLocalizedModule</span><span class=\"bp\">.</span><span class=\"n\">linearEquiv</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LocalizedModule</span><span class=\"bp\">.</span><span class=\"n\">mkLinearMap</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">linearMap</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">|&gt;.</span><span class=\"n\">extendScalarsOfIsLocalization</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>",
        "id": 513058919,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1744992701
    },
    {
        "content": "<p>Or maybe one can use this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span><span class=\"w\"> </span><span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submonoid</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">LocalizedModule</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">Localization</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Localization</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">IsLocalizedModule.mapEquiv</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LocalizedModule.mkLinearMap</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Algebra.linearMap</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Localization</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LinearEquiv.refl</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Does it have better <code>apply</code> lemmas?</p>",
        "id": 513060706,
        "sender_full_name": "Jz Pan",
        "timestamp": 1744993472
    },
    {
        "content": "<p>Give up. Seems that my original approach has slightly shorter code.</p>",
        "id": 513063586,
        "sender_full_name": "Jz Pan",
        "timestamp": 1744994671
    }
]