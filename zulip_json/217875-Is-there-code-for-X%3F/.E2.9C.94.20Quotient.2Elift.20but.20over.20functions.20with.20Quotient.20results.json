[
    {
        "content": "<p>I'm looking for a computable version of (or a way to construct it):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Quotient.liftf</span> <span class=\"o\">[</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">pf</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">≈</span> <span class=\"n\">g</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Quotient</span> <span class=\"n\">s</span><span class=\"o\">):</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">out</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I think this is theoretically sound, since no matter what representatives we happen to come in on we should end up with the same result. Or is there something about infinite types that makes this unsound (conceivably we could extend the lift₂ to cover any finite β)?</p>",
        "id": 406628983,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1701986862
    },
    {
        "content": "<p>I think this is the one that's only computable for finite <code>β</code></p>",
        "id": 406629403,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701987041
    },
    {
        "content": "<p>Do you have intuition for why that would be? My understanding is that the reason \"Quotient.out\" is non-computable is because you aren't really guaranteed to computably get a \"canonical\" representative. But if any representative will still work for equality purposes (as demonstrated by \"pf\") then what does it matter?</p>",
        "id": 406629865,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1701987279
    },
    {
        "content": "<p><a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/quotient.2Elift_on_family/near/286096782\">this thread</a> is the one I'm thinking of</p>",
        "id": 406631598,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701988214
    },
    {
        "content": "<p>That does seem relevant, although I still don’t quite understand the punch line. Mechanically if “m” is computable then it necessarily only looks at a finite projection of “f”, and so can’t we do the finite choice mechanically.</p>",
        "id": 406632680,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1701988817
    },
    {
        "content": "<p>There is <a href=\"#narrow/stream/287929-mathlib4/topic/Should.20we.20merge.20.60Quotient.2Eout.60.20and.20.60Quotient.2Eunquot.60.3F/near/390172327\">another thread</a> which shows that <code>def foo (f : β → Trunc α) : Trunc (β → α)</code> is not consistent (or rather IIRC it makes the compiler inconsistent with the logic, this is a construction due to <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> )</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Quot</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Quotient.liftf</span> <span class=\"o\">[</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">pf</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">≈</span> <span class=\"n\">g</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Quotient</span> <span class=\"n\">s</span><span class=\"o\">):</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cast</span> <span class=\"gr\">sorry</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">uhoh</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Trunc</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Trunc</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Quotient.liftf</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">trueSetoid</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Quotient.mk</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Quotient.sound</span> <span class=\"o\">⟨⟩)</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">uhoh'</span> <span class=\"o\">:</span> <span class=\"n\">Trunc</span> <span class=\"o\">(</span><span class=\"n\">Trunc</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">uhoh</span> <span class=\"n\">id</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">exoticInstance</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">True</span> <span class=\"o\">:=</span>\n  <span class=\"n\">uhoh'.recOnSubsingleton</span> <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">decidable_of_iff</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⟦</span><span class=\"n\">false</span><span class=\"bp\">⟧</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">⟦</span><span class=\"n\">true</span><span class=\"bp\">⟧</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">iff_true_intro</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">Quotient.sound</span> <span class=\"n\">trivial</span><span class=\"o\">)))</span>\n\n<span class=\"c1\">-- VM disagrees with type theory:</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">decide</span> <span class=\"n\">True</span> <span class=\"n\">exoticInstance</span> <span class=\"bp\">=</span> <span class=\"n\">true</span>  <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">congr</span><span class=\"o\">)</span> <span class=\"n\">decide_True</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">decide</span> <span class=\"n\">True</span> <span class=\"n\">exoticInstance</span> <span class=\"bp\">=</span> <span class=\"n\">false</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">native_decide</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">exoticInstance</span> <span class=\"c1\">-- isFalse _</span>\n\n<span class=\"c1\">-- let's use this to crash lean</span>\n<span class=\"kd\">@[</span><span class=\"n\">noinline</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">True</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">trivial</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"k\">#eval</span> <span class=\"bp\">@</span><span class=\"n\">dite</span> <span class=\"n\">_</span> <span class=\"n\">True</span> <span class=\"n\">exoticInstance</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">foo</span>\n</code></pre></div>",
        "id": 406724418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702029523
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"562941\">@Andrew Carter</span></p>",
        "id": 406726352,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702030112
    },
    {
        "content": "<p>Honestly I think we should put this into <code>Counterexamples</code> because it is quite natural, it comes up once a year</p>",
        "id": 406726539,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702030167
    },
    {
        "content": "<p>This hurts my brain, but I think I've finally wrapped my head around it I think.<br>\nIntuitively this example seems super weird to me since, I'm pretty sure lift₂ can be extended to liftFin</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Quotient.liftFin</span> <span class=\"o\">[</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">pf</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">≈</span> <span class=\"n\">g</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">Quotient</span> <span class=\"n\">s</span><span class=\"o\">):</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cast</span> <span class=\"gr\">sorry</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>and correspondingly to Fintype</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Quotient.liftFin</span> <span class=\"o\">[</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">pf</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">≈</span> <span class=\"n\">g</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Quotient</span> <span class=\"n\">s</span><span class=\"o\">):</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cast</span> <span class=\"gr\">sorry</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>(although if I'm wrong somebody should let me know).</p>\n<p>And in fact we can construct uhoh in multiple ways, f.x.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">uhoh_t</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">Trunc</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Trunc</span> <span class=\"n\">Bool</span><span class=\"o\">):</span> <span class=\"n\">Trunc</span> <span class=\"o\">(</span><span class=\"n\">Trunc</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Quotient.liftOn</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⟦</span><span class=\"n\">True</span><span class=\"bp\">⟧</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"bp\">⟦λ</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">b</span><span class=\"bp\">⟧</span><span class=\"o\">)</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">Quotient.sound</span> <span class=\"n\">trivial</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">uhoh_f</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">Trunc</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Trunc</span> <span class=\"n\">Bool</span><span class=\"o\">):</span> <span class=\"n\">Trunc</span> <span class=\"o\">(</span><span class=\"n\">Trunc</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Quotient.liftOn</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⟦</span><span class=\"n\">False</span><span class=\"bp\">⟧</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"bp\">⟦λ</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">b</span><span class=\"bp\">⟧</span><span class=\"o\">)</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">Quotient.sound</span> <span class=\"n\">trivial</span>\n</code></pre></div>\n<p>and the weird thing to me is that <code>Trunc (Trunc Bool → Bool)</code> is a subsingleton so necessarily uhoh = uhoh_t = uhoh_f, which is kind of wild then that uhoh is bad but uhoh_t and uhoh_f are good.</p>\n<p>But if my understanding is correct, the root problem is that uhoh doesn't actually wrap a function, i.e. for the \"same\" inputs it has different outputs. And this is exploited in \"exoticInstance\" by passing in [[false]] and [[true]].</p>\n<p>Thus the fintype version actually seems like it kind of lucks out. I could imagine a <code>(f: Fin 1 -&gt; Trunc Bool)</code> function that returns <code>[[True]]</code> the first time its called in the VM and <code>[[False]]</code> the second time (although I don't think I could construct this in Lean). Or even simpler:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- randomly returns either a or b</span>\n<span class=\"kd\">def</span> <span class=\"n\">random</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">schrodinger</span><span class=\"o\">:</span> <span class=\"n\">Trunc</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">random</span> <span class=\"bp\">⟦</span><span class=\"n\">True</span><span class=\"bp\">⟧</span> <span class=\"bp\">⟦</span><span class=\"n\">False</span><span class=\"bp\">⟧</span> <span class=\"o\">(</span><span class=\"n\">Quotient.sound</span> <span class=\"n\">trivial</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">uhoh</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">Trunc</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Trunc</span> <span class=\"n\">Bool</span><span class=\"o\">):</span> <span class=\"n\">Trunc</span> <span class=\"o\">(</span><span class=\"n\">Trunc</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Quotient.liftOn</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">schrodinger</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"bp\">⟦λ</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">b</span><span class=\"bp\">⟧</span><span class=\"o\">)</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">Quotient.sound</span> <span class=\"n\">trivial</span>\n</code></pre></div>\n<p>In current Lean4 \"random\" always returns \"a\" (and thus shrodinger is always <code>[[True]]</code>), but does this logically have to be the case? Why is a VM that changes which \"equal\" value it returns (f.x. for performance reasons based on register allocation) problematic.</p>\n<p>I think <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> and <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> conclusively answered the question, but now I'm left with an epistemological hole in my understanding of quotients.</p>",
        "id": 406985045,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1702166438
    },
    {
        "content": "<p>We do want to allow things like <code>schrodinger</code> to exist. We can already create such things using pointer equality:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"mi\">64</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"c1\">-- to ensure it is not stored inline</span>\n<span class=\"kd\">def</span> <span class=\"n\">schrodinger</span><span class=\"o\">:</span> <span class=\"n\">Trunc</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"n\">withPtrAddr</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">addr</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Trunc.mk</span> <span class=\"o\">(</span><span class=\"n\">addr</span> <span class=\"bp\">=</span> <span class=\"mi\">94672111005448</span><span class=\"o\">))</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Subsingleton.elim</span> <span class=\"bp\">..</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">schrodinger.unquot</span> <span class=\"c1\">-- true for me, probably not for you</span>\n</code></pre></div>",
        "id": 406989633,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702169546
    },
    {
        "content": "<p>But it's consistently true or false for a given VM session, right? If it wasn't then you could write uhoh and have it break</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">f</span> <span class=\"bp\">⟦</span><span class=\"n\">false</span><span class=\"bp\">⟧</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">⟦</span><span class=\"n\">true</span><span class=\"bp\">⟧</span>\n</code></pre></div>\n<p>or even</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">f</span> <span class=\"bp\">⟦</span><span class=\"n\">true</span><span class=\"bp\">⟧</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">⟦</span><span class=\"n\">true</span><span class=\"bp\">⟧</span>\n</code></pre></div>\n<p>since schrodinger's truthiness isn't dependent on the input at all. Although I wonder if I can break it with a \"Fin 1\" version of withPtrAddr</p>",
        "id": 406990253,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1702169971
    },
    {
        "content": "<p>I don't think your <code>uhoh</code> creates the problematic situation, because it evaluates <code>schrodinger</code> once to get a bool, then returns a closure<code>λ _ ↦ b</code> with that bool</p>",
        "id": 406990444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702170060
    },
    {
        "content": "<p>so this closure will always return the same result even if <code>schrodinger</code> is somehow nondeterministic on subsequent evaluations</p>",
        "id": 406990507,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702170085
    },
    {
        "content": "<p>and as you say, I don't even think this level of nondeterminism is possible, it always returns the same value in a given VM session</p>",
        "id": 406990643,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702170127
    },
    {
        "content": "<p>specifically, a <code>@Quotient A _</code> is stored as a value of type <code>A</code>, so a <code>Quotient Bool</code> is just a <code>Bool</code>, it has no re-evaluation semantic</p>",
        "id": 406990747,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702170171
    },
    {
        "content": "<p>you would need a function type to have a re-evaluation semantic, and that function is required to be... functional</p>",
        "id": 406990812,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702170197
    },
    {
        "content": "<p>as you correctly pointed out the <code>Trunc Bool -&gt; Bool</code> wrapped by the original <code>uhoh</code> is not a proper function</p>",
        "id": 406990885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702170234
    },
    {
        "content": "<p>it violates a property that lean knows is true of all functions, namely that equal inputs imply equal outputs</p>",
        "id": 406990980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702170278
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"562941\">Andrew Carter</span> has marked this topic as resolved.</p>",
        "id": 407023422,
        "sender_full_name": "Notification Bot",
        "timestamp": 1702194697
    }
]