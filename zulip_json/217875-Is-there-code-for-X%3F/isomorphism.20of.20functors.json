[
    {
        "content": "<p>Is there a way to say two functors are isomorphic? That is, given two functors <code>F</code> and <code>G</code> I want the type of natural isomorphisms between <code>F</code> and <code>G</code>. This is talking about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LawfulFunctor#doc\">docs#LawfulFunctor</a>, not those category-theory functors. Ideally I would want this to be as universe-polymorphic as possible, so the domain and codomain of <code>F</code> and <code>G</code> can be four different universes (I guess if they're in different universes this would be saying the one functor naturally extends the other functor into the higher universe).</p>",
        "id": 558067583,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763500376
    },
    {
        "content": "<p>Have you considered turning the Type functors into category theory functors, then use categorical isomorphisms?</p>",
        "id": 558068471,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1763500716
    },
    {
        "content": "<p>that sound like a lot of work and also not universe polymorphic</p>",
        "id": 558068535,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763500749
    },
    {
        "content": "<p>I agree, but whether universe polymorphism is worth fighting for depends on your application: What's your application?</p>",
        "id": 558068618,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1763500787
    },
    {
        "content": "<p>To be clear, my suggestion works today:</p>",
        "id": 558068778,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1763500856
    },
    {
        "content": "<p>For defining <a href=\"https://vihdzp.github.io/combinatorial-games/find/?pattern=GameFunctor#doc\">CGT#GameFunctor</a></p>",
        "id": 558068787,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763500860
    },
    {
        "content": "<p>@loogle Functor, CategoryTheory.Functor</p>",
        "id": 558068851,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1763500876
    },
    {
        "content": "<p>well not the definition but using the fact that it's a quotient of a polynomial functor</p>",
        "id": 558068916,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763500897
    },
    {
        "content": "<p>Can you clearly say what two functors you want to state are isomorphic?</p>",
        "id": 558069071,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1763500961
    },
    {
        "content": "<p>The <a href=\"https://vihdzp.github.io/combinatorial-games/find/?pattern=GameFunctor#doc\">CGT#GameFunctor</a> and the quotient of the polynomial functor in the QPF instance we put on it</p>",
        "id": 558069230,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763501015
    },
    {
        "content": "<p>across all the universes</p>",
        "id": 558069289,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763501038
    },
    {
        "content": "<p>Great, but can you give their types? I see <code>GameFunctor : Type (u + 1) -&gt; Type (u + 1)</code>. What about the other one?</p>",
        "id": 558070973,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1763501668
    },
    {
        "content": "<p>not sure why loogle didn't work above but I'm guessing Yael was trying to surface <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.ofTypeFunctor#doc\">docs#CategoryTheory.ofTypeFunctor</a></p>",
        "id": 558071656,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763501939
    },
    {
        "content": "<p>probably I think it will be <code>Type v -&gt; Type (max v (u + 1))</code></p>",
        "id": 558071749,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763501977
    },
    {
        "content": "<p><code>ofTypeFunctor</code> seems to support universe polymorphic functors? but I could be misreading it</p>",
        "id": 558071895,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763502028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/isomorphism.20of.20functors/near/558068851\">said</a>:</p>\n<blockquote>\n<p>@loogle Functor, CategoryTheory.Functor</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> Functor, CategoryTheory.Functor</p>",
        "id": 558071902,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763502029
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Types/Basic.html#CategoryTheory.ofTypeFunctor\">CategoryTheory.ofTypeFunctor</a></p>",
        "id": 558071906,
        "sender_full_name": "loogle",
        "timestamp": 1763502030
    },
    {
        "content": "<p>yeah, that's what I thought</p>",
        "id": 558071938,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763502048
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/isomorphism.20of.20functors/near/558071895\">said</a>:</p>\n<blockquote>\n<p><code>ofTypeFunctor</code> seems to support universe polymorphic functors? but I could be misreading it</p>\n</blockquote>\n<p>But surely we don't support natural isomorphisms between functors with different source/target categories</p>",
        "id": 558072007,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763502080
    },
    {
        "content": "<p>so if I have a functor <code>Type u -&gt; Type v</code> and another one <code>Type u' -&gt; Type v'</code> then I don't expect to be able to state that they're compatible using the category theory machinery since they're different types</p>",
        "id": 558072163,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763502137
    },
    {
        "content": "<p>you're probably right but I would confirm by looking at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Functor.category#doc\">docs#CategoryTheory.Functor.category</a>, which is what you end up doing the iso in</p>",
        "id": 558072334,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763502193
    },
    {
        "content": "<p>yeah that's true, C and D are fixed</p>",
        "id": 558072424,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763502222
    },
    {
        "content": "<p>alright yeah, not universe polymorphic then</p>",
        "id": 558072480,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763502247
    },
    {
        "content": "<p>The battle tested way is to suitably compose with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.uliftFunctor#doc\">docs#CategoryTheory.uliftFunctor</a>.</p>",
        "id": 558143099,
        "sender_full_name": "Christian Merten",
        "timestamp": 1763541934
    },
    {
        "content": "<p>then I have ulifts everywhere</p>",
        "id": 558171686,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763550064
    },
    {
        "content": "<p>I guess it's not impossible to work with</p>",
        "id": 558171729,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763550075
    },
    {
        "content": "<p>so now I have to import category theory too?</p>",
        "id": 558171767,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763550089
    },
    {
        "content": "<p>Why do you need universes? Is it not enough to talk about your second functor when <code>v := u + 1</code>?</p>",
        "id": 558171995,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1763550156
    },
    {
        "content": "<p>For coinduction it took a lot of effort to make it universe polymorphic</p>",
        "id": 558172132,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763550196
    },
    {
        "content": "<p>so I'm thinking can I upstream some of this into <code>QPF</code> but then this requires refactoring it to be bundled</p>",
        "id": 558172316,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763550255
    },
    {
        "content": "<p>so I want to say that the bundled <code>QPF</code> is iso to the nicer description</p>",
        "id": 558172424,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763550294
    },
    {
        "content": "<p>What do you want to do with the isomorphism? What is its envisioned application?</p>",
        "id": 558172975,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1763550455
    },
    {
        "content": "<p>Transfer the coinduction principle across it</p>",
        "id": 558173096,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763550497
    },
    {
        "content": "<p>I guess another perspective would be transfer the cofixpoint across</p>",
        "id": 558173246,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763550546
    },
    {
        "content": "<p>The one functor has a terminal coalgebra so the other functor also does since it's isomorphic</p>",
        "id": 558173320,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763550569
    },
    {
        "content": "<p>oh and probably the same thing dually for the initial algebra</p>",
        "id": 558173408,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763550596
    },
    {
        "content": "<p>So do you really need a way to state the isomorphism? Why don't simply write down the natural transformation by hand both ways?</p>",
        "id": 558174389,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1763550852
    },
    {
        "content": "<p>That's the plan</p>",
        "id": 558174451,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763550870
    },
    {
        "content": "<p>I was hoping there would be a way to write lemmas about this though</p>",
        "id": 558174563,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763550908
    },
    {
        "content": "<p>lemmas which don't only apply to my one specific natiso</p>",
        "id": 558174618,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763550929
    },
    {
        "content": "<p>This seems to be a niche enough application that writing one off lemmas seems fine</p>",
        "id": 558174707,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1763550946
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/isomorphism.20of.20functors/near/558143099\">said</a>:</p>\n<blockquote>\n<p>The battle tested way is to suitably compose with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.uliftFunctor#doc\">docs#CategoryTheory.uliftFunctor</a>.</p>\n</blockquote>\n<p>I don't think that works, because the source categories are also in different universes, and ulift only lifts up so the direction of composition means I can only push these source universes down, which loses information about what happens to big types</p>",
        "id": 558175281,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763551109
    },
    {
        "content": "<p>there's also no good candidate for which universe I would descend to, there's no universe min like there is a max</p>",
        "id": 558175420,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763551157
    }
]