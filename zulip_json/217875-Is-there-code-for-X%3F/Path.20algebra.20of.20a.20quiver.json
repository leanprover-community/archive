[
    {
        "content": "<p>I might be interested in working with the path algebra of a quiver. I know that paths of a quiver are already defined, but I cannot find a definition of the path algebra. I guess it should be possible to define a <code>MonoidWithZero</code> instance on the total type of paths (with <code>0</code> adjoined), provided the type underlying the quiver has decidable equality. But I am not sure whether there is already something for the \"MonoidWithZero\" algebra of a monoid with zero.</p>\n<p>Edit: <code>SemigroupWithZero</code>is more appropriate, see discussion below</p>",
        "id": 497858148,
        "sender_full_name": "Bernhard Reinke",
        "timestamp": 1738751266
    },
    {
        "content": "<p>Can you compose arbitrary paths in a quiver? There's no endpoint requirement? And is 0 not the identity of the monoid? In a monoid with 0 we have <code>0*x=0</code>, not <code>0*x=x</code></p>",
        "id": 497866179,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738753611
    },
    {
        "content": "<p>The definition of a path algebra that I know is that <code>p*q = 0</code> if p and q are not composable. The algebra has an identity element if V is finite, it should be the sum of all paths of length 0 (so the sum of the idempotents associated to the vertices of the quiver)</p>",
        "id": 497875520,
        "sender_full_name": "Bernhard Reinke",
        "timestamp": 1738756723
    },
    {
        "content": "<p>I'm still a bit confused about something. You said at the end that you wanted to take the \"monoid with zero algebra of a monoid with zero\". What is the latter monoid with zero? I was just saying that paths don't form a monoid with zero.</p>",
        "id": 497876794,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738757093
    },
    {
        "content": "<p>I think Bernhard wants <code>0</code> to be an extra element not corresponding to any path</p>",
        "id": 497881233,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1738758482
    },
    {
        "content": "<p>This feels related to the isomorphism between the categories of pointed types with point-preserving functions and usual types with partial functions</p>",
        "id": 497881424,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1738758540
    },
    {
        "content": "<p>But adding a zero to the (sigma type of) all paths in a quiver does not make it into a monoid with zero -- what is the 1? I'm just confused about relating the path algebra story (which I think I understand) into \"monoid with zero algebra of a monoid with zero\"</p>",
        "id": 497882185,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738758789
    },
    {
        "content": "<p>It seems more accurate to say something like \"semiring non-unital algebra associated to some kind of semigroup with zero thing\"</p>",
        "id": 497882582,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738758914
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Path.20algebra.20of.20a.20quiver/near/497882185\">said</a>:</p>\n<blockquote>\n<p>what is the 1?</p>\n</blockquote>\n<p>Right, that is the issue, I think</p>",
        "id": 497882916,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1738759035
    },
    {
        "content": "<p>Ah, sorry for the confusion, yes, semigroup with zero would be more appropriate</p>",
        "id": 497882981,
        "sender_full_name": "Bernhard Reinke",
        "timestamp": 1738759063
    },
    {
        "content": "<p>I found <a href=\"https://www.math.uni-bielefeld.de/~sek/kau/leit4.pdf\">this</a> which says</p>\n<blockquote>\n<p>Definition: Let kQ be the vector space with basis the set of all paths in Q, and with the following multiplication: if w, w′ are paths, let ww′ be the concatenation of w and w ′ provided the tail of w is the head of w ′ , and the zero vector otherwise, and extend this multiplication bilinearly to kQ.</p>\n</blockquote>",
        "id": 497883076,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1738759088
    },
    {
        "content": "<p>It looks like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MonoidAlgebra#doc\">docs#MonoidAlgebra</a></p>",
        "id": 497883166,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1738759121
    },
    {
        "content": "<p>Well I am a little concerned about this claim because if you add the zero to the paths first (which you need to do to get the multiplication) then you'll have two zeros in the monoid algebra</p>",
        "id": 497884932,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738759683
    },
    {
        "content": "<p>I guess then my question would be if there is a variant of MonoidAlgebra for <code>SemigroupWithZero</code> where the zero element of the SemigroupWithZero is quotiented out. Probably one lemma in this direction would be that for a SemigroupWithZero, the subspace generated by the zero element of the semigroup is an ideal of the \"MonoidAlgebra\" (which is a priori non unital)</p>",
        "id": 497885045,
        "sender_full_name": "Bernhard Reinke",
        "timestamp": 1738759713
    },
    {
        "content": "<p>Fortunately, a viable approach to two sided ideals of semirings was merged yesterday, but I don't think we have this construction. Seems to me that there are two approaches. Firstly don't add the zero, then you have a partially defined associative multiplication on the paths, and you can define an associative multiplication on the \"monoid algebra\" this way because this type has a zero and you can define all bad multiplications to be this zero. Or you can add the zero to the paths first and then make the monoid algebra and then identify the two zeros by quotienting out by the two sided ideal. As far as I know we have neither of these constructions in mathlib.</p>",
        "id": 497885956,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738760020
    },
    {
        "content": "<p>My recently merged PR allows taking the quotient of a ring by a two-sided ideal. For quotients of semirings you still have to use RingCon. Not every ideal gives a equivalence relation / congruence in the obvious way.<br>\nIn this case the congruence would just ignore the 0th coordinate.</p>",
        "id": 497888573,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1738760800
    },
    {
        "content": "<p>Just to say that a slightly unconventional approach to the definition of path algebra that <em>might</em> be worth thinking about for formalization is that the path algebra of a quiver is the category algebra of the path category of that quiver.  Here, category algebra means the following:</p>\n<p>Let C be a small category and let R be a ring. The category algebra R[C] is the R-algebra whose underlying R-module is the free module over the set of morphisms of C and with multiplication defined on basis elements by m(q, p) = q ◦ p if defined and =0 otherwise, where p, q are morphisms in C.</p>\n<p>Since the group algebra is the category algebra of the associated 1-object groupoid, the notion of a category algebra would be reusable.</p>",
        "id": 497903391,
        "sender_full_name": "Jan Grabowski",
        "timestamp": 1738764986
    },
    {
        "content": "<p>I guess if one wants to be more general one can also construct the category ring of a preadditive category</p>",
        "id": 497905114,
        "sender_full_name": "Bernhard Reinke",
        "timestamp": 1738765440
    },
    {
        "content": "<p>This looks perfect, except that another thing now occurs to me: now you're talking about categories rather than quivers, I guess I'm realising that probably quiver is probably way too general. You can't even compose paths in quiver if the target of the first equals the source of the second, right? So what does \"composable\" even mean in</p>\n<blockquote>\n<p>The definition of a path algebra that I know is that <code>p*q = 0</code> if p and q are not composable.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"562819\">@Bernhard Reinke</span> ? You would surely need at least what Lean calls a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.CategoryStruct#doc\">docs#CategoryTheory.CategoryStruct</a> (which supplies the data of composition) to make any sense of this multiplication.</p>\n<p>So it seems like this is a variant of MonoidAlgebra and should probably follow the pattern of MonoidAlgebra, i.e. don't assume <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is a ring or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is monoid when defining <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mi>M</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R[M]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">]</span></span></span></span>, and then assuming more structure on the the inputs gives you more structure on the outputs. In fact one might naively think that one can reuse MonoidAlgebra, but I think this is probably quite risky.</p>",
        "id": 497906245,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738765686
    },
    {
        "content": "<p>One could define <code>CategoryAlgebra R C</code> for <code>(C : Type*)</code> and <code>[Zero R]</code> as finitely-supported functions C -&gt; R (yet another alias for Finsupp with yet another multiplication) and then if <code>[Add R]</code> you get <code>[Add CategoryAlgebra R C]</code> and if furthermore <code>[Mul R]</code> and <code>CategoryStruct C</code> then you get <code>Mul (CategoryAlgebra R C)</code> etc. Then if <code>Category C</code> and <code>CommSemiring R</code> you get <code>Semiring (CategoryAlgebra R C)</code> etc etc.</p>",
        "id": 497907022,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738765891
    },
    {
        "content": "<p>But for quivers you'll have nothing more than <code>AddCommGroup (CategoryAlgebra R C)</code> even if <code>Field R</code>, because you can't compose paths in a quiver as far as I can see so you can't multiply anything other than elements of R.</p>",
        "id": 497907377,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738765979
    },
    {
        "content": "<p>We know paths in a quiver form a category: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/PathCategory/Basic.html#CategoryTheory.Paths.categoryPaths\">CategoryTheory.Paths.categoryPaths</a></p>",
        "id": 497907573,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1738766042
    },
    {
        "content": "<p>To compose composable paths it looks like you need to insert some eqToHom though.</p>",
        "id": 497907887,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1738766123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Path.20algebra.20of.20a.20quiver/near/497906245\">said</a>:</p>\n<blockquote>\n<p>This looks perfect, except that another thing now occurs to me: now you're talking about categories rather than quivers, I guess I'm realising that probably quiver is probably way too general. You can't even compose paths in quiver if the target of the first equals the source of the second, right? So what does \"composable\" even mean in</p>\n<blockquote>\n<p>The definition of a path algebra that I know is that <code>p*q = 0</code> if p and q are not composable.<br>\n</p>\n</blockquote>\n</blockquote>\n<p>I think in more category theoretic terms, the path category of a quiver is the free category over a quiver (every category becomes a quiver by forgetting composition, and the path category is left adjoint to that). So you can compose paths in a quiver as you would expect from a category</p>",
        "id": 497908086,
        "sender_full_name": "Bernhard Reinke",
        "timestamp": 1738766181
    },
    {
        "content": "<p>There is also <code>Path.comp</code></p>",
        "id": 497908134,
        "sender_full_name": "Bernhard Reinke",
        "timestamp": 1738766197
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Path.20algebra.20of.20a.20quiver/near/497907887\">said</a>:</p>\n<blockquote>\n<p>To compose composable paths it looks like you need to insert some eqToHom though.</p>\n</blockquote>\n<p>that is probably the way to go if one wants to do this via categories. For quivers there is also <code>Quiver.Cast</code> but I don't think there is an direct analogue of <code>eqToHom</code> there</p>",
        "id": 497909923,
        "sender_full_name": "Bernhard Reinke",
        "timestamp": 1738766671
    },
    {
        "content": "<p>Yes. Quivers doesn't have identity morphisms so eqToHom can't be defined. Here's a construction of the SemigroupWithZero; you probably want to directly construct an Algebra from the Semigroup instead of needlessly adjoining a zero element though.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">GroupWithZero</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Group</span><span class=\"bp\">.</span><span class=\"n\">WithOne</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">PathCategory</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">SemigroupWithZero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">WithZero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Paths</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Paths</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">eqToHom</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">mul_assoc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">zero_mul</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">mul_zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨⟩</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 497911850,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1738767162
    },
    {
        "content": "<p>So the path algebra of a quiver is then the category algebra of the path category of a quiver, this is less general than the category algebra of any category. What I was saying is that you can go even one step further: if you have a category field (probably semiring is enough) <code>k</code>, you can also consider the \"free <code>k</code>-linear category\" of it, where you replace every hom set by the free <code>k</code>-module generated by it, and extend composition bilinearly. You should be able to define the category algebra of a <code>k</code>-linear category, and the path algebra of a quiver is then the category algebra of the free <code>k</code>-linear category of the free category of the quiver.</p>",
        "id": 497912497,
        "sender_full_name": "Bernhard Reinke",
        "timestamp": 1738767324
    },
    {
        "content": "<p>I agree we should do things in that generality. (I'm mostly writing this as a demo to show Kevin.) It's less clear whether we want to refactor the existing MonoidAlgebra because defeq is worse. (To keep the current generality, we could define multiplication assuming only <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.CategoryStruct#doc\">docs#CategoryTheory.CategoryStruct</a>, and then show it's associative when we have a category.) Another issue is that mathlib apparently doesn't have nonunital algebras yet, which path algebras can be.</p>",
        "id": 497914582,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1738767836
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Path.20algebra.20of.20a.20quiver/near/497911850\">said</a>:</p>\n<blockquote>\n<p>Yes. Quivers doesn't have identity morphisms so eqToHom can't be defined. Here's a construction of the SemigroupWithZero; you probably want to directly construct an Algebra from the Semigroup instead of needlessly adjoining a zero element though.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">GroupWithZero</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Group</span><span class=\"bp\">.</span><span class=\"n\">WithOne</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">PathCategory</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">SemigroupWithZero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">WithZero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Paths</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Paths</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">eqToHom</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">mul_assoc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">zero_mul</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">mul_zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨⟩</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thanks for the stub! Regarding <code>eqToHom</code>, I meant something using <code>Quiver.Path</code>, not the path category. You can of course define something of the form<code>a = b -&gt; Path a b</code>, but this is not in <code>Quiver.Cast</code>. Using the path category is probably cleaner</p>",
        "id": 497915053,
        "sender_full_name": "Bernhard Reinke",
        "timestamp": 1738767954
    },
    {
        "content": "<p>I think the way to go is defining a category algebra of a <code>k</code>-linear category. But I am not sure whether <code>k</code>-linear categories are already in mathlib</p>",
        "id": 497915482,
        "sender_full_name": "Bernhard Reinke",
        "timestamp": 1738768053
    },
    {
        "content": "<p>Oh, they are : <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Linear#doc\">docs#CategoryTheory.Linear</a></p>",
        "id": 497919759,
        "sender_full_name": "Bernhard Reinke",
        "timestamp": 1738769220
    },
    {
        "content": "<p>But I haven't found the free linear category of a category yet</p>",
        "id": 497920891,
        "sender_full_name": "Bernhard Reinke",
        "timestamp": 1738769512
    },
    {
        "content": "<p>The path algebra of a quiver can be defined without ever using the word \"path\". It can be generated as an algebra by generators <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>x</mi><mi>v</mi></msub></mrow><annotation encoding=\"application/x-tex\">x_v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>y</mi><mi>e</mi></msub></mrow><annotation encoding=\"application/x-tex\">y_e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> ranges over all vertices and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">e</span></span></span></span> ranges over all edges. It is not too difficult to write down the necessary relations. You may find this approach easier.</p>",
        "id": 497945889,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1738776312
    },
    {
        "content": "<p>See Problem 2.8.6 here: <a href=\"https://math.mit.edu/~etingof/reprbook.pdf\">https://math.mit.edu/~etingof/reprbook.pdf</a></p>",
        "id": 497946146,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1738776397
    },
    {
        "content": "<p>With this approach, it is probably easier to prove the key theorem that the category of representations of a quiver is equivalent to the category of representations of its path algebra.</p>",
        "id": 497946658,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1738776581
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"562819\">Bernhard Reinke</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Path.20algebra.20of.20a.20quiver/near/497920891\">said</a>:</p>\n<blockquote>\n<p>But I haven't found the free linear category of a category yet</p>\n</blockquote>\n<p><a href=\"https://leansearch.net/?q=The%20free%20linear%20category%20on%20a%20category%3F\">https://leansearch.net/?q=The%20free%20linear%20category%20on%20a%20category%3F</a></p>",
        "id": 498010164,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1738802433
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Free#doc\">docs#CategoryTheory.Free</a></p>",
        "id": 498010210,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1738802469
    },
    {
        "content": "<p>I have created a WIP PR at <a href=\"https://github.com/leanprover-community/mathlib4/pull/22809\">#22809</a>. In particular the path algebra part is just the definition so far. For the category algebra I managed to prove associativity using distributivity, the most abstract part I put in the new file<code>Mathlib.Algebra.Ring.Assoc</code>. I don't know whether it deserves its own file, but maybe one can also start putting the theory of the associator (as in <code>(x*y)*z - x*(y*z)</code>for non-associative rings) there.</p>",
        "id": 504681104,
        "sender_full_name": "Bernhard Reinke",
        "timestamp": 1741638637
    },
    {
        "content": "<p>Does it make sense to split this into 3 PRs (one for <code>Mathlib.Algebra.Ring.Assoc</code>, one for <code>Mathlib.CategoryTheory.Linear.CategoryAlgebra</code>and one for the path algebra itself)?</p>",
        "id": 504681293,
        "sender_full_name": "Bernhard Reinke",
        "timestamp": 1741638710
    },
    {
        "content": "<p>Ok, the definition of the associator is now in <a href=\"https://github.com/leanprover-community/mathlib4/pull/22823\">#22823</a></p>",
        "id": 504797728,
        "sender_full_name": "Bernhard Reinke",
        "timestamp": 1741688707
    },
    {
        "content": "<p>Has there been any updates to this recently? I'm interested in quiver representations.</p>",
        "id": 576149704,
        "sender_full_name": "Niels Voss",
        "timestamp": 1772152826
    },
    {
        "content": "<p>Actually I believe what I actually need is the Category Algebra, discussed above, which there is an open PR for (also linked above)</p>",
        "id": 576164072,
        "sender_full_name": "Niels Voss",
        "timestamp": 1772158668
    }
]