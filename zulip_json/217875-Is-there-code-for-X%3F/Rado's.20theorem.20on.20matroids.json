[
    {
        "content": "<p>Do we have Rado's theorem on matroids, or at least its linear algebra incarnation, which says the following?</p>\n<p>Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> be a vector space over a field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span>, let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> be a finite set, and let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>Z</mi><mi>i</mi></msub><mo>⊆</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">Z_i \\subseteq V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">i \\in I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6986em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> be subsets such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>dim</mi><mo>⁡</mo><mo stretchy=\"false\">⟨</mo><msub><mo>⋃</mo><mrow><mi>j</mi><mo>∈</mo><mi>J</mi></mrow></msub><msub><mi>Z</mi><mi>j</mi></msub><mo stretchy=\"false\">⟩</mo><mo>≥</mo><mi mathvariant=\"normal\">#</mi><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">\\dim \\langle \\bigcup_{j \\in J} Z_j \\rangle \\ge \\#J</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mop\">dim</span><span class=\"mopen\">⟨</span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">⋃</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.09618em;\">J</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mclose\">⟩</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">#</span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span> for each subset <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>J</mi><mo>⊆</mo><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">J \\subseteq I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span>. Then there exists a linearly independent family in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∏</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub><msub><mi>Z</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\prod_{i \\in I} Z_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0771em;vertical-align:-0.3271em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">I</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3271em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</p>\n<p>Searching for \"Rado\" in mathlib seems to turn up only stuff on Radon-Nikodym measures...</p>",
        "id": 343266817,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1679368575
    },
    {
        "content": "<p>I suppose we have the special case of when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> has some fixed basis and each <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>Z</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">Z_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is the span of some subset of that basis, which is Hall's marriage theorem <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.all_card_le_bUnion_card_iff_exists_injective\">docs#finset.all_card_le_bUnion_card_iff_exists_injective</a></p>",
        "id": 343272362,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679372886
    },
    {
        "content": "<p>Yes; Hall's theorem is the special case when \"independent\" just means \"pairwise distinct\". But I need the more general version...</p>",
        "id": 343272611,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1679373074
    },
    {
        "content": "<p>Actually, I'm struggling a bit with how to formalize the statement. Should I use a <code>finset</code> for I? Then it seems that to write a union of <code>set</code>s indexed by a <code>finset</code>, I have to turn the <code>finset</code> into a <code>set</code>and I have to turn the cardinality of the <code>finset</code> into a <code>cardinal</code>. I could probably work with a <code>fintype</code> instead. Then I need to <code>open_locale classical</code> to be able to talk about the cardinality of <code>J :  set \\iota</code>. I'll see what works better, but also appreciate comments on the pros and cons.</p>",
        "id": 343273234,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1679373595
    },
    {
        "content": "<p>I haven't tested it, but I'd expect something in the neighborhood of this to capture what you'd want for the condition: <code>(Z : I → submodule F V) : ∀ (J : finset I), J.card ≤ module.rank (⨆ (i ∈ J), Z i)</code></p>",
        "id": 343274845,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679374755
    },
    {
        "content": "<p><code>⨆</code> is the supremum of the collection of subspaces, which is the subspace generated by the union of all of them.</p>",
        "id": 343274981,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679374832
    },
    {
        "content": "<p>Only that the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>Z</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">Z_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> are sub<em>sets</em>, not sub<em>spaces</em>, so my current attempt (in the <code>fintype</code> version) is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"kn\">open</span> <span class=\"n\">submodule</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">V</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">hall_condition</span> <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">fintype.card</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">module.rank</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">set.Union</span> <span class=\"o\">(</span><span class=\"n\">J.restrict</span> <span class=\"n\">Z</span><span class=\"o\">)))</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">rado</span> <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hZ</span> <span class=\"o\">:</span> <span class=\"n\">hall_condition</span> <span class=\"n\">F</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">Z</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">linear_independent</span> <span class=\"n\">F</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>(EDITED: condition <code>v i ∈ Z i</code> was missing.)<br>\n(Note that <code>module.rank</code> gives a <code>cardinal</code>.)</p>",
        "id": 343276117,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1679375454
    },
    {
        "content": "<p>Again untested, but you should be able to use notation for <code>set.Union</code> along with <code>finset</code> here, which can be easier to work with when you're doing cardinalities sometimes.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">hall_condition</span> <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"bp\">↑</span><span class=\"n\">J.card</span> <span class=\"bp\">≤</span> <span class=\"n\">module.rank</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"n\">Z</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>You can also use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.card\">docs#nat.card</a> instead of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.card\">docs#fintype.card</a> if you don't want to worry about <code>fintype</code> instances or computability.</p>",
        "id": 343278499,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679377104
    },
    {
        "content": "<p>Do you know if Rado's theorem is true when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> is infinite? I think the compactness theorem should apply, letting you lift a proof of the finite case to the arbitrary cardinality case. (This is what mathlib's Hall's theorem does.)</p>",
        "id": 343278640,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679377189
    },
    {
        "content": "<p>It probably extends in the same way. But I'll worry about that later...</p>",
        "id": 343278769,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1679377268
    },
    {
        "content": "<p>It's just a good reason to not rely on <code>ι</code> being finite when you state <code>hall_condition</code></p>",
        "id": 343278799,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679377302
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Rado's.20theorem.20on.20matroids/near/343276117\">said</a>:</p>\n<blockquote>\n<p>Only that the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>Z</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">Z_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> are sub<em>sets</em>, not sub<em>spaces</em></p>\n</blockquote>\n<p>Where in the theorem statement does it depend on them being subsets and not subspaces? I'd switched them to subspaces because it didn't look like it mattered.</p>",
        "id": 343279111,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679377513
    },
    {
        "content": "<p>Oh, I got it, nevermind. I kept seeing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∏</mo><mi>i</mi></msub><msub><mi>Z</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\prod_i Z_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.162em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> as a vector space, not a product of sets.</p>",
        "id": 343279155,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679377545
    },
    {
        "content": "<p>Is there <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.finrank\">docs#module.finrank</a> ?</p>",
        "id": 343287782,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1679381919
    },
    {
        "content": "<p>It's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finite_dimensional.finrank\">docs#finite_dimensional.finrank</a></p>",
        "id": 343287916,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1679381990
    },
    {
        "content": "<p>I guess one decision to make here is whether to work with <code>set</code>s <code>Z i</code> or <code>finset</code>s <code>Z i</code>. I think only the latter version will generalize fairly easily to an infinite indexing type (a product of finite sets with the discrete topology is compact), but for a finite indexing type, general sets should be OK as well.</p>",
        "id": 343459943,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1679415550
    },
    {
        "content": "<p>It would probably make sense to define an abstract notion of \"independence\" (of families over a type) and prove the theorem in this context (this is what Rado does in his paper from 1942). Then one can specialize to Hall's theorem, linear independence, algebraic independence, what have you. I don't think I want to develop the general theory of matroids, though (which I don't really know anyway). What do you think?</p>",
        "id": 343460593,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1679415715
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span> has.</p>",
        "id": 343461371,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1679415905
    },
    {
        "content": "<p><a href=\"https://github.com/e45lee/lean-matroids\">https://github.com/e45lee/lean-matroids</a></p>\n<p>Currently under construction after 2 years growing stale. A lot of the basic matroid stuff is in there.</p>",
        "id": 343461916,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1679416046
    },
    {
        "content": "<p>Looking at your \"basic.lean\" file, I have the impression that you are carrying around a <code>[fintype E]</code> TC argument in most of what is done. This will be problematic for applications in (linear) algebra, as the relevant carrier sets can be infinite.</p>",
        "id": 343465461,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1679416920
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span> Do you have Rado's theorem somewhere?</p>",
        "id": 343466222,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1679417099
    },
    {
        "content": "<p>Not as such. It would follow pretty easily from the stuff in the intersection/union subfolder, but that's currently very broken. I'll get there soon though.</p>",
        "id": 343468433,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1679417603
    },
    {
        "content": "<p>My conclusion for now is that I'll implement a version that is good for what I need right now, with no intention to add that one to mathlib. But it would be nice if the result would make it into mahthlib(4) eventually as a part of matroids!</p>",
        "id": 343469608,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1679417902
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> How different is the proof of Rado's theorem from Hall's marriage theorem? I'm wondering if what's in mathlib can be suitably linearized, which might speed up your work. (At least the compactness argument is already there and not specialized too much to Hall's theorem.)</p>",
        "id": 343473104,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679418756
    },
    {
        "content": "<p>The proof I have in mind for the linear algebra setting should not be too hard to formalize (but it uses quotients of vector spaces, so maybe does not generalize to arbitrary matroids). (Aside: I came up with the proof before I found out that the result was a special case of Rado's theorem.) Rado's original proof is two pages long and does not look too bad either (but that is easy to say before actually trying to formalize it...).</p>",
        "id": 343475229,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1679419391
    },
    {
        "content": "<p>Rado is now done! See <a href=\"https://github.com/apnelson1/lean-matroids/blob/master/src/matroid/minmax/inter.lean\">https://github.com/apnelson1/lean-matroids/blob/master/src/matroid/minmax/inter.lean</a></p>",
        "id": 345709277,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1680189646
    },
    {
        "content": "<p>It's done purely matroidally - the project is not really set up for any interactions with linear algebra (yet). Hence it might be a little awkward to apply.</p>",
        "id": 345709635,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1680189722
    },
    {
        "content": "<p>After struggling for a while with the linear algebra API (as can be seen to some extent <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/subfamilies.20are.20linearly.20independent/near/344418378\">here</a>), I decided that the better way would be to build a proof of Rado's Theorem in the general setting of a rank function (on finite subsets of a not-necessarily-finite type) and then derive the result I want as a special case. This is what I have now done; see <a href=\"https://github.com/leanprover-community/mathlib/pull/18789\">#18789</a>.</p>",
        "id": 348273508,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1681149216
    },
    {
        "content": "<p>The proof is, I think, the standard proof, but I did it from scratch. I develop some theory of rank functions, independent families and sections of families of (finite) sets to be able to state ands prove things nicely.</p>",
        "id": 348273763,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1681149309
    },
    {
        "content": "<p>The PR is labeled \"WIP\" for now, since I'm not sure what the best way is to proceed relative to the port of mathlib. Most of what is in the PR is new material (and some of it depends on files that are not yet ported as of now), but, as usually happens, I found that I need a bunch of auxiliary lemmas and definitions that should be put into places like <code>data.finset.basic</code>. So proceeding with this as a mathlib(3) PR would create some forward-porting obligations, but right now it is not yet possible to do this in mathlib4.</p>",
        "id": 348274262,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1681149491
    },
    {
        "content": "<p>Comments and reviews are welcome, of course. <span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span> <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span></p>",
        "id": 348274401,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1681149542
    },
    {
        "content": "<p>(already on it!)</p>",
        "id": 348274448,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1681149558
    },
    {
        "content": "<p>The stuff on rank functions and independence will certainly overlap with Matroid stuff (I didn't check yet), but for my purposes it is important that this is developed without a finiteness assumption on the ambient type. My impression regarding <span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span>'s Matroid code was that there is always a <code>fintype</code> assumption in place.</p>",
        "id": 348274695,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1681149639
    },
    {
        "content": "<p>Are <code>linear_algebra.finite_dimensional</code> and <code>category_theory.cofiltered_systems</code> the only un-ported dependencies?</p>",
        "id": 348274868,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1681149695
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Rado's.20theorem.20on.20matroids/near/348274695\">said</a>:</p>\n<blockquote>\n<p>The stuff on rank functions and independence will certainly overlap with Matroid stuff (I didn't check yet), but for my purposes it is important that this is developed without a finiteness assumption on the ambient type. My impression regarding <span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span>'s Matroid code was that there is always a <code>fintype</code> assumption in place.</p>\n</blockquote>\n<p>That's somewhat true. But in matroid language, the ambient type can, for instance, be a finite set of vectors in some infinite vector space. So one should be able to recover Rado's theorem in all the settings where it makes sense. I'm actually in the process of refactoring my matroid project to allow for infinite matroids of finite rank, which might make the connection be smoother.</p>",
        "id": 348275014,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1681149748
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Rado's.20theorem.20on.20matroids/near/348275014\">said</a>:</p>\n<blockquote>\n<p>But in matroid language, the ambient type can, for instance, be a finite set of vectors in some infinite vector space. So one should be able to recover Rado's theorem in all the settings where it makes sense.</p>\n</blockquote>\n<p>But the version I did (which does not require the indexing type to be finite) will be impossible to obtain (directly) in this setting. (Of course, one can apply the compactness agrument afterwards.)</p>",
        "id": 348275478,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1681149904
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Rado's.20theorem.20on.20matroids/near/348274868\">said</a>:</p>\n<blockquote>\n<p>Are <code>linear_algebra.finite_dimensional</code> and <code>category_theory.cofiltered_systems</code> the only un-ported dependencies?</p>\n</blockquote>\n<p>Yes. The first one is only needed to derive the linear algebra version. The second one is needed to go to potentially infinite indexing types. Everything else is basic stuff. (<code>data.finset.card</code> and <code>data.fintype.basic</code>, to be precise; except the additional auxiliary lemmas.)</p>",
        "id": 348275637,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1681149962
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span> The point I'm trying to make is that one should develop the theory without the finiteness assumption to the extent possible, and then only impose it where it is really needed.</p>",
        "id": 348275864,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1681150044
    },
    {
        "content": "<p>I would surprised if <code>linear_algebra.finite_dimensional</code> is not ported by the end of next week (or even the end of this week). It will be at the top of board soon. <code>category_theory.cofilitered_systems</code> isn't that far from being ported either.</p>",
        "id": 348279614,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1681151331
    },
    {
        "content": "<p>.</p>",
        "id": 348279996,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1681151480
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Rado's.20theorem.20on.20matroids/near/348275864\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> The point I'm trying to make is that one should develop the theory without the finiteness assumption to the extent possible, and then only impose it where it is really needed.</p>\n</blockquote>\n<p>That's right - but for my way of proving Rado's theorem (the matroid intersection theorem), that's not easy - the matroid intersection theorem for general infinite matroids is still open. So going via compactness would be the only way with my method, as you say. And your project already gets there a different way, so there is even less reason to do that from my end :)</p>\n<p>The reason my project is mostly just for finite matroids is in line with the literature, 95% of which is on finite matroids. Even basic notions such as linear representation become pathological in the infinite setting, and infinite matroids can't in general be described by rank functions defined only on finite subsets.</p>",
        "id": 348280112,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1681151522
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> it has been suggested in the recent past that a reasonable approach right now to new developments which need a few additions to ported files is the following: intentionally put the new lemmas in the wrong place, instead of data.finset.basic, and make a porting note to move them later on after the port.</p>",
        "id": 348287793,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1681154353
    },
    {
        "content": "<p>... which is what I've done (see <code>combinatorics.rado.auxiliary</code>), minus the porting note.</p>",
        "id": 348289730,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1681155055
    },
    {
        "content": "<p>In your case, I think you in fact can dispense of all the preliminary lemmas</p>",
        "id": 348291702,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1681155840
    },
    {
        "content": "<p>Well, six of them still stand. And some of them are gaps in mathlib, I think.</p>",
        "id": 348292608,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1681156160
    }
]