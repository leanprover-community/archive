[
    {
        "content": "<p>I wanted to understand how <strong>tail recursion optimization</strong> works, so I wrote the following code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">compiler</span><span class=\"bp\">.</span><span class=\"n\">ir</span><span class=\"bp\">.</span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">factorial</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">factorial</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">factorialTR</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">acc</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>I expected that <strong><code>factorialTR.aux</code> would be compiled into a loop-based function</strong> rather than a recursive function due to tail recursion optimization, and that the intermediate representation (IR) would reflect this transformation.</p>\n<p>However, that was not the case. At the IR stage, <code>factorialTR.aux</code> was still a recursive function.</p>\n<p>So, my question is: <strong>Is there a way to check how the function is transformed by tail recursion optimization without actually running the compiler and inspecting the generated C code?</strong></p>",
        "id": 498799477,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1739202918
    },
    {
        "content": "<p>If your function at the end of compiler optimizations is tail recursive it is going to be compiled into a loop based function at the binary level, everything else would be a (rather surprising) bug. The Lean IR does not have a notion of a loop or an explicit tail call primitive and as such cannot express what you are asking for.</p>",
        "id": 498814024,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1739206690
    },
    {
        "content": "<p>Function call followed by <code>ret</code> is recognized as a tail call by the interpreter.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x_9</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">factorialTR</span><span class=\"bp\">.</span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"n\">x_6</span><span class=\"w\"> </span><span class=\"n\">x_8</span><span class=\"bp\">;</span>\n<span class=\"w\">    </span><span class=\"n\">ret</span><span class=\"w\"> </span><span class=\"n\">x_9</span>\n</code></pre></div>\n<p>If you want to be sure for compiled code, you should inspect the generated C. You will see a <code>goto _start</code> in place of the function call.</p>",
        "id": 498817299,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739207607
    },
    {
        "content": "<p>Another test: <code>#eval factorial 10000</code> does a stack overflow, but <code>#eval factorialTR 10000</code> does not.</p>",
        "id": 498817503,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739207665
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> Thank you. I didn’t know that Lean’s IR couldn’t represent loops.</p>",
        "id": 499212573,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1739360956
    },
    {
        "content": "<p>It can totally represent a loop with a sequence of jumps between joinpoints, it's just that there is no explicit loop primitive so you don't necessarily see it at first glance.</p>",
        "id": 499213415,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1739361227
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> </p>\n<p>Thank you. By checking the IR and finding <code>ret</code>, you can confirm it’s a tail call. That’s a useful thing to know.</p>\n<p>While using a stack overflow as an indicator is a good way to determine tail calls when the code runs, stack overflow errors can’t be sanitized using something like <code>#guard_msgs</code>, so it’s not what I was looking for. I apologize for not explaining clearly. I’m writing a reference for Lean, and I want to express concepts with code examples to make version updates easier. That’s why I’m looking for code-based representations.</p>",
        "id": 499213590,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1739361272
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"626349\">Asei Inoue</span> has marked this topic as resolved.</p>",
        "id": 499213906,
        "sender_full_name": "Notification Bot",
        "timestamp": 1739361379
    },
    {
        "content": "<p>I'd like to clarify that you can't confirm that it's a tail call that way, but if you don't see an immediate <code>ret</code> you can exclude the case that Lean recognizes that it's a tail call.</p>\n<p>There are some additional restrictions, but you would have to check with the evaluator source code and the code generator source code. I think I remember that these each only support self tail calls.</p>\n<p>Plus, GCC itself can do some tail call elimination itself, so some calls that don't appear to be tail calls can still be transformed in the end.</p>",
        "id": 499283875,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739379624
    }
]