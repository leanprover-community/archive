[
    {
        "content": "<p>Hi again.</p>\n<p>In my informal proof style, I am used to having a hypothesis such as <code>h: complicated_expression_1 = complicated_expression_2</code> and applying a function <code>f</code> to both sides to obtain a conclusion <code>h': f(complicated_expression 1) = f(complicated expression_2)</code>.  I would like to do this in Lean without having to keep typing out <code>complicated_expression_1</code> and <code>complicated_expression_2</code>.  Currently the best way I have to do this in Lean is code such as the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">complicated_expression_1</span> <span class=\"n\">complicated_expression_2</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">complicated_expression_1</span> <span class=\"bp\">=</span> <span class=\"n\">complicated_expression_2</span><span class=\"o\">):</span> <span class=\"n\">f</span> <span class=\"n\">complicated_expression_1</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">complicated_expression_2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">congrArg</span> <span class=\"n\">f</span> <span class=\"n\">h</span>\n  <span class=\"n\">assumption</span>\n</code></pre></div>\n<p>Is there a better way to do this?  I would have thought that one of the standard tactics like rw or apply should do this, but I couldn't get the syntax to work.</p>",
        "id": 396935896,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697472569
    },
    {
        "content": "<p><code>apply_fun f at h</code> should work, but your spelling is pretty canonical too</p>",
        "id": 396936041,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697472619
    },
    {
        "content": "<p>Note you can drop the <code>: _</code>, and <code>congr_arg</code> is preferred over <code>congrArg</code></p>",
        "id": 396936056,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697472625
    },
    {
        "content": "<p>Do I have to import something to get apply_fun or congr_arg to work?  I'm getting \"unknown tactic\" and \"unknown identifier\" currently.</p>",
        "id": 396936510,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697472813
    },
    {
        "content": "<p>Probably <code>import Mathlib.Tactic</code> will help</p>",
        "id": 396936551,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697472836
    },
    {
        "content": "<p>It's hard to say exactly why it's not working for you without seeing the full set of imports that make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, unless of course that (the empty set) <em>is</em> your full set of imports!</p>",
        "id": 396936736,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697472912
    },
    {
        "content": "<p>Thanks!  I was using the empty set of imports for my example.</p>",
        "id": 396936794,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697472953
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> the <code>congrm</code> tactic is also very useful, let me find the thread that introduces it.</p>",
        "id": 396936859,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697472973
    },
    {
        "content": "<p>If you have no imports at all, then there's another trap hiding there: <code>ℕ</code> is not <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat#doc\">docs#Nat</a>, but an arbitrary <code>variable {ℕ : Type _}</code>!</p>",
        "id": 396936866,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697472978
    },
    {
        "content": "<p>here is the thread for <code>congrm</code>: <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/congrm\">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/congrm</a></p>",
        "id": 396936909,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697473005
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 396937038,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697473072
    },
    {
        "content": "<p>probably <code>#help tactic congrm</code> in the VS Code extension provides good documentation for its use though.</p>",
        "id": 396937210,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697473125
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/Congrm.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/Congrm.html</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/TermCongr.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/TermCongr.html</a> were the documentation links I should have pasted</p>",
        "id": 396937318,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697473183
    },
    {
        "content": "<p>Just so it's clear: your example can be achieved with <code>congrm</code> as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Congrm</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">complicated_expression_1</span> <span class=\"n\">complicated_expression_2</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">complicated_expression_1</span> <span class=\"bp\">=</span> <span class=\"n\">complicated_expression_2</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">f</span> <span class=\"n\">complicated_expression_1</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">complicated_expression_2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congrm</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">$</span><span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 396938116,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697473559
    },
    {
        "content": "<p>Nice!  congrm looks extremely flexible for this sort of thing.</p>",
        "id": 396939334,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697474107
    },
    {
        "content": "<p>One related question.  Given a hypothesis <code>h : complicated_expression_1 = complicated_expression_2</code>, is it possible to extract out the LHS and RHS as expressions without having to type them out explicitly?  I'd like something roughly like <code>let LHS := (typeof h).1; let RHS := (typeof h).2</code>, although this particular code doesn't work.</p>",
        "id": 396942909,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697475527
    },
    {
        "content": "<p>It is certainly possible to write a macro for this. I don't think a user-facing one exists right now.</p>",
        "id": 396943183,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1697475624
    },
    {
        "content": "<p>But I'm skeptical this is actually something you want. Can you point to your use case?</p>",
        "id": 396943236,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697475644
    },
    {
        "content": "<p>Doesn't conv work for hypotheses? EDIT: It does. Source: The line just above the <a href=\"https://lean-lang.org/theorem_proving_in_lean4/conv.html?highlight=Conv#pattern-matching\">pattern matching section of conv in tpil</a></p>",
        "id": 396946852,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1697476980
    },
    {
        "content": "<p>I was hoping this would work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">LHS</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"k\">let</span> <span class=\"n\">RHS</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">change</span> <span class=\"n\">LHS</span> <span class=\"bp\">=</span> <span class=\"n\">RHS</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but it seems to refuse to unify. It works in Lean 3 (the \"open in playground\" button will open this in a lean3 editor)</p>\n<div class=\"codehilite\" data-code-language=\"lean3\"><pre><span></span><code>import tactic\n\nexample (h : 1 + 2 = 2 + 1) : true :=\nbegin\n  let LHS : ℕ := _,\n  let RHS : ℕ := _,\n  change LHS = RHS at h,\n  sorry\nend\n</code></pre></div>",
        "id": 396948571,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697477764
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">LHS</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n  <span class=\"k\">let</span> <span class=\"n\">RHS</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n  <span class=\"kd\">by</span>\n    <span class=\"n\">change</span> <span class=\"n\">LHS</span> <span class=\"bp\">=</span> <span class=\"n\">RHS</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but the <code>let</code>s have to be outside the <code>by</code> which is pretty weird. Maybe a metaprogramming expert can chime in about why things are behaving in this way.</p>",
        "id": 396949119,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697478007
    },
    {
        "content": "<p>Here's a really basic tactic to do this as well. It could certainly be written more efficiently.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">let_lhs_rhs</span><span class=\"o\">)</span> <span class=\"s2\">\"let_lhs_rhs\"</span> <span class=\"n\">term</span> <span class=\"s2\">\"with\"</span> <span class=\"n\">ident</span> <span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Expr</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">tactic</span> <span class=\"n\">let_lhs_rhs</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">letSidesTac</span> <span class=\"o\">:</span> <span class=\"n\">Tactic</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">let_lhs_rhs</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"k\">with</span> <span class=\"bp\">$</span><span class=\"n\">h₁</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"n\">h₂</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">withMainContext</span> <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">Elab.Term.elabTerm</span> <span class=\"n\">e</span> <span class=\"n\">none</span>\n        <span class=\"k\">let</span> <span class=\"n\">t</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">e</span>\n        <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">lhs</span><span class=\"o\">,</span> <span class=\"n\">rhs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">eq</span><span class=\"bp\">?</span> <span class=\"n\">t</span> <span class=\"k\">then</span>\n        <span class=\"n\">liftMetaTactic</span> <span class=\"k\">fun</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n          <span class=\"k\">let</span> <span class=\"n\">mvarIdNew</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.define</span> <span class=\"n\">h₁.getId</span> <span class=\"n\">type</span> <span class=\"n\">lhs</span>\n          <span class=\"k\">let</span> <span class=\"n\">mvarIdNew'</span> <span class=\"bp\">←</span> <span class=\"n\">mvarIdNew.define</span> <span class=\"n\">h₂.getId</span> <span class=\"n\">type</span> <span class=\"n\">rhs</span>\n          <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">mvarIdNew'</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mvarIdNew'.introNP</span> <span class=\"mi\">2</span>\n          <span class=\"n\">return</span> <span class=\"o\">[</span><span class=\"n\">mvarIdNew'</span><span class=\"o\">]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">):</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">let_lhs_rhs</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">lhs</span> <span class=\"n\">rhs</span>\n  <span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 396950262,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697478456
    },
    {
        "content": "<p>It would be neat if we could do <code>change ?lhs = ?rhs</code> (or maybe <code>change $lhs = $rhs</code> to be a bit closed to the <code>~q($lhs = $rhs)</code> we already have) and it did all this for us</p>",
        "id": 396950668,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697478630
    },
    {
        "content": "<p>Maybe that's a hint that this should be built on top of <code>Qq</code></p>",
        "id": 396950810,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697478700
    },
    {
        "content": "<p>That would have the downside of taking <code>change</code> out of core though.</p>",
        "id": 396951254,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697478892
    },
    {
        "content": "<p>You can do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">lhs</span> <span class=\"bp\">=</span> <span class=\"bp\">?</span><span class=\"n\">rhs</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">h</span>\n  <span class=\"k\">have</span> <span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"bp\">*?</span><span class=\"n\">rhs</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">lhs</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"bp\">*?</span><span class=\"n\">lhs</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"n\">trivial</span>\n</code></pre></div>\n<p>fwiw</p>",
        "id": 396951840,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1697479162
    },
    {
        "content": "<p>Any idea why it didn't work if I created the metavariables on a separate <code>let</code> tactic?</p>",
        "id": 396951962,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697479206
    },
    {
        "content": "<p>Or for that matter, why the <code>by exact</code> is needed?</p>",
        "id": 396952104,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697479264
    },
    {
        "content": "<p>It feels like we're navigating a mixture of bugs and unintended behaviors here</p>",
        "id": 396952131,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697479279
    },
    {
        "content": "<p>Not really, maybe something to do with metavariable contexts, who knows.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">LHS</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"k\">let</span> <span class=\"n\">RHS</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">LHS</span> <span class=\"bp\">=</span> <span class=\"n\">RHS</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">h</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>works too with the by exact</p>",
        "id": 396952269,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1697479323
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Is.20there.20a.20slicker.20way.20to.20do.20.22apply.20f.20to.20both.20sides.22.3F/near/396943236\">said</a>:</p>\n<blockquote>\n<p>But I'm skeptical this is actually something you want. Can you point to your use case?</p>\n</blockquote>\n<p>Here's a typical thing that shows up in a mathematical argument, particularly in analysis.  One needs to bound some expression <code>X</code>, and after a lot of manipulation one ends up demonstrating</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">\\</span><span class=\"n\">leq</span> <span class=\"n\">complicated_expression_1</span> <span class=\"bp\">+</span> <span class=\"n\">complicated_expression_2</span> <span class=\"bp\">+</span> <span class=\"n\">complicated_expression_3.</span>\n</code></pre></div>\n<p>Then one often happens is that one writes a line like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>=</mo><mo>:</mo><mi>I</mi><mo>+</mo><mi>I</mi><mi>I</mi><mo>+</mo><mi>I</mi><mi>I</mi><mi>I</mi></mrow><annotation encoding=\"application/x-tex\"> =: I + II + III</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mrel\">=:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">II</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">III</span></span></span></span> in the informal proof, which is implicitly defining</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">I</span> <span class=\"o\">:=</span> <span class=\"n\">complicated_expression_1</span>\n<span class=\"k\">let</span> <span class=\"n\">II</span> <span class=\"o\">:=</span> <span class=\"n\">complicated_expression_2</span>\n<span class=\"k\">let</span> <span class=\"n\">III</span> <span class=\"o\">:=</span> <span class=\"n\">complicated_expression_3</span>\n</code></pre></div>\n<p>and then one works further to estimate the terms <code>I</code>, <code>II</code>, and <code>III</code> separately, and only at the end of the argument return to <code>h</code> to conclude a final bound for <code>X</code>.  This can all be done right now in Lean if one is willing to write out <code>complicated_expression_*</code> several times in the proof itself, but it would be conceptually cleaner if the proof didn't explicitly have to do this, and these complicated expressions were only present in the tactic state.</p>",
        "id": 396952839,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697479510
    },
    {
        "content": "<p>I think you are looking for the conv mode I linked above.</p>",
        "id": 396953540,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1697479841
    },
    {
        "content": "<p>Shreyas, I agree that conv mode can be used, but it still doesn't really match the informal steps  that are used on paper, the way Terry describes. Having help from some macro (maybe similar in spirit to congrm) would be helpful, I think.</p>",
        "id": 396953936,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1697480033
    },
    {
        "content": "<p>Oh, I completely understand that (I am an analyst after all). I guess more what I was questioning is why you don't start with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">I</span> <span class=\"o\">:=</span> <span class=\"n\">complicated_expression_1</span>\n<span class=\"k\">let</span> <span class=\"n\">II</span> <span class=\"o\">:=</span> <span class=\"n\">complicated_expression_2</span>\n<span class=\"k\">let</span> <span class=\"n\">III</span> <span class=\"o\">:=</span> <span class=\"n\">complicated_expression_3</span>\n</code></pre></div>\n<p>and then derive:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≤</span> <span class=\"n\">I</span> <span class=\"bp\">+</span> <span class=\"n\">II</span> <span class=\"bp\">+</span> <span class=\"n\">III</span>\n</code></pre></div>\n<p>and proceed from there? In any case, it seems that what Alex suggested above should work.</p>",
        "id": 396954549,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697480336
    },
    {
        "content": "<p>I will say, <code>calc</code> type proofs that show up in analysis is one area where our current tooling is lacking, so probably this is just something we want to provide direct support for as Johan mentioned.</p>",
        "id": 396954795,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697480448
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Is.20there.20a.20slicker.20way.20to.20do.20.22apply.20f.20to.20both.20sides.22.3F/near/396954549\">said</a>:</p>\n<blockquote>\n<p>Oh, I completely understand that (I am an analyst after all). I guess more what I was questioning is why you don't start with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">I</span> <span class=\"o\">:=</span> <span class=\"n\">complicated_expression_1</span>\n<span class=\"k\">let</span> <span class=\"n\">II</span> <span class=\"o\">:=</span> <span class=\"n\">complicated_expression_2</span>\n<span class=\"k\">let</span> <span class=\"n\">III</span> <span class=\"o\">:=</span> <span class=\"n\">complicated_expression_3</span>\n</code></pre></div>\n<p>and then derive:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≤</span> <span class=\"n\">I</span> <span class=\"bp\">+</span> <span class=\"n\">II</span> <span class=\"bp\">+</span> <span class=\"n\">III</span>\n</code></pre></div>\n<p>and proceed from there? In any case, it seems that what Alex suggested above should work.</p>\n</blockquote>\n<p>The point is that I would prefer not to explicitly write down <code>complicated_expression_*</code> again, as it is only serving as an intermediate quantity in the argument anyway and having too many expressions of this type makes the proof look intimidating.</p>\n<p>Here is a more concrete coding problem: can one solve</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">complicated_expression_1</span> <span class=\"n\">complicated_expression_2</span> <span class=\"n\">complicated_expression_3</span> <span class=\"n\">bound_1</span> <span class=\"n\">bound_2</span> <span class=\"n\">bound_3</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≤</span> <span class=\"n\">complicated_expression_1</span> <span class=\"bp\">+</span> <span class=\"n\">complicated_expression_2</span> <span class=\"bp\">+</span> <span class=\"n\">complicated_expression_3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b1</span> <span class=\"o\">:</span> <span class=\"n\">complicated_expression_1</span> <span class=\"bp\">≤</span> <span class=\"n\">bound_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b2</span> <span class=\"o\">:</span> <span class=\"n\">complicated_expression_2</span> <span class=\"bp\">≤</span> <span class=\"n\">bound_2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b3</span> <span class=\"o\">:</span> <span class=\"n\">complicated_expression_3</span> <span class=\"bp\">≤</span> <span class=\"n\">bound_3</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≤</span> <span class=\"n\">bound_1</span> <span class=\"bp\">+</span> <span class=\"n\">bound_2</span> <span class=\"bp\">+</span> <span class=\"n\">bound_3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>without explicitly writing down <code>complicated_expression_1</code>, <code>complicated_expression_2</code>, and <code>complicated_expression_3</code> again?  (But usually <code>bound_1</code>, <code>bound_2</code>, and <code>bound_3</code> are pretty civilized and don't make the proof much scarier-looking if they are written down a few more times in the proof.)</p>",
        "id": 396956294,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697481134
    },
    {
        "content": "<p>One way to do this is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">calc</span> <span class=\"n\">X</span> <span class=\"bp\">≤</span> <span class=\"n\">complicated_expression_1</span> <span class=\"bp\">+</span> <span class=\"n\">complicated_expression_2</span> <span class=\"bp\">+</span> <span class=\"n\">complicated_expression_3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">_</span> <span class=\"bp\">≤</span> <span class=\"n\">bound1</span> <span class=\"bp\">+</span> <span class=\"n\">bound2</span> <span class=\"bp\">+</span> <span class=\"n\">bound3</span> <span class=\"o\">:=</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n<span class=\"n\">gcongr</span>\n<span class=\"bp\">·</span> <span class=\"o\">[</span><span class=\"n\">first</span> <span class=\"n\">bound</span> <span class=\"n\">proof</span><span class=\"o\">]</span>\n<span class=\"bp\">·</span> <span class=\"o\">[</span><span class=\"n\">second</span> <span class=\"n\">bound</span> <span class=\"n\">proof</span><span class=\"o\">]</span>\n<span class=\"bp\">·</span> <span class=\"o\">[</span><span class=\"n\">third</span> <span class=\"n\">bound</span> <span class=\"n\">proof</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 396956365,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1697481172
    },
    {
        "content": "<p>The disadvantage here is a psychological difference: you are thinking of the three sub-proofs as coming before the endgame, and this way the endgame is presented before the three sub-proofs.</p>",
        "id": 396956644,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1697481278
    },
    {
        "content": "<p>So, in your more precise example,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">complicated_expression_1</span> <span class=\"n\">complicated_expression_2</span> <span class=\"n\">complicated_expression_3</span> <span class=\"n\">bound_1</span> <span class=\"n\">bound_2</span> <span class=\"n\">bound_3</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≤</span> <span class=\"n\">complicated_expression_1</span> <span class=\"bp\">+</span> <span class=\"n\">complicated_expression_2</span> <span class=\"bp\">+</span> <span class=\"n\">complicated_expression_3</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">b1</span> <span class=\"o\">:</span> <span class=\"n\">complicated_expression_1</span> <span class=\"bp\">≤</span> <span class=\"n\">bound_1</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">b2</span> <span class=\"o\">:</span> <span class=\"n\">complicated_expression_2</span> <span class=\"bp\">≤</span> <span class=\"n\">bound_2</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">b3</span> <span class=\"o\">:</span> <span class=\"n\">complicated_expression_3</span> <span class=\"bp\">≤</span> <span class=\"n\">bound_3</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">X</span> <span class=\"bp\">≤</span> <span class=\"n\">bound_1</span> <span class=\"bp\">+</span> <span class=\"n\">bound_2</span> <span class=\"bp\">+</span> <span class=\"n\">bound_3</span> <span class=\"o\">:=</span>\n  <span class=\"k\">calc</span> <span class=\"n\">X</span> <span class=\"bp\">≤</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n    <span class=\"n\">_</span> <span class=\"bp\">≤</span> <span class=\"n\">bound_1</span> <span class=\"bp\">+</span> <span class=\"n\">bound_2</span> <span class=\"bp\">+</span> <span class=\"n\">bound_3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">gcongr</span>\n</code></pre></div>",
        "id": 396957000,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1697481452
    },
    {
        "content": "<p>OK, that is workable, and reasonably close to the structure of the informal proof. Thanks!</p>",
        "id": 396957196,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697481547
    },
    {
        "content": "<p>(Noting that typically you wouldn't prove <code>b1</code>, <code>b2</code>, <code>b3</code> ahead of time, you would let Lean/<code>gcongr</code> formulate them for you based on the structure of the computation, so you didn't need to write out the complicated expressions more than once.)</p>",
        "id": 396957279,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1697481603
    },
    {
        "content": "<p>Yeah, that was an artefact in order to get a minimal working example.  Ideally one would never write out the complicated expressions ever, they would only be implicitly stored in the tactic state.</p>",
        "id": 396957439,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697481662
    },
    {
        "content": "<p>That would be ideal but is somewhat beyond current tooling.  <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> has a tool in progress which will let you get such expressions by clicking on the appropriate sub-expression as displayed in the infoview, so you have to click on it but not write it out.  I don't think this tool is merged to mathlib yet, though.</p>",
        "id": 396957645,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1697481745
    },
    {
        "content": "<p>I think it could aid in readability if we could sometimes write proof steps like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">%</span><span class=\"n\">lhs</span> <span class=\"bp\">&lt;</span> <span class=\"n\">bound_1</span> <span class=\"bp\">+</span> <span class=\"n\">bound_2</span> <span class=\"bp\">+</span> <span class=\"n\">bound_3</span>\n</code></pre></div>\n<p>I suppose that macros <code>%lhs</code> and <code>%rhs</code> aren't too difficult to implement, but I wouldn't know how to do it myself.</p>",
        "id": 396957687,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1697481768
    },
    {
        "content": "<p>So there is nothing like <code>(typeof this).1</code> to reference this?  I don't really know how equality types are structured but this is what I would have naively thought would be the syntax (and also I don't know what the correct version of `typeof' is in Lean4)</p>",
        "id": 396957947,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697481865
    },
    {
        "content": "<p>Currently we can write Johan's proposed macro as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">calc</span> <span class=\"n\">_</span> <span class=\"bp\">≤</span> <span class=\"n\">bound_1</span> <span class=\"bp\">+</span> <span class=\"n\">bound_2</span> <span class=\"bp\">+</span> <span class=\"n\">bound_3</span> <span class=\"o\">:=</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">_</span> <span class=\"bp\">&lt;</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n</code></pre></div>",
        "id": 396957976,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1697481881
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> We can make definitions like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Eq.lhs</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n<span class=\"c1\">-- and then write</span>\n\n<span class=\"bp\">...</span> <span class=\"n\">h.lhs</span>\n</code></pre></div>",
        "id": 396958394,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1697482067
    },
    {
        "content": "<p>But the problem is that you will then have <code>h.lhs</code> appearing in all sorts of places, and you have to explicitly unfold the <code>Eq.lhs</code> away.</p>",
        "id": 396958494,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1697482103
    },
    {
        "content": "<p>So it would be nicer to have a \"meta\" place holder.</p>",
        "id": 396958515,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1697482118
    },
    {
        "content": "<p>Right, and <code>Eq.lhs</code> would only work for equality, we would need something else for every expression. I think implementing this with <code>Qq</code> makes sense though.</p>",
        "id": 396958607,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697482173
    },
    {
        "content": "<p>Note that not writing the complicated expressions even once may make the proof much harder to read without looking at the goal state. Ideally, one should still retain a readability degree which is comparable to a paper proof, so taking too many shortcuts relying on the framework is not always a good idea.</p>",
        "id": 396958631,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1697482184
    },
    {
        "content": "<p>Well one could still make \"assertions\" as needed to remind the reader.  Something like <code>have : I = complicated_expression_1 by rfl</code> or whatever.</p>",
        "id": 396958831,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697482270
    },
    {
        "content": "<p>This (Sebastien's comment) is in part why I was suggesting writing <code>let I := ..., let II := ..., let III := ...</code> first. The other reason is that Lean can do more when it knows the expected type, so then proving <code>have : X ≤ I + II + III</code> would probably be easier (e.g., in a <code>calc</code> proof).</p>",
        "id": 396958976,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697482333
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span>  Agreed, although experience tells me that we're a lazy bunch, and quickly stop writing such assertions.</p>",
        "id": 396959002,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1697482348
    },
    {
        "content": "<p>\"After all, the reader should just look at the goal view\" <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span></p>",
        "id": 396959082,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1697482384
    },
    {
        "content": "<p>I hope that the point-and-click version Patrick is working on will let us be lazy while leaving a readable trace in the code.</p>",
        "id": 396959106,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1697482399
    },
    {
        "content": "<p>Heather, I thought that was already merged, no? <a href=\"https://github.com/leanprover-community/mathlib4/pull/7260\">#7260</a></p>",
        "id": 396959139,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697482415
    },
    {
        "content": "<p>Also I would imagine a non-interactive Lean -&gt; LaTeX converter would also have to have enough of the tactic state embedded in the LaTeX output that one would still see the complicated expressions appear once or twice, much as they already do in informal proofs as a natural consequence of applying all the manipulations.</p>",
        "id": 396959282,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697482467
    },
    {
        "content": "<p>Hmm, I thought the Lean core issue <a href=\"https://github.com/leanprover/lean4/pull/2652\">lean4#2652</a> it exposed had not yet had the fix arrive in mathlib ... maybe I'm behind the times?</p>",
        "id": 396959332,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1697482500
    },
    {
        "content": "<p>I think you're right, <a href=\"https://github.com/leanprover-community/mathlib4/pull/7260\">#7260</a> doesn't by itself have all the goodies for <code>calc</code>.</p>",
        "id": 396960030,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697482695
    },
    {
        "content": "<p>Concerning getting the LHS and RHS, what do people think about introducing elaborators for this a la </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Lean.Expr.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"lhs%\"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">t</span> <span class=\"bp\">←</span> <span class=\"n\">Elab.Term.elabTerm</span> <span class=\"n\">t</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"n\">tp</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">t</span>\n  <span class=\"k\">match</span> <span class=\"n\">tp.getAppFnArgs</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">``</span><span class=\"n\">Eq</span><span class=\"o\">,</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">a</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{← ppExpr tp} is not an equality.\"</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"rhs%\"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">t</span> <span class=\"bp\">←</span> <span class=\"n\">Elab.Term.elabTerm</span> <span class=\"n\">t</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"n\">tp</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">t</span>\n  <span class=\"k\">match</span> <span class=\"n\">tp.getAppFnArgs</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">``</span><span class=\"n\">Eq</span><span class=\"o\">,</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">a</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{← ppExpr tp} is not an equality.\"</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">lhs</span><span class=\"bp\">%</span> <span class=\"n\">h</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">lhs</span><span class=\"bp\">%</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">rhs</span><span class=\"bp\">%</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 396965822,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1697484672
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> what I often do if I have expressions that I want to abbreviate is to use <code>abbrev</code>.  I then can use the shorter notation in the rest of my code and unfold this definition when it is needed in the proof.  There isn't much documentation on <code>abbrev</code> but it works basically like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">LHS</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">complicated_experession</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>where you can pass arguments, explicit or implicit, on the left hand side which you can use for your complicated expression.</p>",
        "id": 396966632,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1697485082
    },
    {
        "content": "<p>This is similar to <code>def</code> and so forth.</p>",
        "id": 396966781,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1697485153
    },
    {
        "content": "<p>Additionally, if you add <code>@[simp]</code> in front of <code>abbrev</code> in your proofs to unfold you can use <code>simp only [LHS]</code></p>",
        "id": 396967148,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1697485331
    },
    {
        "content": "<p><code>abbrev</code> is pretty awkward if the expression in question only exists in the middle of the proof</p>",
        "id": 396967629,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697485612
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Is.20there.20a.20slicker.20way.20to.20do.20.22apply.20f.20to.20both.20sides.22.3F/near/396959332\">said</a>:</p>\n<blockquote>\n<p>Hmm, I thought the Lean core issue <a href=\"https://github.com/leanprover/lean4/pull/2652\">lean4#2652</a> it exposed had not yet had the fix arrive in mathlib ... maybe I'm behind the times?</p>\n</blockquote>\n<p>This fix arrived in Mathlib last night but it's going away soon (see <a href=\"https://github.com/leanprover-community/mathlib4/pull/7710\">#7710</a>) because the new Lean version introduced a completely <a href=\"#narrow/stream/113488-general/topic/Lean.20server.20crashes/near/396908703\">unrelated bug</a>.</p>",
        "id": 396967903,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1697485752
    },
    {
        "content": "<p>But if you are lucky you won't see the bug that affects <code>calc</code>. It won't show up in  a calculation involving real numbers or natural numbers for instance.</p>",
        "id": 396968051,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1697485813
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Is.20there.20a.20slicker.20way.20to.20do.20.22apply.20f.20to.20both.20sides.22.3F/near/396967629\">said</a>:</p>\n<blockquote>\n<p><code>abbrev</code> is pretty awkward if the expression in question only exists in the middle of the proof</p>\n</blockquote>\n<p>agreed, <code>abbrev</code> is nice if you are using the complicated expressions in multiple lemmas or theorems, which may be of use to Terence if he plans to use the complicated expressions in more than one lemma or theorem.</p>",
        "id": 396968133,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1697485857
    },
    {
        "content": "<p>So everything that you can see in the gif from <a href=\"#narrow/stream/287929-mathlib4/topic/Select.20and.20insert.20widgets/near/395051098\">this message</a> is currently available in a recent Mathlib. But indeed this does not include all my plans for this, and it would help with Terry's current question (but Adam's elaborator would).</p>",
        "id": 396968329,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1697485941
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> I was thinking of something like the following, which I would call <code>letm</code> (for \"let match\"). It would take a term with some named holes (or maybe antiquotations instead), e.g., <code>1 + ?x ^ 2 = ?y</code>, and another term <code>e</code> whose type should match the given expression. We then make all the holes into metavariables, run <code>isDefEq (expression with holes) (← inferType e)</code> which should assign these, and then add the assigned ones to the context with <code>let</code> and the provided name.</p>",
        "id": 396969744,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697486597
    },
    {
        "content": "<p>A lot of infrastructure should already be here since this rather close to what congrm is doing.</p>",
        "id": 396971305,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1697487361
    },
    {
        "content": "<p>I know, I'm currently trying to simply understand some of that code.</p>",
        "id": 396971389,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697487387
    },
    {
        "content": "<p>Note that it will then be very easy to turn into a widget that looks like the <code>congrm?</code> widget.</p>",
        "id": 396971429,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1697487416
    },
    {
        "content": "<p>And this as definitely on my TODO list.</p>",
        "id": 396971450,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1697487428
    },
    {
        "content": "<p>So it you do the hard back-end work then I'll be very happy.</p>",
        "id": 396971604,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1697487492
    },
    {
        "content": "<p>Something resembling the following would I think be very readable and usable by working mathematicians (particularly analysts): starting with a statement like <code>h: X \\leq complicated_expression_1 + complicated_expression_2 + complicated_expression_3</code>, it would be nice to have a tactic like <code>rewrite h as X \\leq I + II + III for some I, II, III</code> (I know this isn't good Lean syntax, but you should get the point) and this will convert h to <code>h: X \\leq I + II + III</code> and introduce three new definitions <code>I := complicated_expression_1</code>, <code>II := complicated_expression_2</code>, <code>III := complicated_expression_3</code> which can then be manipulated separately without ever having to type out the complicated expressions.  (I find that just cut and pasting them from the tactic state stops working once the expressions gets too complicated, mostly due to subtle casting operator issues that I don't really have the expertise or patience to diagnose.)</p>\n<p>Having lhs and rhs type operations for arbitrary relations (not just equality), as well as the letm proposal of Jireh, also sound good to me.</p>",
        "id": 396972178,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697487778
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Is.20there.20a.20slicker.20way.20to.20do.20.22apply.20f.20to.20both.20sides.22.3F/near/396957947\">said</a>:</p>\n<blockquote>\n<p>So there is nothing like <code>(typeof this).1</code> to reference this?  I don't really know how equality types are structured but this is what I would have naively thought would be the syntax (and also I don't know what the correct version of `typeof' is in Lean4)</p>\n</blockquote>\n<p>There is actually a typeof operator, it is spelled <code>type_of% this</code>. But you can't use <code>.1</code> to get the arguments of an equality, because types are values and there is no function which applied to <code>Eq A B</code> returns <code>A</code> because the function <code>A |-&gt; Eq A B</code> is not injective. You would need to use metamathematical mechanisms to do this, which can look at the syntax <code>Eq A B</code> rather than the value, and unification is the normal one you would use in this case, along the lines of <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> 's code example.</p>",
        "id": 396973022,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697488203
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Is.20there.20a.20slicker.20way.20to.20do.20.22apply.20f.20to.20both.20sides.22.3F/near/396950668\">said</a>:</p>\n<blockquote>\n<p>It would be neat if we could do <code>change ?lhs = ?rhs</code> (or maybe <code>change $lhs = $rhs</code> to be a bit closed to the <code>~q($lhs = $rhs)</code> we already have) and it did all this for us</p>\n</blockquote>\n<p>I think this would be essentially what Eric suggests (but not restricted to lhs and rhs of course)</p>",
        "id": 396973109,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1697488241
    },
    {
        "content": "<p>Terry, my <code>letm</code> proposal should handle your use case as <code>letm X ≤ ?I + ?II + ?III using h</code> (exact syntax TBD).</p>",
        "id": 396973114,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697488243
    },
    {
        "content": "<p>I think building that on top of <code>change</code> is the cleaner syntactically</p>",
        "id": 396973203,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1697488292
    },
    {
        "content": "<p>OK, thanks for the clarification, that makes sense.  I guess one can't have one's cake (invariance under definitional equality) and eat it too (be able to directly reference syntax).</p>",
        "id": 396973252,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697488319
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Is.20there.20a.20slicker.20way.20to.20do.20.22apply.20f.20to.20both.20sides.22.3F/near/396973114\">said</a>:</p>\n<blockquote>\n<p>Terry, my <code>letm</code> proposal should handle your use case as <code>letm X ≤ ?I + ?II + ?III using h</code> (exact syntax TBD).</p>\n</blockquote>\n<p>That looks pretty good to me - it would be intelligible to a mathematician not expert in Lean, and would match the flow of the informal mathematical version of argument.  Basically as long as all the functional programming type stuff is concealed under very suggestively worded tactics, it should be readable.</p>",
        "id": 396973663,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697488547
    },
    {
        "content": "<p>yeah, you would normally put these metaprograms inside some other file and import it</p>",
        "id": 396973816,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697488620
    },
    {
        "content": "<p>Some context about <code>change</code> for <span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span>: currently you can do <code>change _ + _ = _</code> to reformulate the goal as a definitionally equal form. The change Eric suggested would be to allow naming the underscores, which has the benefit of not really adding \"new\" syntax for users.</p>",
        "id": 396973820,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1697488622
    },
    {
        "content": "<p>I think it's essentially the same as Jireh's proposal, but I think it would be better to keep the current syntax</p>",
        "id": 396973926,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1697488679
    },
    {
        "content": "<p>You \"can\" name the underscores, this is just an issue with metavariable depths which seems fixable</p>",
        "id": 396974013,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697488712
    },
    {
        "content": "<p>Can we do that without moving <code>change</code> out of core?</p>",
        "id": 396974015,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697488712
    },
    {
        "content": "<p>(<code>change</code> isn't in core btw)</p>",
        "id": 396974061,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697488737
    },
    {
        "content": "<p>same thing for the issue with <code>let</code> in <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> 's original version</p>",
        "id": 396974152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697488802
    },
    {
        "content": "<p>Mario, if you have a basic understanding of what's going wrong but don't intend to work on it right now, could you open a Lean4 issue?</p>",
        "id": 396974215,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697488818
    },
    {
        "content": "<p>(of course a fix would be great, but I don't want to snipe you!)</p>",
        "id": 396974253,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697488846
    },
    {
        "content": "<p>for change or for let?</p>",
        "id": 396974262,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697488850
    },
    {
        "content": "<p>Either/both</p>",
        "id": 396974300,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697488873
    },
    {
        "content": "<p>Maybe I am missing the point, but... wouldn't <code>linarith</code> just do this automatically?</p>",
        "id": 396975618,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1697489620
    },
    {
        "content": "<p><code>linarith</code> is just for <em>proving</em> inequalities. The discussion here is about convenient syntax for assigning names to subexpressions of the type of a given hypothesis, and then introducing those with <code>let myName := subexpression</code>.</p>",
        "id": 396975989,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697489785
    },
    {
        "content": "<p>For the minimal code example I provided, yes.  But in a more practical situation, the bounds b1, b2, and b3 would not yet be in place, and one would have to derive them as part of the task of establishing the final conclusion.  Without these sorts of metasyntactic tools, one would have to write out b1, b2, and b3 explicitly at some point, which can make the proof look quite complicated.</p>",
        "id": 396976049,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697489821
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> , for clarity, are you saying that <code>change</code> <em>should already</em> support the desired behavior, but doesn't because of a bug related to MVarDepth? Or am I misunderstanding?</p>",
        "id": 396977785,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697490618
    },
    {
        "content": "<p>modulo some design questions about metavariable depths, yes</p>",
        "id": 396977836,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697490657
    },
    {
        "content": "<p>Cool, then I guess I won't work on it!</p>",
        "id": 396978071,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697490780
    },
    {
        "content": "<p>I think there's still a feature request here; <code>change ?foo = ?bar</code> creates metavariables, but does not show their values in the infoview</p>",
        "id": 396978275,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697490897
    },
    {
        "content": "<p>I'm not sure you want to be seeing all the metavariables in the infoview</p>",
        "id": 396979494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697491555
    },
    {
        "content": "<p>I don't think it's metavariables we want. We're trying to get <code>let</code> declarations for subexpressions determined by the named holes in <code>change</code>.</p>",
        "id": 396981094,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697492531
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Is.20there.20a.20slicker.20way.20to.20do.20.22apply.20f.20to.20both.20sides.22.3F/near/396979494\">said</a>:</p>\n<blockquote>\n<p>I'm not sure you want to be seeing all the metavariables in the infoview</p>\n</blockquote>\n<p>I think it's reasonable to see any metavariables given explicit names by the user</p>",
        "id": 396985352,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697495022
    },
    {
        "content": "<p>So I found a little time on Saturday night and tried out an idea with very helpful feedback and improvements from <span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"name \"</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"s2\">\" := \"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">var_name</span> <span class=\"o\">:=</span> <span class=\"n\">TSyntax.getId</span> <span class=\"n\">x</span>\n  <span class=\"k\">let</span> <span class=\"n\">eq_name</span> <span class=\"o\">:=</span> <span class=\"n\">Name.mkStr</span> <span class=\"n\">var_name</span> <span class=\"s2\">\"eq\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">identifier</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"n\">eq_name</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"o\">(</span>\n    <span class=\"k\">let</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">t</span>\n    <span class=\"k\">have</span> <span class=\"bp\">$</span><span class=\"n\">identifier</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">trivial</span>\n    <span class=\"n\">repeat</span> <span class=\"n\">rewrite</span><span class=\"o\">[</span><span class=\"bp\">←$</span><span class=\"n\">identifier</span><span class=\"o\">]</span>\n  <span class=\"o\">))</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">name</span> <span class=\"n\">lhs</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">lhs.eq</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">Nat.add_assoc</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">name</span> <span class=\"n\">my_subexp</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 397886240,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1697933277
    },
    {
        "content": "<p>My next step is to implement this inside <code>conv</code>. After that I plan to use the awesome abilities of <code>conv</code> to navigate through subexpressions and match patterns to write a <code>desugar &lt;expression&gt; as &lt;pattern&gt;</code>  tactic.</p>",
        "id": 397886398,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1697933412
    },
    {
        "content": "<p>Part of my reason to want to put a separate <code>name</code> tactic inside conv is that I have found myself exploring expressions with <code>conv</code> and sometimes wished that I could just put a tag on them.</p>",
        "id": 397886554,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1697933591
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> : if you find the redundant appearance of the <code>let</code> and <code>have</code> expression annoying, you can use the filter button on top of the infoview in vscode to hide the <code>let</code> definitions. I needed a way to allow <code>rewrite</code> to work with the definition for convenience.</p>",
        "id": 397886696,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1697933743
    },
    {
        "content": "<p>This looks very similar to the mathlib <code>set x := blah with h</code> tactic, is there a difference I'm not seeing?</p>",
        "id": 397940299,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1697976716
    },
    {
        "content": "<p>Yes, that you don't need to write <code>blah</code> because it's automatically inferred from the LHS of the goal/assumption.</p>",
        "id": 397954052,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1697990268
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> I don't see this <code>name</code> tactic inferring anything from either goals or assumptions. It appears to be that <code>name x := v</code> is roughly the same as <code>set x := v with x.eq</code>.</p>",
        "id": 397954946,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1697990862
    },
    {
        "content": "<p>Oh indeed I misread the syntax.</p>",
        "id": 397955158,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1697991061
    },
    {
        "content": "<p>It isn't different. Nevertheless I just want a blank slate before I start doing further stuff on top of it. Hopefully debugging will be simpler.  <code>set</code>  doesn't work inside conv btw. I am writing <code>name</code>  to eventually work within conv</p>",
        "id": 397955564,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1697991529
    },
    {
        "content": "<p>There's not much code to <code>set</code>: <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/Set.lean\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/Set.lean</a></p>\n<p>It would be a nice small project to split off the code in the <code>elab_rules</code> into a separate function and then add a conv tactic version.</p>",
        "id": 397957801,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1697992709
    },
    {
        "content": "<p>Though maybe you do need a separate conv version to be sure that you use the conv <code>rewrite</code> rather than the tactic one. (The conv <code>rewrite</code> makes sure to just rw the LHS of the conv goal.)</p>",
        "id": 397958386,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1697993039
    }
]