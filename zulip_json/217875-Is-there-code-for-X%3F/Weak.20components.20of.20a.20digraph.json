[
    {
        "content": "<p>At Knuth's lecture on Thursday, he defined the weak components of a digraph to be the finest partition of its vertices such that for any two distinct weak components A and B, either there is a path from every element of A to every element of B but no path from any element of B to any element of A, or there is a path from every element of B to every element of A but no path from any element of A to any element of B. If the graph is acyclic, the definition simplifies to there being a path from every element of A to every element of B or vice versa. See page 11 here: <a href=\"https://cs.stanford.edu/~knuth/fasc12a+.pdf\">https://cs.stanford.edu/~knuth/fasc12a+.pdf</a></p>\n<p>The intuition is that when you take the strong components of a graph and contract each of them to a single vertex, you end up with a graph that is partially ordered by reachability. When you take the weak components of a graph and contract them to a single vertex, you end up with a graph that is linearly ordered by reachability. Knuth thinks that the common definition of weakly connected components is less useful than this new definition and should be renamed to \"undirected components\".</p>\n<p>I was wondering if there way anything like this in mathlib? I can't even even find the strongly connected components of a diagraph in mathlib (unless you count Quivers as digraphs).</p>",
        "id": 486801883,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733690677
    },
    {
        "content": "<p>It's possible that strongly connected components exists somewhere for relations (the RflTransGen is partway there, and then you'd take a quotient to make it trichotomous), but digraphs are relatively new so it's not surprising it hasn't been defined yet for them.</p>",
        "id": 486802624,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733691350
    },
    {
        "content": "<p>I don't see how taking a quotient of the strongly connected components will make it trichotomous. Doesn't that only get you an antisymmetric relation, not necessarily a trichotomous relation?</p>",
        "id": 486806779,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733695141
    },
    {
        "content": "<p>You're right, I meant antisymmetric.</p>",
        "id": 486807493,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733695711
    },
    {
        "content": "<p>(Unless I'm mistaken, taking <code>ReflTransGen R</code> and then quotient by <code>fun x y : ReflTransGen R =&gt; x ≤ y ∧ y ≤ x</code> gives a type whose terms are strongly connected components. I'm curious if this is already in mathlib somewhere. It seems plausible that there are cases where you start with an almost poset and then want to impose antisymmetry.)</p>",
        "id": 486807647,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733695830
    },
    {
        "content": "<p>There is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AntisymmRel.setoid#doc\">docs#AntisymmRel.setoid</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Antisymmetrization#doc\">docs#Antisymmetrization</a> for preorders specifically, so I guess it is already in mathlib. However, I think strongly connected components are missing. Is this something that that there's interest in?</p>",
        "id": 486828898,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733713261
    },
    {
        "content": "<p>I could see something similar for turning partial orders into total orders via Knuth's weak components, although I'm not sure what that's useful for</p>",
        "id": 486829105,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733713390
    },
    {
        "content": "<p>Yeah, I'd be interested in seeing the development of strongly connected components for digraphs.</p>\n<p>(By the way, <a href=\"https://github.com/leanprover/lean4/pull/6189\">lean4#6189</a> paired with the unmerged <a href=\"https://github.com/leanprover/lean4/pull/6267\">lean4#6267</a> I hope will have an effect on the development of graph theory. These should make it possible to finally be able to have a generic <code>HasAdj</code> class and be able to write <code>G.Adj</code> with it, in addition to other generic constructions like paths and connected components.)</p>",
        "id": 486842501,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733721446
    },
    {
        "content": "<p>What's the status of <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">#4127</a>? It seems that this PR has been around longer than <code>Digraph</code> has yet seems to contain more stuff than the current <code>Digraph</code></p>",
        "id": 486965227,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733742119
    },
    {
        "content": "<p>There were a few obstructions:</p>\n<ul>\n<li>I didn't want to lose <code>G.Adj v w</code>, so I've been waiting on changes to core.</li>\n<li>It was unclear whether <code>HasAdj</code> should be dependent on the graph, or if that's just an unnecessary complication. It's conceivable that there are graph structures that would want the vertex type to be a field of the structure.</li>\n<li>There were some really bad <code>simp</code> failures. It's possible that <code>simp</code> has improved enough in the interim, but I haven't checked. These helper lemmas were necessary to get some obvious simps to go through, but they shouldn't be necessary: <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127/files#diff-fe0532c2bbc700795928c8fe1cdb0a7a07bd69b3d8a97117c08f0f84b159b091R915-R917\">https://github.com/leanprover-community/mathlib4/pull/4127/files#diff-fe0532c2bbc700795928c8fe1cdb0a7a07bd69b3d8a97117c08f0f84b159b091R915-R917</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127/files#diff-fe0532c2bbc700795928c8fe1cdb0a7a07bd69b3d8a97117c08f0f84b159b091R1172-R1173\">https://github.com/leanprover-community/mathlib4/pull/4127/files#diff-fe0532c2bbc700795928c8fe1cdb0a7a07bd69b3d8a97117c08f0f84b159b091R1172-R1173</a></li>\n</ul>",
        "id": 487056103,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733765310
    },
    {
        "content": "<p>Do you think there's any merit in trying to get the absolute most general definition of a graph into mathlib or should we just try to work at suitable levels of abstraction? The problem I see with this is that even <code>Quiver</code> isn't general enough to accommodate all types of graphs (it can't accommodate weighted graphs or mixed graphs) so anything that general would basically have to become a notation typeclass.</p>",
        "id": 487069175,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733769033
    },
    {
        "content": "<p>I doubt that there's a most general graph, and that's an idea behind <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">#4127</a> — let's make it easy to define a <code>structure</code> for the combinatorics you want to do, and then give enough typeclass instances to hook in general theory and constructions that apply to the <code>structure</code>.</p>\n<p>Even <code>SimpleGraph</code> isn't meant to be \"the\" simple graph by the way. It's the abstract interface to a simple graph, and for concrete applications you need to make a custom data structure with a function giving it a <code>SimpleGraph</code> view. (The bridges of Konigsberg proof in the Archive uses an <a href=\"https://github.com/leanprover-community/mathlib4/blob/b202b867947571f7d316d1f591be7e759dc0165c/Archive/Wiedijk100Theorems/Konigsberg.lean#L33-L37\">edge list representation</a> for example. There could be some more general constructions here so it doesn't need to be ad hoc.)</p>",
        "id": 487070379,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733769425
    },
    {
        "content": "<p>What about making a <code>DigraphLike</code> typeclass, inspired by <code>SetLike</code> and <code>FunLike</code>? Or would this essentially be the same as <code>HasAdj</code>?</p>",
        "id": 487070845,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733769595
    },
    {
        "content": "<p>That's <code>HasAdj</code>, though feel free to be inspired on your own and see if something different comes out of it.</p>",
        "id": 487072302,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733770028
    },
    {
        "content": "<p>Is there interest in trying to revive <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">#4127</a>?</p>",
        "id": 487072457,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733770082
    },
    {
        "content": "<p>Yes, I hope it's clear that I'm interested in it, even if there's been no obvious progress on <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">#4127</a> itself for awhile now. For obstruction 1, the only thing remaining is a way to set which argument gets to be used for dot notation (<a href=\"https://github.com/leanprover/lean4/pull/6267\">lean4#6267</a>), which will save a <em>lot</em> of unnecessary code churn.</p>\n<p>For the other two obstructions, it would be helpful to know if simp has gotten better. This will take work to bring the PR up to date, which needs to be done anyway. If it's something you're interested in doing, feel free! I don't expect it to be straightforward unfortunately.</p>",
        "id": 487074348,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733770629
    },
    {
        "content": "<p>I'll try to take a look at it after exams</p>",
        "id": 487074857,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733770791
    },
    {
        "content": "<p>I'm going to try looking at <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">#4127</a>. Is <a href=\"https://github.com/leanprover/lean4/pull/6267\">lean4#6267</a> a hard dependency of <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">#4127</a>, or would it be possible to work on <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">#4127</a> without having <a href=\"https://github.com/leanprover/lean4/pull/6267\">lean4#6267</a> merged, and just change the notation later?</p>\n<p>An alternative to dot notation would be to define new notation for <code>HasAdj.Adj</code>, so that instead of writing <code>G.Adj A B</code> we could write something like <code>A ~G~ B</code> or <code>G⇢ A B</code> or <code>A [G]⇢ B</code> or something. This could potentially tie in to quiver syntax, so that <code>A ⟶ B</code> is the type of typeclass inferred quiver homs, and <code>A [G]⟶ B</code> or <code>A ⟶ B [G]</code> is the type of non-typeclass inferred quiver homs. This also leaves open the option to add symbols for bidirectional connections.</p>",
        "id": 490606168,
        "sender_full_name": "Niels Voss",
        "timestamp": 1734999655
    }
]