[
    {
        "content": "<p>\"Clearly\", I claim, there must exist some surjective function from all of <code>Type u</code> to any specific <code>α : Type u</code>. But I'm having a bear of a time coming up with a construction. I can make it work by importing <code>Cardinal</code>, though even then it's less clean than I'd like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Cardinal</span><span class=\"bp\">.</span><span class=\"n\">Arithmetic</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">exists_surj</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">Surjective</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">suffices</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">Surjective</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mk_eq_zero_iff</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mk_surjective_eq_zero_iff_lift</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">contrapose!</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ne_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mk_ne_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_false_eq_true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imp_self</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">and_true</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">suffices</span><span class=\"w\"> </span><span class=\"n\">IsEmpty</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">Surjective</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">erw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mk_eq_zero_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mk_surjective_eq_zero_iff_lift</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">isEmpty_iff</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">not_surjective_Type</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">hf</span>\n</code></pre></div>\n<p>... which I'm moderately okay with, since this <em>is</em> fundamentally a size argument: Type u is much bigger than any specific Type u, so of course there's a surjective function. But surely there's something cleaner than this? It feels just a step away from Cantor, but it's a step I don't quite see.</p>",
        "id": 507404254,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1742613690
    },
    {
        "content": "<p>I suppose it boils down to: what's the cleanest way to show that for any two sets, there exists a surjective function in at least one direction?</p>",
        "id": 507404384,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1742613812
    },
    {
        "content": "<p>I wonder if <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Embedding.total#doc\">docs#Function.Embedding.total</a> could help here (by proving an injection in the reverse direction and then getting the surjection from that)</p>",
        "id": 507405262,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1742614605
    },
    {
        "content": "<p>it just says \"for any two types, there must be an injection going from one of them to the other\"</p>",
        "id": 507405358,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1742614688
    },
    {
        "content": "<p>also it sounds like you want to prove it in a specific direction, so maybe that's not so helpful...</p>",
        "id": 507405499,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1742614837
    },
    {
        "content": "<p>here's one approach:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Cardinal</span><span class=\"bp\">.</span><span class=\"n\">SchroederBernstein</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">exists_surj</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">Surjective</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">↪</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">Surjective</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hg</span><span class=\"bp\">⟩</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">not_surjective_Type</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">hg</span>\n<span class=\"w\">    </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">exists_surjective_iff</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hg</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Embedding</span><span class=\"bp\">.</span><span class=\"n\">total</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">resolve_left</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">invFun_surjective</span><span class=\"w\"> </span><span class=\"n\">hg</span>\n</code></pre></div>",
        "id": 507407303,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1742616469
    },
    {
        "content": "<p>Oh hey. Yes, that does clean up the lemma a bunch, thanks~</p>",
        "id": 507408415,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1742617468
    },
    {
        "content": "<blockquote>\n<p>But surely there's something cleaner than this? It feels just a step away from Cantor, but it's a step I don't quite see.</p>\n</blockquote>\n<p>I think the core theorem you want here (which does not use cardinals) is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.not_surjective_Type#doc\">docs#Function.not_surjective_Type</a>, used in Matt's proof above.</p>",
        "id": 507453302,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742651182
    },
    {
        "content": "<p>and indeed it is one step away from cantor - it's literally the following theorem <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 507453354,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742651225
    },
    {
        "content": "<p>Ha! Indeed it is. But also, see my original proof, which uses it as well -- but I don't see a way to get from \"no surjective <code>(α : Type u) → Type u</code>\" to \"yes surjective <code>Type u → (α : Type u)</code>\" without a cardinality argument.</p>",
        "id": 507481928,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1742671131
    },
    {
        "content": "<p>right, which is why I suggested <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Embedding.total#doc\">docs#Function.Embedding.total</a> ... I guess the question is whether or not that lemma relies on a cardinality argument</p>",
        "id": 507482598,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1742671394
    },
    {
        "content": "<p>... Huh. Apparently <em>not</em>, to my surprise; it's imported <em>by</em> Cardinal.Basic. Alright, neat, no further remarks! :p</p>",
        "id": 507482984,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1742671498
    }
]