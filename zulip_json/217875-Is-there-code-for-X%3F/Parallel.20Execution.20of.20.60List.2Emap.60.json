[
    {
        "content": "<p>How can I execute <code>List.map</code> in parallel?</p>",
        "id": 528975273,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1752637869
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Define the syntax for a tactic named `my_exact?` (make `my_exact?` recognized as a syntax)</span>\n\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">myExact?</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"my_exact?\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"k\">in</span>\n\n<span class=\"c1\">-- Define the implementation of the `my_exact?` tactic</span>\n<span class=\"kd\">@[</span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"n\">myExact?</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">evalMyExact?</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Retrieve the current environment (which stores theorems and other constants)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Get the constants in the environment and filter them under the following conditions:</span>\n<span class=\"w\">  </span><span class=\"c1\">-- 1. They are not marked as unsafe</span>\n<span class=\"w\">  </span><span class=\"c1\">-- 2. Their kind is either `axiom` or `thm` (theorem)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">theorems</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">SMap</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Environment</span><span class=\"bp\">.</span><span class=\"n\">constants</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">|&gt;.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">name</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">info</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"n\">ConstantInfo</span><span class=\"bp\">.</span><span class=\"n\">isUnsafe</span><span class=\"w\"> </span><span class=\"n\">info</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">|&gt;.</span><span class=\"n\">filterMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">info</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getOriginalConstKind?</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"n\">name</span>\n<span class=\"w\">        </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">thm</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">name</span>\n<span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">      </span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Try each of the theorems that meet the conditions</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">theorems</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">try</span>\n<span class=\"w\">      </span><span class=\"c1\">-- Convert the name into a syntax node</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">nameStx</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"n\">name</span>\n\n<span class=\"w\">      </span><span class=\"c1\">-- Expand and execute `apply name &lt;;&gt; assumption` as a tactic expression</span>\n<span class=\"w\">      </span><span class=\"n\">evalTactic</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">nameStx</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">assumption</span><span class=\"o\">)</span>\n\n<span class=\"w\">      </span><span class=\"c1\">-- If successful, log a message and exit the tactic</span>\n<span class=\"w\">      </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"Applied {name} successfully.\"</span>\n<span class=\"w\">      </span><span class=\"n\">return</span>\n\n<span class=\"w\">    </span><span class=\"n\">catch</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"c1\">-- On failure, continue to the next theorem</span>\n<span class=\"w\">      </span><span class=\"n\">continue</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- If no theorem could be applied, fail as a tactic</span>\n<span class=\"w\">  </span><span class=\"n\">failure</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">maxHeartbeats</span><span class=\"w\"> </span><span class=\"mi\">500000</span><span class=\"w\"> </span><span class=\"k\">in</span>\n\n<span class=\"c1\">-- Example usage</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">my_exact?</span>\n</code></pre></div>\n<p>I wrote a tactic that imitates <code>exact?</code> as shown above, but it is extremely slow, which is a problem.<br>\nI want to speed it up by using parallel execution.</p>",
        "id": 528975797,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1752638316
    },
    {
        "content": "<p>This is not an answer to your question, but I think that <code>exact?</code> is relatively fast because it preprocesses lemmas, so that it does not even try to apply the ones that are clearly not applicable.  For that, I think that it uses a discrimination tree.  I suspect that using some quicker test to pre-filter the lemmas that you apply has a larger impact on performance than just dividing by the number of cores.</p>",
        "id": 528976681,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1752638949
    },
    {
        "content": "<p>Using the new <code>Async</code> monad in Lean 4.22 (it's still <code>Internal</code> in Lean 4.22, so use at your own risk. It will be officially released later this year):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Internal</span><span class=\"bp\">.</span><span class=\"n\">Async</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Internal</span><span class=\"bp\">.</span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">Async</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">expensiveOperation</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Async</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">sleep</span><span class=\"w\"> </span><span class=\"mi\">1000</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">manyInParallel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Async</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">tasks</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">expensiveOperation</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">results</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">concurrentlyAll</span><span class=\"w\"> </span><span class=\"n\">tasks</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">results</span><span class=\"bp\">.</span><span class=\"n\">sum</span>\n\n<span class=\"c1\">-- Only runs about a second</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">manyInParallel</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">wait</span>\n</code></pre></div>",
        "id": 529001854,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1752653010
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> , this is really cool!</p>\n<p>To more or less answer the question, I have devised the following definition for the Async map function for Array:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Internal</span><span class=\"bp\">.</span><span class=\"n\">Async</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Internal</span><span class=\"bp\">.</span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">Async</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">process</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Async</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"c1\">-- IO.println x</span>\n<span class=\"w\">  </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">sleep</span><span class=\"w\"> </span><span class=\"mi\">1000</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">concMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Async</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Async</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">concurrentlyAll</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">concMap</span><span class=\"w\"> </span><span class=\"n\">process</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">wait</span>\n</code></pre></div>\n<p>List version can be gotten by pre and post-composition with Array.toList and List.toArray.</p>\n<p>Also I have a question of my own: Why does the code with <code>IO.println</code> get stuck at the <code>#eval</code>?</p>\n<p>In the process of experimenting with this I noticed that the Lean server at <a href=\"http://live.lean-lang.org\">live.lean-lang.org</a> keeps crashing after almost any code change (usually when there's a type error). I wonder if this is a known bug...</p>",
        "id": 529483927,
        "sender_full_name": "Niklas Halonen",
        "timestamp": 1752852533
    },
    {
        "content": "<p>It's been a while since I worked on it, but <code>exact?</code> is using a few things to run quickly.</p>\n<p>It uses a discrimination tree so that one can quickly look up a pattern that could potentially match using apply in the tree.  Furthermore, the tree data type isn't the standard Lean discrimination tree used by simp, but is a lazy discrimination tree that is tuned to allow patterns to be inserted at the root, but not fully expanded until needed in a lookup.</p>\n<p>For concurrency, multiple lazy discrimination trees on subsets of available definitions are constructed in parallel and then merged.</p>\n<p>Concurrency is likely fine as long as you have a relatively small number of theorems.  The laziness tricks become important if you want to do things like quickly search all theorems in Mathlib.</p>",
        "id": 529517635,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1752867772
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"706442\">Niklas Halonen</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Parallel.20Execution.20of.20.60List.2Emap.60/near/529483927\">said</a>:</p>\n<blockquote>\n<p>Also I have a question of my own: Why does the code with <code>IO.println</code> get stuck at the <code>#eval</code>?</p>\n<p>In the process of experimenting with this I noticed that the Lean server at <a href=\"http://live.lean-lang.org/\">live.lean-lang.org</a> keeps crashing after almost any code change (usually when there's a type error). I wonder if this is a known bug...</p>\n</blockquote>\n<p>Yes, this is a known issue: <a href=\"https://github.com/leanprover/lean4/pull/738\">lean4#738</a>.</p>",
        "id": 530710233,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1753428473
    }
]