[
    {
        "content": "<p>Is it possible to implement <code>ext?</code>?<br>\nPresumably it would have a clickable text to convert it to <code>refine [ext_lemma] fun i ↦ ?_</code></p>",
        "id": 524486717,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750176440
    },
    {
        "content": "<p>Of course, it is possible</p>",
        "id": 524487088,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750176596
    },
    {
        "content": "<p>IMO it would be much more productive if you started opening issues instead (or at the conclusion) of all those threads</p>",
        "id": 524487365,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750176691
    },
    {
        "content": "<p>In my experience <code>show_term ext</code> works very well, so this may be very easy.</p>",
        "id": 524487694,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1750176831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/ext.3F/near/524487365\">said</a>:</p>\n<blockquote>\n<p>IMO it would be much more productive if you started opening issues instead (or at the conclusion) of all those threads</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/issues/26042\">https://github.com/leanprover-community/mathlib4/issues/26042</a></p>",
        "id": 524488208,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750177041
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/ext.3F/near/524487694\">said</a>:</p>\n<blockquote>\n<p>In my experience <code>show_term ext</code> works very well, so this may be very easy.</p>\n</blockquote>\n<p>In my experience, this does not work very well, because of delayed assignment hiding what happens under binders.</p>",
        "id": 524489203,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750177434
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Try this: refine fun x ↦ ?_</span>\n<span class=\"w\">  </span><span class=\"n\">show_term</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span>\n</code></pre></div>",
        "id": 524489640,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750177572
    },
    {
        "content": "<p>Do you have an example with <code>show_term ext</code> specifically, though?</p>",
        "id": 524489965,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750177690
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ f x y = g x y</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">test'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">show_term</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Try this: refine funext fun x ↦ ?_</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 524490294,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750177799
    },
    {
        "content": "<p>Sounds like it's a bug in <code>show_term</code> though, and implementing <code>ext?</code> as doing the same thing as <code>show_term ext</code> is correct</p>",
        "id": 524490470,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750177857
    },
    {
        "content": "<p><code>by</code> the way, <code>by?</code> performs better.</p>",
        "id": 524491082,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1750178098
    },
    {
        "content": "<p>That's because it <code>sorry</code>s at the end, which fills all the metavariables</p>",
        "id": 524491203,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750178158
    },
    {
        "content": "<p>Mathlib could implement <code>ext?</code> as <code>show_term ext</code></p>\n<p>I think any implementation of <code>ext?</code> would be using the pretty printer. <span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span>'s point about limitations of the pretty printer are valid, but I'm not sure if that has any bearing on <code>ext?</code> per se.</p>\n<p>(Aaron: If you've got a good handle on delayed assignments, do you want to try experimenting with making a delayed assignment forcer? The idea would be to have a more aggressive <code>instantiateMVars</code> that takes the assigned value of a delayed assignment and then reabsracts it in the current context. If we get a good efficient one, we could add it as a pretty printer option. Alternatively, the pretty printer could attempt to pretty print delayed assignment values, but I've hesitated implementing it that way because that not obviously correct...)</p>",
        "id": 524491581,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750178315
    },
    {
        "content": "<p>I guess it's time to learn delayed assignments</p>",
        "id": 524491758,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750178393
    },
    {
        "content": "<p>The source code to <code>instantiateMVars</code> from sometime last year, before it was moved to C++, is informative. Feel free to ping me with questions.</p>",
        "id": 524491992,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750178490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/ext.3F/near/524491581\">said</a>:</p>\n<blockquote>\n<p>@Aaron Liu's point about limitations of the pretty printer are valid, but I'm not sure if that has any bearing on <code>ext?</code> per se.</p>\n</blockquote>\n<p>I'm not sure if I understand this point. This leads to the result of <code>ext?</code> producing a different result from the <code>ext</code> call.</p>",
        "id": 524493809,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750179165
    },
    {
        "content": "<p>Given a delayed assignment <code>?n fvars := ?m</code>, where <code>?m</code> is the original metavariable, it <em>might</em> work to simply take <code>?m</code>, see if it has an assignment <code>?m := v</code>, and if so, then replace <code>?n x1 ... xn</code> with <code>(&lt;- mkLambdaFVars fvars v).headBeta #[x1, ..., xn]</code>, after recursively expanding <code>v</code> with the same process. The <code>mkLambdaFVars</code> would be responsible for creating some new delayed assignments — but these would be <em>at</em> the synthetic opaque metavariables, so for pretty printing purposes it is exactly what we want.</p>\n<p>There are some complications though, with the way <code>let</code> variables are handled with delayed abstractions. The top of MetavarContext.lean has a long module doc with the \"gruesome details\", and within there is a small comment about how actually assigning <code>?n</code> itself \"may not even be type correct\". That's a very important subtle detail here (one which I only really appreciated in the last few weeks). I haven't thought through whether this is important here. In short: for <code>let</code>s, the system assumes that the value passed to <code>?n</code> is defeq to what the local context of <code>?m</code> says it should be.</p>",
        "id": 524493946,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750179218
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/ext.3F/near/524493809\">said</a>:</p>\n<blockquote>\n<p>This leads to the result of <code>ext?</code> producing a different result from the <code>ext</code> call.</p>\n</blockquote>\n<p>Yes, certainly, but what is <code>ext?</code> supposed to do except use the pretty printer with the term it produced?</p>",
        "id": 524494083,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750179283
    },
    {
        "content": "<p><code>show_term</code> is simply a frontend to the pretty printer</p>",
        "id": 524494198,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750179329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/ext.3F/near/524494083\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/ext.3F/near/524493809\">said</a>:</p>\n<blockquote>\n<p>This leads to the result of <code>ext?</code> producing a different result from the <code>ext</code> call.</p>\n</blockquote>\n<p>Yes, certainly, but what is <code>ext?</code> supposed to do except use the pretty printer with the term it produced?</p>\n</blockquote>\n<p>but isn't <code>funext fun x ↦ funext fun y ↦ ?_</code> the term produced?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ f x y = g x y</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">test</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">theorem test.{u_1, u_2, u_3} : ∀ {X : Type u_1} {Y : Type u_2} {Z : Type u_3} (f g : X → Y → Z), f = g :=</span>\n<span class=\"cm\">fun {X} {Y} {Z} f g ↦ funext fun x ↦ funext fun y ↦ sorry</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 524495658,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750179923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/ext.3F/near/524493946\">said</a>:</p>\n<blockquote>\n<p>In short: for <code>let</code>s, the system assumes that the value passed to <code>?n</code> is defeq to what the local context of <code>?m</code> says it should be.</p>\n</blockquote>\n<p>This is so much fun</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">warning: declaration uses 'sorry'</span>\n<span class=\"sd\">---</span>\n<span class=\"sd\">error: (kernel) application type mismatch</span>\n<span class=\"sd\">  [1, 2][k]</span>\n<span class=\"sd\">argument has type</span>\n<span class=\"sd\">  1 &lt; [1, 2].length</span>\n<span class=\"sd\">but function has type</span>\n<span class=\"sd\">  (fun as i ↦ i &lt; as.length) [1, 2] k → ℕ</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨?</span><span class=\"n\">P</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">swap</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">swap</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">][</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">k</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 524496644,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750180306
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> Feel free to post more examples to <a href=\"https://github.com/leanprover/lean4/pull/8488\">lean4#8488</a></p>",
        "id": 524496928,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750180448
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> Unless you want to get into the weeds of delayed assignments, the short answer is \"yes, that's the term it produced, but partial proofs with binders are complicated and confuse the pretty printer\".</p>\n<p>This is a fundamental problem that, if the pretty printer can't handle it, I don't see how <code>ext?</code> would do any better.</p>",
        "id": 524497303,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750180633
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I do not want to get into the details, but, could we instead have two <code>refines</code>? As in, I assume <code>ext</code> is secretly doing:?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n</code></pre></div>",
        "id": 524497457,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750180720
    },
    {
        "content": "<p>as in, I assume that we can do a tactic based on <code>show_term</code> that keeps calling <code>ext</code> afterwards and recording the new proofs</p>",
        "id": 524497538,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750180770
    },
    {
        "content": "<p>That would be reasonable for <code>ext?</code>. For that, it could even do <code>funext x; funext y</code>.</p>\n<p>It all depends what you want from <code>ext?</code> though. Is the point getting a proof term? Or to use simple tactics? Or only <code>refine</code>s? Or what?</p>",
        "id": 524497685,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750180845
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> only <code>refine</code>.</p>",
        "id": 524497813,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750180911
    },
    {
        "content": "<p>I think you need to justify that, given that there are lots of options in this design space.</p>",
        "id": 524497879,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750180941
    },
    {
        "content": "<p>Especially since you're talking about using multiple <code>refines</code> rather than a single refine. Why is that better? Is it what you'd want more in general? Or is it only a way to work around the pretty printer?</p>",
        "id": 524497978,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750180993
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> It's because <code>refine</code> is the most commonly used low-level tactic, and outputting multiple <code>refine</code>s allows the user (i.e. me) to chain them together manually. honestly, the point was just so that I know which <code>ext</code> lemma it used, so that I can convert the tactic proof manually to a term.</p>",
        "id": 524498267,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750181140
    },
    {
        "content": "<p>as long as it can give me a list of the <code>@[ext]</code> lemmas used, I'm fine with whatever it outputs</p>",
        "id": 524498338,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750181173
    },
    {
        "content": "<p>What I'm hearing is that if <code>show_term</code> could show the whole partial proof, you would have no need for <code>ext?</code>, right?</p>",
        "id": 524498419,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750181214
    },
    {
        "content": "<p>That's the general approach, and otherwise we're in a situation where every single tactic has a <code>?</code> variant.</p>",
        "id": 524498489,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750181236
    },
    {
        "content": "<p>yes, well, i also didn't know that <code>show_term</code> (and also <code>by?</code>) existed prior to this thread <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 524498524,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750181248
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> Another approach to this pretty printing problem, instead of a delayed assignment forcer, could be to have a pretty printer pass that assigns some dummy values to every leaf metavariable. Those dummy values could record the mvarids so that they can print as the correct expression.</p>\n<p>The delayed assignment forcer could still be useful though, to get some defeqs to go through that otherwise wouldn't (since delayed assignments are effectively opaque)</p>",
        "id": 524498601,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750181285
    },
    {
        "content": "<p>I believe <code>ext?</code> used to exist in lean 3, and it would not just do <code>show_term</code> (I don't see the point of that), it would suggest the pattern to use after <code>ext</code>. There was something similar for <code>rintro</code> and <code>rcases</code></p>",
        "id": 524611906,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750204236
    }
]