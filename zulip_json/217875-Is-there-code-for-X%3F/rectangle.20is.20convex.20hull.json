[
    {
        "content": "<p>Is there an easy way to prove this? (Here <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> are two complex numbers, and I want to realize the axis-parallel rectangle with opposite corners z and w as the convex hull of those four points.) Thanks!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span> <span class=\"n\">Complex</span> <span class=\"n\">Topology</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">true</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Interval</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">rect_eq_convex_hull</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">([[</span><span class=\"n\">z.re</span><span class=\"o\">,</span> <span class=\"n\">w.re</span><span class=\"o\">]]</span> <span class=\"bp\">×</span><span class=\"n\">ℂ</span> <span class=\"o\">[[</span><span class=\"n\">z.im</span><span class=\"o\">,</span> <span class=\"n\">w.im</span><span class=\"o\">]])</span> <span class=\"bp\">=</span>\n      <span class=\"n\">convexHull</span> <span class=\"n\">ℝ</span> <span class=\"o\">{</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">z.re</span> <span class=\"bp\">+</span> <span class=\"n\">w.im</span> <span class=\"bp\">*</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">w.re</span> <span class=\"bp\">+</span> <span class=\"n\">z.im</span> <span class=\"bp\">*</span> <span class=\"n\">I</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 408395310,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1702777412
    },
    {
        "content": "<p>You should prove a <code>reProdIm</code> version of <code>convexHull_prod</code></p>",
        "id": 408404854,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1702785533
    },
    {
        "content": "<p>Then you can write the set in the RHS as <code>{z.re, w.re} ×ℂ {z.im, w.im}</code></p>",
        "id": 408404896,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1702785589
    },
    {
        "content": "<p>Unfortunately, following equivalences is far from automatic.</p>",
        "id": 408404964,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1702785608
    },
    {
        "content": "<p>I'll try to do it now</p>",
        "id": 408405258,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1702785749
    },
    {
        "content": "<p>I have this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Convex.Combination</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Module</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Interval</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Complex</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">convexHull_reProdIm</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">convexHull</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">×</span><span class=\"n\">ℂ</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">convexHull</span> <span class=\"n\">ℝ</span> <span class=\"n\">s</span> <span class=\"bp\">×</span><span class=\"n\">ℂ</span> <span class=\"n\">convexHull</span> <span class=\"n\">ℝ</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n  <span class=\"k\">calc</span>\n    <span class=\"n\">convexHull</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">equivRealProdLm</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">equivRealProdLm</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">(</span><span class=\"n\">convexHull</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">LinearEquiv.image_symm_eq_preimage</span><span class=\"o\">]</span>\n        <span class=\"n\">using</span> <span class=\"n\">equivRealProdLm.symm.toLinearMap.convexHull_image</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">convexHull</span> <span class=\"n\">ℝ</span> <span class=\"n\">s</span> <span class=\"bp\">×</span><span class=\"n\">ℂ</span> <span class=\"n\">convexHull</span> <span class=\"n\">ℝ</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">convexHull_prod</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">segment_reProdIm_segment_eq_convexHull</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">[[</span><span class=\"n\">z.re</span><span class=\"o\">,</span> <span class=\"n\">w.re</span><span class=\"o\">]]</span> <span class=\"bp\">×</span><span class=\"n\">ℂ</span> <span class=\"o\">[[</span><span class=\"n\">z.im</span><span class=\"o\">,</span> <span class=\"n\">w.im</span><span class=\"o\">]]</span> <span class=\"bp\">=</span> <span class=\"n\">convexHull</span> <span class=\"n\">ℝ</span> <span class=\"o\">({</span><span class=\"n\">z.re</span><span class=\"o\">,</span> <span class=\"n\">w.re</span><span class=\"o\">}</span> <span class=\"bp\">×</span><span class=\"n\">ℂ</span> <span class=\"o\">{</span><span class=\"n\">z.im</span><span class=\"o\">,</span> <span class=\"n\">w.im</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">segment_eq_uIcc</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">convexHull_pair</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">convexHull_reProdIm</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Complex</span>\n</code></pre></div>",
        "id": 408406170,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1702786600
    },
    {
        "content": "<p>If you really want <code>{z, w, z.re + w.im * I, w.re + z.im * I}</code>, then you need to go along <code>equivRealProd</code> again.</p>",
        "id": 408406198,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1702786640
    },
    {
        "content": "<p>This is a version with a different order of points:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Convex.Combination</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Module</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Set</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Interval</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Complex</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">convexHull_reProdIm</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">convexHull</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">×</span><span class=\"n\">ℂ</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">convexHull</span> <span class=\"n\">ℝ</span> <span class=\"n\">s</span> <span class=\"bp\">×</span><span class=\"n\">ℂ</span> <span class=\"n\">convexHull</span> <span class=\"n\">ℝ</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n  <span class=\"k\">calc</span>\n    <span class=\"n\">convexHull</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">equivRealProdLm</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">equivRealProdLm</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">(</span><span class=\"n\">convexHull</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">LinearEquiv.image_symm_eq_preimage</span><span class=\"o\">]</span>\n        <span class=\"n\">using</span> <span class=\"n\">equivRealProdLm.symm.toLinearMap.convexHull_image</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">convexHull</span> <span class=\"n\">ℝ</span> <span class=\"n\">s</span> <span class=\"bp\">×</span><span class=\"n\">ℂ</span> <span class=\"n\">convexHull</span> <span class=\"n\">ℝ</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">convexHull_prod</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">preimage_equivRealProd_prod</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">equivRealProd</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"bp\">×</span><span class=\"n\">ℂ</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">segment_reProdIm_segment_eq_convexHull</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">[[</span><span class=\"n\">z.re</span><span class=\"o\">,</span> <span class=\"n\">w.re</span><span class=\"o\">]]</span> <span class=\"bp\">×</span><span class=\"n\">ℂ</span> <span class=\"o\">[[</span><span class=\"n\">z.im</span><span class=\"o\">,</span> <span class=\"n\">w.im</span><span class=\"o\">]]</span> <span class=\"bp\">=</span> <span class=\"n\">convexHull</span> <span class=\"n\">ℝ</span> <span class=\"o\">{</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">z.re</span> <span class=\"bp\">+</span> <span class=\"n\">w.im</span> <span class=\"bp\">*</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">w.re</span> <span class=\"bp\">+</span> <span class=\"n\">z.im</span> <span class=\"bp\">*</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">segment_eq_uIcc</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">convexHull_pair</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">convexHull_reProdIm</span><span class=\"o\">,</span>\n    <span class=\"bp\">←</span> <span class=\"n\">preimage_equivRealProd_prod</span><span class=\"o\">,</span> <span class=\"n\">insert_prod</span><span class=\"o\">,</span> <span class=\"n\">singleton_prod</span><span class=\"o\">,</span> <span class=\"n\">image_pair</span><span class=\"o\">,</span>\n    <span class=\"n\">insert_union</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">insert_eq</span><span class=\"o\">,</span> <span class=\"n\">Set.preimage_equiv_eq_image_symm</span><span class=\"o\">,</span> <span class=\"n\">image_insert_eq</span><span class=\"o\">,</span> <span class=\"n\">image_singleton</span><span class=\"o\">,</span>\n    <span class=\"n\">equivRealProd_symm_apply</span><span class=\"o\">,</span> <span class=\"n\">re_add_im</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Complex</span>\n</code></pre></div>",
        "id": 408406633,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1702787121
    },
    {
        "content": "<p>Great thanks! I'm trying to use this to see that a rectangle with all four endpoints in a disc is itself a subset of the disc. Do you see a better way to do this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Convex.Combination</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Module</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Set</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Interval</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Complex</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">rectangle_inside_disc</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hz</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">∈</span> <span class=\"n\">Metric.ball</span> <span class=\"n\">c</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hw</span> <span class=\"o\">:</span> <span class=\"n\">w</span> <span class=\"bp\">∈</span> <span class=\"n\">Metric.ball</span> <span class=\"n\">c</span> <span class=\"n\">r</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">hzw</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">z.re</span> <span class=\"bp\">+</span> <span class=\"n\">w.im</span> <span class=\"bp\">*</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">Metric.ball</span> <span class=\"n\">c</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hwz</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">w.re</span> <span class=\"bp\">+</span> <span class=\"n\">z.im</span> <span class=\"bp\">*</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">Metric.ball</span> <span class=\"n\">c</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">([[</span><span class=\"n\">z.re</span><span class=\"o\">,</span> <span class=\"n\">w.re</span><span class=\"o\">]]</span> <span class=\"bp\">×</span><span class=\"n\">ℂ</span> <span class=\"o\">[[</span><span class=\"n\">z.im</span><span class=\"o\">,</span> <span class=\"n\">w.im</span><span class=\"o\">]])</span> <span class=\"bp\">⊆</span> <span class=\"n\">Metric.ball</span> <span class=\"n\">c</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">rect_eq_convex_hull</span><span class=\"o\">]</span>\n  <span class=\"n\">convert</span> <span class=\"n\">convexHull_min</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">convex_ball</span> <span class=\"n\">c</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n  <span class=\"n\">refine</span> <span class=\"n\">Set.insert_subset</span> <span class=\"n\">hz</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">refine</span> <span class=\"n\">Set.insert_subset</span> <span class=\"n\">hw</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">refine</span> <span class=\"n\">Set.insert_subset</span> <span class=\"n\">hzw</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Set.singleton_subset_iff.mpr</span> <span class=\"n\">hwz</span>\n</code></pre></div>",
        "id": 408406706,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1702787204
    },
    {
        "content": "<p>No, I don't have any better idea. If you generalize this lemma from <code>Metric.ball</code> to any convex set, then you can probably replace the last 4 lines with <code>simp [*]</code> (not tested)</p>",
        "id": 408406825,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1702787377
    },
    {
        "content": "<p>Also I am planning to formalise some material related to Krein-Milman, if ever you need to find the extreme points of a set (as the convex hull of those is your original set if it is convex, at least in finite dimensions).</p>",
        "id": 408421214,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702800752
    }
]