[
    {
        "content": "<p>I've converted a Nat to a list of Bools, via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.Bits#doc\">docs#Nat.Bits</a>. Now I'm looking for a way to recover the Nat from the list of Bools. I'm aware of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.ofDigits#doc\">docs#Nat.ofDigits</a>, but it takes a list of Nats rather than Bools. There's also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BitVec.toNat#doc\">docs#BitVec.toNat</a> for BitVecs, but I don't want to recast my list of Bools. Any suggestions?</p>",
        "id": 454523682,
        "sender_full_name": "Isabel Dahlgren",
        "timestamp": 1722111272
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"628409\">Isabel Dahlgren</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/List.20of.20Bools.20to.20Nat/near/454523682\">said</a>:</p>\n<blockquote>\n<p>I've converted a Nat to a list of Bools, via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.Bits#doc\">docs#Nat.Bits</a>. Now I'm looking for a way to recover the Nat from the list of Bools. I'm aware of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.ofDigits#doc\">docs#Nat.ofDigits</a>, but it takes a list of Nats rather than Bools. There's also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BitVec.toNat#doc\">docs#BitVec.toNat</a> for BitVecs, but I don't want to recast my list of Bools. Any suggestions?</p>\n</blockquote>\n<p>There's a problem with this idea, and that's that any non-zero <code>Nat</code> converted to a list of bools always starts with a <code>true</code>. So a list of bools that starts with a <code>false</code> can't be represented. That's probably why you can't find the inverse.</p>\n<p>There's a trick where you treat the most-significant bit as a marker only, ignoring its <code>true</code>/<code>false</code> meaning, so a binary int that starts with <code>10</code> now maps to a list of bools that starts with <code>false</code>, and so now the mapping is invertible. It's a useful enough trick that it should probably have a name (if it doesn't already) and be a standardized trick. But I don't know if its well-known.</p>",
        "id": 454578301,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1722149907
    },
    {
        "content": "<p>The broader context is that we have some finite (group) <code>G</code> and want to broadcast over a channel (interpreted as a sequence of <code>Bool</code>, namely <code>List Bool</code>) an element of <code>G</code>. So we find some <code>k</code> such that <code>2 ^ (k - 1) &lt; card G ≤ 2 ^ k</code> and send over <code>k</code> bits of information (where the identification <code>G ≃ Fin (card G)</code> is arbitrary, eg <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.equivFin#doc\">docs#Fintype.equivFin</a>).</p>",
        "id": 454582042,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1722152691
    },
    {
        "content": "<p>I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BitVec#doc\">docs#BitVec</a> would be better here, but it seems the API is quite underdeveloped <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 454582719,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1722152889
    },
    {
        "content": "<p>The relevant items <a href=\"https://yaeldillies.github.io/ChandraFurstLipton/blueprint/dep_graph_document.html\">here</a> are <code>trivial-strategy</code> and <code>trivial-strategy-valid</code></p>",
        "id": 454584726,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1722154506
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"686420\">@Richard Kiss</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/List.20of.20Bools.20to.20Nat/near/454578301\">said</a>:</p>\n<blockquote>\n<p>There's a trick where you treat the most-significant bit as a marker only, ignoring its <code>true</code>/<code>false</code> meaning, so a binary int that starts with <code>10</code> now maps to a list of bools that starts with <code>false</code>, and so now the mapping is invertible. It's a useful enough trick that it should probably have a name (if it doesn't already) and be a standardized trick. But I don't know if its well-known.</p>\n</blockquote>\n<p>The trouble with that is that it sets up a bijection between lists of bools and <em>positive</em> nats. There are a few variations on that bijection in mathlib</p>",
        "id": 454635832,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1722185033
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/List.20of.20Bools.20to.20Nat/near/454582719\">said</a>:</p>\n<blockquote>\n<p>I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BitVec#doc\">docs#BitVec</a> would be better here, but it seems the API is quite underdeveloped <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>\n</blockquote>\n<p>Requests welcome.</p>",
        "id": 454677014,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1722207818
    }
]