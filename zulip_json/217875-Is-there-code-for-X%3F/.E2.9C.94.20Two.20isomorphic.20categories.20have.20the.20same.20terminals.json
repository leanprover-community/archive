[
    {
        "content": "<p>Is there a proof of </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">isoOfCategoryIsoTerminalObj</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsoOfCategory</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">th</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Terminal</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Terminal</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>\n<p>where <code>IsoOfCategory B C</code> is an isomorphism of categories (aka an iso in <code>Cat</code> ) ?</p>",
        "id": 465027926,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1724604370
    },
    {
        "content": "<p>What is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.IsoOfCategory#doc\">docs#CategoryTheory.IsoOfCategory</a> ?</p>",
        "id": 465027969,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724604457
    },
    {
        "content": "<p>If that doesn’t exist, then there’s no way for what you’re looking for to exist!</p>",
        "id": 465028026,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724604489
    },
    {
        "content": "<p>We do have a way of mapping terminal objects to terminal objects along an equivalence of cats</p>",
        "id": 465028056,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724604531
    },
    {
        "content": "<p>So if you have a way of converting your iso to an equivalence, then you can get what you want that way.</p>",
        "id": 465028089,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724604570
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Two.20isomorphic.20categories.20have.20the.20same.20terminals/near/465028056\">said</a>:</p>\n<blockquote>\n<p>We do have a way of mapping terminal objects to terminal objects along an equivalence of cats</p>\n</blockquote>\n<p>Which file would that be in ?</p>",
        "id": 465029381,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1724605989
    },
    {
        "content": "<p>this is a general statement about equivalences preserving limits.</p>",
        "id": 465029390,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724606011
    },
    {
        "content": "<p>But there is probably a file about preserving terminal objects in <code>CategoryTheory/Limits/Preserves/Shapes/Terminal</code> or something like that</p>",
        "id": 465029441,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724606053
    },
    {
        "content": "<p>It seems like we can at least get it in two steps</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Mathlib/CategoryTheory/Limits/Cones.lean</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">functorialityEquivalence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">≌</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cone</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">≌</span><span class=\"w\"> </span><span class=\"n\">Cone</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Mathlib/CategoryTheory/Limits/IsLimit.lean</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ofConeEquiv</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u₄</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₄</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cone</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">≌</span><span class=\"w\"> </span><span class=\"n\">Cone</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cone</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsLimit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">IsLimit</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>",
        "id": 465031203,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1724607947
    },
    {
        "content": "<p>its actually not that simple, because we are so strongly typed...</p>\n<p>I am probably doing something wrong, this should be simple.</p>\n<p><a href=\"https://live.lean-lang.org/#code=import%20Mathlib.CategoryTheory.Limits.Shapes.Terminal%0A%0Aopen%20CategoryTheory%0Aopen%20Limits%0Aopen%20CategoryTheory.Functor%0A%0Auniverse%20v₁%20v₂%20v₃%20v₄%20v%20vm%20u₁%20u₂%20u₃%20u₄%20u%20um%0Avariable%20%7BJ%20%3A%20Type%20u₁%20%7D%20%5BCategory.%7Bv₁%7D%20J%5D%0Avariable%20%7BB%20%3A%20Type%20u₂%20%7D%20%5BCategory.%7Bv₂%7D%20B%5D%0Avariable%20%7BC%20%3A%20Type%20u₃%20%7D%20%5BCategory.%7Bv₃%7D%20C%5D%0A%0Avariable%20(F%20G%20%3A%20J%20⥤%20B)%0A%0A%0Aabbrev%20Terminal%20(B%20%3A%20Type%20u₂%20)%20%5BCategory.%7Bv₂%7D%20B%5D%20%3A%3D%20%20Σ%20x%20%3A%20B%2C%20IsTerminal%20x%0A%0A%0Adef%20isoOfCategoryIsoTerminalObj%20%20(x%3A%20B)%20(equiv%3A%20%20B%20≌%20C)%20%20(h%20%3A%20IsTerminal%20x%20%20)%20%3A%20IsTerminal%20(equiv.functor.obj%20x)%20%3A%3D%0A%0A%20%20--%20the%20categories%20of%20cones%20are%20the%20same%0A%20%20let%20coneCatquiv%20%3A%20Cone%20(Functor.empty%20B)%20≌%20Cone%20(empty%20B%20⋙%20equiv.functor)%20%3A%3D%0A%20%20%20%20Limits.Cones.functorialityEquivalence%20(Functor.empty.%7B0%7D%20B)%20equiv%0A%0A%20%20--%20%22the%22%20cone%20for%20the%20empty%20functor%0A%20%20let%20theConeB%20%3A%20Cone%20(empty%20B)%20%3A%3D%20asEmptyCone%20x%0A%0A%20%20--%20IsLimit%20for%20theConeB%20is%20in%20bijection%20with%20IsLimit%20for%20%22a%22%20cone%20in%20C%0A%20%20let%20qe%20%3A%20IsLimit%20(coneCatquiv.functor.obj%20theConeB)%20≃%20IsLimit%20theConeB%20%20%3A%3D%20IsLimit.ofConeEquiv%20coneCatquiv%0A%0A%20%20let%20aconeC_isTerminal%20%3A%20IsLimit%20(coneCatquiv.functor.obj%20theConeB)%20%20%3A%3D%20qe.invFun%20h%0A%0A%20%20---------%0A%20%20--%20we%20want%20to%20rewrite%20that%20previous%20term%20thanks%20to%20an%20equality%20between%20%22a%22%20cone%20and%20%22the%22%20cone%0A%0A%20%20--%20they%20are%20not%20of%20the%20same%20type%0A%20%20let%20aconeC%20%3A%20Cone%20(empty%20B%20⋙%20equiv.functor)%20%3A%3D%20coneCatquiv.functor.obj%20theConeB%0A%20%20let%20theconeC%20%3A%20Cone%20(empty%20C)%20%3A%3D%20asEmptyCone%20(equiv.functor.obj%20x)%0A%0A%20%20--%20best%20we%20can%20hope%20is%20HEq%0A%20%20let%20the_a_HEq%20%3A%20HEq%20theconeC%20aconeC%20%3A%3D%20by%20sorry%0A%20%20--%20and%20we%20have%20some%20type%20identity%0A%20%20let%20eqConeType%20%3A%20Cone%20(empty.%7B0%7D%20B%20⋙%20equiv.functor)%20%3D%20Cone%20(empty%20C)%20%3A%3D%20congrArg%20Cone%20(empty_ext'%20_%20_)%0A%0A%0A%20%20let%20result%20%3A%20IsLimit%20(asEmptyCone%20(equiv.functor.obj%20x))%20%3A%3D%20by%0A%20%20%20%20sorry%0A%0A%20%20result%0\">live</a>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">Shapes</span><span class=\"bp\">.</span><span class=\"n\">Terminal</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Limits</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Functor</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">v₁</span><span class=\"w\"> </span><span class=\"n\">v₂</span><span class=\"w\"> </span><span class=\"n\">v₃</span><span class=\"w\"> </span><span class=\"n\">v₄</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">vm</span><span class=\"w\"> </span><span class=\"n\">u₁</span><span class=\"w\"> </span><span class=\"n\">u₂</span><span class=\"w\"> </span><span class=\"n\">u₃</span><span class=\"w\"> </span><span class=\"n\">u₄</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">um</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u₁</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u₂</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u₃</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₃</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span>\n\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Terminal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u₂</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\">  </span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsTerminal</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">isoOfCategoryIsoTerminalObj</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">equiv</span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">≌</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsTerminal</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\">  </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsTerminal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- the categories of cones are the same</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">coneCatquiv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cone</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≌</span><span class=\"w\"> </span><span class=\"n\">Cone</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">Cones</span><span class=\"bp\">.</span><span class=\"n\">functorialityEquivalence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">equiv</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- \"the\" cone for the empty functor</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">theConeB</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cone</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">asEmptyCone</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- IsLimit for theConeB is in bijection with IsLimit for \"a\" cone in C</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">qe</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLimit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">coneCatquiv</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">theConeB</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">IsLimit</span><span class=\"w\"> </span><span class=\"n\">theConeB</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">IsLimit</span><span class=\"bp\">.</span><span class=\"n\">ofConeEquiv</span><span class=\"w\"> </span><span class=\"n\">coneCatquiv</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">aconeC_isTerminal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLimit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">coneCatquiv</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">theConeB</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">qe</span><span class=\"bp\">.</span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"w\">  </span><span class=\"c1\">---------</span>\n<span class=\"w\">  </span><span class=\"c1\">-- we want to rewrite that previous term thanks to an equality between \"a\" cone and \"the\" cone</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- they are not of the same type</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">aconeC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cone</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">coneCatquiv</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">theConeB</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">theconeC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cone</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">asEmptyCone</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- best we can hope is HEq</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">the_a_HEq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HEq</span><span class=\"w\"> </span><span class=\"n\">theconeC</span><span class=\"w\"> </span><span class=\"n\">aconeC</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"c1\">-- and we have some type identity</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">eqConeType</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cone</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">empty</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Cone</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">Cone</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">empty_ext'</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLimit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">asEmptyCone</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n\n<span class=\"w\">  </span><span class=\"n\">result</span>\n</code></pre></div>",
        "id": 465046077,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1724623539
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Limits</span>\n<span class=\"kd\">noncomputable</span><span class=\"w\"> </span><span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">≌</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hX</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsTerminal</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsTerminal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E.functor.obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">IsTerminal.isTerminalObj</span><span class=\"w\"> </span><span class=\"n\">E.functor</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">hX</span><span class=\"w\"> </span><span class=\"c1\">-- found with exact?</span>\n</code></pre></div>",
        "id": 465052449,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724630003
    },
    {
        "content": "<p>Thanks !</p>\n<p>That's a lot of smarts in type class instance search performed by <code>exact? </code></p>\n<p>IsEquivalence -&gt; RightAdjoint -&gt; preserves limits</p>\n<p>By trial and error,  with <code>set_option trace.Meta.synthInstance true</code>,  could get down to the following imports</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">Preserves</span><span class=\"bp\">.</span><span class=\"n\">Shapes</span><span class=\"bp\">.</span><span class=\"n\">Terminal</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Adjunction</span><span class=\"bp\">.</span><span class=\"n\">Limits</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Limits</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">≌</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hX</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsTerminal</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsTerminal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">IsTerminal</span><span class=\"bp\">.</span><span class=\"n\">isTerminalObj</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">hX</span><span class=\"w\"> </span><span class=\"c1\">-- found with exact?</span>\n</code></pre></div>",
        "id": 465116723,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1724660486
    },
    {
        "content": "<p>Do you know about <code>#min_imports</code>?</p>",
        "id": 465118580,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1724660824
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 465123518,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1724662166
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Two.20isomorphic.20categories.20have.20the.20same.20terminals/near/465118580\">said</a>:</p>\n<blockquote>\n<p>Do you know about <code>#min_imports</code>?</p>\n</blockquote>\n<p>Thank god for that tool. I thought it didn't work for instance search for some reason</p>\n<p>It provides a repeatable procedure in such case : turn on all the smarts via import mathlib, then exact?, then #min_imports</p>",
        "id": 465124252,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1724662412
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257803\">Nicolas Rolland</span> has marked this topic as resolved.</p>",
        "id": 465133056,
        "sender_full_name": "Notification Bot",
        "timestamp": 1724664528
    },
    {
        "content": "<p>my previous attempt without the type dependency hell . right adjointness is cleaner</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">emptyConeExt</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cone</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a.pt</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b.pt</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Cones.ext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eqToIso</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a.as.elim</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">isoOfCategoryIsoTerminalObj'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">equiv</span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">≌</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsTerminal</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsTerminal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">equiv.functor.obj</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">coneCatequiv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Cones.functorialityEquivalence</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">equiv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Cones.postcomposeEquivalence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">emptyExt</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">))</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">equiv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">coneCatequiv.functor.obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">asEmptyCone</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">asEmptyCone</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">equiv.functor.obj</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">emptyConeExt</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"w\">  </span><span class=\"o\">((</span><span class=\"n\">IsLimit.ofConeEquiv</span><span class=\"w\"> </span><span class=\"n\">coneCatequiv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ofIsoLimit</span><span class=\"w\"> </span><span class=\"n\">equiv</span>\n</code></pre></div>",
        "id": 465191531,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1724679952
    }
]