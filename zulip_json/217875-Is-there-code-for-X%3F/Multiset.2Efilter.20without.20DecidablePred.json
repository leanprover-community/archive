[
    {
        "content": "<p>Is there a function that filters a Multiset (like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.filter#doc\">docs#Multiset.filter</a>) but that does not require the filter to be decidable?<br>\nSince <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.filterMap#doc\">docs#Multiset.filterMap</a> exists and doesn't require decidability I'm not sure why filter without a map needs it.<br>\nI found this awkward solution:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">filter'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">decPred</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s</span>\n</code></pre></div>",
        "id": 536674456,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1756410743
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Multiset.2Efilter.20without.20DecidablePred/near/536674456\">said</a>:</p>\n<blockquote>\n<p>Since <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.filterMap#doc\">docs#Multiset.filterMap</a> exists and doesn't require decidability</p>\n</blockquote>\n<p>This doesn't require decidability because it returns an <code>Option</code>. You could write a version of <code>filter</code> that \"doesn't need\" decidability because it returns a <code>Bool</code>, but this just passes the problem to the caller who now needs decidability to produce the <code>Bool</code></p>",
        "id": 536676278,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756411605
    },
    {
        "content": "<p>filtermap takes the a function returning <code>Option</code>, so it's decidable whether an option value equals <code>none</code></p>",
        "id": 536676292,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756411612
    },
    {
        "content": "<p>What problem are you trying to solve here?</p>",
        "id": 536676357,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756411636
    },
    {
        "content": "<p>I see, so everything in Multiset requires decidability. I'll use <code>decPred</code> then, thanks!</p>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Multiset.2Efilter.20without.20DecidablePred/near/536676357\">said</a>:</p>\n<blockquote>\n<p>What problem are you trying to solve here?</p>\n</blockquote>\n<p>I was messing around with roots of polynomials (which are a <code>Multiset</code>) and I tried to prove something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">map_roots_eq</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsDomain</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsDomain</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→+*</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">roots</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">roots</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and I was surprised by the error. I expected <code>Multiset</code> to behave like <code>Set</code> which allows undecidable filters.</p>",
        "id": 536680627,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1756413667
    },
    {
        "content": "<p>Because it's in the theorem statement, you should probably make <code>DecidablePred</code> explicit:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">map_roots_eq</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsDomain</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsDomain</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→+*</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">roots</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">roots</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>In proofs, you can then just use the <code>classical</code> tactic</p>",
        "id": 536753857,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1756460860
    }
]