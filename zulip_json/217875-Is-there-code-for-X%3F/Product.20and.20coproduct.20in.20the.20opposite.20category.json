[
    {
        "content": "<p>Do we have something like the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Limits.Preserves.Opposites</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span> <span class=\"n\">Opposite</span> <span class=\"n\">Limits</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">HasFiniteProducts</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"bp\">≅</span> <span class=\"bp\">∐</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">z</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I had a look in around <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.hasFiniteCoproducts_opposite#doc\">docs#CategoryTheory.Limits.hasFiniteCoproducts_opposite</a>, where the instance <code>HasFiniteCoproduct</code> on <code>Cᵒᵖ</code> is defined, but I don't see it.</p>",
        "id": 372400733,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688498539
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Limits.Preserves.Opposites</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span> <span class=\"n\">Opposite</span> <span class=\"n\">Limits</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">HasFiniteProducts</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"bp\">≅</span> <span class=\"bp\">∐</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">z</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">ee</span> <span class=\"o\">:=</span> <span class=\"n\">Discrete.opposite</span> <span class=\"n\">α</span>\n  <span class=\"k\">let</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">limit.cone</span> <span class=\"o\">(</span><span class=\"n\">Discrete.functor</span> <span class=\"n\">Z</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">op</span>\n  <span class=\"k\">let</span> <span class=\"n\">hE</span> <span class=\"o\">:</span> <span class=\"n\">IsColimit</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">limit.isLimit</span> <span class=\"o\">(</span><span class=\"n\">Discrete.functor</span> <span class=\"n\">Z</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">op</span>\n  <span class=\"k\">let</span> <span class=\"n\">E'</span> <span class=\"o\">:=</span> <span class=\"n\">E.whisker</span> <span class=\"o\">(</span><span class=\"n\">Discrete.opposite</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inverse</span>\n  <span class=\"k\">let</span> <span class=\"n\">hE'</span> <span class=\"o\">:</span> <span class=\"n\">IsColimit</span> <span class=\"n\">E'</span> <span class=\"o\">:=</span> <span class=\"n\">IsColimit.whiskerEquivalence</span> <span class=\"n\">hE</span> <span class=\"n\">ee.symm</span>\n  <span class=\"o\">(</span><span class=\"n\">hE'.coconePointsIsoOfEquivalence</span> <span class=\"n\">hE</span> <span class=\"n\">ee.symm</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Iso.refl</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n    <span class=\"bp\">≪≫</span> <span class=\"n\">hE'.coconePointUniqueUpToIso</span> <span class=\"o\">(</span><span class=\"n\">colimit.isColimit</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">≪≫</span>\n    <span class=\"n\">HasColimit.isoOfNatIso</span> <span class=\"o\">(</span><span class=\"n\">Discrete.natIso</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Iso.refl</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Maybe this can be done with fewer lego blocks?</p>",
        "id": 372416410,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688505329
    },
    {
        "content": "<p>It's annoying because you need to use the equivalence between <code>Discrete X</code> and its opposite.</p>",
        "id": 372416496,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688505368
    },
    {
        "content": "<p>It would be easier to just construct the isomorphism by hand, I suppose.</p>",
        "id": 372416516,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688505390
    },
    {
        "content": "<p>Thanks! I will see what I can do with it tomorrow</p>",
        "id": 372416576,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688505462
    },
    {
        "content": "<p>I think this is much more manageable, but a few lines longer:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Limits.Preserves.Opposites</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span> <span class=\"n\">Opposite</span> <span class=\"n\">Limits</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">HasFiniteProducts</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simps!]</span>\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">oppositeCofan</span> <span class=\"o\">:</span> <span class=\"n\">Cofan</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">z</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Cofan.mk</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">∏</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">π</span> <span class=\"n\">_</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">isColimitOppositeCofan</span> <span class=\"o\">:</span> <span class=\"n\">IsColimit</span> <span class=\"o\">(</span><span class=\"n\">oppositeCofan</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">desc</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">S</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">S.pt.unop</span> <span class=\"bp\">⟶</span> <span class=\"bp\">∏</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"k\">fun</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">S.ι.app</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">unop</span>\n    <span class=\"n\">e.op</span>\n  <span class=\"n\">fac</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">oppositeCofan_pt</span><span class=\"o\">,</span> <span class=\"n\">Functor.const_obj_obj</span><span class=\"o\">,</span>\n      <span class=\"n\">oppositeCofan_ι_app</span><span class=\"o\">,</span> <span class=\"n\">Discrete.functor_obj</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">op_comp</span><span class=\"o\">,</span> <span class=\"n\">limit.lift_π</span><span class=\"o\">,</span>\n      <span class=\"n\">Fan.mk_pt</span><span class=\"o\">,</span> <span class=\"n\">Fan.mk_π_app</span><span class=\"o\">,</span> <span class=\"n\">Quiver.Hom.op_unop</span><span class=\"o\">]</span>\n  <span class=\"n\">uniq</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">S</span> <span class=\"n\">m</span> <span class=\"n\">hm</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">m.op_unop</span><span class=\"o\">]</span>\n    <span class=\"n\">congr</span> <span class=\"mi\">1</span>\n    <span class=\"n\">apply</span> <span class=\"n\">limit.hom_ext</span>\n    <span class=\"n\">intro</span> <span class=\"n\">j</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">congr_arg</span> <span class=\"n\">Quiver.Hom.unop</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"bp\">≅</span> <span class=\"bp\">∐</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">z</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"n\">isColimitOppositeCofan</span> <span class=\"n\">Z</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">coconePointUniqueUpToIso</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">colimit.isColimit</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 372418031,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688506316
    }
]