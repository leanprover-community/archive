[
    {
        "content": "<p>I wish to use <code>Std.ExtHashMap</code> (<a href=\"https://lean-lang.org/doc/reference/4.21.0-rc3//Basic-Types/Maps-and-Sets/#Std___ExtHashMap\">https://lean-lang.org/doc/reference/4.21.0-rc3//Basic-Types/Maps-and-Sets/#Std___ExtHashMap</a>) to implement a function which takes two Extensional Hashmaps to return a new Extensional HashMap which contains the maximum of the values in each of the input maps for every key. The equivalent for HashMaps is given below. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">concrete_st</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">sel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">concrete_st</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">merge_helper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">klist</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">concrete_st</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">concrete_st</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">klist</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{}</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"bp\">::</span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">merge_helper</span><span class=\"w\"> </span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sel</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sel</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"o\">))</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">concrete_st</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">keys1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">keys2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">keys</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">keys1</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">keys2</span>\n<span class=\"n\">merge_helper</span><span class=\"w\"> </span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>Is there a way to iterate over / find the keys of the <code>Std.ExtHashMap</code> ? I want to use extensionality to prove certain theorems related to this implementation</p>",
        "id": 543075991,
        "sender_full_name": "Pranav cs22b015",
        "timestamp": 1759572401
    },
    {
        "content": "<p>If your keys are natural numbers, then using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.ExtTreeMap#doc\">docs#Std.ExtTreeMap</a> instead of <code>ExtHashMap</code> could be an option, as that oen has a <code>keys</code> function.</p>",
        "id": 543077184,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1759573715
    },
    {
        "content": "<p>One of the next few releases will contain an <code>ExtDHashMap.mergeWith</code> function that should suit your needs, but it's not done yet.</p>",
        "id": 543077291,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1759573842
    },
    {
        "content": "<p>Is there a way to reason about the keys of such an <code>ExtTreeMap</code>? For example, how should I proceed in proving the following - </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">concrete_st</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtTreeMap</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">sel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">concrete_st</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtTreeMap</span><span class=\"bp\">.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">merge_helper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">klist</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">concrete_st</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">concrete_st</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">klist</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{}</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"bp\">::</span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtTreeMap</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">merge_helper</span><span class=\"w\"> </span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sel</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sel</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"o\">))</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">concrete_st</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">concrete_st</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">keys1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtTreeMap</span><span class=\"bp\">.</span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">keys2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtTreeMap</span><span class=\"bp\">.</span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">keys</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">keys1</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">keys2</span>\n<span class=\"n\">merge_helper</span><span class=\"w\"> </span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">merge_comm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">concrete_st</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">concrete_st</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">concrete_st</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The <code>merge</code> function basically collects the keys <code>k</code>of each of the maps A and B, and creates a new map with the values corresponding to <code>max(A[k], B[k])</code>. We need to show that this function is commutative.</p>",
        "id": 543084255,
        "sender_full_name": "Pranav cs22b015",
        "timestamp": 1759581129
    },
    {
        "content": "<p>You can prove some helper lemmas about <code>merge_helper</code> that would make <code>merge_comm</code> a lot easier. Like when <code>merge_helper</code>  contains a key, the value is given by <code>max ...</code> and similarly <code>merge_helper</code> contains a key iff it is in <code>klist</code>.</p>",
        "id": 543091920,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1759588145
    },
    {
        "content": "<p>Is there a direct way to prove this seemingly simpler result?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">insert_insert</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtTreeMap</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k1</span><span class=\"w\"> </span><span class=\"n\">k2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">k1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">k2</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">k1</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">k2</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">k2</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">k1</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>",
        "id": 543095082,
        "sender_full_name": "Pranav cs22b015",
        "timestamp": 1759591065
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"957371\">Pranav cs22b015</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Get.20keys.20of.20a.20.60Std.2EExtHashMap.60/near/543095082\">said</a>:</p>\n<blockquote>\n<p>Is there a direct way to prove this seemingly simpler result?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">insert_insert</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtTreeMap</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k1</span><span class=\"w\"> </span><span class=\"n\">k2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">k1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">k2</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">k1</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">k2</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">k2</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">k1</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Okay, I got it, I need to use extensionality</p>",
        "id": 543097591,
        "sender_full_name": "Pranav cs22b015",
        "timestamp": 1759593030
    },
    {
        "content": "<p>How does one show this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">union_same</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>I am also confused on the difference between <code>List.union</code> and <code>∪</code> in terms of what theorems <code>simp</code> and <code>grind</code> are aware of about these constructs.</p>",
        "id": 543143745,
        "sender_full_name": "Pranav cs22b015",
        "timestamp": 1759649047
    },
    {
        "content": "<p>All the <code>simp</code> and <code>grind</code> annotations should be on lemmas using the notation. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.union_def#doc\">docs#List.union_def</a> shows how they are equivalent.</p>",
        "id": 543144740,
        "sender_full_name": "Chris Henson",
        "timestamp": 1759650188
    },
    {
        "content": "<p><code>List.Subset.union_eq_right (List.Subset.refl _)</code> works, but I'm surprised this doesn't exist as a simp lemma yet</p>",
        "id": 543145451,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1759651027
    },
    {
        "content": "<p>Feel free to PR it to <code>Mathlib.Data.List.Lattice</code></p>",
        "id": 543145527,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1759651171
    },
    {
        "content": "<p>Or maybe</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Subset</span><span class=\"bp\">.</span><span class=\"n\">union_left</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">contextual</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">subset_def</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Subset</span><span class=\"bp\">.</span><span class=\"n\">union_eq_right_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Subset</span><span class=\"bp\">.</span><span class=\"n\">union_left</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Subset</span><span class=\"bp\">.</span><span class=\"n\">union_eq_right</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Subset</span><span class=\"bp\">.</span><span class=\"n\">union_self</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 543145903,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1759651606
    },
    {
        "content": "<p>Any help for proving this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">merge_idem_prime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtTreeMap</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">):</span>\n<span class=\"o\">(</span><span class=\"n\">merge_helper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtTreeMap</span><span class=\"bp\">.</span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtTreeMap</span><span class=\"bp\">.</span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"bp\">→</span><span class=\"w\">  </span><span class=\"n\">s</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>where <code>merge_helper</code> is defined as follows: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">sel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">concrete_st</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtTreeMap</span><span class=\"bp\">.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">merge_helper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">klist</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">concrete_st</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">concrete_st</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">klist</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{}</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"bp\">::</span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">merge_helper</span><span class=\"w\"> </span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sel</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sel</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 543150493,
        "sender_full_name": "Pranav cs22b015",
        "timestamp": 1759657010
    },
    {
        "content": "<p>From a theoretical standpoint, how does an <code>ExtTreeMap</code> behave differently from a <code>TreeMap</code> in terms of reference counting? Also, in the PR introducing <code>ExtTreeMap</code>s, the fact that trees maintain data in order made it possible for building an extensional version with equal representative power. Why is order important here? In other words, why is designing an <code>ExtHashMap</code> with iterability difficult?</p>",
        "id": 543565243,
        "sender_full_name": "Pranav cs22b015",
        "timestamp": 1759851753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"957371\">Pranav cs22b015</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Get.20keys.20of.20a.20.60Std.2EExtHashMap.60/near/543565243\">schrieb</a>:</p>\n<blockquote>\n<p>From a theoretical standpoint, how does an <code>ExtTreeMap</code> behave differently from a <code>TreeMap</code> in terms of reference counting?</p>\n</blockquote>\n<p>Not sure what you mean about theoretical standpoint but <code>ExtTreeMap</code> behaves exactly like <code>TreeMap</code> at runtime.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"957371\">Pranav cs22b015</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Get.20keys.20of.20a.20.60Std.2EExtHashMap.60/near/543565243\">schrieb</a>:</p>\n<blockquote>\n<p>Why is order important here? In other words, why is designing an <code>ExtHashMap</code> with iterability difficult?</p>\n</blockquote>\n<p>Order gives you a canonical iteration order. With <code>ExtHashMap</code> this is more difficult: You'll have to either prove that iteration order doesn't matter (some kind of commutativity on the operation) or preprocess the data to put it into a deterministic order (e.g. through sorting). The first one should come eventually though.</p>",
        "id": 543590598,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1759859216
    },
    {
        "content": "<p>From the response, if I understand correctly, Extensionality on a <code>TreeMap</code> comes for free. My question also stems from the fact that in order to have extensionality, you only need to have decidable equality between the elements of the type constructing the keys of the map / set. Therefore, it is still unclear as to why order really matters. Iterability can be gained by attaching a separate iterator to walk through the map / set.</p>",
        "id": 543592701,
        "sender_full_name": "Pranav cs22b015",
        "timestamp": 1759859998
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"957371\">Pranav cs22b015</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Get.20keys.20of.20a.20.60Std.2EExtHashMap.60/near/543592701\">schrieb</a>:</p>\n<blockquote>\n<p>My question also stems from the fact that in order to have extensionality, you only need to have decidable equality between the elements of the type constructing the keys of the map / set</p>\n</blockquote>\n<p>How do you come to that conclusion? <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.ExtHashMap.ext_getKey_getElem%3F#doc\">docs#Std.ExtHashMap.ext_getKey_getElem?</a> doesn't require decidability</p>",
        "id": 543596360,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1759861220
    },
    {
        "content": "<p>The extensional variants of maps are defined as a quotient by equivalence on the regular map (e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.DTreeMap.Equiv#doc\">docs#Std.DTreeMap.Equiv</a>). Most operations are defined by lifting a function on the regular map to the quotient (e.g. see the equations tab under <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.ExtDHashMap.insert#doc\">docs#Std.ExtDHashMap.insert</a>). That however requires a proof that these operations are congruent (see e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.DHashMap.Equiv.insert#doc\">docs#Std.DHashMap.Equiv.insert</a>), i.e. that equivalent inputs produce equivalent outputs. Lifting <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.DTreeMap.toList#doc\">docs#Std.DTreeMap.toList</a> is possible because it is congruent under equivalence (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.DTreeMap.Equiv.toList_eq#doc\">docs#Std.DTreeMap.Equiv.toList_eq</a>). This is however not the case for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.DHashMap#doc\">docs#Std.DHashMap</a> since multiple equivalent hash maps may have different ordering of elements in <code>toList</code>.</p>",
        "id": 543597815,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1759861787
    },
    {
        "content": "<p>And in case you're confused about why congruence matters so much:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span>\n\n<span class=\"c1\">-- both hash sets have different `toList` output</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">17</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"c1\">-- [1, 17]</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"mi\">17</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"c1\">-- [17, 1]</span>\n\n<span class=\"c1\">-- both extensional hash sets are equal</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">th1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">17</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtHashSet</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"mi\">17</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtHashSet</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">or_comm</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- assume a `toList` operation exists</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtHashSet</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">EquivBEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulHashable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtHashSet</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"c1\">-- both extensional hash sets must produce the same `toList` output (but they don't as regular hash sets!)</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">th2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">17</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtHashSet</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"mi\">17</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtHashSet</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">th1</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- =&gt; extensional hash set `toList` can't just be defined through `toList` on regular hash sets</span>\n<span class=\"bp\">````</span>\n</code></pre></div>",
        "id": 543600076,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1759862594
    }
]