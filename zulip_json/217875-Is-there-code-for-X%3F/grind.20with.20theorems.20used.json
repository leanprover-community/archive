[
    {
        "content": "<p>Kim recently added <code>grind +premises</code> (<a href=\"https://github.com/leanprover/lean4/pull/10920\">lean#10920</a>), which I think calls <code>grind</code> with the suggestions from <code>apply?</code>, and then added a linter to try <code>grind +premises</code> at every step of an existing proof (<a href=\"https://github.com/leanprover-community/mathlib4/pull/30808\">#30808</a>).</p>\n<p>Instead of suggestions, for a finished proof is there a way to ask <code>grind</code> to use everything that follows it in the proof?<br>\nFor example, let's say I want to attempt to replace the last line of this proof with <code>grind</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">powersetCard_eq_empty'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">powersetCard</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨?_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">card_eq_zero</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">card_powersetCard</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">choose_eq_zero_of_lt</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">contrapose!</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">nonempty_iff_ne_empty</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exists_subset_card_eq</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">imp</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>Then it'll call <code>grind [nonempty_iff_ne_empty, exists_subset_card_eq, Exists.imp, mem_powersetCard, imp_self, implies_true]</code> since the first 3 are used in the last line and the <code>simp</code> uses the rest.<br>\n(it also needs to remove parameters that cause \"failed to find an usable pattern\" or \"this parameter is redundant\")</p>\n<p>Does this exist / is planned to exist?</p>",
        "id": 546687932,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1761227948
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/10920\">lean4#10920</a> (also <code>permises</code> -&gt; <code>premises</code>)</p>",
        "id": 546699556,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1761230604
    },
    {
        "content": "<p>If this does not exist, is it possible to build?<br>\nI'm not sure how difficult it is to start developing tactics, but I'm willing to try if this is not already in the works</p>",
        "id": 546784580,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1761262835
    },
    {
        "content": "<p><code>grind +premises</code> does not call <code>apply?</code>, but instead uses a configurable premise selector.</p>\n<p>Currently lean doesn't ship with a useful built in premise selector (it ships with a naive implementation of MePo, accessible via <code>set_premise_selector Lean.PremiseSelection.mepoSelector (useRarity := false)</code>, which gives terrible suggestions!) We're working on this, but if others want to write more premise selectors that is wonderful!</p>\n<p>There is a quite good neural premise selector, which supports this API, from the PKU group (<span class=\"user-mention\" data-user-id=\"699571\">@Yutong Wang</span>), which we're hoping to make easily accessible to Mathlib users soon/</p>",
        "id": 546797766,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1761272081
    },
    {
        "content": "<p>I also like your idea of pulling out all constants from the remaining proof. I wonder how to best implement it... We could write <code>grindify</code> which eats a tacticSeq, replays that tactic, extracts constants, and then tries running grind with those as parameters.</p>\n<p><span class=\"user-mention\" data-user-id=\"933054\">@Snir Broshi</span>, does that sound like something you could experiment with? I can put it (low down) on my TODO list as well.</p>",
        "id": 546797938,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1761272183
    },
    {
        "content": "<p>I've never done metaprogramming so far, but I'll give it a shot. Do you happen to have an existing tactic that does a similar thing that I can use as a reference? The closest one I have in mind is <code>suffices</code> but just because it takes in a tacticSeq</p>",
        "id": 546798248,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1761272426
    },
    {
        "content": "<p>how do you propose the syntax to be? as in, in the finished products, what steps exactly would you take to transform that final line <code>exact ...</code> into the desired <code>grind [...</code>?</p>",
        "id": 546798330,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761272520
    },
    {
        "content": "<p>I was thinking of adding a line with <code>grind by</code> (or <code>grindify</code> as Kim suggested) and indenting the rest of the proof by one level, and then it would call <code>grind</code> with extra lemmas.<br>\nAnd possibly having something similar to <code>simp?</code> which let's you click in the info view to replace the entire thing with the equivalent <code>grind</code> call.</p>",
        "id": 546798573,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1761272699
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">powersetCard_eq_empty'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">powersetCard</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨?_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">card_eq_zero</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">card_powersetCard</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">choose_eq_zero_of_lt</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">contrapose!</span>\n<span class=\"w\">  </span><span class=\"n\">grindify</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">nonempty_iff_ne_empty</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exists_subset_card_eq</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">imp</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>\n<hr>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Try</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">apply</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">nonempty_iff_ne_empty</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">exists_subset_card_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">imp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mem_powersetCard</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imp_self</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">implies_true</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 546798739,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1761272834
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"933054\">@Snir Broshi</span> i can write a skeleton for you:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"grindify?\"</span><span class=\"w\"> </span><span class=\"n\">colGt</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">tacticSeq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">withMainContext</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">t</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">powersetCard_eq_empty'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">powersetCard</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨?_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">card_eq_zero</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">card_powersetCard</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">choose_eq_zero_of_lt</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">contrapose!</span>\n<span class=\"w\">  </span><span class=\"n\">grindify?</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">nonempty_iff_ne_empty</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exists_subset_card_eq</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">imp</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">nonempty_iff_ne_empty</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exists_subset_card_eq</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">imp</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">nonempty_iff_ne_empty</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exists_subset_card_eq</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">imp</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 546798848,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761272935
    },
    {
        "content": "<p>Don't forget to with main context</p>",
        "id": 546798888,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761272970
    },
    {
        "content": "<p>You will probably need the brand new <code>grind +lax</code> which I just wrote, that means that when you write <code>grind +lax [X, Y, Z]</code>, any bad parameters (don't exist, can't find good grind patterns, etc) get silently ignored.</p>",
        "id": 546798989,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1761273043
    },
    {
        "content": "<p>(edited with aaron's suggestion)</p>",
        "id": 546799037,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761273070
    },
    {
        "content": "<p>(Although this is probably only available on nightly toolchains, it didn't make it into v4.25.0-rc2)</p>",
        "id": 546799041,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1761273073
    },
    {
        "content": "<p>One can always test the premise selector from reap by <code>set_premise_selector</code> (You need to require <code>reap</code> or on correct mathlib branch)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Reap</span>\n<span class=\"n\">set_premise_selector</span><span class=\"w\"> </span><span class=\"n\">reapSelector</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Set</span>\n\n<span class=\"sd\">/-- If two finite sets are subsets of each other,</span>\n<span class=\"sd\">then they have the same cardinality -/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">suggest_premises</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Premise suggestions: [Finset, Finset.card, And, Eq.symm, Iff.mpr, Finset.empty]</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But I didn't try how these premises work for <code>grind</code>. Maybe need to checkout <code>grind_premise</code> branch to test it?</p>",
        "id": 546845752,
        "sender_full_name": "Yutong Wang",
        "timestamp": 1761296386
    },
    {
        "content": "<p>btw, we are planning to develop an  automatic pipeline to update premise selection database to at least match every mathlib release. So maybe we indeed need a standard benchmark for downstream usage like <code>grind</code> to see the actual benefits.</p>",
        "id": 546846675,
        "sender_full_name": "Yutong Wang",
        "timestamp": 1761296686
    }
]