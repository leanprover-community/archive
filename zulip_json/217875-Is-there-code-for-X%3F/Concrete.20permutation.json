[
    {
        "content": "<p>Do we have a standard way to represent a concrete permutation?</p>\n<p>For example, suppose I wanted to talk about the permutation <code>3, 0, 4, 1, 2</code> of <code>Fin 5</code>, how should I represent it?</p>",
        "id": 522453592,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1749071966
    },
    {
        "content": "<p>Here's one way which I don't particularly like:</p>\n<p>[EDIT: removed to prevent confusing future people as it was nonsense]</p>",
        "id": 522453660,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1749071996
    },
    {
        "content": "<p>What better means exist?</p>",
        "id": 522453697,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1749072009
    },
    {
        "content": "<p>Oh wait, I'm missing the obvious:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">ofBijective</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 522456263,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1749073151
    },
    {
        "content": "<p>Look at <a href=\"https://tqft.net/mathlib4files/Mathlib/GroupTheory/Perm/Cycle/Concrete\">file#Mathlib/GroupTheory/Perm/Cycle/Concrete</a> and around</p>",
        "id": 522456903,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1749073421
    },
    {
        "content": "<p>Thanks! How did I miss this? I think this is a sign I need to go to bed!</p>",
        "id": 522457083,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1749073499
    },
    {
        "content": "<p>OK that is a useful file but it doesn't quite seem to have what I want. Possibly just notation for the construction I outlined above might suffice.</p>",
        "id": 522457847,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1749073863
    },
    {
        "content": "<p>Anyway, I have to stop for now.</p>",
        "id": 522457861,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1749073870
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/24960\">#24960</a> has some links between Fin and Vector, but it evolved into permutations of natural numbers instead</p>",
        "id": 522458687,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749074252
    },
    {
        "content": "<p>Why doesn't c[3,0,4,1,2] work for your use case?</p>",
        "id": 522459485,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1749074666
    },
    {
        "content": "<p>There are two standard ways to represent permutations of {0,1,2,...,n}.  One is the \"product of disjoint cycles\" notation, the other is the \"write down a list, the j'th element of which is where j goes\" and I think Oliver is talking about the latter whereas I think you're talking about the former (but I might be wrong, I don't know this part of the library at all, I just know there are two standard ways to represent permutations)</p>",
        "id": 522460711,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749075243
    },
    {
        "content": "<p>Oliver, surely you're in trouble there because <code>Fintype.equivFin</code> is an arbitrary bijection, and so <code>toPerm [0, 1, 2, 3, 4]</code> is not the identity permutation</p>",
        "id": 522461168,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749075471
    },
    {
        "content": "<p>yeah I think the object Oliver is talking about would be <code>c[3, 0, 1] * c[2, 4]</code> in cycle format, considered as a permutation of <code>0, 1, 2, 3, 4</code> (we move <code>3</code> to where <code>0</code> is, move <code>0</code> to where <code>1</code> is, etc.)</p>",
        "id": 522461771,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1749075800
    },
    {
        "content": "<p>Here's a computable implementation with some annoying proofs absent:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">finIdxOf?_eq_some_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulBEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">finIdxOf?</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">v</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n\n<span class=\"c1\">-- Like `List.get_eq_getElem`</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">get_eq_getElem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">[(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Function</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">toPerm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Injective</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">get</span>\n<span class=\"w\">  </span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">finIdxOf?</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"bp\">.</span><span class=\"n\">surjective_of_injective</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">    </span><span class=\"n\">aesop</span>\n<span class=\"w\">  </span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">dsimp</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">get_of_eq_some</span>\n<span class=\"w\">    </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">get_eq_getElem</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">eq_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ne_of_lt</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">right_inv</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">get_eq_getElem</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">finIdxOf?_eq_some_iff</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval!</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">v</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">toPerm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">eval!</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">v</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">toPerm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"c1\">-- not the same thing</span>\n</code></pre></div>",
        "id": 522461859,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749075846
    },
    {
        "content": "<p><del>The two <code>sorry</code>s look like missing theorems that core or batteries wants, so the fact they're annoying doesn't make this a bad idea</del></p>",
        "id": 522462642,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749076285
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"330967\">@Wrenna Robson</span> already has a proof of them?</p>",
        "id": 522462683,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749076308
    },
    {
        "content": "<p>I would expect to see a List.ofFn somewhere here, to me, Vector is a red herring.</p>",
        "id": 522463992,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1749077097
    },
    {
        "content": "<p>That goes in the wrong direction, it's the opposite to <code>get</code></p>",
        "id": 522464219,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749077218
    },
    {
        "content": "<p>I thought it would be something like Perm.ofFn ![3,0,4,1,2]</p>",
        "id": 522464935,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1749077629
    },
    {
        "content": "<p>My work definitely covers this stuff.</p>",
        "id": 522465188,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749077801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Concrete.20permutation/near/522458687\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/24960\">#24960</a> has some links between Fin and Vector, but it evolved into permutations of natural numbers instead</p>\n</blockquote>\n<p>I don't think this is quite fair as a description. It could easily be \"about\" Fin as well. </p>\n<p>Essentially I have done a lot of work on thinking about concrete permutations in a nice way.</p>",
        "id": 522465351,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749077907
    },
    {
        "content": "<p>I use Vectors though because I wanted fairly nice performance for some specific uses.</p>",
        "id": 522465419,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749077952
    },
    {
        "content": "<p>Edited above to be sorry free, PR'd as <a href=\"https://github.com/leanprover-community/batteries/pull/1262\">batteries#1262</a></p>",
        "id": 522465449,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749077971
    },
    {
        "content": "<p>I have in a repository a nice type which essentially captures \"all finite permutations\" using \"one line notation\" rather than cycle notation.</p>",
        "id": 522465538,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749078017
    },
    {
        "content": "<p>It depends in some ways if you want it for logical and mathematical reasoning or for calculation and computation. I needed the latter. I feel like the existing theories probably cover the former?</p>",
        "id": 522465765,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749078137
    },
    {
        "content": "<p>My argument is that permutations of <code>Fin n</code> are most naturally thought of as permutations of the naturals with finite support because it becomes much more obvious how you should combine them.</p>",
        "id": 522465883,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749078209
    },
    {
        "content": "<p>Cycle notation is obviously also useful for this but sometimes it's useful to just be able to write down a permutation with decomposing it.</p>",
        "id": 522465972,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749078273
    },
    {
        "content": "<p>There's also this method from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.Perm.fin_5_not_solvable#doc\">docs#Equiv.Perm.fin_5_not_solvable</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">Equiv.Perm.fin_5_not_solvable</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">IsSolvable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Equiv.Perm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">⟩</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Equiv.Perm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">⟩</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Equiv.Perm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">⟩</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">⁅</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">⁻¹⁆</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"bp\">⁻¹</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">not_solvable_of_mem_derivedSeries</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">_</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">mem_top</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">key</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">derivedSeries_normal</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mem_comm_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inv_mul_cancel_left</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">commutator_mem_commutator</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">derivedSeries_normal</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">conj_mem</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 522466337,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1749078495
    },
    {
        "content": "<p>Yes I think that kind of construction basically works. As I say on balance I favour, through experience, not having the carrying entries be <code>Fin n</code> but instead <code>Nat</code> - essentially my argument is that the fact that all the entries are less than <code>n</code> should be a global property and not a local one.</p>",
        "id": 522466843,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749078797
    },
    {
        "content": "<p>Sorry if I seem terse about this - it's past midnight here and also my discussion with Eric about it the other day seemed to just go round and round. But I spent months of my time thinking about different ways of doing this and the above is the conclusion I came to. I know that's not a fully-reasoned argument but I haven't written the paper yet.</p>",
        "id": 522467071,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749078908
    },
    {
        "content": "<p>There's an interesting and subtle argument that arises from the fact that you can use injectivity implying surjectivity - in the way that Eric does above - to construct the permutation without knowing all the information you think you'd need to know.</p>",
        "id": 522467325,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749079002
    },
    {
        "content": "<p>But mostly it's just neater and I hate dependent type casting if I can help it (and not making the individual entries <code>Fin n</code> avoids a lot of that).</p>",
        "id": 522467397,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749079045
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ofVector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"bp\">.</span><span class=\"n\">Nodup</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PermOf</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toVector</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">invVector</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"bp\">.</span><span class=\"n\">idxOf</span>\n<span class=\"w\">  </span><span class=\"n\">getElem_toVector_lt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">  </span><span class=\"n\">getElem_invVector_getElem_toVector</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">getElem_map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">getElem_range</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"bp\">.</span><span class=\"n\">idxOf_getElem</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>I do the above construction from a Vector like this.</p>",
        "id": 522524752,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749110359
    },
    {
        "content": "<p>(Note that again here the use of <code>List.idxOf</code>is convenient because we are working with <code>ℕ</code>. As I say I really am quite convinced this is the way to go.)</p>",
        "id": 522527455,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749111140
    },
    {
        "content": "<p>Wow, what a great set of responses :)</p>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> and <span class=\"user-mention\" data-user-id=\"380294\">@Matt Diamond</span> are right of course: I was not using cycle notation, which also answers <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> 's very sensible question about why I didn't want <code>c[3, 0, 4, 1, 2]</code>. Also <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> is right that using <code>Fintype.equivFin</code> was insanity.</p>",
        "id": 522536546,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1749113790
    },
    {
        "content": "<p>What was the context ooi?</p>",
        "id": 522536700,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749113832
    },
    {
        "content": "<p>Just for for some fun, I was toying with the idea if introducing a concrete model for the <code>g2</code> root system. There are lots of ways to do this (especially as the Weyl group is a dihedral group) but my preferred approach requires me to supply data of some explicit permutations.</p>",
        "id": 522537222,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1749113981
    },
    {
        "content": "<p>Permutations on what?</p>",
        "id": 522537404,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749114018
    },
    {
        "content": "<p>Sounds fun, by the way.</p>",
        "id": 522537433,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749114026
    },
    {
        "content": "<p>I now wonder if we should introduce:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">unusedTactic</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"n\">notation3</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prettyPrint</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"p[\"</span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"s2\">\", \"</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">foldr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">)</span><span class=\"s2\">\"]\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">ofBijective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"c1\">-- works!</span>\n</code></pre></div>",
        "id": 522537469,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1749114033
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Concrete.20permutation/near/522537404\">said</a>:</p>\n<blockquote>\n<p>Permutations on what?</p>\n</blockquote>\n<p>This is a choice but pobably <code>Fin 12</code> is the most convenient thing.</p>",
        "id": 522537650,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1749114080
    },
    {
        "content": "<p>So I do like this, but (see above etc.) I think there is value in being able to do, say, <code>p[3, 0, 4, 1, 2] * p[1, 0] = p [0, 3, 4, 1, 2]</code>, say.</p>",
        "id": 522537946,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749114157
    },
    {
        "content": "<p>If you make this <code>Equiv.Perm (Fin n))</code> you can't really do that.</p>",
        "id": 522538054,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749114184
    },
    {
        "content": "<p>You mean it should be computable?</p>\n<p>For once I agree: I would prefer a computable thing here.</p>",
        "id": 522538062,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1749114187
    },
    {
        "content": "<p>Aye. Apologies for linking a random file, but see <code>FinitePerm</code> in this file:<br>\n<a href=\"https://github.com/linesthatinterlace/controlbits/blob/master/CBConcrete/CBConcrete/PermOf/MonoidHom.lean\">https://github.com/linesthatinterlace/controlbits/blob/master/CBConcrete/CBConcrete/PermOf/MonoidHom.lean</a></p>",
        "id": 522538184,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749114228
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">FinitePerm</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"n\">toPermOf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PermOf</span><span class=\"w\"> </span><span class=\"n\">len</span>\n<span class=\"w\">  </span><span class=\"n\">toPermOf_minLen</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">toPermOf</span><span class=\"bp\">.</span><span class=\"n\">minLen</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">len</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n</code></pre></div>",
        "id": 522538201,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749114234
    },
    {
        "content": "<p>Oh I definitely do want a term of type <code>Equiv.Perm α</code> (for some <code>α</code>). The reason my definition above is not computable is that the inverse is not explicit.</p>",
        "id": 522538237,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1749114244
    },
    {
        "content": "<p>Oh that's easy enough to convert to :)</p>",
        "id": 522538285,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749114258
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Concrete.20permutation/near/522538062\">said</a>:</p>\n<blockquote>\n<p>You mean it should be computable?</p>\n<p>For once I agree: I would prefer a computable thing here.</p>\n</blockquote>\n<p>Your strategy is to post deliberately non-computable code to increase engagement and snipe someone into writing the computable version for you, right?</p>",
        "id": 522538364,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749114280
    },
    {
        "content": "<p>Exactly :)</p>",
        "id": 522538404,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1749114291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Concrete.20permutation/near/522538201\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">FinitePerm</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"n\">toPermOf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PermOf</span><span class=\"w\"> </span><span class=\"n\">len</span>\n<span class=\"w\">  </span><span class=\"n\">toPermOf_minLen</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">toPermOf</span><span class=\"bp\">.</span><span class=\"n\">minLen</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">len</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Essentially this is a type that captures \"a finite permutation, written in minimal one-line form\".</p>",
        "id": 522538487,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749114308
    },
    {
        "content": "<p>And it's computable I believe :)</p>",
        "id": 522538505,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749114314
    },
    {
        "content": "<p>Then I have <code>def natPerm : FinitePerm →* Perm ℕ</code> which is basically the conversion to a \"proper\" Equiv.</p>",
        "id": 522538699,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749114365
    },
    {
        "content": "<p>So I <em>think</em> I have already written something that ought to be suitable but I need some help person-handling it into mathlib in the right form.</p>",
        "id": 522538838,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749114405
    },
    {
        "content": "<p>Does Oliver need these extra abstractions, or would Vector.toPerm above suffice, which is computable but not efficient.</p>",
        "id": 522538934,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749114431
    },
    {
        "content": "<p>I think that's <code>nice</code>, but it doesn't solve the issue that being able to do <code>p[3, 0, 4, 1, 2] * p[1, 0] = p [0, 3, 4, 1, 2]</code> etc. is desirable.</p>",
        "id": 522539138,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749114484
    },
    {
        "content": "<p>Yeah I mean <code>Equiv.ofBijective (List.get l) (by decide)</code> is sufficient for me, but I think if we are going to introduce a notation to own <code>p[...]</code> then it probably should be computable, and should describe a term of type <code>Equiv.Perm α</code>.</p>",
        "id": 522539199,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1749114501
    },
    {
        "content": "<p>Basically you kind of want to compute permutations together that aren't the same length. This gives a way of doing that and hides the abstractions.</p>",
        "id": 522539220,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749114505
    },
    {
        "content": "<p>I don't think Oliver's application cares about mixing lengths</p>",
        "id": 522539419,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749114563
    },
    {
        "content": "<p>Right :)</p>",
        "id": 522539484,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749114582
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Concrete.20permutation/near/522539199\">said</a>:</p>\n<blockquote>\n<p>and should describe a term of type <code>Equiv.Perm α</code>.</p>\n</blockquote>\n<p>This could only work with FinEnum</p>",
        "id": 522539528,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749114593
    },
    {
        "content": "<p>Then yeah I think <code>Vector.toPerm</code> or <code>ofVector</code> work fine.</p>",
        "id": 522539560,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749114601
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Concrete.20permutation/near/522539528\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Concrete.20permutation/near/522539199\">said</a>:</p>\n<blockquote>\n<p>and should describe a term of type <code>Equiv.Perm α</code>.</p>\n</blockquote>\n<p>This could only work with FinEnum</p>\n</blockquote>\n<p>Not quite true - it only needs to embed, after all.</p>",
        "id": 522539742,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749114650
    },
    {
        "content": "<p>Basically, if <code>FixGENat n</code> is the subgroup of <code>Perm ℕ</code> which fixes all inputs <code>&gt;= n</code>, what you need is an embedding of <code>Equiv.Perm α</code> into <code>⨆ (n : ℕ), FixGENat n</code>.</p>",
        "id": 522540187,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749114769
    },
    {
        "content": "<p>Well, hmm, I guess <code>α</code> <em>is</em> <code>ℕ</code>. The point is that <code>⨆ (n : ℕ), FixGENat n</code> is much smaller and more controlled than <code>Perm ℕ</code>.</p>",
        "id": 522540453,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749114837
    },
    {
        "content": "<p>(Well, \"smaller\".)</p>",
        "id": 522540529,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749114858
    },
    {
        "content": "<p>I do think having a convenient short notation for <code>Equiv.Perm (Fin n)</code> is an unambiguous good though, it is clearly going to make sense for some applications.</p>",
        "id": 522541270,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749115041
    },
    {
        "content": "<p>I think for other types it doesn't make so much sense, <code>p[A, a, æ]</code> relies on the reader knowing what the canonical order of the type is (the contents of the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FinEnum#doc\">docs#FinEnum</a> instance)</p>",
        "id": 522542713,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749115427
    },
    {
        "content": "<p>I am inclined to agree.</p>",
        "id": 522542819,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749115465
    },
    {
        "content": "<p>You could imagine <code>p[a=&gt;A, A=&gt;a]</code> or something though</p>",
        "id": 522543007,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749115524
    },
    {
        "content": "<p>Oh, that would be quite nice I think.</p>",
        "id": 522543085,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749115546
    },
    {
        "content": "<p>If we want that notation for perms we should have it for regular functions too I think; right now that's only possible for constants on the LHS of the =&gt;</p>",
        "id": 522543228,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749115586
    },
    {
        "content": "<p>In effect what you're talking about there is the <code>two line</code> notation, right?</p>",
        "id": 522543233,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749115586
    },
    {
        "content": "<p>In the sense of <br>\n<a href=\"/user_uploads/3121/TFJspI-RACivTy_PVNvLchOy/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/TFJspI-RACivTy_PVNvLchOy/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"558x192\" src=\"/user_uploads/thumbnail/3121/TFJspI-RACivTy_PVNvLchOy/image.png/840x560.webp\"></a></div>",
        "id": 522543258,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749115594
    },
    {
        "content": "<p>But for a general type.</p>",
        "id": 522543295,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749115608
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Concrete.20permutation/near/522543228\">said</a>:</p>\n<blockquote>\n<p>If we want that notation for perms we should have it for regular functions too I think; right now that's only possible for constants on the LHS of the =&gt;</p>\n</blockquote>\n<p>Of course such functions are precisely those with finite support I think?</p>",
        "id": 522543622,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749115689
    },
    {
        "content": "<p>I am inclined to agree that that would be nice.</p>",
        "id": 522543725,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749115718
    },
    {
        "content": "<p>I'm not sure what the efficient way to calculate that such an (asserted) permutation is actually a permutation is.</p>",
        "id": 522543994,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749115794
    },
    {
        "content": "<p>I don't think we care about efficient, <code>decide</code> is enough</p>",
        "id": 522544188,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749115839
    },
    {
        "content": "<p>Well, true - I guess I meant I wasn't sure what procedure <code>decide</code> would use, if the underlying type is not finite.</p>",
        "id": 522544299,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749115865
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Concrete.20permutation/near/522543622\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Concrete.20permutation/near/522543228\">said</a>:</p>\n<blockquote>\n<p>If we want that notation for perms we should have it for regular functions too I think; right now that's only possible for constants on the LHS of the =&gt;</p>\n</blockquote>\n<p>Of course such functions are precisely those with finite support I think?</p>\n</blockquote>\n<p>(I take it from the react that this is not correct - what am I missing?)</p>",
        "id": 522544419,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749115898
    },
    {
        "content": "<p>You only need to decide anything when building the permutation, there's nothing to decide for a raw function (eg the function that swaps π and e and is the identity elsewhere)</p>",
        "id": 522544492,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749115916
    },
    {
        "content": "<p>Sure, agreed on that.</p>",
        "id": 522544584,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749115936
    },
    {
        "content": "<p>But suppose you have p[π=&gt;e, e=&gt;π]. What does decide do to construct the permutation?</p>",
        "id": 522544740,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749115978
    },
    {
        "content": "<p>Well, the comment I <span aria-label=\"-1\" class=\"emoji emoji-1f44e\" role=\"img\" title=\"-1\">:-1:</span> d was about functions not perms...</p>",
        "id": 522544853,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749116007
    },
    {
        "content": "<p>No I know, I just would have thought that, in theory, every function with finite support could be written in this notation.</p>",
        "id": 522544951,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749116035
    },
    {
        "content": "<p>Indeed, and such notation already exists (with \"support\" meaning \"not zero\")</p>",
        "id": 522545033,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749116058
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Concrete.20permutation/near/522544740\">said</a>:</p>\n<blockquote>\n<p>But suppose you have p[π=&gt;e, e=&gt;π]. What does decide do to construct the permutation?</p>\n</blockquote>\n<p>Bijectivity on the finite support</p>",
        "id": 522545124,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749116084
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Concrete.20permutation/near/522543228\">said</a>:</p>\n<blockquote>\n<p>If we want that notation for perms we should have it for regular functions too I think; right now that's only possible for constants on the LHS of the =&gt;</p>\n</blockquote>\n<p>Oh, maybe I misunderstood this comment, then.</p>",
        "id": 522545202,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749116103
    },
    {
        "content": "<p>I took that to mean we either didn't have it for regular functions or in a limited case (though I suppose I am not certain what you meant by constants on the LHS of the =&gt;).</p>",
        "id": 522545611,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749116206
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Concrete.20permutation/near/522545124\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Concrete.20permutation/near/522544740\">said</a>:</p>\n<blockquote>\n<p>But suppose you have p[π=&gt;e, e=&gt;π]. What does decide do to construct the permutation?</p>\n</blockquote>\n<p>Bijectivity on the finite support</p>\n</blockquote>\n<p>Right, so ultimately <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Fintype/Defs.html#Fintype.decidableBijectiveFintype\">Fintype.decidableBijectiveFintype</a>?</p>",
        "id": 522545810,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749116259
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Concrete.20permutation/near/522537946\">said</a>:</p>\n<blockquote>\n<p>So I do like this, but (see above etc.) I think there is value in being able to do, say, <code>p[3, 0, 4, 1, 2] * p[1, 0] = p [0, 3, 4, 1, 2]</code>, say.</p>\n</blockquote>\n<p><code>p[1, 0]</code> makes no sense, right? Or should it expand to <code>p[1, 0, 2, 3, 4]</code>?</p>",
        "id": 522546471,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749116462
    },
    {
        "content": "<p>Yes, that.</p>",
        "id": 522546528,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749116476
    },
    {
        "content": "<p>But the nice thing about my <code>FinitePerm</code> type is that it doesn't matter for this kind of thing.</p>",
        "id": 522546735,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749116529
    },
    {
        "content": "<p>i.e. you can just mash together permutations of different lengths, computably, and not worry about expanding them to the same length.</p>",
        "id": 522546806,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749116550
    },
    {
        "content": "<p>So in fact it is true that <code>p[1, 0] = p[1, 0, 2] = p[1, 0, 2, 3]</code>, etc.</p>",
        "id": 522547003,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749116604
    },
    {
        "content": "<p>I would guess that in 90% of cases this would  just be a trap for users</p>",
        "id": 522548353,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749117016
    },
    {
        "content": "<p>Fair!</p>",
        "id": 522548411,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749117039
    },
    {
        "content": "<p>Ultimately I <em>didn't</em> use that part, that was just for fun, so I haven't \"field tested\" it.</p>",
        "id": 522548490,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749117067
    },
    {
        "content": "<p>I think this <code>=&gt;</code> notation would be useful though, quite agree there.</p>",
        "id": 522549012,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749117237
    },
    {
        "content": "<p>Notably though, like, <code>p[0=&gt;1, 1=&gt;0]</code> in that notation is very similar. So I am not sure why you feel that's less of a trap.</p>",
        "id": 522549246,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749117306
    },
    {
        "content": "<p>FWIW here are the concrete permutations in action <a href=\"https://github.com/leanprover-community/mathlib4/pull/25480\">#25480</a> (this is a bit of an experimental PR --- I'm not sure about the design just yet)</p>",
        "id": 522566986,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1749122928
    }
]