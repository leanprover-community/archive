[
    {
        "content": "<p>I'd like an attribute (or something similar) for instances that generates appropriate abbreviations for dot notation. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Str</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">dotify</span><span class=\"w\"> </span><span class=\"n\">Str</span><span class=\"kd\">]</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToString</span><span class=\"w\"> </span><span class=\"n\">Str</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ToString</span><span class=\"bp\">.</span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">str</span><span class=\"bp\">.</span><span class=\"n\">n</span>\n\n<span class=\"c1\">-- The use of dotify above generates:</span>\n<span class=\"c1\">-- def Str.toString : Str → String := ToString.toString</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Str</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"c1\">-- This works because of the generated abbrev. Otherwise, it'd throw an error as usual.</span>\n</code></pre></div>\n<p>Does this exist already perhaps? It look feasible but nontrivial, as identifying the definitions that should be abbreviated requires some care. I guess one could also provide a parameter to force the inclusion/exclusion of some definitions.</p>\n<p>We could really use this in CSLib, to avoid a proliferation of manually-written abbreviations.</p>",
        "id": 554475581,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762601532
    },
    {
        "content": "<p>how do you generate the name? Does it only do one-field classes</p>",
        "id": 554475706,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762601668
    },
    {
        "content": "<p>You mean <code>Str</code>? I passed it as an argument to the annotation.</p>",
        "id": 554475757,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762601718
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Deriving.20dot.20notation.20from.20class.20instances/near/554475581\">said</a>:</p>\n<blockquote>\n<p>Does this exist already perhaps? It look feasible but nontrivial, as identifying the definitions that should be abbreviated requires some care. I guess one could also provide a parameter to force the inclusion/exclusion of some definitions.</p>\n</blockquote>\n<p>This probably doesn't exist but probably isn't too hard to make</p>",
        "id": 554475780,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762601737
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Deriving.20dot.20notation.20from.20class.20instances/near/554475757\">said</a>:</p>\n<blockquote>\n<p>You mean <code>Str</code>? I passed it as an argument to the annotation.</p>\n</blockquote>\n<p>I mean the name <code>Str.toString</code></p>",
        "id": 554475787,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762601756
    },
    {
        "content": "<p>Here's a first informal idea:</p>\n<p>Say I use <code>@[dotify T]</code>.<br>\nThis looks for all names under the class namespace (this would find <code>toString</code>), filters to get only those whose signature starts by taking an explicit parameter of type <code>T</code>, and then produces an abbreviation for each under <code>T</code>'s namespace.</p>",
        "id": 554475907,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762601921
    },
    {
        "content": "<p>ok</p>",
        "id": 554476102,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762602113
    },
    {
        "content": "<p>that's an algorithm I can follow</p>",
        "id": 554476108,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762602121
    },
    {
        "content": "<p>Something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span>\n\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">dotify</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">target</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getConstVal</span><span class=\"w\"> </span><span class=\"n\">inst</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">doCompile</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"n\">isNoncomputable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">inst</span>\n<span class=\"w\">  </span><span class=\"n\">forallTelescopeReducing</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">whnfType</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">body</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">instApp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkAppN</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">levelParams</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">Level</span><span class=\"bp\">.</span><span class=\"n\">param</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">traverse</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">instApp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"n\">ty</span><span class=\"bp\">.</span><span class=\"n\">withApp</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"n\">nm</span><span class=\"w\"> </span><span class=\"n\">us</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"not a class: {body}\"</span>\n<span class=\"w\">      </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"n\">isClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">nm</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"not a class: {body}\"</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">info</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">getStructureInfo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">nm</span>\n<span class=\"w\">      </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">field</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">info</span><span class=\"bp\">.</span><span class=\"n\">fieldInfo</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">projApp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkAppN</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"n\">field</span><span class=\"bp\">.</span><span class=\"n\">projFn</span><span class=\"w\"> </span><span class=\"n\">us</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">instApp</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">projType</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferType</span><span class=\"w\"> </span><span class=\"n\">projApp</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">field</span><span class=\"bp\">.</span><span class=\"n\">subobject?</span><span class=\"bp\">.</span><span class=\"n\">isSome</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">          </span><span class=\"n\">traverse</span><span class=\"w\"> </span><span class=\"n\">projApp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">whnf</span><span class=\"w\"> </span><span class=\"n\">projType</span><span class=\"o\">)</span>\n<span class=\"w\">          </span><span class=\"n\">continue</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">target</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">field</span><span class=\"bp\">.</span><span class=\"n\">fieldName</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">          </span><span class=\"n\">continue</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkForallFVars</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">projType</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkLambdaFVars</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">projApp</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isProp</span><span class=\"w\"> </span><span class=\"n\">projType</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">          </span><span class=\"n\">addDecl</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">thmDecl</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">            </span><span class=\"n\">name</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">value</span>\n<span class=\"w\">            </span><span class=\"n\">levelParams</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">levelParams</span>\n<span class=\"w\">          </span><span class=\"o\">}</span>\n<span class=\"w\">        </span><span class=\"k\">else</span>\n<span class=\"w\">          </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Declaration</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">defnDecl</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">            </span><span class=\"n\">name</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">value</span>\n<span class=\"w\">            </span><span class=\"n\">levelParams</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">levelParams</span>\n<span class=\"w\">            </span><span class=\"n\">hints</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"kn\">abbrev</span>\n<span class=\"w\">            </span><span class=\"n\">safety</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">safe</span>\n<span class=\"w\">          </span><span class=\"o\">}</span>\n<span class=\"w\">          </span><span class=\"n\">addDecl</span><span class=\"w\"> </span><span class=\"n\">decl</span>\n<span class=\"w\">          </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">doCompile</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">            </span><span class=\"n\">compileDecl</span><span class=\"w\"> </span><span class=\"n\">decl</span>\n<span class=\"w\">    </span><span class=\"n\">traverse</span><span class=\"w\"> </span><span class=\"n\">instApp</span><span class=\"w\"> </span><span class=\"n\">body</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Str</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">instToStringStr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToString</span><span class=\"w\"> </span><span class=\"n\">Str</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ToString</span><span class=\"bp\">.</span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">str</span><span class=\"bp\">.</span><span class=\"n\">n</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval!</span><span class=\"w\"> </span><span class=\"n\">dotify</span><span class=\"w\"> </span><span class=\"ss\">``instToStringStr</span><span class=\"w\"> </span><span class=\"ss\">`Str</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">Str</span><span class=\"bp\">.</span><span class=\"n\">toString</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">RealClone</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Real</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ConditionallyCompleteLinearOrderedField</span><span class=\"w\"> </span><span class=\"n\">RealClone</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ConditionallyCompleteLinearOrderedField</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval!</span><span class=\"w\"> </span><span class=\"n\">dotify</span><span class=\"w\"> </span><span class=\"ss\">``instConditionallyCompleteLinearOrderedFieldRealClone</span><span class=\"w\"> </span><span class=\"ss\">`RealClone</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">RealClone</span><span class=\"bp\">.</span><span class=\"n\">one_mul</span>\n</code></pre></div>\n<p>... although I didn't do the \"filters ...\" part</p>",
        "id": 554484382,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1762610053
    },
    {
        "content": "<p>I need to read up some more about macro development to fully understand it, but the effect looks pretty good, thanks!</p>\n<p>I've found a few discussions with desiderata that could be (at least partially) addressed by such an annotation:</p>\n<p><a href=\"https://leanprover-community.github.io/archive/stream/270676-lean4/topic/class.20dot.20notation.html\">https://leanprover-community.github.io/archive/stream/270676-lean4/topic/class.20dot.20notation.html</a><br>\n<a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/channel/113489-new-members/topic/Why.20Dot.20notation.20doesn.27t.20work.20for.20instance.20methods.3F/with/453924206\">#new members &gt; Why Dot notation doesn't work for instance methods?</a> <br>\n<a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/channel/113489-new-members/topic/Why.20is.20dot-notation.20not.20working.20here.3F/with/537042353\">#new members &gt; Why is dot-notation not working here?</a> </p>\n<p>Hence the question: where should this (or some version of this) go? I'd like to be able to use it in CSLib, but maybe it could be good to put it in batteries? I don't know if there are plans to include a feature like this in Lean.</p>",
        "id": 554500324,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762624992
    },
    {
        "content": "<p>Suppose the dot-notation discussed above works, in the sense that one can use it in an expression and the expression compiles.  But will all  the theorems reachable via the dot-notation also be available to tactics like <code>grind</code> and <code>simp</code>?  In the particular application that motivates this thread, we have a class like <code>Acceptor</code> below.  Will the instances of <code>language</code> and <code>mem_language</code> be also be available to <code>grind</code> because of their <code>grind</code> annotations?  If I still have to make instances of them and put the <code>grind</code> annotation on them, what exactly does the dot-notation buy me?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- An `Acceptor` is a machine that recognises strings (lists of symbols in an alphabet). -/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Predicate that establishes whether a string `xs` is accepted. -/</span>\n<span class=\"w\">  </span><span class=\"n\">Accepts</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- The language of an `Acceptor` is the set of strings it `Accepts`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">scoped</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Accepts</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- A string is in the language of an acceptor iff the acceptor accepts it. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">scoped</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">mem_language</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Accepts</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Iff</span><span class=\"bp\">.</span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 554501460,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762626230
    },
    {
        "content": "<p>They might, I tried with manually-written abbrevs and it worked once (that's why I wanted abbrevs). But it needs further testing. If it doesn't work out of the box, we might need to replicate the grind annotations.</p>",
        "id": 554501568,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762626345
    },
    {
        "content": "<p>If I need to replicate the <code>grind</code> annotation for each instance of <code>Acceptor</code>, then what does <code>Acceptor</code> buy me?</p>",
        "id": 554502455,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762627213
    },
    {
        "content": "<p><code>grind</code> eagerly unfolds all reducible declarations so <code>abbrev</code>s don't need new <code>grind</code> annotations</p>",
        "id": 554502590,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1762627332
    },
    {
        "content": "<p>For the sake of the argument: If we can't get grind to work I wouldn't use abbreviations for Acceptor at all then, or it'd kill the point of code deduplication. It'd become a choice between code deduplication (Acceptor) or having dot notation (copy defs for all instances).</p>\n<p>But there's a good chance it'll work, we should check.</p>",
        "id": 554502623,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762627371
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Deriving.20dot.20notation.20from.20class.20instances/near/554502590\">said</a>:</p>\n<blockquote>\n<p><code>grind</code> eagerly unfolds all reducible declarations so <code>abbrev</code>s don't need new <code>grind</code> annotations</p>\n</blockquote>\n<p>Precisely this.</p>",
        "id": 554502644,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762627391
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"873547\">@Robin Arnez</span> Just to be clear: Are you saying that if <code>language</code> above is declared using <code>abbrev</code> instead of <code>def</code>, then for every instance of <code>Acceptor</code>, <code>grind</code> will find the corresponding instances of <code>language</code> and <code>mem_language</code>?  Note that the latter two are only in the namespace of <code>Acceptor</code>, not in the class declaration proper.</p>",
        "id": 554503478,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762628221
    },
    {
        "content": "<p>No, the proxy def should be an abbrev (for example, DA.FinAcc.language in our current case in cslib).</p>",
        "id": 554503559,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762628312
    },
    {
        "content": "<p>(and the macro we're discussing produces these proxy defs automatically)</p>",
        "id": 554503588,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762628343
    },
    {
        "content": "<p>So you are saying that I still have to make a <code>abbrev</code> definition for <code>DA.FinAcc.language</code> but I don't have to repeat the <code>mem_language</code> theorem for that instance?  If so, is the saving (which is 4 lines of code) worth the introduction of an \"acceptor\" concept and the need for extending Lean?  Note that the introduction of a new concept is not free either.  It's one additional of indirection for a human reader of the code to comprehend and one additional file for Lean to load.</p>",
        "id": 554504783,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762629508
    },
    {
        "content": "<p>No, you wouldn't need language either. You would just need the instance as we have now (annotated with @[dotify] or whatever we end up calling it).</p>",
        "id": 554504883,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762629641
    },
    {
        "content": "<p>OK, we saved another 4 lines of code.  But it still seems to me that the concepts being abstracted into <code>Acceptor</code> are so meager that the saving from code deduplication does not justify the additional level of indirection and the need for extending Lean.</p>",
        "id": 554505421,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762630247
    },
    {
        "content": "<p>Maybe let's discuss further the particular application to CSlib in that channel as to not get too off-topic for this thread.</p>",
        "id": 554505554,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762630396
    },
    {
        "content": "<p>Recently I wanted something similar. One field structures are used to do function overloading so I decided to streamline the notation for it and it supports dot notation too. </p>\n<p>You first declare the function</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">declfun</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>then define it for some types</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">defun</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span>\n<span class=\"n\">defun</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"bp\">*</span><span class=\"n\">x</span>\n</code></pre></div>\n<p>or for structures</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Vector2</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Vector2</span>\n<span class=\"n\">defun</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Vector2</span>\n</code></pre></div>\n<p>Now you can call</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- 100</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"mi\">10</span>\n<span class=\"c1\">-- 20</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"mf\">10.0</span>\n<span class=\"c1\">-- { x := 2.000000, y := 4.000000 }</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Vector2</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mf\">1.0</span><span class=\"w\"> </span><span class=\"mf\">2.0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">foo</span>\n</code></pre></div>\n<p>For structures either <code>foo (Vector2.mk 1.0 2.0)</code> or <code>(Vector2.mk 1.0 2.0).foo</code> works. The later is exactly the problem in question here.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">HouLean.Meta</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Declare an overloadable function by creating a single-method typeclass.</span>\n\n<span class=\"sd\">## Example</span>\n<span class=\"sd\">```lean</span>\n<span class=\"sd\">declfun sin {α} (x : α) : α</span>\n<span class=\"sd\">```</span>\n\n<span class=\"sd\">This creates a typeclass `Sin` with a single method `sin`. You can then define</span>\n<span class=\"sd\">overloads using `defun`:</span>\n\n<span class=\"sd\">```lean</span>\n<span class=\"sd\">defun sin (x : Float) := x.sin</span>\n<span class=\"sd\">defun sin (x : Float32) := x.sin</span>\n<span class=\"sd\">defun Vector2.sin (u : Vector2) : Vector2 := ⟨u.x.sin, u.y.sin⟩</span>\n<span class=\"sd\">```</span>\n\n<span class=\"sd\">## Implementation Details</span>\n<span class=\"sd\">Internally, `declfun` creates a typeclass and exports its method. For example,</span>\n<span class=\"sd\">`declfun sin {α} (x : α) : α` generates:</span>\n<span class=\"sd\">```lean</span>\n<span class=\"sd\">class Sin (α : Type) where</span>\n<span class=\"sd\">  sin (x : α) : α</span>\n<span class=\"sd\">export Sin (sin)</span>\n<span class=\"sd\">```</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">syntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">docComment</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"s2\">\"declfun\"</span><span class=\"w\"> </span><span class=\"n\">declId</span><span class=\"w\"> </span><span class=\"n\">bracketedBinder</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"s2\">\":\"</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Define an overload for a function declared with `declfun`.</span>\n\n<span class=\"sd\">## Example</span>\n<span class=\"sd\">```lean</span>\n<span class=\"sd\">-- Simple overload</span>\n<span class=\"sd\">defun sin (x : Float) := x.sin</span>\n\n<span class=\"sd\">-- Member function (automatically creates both the function and the overload instance)</span>\n<span class=\"sd\">defun Vector2.sin (u : Vector2) : Vector2 := ⟨u.x.sin, u.y.sin⟩</span>\n<span class=\"sd\">```</span>\n\n<span class=\"sd\">## Behavior</span>\n<span class=\"sd\">- For simple names like `sin`, `defun` creates an instance of the corresponding typeclass</span>\n<span class=\"sd\">- For qualified names like `Vector2.sin`, it defines the member function and creates an instance</span>\n\n<span class=\"sd\">## Implementation Details</span>\n<span class=\"sd\">`defun` generates typeclass instances. For example, `defun sin (x : Float) := x.sin`</span>\n<span class=\"sd\">creates:</span>\n<span class=\"sd\">```lean</span>\n<span class=\"sd\">instance : Sin Float where</span>\n<span class=\"sd\">  sin x := x.sin</span>\n<span class=\"sd\">```</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">syntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">docComment</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"s2\">\"defun\"</span><span class=\"w\"> </span><span class=\"n\">declId</span><span class=\"w\"> </span><span class=\"n\">bracketedBinder</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s2\">\":\"</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"s2\">\":=\"</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean.Parser.Term</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"sd\">/-- Extract leading implicit and instance implicit binders from a binder array. -/</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">extractImplicitBinders</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">binders</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TSyntaxArray</span><span class=\"w\"> </span><span class=\"ss\">``bracketedBinder</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">``bracketedBinder</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">``bracketedBinder</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">implicit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">binders.takeWhile</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">``bracketedBinder</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">implicit</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"o\">[</span><span class=\"n\">implicit.size</span><span class=\"o\">:])</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean.Parser.Term</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"sd\">/-- Convert implicit binders `{x}` to explicit binders `(x)`. -/</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">implicitBindersToExplicit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">binders</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TSyntaxArray</span><span class=\"w\"> </span><span class=\"ss\">``bracketedBinder</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">MacroM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TSyntaxArray</span><span class=\"w\"> </span><span class=\"ss\">``bracketedBinder</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">binders.mapM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">``bracketedBinder</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"n\">elab_rules</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">doc</span><span class=\"o\">:</span><span class=\"n\">docComment</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"n\">declfun</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">bs</span><span class=\"o\">:</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">className</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">id.getId.capitalize</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">classBinders</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">funBinders</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">extractImplicitBinders</span><span class=\"w\"> </span><span class=\"n\">bs</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">classBinders</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">liftMacroM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">implicitBindersToExplicit</span><span class=\"w\"> </span><span class=\"n\">classBinders</span>\n\n<span class=\"w\">  </span><span class=\"n\">elabCommand</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">className</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">classBinders</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">      </span><span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">doc</span><span class=\"o\">:</span><span class=\"n\">docComment</span><span class=\"o\">]</span><span class=\"bp\">?</span>\n<span class=\"w\">      </span><span class=\"bp\">$</span><span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">funBinders</span><span class=\"o\">:</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">))</span>\n\n<span class=\"w\">  </span><span class=\"n\">elabCommand</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kn\">export</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">className</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">id</span><span class=\"o\">)))</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"n\">elab_rules</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">doc</span><span class=\"o\">:</span><span class=\"n\">docComment</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"n\">defun</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">bs</span><span class=\"o\">:</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">body</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"n\">id.getId.isStr</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"invalid function name {id}\"</span>\n\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">funName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">id.getId.getString</span><span class=\"bp\">!</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">className</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">funName.capitalize</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">funId</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">resolveGlobalConstNoOverload</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Name.mkSimple</span><span class=\"w\"> </span><span class=\"n\">className</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">mkSimple</span><span class=\"w\"> </span><span class=\"n\">funName</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">classId</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">resolveGlobalConstNoOverload</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Name.mkSimple</span><span class=\"w\"> </span><span class=\"n\">className</span><span class=\"o\">)</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Elaborate function definition</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Term.elabBinders</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">ty.mapM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">elabTermAndSynthesize</span><span class=\"w\"> </span><span class=\"n\">body</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">?</span>\n<span class=\"w\">      </span><span class=\"n\">mkLambdaFVars</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferType</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span>\n\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">F.hasLevelMVar</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"Universe polymorphic functions are not supported yet!\"</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Prepare function declaration with mvars</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">funExpr</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkConstWithFreshMVarLevels</span><span class=\"w\"> </span><span class=\"n\">funId</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">classExpr</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkConstWithFreshMVarLevels</span><span class=\"w\"> </span><span class=\"n\">classId</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">forallMetaTelescope</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferType</span><span class=\"w\"> </span><span class=\"n\">classExpr</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">classExpr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">classExpr.beta</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVar</span><span class=\"w\"> </span><span class=\"n\">classExpr</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">funExpr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">funExpr.beta</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys.push</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">funType</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferType</span><span class=\"w\"> </span><span class=\"n\">funExpr</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Overload should have the same type, which fills type mvars</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">funType</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">classExpr</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span><span class=\"w\"> </span><span class=\"n\">classExpr</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">classId.append</span><span class=\"w\"> </span><span class=\"ss\">`mk</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span>\n\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ns</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getCurrNamespace</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">strName</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">id.getId.getNumParts</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">          </span><span class=\"n\">id.getId.getPrefix</span>\n<span class=\"w\">        </span><span class=\"k\">else</span>\n<span class=\"w\">          </span><span class=\"n\">ns</span>\n\n<span class=\"w\">      </span><span class=\"c1\">-- Handle member function case</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"n\">strName</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"c1\">-- Resolve namespace properly</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">funName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">id.getId.getString</span><span class=\"bp\">!</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">strId</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">resolveGlobalConstNoOverload</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"n\">strName</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">declId</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">strId.append</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">mkSimple</span><span class=\"w\"> </span><span class=\"n\">funName</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">hints</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ReducibilityHints.regular</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">getMaxHeight</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean.mkDefinitionValInferringUnsafe</span><span class=\"w\"> </span><span class=\"n\">declId</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">hints</span>\n<span class=\"w\">        </span><span class=\"n\">addDeclarationRangesFromSyntax</span><span class=\"w\"> </span><span class=\"n\">declId</span><span class=\"w\"> </span><span class=\"n\">id</span>\n\n\n<span class=\"w\">        </span><span class=\"c1\">-- Add documentation if provided</span>\n<span class=\"w\">        </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">doc</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">doc</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">          </span><span class=\"n\">addDecl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Declaration.defnDecl</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"o\">)</span>\n<span class=\"w\">          </span><span class=\"n\">addDocString</span><span class=\"w\"> </span><span class=\"n\">declId</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkNullNode</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">doc</span>\n<span class=\"w\">          </span><span class=\"n\">compileDecl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Declaration.defnDecl</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">          </span><span class=\"n\">addAndCompile</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Declaration.defnDecl</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"o\">)</span>\n\n<span class=\"w\">        </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">classId.append</span><span class=\"w\"> </span><span class=\"ss\">`mk</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"n\">declId</span><span class=\"w\"> </span><span class=\"o\">[])]</span>\n\n<span class=\"w\">      </span><span class=\"c1\">-- Generate and add instance</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">instName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getCurrNamespace</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">NameGen.mkBaseNameWithSuffix</span><span class=\"w\"> </span><span class=\"s2\">\"inst\"</span><span class=\"w\"> </span><span class=\"n\">classExpr</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"n\">instName</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"Enviroment already contains {instName}\"</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">hints</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ReducibilityHints.regular</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">getMaxHeight</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean.mkDefinitionValInferringUnsafe</span><span class=\"w\"> </span><span class=\"n\">instName</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">classExpr</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"n\">hints</span>\n<span class=\"w\">      </span><span class=\"n\">addAndCompile</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Declaration.defnDecl</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">addInstance</span><span class=\"w\"> </span><span class=\"n\">instName</span><span class=\"w\"> </span><span class=\"n\">AttributeKind.global</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eval_prio</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">addDeclarationRangesFromSyntax</span><span class=\"w\"> </span><span class=\"n\">instName</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"Invalid function type {F}, expected {funType}!\"</span>\n\n\n<span class=\"kd\">end</span><span class=\"w\"> </span><span class=\"n\">HouLean.Meta</span>\n\n\n\n<span class=\"n\">declfun</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"n\">defun</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span>\n<span class=\"n\">defun</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"bp\">*</span><span class=\"n\">x</span>\n\n<span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">Vector2</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Vector2</span>\n<span class=\"n\">defun</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">⟩</span>\n<span class=\"kd\">end</span><span class=\"w\"> </span><span class=\"n\">Vector2</span>\n\n<span class=\"c1\">-- 100</span>\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"mi\">10</span>\n<span class=\"c1\">-- 20</span>\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"bp\">.</span><span class=\"mi\">0</span>\n<span class=\"c1\">-- { x := 2.000000, y := 4.000000 }</span>\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Vector2.mk</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>\n</div></div>",
        "id": 554623093,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1762752537
    },
    {
        "content": "<p>Using <code>abbrev</code> purely for dot notation is suboptimal, since e.g. <code>rw</code> works very syntactically, i.e. won't see through an abbrev at the top level and may unexpectedly not fire.<br>\nThe same may be true for other tactics. A way to call the original function with dot notation would be much safer of course.<br>\nThere is an open <a href=\"https://github.com/leanprover/lean4/issues/5482\">RFC</a> on dot notation, <span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span>  maybe you want to add some motivating examples there and reference this zulip thread.<br>\nIt could also use some upvotes i guess :)</p>",
        "id": 575546546,
        "sender_full_name": "Moritz R",
        "timestamp": 1771941155
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"602461\">Moritz R</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Deriving.20dot.20notation.20from.20class.20instances/near/575546546\">said</a>:</p>\n<blockquote>\n<p>Using <code>abbrev</code> purely for dot notation is suboptimal, since e.g. <code>rw</code> works very syntactically, i.e. won't see through an abbrev at the top level and may unexpectedly not fire.<br>\nThe same may be true for other tactics. A way to call the original function with dot notation would be much safer of course.<br>\nThere is an open <a href=\"https://github.com/leanprover/lean4/issues/5482\">RFC</a> on dot notation, <span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span>  maybe you want to add some motivating examples there and reference this zulip thread.<br>\nIt could also use some upvotes i guess :)</p>\n</blockquote>\n<p>Will do. Thanks for the ref!</p>",
        "id": 575762200,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1772022677
    }
]