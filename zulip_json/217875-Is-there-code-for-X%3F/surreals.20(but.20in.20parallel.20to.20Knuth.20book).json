[
    {
        "content": "<p>Hello Lean Community,</p>\n<p>I was wondering if anyone had tried to do the surreal numbers in Lean but following the exposition in Knuthâ€™s book?</p>\n<p>We have them as part of the combinatorial games library (amazing), but I was curious if there was a nice way to develop them in Knuth.</p>\n<p>Presumably the first attempts using Sets would founder eventually (?) because the surreals get pretty surreal. But doing that refactor would be a nice pedagogical exercise.</p>\n<p>If anyone has tried this and wants to share their experience Iâ€™d be very grateful! Again this is largely a pedagogical exercise for me.</p>\n<p>Simon</p>",
        "id": 557947425,
        "sender_full_name": "Simon DeDeo",
        "timestamp": 1763475741
    },
    {
        "content": "<p>Our resident expert on surrealism is <span class=\"user-mention\" data-user-id=\"459227\">@Violeta HernÃ¡ndez</span></p>",
        "id": 557961456,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1763478559
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"557100\">Simon DeDeo</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/557947425\">said</a>:</p>\n<blockquote>\n<p>I was wondering if anyone had tried to do the surreal numbers in Lean but following the exposition in Knuthâ€™s book?</p>\n</blockquote>\n<p>I'm not knowledgeable on the specifics of Knuth's book. Are there any notable differences in his treatment of the topic compared to Conway?</p>",
        "id": 557984005,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1763483096
    },
    {
        "content": "<p>Regarding sets: one could in theory re-implement <a href=\"https://vihdzp.github.io/combinatorial-games/find/?pattern=IGame#doc\">CGT#IGame</a> in terms of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZFSet#doc\">docs#ZFSet</a>, as a subtype of Kuratowski pairs. But frankly ZFC's treatment of ordered pairs has always seemed to me like a bit of a hack.</p>",
        "id": 557985464,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1763483448
    },
    {
        "content": "<p>And this wouldn't let us as readily talk about loopy games.</p>",
        "id": 557985612,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1763483486
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"557100\">Simon DeDeo</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/557947425\">said</a>:</p>\n<blockquote>\n<p>I was wondering if anyone had tried to do the surreal numbers in Lean but following the exposition in Knuthâ€™s book?</p>\n</blockquote>\n<p>I tried a few weeks ago, but using lists instead of sets:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">PseudoNumber</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">PseudoNumber</span>\n<span class=\"w\">  </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">PseudoNumber</span>\n</code></pre></div>\n<p>Then I defined â‰¤ for pseudonumbers and defined surreal numbers as a subtype of pseudonumbers. Unfortunately this approach using lists can't represent surreal numbers where one of the lists should be infinite, but it'll at least get you through the first few chapters of Knuth's book.</p>",
        "id": 557987448,
        "sender_full_name": "Anthony Wang",
        "timestamp": 1763483929
    },
    {
        "content": "<p>My code is at <a href=\"http://git.unnamed.website/miscelleaneous/tree/Surreal.lean\">http://git.unnamed.website/miscelleaneous/tree/Surreal.lean</a> but it's very unpolished and low-quality.</p>",
        "id": 557987857,
        "sender_full_name": "Anthony Wang",
        "timestamp": 1763484021
    },
    {
        "content": "<p>This is not at all dissimilar from what the CGT codebase does. There's some category theory black magic hiding the fact, which is necessary for some very technical reasons, but morally <code>IGame</code> is just defined as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">IGame</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ofSets</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">IGame</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Small</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Small</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IGame</span>\n</code></pre></div>\n<p>That is to say, a game (up to identity) is defined as a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Small#doc\">docs#Small</a> set of other games. In Lean, small sets are basically the same things as just sets in ZFC (large sets would be proper classes).</p>",
        "id": 557989451,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1763484383
    },
    {
        "content": "<p>Just took a look through the codebase. I think everything in there is covered already by Game/IGame.lean and Game/Surreal.lean. Though a very important caveat is that the way that you defined surreals doesn't have the \"correct\" equality, since you'll have e.g. <code>âŸ¨[0, 1], []âŸ© â‰  âŸ¨[1], []âŸ©</code>.</p>",
        "id": 557992673,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1763485112
    },
    {
        "content": "<p>Thank you both! Knuth is very informal â€” it's literally a dialogue, with a lot of informal set theory talk. I thought it might be a fun pedagogical exercise to interleave that dialogue with the way Lean might set things up.</p>\n<p><span class=\"user-mention\" data-user-id=\"910779\">@Anthony Wang</span> your file is lovely! I mean, can't follow it much, because it has a lot of Lean that I don't know â€”Â the reason I thought of this idea was as a way to get more comfortable with Lean. But it looks like you're following Knuth and his T1, T2, and so on.</p>\n<p>I see you begin with the pseudonumbers, which arise a bit later in the dialogue. </p>\n<p>I'm also curious about your use of lists instead of sets (you mention it can cause paradoxes). I think Violeta is saying that you can get around these by using small sets.</p>\n<p>Just in the back of my mind all of this seems like great pedagogical material for getting someone familiar with how Lean works. In any case, if I do something with this I'll be sure to mention it here. And if anyone has played out Knuth a bit further, perhaps with more exposition, I'd love to see it.</p>",
        "id": 558003525,
        "sender_full_name": "Simon DeDeo",
        "timestamp": 1763487665
    },
    {
        "content": "<p>I used lists because Lean rejects the naive definition of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">PseudoNumber</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">PseudoNumber</span>\n<span class=\"w\">  </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">PseudoNumber</span>\n</code></pre></div>\n<p>(See <a class=\"message-link\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/Surreal.20numbers/near/214704929\">#Is there code for X? &gt; Surreal numbers @ ðŸ’¬</a>, although note that that thread is old and uses Lean 3 instead of Lean 4)</p>\n<p>I defined the pseudonumbers first because the definition of surreal numbers requires â‰¤ defined already, but defining â‰¤ requires surreal numbers defined already. My solution was to define â‰¤ for pseudonumbers and then use that instance of â‰¤ in the definition of surreal numbers to break the cycle. I first tried using a <code>mutual</code> block but that didn't work because Lean doesn't allow defining both a <code>structure</code> and a function <code>def</code> inside the same <code>mutual</code> block.</p>",
        "id": 558023116,
        "sender_full_name": "Anthony Wang",
        "timestamp": 1763493393
    },
    {
        "content": "<p>Thank you! â€”Â that's a very helpful thread as well (I like how it's Johan who is like, I'm not sure how to pull this off!)</p>",
        "id": 558024189,
        "sender_full_name": "Simon DeDeo",
        "timestamp": 1763493748
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"557100\">Simon DeDeo</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/558003525\">said</a>:</p>\n<blockquote>\n<p>I'm also curious about your use of lists instead of sets (you mention it can cause paradoxes). I think Violeta is saying that you can get around these by using small sets.</p>\n</blockquote>\n<p>I can elaborate on this point. Lean does not let you define an inductive type like this: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Bad</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Bad</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Bad</span>\n</code></pre></div>\n<p>The reason is that constructors of inductive types are required to be injective, which is not possible here due to Cantor's theorem. Note that <code>Set X = X -&gt; Prop</code>.</p>",
        "id": 558064172,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1763499024
    },
    {
        "content": "<p>The way we sidestep this is quite technical. We basically have to use the internal theory of inductive types (as initial F-algebras of a functor) to prove that, when you restrict to small sets, the desired inductive type actually exists. But once you have that the rest of the theory proceeds as normal.</p>",
        "id": 558064952,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1763499336
    },
    {
        "content": "<p>You can accomplish the same by first defining an \"auxiliary\" type of games</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">PGame</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">PGame</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">PGame</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PGame</span>\n</code></pre></div>\n<p>and taking the quotient by some complicated relation. This is what an older version of our codebase did. Works, but ends up being more tedious.</p>",
        "id": 558066337,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1763499873
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta HernÃ¡ndez</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/558064172\">said</a>:</p>\n<blockquote>\n<p>I can elaborate on this point. Lean does not let you define an inductive type like this: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Bad</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Bad</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Bad</span>\n</code></pre></div>\n<p>The reason is that constructors of inductive types are required to be injective, which is not possible here due to Cantor's theorem. Note that <code>Set X = X -&gt; Prop</code>.</p>\n</blockquote>\n<p>Is this related to <a href=\"https://counterexamples.org/currys-paradox.html\">Curry's paradox</a>? I heard something like \"the number of function arrows to the right of the type used recursively must be odd\"</p>",
        "id": 558091790,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1763511496
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"933054\">@Snir Broshi</span> I believe it is, based on the <a href=\"https://counterexamples.org/strict-positivity.html\">Positivity, strict and otherwise</a> page on <a href=\"http://counterexamples.org\">counterexamples.org</a></p>",
        "id": 558097805,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763515535
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta HernÃ¡ndez</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/557985464\">said</a>:</p>\n<blockquote>\n<p>Regarding sets: one could in theory re-implement <a href=\"https://vihdzp.github.io/combinatorial-games/find/?pattern=IGame#doc\">CGT#IGame</a> in terms of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZFSet#doc\">docs#ZFSet</a>, as a subtype of Kuratowski pairs. But frankly ZFC's treatment of ordered pairs has always seemed to me like a bit of a hack.</p>\n</blockquote>\n<p>What would the actual technical issues with this approach be?</p>",
        "id": 558098797,
        "sender_full_name": "James E Hanson",
        "timestamp": 1763516280
    },
    {
        "content": "<p>technically it would be very annoying</p>",
        "id": 558105907,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763521325
    },
    {
        "content": "<p><em>Everything</em> in ZFC seems like a hack, if you're not used to it. If all you have to work with are sets, then you have to \"hack\" everything else. I think James Hanson is asking whether there is anything more to the complaint about Kuratowski pairs than \"set theory is icky and I don't like working with it.\"</p>",
        "id": 558215222,
        "sender_full_name": "Timothy Chow",
        "timestamp": 1763561906
    },
    {
        "content": "<p>For example, if everything is a set then <code>ext</code> will tell you to show they're equal by they have the same elements, but what you really want is to show a pair is equal to another pair by showing the components are equal</p>",
        "id": 558229002,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763564904
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/558229002\">said</a>:</p>\n<blockquote>\n<p>For example, if everything is a set then <code>ext</code> will tell you to show they're equal by they have the same elements, but what you really want is to show a pair is equal to another pair by showing the components are equal</p>\n</blockquote>\n<p>I don't understand this comment. The Kuratowski pair definition is designed exactly for this purpose. <br>\n<code>{{x},{x,y}} = {{x'},{x',y'}}</code> as sets (i.e., if and only if they have the same elements) if and only if <code>x=x'</code> and <code>y=y'</code>.</p>",
        "id": 558239510,
        "sender_full_name": "Timothy Chow",
        "timestamp": 1763567284
    },
    {
        "content": "<p>You want <code>ext</code> to take you to <code>x = x'</code> and <code>y = y'</code> but what it will do is it will introduce a new variable and if you name it with <code>ext s</code> instead of just <code>ext</code> then you will have the goal <code>s âˆˆ {{x},{x,y}} â†” s âˆˆ {{x'},{x',y'}}</code></p>",
        "id": 558240652,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763567550
    },
    {
        "content": "<p>But that's not how you would do it, is it? I admit I have no experience with ZFSet but I see that there exists something called ZFSet.pair which I would presume smooths over some of these basic interface issues.</p>",
        "id": 558252880,
        "sender_full_name": "Timothy Chow",
        "timestamp": 1763570178
    },
    {
        "content": "<p>That doesn't solve the problem since you will still get something like <code>s âˆˆ pair x y â†” s âˆˆ pair x' y'</code>, what we really want is <code>x = x'</code> and <code>y = y'</code></p>",
        "id": 558253546,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763570363
    },
    {
        "content": "<p>Okay, again I have no experience with ZFSet, but my intuition is that if this is causing problems then it's because ZFSet.pair is not implemented as well as it could be, not because there's something intrinsically technically difficult about working with sets. But I will have to defer to more knowledgeable people.</p>",
        "id": 558279409,
        "sender_full_name": "Timothy Chow",
        "timestamp": 1763577992
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/558253546\">said</a>:</p>\n<blockquote>\n<p>That doesn't solve the problem since you will still get something like <code>s âˆˆ pair x y â†” s âˆˆ pair x' y'</code>, what we really want is <code>x = x'</code> and <code>y = y'</code></p>\n</blockquote>\n<p>How is this any different from any other kind of working with lemmas on defined notation? You introduce notation for the ordered pair, you prove a lemma that the ordered pair works, and then you proceed.</p>",
        "id": 558279586,
        "sender_full_name": "James E Hanson",
        "timestamp": 1763578048
    },
    {
        "content": "<p>how is {{x},{x,y}} \"badly implemented\", it's like the standard definition (at least the one that's actually good) of ordered pairs inside set theory</p>",
        "id": 558279974,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1763578191
    },
    {
        "content": "<p>it's the usual stuff about ordered pairs in set theory that is hard, nothing to do with the implementation of ZFSet. the proof that {{x},{x,y}} is correct in set theory is already a bit messy</p>\n<p>or rather, it's set theory itself that's messy, that's why we all switched to type theory</p>",
        "id": 558280073,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1763578233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/558280073\">said</a>:</p>\n<blockquote>\n<p>the proof that {{x},{x,y}} is correct in set theory is already a bit messy</p>\n</blockquote>\n<p>I don't understand why this is relevant. Shouldn't the proof be buried in the library as a lemma somewhere so that users don't have to worry about it? As James Hanson said, I don't see how this is different from working with any other defined notion.</p>",
        "id": 558280536,
        "sender_full_name": "Timothy Chow",
        "timestamp": 1763578394
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/558280073\">said</a>:</p>\n<blockquote>\n<p>or rather, it's set theory itself that's messy, that's why we all switched to type theory</p>\n</blockquote>\n<p>This is definitely not true, as <a href=\"https://fomarchive.ugent.be/2018-June/021032.html\">Larry Paulson</a> and <a href=\"https://aitp-conference.org/2018/slides/JH.pdf\">John Harrison</a> and <a href=\"https://arxiv.org/abs/1707.04757\">Bohua Zhan</a> and even <a href=\"https://fomarchive.ugent.be/2018-May/021026.html\">Jeremy Avigad</a> will assure you.</p>",
        "id": 558281708,
        "sender_full_name": "Timothy Chow",
        "timestamp": 1763578774
    },
    {
        "content": "<p>By the way, in the same discussion that I quoted above, Larry Paulson <a href=\"https://fomarchive.ugent.be/2018-June/021030.html\">briefly describes</a> how to work with Kuratowski pairs in Isabelle. If there's something klunky with the Lean implementation of ZFSet then I suspect we could ask Larry Paulson for advice, since he has a lot of experience with working with sets inside a type-theoretic proof assistant.</p>",
        "id": 558283648,
        "sender_full_name": "Timothy Chow",
        "timestamp": 1763579470
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/558279586\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/558253546\">said</a>:</p>\n<blockquote>\n<p>That doesn't solve the problem since you will still get something like <code>s âˆˆ pair x y â†” s âˆˆ pair x' y'</code>, what we really want is <code>x = x'</code> and <code>y = y'</code></p>\n</blockquote>\n<p>How is this any different from any other kind of working with lemmas on defined notation? You introduce notation for the ordered pair, you prove a lemma that the ordered pair works, and then you proceed.</p>\n</blockquote>\n<p>Usually when working with ordered pairs you can tell from the type whether a term is a pair or not</p>",
        "id": 558284371,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763579737
    },
    {
        "content": "<p>but with ZFSet it's all sets</p>",
        "id": 558284490,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763579779
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"478409\">Timothy Chow</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/558215222\">said</a>:</p>\n<blockquote>\n<p>I think James Hanson is asking whether there is anything more to the complaint about Kuratowski pairs than \"set theory is icky and I don't like working with it.\"</p>\n</blockquote>\n<p>Not really. I just happen to believe that the fact sets can embed so many structures doesn't mean they're the most natural way to describe said structures.</p>",
        "id": 558297611,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1763584552
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/558240652\">said</a>:</p>\n<blockquote>\n<p>You want <code>ext</code> to take you to <code>x = x'</code> and <code>y = y'</code> but what it will do is it will introduce a new variable and if you name it with <code>ext s</code> instead of just <code>ext</code> then you will have the goal <code>s âˆˆ {{x},{x,y}} â†” s âˆˆ {{x'},{x',y'}}</code></p>\n</blockquote>\n<p>I don't think you do want <code>ext</code> to do this though. With Lean's (type-theoretic) ordered pairs, if I have the goal <code>(x, y) = (x', y')</code>, then I don't expect <code>ext</code> to take me to <code>x = x'</code> and <code>y = y'</code>; I expect <code>simp</code> or similar to do that. And similarly I'd wouldn't expect <code>ext</code> on <code>ZFSet.pair x y = ZFSet.pair x' y'</code> to take me to <code>x = x'</code> and <code>y = y'</code>; I expect <code>simp</code> to do that. And this is something that already happens: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZFSet.pair_inj#doc\">docs#ZFSet.pair_inj</a>. <br>\nSo, as others have said, I'm not entirely sure there's a technical difficulty with working with zf sets in Lean, except for the usual difficulties you get when embedding one theory in another, and peoples' personal taste</p>",
        "id": 558298320,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1763584781
    },
    {
        "content": "<p>Maybe not for pairs, but surely for functions you would want <code>ext</code> to do something nice. But I expect this won't happen for the ZFSet encoding of functions, whatever that may be, since I think it will use the generic ext lemma instead of the one for the encoded functions.</p>",
        "id": 558303975,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763586801
    },
    {
        "content": "<p>so this is what happens when everything is the same type, is that you lose typing information that may be useful</p>",
        "id": 558304155,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763586869
    },
    {
        "content": "<p><del>well some people wanted ext to be more customisable</del><br>\n(i think i remembered that wrong, but it would be nice)</p>",
        "id": 558304865,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1763587133
    },
    {
        "content": "<p>I'd like to point out that if you want to work in pure ZFC you want Metamath, not Lean.</p>",
        "id": 558327596,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1763597581
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/558298320\">said</a>:</p>\n<blockquote>\n<p>I don't think you do want <code>ext</code> to do this though. With Lean's (type-theoretic) ordered pairs, if I have the goal <code>(x, y) = (x', y')</code>, then I don't expect <code>ext</code> to take me to <code>x = x'</code> and <code>y = y'</code>; I expect <code>simp</code> or similar to do that. And similarly I'd wouldn't expect <code>ext</code> on <code>ZFSet.pair x y = ZFSet.pair x' y'</code> to take me to <code>x = x'</code> and <code>y = y'</code>; I expect <code>simp</code> to do that. And this is something that already happens: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZFSet.pair_inj#doc\">docs#ZFSet.pair_inj</a>. <br>\nSo, as others have said, I'm not entirely sure there's a technical difficulty with working with zf sets in Lean, except for the usual difficulties you get when embedding one theory in another, and peoples' personal taste</p>\n</blockquote>\n<p>If that's not what you expect <code>ext</code> to do, then what should it ever do? It's admittedly not often that I equate data structures in Lean, but when I do, I absolutely expect <code>ext</code> to convert an equality of structures into a conjunction of equalities for each projection, which in this case is <code>x = x'</code> and <code>y = y'</code>. That's not <code>simp</code>'s job, and in fact <code>simp</code> is bad at opening goals like that.</p>\n<p>And indeed,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span>\n</code></pre></div>\n<p>leaves you with the two goals <code>(a, b).fst = (c, d).fst</code>, <code>(a, b).snd = (c, d).snd</code>.</p>",
        "id": 558778065,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1763779049
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/558778065\">said</a>:</p>\n<blockquote>\n<p>I absolutely expect <code>ext</code> to convert an equality of structures into a conjunction of equalities for each projection, which in this case is <code>x = x'</code> and <code>y = y'</code>. </p>\n</blockquote>\n<p>I'm not familiar with <code>ext</code>, so some of the nuances of this discussion are going over my head. But let's suppose I agree with you. Given that <code>ZFSet.pair</code> already exists in mathlib, and that <code>ext</code> \"should\" behave the way you indicate here, what's standing in the way of making it behave that way?</p>",
        "id": 558927943,
        "sender_full_name": "Timothy Chow",
        "timestamp": 1763937692
    },
    {
        "content": "<p>well <code>ext</code> only looks at the type of the terms, so it can't use one lemma for generic sets and another lemma for sets that represent a pair</p>",
        "id": 558928548,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763938319
    },
    {
        "content": "<p>To expand on what Aaron is saying -- I can't remember the details but someone once showed me a very cute construction of ordered pairs in set theory whereby every set becomes an ordered pair (edit: Gemini found it, it's the <a href=\"https://en.wikipedia.org/wiki/Ordered_pair#Quine%E2%80%93Rosser_definition\">Quine-Rosser definition</a> ). Say mathlib had used that encoding. Then faced with a goal <code>a = b</code> of <code>ZFSet</code>s, the <code>ext</code> tactic doesn't know whether to turn it into \"z is an element of a iff it's an element of b\" or \"a.1 = b.1 and a.2 = b.2\". In type theory when faced with a goal <code>a = b</code> of ordered pairs you can look at the type of <code>a</code> and see it's <code>X x Y</code> (every term has a unique type in type theory) and then you know which extensionality lemma to use.</p>",
        "id": 558928896,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1763938725
    },
    {
        "content": "<p>Okay, I think I'm beginning to understand, but now my inclination is to agree with Bhavik that for sets, I would <em>not</em> expect a tactic named <code>ext</code> to reduce equality of a Kuratowski ordered pair to equality of the components.</p>\n<p>For a different kind of example, suppose H and K are subgroups of a group G, and my goal is to prove H = K. If I have a set-theoretic mindset, then what might I naively expect a tactic named <code>ext</code> to do to my goal? My first instinct is that it would reduce my goal to two goals, the first showing that if x is in H then x is in K, and the second showing that if x is in K then x is in H. If you buy that, then <code>ext</code> should do something similar with Kuratowski ordered pairs.</p>\n<p>That's not to say that it wouldn't be useful to have <em>some</em> tactic that reduces equality of Kuratowski ordered pairs to equality of the \"components,\" just that it's not obvious to me that such a tactic should be named <code>ext</code>.</p>",
        "id": 558943595,
        "sender_full_name": "Timothy Chow",
        "timestamp": 1763953845
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"478409\">Timothy Chow</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/558943595\">said</a>:</p>\n<blockquote>\n<p>For a different kind of example, suppose H and K are subgroups of a group G, and my goal is to prove H = K. If I have a set-theoretic mindset, then what might I naively expect a tactic named <code>ext</code> to do to my goal? My first instinct is that it would reduce my goal to two goals, the first showing that if x is in H then x is in K, and the second showing that if x is in K then x is in H.</p>\n</blockquote>\n<p>In this example, <code>ext</code> will introduce a new variable of type <code>G</code>, and if you name it by writing <code>ext x</code> instead then you will have the goal <code>x âˆˆ H â†” x âˆˆ K</code></p>",
        "id": 558944241,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763954567
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"478409\">Timothy Chow</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/558943595\">said</a>:</p>\n<blockquote>\n<p>If you buy that, then <code>ext</code> should do something similar with Kuratowski ordered pairs.</p>\n</blockquote>\n<p>What does this <em>mean</em>? What is the similar thing that it should do? Why are you specifying Kuratowski ordered pairs do you not expect this for some other kind of ordered pairs?</p>",
        "id": 558944318,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763954617
    },
    {
        "content": "<p>It means that it should reduce to two goals. The first is that if z is in {{x},{x,y}} then z is in {{x'},{x',y'}}, and the second is that if z is in {{x'},{x',y'}} then z is in {{x},{x,y}}.</p>\n<p>I'm not sure what you mean by \"some other kind of ordered pairs.\" I'm using the name \"Kuratowski\" for emphasis only. In set theory, there is no other kind of ordered pair.</p>",
        "id": 558946067,
        "sender_full_name": "Timothy Chow",
        "timestamp": 1763956408
    },
    {
        "content": "<p>a) We already have a tactic that does this. It's called <code>simp</code>.<br>\nb) There are a lot of potential ordered pair definitions. Products in the category of sets are far from unique. Kuratowski just happened to catch on as semi-standard convention.</p>",
        "id": 558948794,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1763958138
    },
    {
        "content": "<p>Ah, now I see what Aaron Liu might have meant by \"other kinds of ordered pairs.\" If that is what is meant, then yes, I'm just saying what my instincts are for Kuratowski ordered pairs. If we're talking about some kind of categorical product, then I'm not sure what I would expect <code>ext</code> to do.</p>",
        "id": 558950431,
        "sender_full_name": "Timothy Chow",
        "timestamp": 1763958833
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/558928896\">said</a>:</p>\n<blockquote>\n<p>every term has a unique type in type theory</p>\n</blockquote>\n<p>Strictly speaking this depends on the type theory in question. Some type theories have subtyping (e.g., universe subtyping in Rocq).</p>",
        "id": 558966933,
        "sender_full_name": "James E Hanson",
        "timestamp": 1763969702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta HernÃ¡ndez</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/558948794\">said</a>:</p>\n<blockquote>\n<p>semi-standard convention.</p>\n</blockquote>\n<p>Why do you say 'semi-standard'? I feel like it's fairly established as the standard definition in set theory.</p>",
        "id": 558967192,
        "sender_full_name": "James E Hanson",
        "timestamp": 1763969814
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/558928896\">said</a>:</p>\n<blockquote>\n<p>\"z is an element of a iff it's an element of b\" or \"a.1 = b.1 and a.2 = b.2\"</p>\n</blockquote>\n<p>These are pretty directly equivalent goals for the Quine-Rosser pair though.</p>",
        "id": 558970493,
        "sender_full_name": "James E Hanson",
        "timestamp": 1763971038
    },
    {
        "content": "<p>Specifically, a.1 = b.1 is equivalent to \"for any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span></span> not containing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">âˆ…</mi></mrow><annotation encoding=\"application/x-tex\">\\varnothing</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6633em;vertical-align:-0.0817em;\"></span><span class=\"mord amsrm\">âˆ…</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi><mo>âˆˆ</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">z \\in a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">âˆˆ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> iff <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi><mo>âˆˆ</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">z \\in b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">âˆˆ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>\" and a.2 = b.2 is equivalent to \"for any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span></span> containing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">âˆ…</mi></mrow><annotation encoding=\"application/x-tex\">\\varnothing</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6633em;vertical-align:-0.0817em;\"></span><span class=\"mord amsrm\">âˆ…</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi><mo>âˆˆ</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">z \\in a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">âˆˆ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> iff <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi><mo>âˆˆ</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">z \\in b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">âˆˆ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>\".</p>",
        "id": 558973276,
        "sender_full_name": "James E Hanson",
        "timestamp": 1763971823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta HernÃ¡ndez</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/558948794\">said</a>:</p>\n<blockquote>\n<p>a) We already have a tactic that does this. It's called <code>simp</code>.</p>\n</blockquote>\n<p>I'm trying to understand why Robert Maxton says that this sort of thing is not what <code>simp</code> is supposed to do; it's what <code>ext</code> is supposed to do. (At least, that's what I think he's saying.) If <code>ext</code> is supposed to be reminiscent of the axiom of extensionality in set theory, then I do have some intuitions about that, as I have indicated above.</p>\n<p>But without understanding the philosophy behind <code>simp</code> I can't intelligently comment on what it \"should\" be doing. I have used <code>simp</code> a few times, but only as a sorcerer's apprentice, uttering magical incantations without really knowing what I'm doing.</p>",
        "id": 559081979,
        "sender_full_name": "Timothy Chow",
        "timestamp": 1763999094
    },
    {
        "content": "<p>I don't see how Lean's <code>ext</code> tactic as it stands can do anything for <code>ZFSet</code> other than applying set extensionality, because its behaviour depends solely on the type of the objects in the goal. No doubt one can write a different extensionality tactic which is specific to ZFSet, but that's not <code>ext</code>, it's something else.</p>\n<p>Whether <code>a.pair b = a'.pair b'  &lt;-&gt; a = a' \\and b = b'</code> should be a simp lemma will depend on how the ZFSet part of the library is designed. In the part of mathlib which I do understand, I will typically know what the \"simp normal form\" of an expression is. Whether you want <code>simp</code> to start messing with <code>a.pair b</code> will depend a lot on how this term is used in practice. These questions are delicate. For example when one is making the basic API for complex numbers it's super-useful to have the simplifier turning <code>z = w</code> into <code>z.re = w.re \\and z.im = w.im</code> because that's how you're proving every ring axiom for the complexes. However the moment you're beyond this, <code>simp</code> turning <code>z = w</code> into <code>z.re = w.re \\and z.im = w.im</code> would be a disaster, because if one is doing some complicated calculation with complex numbers then probably the last thing you want to do is to start comparing real and imaginary parts.</p>\n<p>What is absolutely clear is that <code>a.pair b = a'.pair b'  &lt;-&gt; a = a' \\and b = b'</code> should be a <em>lemma</em>, and rewriting that lemma is a perfectly satisfactory way of making progress here. Making it a <code>simp</code> lemma could perhaps be something which one could experiment with, and it might be more of a sociological experiment than anything else -- one will probably discover pretty quickly whether one wants the simplifier to do this or not.</p>",
        "id": 559086333,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764000012
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/558967192\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta HernÃ¡ndez</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/558948794\">said</a>:</p>\n<blockquote>\n<p>semi-standard convention.</p>\n</blockquote>\n<p>Why do you say 'semi-standard'? I feel like it's fairly established as the standard definition in set theory.</p>\n</blockquote>\n<p>I've seen âŸ¨a, bâŸ© = {a, {a, b}} about as often. I've seen people omit either definition much more. It's ultimately just an implementation detail.</p>",
        "id": 559086432,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1764000032
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta HernÃ¡ndez</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/559086432\">said</a>:</p>\n<blockquote>\n<p>I've seen âŸ¨a, bâŸ© = {a, {a, b}} about as often.</p>\n</blockquote>\n<p>This definition doesn't work properly in the absence of the axiom of foundation, does it? Can't you have something like a = {a',b'} and a' = {a,b} so that {a, {a,b}} = {a', {a',b'}} without a = a' and b = b'?</p>",
        "id": 560036667,
        "sender_full_name": "Timothy Chow",
        "timestamp": 1764025751
    },
    {
        "content": "<p>So you're saying it works when we have the axiom of foundation</p>",
        "id": 560037029,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764025924
    },
    {
        "content": "<p>See the comments on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><msub><mo stretchy=\"false\">)</mo><mrow><mi>s</mi><mi>h</mi><mi>o</mi><mi>r</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">(a,b)_{short}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">h</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">or</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> at <a href=\"https://en.wikipedia.org/wiki/Ordered_pair#Variants\">https://en.wikipedia.org/wiki/Ordered_pair#Variants</a></p>",
        "id": 560038581,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764026672
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/560037029\">said</a>:</p>\n<blockquote>\n<p>So you're saying it works when we have the axiom of foundation</p>\n</blockquote>\n<p>Yes, it does, but the point is that it's certainly not \"standard,\" and under most circumstances, there's no good reason to use it. Usually, when I've seen it, it's a typo, or written by someone who doesn't appreciate the subtle point about foundation. There might be some specialized circumstances where it has some definite advantages, but again, it's not \"standard.\" Just like there are infinitely many ways that one can write down axioms for a group, but most of them are nonstandard.</p>",
        "id": 560046036,
        "sender_full_name": "Timothy Chow",
        "timestamp": 1764030146
    },
    {
        "content": "<p>well if it shows up a lot then it's a standard</p>",
        "id": 560050548,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764033359
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/560050548\">said</a>:</p>\n<blockquote>\n<p>well if it shows up a lot then it's a standard</p>\n</blockquote>\n<p>I'm not sure what point you're trying to make. James Hanson, who is an expert in foundations and knows a lot about set theory, was trying to understand why Violeta was calling the definition \"semi-standard\" when in his experience (and mine, for what that's worth, though I don't know as much set theory as James does), it's standard. I would say that the alternative proposed by Violeta shows up very rarely in careful treatments of set theory. I have seen many people write it that way, but as I said, usually by mistake. By analogy, I see the spellings \"accomodation\" and \"occurence\" a lot, but that doesn't automatically make those spellings standard.</p>\n<p>But I would be interested if you can cite (for example) several graduate textbooks in set theory that use the {x, {x,y}} definition. That would be good evidence that {x, {x,y}} is just as standard a definition as {{x}, {x,y}}.</p>",
        "id": 560052402,
        "sender_full_name": "Timothy Chow",
        "timestamp": 1764034681
    },
    {
        "content": "<p>The point I was trying to make is that there are a lot of potential options. If one is preferred over the others the reasons are largely historical.</p>",
        "id": 560052955,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1764035099
    },
    {
        "content": "<p>I could well imagine some more categorical treatment of set theory, where one first proves \"there are products in the category of sets\", gives whichever construction as an example, then just uses âŸ¨a, bâŸ© to refer to elements of an arbitrary product.</p>",
        "id": 560053096,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1764035216
    },
    {
        "content": "<p>Ultimately the nice thing about <em>not</em> working with <code>ZFSet</code> is that we don't have to quabble over these arbitrary choices. We have a constructor which makes a game out of two other sets of games; its implementation is for the purposes of the mathematics completely opaque.</p>",
        "id": 560053198,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1764035291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta HernÃ¡ndez</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/559086432\">said</a>:</p>\n<blockquote>\n<p>I've seen âŸ¨a, bâŸ© = {a, {a, b}} about as often.</p>\n</blockquote>\n<p>Where have you seen this? I just googled 'set theory textbooks' and checked all of the books I found listed that I could get my hands on, and all of them either used the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo stretchy=\"false\">}</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">}</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{\\{x\\},\\{x,y\\}\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{{</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">}</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">}}</span></span></span></span> Kuratowski pair definition or (in one case) took ordered pairs as a primitive notion. In particular, all of these books use that definition.</p>\n<ul>\n<li><em>Set Theory: An Open Introduction</em> by the Open Logic Project.</li>\n<li><em>Elements of Set Theory</em> by Enderton</li>\n<li><em>Set Theory</em> by Jech</li>\n<li><em>Introduction to Set Theory</em> by Hrbacek and Jech</li>\n<li><em>Naive Set Theory</em> by Halmos</li>\n<li><em>Basic Set Theory</em> by Levy</li>\n<li><em>Intermediate Set Theory</em> by Drake and Singh</li>\n<li><em>Axioms and Set Theory: A first course in Set Theory</em> by AndrÃ©</li>\n</ul>\n<p>Enderton mentions the Wiener pair definition but then said that the Kuratowski pair is 'in general use today'. I also asked ChatGPT what the standard definition of ordered pairs in set theory is, and it said the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo stretchy=\"false\">}</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">}</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{\\{x\\},\\{x,y\\}\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{{</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">}</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">}}</span></span></span></span> Kuratowski pair.</p>\n<p>Only <em>Book of Proof</em> by Hammack didn't use this definition, and instead seemed to take ordered pairs as a primitive concept.</p>\n<p>The only place I ever see the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>x</mi><mo separator=\"true\">,</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">}</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{x,\\{x,y\\}\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">}}</span></span></span></span> definition is in conversations about different definitions of ordered pairs or the history of set theory, on Wikipedia (which is trying to present an encyclopedic account of different definitions people have proposed), and in the <em>one</em> textbook (<em>Lectures in Logic and Set Theory. Vol. 2: Set Theory</em> by Tourlakis) and <a href=\"https://us.metamath.org/mpegif/opthreg.html\">Metamath proof</a> Wikipedia cites. (Note that Wikipedia also refers to the Kuratowski pair as the 'now-accepted definition'.) Other than that, the Quine-Rosser definition and (extremely rarely, as in literally in 2 papers I can think of, one of which is mine) the Wiener definintion show up in some places for technical reasons.</p>\n<p>I understand that this is not that important. I understand that in the context of formalizing the surreal numbers in Lean, set-theoretic ordered pairs don't make sense. The reason I am touchy about this is that, as someone in the general cultural sphere of set theory, I find it <em>extremely</em> obnoxious when people outside the area insist (seemingly on the basis of vibes) that it hasn't decided on a standard definition (as Kevin quite aggressively and unpleasantly did the last time this topic came up). If you ask set theorists or classical mathematical logicians more generally whether there's a 'standard' set-theoretic ordered pair, the vast majority of them will tell you yes and say that it's <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo stretchy=\"false\">}</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">}</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{\\{x\\},\\{x,y\\}\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{{</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">}</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">}}</span></span></span></span>. It is the standard definition in set theory by any reasonable social notion of 'standard definition'.</p>",
        "id": 560059982,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764040137
    },
    {
        "content": "<p>ok, maybe Kuratowski pairs are standard</p>",
        "id": 560060147,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764040287
    },
    {
        "content": "<p>does that change anything?</p>",
        "id": 560060158,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764040294
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/560060158\">said</a>:</p>\n<blockquote>\n<p>does that change anything?</p>\n</blockquote>\n<p>I feel like this question is not a response to my point.</p>",
        "id": 560060492,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764040586
    },
    {
        "content": "<p>what is your point?</p>",
        "id": 560060569,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764040667
    },
    {
        "content": "<p>I feel like I communicated my point pretty clearly in the last paragraph of my earlier message.</p>",
        "id": 560060770,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764040876
    },
    {
        "content": "<p>oh yes sorry I see it now</p>",
        "id": 560060891,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764041008
    },
    {
        "content": "<p>I concede that I was under the impression Kuratowski was somewhat less agreed-upon. But my use of the word semi-standard was also intended to call attention to the fact that there is no strictly mathematical reason to prefer this definition over others in the context of ZFC.</p>",
        "id": 560075192,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1764051100
    },
    {
        "content": "<p>That's not how the phrase 'standard definition' is used in math.</p>",
        "id": 560077371,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764052639
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 560077490,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764052726
    },
    {
        "content": "<p>Sure, but <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">{</mo><mi>y</mi><mo stretchy=\"false\">}</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">}</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{\\{y\\}, \\{x, y\\}\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{{</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">}</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">}}</span></span></span></span> is an equally robust definition, as is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo stretchy=\"false\">}</mo><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">âˆ…</mi><mo stretchy=\"false\">}</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">{</mo><mi>y</mi><mo stretchy=\"false\">}</mo><mo stretchy=\"false\">}</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{\\{\\{x\\},\\varnothing\\},\\{\\{y\\}\\}\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{{{</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">}</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord amsrm\">âˆ…</span><span class=\"mclose\">}</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">{{</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">}}}</span></span></span></span>, or perhaps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo stretchy=\"false\">}</mo><mo stretchy=\"false\">}</mo><mo stretchy=\"false\">}</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">{</mo><mn>1</mn><mo separator=\"true\">,</mo><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">{</mo><mi>y</mi><mo stretchy=\"false\">}</mo><mo stretchy=\"false\">}</mo><mo stretchy=\"false\">}</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{\\{0, \\{\\{x\\}\\}\\}, \\{1,\\{\\{y\\}\\}\\}\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">{{</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">}}}</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">{{</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">}}}}</span></span></span></span>, etc.</p>",
        "id": 560077749,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1764052917
    },
    {
        "content": "<p>Sorry, I didn't see that you said ZFC specifically.</p>",
        "id": 560077828,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764052956
    },
    {
        "content": "<p>I just don't get why set theory gets put under such an intense microscope in this context.</p>\n<p>If we were talking about some place in algebra where there was a technically arbitrary sign convention, would you also go out of your way to refer to an established convention as 'semi-standard'?</p>",
        "id": 560077911,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764053012
    },
    {
        "content": "<p>Or, rather, I feel like I do get why set theory is treated this way and I feel like it has to do with people thinking of it as 'not really being mathematics' (cf. Kevin's comments last time this conversation happened about basic things in set theory being 'wiring' rather than 'mathematics').</p>",
        "id": 560078105,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764053132
    },
    {
        "content": "<p>Or your phrasing just now about 'strictly mathematical reason'.</p>",
        "id": 560078472,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764053325
    },
    {
        "content": "<p>I had to use the Wiener pair instead of the Kuratowski pair in one of my papers for technical reasons. Was the reason I had to do that not 'mathematical'?</p>",
        "id": 560078550,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764053371
    },
    {
        "content": "<p>Admittedly this was not in the context of ZFC, but whenever people start talking about these basic things from set theory this way, I always feel like there's a certain degree of 'set theory is not mathematics' subtext.</p>",
        "id": 560078898,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764053561
    },
    {
        "content": "<p>My main gripe with set theory is that in my eyes it has a bad habit of glorifying arbitrary choices of encoding. An ordered pair can be encoded via Kuratowski just as a natural number can be encoded via Zermelo or as an ordinal can be encoded via von Neumann, but all of these choices are far from unique and very rarely relevant.</p>",
        "id": 560079489,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1764053874
    },
    {
        "content": "<p>The von Neumann definition has meaningful technical advantages when you pass to arbitrary ordinals rather than just natural numbers.</p>",
        "id": 560079606,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764053932
    },
    {
        "content": "<p>It's not arbitrary.</p>",
        "id": 560079610,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764053935
    },
    {
        "content": "<p>You're just insisting that it's arbitrary because you don't respect the mathematical ideas in set theory.</p>",
        "id": 560079639,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764053951
    },
    {
        "content": "<p>Mathlib has a lot of work done on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ordinal#doc\">docs#Ordinal</a>, and none of it depends on von Neumann's definition.</p>",
        "id": 560079643,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1764053955
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 560079692,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764053979
    },
    {
        "content": "<p>I respect the mathematics, my point is that the encodings themselves aren't all that important.</p>",
        "id": 560079719,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1764053991
    },
    {
        "content": "<p>You don't respect the mathematics if you insist that people in the field are thinking about it incorrectly in a fundamental way.</p>",
        "id": 560079820,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764054026
    },
    {
        "content": "<p>Or rather you don't respect the people in the field.</p>",
        "id": 560079850,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764054038
    },
    {
        "content": "<p>I apologize if any of this has come off as a personal attack. That's far from my intention.</p>",
        "id": 560079926,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1764054070
    },
    {
        "content": "<p>I am sorry for being difficult. I just find this attitude extremely frustrating.</p>",
        "id": 560079967,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764054095
    },
    {
        "content": "<p>It's kind of condescending.</p>",
        "id": 560079976,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764054101
    },
    {
        "content": "<p>'All these basic conventions in your field are wrong and not really mathematics.'</p>",
        "id": 560080035,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764054137
    },
    {
        "content": "<p>Can't you see why this is maybe a bit insulting?</p>",
        "id": 560080050,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764054145
    },
    {
        "content": "<p>Like do you know anything about inner model theory? Do you know the condensation lemma?</p>",
        "id": 560080118,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764054179
    },
    {
        "content": "<p>There's a reason why 'structural' set theory never took off among set theorists as a formalism. It makes very basic ideas in the area extremely awkward.</p>",
        "id": 560080192,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764054209
    },
    {
        "content": "<p>Well, my argument isn't that the conventions are wrong. My ultimate point is that we could have gone with any of them with largely the same result.</p>",
        "id": 560080433,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1764054325
    },
    {
        "content": "<p>I'm not talking about ordered pairs now. I'm talking about ordinals.</p>",
        "id": 560080470,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764054344
    },
    {
        "content": "<p>The von Neumann ordinal definition is natural. It's more natural than the Kuratowski pair.</p>",
        "id": 560080503,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764054364
    },
    {
        "content": "<p>It's a canonical notion.</p>",
        "id": 560080509,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764054367
    },
    {
        "content": "<p>Model theory is an area I am somewhat interested in, but my knowledge is superficial. It does feel a bit insulting that you'd attack my intelligence rather than my actual words.</p>",
        "id": 560080545,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1764054381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/560080503\">said</a>:</p>\n<blockquote>\n<p>The von Neumann ordinal definition is natural. It's more natural than the Kuratowski pair.</p>\n</blockquote>\n<p>Perhaps I can rephrase: one can develop the entirety of ordinal arithmetic without reference to an encoding. The characterizing property of ordinals is that they are a skeleton for the category of well-orders, and that's enough to get the ball rolling.</p>",
        "id": 560080662,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1764054438
    },
    {
        "content": "<p>I did not mean to attack your intelligence. I'm trying to say that there are reasons for preferring something like the von Neumann ordinal definition that you only really get to after, say, a semester of graduate set theory.</p>",
        "id": 560080682,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764054448
    },
    {
        "content": "<p>I guess we're talking about different usages of the same concept</p>",
        "id": 560080740,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1764054483
    },
    {
        "content": "<p>Also, this is a common misconception, but 'inner model theory' isn't really a kind of model theory. It's just a part of set theory.</p>",
        "id": 560080747,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764054485
    },
    {
        "content": "<p>Dear all, online communication is always difficult and it's easy to misinterpret the tone or the intentions of a message. I am confident that nobody wanted to insult anybody in this discussion and I propose to keep it at a scientific level.</p>",
        "id": 560080883,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1764054553
    },
    {
        "content": "<p>I think I can state my point while remaining within the confines of the original discussion. It is somewhat more natural to define games as we do in the CGT repo (as an inductive type where two sets of games create a new one) than it is to define it as a subtype of <code>ZFSet</code>, since the latter involves a choice of pair encoding that is far from unique.</p>",
        "id": 560081691,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1764054911
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta HernÃ¡ndez</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surreals.20.28but.20in.20parallel.20to.20Knuth.20book.29/near/560080545\">said</a>:</p>\n<blockquote>\n<p>Model theory is an area I am somewhat interested in, but my knowledge is superficial.</p>\n</blockquote>\n<p>In any case, my main area is actually model theory. It can be a hard area to learn about without talking to people already familiar with the material. If you have questions about model theory at some point in the future, I'd be more than happy to answer them.</p>",
        "id": 560081723,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764054924
    },
    {
        "content": "<p>Thank you! I do actually have one question: is there some good introductory reference for the topic?</p>",
        "id": 560081779,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1764054955
    },
    {
        "content": "<p>Unfortunately, kind of no.</p>",
        "id": 560081823,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764054967
    },
    {
        "content": "<p>The closest is maybe Maker's book, but it's notoriously full of typos and is somewhat outdated at this point.</p>",
        "id": 560081874,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764054987
    },
    {
        "content": "<p>Hm, that's unfortunate. But thanks</p>",
        "id": 560081947,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1764055015
    }
]