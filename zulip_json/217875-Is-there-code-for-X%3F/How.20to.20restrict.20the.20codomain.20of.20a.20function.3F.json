[
    {
        "content": "<p>Any function <code>f : A → B</code> (where A and B are arbitrary types) naturally induces a surjective function of type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">f'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>via the informal equation <code>f' x = f x</code>.  Is the <code>f ↦ f'</code> map already defined in mathlib?</p>\n<p>I know I can define it using <a href=\"http://Subtype.map\">Subtype.map</a>, but am wondering whether it is already in mathlib with proved results.  (For example, if f is injective, then so is f'.  And so on.)</p>",
        "id": 540546890,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758326757
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.rangeFactorization#doc\">docs#Set.rangeFactorization</a></p>",
        "id": 540547090,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758326954
    },
    {
        "content": "<p>please report any missing lemmas you (don't) find I don't think the API around this area is complete</p>",
        "id": 540547125,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758327001
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/How.20to.20restrict.20the.20codomain.20of.20a.20function.3F/near/540546890\">said</a>:</p>\n<blockquote>\n<p>(For example, if f is injective, then so is f'.  And so on.)</p>\n</blockquote>\n<p>Surprisingly I don't think we have this result</p>",
        "id": 540547271,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758327179
    },
    {
        "content": "<p>are you willing to PR it to mathlib?</p>",
        "id": 540547289,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758327201
    },
    {
        "content": "<p>we do have the slightly stronger result of having a specified left inverse (actually stated as being a right inverse) in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.rightInverse_rangeSplitting#doc\">docs#Set.rightInverse_rangeSplitting</a></p>",
        "id": 540547457,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758327381
    },
    {
        "content": "<p>we also might want the version stating bijective</p>",
        "id": 540547513,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758327471
    },
    {
        "content": "<p>Seeing <code>↑(range f)</code> in the type makes me think of dependent type hell, which might be the reason it isn't used much (-&gt; people don't add many lemma to it). Perhaps you can provide more context on what you want to do, and maybe there is a better way to avoid using this?</p>",
        "id": 540547579,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1758327557
    },
    {
        "content": "<p>Actually, after thinking more, I wonder if mathlib has the following more useful result:<br>\nIf a function <code>f : A → B</code> is injective, then there is an equivalence (≃) between the type A and the type <code>{y // y ∈ range f}</code>.</p>",
        "id": 540547580,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758327558
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.ofInjective#doc\">docs#Equiv.ofInjective</a></p>",
        "id": 540547651,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1758327632
    },
    {
        "content": "<p>(Found by loogle <code>Function.Injective, Equiv</code>)</p>",
        "id": 540547681,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1758327666
    },
    {
        "content": "<p>Ah, thanks!  I still don't know how to loogle effectively.</p>",
        "id": 540547715,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758327714
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873350\">Weiyi Wang</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/How.20to.20restrict.20the.20codomain.20of.20a.20function.3F/near/540547579\">said</a>:</p>\n<blockquote>\n<p>Seeing <code>↑(range f)</code> in the type makes me think of dependent type hell, which might be the reason it isn't used much</p>\n</blockquote>\n<p>cmon it's not <em>that</em> bad once you get used to it</p>",
        "id": 540547730,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758327724
    },
    {
        "content": "<p>There's also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.codRestrict#doc\">docs#Set.codRestrict</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subtype.coind#doc\">docs#Subtype.coind</a> for when you want to restrict to an arbitrary superset of the range instead of the range itself. I think the former has a bit more API than the latter</p>",
        "id": 540586068,
        "sender_full_name": "Ben Eltschig",
        "timestamp": 1758375132
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/How.20to.20restrict.20the.20codomain.20of.20a.20function.3F/near/540547730\">said</a>:</p>\n<blockquote>\n<p>cmon it's not <em>that</em> bad once you get used to it</p>\n</blockquote>\n<p>Yeah, sets-as-types is <em>really</em> not bad compared to most things called dependent type hell; the only place where it gets annoying is working with nested preimage vals/ <code>↓∩</code>, IMO</p>",
        "id": 540683236,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1758487101
    }
]