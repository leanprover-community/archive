[
    {
        "content": "<p>Has anyone formalised this result?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Sites.Surjective</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">GrothendieckTopology</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">GrothendieckTopology</span> <span class=\"n\">C</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ConcreteCategory</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Sheaf</span> <span class=\"n\">J</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">⟶</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">epi_iff_locallySurjective</span> <span class=\"o\">:</span> <span class=\"n\">Epi</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"n\">IsLocallySurjective</span> <span class=\"n\">J</span> <span class=\"n\">f.val</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(probably with some more assumptions on <code>A</code>). It doesn't seem to be in mathlib, but maybe something similar was done in LTE <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>? For (light) condensed sets it means that a map is an epi iff for every (light) profinite set <code>S</code> mapping into the target, there is another (light) profinite set <code>S'</code> with a surjection to <code>S</code> and a map to the source, making the square commute.</p>",
        "id": 418489810,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1706436743
    },
    {
        "content": "<p>I have done this very recently for sheaves of sets <a href=\"https://github.com/leanprover-community/mathlib4/pull/9965\">https://github.com/leanprover-community/mathlib4/pull/9965</a><br>\n(see the file  <code>CategoryTheory.Sites.EpiMono</code>). The argument is based on the fact that the category of sheaves is balanced (for sheaves of sets, I have followed the argument in SGA 4 II 4.2; for sheaves of abelian groups, it follows from the fact it is an abelian category) and the existence of an epi-mono factorization of a morphism for which we would know the epi is locally surjective.</p>",
        "id": 418498124,
        "sender_full_name": "Joël Riou",
        "timestamp": 1706444637
    },
    {
        "content": "<p>Great! I’ll take a look at your PR this evening</p>",
        "id": 418498231,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1706444726
    },
    {
        "content": "<p>Thanks to your message, I notice that part of my code duplicates the file <code>Sites.Surjective</code> by <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span></p>",
        "id": 418500779,
        "sender_full_name": "Joël Riou",
        "timestamp": 1706446639
    },
    {
        "content": "<p>Yeah IIRC Andrew did this in a reasonable level of generality (we did it for condensed abelian groups in LTE)</p>",
        "id": 418506142,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1706451450
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/13478\">#13478</a> characterises epimorphisms in condensed sets and condensed modules over any ring <code>R</code> (this now includes condensed abelian groups by definition), as objectwise surjections on <code>Stonean</code> (and hence generalises <a href=\"https://github.com/leanprover-community/lean-liquid/blob/087fffad55dc1dd8d54ab35c9816926a45b8c0fd/src/condensed/projective_resolution.lean#L199-L234\">this result in LTE</a>). </p>\n<p>Thanks <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> for providing the general API for locally surjective maps of sheaves!</p>",
        "id": 442233613,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1717416316
    },
    {
        "content": "<p>Is there a reason this is done only for <code>CondensedSet</code> and <code>CondensedMod</code>, and not for more general condensed objects (maybe satisfying some further assumptions)?</p>",
        "id": 442234550,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1717416564
    },
    {
        "content": "<p>The target category has to be concrete, and satisfy the assumptions in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Sheaf.isLocallySurjective_iff_epi%27#doc\">docs#CategoryTheory.Sheaf.isLocallySurjective_iff_epi'</a>. But indeed the theorem in the condensed file should be stated for this type of category, it should then apply directly to condensed sets and condensed modules</p>",
        "id": 442236129,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1717417044
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"519559\">Dagur Asgeirsson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Epimorphisms.20of.20sheaves/near/442233613\">said</a>:</p>\n<blockquote>\n<p>Thanks <span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> for providing the general API for locally surjective maps of sheaves!</p>\n</blockquote>\n<p>Half of the credit should go to <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span>!</p>",
        "id": 442250308,
        "sender_full_name": "Joël Riou",
        "timestamp": 1717420638
    },
    {
        "content": "<p>Of course! Sorry Andrew</p>",
        "id": 442250526,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1717420695
    },
    {
        "content": "<p>I'm running into some universe issues when trying to apply this to light condensed sets. I wonder if some of the universes in the concrete sheafification file could be generalised so it applies to essentially small sites</p>",
        "id": 442250820,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1717420767
    },
    {
        "content": "<p>In a very draft branch <a href=\"https://github.com/leanprover-community/mathlib4/blob/dense-subsite-refactor/Mathlib/CategoryTheory/Sites/DenseSubsiteNew.lean\">https://github.com/leanprover-community/mathlib4/blob/dense-subsite-refactor/Mathlib/CategoryTheory/Sites/DenseSubsiteNew.lean</a> based of my 1-hypercovers PRs I have a plan for a refactor of <code>DenseSubsite</code> which would eventually allow to get properties of categories of sheaves by transporting properties of a \"smaller\" site with equivalent categories of sheaves (in particular, we could get sheafification if the category of the site is essentially small, but this shall more general).</p>\n<p>Also, I would think that an alternative (or replacement?) construction of the \"concrete sheafification\" should be done using 1-hypercovers of a certain size <code>w</code>. (The difference is that the current sheafification using the ordered set of covering sieves involves limits and colimits indexed by types in a universe <code>max u v</code>.). The extra difficulty is that we would have to consider the homotopy category of 1-hypercovers instead of an ordered set... (Using such constructions, I think it will be possible to sheafify presheaves <code>Scheme.{u}ᵒᵖ ⥤ Type u</code> (and not just <code>`Scheme.{u}ᵒᵖ ⥤ Type (u + 1)</code>) for the Zariski, étale or fppf topologies.)</p>\n<p>(Doing all of this may take some time though...)</p>",
        "id": 442257229,
        "sender_full_name": "Joël Riou",
        "timestamp": 1717422239
    },
    {
        "content": "<p>I think this is a good approach, but indeed sounds like it might take some time!</p>\n<p>For my application, my site is already equivalent to a small category, so I should be able to prove directly things like the fact that <code>PreservesSheafification</code> is preserved by the equivalence of sites, and use that (similar to what we did for <code>HasSheafify</code> and <code>HasSheafCompose</code> in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Sites/Equivalence.html\">this file</a>).</p>",
        "id": 442260552,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1717422946
    },
    {
        "content": "<p>Yes, this is the short term solution...</p>",
        "id": 442260975,
        "sender_full_name": "Joël Riou",
        "timestamp": 1717423023
    },
    {
        "content": "<p>Sounds like someone is volunteering to review <a href=\"https://github.com/leanprover-community/mathlib4/pull/13004\">#13004</a> :)</p>",
        "id": 442261067,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1717423040
    },
    {
        "content": "<p>I agree it would be great to refactor sheafification to use 1-hypercovers. I think the construction works in a single step with such an approach, as opposed to two steps like this \"plus-plus\" construction!</p>",
        "id": 442268251,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1717424544
    },
    {
        "content": "<p>Does <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.GrothendieckTopology.OneHypercover#doc\">docs#CategoryTheory.GrothendieckTopology.OneHypercover</a> have a category structure yet?</p>",
        "id": 442271189,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1717425206
    },
    {
        "content": "<p>No, it does not.</p>",
        "id": 442271383,
        "sender_full_name": "Joël Riou",
        "timestamp": 1717425249
    },
    {
        "content": "<p>Ok. Why do you need the homotopy category BTW? Is it not the case that you just take the colimit over the category of hypercovers of the limit of the presheaf applied to the objects in the hypercover?</p>",
        "id": 442271553,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1717425297
    },
    {
        "content": "<p>For the colimit, it does not change whether we take the homotopy category or not, but this is (co?)filtering only after passing to the homotopy category. Eventually, we would probably want to apply cofinality results to this category (introducing suitable small cofinal subcategories), and as we have more cofinality results for filtering categories, it is probably better to use the homotopy category.</p>",
        "id": 442273584,
        "sender_full_name": "Joël Riou",
        "timestamp": 1717425795
    },
    {
        "content": "<p>I see, yes, you would need that it's filtered to prove left exactness and things of that sort.</p>",
        "id": 442273733,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1717425830
    },
    {
        "content": "<p>It all works now for light condensed sets and modules as well: <a href=\"https://github.com/leanprover-community/mathlib4/pull/13495\">#13495</a>.</p>",
        "id": 442535458,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1717509265
    },
    {
        "content": "<p>Using the short term solution, of course. If we refactor sheafification using 1-hypercovers, I guess almost everything in the file <code>Sites/Equivalence</code> becomes obsolete</p>",
        "id": 442535743,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1717509354
    },
    {
        "content": "<p>I now have very draft PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/19444\">#19444</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/19462\">#19462</a>. The first <a href=\"https://github.com/leanprover-community/mathlib4/pull/19444\">#19444</a> shows that if we have a functor <code>F : C₀ ⥤ C</code> which is a dense subsite (for topologies <code>J₀</code> and <code>J</code>), then if moreover <code>F</code> is \"<code>1</code>-hypercover dense\" (any object in <code>C</code> has a <code>1</code>-hypercover consisting of objects from <code>C₀</code>, with index types in a certain universe <code>w</code>), then assuming the target category <code>A</code> has limits of size <code>w</code>, I obtain an equivalence <code>Sheaf J A ≌ Sheaf J₀ A</code>, and show that a <code>HasSheafify J₀ A</code> instance transports to a <code>HasSheafify J A</code> instance.<br>\nIn the second <a href=\"https://github.com/leanprover-community/mathlib4/pull/19462\">#19462</a> (still a few sorries), I outline a construction of such a <code>C₀</code> in case <code>C</code> is the small étale site of a scheme <code>S : Scheme.{u}</code>. Indeed, the issue is that the small étale site of <code>S</code> is a large category! By using a certain packaging of schemes <code>X ⟶ S</code> that are finitely presented (and étale) over an affine open subset of <code>S</code>, I obtain a small category <code>C₀</code> (which is not equivalent to <code>C</code>) but such that all objects in <code>C</code> have a \"small\" <code>1</code>-hypercover consisting of objects in <code>C₀</code>.</p>\n<p>As a result, we shall get <code>HasSheafify (smallEtaleTopology S) (Type u)</code>. (The second part obviously depends on the work by <span class=\"user-mention\" data-user-id=\"648495\">@Christian Merten</span>, <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span>  et al. on notions of smooth and étale morphisms, and part of the code will have to be adapted after Christian's PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/19096\">#19096</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/18945\">#18945</a> are merged.) Eventually, the étale cohomology of a scheme in <code>Scheme.{0}</code> shall be in <code>Type 0</code>...</p>\n<p>A similar method would work for the fppf site, for the site of smooth schemes over a base, etc. However, it would not work for the big étale site of all <code>S</code>-schemes (but do we need to sheafify presheaves over such categories?). A different method would have to be followed: if someone is interested, they may implement a construction of the associated sheaf directly in one step using 1-hypercovers (as an alternative to the \"plus-plus\" construction).</p>",
        "id": 484294256,
        "sender_full_name": "Joël Riou",
        "timestamp": 1732539745
    },
    {
        "content": "<p>Wow, very nice!</p>",
        "id": 484332788,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1732548995
    },
    {
        "content": "<p>It's cool that these technical pieces of the puzzle are falling into place</p>",
        "id": 484332879,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1732549021
    }
]