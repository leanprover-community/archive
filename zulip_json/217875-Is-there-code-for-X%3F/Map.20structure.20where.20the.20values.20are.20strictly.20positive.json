[
    {
        "content": "<p>Is there a Map/Dictionary structure where the values are in strictly positive positions, such that you could use it inductively, like so?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Foo</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Map</span><span class=\"w\"> </span><span class=\"n\">Key</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Foo</span>\n</code></pre></div>",
        "id": 574565869,
        "sender_full_name": "Mai",
        "timestamp": 1771435782
    },
    {
        "content": "<p>Not that I'm aware of, although you could reimplement Rocq's <a href=\"https://coq-workshop.gitlab.io/2023/abstracts/coq2023_finmap-stdpp.pdf\"><code>gmap</code></a>, which can be used in nested types.</p>",
        "id": 574567706,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1771436316
    },
    {
        "content": "<p>Hmm, might take a shot at that</p>",
        "id": 574568111,
        "sender_full_name": "Mai",
        "timestamp": 1771436434
    },
    {
        "content": "<p>Is there a reason the standard HashMap/TreeMap can't be used this way?</p>",
        "id": 574570007,
        "sender_full_name": "Mai",
        "timestamp": 1771437021
    },
    {
        "content": "<p>I guess it's because the underlying structures are Dependent</p>",
        "id": 574570260,
        "sender_full_name": "Mai",
        "timestamp": 1771437107
    },
    {
        "content": "<p>The <code>Raw</code> versions (i.e. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.HashMap.Raw#doc\">docs#Std.HashMap.Raw</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.TreeMap.Raw#doc\">docs#Std.TreeMap.Raw</a>, etc.) work here but their wellformedness is unbundled in e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.HashMap.Raw.WF#doc\">docs#Std.HashMap.Raw.WF</a></p>",
        "id": 574599075,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1771447109
    },
    {
        "content": "<p>What's the implication of the wellformedness being unbundled?</p>",
        "id": 574601292,
        "sender_full_name": "Mai",
        "timestamp": 1771448017
    },
    {
        "content": "<p>Well it's a little more inconvenient for proofs since you need to get the wellformedness from somewhere else</p>",
        "id": 574607910,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1771450400
    },
    {
        "content": "<p>And you'll most likely want a wellformedness predicate for <code>Foo</code> to get those recursively</p>",
        "id": 574608036,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1771450438
    },
    {
        "content": "<p>You could make your inductive type take both an unbundled map and a proof of well-foundedness, and then make the public accessor return the bundled version.</p>",
        "id": 574617368,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1771454263
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> no? because WF will indirectly depend on the type being defined</p>",
        "id": 574622588,
        "sender_full_name": "Mai",
        "timestamp": 1771457075
    },
    {
        "content": "<p>The reference manual has a worked example of using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.HashMap.Raw#doc\">docs#Std.HashMap.Raw</a> in a nested inductive: <a href=\"https://lean-lang.org/doc/reference/latest/Basic-Types/Maps-and-Sets/#raw-data\">https://lean-lang.org/doc/reference/latest/Basic-Types/Maps-and-Sets/#raw-data</a></p>",
        "id": 574659472,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1771484283
    }
]