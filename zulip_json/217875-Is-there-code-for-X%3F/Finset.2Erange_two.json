[
    {
        "content": "<p>In my own project I recently needed a proof that  Finset.range 2 = {0,1}.  I initially had an embarrasingly long proof of this,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Finset.range</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">a</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">.</span> <span class=\"n\">intro</span> <span class=\"n\">ha</span>\n    <span class=\"k\">have</span> <span class=\"n\">ha'</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span> <span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">]</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">a</span>\n    <span class=\"bp\">.</span> <span class=\"n\">norm_num</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.succ_eq_add_one</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.succ_eq_add_one</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">ha'</span>\n    <span class=\"k\">have</span> <span class=\"n\">ha''</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span>\n    <span class=\"n\">right</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ha''</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">ha</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">ha</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"bp\">|</span> <span class=\"n\">h</span>\n  <span class=\"bp\">.</span> <span class=\"n\">norm_num</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"n\">norm_num</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>but eventually realized that due to existing tools such as Finset.range_one, it was much easier:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Finset.range</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[(</span><span class=\"k\">show</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.succ</span> <span class=\"mi\">1</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">),</span> <span class=\"n\">Finset.range_succ</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>\n<p>But I wonder if one should actually have a Finset.range_two simp lemma in the Mathlib for this sort of situation.  What is the general philosophy regarding simp lemmas - should one stuff in as many random lemmas like this into the mathlib that would come up occasionally but not incredibly frequently, or should one be more minimalist?</p>",
        "id": 397130563,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697555545
    },
    {
        "content": "<p>Not addressing your direct question, but for me, these both work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Finset.range</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Finset.range</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 397131062,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1697555669
    },
    {
        "content": "<p>Do they on your mathlib version?</p>",
        "id": 397131227,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1697555717
    },
    {
        "content": "<p>Okay, I'm embarrassed to say I never even tried this!</p>",
        "id": 397131282,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697555735
    },
    {
        "content": "<p>In which case there is probably no need for an explicit Finset.range_two lemma in mathlib.</p>",
        "id": 397132268,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697556004
    },
    {
        "content": "<p>There's even automation (a \"linter\") which is supposed to prevent mathlib from getting simp lemmas which would provide duplicate simp-ing paths to an existing path.</p>",
        "id": 397132814,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1697556146
    },
    {
        "content": "<p>There's a few things to say here:</p>\n<ol>\n<li>Just as a tip, one way you may have been able to suspect the proof was <code>rfl</code> easier once you got down to this code:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Finset.range</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[(</span><span class=\"k\">show</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.succ</span> <span class=\"mi\">1</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">),</span> <span class=\"n\">Finset.range_succ</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>\n<p>Is by calling <code>simp?</code> which says <code>Try this: simp only</code>, which means that it wasn't applying any simp lemmas. And then you might just try deleting stuff, and you'll find that you get all the way down to <code>rfl</code>.</p>\n<ol start=\"2\">\n<li>Your question is still valid for explicit lemmas like <code>Finset.range_two</code> which are <em>not</em> provable by <code>rfl</code>, and the answer is that sometimes we provide convenience lemmas for special cases. Generally, I would say the rule of thumb is: if someone needed it, they probably wrote it and added it to mathlib (assuming it passes the <code>simpNF</code> linter Heather referred to).</li>\n</ol>\n<p>The following aren't all necessarily <code>simp</code> lemmas, but they are the sorts of special case lemmas you were considering here:<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=half_pos#doc\">docs#half_pos</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=zero_lt_four#doc\">docs#zero_lt_four</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.card_doubleton#doc\">docs#Finset.card_doubleton</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=isLUB_pair#doc\">docs#isLUB_pair</a>, and there are plenty more throughout the library.</p>",
        "id": 397147835,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697561231
    },
    {
        "content": "<p>I just found that the defeq of List.Mem changed from <a href=\"https://leanprover-community.github.io/mathlib_docs/init/data/list/basic.html#list.mem\">Lean 3</a> to <a href=\"https://github.com/leanprover/lean4/blob/5e0f6049c002e04e3593f1a08c96488bc6f8c49a/src/Init/Data/List/Basic.lean#L350-L354\">Lean 4</a> and as a consequence destructing Finset membership becomes more complicated:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Finset.range</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"bp\">|</span><span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,(</span><span class=\"n\">_</span><span class=\"bp\">|</span><span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,⟨⟩⟩)⟩)</span>\n  <span class=\"n\">exacts</span> <span class=\"o\">[</span><span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">Or.inr</span> <span class=\"n\">rfl</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>in Lean3 it used to be <code>rintro (rfl|rfl|⟨⟩)</code> IIRC.</p>",
        "id": 397428013,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1697690415
    }
]