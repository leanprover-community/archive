[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p><code>ENat</code> is a <code>CompleteLinearOrder</code> so there's probably some lattice class that this statement works for, but I couldn't find a theorem for it.<br>\nAs for proving it:<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=iSup_eq_top#doc\">docs#iSup_eq_top</a> seems almost helpful but not quite.<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENat.iSup_coe_ne_top#doc\">docs#ENat.iSup_coe_ne_top</a> might help (applied to <code>ENat.toNat ∘ f</code>, plus <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finite.bddAbove_range#doc\">docs#Finite.bddAbove_range</a>) but I don't like that direction, especially since it's specific to <code>ENat</code>.</p>",
        "id": 566006078,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1767311537
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">iSup_coe_ne_top</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"c1\">-- apply?</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"bp\">.</span><span class=\"n\">bddAbove_range</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"c1\">-- apply?</span>\n</code></pre></div>",
        "id": 566006426,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1767311980
    },
    {
        "content": "<p>But you found those</p>",
        "id": 566006490,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1767312020
    },
    {
        "content": "<p>Maybe this is a start</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ne_eq</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">iSup_eq_top</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_forall</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"bp\">.</span><span class=\"n\">bddAbove_range</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">bddAbove_def</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"n\">simp_all</span>\n</code></pre></div>",
        "id": 566006879,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1767312316
    },
    {
        "content": "<p>Cool, I didn't know about <code>lift</code>! But the <code>lift</code> is probably specific to <code>ENat</code> (or maybe to <code>WithTop</code>).<br>\nDo you know which lattice class this theorem holds for? Or maybe where I can find a Venn diagram of them?</p>",
        "id": 566007378,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1767313162
    },
    {
        "content": "<p>It has nothing to do with Top. For any linear order it will be true that if f(x) isn't y for all x in some finite set then the sup of the f(x) won't be y, because the sup is just the max for a finite set in a linear order and in particular is attained.</p>",
        "id": 566007655,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1767313677
    },
    {
        "content": "<p>Good point, although that also requires the set to be nonempty , or for <code>iSup ∅ ≠ y</code><br>\nSo it works for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CompleteLinearOrder#doc\">docs#CompleteLinearOrder</a> (plus <code>Nontrivial</code> for <code>⊥ ≠ ⊤</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompleteLinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iSup</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">isEmpty_or_nonempty</span><span class=\"w\"> </span><span class=\"n\">ι</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range_nonempty</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">csSup_mem</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">finite_range</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:)</span>\n</code></pre></div>\n<p>Is it possible for a weaker class?</p>",
        "id": 566008523,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1767315133
    },
    {
        "content": "<p>As Kevin said, ⊤ is a red herring here. Replace it by any other value and the result will still be true (except potentially when ι is empty).</p>",
        "id": 566191860,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1767493044
    },
    {
        "content": "<p>Surely <code>ConditionallyCompleteLinearOrder</code> works as well?</p>",
        "id": 566191888,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1767493095
    },
    {
        "content": "<p>Any other value <code>y</code> requires  an <code>iSup ∅ ≠ y</code> hypothesis as I mentioned, unless I'm missing something</p>",
        "id": 566191931,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1767493173
    },
    {
        "content": "<p>Oh yeah, that is true. <code>iSup Ø</code> is pretty much just a non-specified junk value on anything other than an <code>OrderTop</code>.</p>",
        "id": 566191954,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1767493204
    },
    {
        "content": "<p>this is why I like using <code>IsGLB</code> better than <code>iSup</code> or <code>sSup</code> or <code>Finset.max'</code> or <code>Finset.sup</code> or</p>",
        "id": 566192040,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767493341
    },
    {
        "content": "<p>Someone really ought to unify all of these at some point</p>",
        "id": 566192069,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1767493416
    },
    {
        "content": "<p>we have <code>IsGLB</code></p>",
        "id": 566192104,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767493491
    },
    {
        "content": "<p>FWIW I added the theorem above as <code>iSup_ne_top</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/33501\">#33501</a>, used once in <code>Finite.lean</code> (search for <code>Finite.lean</code>, click \"load diff\", then search for <code>iSup_ne_top</code>), if you have any suggestions for it (ignoring the graph theory around it)</p>",
        "id": 566192144,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1767493550
    },
    {
        "content": "<p>Basically it's used to show <code>(f x).toNat ≤ (iSup f).toNat</code> for <code>g : α → Set α</code> and <code>f := Set.encard ∘ g</code> given <code>[Finite α]</code>. It uses <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENat.toNat_le_toNat#doc\">docs#ENat.toNat_le_toNat</a> which requires <code>≠ ⊤</code></p>",
        "id": 566192291,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1767493777
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/iSup.20.E2.89.A0.20.E2.8A.A4/near/566192104\">said</a>:</p>\n<blockquote>\n<p>we have <code>IsGLB</code></p>\n</blockquote>\n<p>I think there was a proposal at some point to turn <code>sSup</code> and <code>sInf</code> into functions defined on any partial order, such that <code>sSup s = x</code> if <code>IsGLB s x</code>, or <code>sSup s = junk</code> otherwise. The different conditionally/complete lattices would then have conditions on <code>IsGLB</code>/<code>IsLUB</code>, rather than on <code>sSup</code>/<code>sInf</code>.</p>",
        "id": 566192766,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1767494646
    },
    {
        "content": "<p>I don't remember the status of this. I think I was opposed to it since it would lead to bad def-eqs, but given that <code>Set α</code> and <code>Unit</code> are the only two types where there's any reasonable def-eq to begin with I now think that's actually completely acceptable.</p>",
        "id": 566192804,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1767494717
    },
    {
        "content": "<p>(On a related note, we could and probably should do the same for <code>succ</code>, defining <code>succ x</code> on any partial order as an arbitrary covering element, or <code>x</code> if none exists.)</p>",
        "id": 566192934,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1767495001
    },
    {
        "content": "<p>No wait, the actual proposal for <code>sSup</code> was to make a <code>LawfulSup</code> class  with the <code>IsGLB s (sSup s)</code> assumption.</p>",
        "id": 566193184,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1767495515
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/27534\">#27534</a></p>",
        "id": 566193251,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1767495589
    }
]