[
    {
        "content": "<p>How can I prove this?</p>\n<p><del>theorem dvd_of_pow_dvd_pow {α : Type*} [CommMonoid α] {a b : α} {n : ℕ} (hn : 0 &lt; n) (h : a ^ n ∣ b ^ n) : a ∣ b :=  by sorry</del></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Int.dvd_of_pow_dvd_pow</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">∣</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∣</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 431879440,
        "sender_full_name": "Casavaca",
        "timestamp": 1712561872
    },
    {
        "content": "<p>I'm not sure your first lemma is true: does it work for <code>Z/p^3</code>, <code>a=p^2, b=p, n=3</code>?</p>",
        "id": 431881467,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712562342
    },
    {
        "content": "<p>You are right. I'll update my message.</p>",
        "id": 431882592,
        "sender_full_name": "Casavaca",
        "timestamp": 1712562664
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Int.GCD</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Int.dvd_of_pow_dvd_pow</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">∣</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∣</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span><span class=\"bp\">?</span> <span class=\"n\">says</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">pow_dvd_pow_iff</span> <span class=\"n\">hn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 431888218,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712563975
    },
    {
        "content": "<p>Strangely enough I also missed to find this very recently. I am adding in <a href=\"https://github.com/leanprover-community/mathlib4/pull/11767\">#11767</a> a generalization (and also changing the assumption to <code>n \\neq 0</code>)</p>",
        "id": 431888921,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1712564134
    },
    {
        "content": "<p>I've thought a little bit about it, and I don't think one can do better than integrally closed domains (being a domain is not enough)</p>",
        "id": 431889396,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1712564232
    },
    {
        "content": "<p>Thank you. Now I know why I missed it and what I should do:</p>\n<p>I missed it because I just imported Mathlib.Tactics and use moogle to search for tactics. I found some tactic but not applicable in my case.<br>\nI should just import the whole Mathlib and try <code>exact?</code> or <code>apply?</code></p>",
        "id": 431890887,
        "sender_full_name": "Casavaca",
        "timestamp": 1712564575
    },
    {
        "content": "<p>(I found the import by running <code>exact?</code> using <code>import Mathlib</code> and then reduced the import to the one containing the lemma.)</p>",
        "id": 431894012,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712565240
    },
    {
        "content": "<p>I found <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.pow_dvd_pow_iff#doc\">docs#Nat.pow_dvd_pow_iff</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.pow_dvd_pow_iff#doc\">docs#Int.pow_dvd_pow_iff</a> in loogle.</p>",
        "id": 433148294,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713113328
    },
    {
        "content": "<p>We now have <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/IntegralClosure/IntegrallyClosed.html#IsIntegrallyClosed.pow_dvd_pow_iff\">IsIntegrallyClosed.pow_dvd_pow_iff</a> that I <em>thought</em>  was general enough for basically any purpose. But then I realized that in flt-regular we need it for <code>Ideal R</code> (here <code>R</code> is a Dedekind domain), and the problem is that <code>Ideal R</code> is only a semiring, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/IntegralClosure/IntegrallyClosed.html#IsIntegrallyClosed.pow_dvd_pow_iff\">IsIntegrallyClosed.pow_dvd_pow_iff</a> does not apply. On the other hand, the results holds because <code>Ideal R</code> is a unique factorization monoid (the proof it's not hard).</p>\n<p>Does anyone see a generalization that cover these two cases? (The theory of integrally closed semirings looks scary :D)</p>",
        "id": 479644641,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1730282351
    },
    {
        "content": "<p>Interesting question! I just read the proof in the integrally closed domain case and the nontrivial direction goes like this: if b^n = x * a^n then working in the field of fractions we see that b/a is integral because its n'th power is x, so b/a is in the ground ring.</p>\n<p>Is it really such a sin to just prove the result again for unique factorisation monoids? UFDs are integrally closed but the concept doesn't make sense for monoids. We surely have lemmas which are true for commrings but also true for Nat and we just reprove for Nat. We also have lemmas which are true for groups and for groups with 0 and again we just state them twice rather than trying to find a common generalisation eg 'groups which might have a zero\".</p>",
        "id": 479662594,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1730288206
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/How.20to.20prove.20dvd_of_pow_dvd_pow.3F/near/479662594\">said</a>:</p>\n<blockquote>\n<p>We also have lemmas which are true for groups and for groups with 0 and again we just state them twice rather than trying to find a common generalisation eg 'groups which might have a zero\".</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DivisionMonoid#doc\">docs#DivisionMonoid</a> <span aria-label=\"sweat\" class=\"emoji emoji-1f613\" role=\"img\" title=\"sweat\">:sweat:</span></p>",
        "id": 479662904,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730288303
    },
    {
        "content": "<p>Ok so we _sometimes_ just state them twice :-)</p>",
        "id": 479664409,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1730288844
    },
    {
        "content": "<p>Of course we can have it twice, I was just wondering if there is a reasonable generalization (I think the standard mathlib solution for important things when there is no common generalization is to define a new class where the result holds by definition, but this is surely an overkill here).</p>",
        "id": 479669609,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1730290678
    },
    {
        "content": "<p>Does <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DecompositionMonoid#doc\">docs#DecompositionMonoid</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WfDvdMonoid#doc\">docs#WfDvdMonoid</a> help?</p>",
        "id": 479669750,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1730290717
    },
    {
        "content": "<p>I don't think so: we already have a proof of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">pow_dvd_pow_iff_dvd</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CancelCommMonoidWithZero</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">UniqueFactorizationMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>but the thing is that if <code>R</code> is a <em>ring</em>, assuming <code>UniqueFactorizationMonoid R</code> is not necessary (it holds with <code>[IsDomain R] [IsIntegrallyClosed R]</code>, that is weaker) and I don't see a common generalization.</p>",
        "id": 479672285,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1730291590
    },
    {
        "content": "<p>WfDvd is too strong because things like the integers in C_p satisfy this (they're integrally closed but not a UFD). But what about decomposition monoids which are domains? Is the result true for those? This covers the integers of C_p, and ideals in a Dedekind domain.</p>",
        "id": 479690282,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1730297142
    }
]