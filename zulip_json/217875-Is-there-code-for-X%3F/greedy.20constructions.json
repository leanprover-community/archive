[
    {
        "content": "<p>I've been thinking about this pattern of \"greedy constructions\" that show up in the Equational Theories project, and it seems like something where mathlib will have a general version but I'm coming up empty. Here's my characterization of the pattern:</p>\n<ul>\n<li>You have a partial order of states</li>\n<li>There are some tasks you want to accomplish. For every task and every state, there exists some later state which solves the task, and every state thereafter will have solved that particular task</li>\n<li>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> is the number of tasks, then every chain of length less than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> has an upper bound.</li>\n</ul>\n<p>Then, there exists a chain of length <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> on which every task has been solved.</p>\n<p>This looks very much like Zorn's lemma as stated, but I'm not sure how to get the cardinality bounds. Example uses:</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi><mo>=</mo><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa=\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span> and we are constructing a function while avoiding countably many obstructions. At each stage we have a finite approximation and so we can avoid any particular obstruction, and by resolving each obstruction in a fair manner (even if solving obstructions creates new obstructions), eventually we will have pointwise solved every obstruction.</li>\n<li>The proof that every countable dense linear order <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> without endpoints is order-isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8556em;vertical-align:-0.1667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span> has this structure (again with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi><mo>=</mo><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa=\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>). You build up a partial bijection point by point and the \"tasks\" are to make sure each element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8556em;vertical-align:-0.1667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span> and each element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> is covered.</li>\n<li>There are also examples with uncountable <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span>, but these are less common. I think you can do the well ordering principle and some kind of forcing constructions using this method.</li>\n</ul>",
        "id": 479008921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729905384
    },
    {
        "content": "<p>It also looks a lot like Kőnig's lemma, but Kőnig's lemma lacks the \"fairness\" element that is required by this kind of construction, it just lets you take any infinite path, meaning that you may have solved infinitely many tasks without solving all of them.</p>",
        "id": 479009580,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729906197
    },
    {
        "content": "<p>It feels a lot like a back and forth argument, in the sense that you assign a \"deadline \" to each task after which you will have solved it</p>",
        "id": 479028725,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1729927277
    },
    {
        "content": "<p>Something stronger than filters?</p>",
        "id": 479049111,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1729947496
    },
    {
        "content": "<p>Are you looking for a general tactic or a math concept or an algorithm?</p>",
        "id": 479049147,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1729947514
    },
    {
        "content": "<p>Or maybe coussot's abstract interpretation?</p>",
        "id": 479050195,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1729948557
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"492774\">@Sky Wilshaw</span> might have ideas</p>",
        "id": 479050591,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1729949025
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/greedy.20constructions/near/479049147\">said</a>:</p>\n<blockquote>\n<p>Are you looking for a general tactic or a math concept or an algorithm?</p>\n</blockquote>\n<p>This is a theorem</p>",
        "id": 479066157,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729964106
    },
    {
        "content": "<p>but if it exists in the literature that will make it easier to find in mathlib if it exists and name if it doesn't</p>",
        "id": 479066238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729964170
    },
    {
        "content": "<p>This is something the too-general <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=nonempty_sections_of_finite_cofiltered_system#doc\">docs#nonempty_sections_of_finite_cofiltered_system</a> can be useful for. More specific is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=nonempty_sections_of_finite_inverse_system#doc\">docs#nonempty_sections_of_finite_inverse_system</a>, which is used by Hall's theorem (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.all_card_le_biUnion_card_iff_exists_injective#doc\">docs#Finset.all_card_le_biUnion_card_iff_exists_injective</a>) and a graph homomorphism extension theorem (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=nonempty_hom_of_forall_finite_subgraph_hom#doc\">docs#nonempty_hom_of_forall_finite_subgraph_hom</a>) to turn finite extensibility into a solution on the full type.</p>\n<p>The second one is easier to explain in terms of colorings. Suppose we've proved the 4-color theorem for finite planar graphs. Then, for a particular (infinite) planar graph G, we create an inverse system indexed by finite subgraphs of G, where the type for a given finite subgraph consist of the all the 4-colorings of it. This is an inverse system because we can always restrict colorings to smaller subgraphs. Each of the types are finite and nonempty, so <code>nonempty_hom_of_forall_finite_subgraph_hom</code> applies. From this section, we can read off a global solution.</p>\n<p>Choosing a color for a vertex is a kind of task, and what I think is interesting about this example is that we don't require every coloring to be able to make forward progress — you might make a tragic choice of vertex color at some point that leads to contradiction only thousands of choices later — an interpretation of the nonemptiness hypotheses is that you <em>could</em> have made a good choice. If you do have a forward progress result that makes nonemptiness of each type in the inverse system all the easier.</p>",
        "id": 479067091,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729965106
    },
    {
        "content": "<p>(These are category-theoretic formulations of the compactness theorem by the way.)</p>",
        "id": 479067187,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729965192
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/greedy.20constructions/near/479067091\">said</a>:</p>\n<blockquote>\n<p>Choosing a color for a vertex is a kind of task, and what I think is interesting about this example is that we don't require every coloring to be able to make forward progress — you might make a tragic choice of vertex color at some point that leads to contradiction only thousands of choices later — an interpretation of the nonemptiness hypotheses is that you <em>could</em> have made a good choice. If you do have a forward progress result that makes nonemptiness of each type in the inverse system all the easier.</p>\n</blockquote>\n<p>How would you express this requirement in the partial order language I used? I agree that something like this might be important, in particular in many of the examples the set of tasks isn't really fixed but depend on the current approximation - but you can at least upper bound the set of tasks by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> so it should still work, where if a task is not applicable then we just skip it on that step.</p>",
        "id": 479067390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729965408
    },
    {
        "content": "<p>(One more note: these are proved with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TopCat.nonempty_limitCone_of_compact_t2_cofiltered_system#doc\">docs#TopCat.nonempty_limitCone_of_compact_t2_cofiltered_system</a>, which is formulated using nonempty compact T2 spaces, which I think is kind of nice since 'compactness' shows up more directly in this compactness theorem.)</p>",
        "id": 479067421,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729965469
    },
    {
        "content": "<p>I'm also interested in using this as a \"workhorse theorem\" so it should be relatively straightforward to apply in areas which don't have any of the above floating around. You quite often need to custom build a partial order or what have you on the spot to apply these theorems because they are really tuned for the application and are not general structure</p>",
        "id": 479067607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729965652
    },
    {
        "content": "<p>I'm guessing that an explicitly category theoretic statement will not meet these requirements because constructing a category on the spot is a chore</p>",
        "id": 479067749,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729965732
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/greedy.20constructions/near/479067390\">said</a>:</p>\n<blockquote>\n<p>How would you express this requirement in the partial order language I used?</p>\n</blockquote>\n<p>To use the Konig-like theorems I mentioned, it seems important that the type of states can be indexed by a partial order <code>I</code>, and for any given term of <code>I</code> the collection of states with that index are finite. There are counterexamples when you relax this finiteness</p>",
        "id": 479067791,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729965787
    },
    {
        "content": "<p>exactly, that's what caused me issues when applying Zorn's lemma because it wants to talk about a maximal <em>element</em> but the thing I'm going for isn't going to be finite even if it is a limit of finite approximations</p>",
        "id": 479067864,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729965852
    },
    {
        "content": "<p>And yeah, using these theorems, even <code>nonempty_sections_of_finite_inverse_system</code>, is a chore. You can look at the couple applications I linked to to see. There's universe level juggling, but also the final assembly of the global solution, not to mention creating the functor for the inverse system.</p>",
        "id": 479067866,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729965855
    },
    {
        "content": "<p>constructing a partial order is also a chore, I would like to have a version specialized for the case where the partial order is the set of partial functions satisfying a property (and the maximal element is a total function), because almost all examples fit in that form</p>",
        "id": 479067935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729965933
    },
    {
        "content": "<p>the way I framed it above has the finiteness baked in to the type of \"states\", so the final result is not actually a state but more of a coherent diagram on the states for which you might be able to take a limit in a larger space</p>",
        "id": 479068040,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729966020
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/greedy.20constructions/near/479067935\">said</a>:</p>\n<blockquote>\n<p>I would like to have a version specialized for the case where the partial order is the set of partial functions satisfying a property</p>\n</blockquote>\n<p>i think i wrote something along these lines some time ago... let me see if i can find it...</p>",
        "id": 479068195,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1729966147
    },
    {
        "content": "<p><a href=\"#narrow/channel/287929-mathlib4/topic/Existance.20proof.20of.20a.20sequence.20inductively.20.28Banach.20Dieudonn.C3.A9.29/near/466566446\">here</a></p>",
        "id": 479068338,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1729966273
    },
    {
        "content": "<p>this is code for proving that for any property <code>P</code> of a sequence <code>a-&gt;b</code> that you can check at some index <code>a</code> (i.e. <code>P:(a-&gt;b) -&gt; a -&gt; Prop</code>), if <code>a</code> is wellfounded, you can use that wellfoundedness as a framework to define a sequence which will have said property for all <code>a</code></p>",
        "id": 479068732,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1729966640
    },
    {
        "content": "<p>in this case, i guess the property would be \"all tasks <code>&lt;= n</code> have been completed at step <code>n</code>\"</p>",
        "id": 479069651,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1729967428
    },
    {
        "content": "<p>Perhaps the correct abstract framework is a state space <code>Ω</code> and a task space <code>T: Set ( Set Ω )</code>, and to have the following two (easy) results:</p>\n<ol>\n<li>Compactness theorem: if the state space is a compact space, the tasks are all closed, and every finite set <code>F: Finset T</code> of tasks is satisfiable by at least one state, then the entire set of tasks is satisfiable by a single state.</li>\n<li>Greedy algorithm: if the state space is partially ordered and non-empty, and the tasks are all downwardly closed and cofinal, then every finite set of tasks is satisfiable by at least one state.</li>\n</ol>\n<p>Of course, these combine to give</p>\n<p>Infinite Greedy algorithm: If the state space is compact, partially ordered and non-empty, and the tasks are all topologically closed, downwardly closed, and cofinal, then there is a state that satisfies all the tasks.</p>",
        "id": 479075472,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729972787
    },
    {
        "content": "<p>Is your state space including the infinite solutions? In (1) it seems like it has to be, but in (2) we need to know we are not already in an infinite state in order to argue that there is a way to solve a given task</p>",
        "id": 479075701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729972967
    },
    {
        "content": "<p>Ah, good point.  In applications one needs to apply the greedy algorithm to a subset of the full state space.  So, um, the corollary looks more like this:</p>\n<p>Infinite Greedy algorithm (revised): If the state space is compact, there is a subset of the state space which is partially ordered and non-empty, the tasks are all topologically closed in the full state space and downwardly closed and cofinal in the subset of the state space, then there is a state (in the full state space) that satisfies all the tasks.</p>",
        "id": 479075804,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729973076
    },
    {
        "content": "<p>Are these structures that are being described something like infinite variants of greedoids or matroids? (Every time I read your initial statement, I get a different structure in my mind, so I am trying to understand what your structure would mean in an algorithmic sense)</p>",
        "id": 479077242,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1729974555
    },
    {
        "content": "<p>I retract my proposal.  In many contexts (particularly ones where there are an infinite number of available choices at each step), one does not in fact have compactness, and this approach is not suitable.  I now think one should not use any topological notions and only proceed through order theory.  Something like:</p>\n<p>Infinite Greedy algorithm (third proposal): If one has a partially ordered state space, with every chain having an upper bound, all tasks upwardly closed, and within a non-empty subset of the state space, all tasks are cofinal, then there is a state that obeys all the tasks.</p>\n<p>[One may need to strengthen \"every chain has an upper bound\" to \"every directed set has an upper bound\".  I thought Zorn's lemma meant the two were equivalent, but actually I can't see this right now.  EDIT: They are equivalent, though nontrivially so, see <a href=\"https://mathoverflow.net/questions/378004/suprema-of-directed-sets]\">https://mathoverflow.net/questions/378004/suprema-of-directed-sets]</a></p>\n<p>As an example, states might be partial functions obeying some rules, and each task verifies that some functional equation is well defined and satisfied for such a partial function.  The greedy part is in verifying the cofinality, that every task can be achieved by extending the partial function suitably, if the partial function is \"small\" (e.g., only defined on a finite set).</p>",
        "id": 479078050,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729975372
    }
]