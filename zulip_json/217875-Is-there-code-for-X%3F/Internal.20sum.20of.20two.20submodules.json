[
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DirectSum.IsInternal#doc\">docs#DirectSum.IsInternal</a> to say that a family of submodules is in direct sum. Do we have the analogue for two submodules? Should we have it? It seems a pretty common special case.</p>",
        "id": 459722791,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1723307330
    },
    {
        "content": "<p>Also, what am I missing when I write the super complicated:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DirectSum</span><span class=\"bp\">.</span><span class=\"n\">IsInternal</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hij</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">disjoint_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">submodule_independent</span><span class=\"bp\">.</span><span class=\"n\">pairwiseDisjoint</span><span class=\"w\"> </span><span class=\"n\">hij</span>\n</code></pre></div>",
        "id": 459724564,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1723308703
    },
    {
        "content": "<p>Is it <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsCompl#doc\">docs#IsCompl</a> ? I guess this doesn't work for subsemimodules</p>",
        "id": 459726126,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723309475
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DirectSum</span><span class=\"bp\">.</span><span class=\"n\">IsInternal</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hij</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">submodule_independent</span><span class=\"bp\">.</span><span class=\"n\">pairwiseDisjoint</span><span class=\"w\"> </span><span class=\"n\">hij</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">eq_bot</span>\n</code></pre></div>\n<p>is a little better</p>",
        "id": 459726592,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723309609
    },
    {
        "content": "<p>Arguably something to teach is to avoid <code>U i ⊓ U j = ⊥</code> and stick with <code>Disjoint</code>, which removes the last bit</p>",
        "id": 459726724,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723309657
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Internal.20sum.20of.20two.20submodules/near/459726126\">said</a>:</p>\n<blockquote>\n<p>Is it <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsCompl#doc\">docs#IsCompl</a> ? I guess this doesn't work for subsemimodules</p>\n</blockquote>\n<p>Oh yes, I was silly, I didn’t think of looking for a purely lattice-theoretic spelling. I guess I was misled by the existence of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DirectSum.IsInternal#doc\">docs#DirectSum.IsInternal</a> which is specific to linear algebra.</p>",
        "id": 459727275,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1723309810
    },
    {
        "content": "<p>The lattice and algebraic spellings don't coincide for additive sub<em>monoid</em>s!</p>",
        "id": 459727414,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723309852
    },
    {
        "content": "<p>That's probably not a point to dwell on in MIL though!</p>",
        "id": 459727633,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723309895
    },
    {
        "content": "<p>What do you mean by the algebraic spelling here? Writing things uniquely as a product?</p>",
        "id": 459727730,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1723309927
    },
    {
        "content": "<p>Indeed I’m currently writing the linear algebra chapter only in the classical context of vector spaces, although I will probably include a short section on modules over rings.</p>",
        "id": 459727931,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1723309973
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Internal.20sum.20of.20two.20submodules/near/459727730\">said</a>:</p>\n<blockquote>\n<p>What do you mean by the algebraic spelling here? Writing things uniquely as a product?</p>\n</blockquote>\n<p>I think I mean that <code>U.subtype.coprod V.subtype</code> is bijective (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.coprod#doc\">docs#LinearMap.coprod</a>), so yes</p>",
        "id": 459728511,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723310149
    },
    {
        "content": "<p>Yes, that’s the same thing.</p>",
        "id": 459728703,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1723310190
    },
    {
        "content": "<blockquote>\n<p>although I will probably include a short section on modules over rings.</p>\n</blockquote>\n<p>but not semimodules over semirings, I assume!</p>",
        "id": 459728744,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723310206
    },
    {
        "content": "<p>I wanted to mention briefly those, simply to explain why we have this generality in Mathlib. My plan was to point out the case of monoids and </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">moduleSubmodule</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 459728945,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1723310273
    },
    {
        "content": "<p>Maybe we should have a binary version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DirectSum.IsInternal#doc\">docs#DirectSum.IsInternal</a> then.</p>",
        "id": 459729099,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1723310329
    },
    {
        "content": "<p>And presumably also a lattice version  of it</p>",
        "id": 459730837,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723310891
    }
]