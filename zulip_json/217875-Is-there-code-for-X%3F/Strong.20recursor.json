[
    {
        "content": "<p>Hi, I am wondering if there is a recursor that can construct a function <code>f</code> on the natural numbers obeying a given recursion <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(n) = F(f(0), \\dots, f(n-1))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">))</span></span></span></span> for a given function <code>F</code>.  More precisely, I would like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">strong_rec</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I am aware of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.strongRec%27#doc\">docs#Nat.strongRec'</a> but am struggling to apply it to this situation.  I think I can cobble together a very long construction here in which I first show inductively that I can build a function <code>f</code> on <code>Fin n</code> for each <code>n</code> obeying the required properties, and which is consistent as one goes from <code>n</code> to <code>n+1</code>, and then extract the diagonal, but surely there is a better way?</p>",
        "id": 525111945,
        "sender_full_name": "Terence Tao",
        "timestamp": 1750459611
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">strong_rec</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">strongRec</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">isLt</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">strongRec_eq</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">isLt</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 525112385,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750459999
    },
    {
        "content": "<p>Can we deprecate <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.strongRec%27#doc\">docs#Nat.strongRec'</a> ? It's just a copy of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.strongRec#doc\">docs#Nat.strongRec</a> with worse argument names.</p>",
        "id": 525112489,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750460108
    },
    {
        "content": "<p>Ah, I had failed to appreciate what <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.strongRec#doc\">docs#Nat.strongRec</a> (or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.strongRec%27#doc\">docs#Nat.strongRec'</a>) was actually doing.  Thanks!</p>",
        "id": 525112589,
        "sender_full_name": "Terence Tao",
        "timestamp": 1750460198
    },
    {
        "content": "<p>It's remarkable to me that the elaborator can even verify that the definition for <code>Nat.strongRec</code> provably terminates</p>",
        "id": 525112799,
        "sender_full_name": "Terence Tao",
        "timestamp": 1750460382
    },
    {
        "content": "<p>When your theorems or definitions are recursive in an interesting way, it's often easier to write them as actually recursive declarations, and then do the termination argument separately (if lean doesn't figure it out itself anyways), using <code>termination_by</code> and <code>decreasing_by</code>, than to find a suitable <code>induction</code> to invoke.</p>",
        "id": 525142046,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1750494815
    },
    {
        "content": "<p>And if you have a definition defined that way, you might enjoy ”functional induction” (the <code>fun_induction</code> tactic) when proving properties of that definition.</p>",
        "id": 525142088,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1750494876
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Strong.20recursor/near/525112799\">said</a>:</p>\n<blockquote>\n<p>It's remarkable to me that the elaborator can even verify that the definition for <code>Nat.strongRec</code> provably terminates</p>\n</blockquote>\n<p>I can see how it does it (infer the termination condition from usage and than prove it by assumption), but it's indeed pretty cool.</p>",
        "id": 525152441,
        "sender_full_name": "suhr",
        "timestamp": 1750504172
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Strong.20recursor/near/525142046\">said</a>:</p>\n<blockquote>\n<p>When your theorems or definitions are recursive in an interesting way, it's often easier to write them as actually recursive declarations, and then do the termination argument separately (if lean doesn't figure it out itself anyways), using <code>termination_by</code> and <code>decreasing_by</code>, than to find a suitable <code>induction</code> to invoke.</p>\n</blockquote>\n<p>You don't get nice kernel reduction with that, which can be achieved with <a href=\"#narrow/channel/113488-general/topic/Reducibility.20and.20decreasing_by/near/522729652\">this version</a> of <code>Nat.strongRec</code>.</p>",
        "id": 525224573,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1750613385
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Strong.20recursor/near/525224573\">schrieb</a>:</p>\n<blockquote>\n<p>You don't get nice kernel reduction with that</p>\n</blockquote>\n<p>There is <a href=\"https://github.com/leanprover/lean4/pull/7965\">lean4#7965</a> :-) I'd love to see this merged in some form but there are still some things to figure out about this</p>",
        "id": 525226846,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750616416
    },
    {
        "content": "<p>And that one would only give you nice reduction behavior for closed terms (<code>by decide</code>), not necessary for open terms (what you want when you use these definitions within types).</p>",
        "id": 525229182,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1750619885
    }
]