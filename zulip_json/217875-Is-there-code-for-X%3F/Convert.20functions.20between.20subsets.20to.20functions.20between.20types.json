[
    {
        "content": "<p>I find it more convenient to work on types than subtypes in Lean. However, some functions are naturally defined on subsets, which are defined as subtypes. Therefore, I hope there is a natural way to convert these functions to functions defined on types. I don't know if there is already a solution in mathlib4, at least I didn't find one. So I wrote one and submitted a PR. The main definition is as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.ContinuousOn</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">true</span>\n<span class=\"kn\">open</span> <span class=\"n\">Set</span> <span class=\"n\">Function</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Nonempty</span> <span class=\"bp\">↑</span><span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidablePred</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Function.toval</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidablePred</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">Set.Nonempty</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"bp\">@</span><span class=\"n\">nonempty_coe_sort</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n  <span class=\"k\">let</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">ht.some</span>\n  <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩)</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n    <span class=\"k\">else</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>See <a href=\"https://github.com/leanprover-community/mathlib4/pull/7449\">https://github.com/leanprover-community/mathlib4/pull/7449</a> for more details.<br>\nI wonder if we could add this to mathlib4.</p>",
        "id": 394205404,
        "sender_full_name": "Wen Yang",
        "timestamp": 1696163788
    },
    {
        "content": "<p>You could use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.extend#doc\">docs#Function.extend</a>. Precisely, <code>Function.toval f = Function.extend f fun _ ↦ (Set.nonempty_coe_sort.1 ‹_›).some</code>.</p>",
        "id": 394205636,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1696163940
    },
    {
        "content": "<p>Thanks, Yaël Dillies. Unfortunately, <code>Function.extend f fun _ ↦ (Set.nonempty_coe_sort.1 ‹_›).some</code> did not work.​ I think it's not intuitive to use <code>Function.extend</code> here.</p>",
        "id": 394210100,
        "sender_full_name": "Wen Yang",
        "timestamp": 1696166251
    },
    {
        "content": "<p>Ah sorry I just forgot an argument to <code>Function.extend</code>. Replace <code>Function\nextend f</code> by <code>Function.extend Subtype.val f</code>.</p>",
        "id": 394211324,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1696166986
    },
    {
        "content": "<p>I wonder why it's not intuitive though. You want to extend a function defined on <code>s</code> to a function defined on the full domain <code>α</code>. Is that not intuitive?</p>",
        "id": 394211450,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1696167045
    },
    {
        "content": "<p>Maybe I'm just not used to it yet. This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Basic</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">true</span>\n<span class=\"kn\">open</span> <span class=\"n\">Set</span> <span class=\"n\">Function</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Nonempty</span> <span class=\"bp\">↑</span><span class=\"n\">t</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Function.toval</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n    <span class=\"n\">extend</span> <span class=\"n\">Subtype.val</span>\n    <span class=\"o\">(</span><span class=\"n\">Subtype.val</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">Set.nonempty_coe_sort.1</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›)</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 394211870,
        "sender_full_name": "Wen Yang",
        "timestamp": 1696167292
    },
    {
        "content": "<p>I'll try to see if I can build the APIs for this.</p>",
        "id": 394212093,
        "sender_full_name": "Wen Yang",
        "timestamp": 1696167403
    },
    {
        "content": "<p>I have modified the definition of <code>Function.toval</code>. However, I don't know how to work with <code>Function.extend</code>, so I give up. I don't even know how to prove that the two definitions are the same:​</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Function</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">true</span>\n<span class=\"kn\">open</span> <span class=\"n\">Set</span> <span class=\"n\">Function</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Nonempty</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Function.toval</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Classical.propDecidable</span> <span class=\"n\">_</span>\n    <span class=\"k\">if</span> <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩)</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n    <span class=\"k\">else</span> <span class=\"n\">Classical.choice</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">toval_eqOn_extend</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">EqOn</span>\n    <span class=\"n\">f.toval</span>\n    <span class=\"o\">(</span><span class=\"n\">extend</span> <span class=\"n\">Subtype.val</span>\n      <span class=\"o\">(</span><span class=\"n\">Subtype.val</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">Classical.choice</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›))</span>\n    <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 394416205,
        "sender_full_name": "Wen Yang",
        "timestamp": 1696249941
    },
    {
        "content": "<p>Here's a proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Function</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">true</span>\n<span class=\"kn\">open</span> <span class=\"n\">Set</span> <span class=\"n\">Function</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Nonempty</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Function.toval</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Classical.propDecidable</span> <span class=\"n\">_</span>\n    <span class=\"k\">if</span> <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"k\">then</span> <span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span>\n    <span class=\"k\">else</span> <span class=\"n\">Classical.choice</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">toval_eq_extend</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">extend</span> <span class=\"n\">Subtype.val</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">Classical.choice</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›)</span> <span class=\"bp\">=</span> <span class=\"n\">f.toval</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">a</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">toval</span>\n  <span class=\"n\">split_ifs</span> <span class=\"k\">with</span> <span class=\"n\">ha</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Subtype.val_injective.extend_apply</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">refine</span> <span class=\"n\">extend_apply'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n    <span class=\"n\">exact</span> <span class=\"n\">ha</span> <span class=\"n\">a.2</span>\n</code></pre></div>",
        "id": 394473880,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1696265151
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>  Thank you very much! I have submitted a PR that includes your proof: <a href=\"https://github.com/leanprover-community/mathlib4/pull/7482\">https://github.com/leanprover-community/mathlib4/pull/7482</a></p>",
        "id": 394593975,
        "sender_full_name": "Wen Yang",
        "timestamp": 1696325239
    }
]