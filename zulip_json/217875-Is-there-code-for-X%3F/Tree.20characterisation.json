[
    {
        "content": "<p>Does anyone have a proof of the converse to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.IsTree.card_edgeFinset#doc\">docs#SimpleGraph.IsTree.card_edgeFinset</a> anywhere? I briefly looked in a couple likely locations (including LeanCamCombi) but I didn't find it.</p>",
        "id": 507455768,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1742652990
    },
    {
        "content": "<p>More precisely, I'm looking for a proof of the following <code>sorry</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">Acyclic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Cardinal</span><span class=\"bp\">.</span><span class=\"n\">Finite</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">isTree_iff_connected_and_card</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">IsTree</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Connected</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edgeSet</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">isConnected</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">ofFinite</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edgeSet</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">ofFinite</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edgeSet</span>\n<span class=\"w\">    </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">card_edgeFinset</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 507455792,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1742653017
    },
    {
        "content": "<p>It would be neat if we had an even more general theorem. These are the parts:</p>\n<ul>\n<li>We already have the number of components: <code>Nat.card G.ConnectedComponent</code></li>\n<li>We need the dimension of the cycle space. I think that's the dimension of the nullspace of <code>G.incMatrix (ZMod 2)</code></li>\n<li>Then the general theorem is that (as integers) <code>Nat.card V - Nat.card G.edgeSet = Nat.card G.ConnectedComponent - G.cycleDim</code> (Euler characteristic for graphs)</li>\n</ul>\n<p>Then we'd want <code>G.IsAcyclic &lt;-&gt; G.cycleDim = 0</code> and <code>G.Connected &lt;-&gt; Nat.card G.ConnectedComponent = 1</code>. Putting these all together, <code>SimpleGraph.isTree_iff_connected_and_card</code> follows.</p>",
        "id": 507460810,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742656870
    },
    {
        "content": "<p>The above is a great plan, which I’d love to see implemented.</p>\n<p>However a direct proof of the tree characterisation would still be a perfectly good contribution.</p>",
        "id": 507476165,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1742667403
    },
    {
        "content": "<p>No objections there. It's unclear to me that it's that much easier to avoid the more general theorem!</p>\n<p>Maybe it's not so bad; we'd need that <code>G.Connected</code> implies <code>Nat.card G.edgeSet + 1 &gt;= Nat.card V</code> and that adding an edge to a tree makes it non-acyclic. This could be organized using a characterization that trees are the minimal connected graphs in the <code>SimpleGraph V</code> lattice.</p>",
        "id": 507477814,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742668491
    },
    {
        "content": "<p>I (independently) thought about similar things a while ago, and suggested it to a student, so after the coursework deadline has passed, stuff making this easier should appear in PRs!</p>",
        "id": 508543836,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1743088002
    },
    {
        "content": "<p>I think the stuff Kyle is talking about should wait for multigraphs (in fact, it's all matroidal; <code>G.cycleDim</code> is the rank of the dual graphic matroid of the <code>G</code> over <code>ZMod 2</code>, and this makes sense for any binary matroid). <br>\nGoing too far down this road just for simple graphs will mean having to start from scratch later. <br>\nFor instance, this theory interacts beautifully with edge-contractions, and simple graphs won't be enough to state that properly.</p>\n<p>My PhD student is working on multigraphs now! Hopefully we'll be able to PR a reasonable definition before too long.</p>",
        "id": 508578902,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743096199
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">Acyclic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Cardinal</span><span class=\"bp\">.</span><span class=\"n\">Finite</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Card</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">Order</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Deleting a non-bridge edge from a connected graph preserves connectedness. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">Connected</span><span class=\"bp\">.</span><span class=\"n\">connected_del_of_not_isBridge</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hG</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Connected</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">IsBridge</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">fromEdgeSet</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)})</span><span class=\"bp\">.</span><span class=\"n\">Connected</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">classical</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">isBridge_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_and</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_not</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">hxy</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hxy</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">em'</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rwa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Disjoint</span><span class=\"bp\">.</span><span class=\"n\">sdiff_eq_left</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">connected_iff_exists_forall_reachable</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">W</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hG</span><span class=\"bp\">.</span><span class=\"n\">preconnected</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"bp\">.</span><span class=\"n\">toPath</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">heP</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">heP</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">em'</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"n\">edges</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"n\">toDeleteEdges</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hyP</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"n\">snd_mem_support_of_mem_edges</span><span class=\"w\"> </span><span class=\"n\">heP</span>\n<span class=\"w\">  </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">P₁</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"n\">takeUntil</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">hyP</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">hP₁</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hxP₁</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Walk</span><span class=\"bp\">.</span><span class=\"n\">endpoint_not_mem_support_takeUntil</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">hyP</span><span class=\"w\"> </span><span class=\"n\">hxy</span><span class=\"bp\">.</span><span class=\"n\">ne</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">heP₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">P₁</span><span class=\"bp\">.</span><span class=\"n\">edges</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">hxP₁</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">P₁</span><span class=\"bp\">.</span><span class=\"n\">fst_mem_support_of_mem_edges</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">hxy</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Reachable</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">P₁</span><span class=\"bp\">.</span><span class=\"n\">toDeleteEdges</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- A minimally connected graph is a tree. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">isTree_of_minimal_connected</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Minimal</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">Connected</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">IsTree</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">isTree_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">and_iff_right</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">prop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">isAcyclic_iff_forall_adj_isBridge</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">hvw</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">by_contra</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hbr</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">not_prop_of_lt</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">prop</span><span class=\"bp\">.</span><span class=\"n\">connected_del_of_not_isBridge</span><span class=\"w\"> </span><span class=\"n\">hbr</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">edgeSet_ssubset_edgeSet</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span>\n\n<span class=\"sd\">/-- Every connected graph on `n` vertices has at least `n-1` edges. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">Connected</span><span class=\"bp\">.</span><span class=\"n\">card_vert_le_card_edgeSet_add_one</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hG</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Connected</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edgeSet</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">classical</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">T</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hTG</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hmin</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">Connected</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">toFinite</span><span class=\"bp\">.</span><span class=\"n\">exists_minimal_le</span><span class=\"w\"> </span><span class=\"n\">hG</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hT</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">IsTree</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">isTree_of_minimal_connected</span><span class=\"w\"> </span><span class=\"n\">hmin</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card_eq_fintype_card</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">hT</span><span class=\"bp\">.</span><span class=\"n\">card_edgeFinset</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card_coe_set_eq</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">ncard_coe_Finset</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_le_add_iff_right</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">ncard_mono</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">isTree_iff_connected_and_card</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">IsTree</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Connected</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edgeSet</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">classical</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">isConnected</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">card_edgeFinset</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩⟩</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">isAcyclic_iff_forall_adj_isBridge</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">by_contra</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hbr</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"bp\">.</span><span class=\"n\">connected_del_of_not_isBridge</span><span class=\"w\"> </span><span class=\"n\">hbr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card_vert_le_card_edgeSet_add_one</span><span class=\"bp\">.</span><span class=\"n\">not_lt</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">edgeSet_sdiff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">edgeSet_fromEdgeSet</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">edgeSet_sdiff_sdiff_isDiag</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">add_lt_add_iff_right</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card_coe_set_eq</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">ncard_diff_singleton_lt_of_mem</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>",
        "id": 508605085,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743104758
    },
    {
        "content": "<p>That was fun! I've never really dived into <code>SimpleGraph</code>,  but it looks like there are still a few API lemmas lacking.</p>",
        "id": 508605354,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743104874
    },
    {
        "content": "<p>Thanks so much for doing this. Please ping me on the PR :)</p>",
        "id": 508711645,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1743155692
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/23399\">#23399</a> - I have also included a few TODOs. In particular, I had to prove the bridge lemma 'backwards' because of the lack of a <code>dropUntil</code> version of <code>Walk.endpoint_not_mem_support_takeUntil</code>, which is just part of a general lack of API for <code>dropUntil</code>. </p>\n<p>Also some of my lemmas are true in the converse, but I am consciously avoiding spending too much time with <code>SimpleGraph</code>, because it will swallow me up if I do. So I'll leave it there with that PR.</p>",
        "id": 508729844,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743161081
    },
    {
        "content": "<p>Regarding TODOs, I see the point about clutter. But at the same time I think there should be a way to record them. Is a TODO section in the module docstring better than individual lemma docstrings?</p>",
        "id": 508750484,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743167133
    },
    {
        "content": "<p>If you want to keep them (which is fine) then I think where you put them is best.</p>",
        "id": 508752055,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1743167585
    },
    {
        "content": "<p>Ok, I've addressed your comments, and just removed the TODOs. I've also added some API to extract paths from proofs of connectedness/reachability without diving into <code>Connected -&gt; Preconnected -&gt; Reachable</code> defeq.</p>",
        "id": 508755237,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743168589
    },
    {
        "content": "<p>edit : never mind</p>",
        "id": 508755505,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743168654
    },
    {
        "content": "<p>(General note: TODOs and \"Future work\" sections in module docs are great. I would encourage -- although there's no clear policy on this -- people to write their name somewhere associated with TODOs, so years later there is someone to guilt-trip if they are still there. :-)</p>",
        "id": 508852153,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1743199245
    }
]