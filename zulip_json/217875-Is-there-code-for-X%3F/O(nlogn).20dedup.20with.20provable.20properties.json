[
    {
        "content": "<p>I want Multiset.dedup on<code> Multiset Nat</code> with O(nlogn) complexity with provable properties(provably equal to Multiset.dedup), using first sort and then dedup. Is there code for that in Mathlib?</p>",
        "id": 518012587,
        "sender_full_name": "Jiatong Yang",
        "timestamp": 1747214233
    },
    {
        "content": "<p>Not exactly what you're asking for, but here is one way to get a fast (expected linear time) <code>Multiset.fastDedup</code> using a hash set for deduplication. The proofs can be optimized considerably.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std.Data.HashSet.Lemmas</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Std</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">List</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">fastDedup</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"mi\">1</span>\n<span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Std.HashSet</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">l.foldr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Std.HashSet</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">IH</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">IH</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">IH</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IH</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">IH</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">([],</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">fastDedup.mem_snd_impl</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fastDedup.impl</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l.dedup</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">impl</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">impl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ite_not</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">ih</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">impl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ite_not</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">foldr_cons</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">rename_i</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">      </span><span class=\"n\">simp_all</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Eq.comm</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">fastDedup_eq_dedup</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l.fastDedup</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l.dedup</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Eq.comm</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fastDedup</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fastDedup.impl</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List.pwFilter</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dedup</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fastDedup</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fastDedup.impl</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">ih</span>\n<span class=\"w\">    </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">rename_i</span><span class=\"w\"> </span><span class=\"n\">h'</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">if_neg</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">fastDedup.mem_snd_impl</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fastDedup</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fastDedup.impl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ite_not</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"n\">mem_dedup</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dedup</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pwFilter</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h''</span>\n<span class=\"w\">        </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"n\">using</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">h''</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">if_pos</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">fastDedup.mem_snd_impl</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fastDedup</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fastDedup.impl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ite_not</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"n\">mem_dedup</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dedup</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pwFilter</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"n\">using</span><span class=\"w\"> </span><span class=\"n\">h'</span>\n\n<span class=\"kd\">end</span><span class=\"w\"> </span><span class=\"n\">List</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Multiset</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">fastDedup</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Quot.liftOn</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l.fastDedup</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Quot.sound</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"n\">using</span><span class=\"w\"> </span><span class=\"n\">p.dedup</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">fastDedup_eq_dedup</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s.fastDedup</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s.dedup</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">dedup</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fastDedup</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span><span class=\"w\"> </span><span class=\"n\">Multiset</span>\n</code></pre></div>",
        "id": 518021791,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1747216687
    },
    {
        "content": "<p>There is also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.sortDedup#doc\">docs#Array.sortDedup</a> that you could try to port to List and then Multiset. I'm quite sure that what you ask doesn't exist in Mathlib yet.</p>",
        "id": 518022737,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1747216940
    },
    {
        "content": "<p>Thank you very much!</p>",
        "id": 518022814,
        "sender_full_name": "Jiatong Yang",
        "timestamp": 1747216964
    },
    {
        "content": "<p>A slight caveat of the approach above is that </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fastDedup</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>fails, so it cannot actually provide proof terms of <code>someList.dedup = someOtherList</code> where the two lists are actual list literals.</p>",
        "id": 518024247,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1747217383
    },
    {
        "content": "<p>You can achieve an actual decidable one by doing something like this but It will be a lot more work to actually prove it is the right thing.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">mergeTR'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l₁</span><span class=\"w\"> </span><span class=\"n\">l₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l₁</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">l₂</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">l₁</span><span class=\"w\"> </span><span class=\"n\">l₂</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l₁</span><span class=\"w\"> </span><span class=\"n\">l₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l₁</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">l₂</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">l₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">reverseAux</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"n\">l₂</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">reverseAux</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"n\">l₁</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">mergeSortTR'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span>\n<span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">contradiction</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"bp\">::</span><span class=\"n\">x₂</span><span class=\"bp\">::</span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">lr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">splitAt</span><span class=\"w\"> </span><span class=\"o\">(((</span><span class=\"n\">x₁</span><span class=\"bp\">::</span><span class=\"n\">x₂</span><span class=\"bp\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x₁</span><span class=\"bp\">::</span><span class=\"n\">x₂</span><span class=\"bp\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">mergeTR'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"n\">lr</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">lr</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">⊢;</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">))</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"n\">lr</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">lr</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">⊢;</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">le</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">dedup'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">mergeSortTR'</span><span class=\"bp\">.</span><span class=\"n\">destutter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">dedup'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 518025394,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1747217758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/O.28nlogn.29.20dedup.20with.20provable.20properties/near/518024247\">said</a>:</p>\n<blockquote>\n<p>A slight caveat of the approach above is that </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fastDedup</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>fails, so it cannot actually provide proof terms of <code>someList.dedup = someOtherList</code> where the two lists are actual list literals.</p>\n</blockquote>\n<p><code>simp</code> solves this example.</p>",
        "id": 518026339,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1747218044
    },
    {
        "content": "<p>It can only do small lists though, which is a concern if one needs <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n \\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> dedup (assuming that they actually care about proof terms for concrete lists).</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fastDedup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eval</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eval</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fastDedup</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fastDedup</span><span class=\"bp\">.</span><span class=\"n\">impl</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 518027103,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1747218295
    },
    {
        "content": "<p>Sure. In general it should be assumed that there should be no relationship between what is fast for the kernel to evaluate and what is fast at runtime. Something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n \\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> doesn't really make sense for kernel evaluation, as the kernel is not a virtual machine in any traditional sense.</p>",
        "id": 518027563,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1747218469
    },
    {
        "content": "<p>Hmmm I assume the time for the kernel to check a proof term is directly related to how big a proof term is? (perhaps quadratic in depth and linear in size for fix depth etc)<br>\nI actually need something like this (which is why I had that code snippet lying around) but it can only go up to ~5000. I wonder if you have any suggestions? Perhaps it is inherently limited by lists being recursive and having depth <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> and I need to switch to a better data structure (e.g. a balanced tree)?</p>",
        "id": 518028874,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1747218880
    },
    {
        "content": "<p>The kernel is a complex machine full of heruristics and opportunities for things to go wrong. Often it is better to have something like a tactic or a simproc which produces something that is easy for the kernel to check. Example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fastDedup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eval</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">List.range</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eval</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">List.range</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fastDedup_eq_dedup</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">repeat'</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">dedup_cons_of_not_mem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">List.cons_inj_right</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">dedup_nil</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>(though 5000 is too much for this example. The approach is still quadratic after all.)</p>",
        "id": 518029594,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1747219116
    },
    {
        "content": "<p>May I ask what your use case for kernel computations involving giant lists is?</p>",
        "id": 518029971,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1747219255
    },
    {
        "content": "<p>An example is to check <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> is a primitive root mod <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> you just generate the list <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><msup><mi>x</mi><mi>y</mi></msup><mi mathvariant=\"normal\">∣</mi><mi>y</mi><mo>&lt;</mo><mi>p</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[x ^ y | y &lt; p ]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">y</span></span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">]</span></span></span></span> and see if there are duplicates. (Of course there are mathematical solutions here that drastically reduces the amount of calculations needed but this is just a simplified example)</p>",
        "id": 518030656,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1747219460
    },
    {
        "content": "<p>From my limited experiences, <code>decide+kernel</code> is almost always faster then my (or <span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> 's) hand roll tactic trying to construct a proof term though.</p>",
        "id": 518030977,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1747219554
    },
    {
        "content": "<p>Thanks. It would certainly be nice to have more data structures specifically optimized for proofs (whether helped along by a tactic or not). We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.RArray#doc\">docs#Lean.RArray</a> which is a first step in that direction.</p>",
        "id": 518032650,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1747220013
    },
    {
        "content": "<p>Note, it is algorithmically easier to check that a list has no duplicates than to compute what the result of <code>dedup</code> is. So if the only thing you need is <code>Nodup</code> you should ask for that and not <code>dedup</code></p>",
        "id": 518087270,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747234107
    },
    {
        "content": "<p>You can for example prove that a list has no duplicates by sorting and then checking that it is strictly monotone. This can actually be done in O(n) proof length</p>",
        "id": 518088104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747234302
    },
    {
        "content": "<p>I'm not sure how to provide a O(n) proof length that L' is the sorted version of L.</p>",
        "id": 518088384,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1747234361
    },
    {
        "content": "<p>(and if you can do so, then you can linearly remove duplicates so dedup would also be O(n))</p>",
        "id": 518088598,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1747234425
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/O.28nlogn.29.20dedup.20with.20provable.20properties/near/518088598\">said</a>:</p>\n<blockquote>\n<p>(and if you can do so, then you can linearly remove duplicates so dedup would also be O(n))</p>\n</blockquote>\n<p>No, the proof is O(n), but the process of finding the proof is O(n log n) since you have to sort.</p>",
        "id": 518089823,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1747234730
    },
    {
        "content": "<p>How is the proof O(n)?</p>",
        "id": 518090547,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1747234870
    },
    {
        "content": "<p>I think we are all talking about proof sizes here? The algorithm Mario gave clearly has run time O(n log n) as well.</p>",
        "id": 518090759,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1747234918
    },
    {
        "content": "<p>I guess, provide an <code>e : Fin n ≃ Fin n</code> and show that <code>∀ n, L[n] = L'[e n]</code>, and also show that <code>L'</code> is sorted</p>",
        "id": 518092339,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1747235263
    },
    {
        "content": "<p>This all seems to be O(n)</p>",
        "id": 518092407,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1747235282
    },
    {
        "content": "<p>Lists probably don't support O(1) random access. You need some binary tree or some finger tree that can only give you O(log n) random access. Arrays don't work here because in the kernel arrays are just lists.</p>",
        "id": 518092599,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1747235335
    },
    {
        "content": "<p>I double checked <a href=\"https://cs.stackexchange.com/questions/105250/minimum-number-of-tree-operations-to-normalize-a-labeled-tree\">my notes</a> on this problem and it's O(n log n), not O(n).</p>",
        "id": 518093620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747235567
    },
    {
        "content": "<p>If you're counting kernel checking time then nothing is O(n) because you have to at least access every element of the list in a random order</p>",
        "id": 518094072,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1747235682
    },
    {
        "content": "<p>That's O(n)?</p>",
        "id": 518094110,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747235695
    },
    {
        "content": "<p>Permutation is O(n log n) in this model because you have only finitely many choices you can do at each stage and n! possible places to get to</p>",
        "id": 518094451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747235767
    },
    {
        "content": "<p>so basically the same kind of argument as why sorting is O(n log n) even though there is no comparison needed</p>",
        "id": 518094611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747235808
    },
    {
        "content": "<p>In an extreme example you traverse once and put everything into a balanced binary tree and then everything is fine and this will only be O(n log ^2 n) at most. This is just an example why it is not necessarily quadratic. The usual sorting algorithms should work in O(n log n) by the standard arguments.</p>",
        "id": 518095078,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1747235912
    },
    {
        "content": "<p>Sorting is not quite optimal in this setting though because it does more comparisons than necessary</p>",
        "id": 518095251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747235955
    },
    {
        "content": "<p>You can do it in O(n log n) time/proof length and O(n) comparisons</p>",
        "id": 518095293,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747235967
    },
    {
        "content": "<p>But I am suspecting that the kernel check time is quadratic wrt the depth of the proof term (and hence the 5000 and not something higher) and traversing lists will necessarily have O(n) depth. Can someone confirm such a suspicion?</p>",
        "id": 518095523,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1747236021
    },
    {
        "content": "<p>No? Why would that be the case</p>",
        "id": 518095643,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747236052
    },
    {
        "content": "<p>Because my near linear thing (see the snippet above) runs quadratically on my inputs. As for why I am guessing (pure guessing) that checking a node takes O(size of context) or whatever.</p>",
        "id": 518096311,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1747236223
    },
    {
        "content": "<p>You aren't generating proof terms though, whnf is an entirely different beast</p>",
        "id": 518096571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747236293
    },
    {
        "content": "<p>Oh you mean it's <code>decide</code> being quadratic? I'll see if I can manage to produce an actual proof term of size O(n log n)</p>",
        "id": 518096986,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1747236390
    },
    {
        "content": "<p>I find it extremely challenging to write functions that actually have good whnf performance</p>",
        "id": 518097007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747236399
    },
    {
        "content": "<p>keep in mind that if you use the default equation compiler it will generate a ton of gunk that has to be waded through in every step of the iteration</p>",
        "id": 518097187,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747236442
    },
    {
        "content": "<p>Your best bet is to use <code>T.rec</code> directly</p>",
        "id": 518097329,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747236480
    },
    {
        "content": "<p>How does the kernel check time scale with the size and depth of the proof term? I have a memory of you Mario telling me that it's worse than linear in the depth, but I might well be misremembering</p>",
        "id": 518097377,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1747236484
    },
    {
        "content": "<p>It's ~quadratic in the size of the context, so you should avoid binders if possible</p>",
        "id": 518097542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747236532
    },
    {
        "content": "<p>Does that include <code>let_fun</code> blocks?</p>",
        "id": 518097645,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1747236563
    },
    {
        "content": "<p>yes, if the data being manipulated has fvars in it</p>",
        "id": 518097915,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747236619
    },
    {
        "content": "<p>You can use <code>letI</code> to avoid introducing a binder in this case</p>",
        "id": 518098113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747236673
    },
    {
        "content": "<p>the issue is that doing a beta reduction when the function to reduce contains your data in it will have lean walk the term to substitute the variable in, which gets more expensive as your data grows unless it's a closed term in which case it can be short circuited</p>",
        "id": 518098469,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747236763
    },
    {
        "content": "<p>The two basic optimizations one can take advantage of during whnf are:</p>\n<ul>\n<li>subterms are cached so if the term has internal sharing or it is duplicative then is not expensive the second time</li>\n<li>There is a flag in each term saying \"I have no bvars/fvars\" which makes the lift and subst operations short circuit</li>\n</ul>\n<p>Other than this, beta reduction is linear</p>",
        "id": 518099059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747236932
    }
]