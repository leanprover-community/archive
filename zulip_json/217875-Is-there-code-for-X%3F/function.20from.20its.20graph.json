[
    {
        "content": "<p>In the usual ZFC theory, functions <code>f : A -&gt; B</code> are not first class objects, but they are just its graph (which is a certain subset of <code>A x B</code>. That way, for instance, the axiom of choice is equivalent to Zorn's lemma because you can use Zorn's lemma to construct the graph of the choice function.</p>\n<p>However, I am unable to deduce choice from Zorn's lemma, or from the well order principle, in Lean. My problem is that I cannot go from the graph of a function (i.e. a subset of <code>A x B</code> that has exactly one element for each element of <code>A</code>)to an actual object of the type <code>A -&gt; B</code>.</p>\n<p>Is it possible? Or in the CIC version of choice is actually stronger than the one in ZFC?</p>",
        "id": 566582001,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1767717859
    },
    {
        "content": "<p>in lean, that specific step does indeed require lean's <code>Classical.choice</code>. However, it's possible your statement of the axiom of choice is not correct. Can you confirm it looks like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.axiomOfChoice#doc\">docs#Classical.axiomOfChoice</a> ?</p>",
        "id": 566583872,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1767718433
    },
    {
        "content": "<p>indeed, <code>Classical.choice</code> is a stronger version of the axiom of choice called <em>global</em> choice</p>",
        "id": 566583967,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1767718462
    },
    {
        "content": "<p>Yes, what I was trying to prove is essentially the same as <code>Classical.axiomOfChoice</code>.</p>\n<p>But I think it boils down to this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hS</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hS2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\">  </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>being trivial by definition in ZF, but not true in Lean without <code>Classical.choice</code></p>\n<p>right?</p>",
        "id": 566585333,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1767718866
    },
    {
        "content": "<p>Right. Going from the <code>Prop</code> universe (\"there exists a thing\") to the <code>Type</code> universe \"the thing\") is exactly where you have to use <code>Classical.choice</code> in Lean's type theory. Even if you know the thing is unique (\"there exists a unique thing\") you're still in the <code>Prop</code> universe and you can't get out without some magic.</p>",
        "id": 566589777,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1767720441
    },
    {
        "content": "<p>Thanks.</p>\n<p>It is kind of surprising that two theories can be so essentially different in its basics... and still be almost equally valid to build the whole mathematical building on top of them.</p>",
        "id": 566590282,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1767720614
    }
]