[
    {
        "content": "<p>I was looking for small things to do to practice using Mathlib's model theory library, and I realized that (at least to my knowledge) there are no theorems about saturation. Now I am interested in seeing if I can contribute some small theorems about saturation to Mathlib. But before I set my sights on that, I want to make sure I am not duplicating existing work. Here is what I have written so far, it is an implementation of the statement of the theorem \"countably incomplete ultraproducts over structures with countable languages are w_1-saturated\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">FirstOrder</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">CountablyIncompleteUltrafilter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ultrafilter</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">chain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">is_chain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">chain</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">chain</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"n\">chain_in_u</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">chain</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"n\">inter_empty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">chain</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">SatisfiableFormulaChain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Structure</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">chain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"bp\">.</span><span class=\"n\">BoundedFormula</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">is_chain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">⊨</span><span class=\"w\"> </span><span class=\"bp\">∀'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">chain</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">⟹</span><span class=\"w\"> </span><span class=\"n\">chain</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">satisfiable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">⊨</span><span class=\"w\"> </span><span class=\"bp\">∃'</span><span class=\"w\"> </span><span class=\"n\">chain</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ultrafilter</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Structure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)]</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Structure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">Product</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"bp\">.</span><span class=\"n\">Ultraproduct</span><span class=\"bp\">.</span><span class=\"kn\">structure</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ultraproduct_saturation</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">CountablyIncompleteUltrafilter</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">SatisfiableFormulaChain</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">Product</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">Product</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"bp\">.</span><span class=\"n\">BoundedFormula</span><span class=\"bp\">.</span><span class=\"n\">Realize</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">SatisfiableFormulaChain</span><span class=\"bp\">.</span><span class=\"n\">chain</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">Product</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Some notes:</p>\n<ul>\n<li>I am not sure how I would easily go about enumerating every formula with countably many parameters, so I abstracted some of the early steps of the proof to just be structure that is provided to the theorem itself.</li>\n<li>I couldn't find an implementation of kappa-completeness of ultrafilters, so i came up with my own ad-hoc implementation.</li>\n<li>I suspect that some of my code is janky because of the @ sign code smell, but I'm still relatively inexperienced with Lean so I'm not sure how I'd fix this.</li>\n<li>I have not worked towards proving this yet, so I may update this post later with details on that, especially if I somehow bungled something that makes this an untrue theorem as stated.</li>\n</ul>",
        "id": 562219481,
        "sender_full_name": "Keith J. Bauer",
        "timestamp": 1765000381
    },
    {
        "content": "<p>One can describe saturation in terms of all types in languages with additional constants being realized. Realized types are defined in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FirstOrder.Language.Theory.realizedTypes#doc\">docs#FirstOrder.Language.Theory.realizedTypes</a></p>",
        "id": 562265307,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1765054599
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> How would one go about proving that there are countably many formulae in a complete type over a countable language? Does such a theorem have an easy solution via Mathlib?</p>",
        "id": 562355949,
        "sender_full_name": "Keith J. Bauer",
        "timestamp": 1765144279
    },
    {
        "content": "<p>The critical idea is here: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FirstOrder.Language.BoundedFormula.card_le#doc\">docs#FirstOrder.Language.BoundedFormula.card_le</a></p>",
        "id": 562357432,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1765144650
    },
    {
        "content": "<p>You can get countability from a little bit of cardinal arithmetic from there.</p>",
        "id": 562357559,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1765144685
    },
    {
        "content": "<p>Whoa, that's really cool. I blame my unfamiliarity with Lean's cardinality library, but that design choice makes sense.</p>",
        "id": 562357687,
        "sender_full_name": "Keith J. Bauer",
        "timestamp": 1765144716
    },
    {
        "content": "<p>I think it will be good practice for me (in using these types of theorems in Lean) to formalize the saturation of ultraproducts theorem using these library calls.</p>",
        "id": 562357906,
        "sender_full_name": "Keith J. Bauer",
        "timestamp": 1765144771
    },
    {
        "content": "<p>I suppose for completeness (no pun intended), is there a standard way to refer to countably incomplete ultrafilters?</p>",
        "id": 562358312,
        "sender_full_name": "Keith J. Bauer",
        "timestamp": 1765144866
    },
    {
        "content": "<p>are you talking about (the negation of) <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CountableInterFilter#doc\">docs#CountableInterFilter</a></p>",
        "id": 562358555,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765144926
    },
    {
        "content": "<p>Yes! I didn't think to check the Filter library, although I probably would have missed it because I wouldn't have known the right search terms.</p>",
        "id": 562358922,
        "sender_full_name": "Keith J. Bauer",
        "timestamp": 1765145016
    }
]