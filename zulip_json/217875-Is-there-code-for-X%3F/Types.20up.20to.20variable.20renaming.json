[
    {
        "content": "<p>Is there code for determining whether two types are the same (say, up to definitional equality, or maybe even literally) up to renaming of the variables that appear in these types?</p>",
        "id": 509496473,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1743524406
    },
    {
        "content": "<p>Equality of types is not likely to be a concept you want to work with</p>",
        "id": 509497085,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1743524579
    },
    {
        "content": "<p>(This is not for a formalization project).</p>",
        "id": 509498334,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1743524923
    },
    {
        "content": "<p>Maybe this question belongs in <a class=\"stream\" data-stream-id=\"239415\" href=\"/#narrow/channel/239415-metaprogramming-.2F-tactics\">#metaprogramming / tactics</a> ?</p>",
        "id": 509498850,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1743525073
    },
    {
        "content": "<p>Yes, possibly; since there may already exist some code for that (e.g. in Lean.Meta?) I thought I should try here first.</p>",
        "id": 509499546,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1743525270
    },
    {
        "content": "<p>Could you give some examples of interesting pairs with answers of 'yes' and 'no'? There are a few things you could be meaning here, and that would pin it down (and give people some test cases to work toward)</p>",
        "id": 509499905,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743525365
    },
    {
        "content": "<p>The implementation of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.Tactic.guardTarget#doc\">docs#Lean.Parser.Tactic.guardTarget</a> is probably relevant. isn't renaming just α-equivalence?</p>",
        "id": 509500355,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1743525499
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> If I remember correctly, all that means is that it uses <code>==</code>, which ignores binder names; if you check just the de Bruijn indices you get alpha equivalence checking for free.</p>",
        "id": 509505716,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743527280
    },
    {
        "content": "<p>If there were a way to reliably abstract the variables to create lambdas that close them, in some fixed order, that would be a way to check for this kind of alpha equivalence.</p>",
        "id": 509505962,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743527354
    },
    {
        "content": "<p>A reason I'm asking for some positive and negative pairs is that I'd like to see what's special about types vs general expressions.</p>",
        "id": 509506174,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743527415
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Types.20up.20to.20variable.20renaming/near/509498850\">said</a>:</p>\n<blockquote>\n<p>Maybe this question belongs in <a class=\"stream\" data-stream-id=\"239415\" href=\"/#narrow/channel/239415-metaprogramming-.2F-tactics\">#metaprogramming / tactics</a> ?</p>\n</blockquote>\n<p>I'm just suggesting this because which stream you post in influences the default reply that ruben-bot posts <span aria-label=\"robot\" class=\"emoji emoji-1f916\" role=\"img\" title=\"robot\">:robot:</span></p>",
        "id": 509527003,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1743534056
    },
    {
        "content": "<p><span aria-label=\"robot\" class=\"emoji emoji-1f916\" role=\"img\" title=\"robot\">:robot:</span></p>",
        "id": 509528373,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1743534542
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Types.20up.20to.20variable.20renaming/near/509500355\">said</a>:</p>\n<blockquote>\n<p>The implementation of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.Tactic.guardTarget#doc\">docs#Lean.Parser.Tactic.guardTarget</a> is probably relevant. isn't renaming just α-equivalence?</p>\n</blockquote>\n<p>Yes, this is simply <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span>-equivalence. I will try to refine what I really want to achieve, but <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span>-equiv is certainly part of it.</p>",
        "id": 509884259,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1743671533
    },
    {
        "content": "<p>One limitation of <code>#guard_expr e =ₐ e'</code> is that it expects two pure expressions <code>e</code> and <code>e'</code>. Can one use <code>#guard_expr</code> with the outputs of some function (that would take as input the name of a def/theorem and returns its associated expression as output)?</p>",
        "id": 514428898,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1745601956
    },
    {
        "content": "<p>Maybe <code>by_elab</code>?</p>",
        "id": 514429197,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745602054
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Types.20up.20to.20variable.20renaming/near/509506174\">said</a>:</p>\n<blockquote>\n<p>A reason I'm asking for some positive and negative pairs is that I'd like to see what's special about types vs general expressions.</p>\n</blockquote>\n<p>If you imply that I should consider the lambda expression associated with an identifier instead of its type, I think you're right.</p>",
        "id": 514429440,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1745602146
    },
    {
        "content": "<p>Or possibly <code>delta%</code>?</p>",
        "id": 514536444,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1745671925
    },
    {
        "content": "<p><code>by_elab</code> seems to work fine. For instance: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">name1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">name2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">m</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getDeclExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"bp\">.</span><span class=\"n\">value?</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">val</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\">     </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"Declaration {n} has no value (might be opaque or a constant)\"</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"Declaration {n} not found\"</span>\n\n<span class=\"bp\">#</span><span class=\"n\">guard_expr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">by_elab</span><span class=\"w\"> </span><span class=\"n\">getDeclExpr</span><span class=\"w\"> </span><span class=\"ss\">`name1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=ₐ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">by_elab</span><span class=\"w\"> </span><span class=\"n\">getDeclExpr</span><span class=\"w\"> </span><span class=\"ss\">`name2</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 514773341,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1745834949
    }
]