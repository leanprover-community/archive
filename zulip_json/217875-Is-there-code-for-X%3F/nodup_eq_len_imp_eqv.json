[
    {
        "content": "<p>(deleted)</p>",
        "id": 492878298,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1736485939
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 492878337,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1736485987
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 492878540,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1736486068
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 492884301,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1736490162
    },
    {
        "content": "<p>I'm wondering if it should be possible to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">nodup_eq_len_imp_eqv</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">Nodup</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"bp\">.</span><span class=\"n\">Nodup</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>\n<p>using</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">  List.InjOn f xs := f is injective on xs if the restriction of f to xs is injective.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">InjOn</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">x₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">x₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">x₂</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x₂</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x₂</span>\n\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">nodup_eq_len_imp_exists_bijon</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">Nodup</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"bp\">.</span><span class=\"n\">Nodup</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">InjOn</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 492886899,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1736491658
    },
    {
        "content": "<p>I think you want the following steps:</p>\n<ul>\n<li>An embedding <code>{ x : α // P x } ↪ β</code> can be extended to an embedding <code>α ↪ β</code> as long as #α ≤ #β. (A Zorn argument, perhaps already available?)</li>\n<li>Easily from that, an embedding <code>{ x : α // P x } ↪ α</code> can be extended to an autoequivalence <code>α ≃ α</code>.</li>\n<li>Now define <code>f' : { x // x ∈ xs } → α</code> by <code>f' ⟨x, h⟩ := ys[xs.indexOf x]</code>, check that is an embedding using the <code>Nodup</code> hypotheses, and use the general machinery.</li>\n</ul>",
        "id": 493043616,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1736553595
    },
    {
        "content": "<p>Thank you.</p>",
        "id": 493046160,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1736555346
    },
    {
        "content": "<p>This seems relevant: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Cardinal.extend_function#doc\">docs#Cardinal.extend_function</a></p>",
        "id": 493048034,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1736556827
    },
    {
        "content": "<p>Thank you. Unfortunately a lot of this notation and terminology is over my head, and I'm fighting some kind of flu, so I probably can't think clearly enough to reason about it at the moment.</p>",
        "id": 493048643,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1736557272
    },
    {
        "content": "<p>Those definitions are weird. Why do they have <code>Nonempty (X \\equiv Y)</code> hypotheses instead of <code>#X = #Y</code>? It's in a file about cardinals!</p>",
        "id": 493055429,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1736562962
    },
    {
        "content": "<p>Can you do it as a product of transpositions by using induction on the list?</p>",
        "id": 493068576,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1736575782
    },
    {
        "content": "<p>I wonder if there's a way to combine <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Nodup.getEquiv#doc\">docs#List.Nodup.getEquiv</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.subtypeCongr#doc\">docs#Equiv.subtypeCongr</a> here (i.e. constructing <code>{ x // x ∈ xs } ≃ { x // x ∈ ys }</code> with <code>List.Nodup.getEquiv</code> and transitivity and then extending it with an equivalence of non-members)</p>",
        "id": 493071300,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1736578302
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/nodup_eq_len_imp_eqv/near/493055429\">said</a>:</p>\n<blockquote>\n<p>Those definitions are weird. Why do they have <code>Nonempty (X \\equiv Y)</code> hypotheses instead of <code>#X = #Y</code>? It's in a file about cardinals!</p>\n</blockquote>\n<p>That's because <code>X</code> and <code>Y</code> live in different universes, so <code>#X = #Y</code> doesn't typecheck. At least, that's my guess</p>",
        "id": 493072991,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1736580024
    },
    {
        "content": "<p>Ah, okay. I guess with <code>lift</code>s in there it's even uglier.</p>",
        "id": 493083362,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1736589703
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"695266\">Mitchell Lee</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/nodup_eq_len_imp_eqv/near/493068576\">said</a>:</p>\n<blockquote>\n<p>Can you do it as a product of transpositions by using induction on the list?</p>\n</blockquote>\n<p>Perhaps? I have this as proven, but I'm not sure how to go about using it to do so, if this is what I would use</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Injective</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h2_left</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h2_right</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Injective</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 493121152,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1736623166
    },
    {
        "content": "<p>Use <code>Equiv.swap</code> and composition of equivalences, as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">equivOfList</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">equivOfList</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"bp\">;</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">swap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">σ</span>\n</code></pre></div>\n<p>If <code>xs</code> and <code>ys</code> have the same length and no duplicates, then this equivalence satisfies the mapping property that you want. (This is a theorem that needs to be proved, but I suspect it isn't too hard. Note that it is better not to include the <code>DecidableEq α</code> hypothesis in the theorem statement, but instead to synthesize it using the <code>classical</code> tactic.)</p>",
        "id": 493125977,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1736627960
    },
    {
        "content": "<p>I'm not sure I entirely follow the definition of <code>List.equivOfList</code>. Is <code>1</code> like <code>Function.id</code>? What is the <code>*</code>, some kind of composition? What does <code>(Equiv.swap (σ x) y) * σ</code> do?</p>",
        "id": 493127885,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1736629927
    },
    {
        "content": "<p><code>1</code> and <code>*</code> come from the group structure on <code>Equiv.Perm α</code>, where multiplication is given by composition. <code>(Equiv.swap (σ x) y) * σ</code> says \"the composition of <code>σ</code> followed by the equivalence that swaps <code>σ x</code> with <code>y</code> and leaves everything else unchanged\"</p>",
        "id": 493130333,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1736632332
    },
    {
        "content": "<p>So if <code>xs</code> and <code>ys</code> are both <code>nil</code>, then the resulting equiv function takes every value to itself? And if <code>xs = [1]</code> and <code>ys = [3]</code> then the result is a function that takes 1 to 3 and 3 to 1 and everything else to itself?</p>",
        "id": 493131036,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1736633042
    },
    {
        "content": "<p>But then, I guess I don't see where it changes the <code>y</code>, ie, sets 3 -&gt; 1? That is, why is it not <code>(Equiv.swap (σ x) (σ y)) * σ</code>?</p>",
        "id": 493131369,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1736633350
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/nodup_eq_len_imp_eqv/near/493083362\">said</a>:</p>\n<blockquote>\n<p>Ah, okay. I guess with <code>lift</code>s in there it's even uglier.</p>\n</blockquote>\n<p>I think in files about cardinals we tend to prefer <code>lift</code>, and let users translate to the <code>Nonempty</code> spelling when they need it</p>",
        "id": 493132272,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736634265
    },
    {
        "content": "<p>Any <code>Cardinal</code> enthusiasts want to rewrite <code>Cardinal.extend_function</code> to follow that rule (which seems good to me)?</p>",
        "id": 493141800,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1736643863
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/nodup_eq_len_imp_eqv/near/493055429\">said</a>:</p>\n<blockquote>\n<p>Those definitions are weird. Why do they have <code>Nonempty (X \\equiv Y)</code> hypotheses instead of <code>#X = #Y</code>? It's in a file about cardinals!</p>\n</blockquote>\n<p>I imagine the reasoning is that these can be types in distinct universes.</p>",
        "id": 495429871,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737612060
    },
    {
        "content": "<p>Oh oops sorry, just noticed the reply.</p>",
        "id": 495429914,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737612076
    },
    {
        "content": "<p>Yeah, I can do that refactor.</p>",
        "id": 495429927,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737612083
    },
    {
        "content": "<p>Do note I made a thread explaining an idea for an alternate, simpler way of writing ordinal and cardinal equalities between different universes: <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Universe-heterogeneous.20ordinal.20and.20cardinal.20relations\">#mathlib4 &gt; Universe-heterogeneous ordinal and cardinal relations</a></p>",
        "id": 495434365,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737614845
    }
]