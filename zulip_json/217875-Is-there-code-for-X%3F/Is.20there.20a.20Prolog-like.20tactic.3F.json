[
    {
        "content": "<p>Consider the prolog example from Wikipedia:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">mother_child</span><span class=\"o\">(</span><span class=\"n\">trude</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sally</span><span class=\"o\">)</span><span class=\"bp\">.</span>\n\n<span class=\"n\">father_child</span><span class=\"o\">(</span><span class=\"n\">tom</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sally</span><span class=\"o\">)</span><span class=\"bp\">.</span>\n<span class=\"n\">father_child</span><span class=\"o\">(</span><span class=\"n\">tom</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">erica</span><span class=\"o\">)</span><span class=\"bp\">.</span>\n<span class=\"n\">father_child</span><span class=\"o\">(</span><span class=\"n\">mike</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tom</span><span class=\"o\">)</span><span class=\"bp\">.</span>\n\n<span class=\"n\">sibling</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\">      </span><span class=\"o\">:</span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">parent_child</span><span class=\"o\">(</span><span class=\"n\">Z</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">parent_child</span><span class=\"o\">(</span><span class=\"n\">Z</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"bp\">.</span>\n\n<span class=\"n\">parent_child</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">father_child</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"bp\">.</span>\n<span class=\"n\">parent_child</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">mother_child</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>Now, in Prolog one would write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">?-</span><span class=\"w\"> </span><span class=\"n\">siblings</span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>And it would give examples of pairs of siblings. </p>\n<p>It is possible to encode the above as Prop statements in Lean. In Lean the equivalent to get the answer would be instead  constructing a proof of the existence of a pair:</p>\n<p><code>theorem T1: ∃ x, y: Siblings(x,y) := by....</code></p>\n<p>Now if all the previous propositions are \"Horn Clauses\", then this is fully provable using a Prolog style search. e.g. if there was a tactic called prolog:</p>\n<p><code>theorem T1: ∃ x, y: Siblings(x,y) := by prolog</code></p>\n<p>And then providing that works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">T1</span>\n</code></pre></div>\n<p>Should be able to reveal which values it chose as witnesses for x and y.</p>\n<p>So, in short, is there a prolog-like tactic that can do all this automatically? (I have played around with Prolog interpreters in C# and it can be done in around 200 lines - probably much shorter). Though not sure how fast it would be with Mathlib. (It would only have to look at horne clauses and ignore the rest).</p>\n<p>If anyone is able to convert the Wikipedia example into lean and show a tactic automatically finding a pair of siblings that would be nice. Also, it would just be nice to be able to use Lean as an alternative to Prolog.</p>",
        "id": 571157525,
        "sender_full_name": "Mr Proof",
        "timestamp": 1769829151
    },
    {
        "content": "<p>How do you want to encode the inputs? GIve an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, please.</p>",
        "id": 571159448,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769831344
    },
    {
        "content": "<p>I suppose like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Define the type of people</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Person</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Alice</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Bob</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Carol</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Dan</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Eve</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Frank</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Person</span>\n\n<span class=\"c1\">-- Define relations</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Person</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Person</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Siblings</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Person</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Person</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Horn-clause style axiom:</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">siblings_from_parent</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Person</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Siblings</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"c1\">-- Some facts</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">parent_alice_bob</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">Alice</span><span class=\"w\"> </span><span class=\"n\">Bob</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">parent_alice_carol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">Alice</span><span class=\"w\"> </span><span class=\"n\">Carol</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">parent_dan_eve</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">Dan</span><span class=\"w\"> </span><span class=\"n\">Eve</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">parent_dan_frank</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">Dan</span><span class=\"w\"> </span><span class=\"n\">Frank</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Siblings</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"o\">[[[[</span><span class=\"n\">Would</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">nice</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">prolog</span><span class=\"bp\">-</span><span class=\"n\">like</span><span class=\"w\"> </span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">solve</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">]]]</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">T1</span>\n</code></pre></div>",
        "id": 571159756,
        "sender_full_name": "Mr Proof",
        "timestamp": 1769831624
    },
    {
        "content": "<p>Your axioms imply <code>False</code>, because they generalize over <code>Parent</code> and <code>Siblings</code>.</p>",
        "id": 571163031,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769834951
    },
    {
        "content": "<p>OK How about this (although it's not really the point of the question):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Define the type of people</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Person</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Alice</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Bob</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Carol</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Dan</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Eve</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Frank</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Person</span>\n\n<span class=\"c1\">-- Parent relation</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Person</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Person</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"c1\">-- Define siblings (same parent, distinct people)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Siblings</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Person</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"c1\">-- Facts</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">parent_alice_bob</span><span class=\"w\">   </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">Alice</span><span class=\"w\"> </span><span class=\"n\">Bob</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">parent_alice_carol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">Alice</span><span class=\"w\"> </span><span class=\"n\">Carol</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">parent_dan_eve</span><span class=\"w\">     </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">Dan</span><span class=\"w\"> </span><span class=\"n\">Eve</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">parent_dan_frank</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">Dan</span><span class=\"w\"> </span><span class=\"n\">Frank</span>\n\n<span class=\"c1\">-- Existence of siblings</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Siblings</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"bp\">?????</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">T1</span>\n</code></pre></div>\n<p>I take it there is no prolog-style tactic as yet. When I got time I guess I could try making one.</p>",
        "id": 571163357,
        "sender_full_name": "Mr Proof",
        "timestamp": 1769835311
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span>, I assume grind can't be told to try instantiating data constructors?</p>",
        "id": 571169201,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769841092
    },
    {
        "content": "<p>This works with <code>aesop</code></p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Aesop</span>\n\n<span class=\"c1\">-- Define the type of people</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Person</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Alice</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Bob</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Carol</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Dan</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Eve</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Frank</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Person</span>\n\n<span class=\"c1\">-- Parent relation</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Person</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Person</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"c1\">-- Define siblings (same parent, distinct people)</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Siblings</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Person</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"c1\">-- Facts</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">parent_alice_bob</span><span class=\"w\">   </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">Alice</span><span class=\"w\"> </span><span class=\"n\">Bob</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">parent_alice_carol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">Alice</span><span class=\"w\"> </span><span class=\"n\">Carol</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">parent_dan_eve</span><span class=\"w\">     </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">Dan</span><span class=\"w\"> </span><span class=\"n\">Eve</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">parent_dan_frank</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">Dan</span><span class=\"w\"> </span><span class=\"n\">Frank</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Tactic</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"n\">unsafe</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">aesopExistsIntroA</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TacticM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">evalTactic</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">Alice</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">)</span>\n<span class=\"kd\">@[</span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"n\">unsafe</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">aesopExistsIntroB</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TacticM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">evalTactic</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">Bob</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">)</span>\n<span class=\"kd\">@[</span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"n\">unsafe</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">aesopExistsIntroC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TacticM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">evalTactic</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">Carol</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">)</span>\n<span class=\"kd\">@[</span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"n\">unsafe</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">aesopExistsIntroD</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TacticM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">evalTactic</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">Dan</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">)</span>\n<span class=\"kd\">@[</span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"n\">unsafe</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">aesopExistsIntroE</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TacticM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">evalTactic</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">Eve</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">)</span>\n<span class=\"kd\">@[</span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"n\">unsafe</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">aesopExistsIntroF</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TacticM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">evalTactic</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">Frank</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Existence of siblings</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Siblings</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">config</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">maxRuleApplications</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1000</span><span class=\"o\">})</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">T1</span>\n</code></pre></div>\n</div></div>",
        "id": 571169781,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769841803
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> can advise on a shorter way to write that</p>",
        "id": 571169811,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769841830
    },
    {
        "content": "<p>That's great! The theorem that came out was:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Siblings</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"n\">id</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">Frank</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">Eve</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">mpr</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">id</span>\n<span class=\"w\">          </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">Exists</span>\n<span class=\"w\">            </span><span class=\"o\">(</span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">              </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">And</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">Frank</span><span class=\"o\">))</span>\n<span class=\"w\">                </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n<span class=\"w\">                  </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">And</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">Eve</span><span class=\"o\">))</span>\n<span class=\"w\">                    </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">Not</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eq_false'</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">noConfusion_of_Nat</span><span class=\"w\"> </span><span class=\"n\">Person</span><span class=\"bp\">.</span><span class=\"n\">ctorIdx</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)))</span>\n<span class=\"w\">                      </span><span class=\"n\">not_false_eq_true</span><span class=\"o\">))</span>\n<span class=\"w\">                  </span><span class=\"o\">(</span><span class=\"n\">and_true</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">Eve</span><span class=\"o\">))))))</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">Dan</span>\n<span class=\"w\">          </span><span class=\"o\">(</span><span class=\"n\">of_eq_true</span>\n<span class=\"w\">            </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">congr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"w\"> </span><span class=\"n\">parent_dan_frank</span><span class=\"bp\">._</span><span class=\"n\">simp_2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">parent_dan_eve</span><span class=\"bp\">._</span><span class=\"n\">simp_2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">and_self</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">)))))))</span>\n</code></pre></div>\n<p>Which translated means \"Frank and Eve are siblings (whose parent is Dan)\".</p>\n<p>Just a note, Prolog does it using depth-first-search, matching and backtracking. </p>\n<p>If I were to design a tactic I would call it \"prolog\" and have it just do whatever prolog can do using the same methods. </p>\n<p>Probably not a high priority but being able to do the equivalent of what Prolog can do seems like maybe a useful thing? IDK, it's kind of a fun gimmick anyway. </p>\n<p>Although also, it could be a good benchmark to test tactics on databases of prolog examples.<span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 571170010,
        "sender_full_name": "Mr Proof",
        "timestamp": 1769842076
    },
    {
        "content": "<p>Actually you can get there much faster with your original code plus</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Siblings</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"n\">safe</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">parent_alice_bob</span><span class=\"w\"> </span><span class=\"n\">parent_alice_carol</span><span class=\"w\"> </span><span class=\"n\">parent_dan_eve</span><span class=\"w\"> </span><span class=\"n\">parent_dan_frank</span>\n\n<span class=\"c1\">-- Existence of siblings</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Siblings</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">aesop</span>\n</code></pre></div>",
        "id": 571170678,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769842865
    },
    {
        "content": "<p>Yes that gives a shorter proof too:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Siblings</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"n\">id</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">Bob</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">Carol</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">Alice</span>\n<span class=\"w\">        </span><span class=\"bp\">⟨</span><span class=\"n\">parent_alice_bob</span><span class=\"o\">,</span>\n<span class=\"w\">          </span><span class=\"bp\">⟨</span><span class=\"n\">parent_alice_carol</span><span class=\"o\">,</span>\n<span class=\"w\">            </span><span class=\"n\">of_eq_true</span>\n<span class=\"w\">              </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">Not</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eq_false'</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">noConfusion_of_Nat</span><span class=\"w\"> </span><span class=\"n\">Person</span><span class=\"bp\">.</span><span class=\"n\">ctorIdx</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)))</span>\n<span class=\"w\">                </span><span class=\"n\">not_false_eq_true</span><span class=\"o\">)</span><span class=\"bp\">⟩⟩</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>This time saying \"Bob and Carol are siblings (with parent Alice)\"</p>\n<p>Actually, this makes me think it might be quite easy to write a small translation app wihch translates basic Prolog files into Lean. (There's probably a good use for this, but I'm not sure what it is yet!)</p>\n<p>It would tell you if the expression was satisfiable. It might be a bit trickier to extract the witnesses from the proof. It might not always be the first few Exist terms.</p>\n<p>But I would have to try it on some more advanced examples first.</p>\n<p>Also on the web editor [aesop safe] seemed to work without \"apply\".</p>\n<p>(BTW my reasons for wanting this is I am making a puzzle solving app, which I needed the power of Type Theory and Prolog combined. Type Theory to \"prove\" when you get stuck in a dead end. And Prolog to search for solutions so I was investigating if Lean could do both. It might not be the correct solution but it is interesting what it can do).</p>",
        "id": 571171194,
        "sender_full_name": "Mr Proof",
        "timestamp": 1769843360
    },
    {
        "content": "<p>I suspect you can also do the same with more light weight tactics such as <code>apply_rules</code> or <code>solve_by_elim</code>.</p>\n<p>(This is not what <code>grind</code> intends to cover, at least for now!)</p>",
        "id": 571174910,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1769847132
    },
    {
        "content": "<p>Yes I wouldn't expect grind to do that.</p>\n<p>I have seen some <a href=\"https://github.com/siddhartha-gadgil/Saturn\">SAT</a> solvers and <a href=\"https://arxiv.org/html/2505.15796v1\">SMT</a> solvers implemented in Lean. (Does Lean/grind make use any of the fast SAT solvers under the hood like Gecode, OR-tools or Z3?)</p>\n<p>So it should be possible to solve simple classic-AI puzzles such as <a href=\"https://en.wikipedia.org/wiki/Eight_queens_puzzle\">8-queens</a> or <a href=\"https://en.wikipedia.org/wiki/Knight%27s_tour\">knights tour</a> , the <a href=\"https://en.wikipedia.org/wiki/Zebra_Puzzle\">zebra puzzle</a>, <a href=\"https://en.wikipedia.org/wiki/15_puzzle\">sliding 15</a>, or even sudokus, and rubiks cube (with IDA* search) with a single tactic one day. So in my humble opinion these classic AI puzzles would make an interesting benchmark for tactic efficiency.</p>\n<p>To me this seems a better way for an AI to solve problems as an alternative to the current paradigm which seems to be for an LLM to try to invent the solution and for Lean to check it. The more Lean can solve using it's own search routines the better, I believe.</p>\n<p><a href=\"/user_uploads/3121/gzfN4wWaUoUSAIddvPg16fK5/Knights-Tour-Animation1.gif\">Knights-Tour-Animation1.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/gzfN4wWaUoUSAIddvPg16fK5/Knights-Tour-Animation1.gif\" title=\"Knights-Tour-Animation1.gif\"><img data-animated=\"true\" data-original-content-type=\"image/gif\" data-original-dimensions=\"220x220\" src=\"/user_uploads/thumbnail/3121/gzfN4wWaUoUSAIddvPg16fK5/Knights-Tour-Animation1.gif/840x560-anim.webp\"></a></div><p>Thats just my 2 cents. Appreciate all the hard work. <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 571224419,
        "sender_full_name": "Mr Proof",
        "timestamp": 1769887305
    },
    {
        "content": "<p>I believe there is <code>bv_decide</code>, which I think uses a SAT solver, although it relies upon <code>Lean.ofReduceBool</code> and <code>Lean.trustCompiler</code>.</p>",
        "id": 571827913,
        "sender_full_name": "Niels Voss",
        "timestamp": 1770187692
    },
    {
        "content": "<p><code>bv_decide</code> is capable of solving these when encoded in Lean yes. There is also no need to trust <code>ofReduceBool</code> in order to have <code>bv_decide</code> solve them. You just state the problem as having no solution, it produces a counter example and then you instantiate that counterexample as a solution (which is usually trivial, at least with NP stuff)</p>",
        "id": 571891449,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1770206906
    },
    {
        "content": "<p>That's great. I will watch your video on it to find out more :) <br>\n<a href=\"https://www.youtube.com/watch?v=Q1LDavBJ94A&amp;t=85s\">https://www.youtube.com/watch?v=Q1LDavBJ94A&amp;t=85s</a><br>\nBTW, if you would like an idea for a new video/article idea then solving classic logic problems/games using the by_decide (or other) tactic in one go would be really interesting.  <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span><br>\nI have been deep-diving into constraint solving and search recently, and have learnt lots of interesting things like CDCL, the \"all-different\" constraint algorithms, IDA* search, <a href=\"https://arxiv.org/pdf/1110.4076\">LRTS search</a>. It's like the past 25 years of people have been developing algorithms that are perfect to use as tactics. </p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"Q1LDavBJ94A\" href=\"https://www.youtube.com/watch?v=Q1LDavBJ94A&amp;t=85s\"><img src=\"https://uploads.zulipusercontent.net/3c12982a3b3ce8192de56bd5ec798c621239e6f9/68747470733a2f2f692e7974696d672e636f6d2f76692f51314c446176424a3934412f6d7164656661756c742e6a7067\"></a></div><p>Unfortunately there is not yet a language (I think) that combines all these search algorithms AND backs it up with a proof. So it's interesting to see how Lean develops in this area.</p>",
        "id": 572575555,
        "sender_full_name": "Mr Proof",
        "timestamp": 1770508514
    }
]