[
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/SimpleGraph/Bipartite.html#TODO\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/SimpleGraph/Bipartite.html#TODO</a></p>\n<p>I've started working on this as a project to learn Lean. I have proofs of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">IsBipartite</span><span class=\"bp\">.</span><span class=\"n\">oddCycleFree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">IsBipartite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cycleGraph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">Free</span><span class=\"w\"> </span><span class=\"n\">G</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">IsBipartite</span><span class=\"bp\">.</span><span class=\"n\">of_eachCycleEven</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">IsCycle</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"bp\">.</span><span class=\"n\">bodd</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hCon</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Connected</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">IsBipartite</span>\n</code></pre></div>\n<p>I'm happy with what I learned so far. I can work further on this to contribute to mathlib. Do you think this would be valuable for mathlib? Also, maybe someone is already working on this?</p>",
        "id": 536718097,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1756443365
    },
    {
        "content": "<p>There's slight discussion of this here: <a href=\"https://github.com/leanprover-community/mathlib4/pull/25837#discussion_r2285926375\">https://github.com/leanprover-community/mathlib4/pull/25837#discussion_r2285926375</a> so perhaps coordinating with <span class=\"user-mention\" data-user-id=\"506168\">@John Talbot</span> would be sensible.</p>",
        "id": 536756089,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1756461715
    },
    {
        "content": "<p>This sounds interesting! </p>\n<p>We currently only have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">two_colorable_iff_forall_loop_even</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Colorable</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n</code></pre></div>\n<p>We really want something like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">two_colorable_iff_forall_isCycle_even</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Colorable</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">IsCycle</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n</code></pre></div>\n<p>I have a proof of this here : <a href=\"https://github.com/jt496/mathlib4/blob/walks/Mathlib/Combinatorics/SimpleGraph/OddCycles.lean\">https://github.com/jt496/mathlib4/blob/walks/Mathlib/Combinatorics/SimpleGraph/OddCycles.lean</a><br>\nbut this is rather long since it goes via the following result (which says that any odd length closed walk contains an odd length cycle as a subwalk): </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">exists_odd_cycle_subwalk</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ho</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Odd</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">IsCycle</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Odd</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\">  </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">&lt;+</span><span class=\"w\"> </span><span class=\"n\">w</span>\n</code></pre></div>\n<p>I'd be very interested in seeing your version and hopefully we can get something suitable for mathlib!</p>",
        "id": 536810721,
        "sender_full_name": "John Talbot",
        "timestamp": 1756480573
    },
    {
        "content": "<p>First proof is actually pretty simple.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span>\n\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Colorable</span><span class=\"bp\">.</span><span class=\"n\">of_hom</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">G'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G'</span><span class=\"bp\">.</span><span class=\"n\">Colorable</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Colorable</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">toColoring</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber_mono_of_hom</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V'</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">G'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">G'</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">chromaticNumber_le_of_forall_imp</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Colorable</span><span class=\"bp\">.</span><span class=\"n\">of_hom</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber_mono_subgraph</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V'</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⊑</span><span class=\"w\"> </span><span class=\"n\">G'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">G'</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">chromaticNumber_mono_of_hom</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"bp\">.</span><span class=\"n\">toHom</span>\n\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">IsBipartite</span><span class=\"bp\">.</span><span class=\"n\">oddCycleFree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">IsBipartite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cycleGraph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">Free</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">hC</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cycleGraph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">symm</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">chromaticNumber_cycleGraph_of_odd</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">omega</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"bp\">.</span><span class=\"n\">add_odd</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">even_two_mul</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">odd_iff</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">cycleGraph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">chromaticNumber_mono_subgraph</span><span class=\"w\"> </span><span class=\"n\">hC</span>\n<span class=\"w\">    </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber_le</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">coe_le_coe</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"n\">contradiction</span>\n</code></pre></div>\n<p>If we want to relate cycleGraph with cycles in a graph we would probably need some lemma about isomorphisms of cycleGraph with subgraphs generated by support of cycles.</p>\n<p>My second proof also has the same lemma as yours, but it's only one implication and only for connected graphs, so it seems like your work is more advanced. I'll put it here if you want to check it out <a href=\"https://live.lean-lang.org/#codez=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\">live.lean-lang.org</a>.</p>\n<p>I've used <code>Nat.bodd</code> instead of <code>Odd/Even</code>, because it has more useful @simp lemmas so it was easier to work with. It might be also worthwhile to look into this and and some more @simp lemmas for Nat, or more generally structures where <code>Odd a XOR Even a</code> is true.</p>\n<p>There's <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/SimpleGraph/Coloring.html#SimpleGraph.Colorable.of_embedding\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/SimpleGraph/Coloring.html#SimpleGraph.Colorable.of_embedding</a> in mathlib, but embedding is an unnecessary assumption there. The same proofs works for just any homomorphism.</p>\n<p>I was thinking, that maybe it would be useful to abstract away induction principle I've used in my proof of <code>odd_cycle_of_odd_walk</code>. This would look something like that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"bp\">.</span><span class=\"n\">bypassRec</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">((</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">IsPath</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n\n<span class=\"w\">  </span><span class=\"o\">({</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pref</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mid</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">suf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"n\">pref</span><span class=\"bp\">.</span><span class=\"n\">IsPath</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mid</span><span class=\"bp\">.</span><span class=\"n\">IsCycle</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">w'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">w'</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">mid</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">toWalk</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pref</span><span class=\"bp\">.</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">suf</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">pref</span><span class=\"bp\">.</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">mid</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">suf</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div>\n<p>This induction principle might potentially be useful for other proofs about subwalks.</p>",
        "id": 536817520,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1756482645
    },
    {
        "content": "<p><code>SimpleGraph.Walk.cons_isCycle_of_path_length_ne_1</code> might be an useful addition to mathlib maybe? I think it has much simpler assumption than <code>SimpleGraph.Walk.cons_isCycle_iff</code>.</p>",
        "id": 536818253,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1756482860
    },
    {
        "content": "<p>Oh, homOfConnectedComponents from the linked PR was exactly what I was missing to get my proof to work for non connected graphs. :D</p>",
        "id": 536822840,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1756484346
    },
    {
        "content": "<blockquote>\n<p>My second proof also has the same lemma as yours, but it's only one implication and only for connected graphs, so it seems like your work is more advanced. I'll put it here if you want to check it out <a href=\"http://live.lean-lang.org\">live.lean-lang.org</a>.</p>\n</blockquote>\n<p>This looks really nice! In particular <code>odd_cycle_of_odd_walk_step</code> looks like a great way to get an odd length cycle from an odd length closed walk.</p>\n<p>There is plenty from here that would be great for mathlib so please go ahead and open a PR!</p>\n<p>You could also start a new thread in <a href=\"#narrow/channel/252551-graph-theory\">#narrow/channel/252551-graph-theory</a> where other people interested in graph theory will see it.</p>",
        "id": 537048797,
        "sender_full_name": "John Talbot",
        "timestamp": 1756712151
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"933054\">@Snir Broshi</span> I will answer your question here.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/252551-graph-theory/topic/How.20to.20return.20Walk/near/555017212\">said</a>:</p>\n<blockquote>\n<p>I'm interested to learn how you managed to get an odd cycle from an odd walk, can you share the body of that function? This might enhance <a href=\"https://github.com/leanprover-community/mathlib4/pull/31217\">#31217</a></p>\n</blockquote>\n<p>Here's the implementation: <a href=\"https://live.lean-lang.org/#codez=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\">live.lean-lang.org</a><br>\nIt's implemented by following the walk, until first repetition of a vertex. This gives either a cycle, or a <code>A -&gt; B -&gt; A</code> walk. If it's an odd cycle, then we get an odd cycle, otherwise it has even length, we can recurse on the walk with the repetition bypassed, and the length of the whole walk is still kept odd. At some point we must end up with odd length cycle, because <code>.nil</code> has even length.</p>\n<p>If you try to apply similar algorithm to any closed walk, to get any cycle, the problem that arises is that we could always end up with <code>A -&gt; B -&gt; A</code> case. I think that the exact condition for when it is possible to extract cycle from closed walk isn't easy to formulate. E.g., you can't extract a cycle from such a walk: <code>A -&gt; B -&gt; C -&gt; B -&gt; C -&gt; D -&gt; C -&gt; E -&gt; F -&gt; E -&gt; C -&gt; B -&gt; A</code>. I think <code>IsTrail</code> is a good, simple condition. Odd length is another. Maybe another simple condition, weaker then <code>IsTrail</code>, is to require that the walk does not contain a back-and-forth <code>A -&gt; B -&gt; A</code> subwalk (this would require implementing similar recursive algorithm, the implementation from <a href=\"https://github.com/leanprover-community/mathlib4/pull/31217\">#31217</a> won't work).</p>",
        "id": 555369802,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1763043965
    },
    {
        "content": "<p>Relevant: <a href=\"https://github.com/leanprover-community/mathlib4/pull/32185\">#32185</a><br>\nThis proves <code>IsTree → IsBipartite</code>, and can probably be extended to <code>IsAcyclic → IsBipartite</code> by coloring each connected component separately</p>",
        "id": 560814383,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1764344789
    },
    {
        "content": "<p>Noting the graph theory progress, and in particular results about trees, I can't resist suggesting that someone consider classifying the graphs underlying Dynkin diagrams. It's a valuable concrete result and would validate the general theory. Furthermore, Mathlib already knows that these diagrams classify root systems: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RootPairing.Base.equivOfCartanMatrixEq#doc\">docs#RootPairing.Base.equivOfCartanMatrixEq</a></p>",
        "id": 560838125,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1764353680
    },
    {
        "content": "<p>Do you need multiple edges between vertices? Because then mathlib has almost no theory established at all.</p>",
        "id": 560849451,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1764360445
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/bipartite.20iff.20does.20not.20contain.20an.20odd.20cycle/near/560814383\">said</a>:</p>\n<blockquote>\n<p>Relevant: <a href=\"https://github.com/leanprover-community/mathlib4/pull/32185\">#32185</a><br>\nThis proves <code>IsTree → IsBipartite</code>, and can probably be extended to <code>IsAcyclic → IsBipartite</code> by coloring each connected component separately</p>\n</blockquote>\n<p>Ah, yes, when I started writing my proof, I believed that proof via trees would be simpler, but mathlib didn't have theory about trees at that moment.</p>",
        "id": 560880267,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764390027
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/bipartite.20iff.20does.20not.20contain.20an.20odd.20cycle/near/560814383\">said</a>:</p>\n<blockquote>\n<p>Relevant: <a href=\"https://github.com/leanprover-community/mathlib4/pull/32185\">#32185</a><br>\nThis proves <code>IsTree → IsBipartite</code>, and can probably be extended to <code>IsAcyclic → IsBipartite</code> by coloring each connected component separately</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/32568\">#32568</a> extends it to <code>IsAcyclic → IsBipartite</code></p>",
        "id": 562377049,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1765159374
    },
    {
        "content": "<p>I believe <code>IsAcyclic.dist_ne_of_adj</code> characterizes graphs without odd cycles. Does anyone have any ideas for proving the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">isBipartite_iff_dist_ne</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">IsBipartite</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Reachable</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 562377356,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1765159697
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/bipartite.20iff.20does.20not.20contain.20an.20odd.20cycle/near/562377356\">said</a>:</p>\n<blockquote>\n<p>I believe <code>IsAcyclic.dist_ne_of_adj</code> characterizes graphs without odd cycle. Does anyone have any ideas for proving the following?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">isBipartite_iff_dist_ne</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">IsBipartite</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Reachable</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I think that right to left implication is almost the same proof as <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/SimpleGraph/ConcreteColorings.html#SimpleGraph.two_colorable_iff_forall_loop_even\">SimpleGraph.two_colorable_iff_forall_loop_even</a>. You create bi-coloring for a connected component, by picking any vertex <code>r</code> in it, and taking <code>dist r v % 2</code> as a color. You would use <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/SimpleGraph/Metric.html#SimpleGraph.Connected.diff_dist_adj\">SimpleGraph.Connected.diff_dist_adj</a> combined with assumption to prove that colors are different.</p>",
        "id": 562381112,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765163794
    },
    {
        "content": "<p>And for left-to-right implication you can prove <code>(∀ (u : α) (w : G.Walk u u), Even w.length) → ∀ u v w, G.Adj v w → G.Reachable u v → G.dist u v ≠ G.dist u w</code>. Assume <code>dist u v = dist u w</code>. Then, you get odd closed walk <code>u ~&gt; v -&gt; w ~&gt; u</code>, which is in contradiction with assumption about even. Well, almost, last time I've tried using Even/Odd I noticed lack of Even iff not Odd lemma for Nat.</p>",
        "id": 562381371,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765164158
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"933054\">@Snir Broshi</span>  I think, it's more like this characterizes graphs without odd closed walk, rather than odd cycle (although, the two are equivalent).</p>",
        "id": 562381494,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765164312
    },
    {
        "content": "<p>Do we have some lemmas about spanning tree / BFS trees in mathlib now? A tree, rooted in a given vertex <code>r</code>, where <code>dist r u</code> is the same in the tree as in the original graph for every <code>u</code>. And some lemmas about least common ancestor. Because I think this would make for a much simpler proof of bipartite iff no odd cycles than what I currently have.</p>",
        "id": 562539317,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765220413
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/bipartite.20iff.20does.20not.20contain.20an.20odd.20cycle/near/562539317\">said</a>:</p>\n<blockquote>\n<p>Do we have some lemmas about spanning tree / BFS trees in mathlib now? A tree, rooted in a given vertex <code>r</code>, where <code>dist r u</code> is the same in the tree as in the original graph for every <code>u</code>. And some lemmas about least common ancestor. Because I think this would make for a much simpler proof of bipartite iff no odd cycles than what I currently have.</p>\n</blockquote>\n<p>Not sure if that's what you're looking for but <a href=\"https://github.com/leanprover-community/mathlib4/pull/32041\">#32041</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/32043\">#32043</a> have some results about spanning trees/forests (maximal acyclic graphs contained in another graph)</p>",
        "id": 562540826,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1765221074
    },
    {
        "content": "<p><a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Formalizing.20Graph.20Theory.20-.20The.20Odd.20Cycle.20Theorem.20in.20Lean/with/565049079\">#mathlib4 &gt; Formalizing Graph Theory - The Odd Cycle Theorem in Lean</a></p>",
        "id": 565049103,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766426515
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"870257\">@Jakub Nowak</span> refer to two lemma helps here:<br>\n<a href=\"/user_uploads/3121/zUG7Eu3Vfwyux4dTb5SxnkOW/PastedText.txt\">dist_eq_length_takeUntil and length_dropUntil_eq_dist_sub.txt</a></p>",
        "id": 565095054,
        "sender_full_name": "Nick Adfor",
        "timestamp": 1766461712
    }
]