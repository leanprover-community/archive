[
    {
        "content": "<p>Is there code for Aut(S_n) ≃ Inn(S_n) when n != 2 and n != 6? <a href=\"https://en.wikipedia.org/wiki/Automorphisms_of_the_symmetric_and_alternating_groups\">ref</a>. Thank you!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">neq2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">neq6</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MulAut</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MulAut</span><span class=\"bp\">.</span><span class=\"n\">conj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 512454480,
        "sender_full_name": "Alissa Tung",
        "timestamp": 1744774813
    },
    {
        "content": "<p>I do not know if there is code for this, but I do not think that you need to exclude the <code>n = 2</code> case.</p>",
        "id": 512456891,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1744776232
    },
    {
        "content": "<p>Or is there any way that I can compute the card of MulAut S₄?  If I know the card of MulAut S₄, then I can prove the <code>MulAut.conj</code> at this situation is surjective, then <code>MonoidHom.range_eq_top.mpr</code> applies.</p>",
        "id": 512458745,
        "sender_full_name": "Alissa Tung",
        "timestamp": 1744777378
    },
    {
        "content": "<p><code>MulAut (Equiv.Perm (Fin 4))</code> has a <code>Fintype</code> instance, so in theory the cardinality is computable via <code>Fintype.card</code>, but I don't know how well it works</p>",
        "id": 512464393,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1744780809
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Aut.28S_n.29.20.E2.89.83.20Inn.28S_n.29.20when.20n.20!.3D.202.20and.20n.20!.3D.206/near/512464393\">发言道</a>：</p>\n<blockquote>\n<p><code>MulAut (Equiv.Perm (Fin 4))</code> has a <code>Fintype</code> instance, so in theory the cardinality is computable via <code>Fintype.card</code>, but I don't know how well it works</p>\n</blockquote>\n<p>Thank you, sadly this only works for <code>n &lt;= 3</code>. Lean would terminate with SOF when n &gt; 3</p>",
        "id": 512465054,
        "sender_full_name": "Alissa Tung",
        "timestamp": 1744781204
    },
    {
        "content": "<p>I think it goes through the equivalences one by one and checks if they preserve multiplication, so that's 24! equivalences to check... not surprising that it doesn't work, alas</p>",
        "id": 512465112,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1744781239
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Aut.28S_n.29.20.E2.89.83.20Inn.28S_n.29.20when.20n.20!.3D.202.20and.20n.20!.3D.206/near/512465112\">said</a>:</p>\n<blockquote>\n<p>I think it goes through the equivalences one by one and checks if they preserve multiplication, so that's 24! equivalences to check... not surprising that it doesn't work, alas</p>\n</blockquote>\n<p>I think that could be improved</p>",
        "id": 512525080,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744801620
    },
    {
        "content": "<p>I've heard that <code>Fintype</code> is the worst of all worlds: it's constructive finiteness so can be prone to diamonds, but it's apparently also highly inefficient computationally. So it might not be worth working on, a better question might be how to better model constructive finiteness.</p>",
        "id": 512562795,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744812449
    },
    {
        "content": "<p>I doubt that's what's going on here - this is more like this particular Decidable instance and this particular Fintype instance are inefficient. But also, as you know, my experience is that Fintype works very well computationally and classically!</p>",
        "id": 512565421,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1744813135
    },
    {
        "content": "<p>To improve this instance I need a beter algorithm. Does anyone have any ideas (maybe something with the order of the elements)?</p>",
        "id": 512569347,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744814065
    },
    {
        "content": "<p>You should look at what GAP does, this is an open source computational group theory package</p>",
        "id": 512569587,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744814138
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Aut.28S_n.29.20.E2.89.83.20Inn.28S_n.29.20when.20n.20!.3D.202.20and.20n.20!.3D.206/near/512569347\">said</a>:</p>\n<blockquote>\n<p>To improve this instance I need a beter algorithm. Does anyone have any ideas (maybe something with the order of the elements)?</p>\n</blockquote>\n<p>I think there are standard algorithms, even in C++ standard template library there is permutation enumeration code...</p>",
        "id": 512571758,
        "sender_full_name": "Jz Pan",
        "timestamp": 1744814718
    },
    {
        "content": "<p>I believe that doesn't help a lot - enumerating the permutations is what's already happening, but enumerating the automorphisms is what (I think) Aaron wants to do: in particular in a way which is more intelligent than \"enumerate the permutations and throw away the non-automorphisms\"</p>",
        "id": 512572441,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1744814898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Aut.28S_n.29.20.E2.89.83.20Inn.28S_n.29.20when.20n.20!.3D.202.20and.20n.20!.3D.206/near/512569587\">said</a>:</p>\n<blockquote>\n<p>You should look at what GAP does, this is an open source computational group theory package</p>\n</blockquote>\n<p>I can't read that code :(</p>",
        "id": 512572616,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744814946
    },
    {
        "content": "<p>In the specific case of S_4, any automorphism must send involutions to involutions, since those are exactly the elements of order 2 that are not squares.  Since those elements also generate the symmetric group, you can now probably brute-force that all permutations of the involutions that are also automorphisms of S_4 are in fact conjugations.</p>",
        "id": 512573429,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1744815127
    },
    {
        "content": "<p>The general characterisation of the outer automorphisms of S_n is not very different: you first show that any automorphism must send involutions to involutions, by a counting argument that fails exactly for n = 6, and then you argue about automorphisms that are induced by permutations of involutions.</p>",
        "id": 512573811,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1744815220
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Aut.28S_n.29.20.E2.89.83.20Inn.28S_n.29.20when.20n.20!.3D.202.20and.20n.20!.3D.206/near/512572441\">said</a>:</p>\n<blockquote>\n<p>I believe that doesn't help a lot - enumerating the permutations is what's already happening, but enumerating the automorphisms is what (I think) Aaron wants to do: in particular in a way which is more intelligent than \"enumerate the permutations and throw away the non-automorphisms\"</p>\n</blockquote>\n<p>Oh sorry I misread the problem. Maybe to do this efficiently we need the actual propositional description of Aut(S_n) (i.e. proof the result OP asked), then use this as the correctness proof of the algorithm.</p>",
        "id": 512575119,
        "sender_full_name": "Jz Pan",
        "timestamp": 1744815538
    },
    {
        "content": "<p>The correct thing to do would be to speed up <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MulEquiv.instFintype#doc\">docs#MulEquiv.instFintype</a>, not to special-case the symmetric group and possibly cause diamonds.</p>",
        "id": 512576193,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744815766
    },
    {
        "content": "<p>That would be the correct change to the Fintype instances, but it's also feasible to calculate this cardinality in some symmetric-specific way on a propositional level; that's what I think Damiano was suggesting</p>",
        "id": 512577991,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1744816226
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Aut.28S_n.29.20.E2.89.83.20Inn.28S_n.29.20when.20n.20!.3D.202.20and.20n.20!.3D.206/near/512569347\">said</a>:</p>\n<blockquote>\n<p>To improve this instance I need a beter algorithm. Does anyone have any ideas (maybe something with the order of the elements)?</p>\n</blockquote>\n<p>I think your idea for simple graph colourings (which I'm now reviewing) would be an improvement on the current one (I trust you can see the analogy?), it's not clear that the improvement would make it past the 3 case as above though</p>",
        "id": 512578238,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1744816289
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Aut.28S_n.29.20.E2.89.83.20Inn.28S_n.29.20when.20n.20!.3D.202.20and.20n.20!.3D.206/near/512578238\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Aut.28S_n.29.20.E2.89.83.20Inn.28S_n.29.20when.20n.20!.3D.202.20and.20n.20!.3D.206/near/512569347\">said</a>:</p>\n<blockquote>\n<p>To improve this instance I need a beter algorithm. Does anyone have any ideas (maybe something with the order of the elements)?</p>\n</blockquote>\n<p>I think your idea for simple graph colourings (which I'm now reviewing) would be an improvement on the current one (I trust you can see the analogy?), it's not clear that the improvement would make it past the 3 case as above though</p>\n</blockquote>\n<p>This gives me all the <code>MulHom</code>s quite easily, but not the <code>MulEquiv</code>s.</p>",
        "id": 512579700,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744816680
    },
    {
        "content": "<p>It's not too hard to modify it to give <code>MulEquiv</code> instead though right? You just also ensure that it's injective as you build it</p>",
        "id": 512580410,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1744816880
    },
    {
        "content": "<p>I am assuming that you're in a finite group, where injective group homs are exactly the group isos, but in this problem that's exactly what's happening</p>",
        "id": 512580692,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1744816956
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Aut.28S_n.29.20.E2.89.83.20Inn.28S_n.29.20when.20n.20!.3D.202.20and.20n.20!.3D.206/near/512573429\">发言道</a>：</p>\n<blockquote>\n<p>In the specific case of S_4, any automorphism must send involutions to involutions, since those are exactly the elements of order 2 that are not squares.  Since those elements also generate the symmetric group, you can now probably brute-force that all permutations of the involutions that are also automorphisms of S_4 are in fact conjugations.</p>\n</blockquote>\n<p>Thank you! I will try to prove this</p>",
        "id": 512728559,
        "sender_full_name": "Alissa Tung",
        "timestamp": 1744860817
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Aut.28S_n.29.20.E2.89.83.20Inn.28S_n.29.20when.20n.20!.3D.202.20and.20n.20!.3D.206/near/512580410\">发言道</a>：</p>\n<blockquote>\n<p>It's not too hard to modify it to give <code>MulEquiv</code> instead though right? You just also ensure that it's injective as you build it</p>\n</blockquote>\n<p>Thank you! Yes, I am working with finite groups. I will try to modify this</p>",
        "id": 512728688,
        "sender_full_name": "Alissa Tung",
        "timestamp": 1744860885
    },
    {
        "content": "<p>It would be nice to prove the result for <code>Equiv.Perm n</code>, of a given finite type <code>n</code>, not necessarily <code>Fin n</code>.</p>",
        "id": 512761930,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1744876510
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 515518590,
        "sender_full_name": "Alissa Tung",
        "timestamp": 1746110643
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"638718\">Alissa Tung</span> has marked this topic as resolved.</p>",
        "id": 515518617,
        "sender_full_name": "Notification Bot",
        "timestamp": 1746110647
    }
]