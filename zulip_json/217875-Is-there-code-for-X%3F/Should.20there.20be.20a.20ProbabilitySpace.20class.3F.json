[
    {
        "content": "<p>I'm starting a project involving probability theory and was looking around for the concept of a probability space.  Mathlib supports <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.MeasureSpace#doc\">docs#MeasureTheory.MeasureSpace</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.ProbabilityMeasure#doc\">docs#MeasureTheory.ProbabilityMeasure</a> but not, as far as I can tell, a probability space directly.  I started coding my own basic theory for probability spaces at</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ProbSpace</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">MeasurableSpace</span> <span class=\"bp\">Ω</span> <span class=\"n\">where</span>\n  <span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">MeasureTheory.ProbabilityMeasure</span> <span class=\"bp\">Ω</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prob</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(‹</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">›</span><span class=\"bp\">.</span><span class=\"n\">μ</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"s2\">\"P[ \"</span> <span class=\"n\">E</span> <span class=\"s2\">\" ]\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">prob</span> <span class=\"n\">E</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_le_one</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">):</span> <span class=\"n\">P</span><span class=\"o\">[</span> <span class=\"n\">E</span> <span class=\"o\">]</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">prob</span>\n  <span class=\"n\">exact</span> <span class=\"n\">MeasureTheory.ProbabilityMeasure.apply_le_one</span> <span class=\"o\">‹</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">›</span><span class=\"bp\">.</span><span class=\"n\">μ</span> <span class=\"n\">E</span>\n</code></pre></div>\n<p>but I wanted to double-check before going further that I wasn't missing some existing support for probability spaces here.  Also, I can't get the above code to work when defining <code>ProbSpace</code> instead as an extension of <code>MeasureSpace</code>,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ProbSpace</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">MeasureTheory.MeasureSpace</span> <span class=\"bp\">Ω</span> <span class=\"n\">where</span>\n  <span class=\"n\">totalProb</span> <span class=\"o\">:</span> <span class=\"n\">MeasureTheory.IsProbabilityMeasure</span> <span class=\"o\">‹</span><span class=\"n\">MeasureTheory.MeasureSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">›</span><span class=\"bp\">.</span><span class=\"n\">volume</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prob</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">MeasureTheory.MeasureSpace.volume</span> <span class=\"n\">E</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"s2\">\"P[ \"</span> <span class=\"n\">E</span> <span class=\"s2\">\" ]\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">prob</span> <span class=\"n\">E</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_le_one</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">):</span> <span class=\"n\">P</span><span class=\"o\">[</span> <span class=\"n\">E</span> <span class=\"o\">]</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">prob</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>although it seems from browsing Mathlib that there isn't much support for <code>MeasureSpace</code> anyway so this seems like no great loss.</p>",
        "id": 401643664,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699826829
    },
    {
        "content": "<p>I think the intent is that you write out <code>[MeasureSpace Ω] [IsProbabilityMeasure (volume : Measure Ω)]</code>, though that's not necessarily an argument against the shorthand you're proposing</p>",
        "id": 401643776,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699826948
    },
    {
        "content": "<p>I think in general there's almost nothing in mathlib about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.MeasureSpace#doc\">docs#MeasureTheory.MeasureSpace</a>, because it's just a way of saying a measure is \"canonical\", which doesn't actually carry any mathematical properties.</p>",
        "id": 401643882,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699827067
    },
    {
        "content": "<p>OK in that case I will revert back to my original plan of defining <code>ProbSpace</code> as an extension of <code>MeasurableSpace</code>.  I would still be interested in figuring out how to close the <code>sorry</code> in the second code block though - I had a lot of trouble accessing <code>volume</code> from a <code>ProbSpace</code> instance (when it was defined as an extension of <code>MeasureSpace</code>) which suggests to me that I don't understand how inheritance works.</p>",
        "id": 401644234,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699827511
    },
    {
        "content": "<p>Here is the canonical way of working with a probability space in mathlib:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">μ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">μ.IsProbabilityMeasure</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 401644469,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699827791
    },
    {
        "content": "<p>Doesn't this mean that all probabilistic notation (e.g., <code>P[  ]</code>, <code>E[  ]</code>, etc.) would have to explicitly involve <code>μ</code>?</p>",
        "id": 401644572,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699827958
    },
    {
        "content": "<p>For my application I will be working with multiple probability spaces (there is a lot of conditioning that will happen) so I can't simply declare the data for a probability space as a global <code>variable</code> that all the notation implicitly uses.</p>",
        "id": 401644653,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699828035
    },
    {
        "content": "<p>Yes. this is a conscious design decision: It is very common to have several measures hanging around, so one can't assume that the measure is canonical and provide notation for it.</p>",
        "id": 401644656,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699828040
    },
    {
        "content": "<p>So this is not your symmetric polynomials project anymore, but something else?</p>",
        "id": 401644677,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699828081
    },
    {
        "content": "<p>My situation is slightly different; I have multiple <em>spaces</em> hanging around, but each space will have a canonical measure attached to it.</p>\n<p>I'm temporarily using the symmetric polynomials github to get started on this, but yes, this is a separate project.</p>",
        "id": 401644724,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699828110
    },
    {
        "content": "<p>And will some of your probability spaces derive their canonical measure from other spaces?</p>",
        "id": 401644766,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699828177
    },
    {
        "content": "<p>Yeah, usually by conditioning an existing probability space to some positive probability event.</p>",
        "id": 401644782,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699828202
    },
    {
        "content": "<p>Or by taking Cartesian products of existing spaces in order to generate independent trials.</p>",
        "id": 401644841,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699828224
    },
    {
        "content": "<p>For all these applications it seems logical to me to set up a <code>ProbabilitySpace</code> class and start defining some operations on it (conditioning, product, etc.).</p>",
        "id": 401644864,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699828267
    },
    {
        "content": "<p>Product will work out fine. Conditioning will be a pain, however. You can't let typeclass inference fill this in for you because it requires the (non-typeclass-accessible) information that the event you're conditioning by has nonzero probability.</p>",
        "id": 401644955,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699828373
    },
    {
        "content": "<p>Couldn't I make a definition that spits out some useless default probability space if the event has zero probability, but makes the correct construction if it has positive probability?</p>",
        "id": 401644992,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699828434
    },
    {
        "content": "<p>I have to say, the Mathlib choice to make the probability measure explicit all the time goes against the mainstream practice of probabilists, which is to hide the probability measure as much as possible (unless one is in the situation of having multiple probability measures on a single space, none of which are canonical).</p>",
        "id": 401645260,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699828704
    },
    {
        "content": "<p>Sure you can. You will run into subtle design decisions, however: what useless default probability space to pick? how to connect it to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ProbabilityTheory.cond#doc\">docs#ProbabilityTheory.cond</a> ? And you will also encounter API writing.</p>",
        "id": 401645261,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699828705
    },
    {
        "content": "<p>(incidentally, people were discussing your symmetric polynomials project, and it was pointed out that it dodged having to write API, so I'm interested to see how you figure this one out)</p>",
        "id": 401645317,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699828789
    },
    {
        "content": "<p>API writing?</p>",
        "id": 401645323,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699828797
    },
    {
        "content": "<p>Do you mean writing classes and their methods?</p>",
        "id": 401645379,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699828823
    },
    {
        "content": "<p>It's computer science terminology, but what we mean here by \"API\" is the set of lemmas and auxiliary definitions that let you interact with a definition.</p>",
        "id": 401645392,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699828853
    },
    {
        "content": "<p>OK.  Well, yeah, that's what I'm trying to do right now with creating a <code>ProbabilitySpace</code> class.</p>",
        "id": 401645435,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699828903
    },
    {
        "content": "<p>This is a very important concept for mathlib, and most of the lemmas in mathlib are API lemmas. The non-API lemmas are the \"big theorems\", which usually have names and take more than a few lines to prove.</p>",
        "id": 401645438,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699828913
    },
    {
        "content": "<p>This is not the case with all theorem provers. Eg Isabelle's strong automation means that API are less likely to be provided, since automation can always reprove it on the fly where. But in mathlib it is a very structuring principle, and the quality of an API distinguishes very strongly \"one-time projects\" (eg your symmetric polynomial project) from 'mathlib-ready code\" (eg hopefully what you will soon write about probability spaces).</p>",
        "id": 401645593,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699829057
    },
    {
        "content": "<p>I'm familiar with the concept of object-oriented programming.  Is API writing synonymous with this (or a particular implementation of that philosophy)?</p>",
        "id": 401645641,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699829121
    },
    {
        "content": "<p>Kind of? Most OOP has no use for lemmas, but if you replace \"lemmas\" with \"methods\", you get a pretty good parallel (except that of course Lean methods are <code>def</code>s, so they too should have some API lemmas written about them!).</p>",
        "id": 401645723,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699829201
    },
    {
        "content": "<p>FWIW, here's how I would prove your original sorry (including two API lemmas):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ProbSpace</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">MeasureSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">,</span>\n  <span class=\"n\">IsProbabilityMeasure</span> <span class=\"o\">‹</span><span class=\"n\">MeasureSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">›</span><span class=\"bp\">.</span><span class=\"n\">volume</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prob</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">MeasureSpace.volume</span> <span class=\"n\">E</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"s2\">\"P[ \"</span> <span class=\"n\">E</span> <span class=\"s2\">\" ]\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">prob</span> <span class=\"n\">E</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_univ</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">[(</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)]</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n  <span class=\"n\">IsProbabilityMeasure.measure_univ</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_mono</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≤</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"bp\">≤</span> <span class=\"n\">P</span><span class=\"o\">[</span><span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"n\">OuterMeasure.mono</span> <span class=\"n\">_</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_le_one</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">[</span> <span class=\"n\">E</span> <span class=\"o\">]</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">prob_univ</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">prob_mono</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 401645741,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1699829230
    },
    {
        "content": "<p><code>extends IsProbabilityMeasure ‹MeasureSpace Ω›.volume</code> is a neat trick!</p>",
        "id": 401645765,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699829271
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/401644841\">said</a>:</p>\n<blockquote>\n<p>Or by taking Cartesian products of existing spaces in order to generate independent trials.</p>\n</blockquote>\n<p>A small warning: (as far as I know) we only have binary products of probability measures currently in Mathlib.</p>\n<p>I <a href=\"#narrow/stream/113488-general/topic/Probability.20projects/near/388605350\">suggested defining general products of probability measures</a> as one of the desirable projects for new probability contributors. It should not be particularly hard compared to other things that have been done, just no-one has done it yet. Although I wouldn't immediately know what is the cleanest extension theorem that would give arbitrary infinite products of probability measures in Mathlib. (I suspect directly applicable extension theorems are missing, but haven't checked carefully.)</p>",
        "id": 401645835,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1699829316
    },
    {
        "content": "<p>... though actually its unnecessary, you can just write <code>volume</code> by itself.</p>",
        "id": 401645837,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699829320
    },
    {
        "content": "<p>All this said, the best answer I can provide to your titular question is: There should be a <code>ProbabilitySpace</code> typeclass iff someone can write an API for it that demonstrates it is easier to use than <code>IsProbabilityMeasure</code>.</p>",
        "id": 401645956,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699829441
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/401645837\">said</a>:</p>\n<blockquote>\n<p>... though actually its unnecessary, you can just write <code>volume</code> by itself.</p>\n</blockquote>\n<p>Ah right. that saves a few characters :)</p>",
        "id": 401645971,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1699829467
    },
    {
        "content": "<p>And now I should go to bed before I rightly learn about the Kolmogorov extension theorem in my lecture tomorrow <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 401645983,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699829506
    },
    {
        "content": "<p>(quite a shame I don't get to see your questions more often due to timezones)</p>",
        "id": 401646036,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699829530
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/401645956\">said</a>:</p>\n<blockquote>\n<p>All this said, the best answer I can provide to your titular question is: There should be a <code>ProbabilitySpace</code> typeclass iff someone can write an API for it that demonstrates it is easier to use than <code>IsProbabilityMeasure</code>.</p>\n</blockquote>\n<p>OK.  I can't imagine that it would be worse - it would be easy to access the probability measure from the <code>ProbabilitySpace</code> object, and any lemma using <code>IsProbabilityMeasure</code> should (I expect) be easily wrapped into a corresponding lemma for <code>ProbabilitySpace</code>.  I'm mostly looking forward to all the measure bookkeeping being done automatically - there will be a lot of random variables associated to various spaces, each equipped with canonical measures, and I simply don't want to explicitly think about exactly those measures are, and focus on the random variables instead.</p>",
        "id": 401646176,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699829731
    },
    {
        "content": "<p>I'll only be needing binary products (and conditional products, but I'll cross that bridge when I come to it), so I'll dodge the need to think about Kolmogorov extension.</p>",
        "id": 401646232,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699829779
    },
    {
        "content": "<p>That's all well and good, but we don't want mathlib to acquire such an API only to notice that it all breaks down when people want to consider several probability measures on the same space. One has to accommodate more than just their application, because we want code to be reusable.</p>",
        "id": 401646432,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699830005
    },
    {
        "content": "<p>But we can't know whether your code is reusable before you've written. So I would say, go ahead!</p>",
        "id": 401646470,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699830032
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/401644572\">said</a>:</p>\n<blockquote>\n<p>Doesn't this mean that all probabilistic notation (e.g., <code>P[  ]</code>, <code>E[  ]</code>, etc.) would have to explicitly involve <code>μ</code>?</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Probability/Notation.html\">This Mathlib file</a> defines notations such as <code>P[X]</code> and <code>𝔼[X]</code>. It uses <code>MeasureSpace.volume</code> directly, but is meant to be used in probability theory context when one has one canonical probability measure (per space) at hand. I think you get the notation if you <code>open scoped ProbabilityTheory</code>, although I haven't used it.</p>",
        "id": 401646484,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1699830039
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/401645741\">said</a>:</p>\n<blockquote>\n<p>FWIW, here's how I would prove your original sorry (including two API lemmas):</p>\n</blockquote>\n<p>Thanks!  It's hurting my brain a bit to think about <code>ProbSpace</code> as both a <code>MeasureSpace</code> and a <code>Prop</code>,  but that does shortcut things.</p>\n<p>For the purpose of interfacing with existing Mathlib lemmas using <code>IsProbabilityMeasure</code> etc., how would one access the probabiliity measure in your code explicitly?  Things like <code>Ω.volume</code> etc. didn't seem to work for me, which in particular was preventing me from using existing methods like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.ProbabilityMeasure.apply_le_one#doc\">docs#MeasureTheory.ProbabilityMeasure.apply_le_one</a> to close the argument in the second formulation.  I would prefer not to duplicate large parts of the existing Mathlib and just borrow whatever has already been proven for probability measures whenever possible.</p>",
        "id": 401646721,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699830153
    },
    {
        "content": "<p>I think your original code was just missing an explicitly recorded <em>instance</em> of <code>[IsProbabilityMeasure _]</code> for your <code>volume</code>. So as soon as the instance is around, it should work. Here's a pedestrian version which does just that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ProbSpace</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">MeasureSpace</span> <span class=\"bp\">Ω</span> <span class=\"n\">where</span>\n  <span class=\"n\">totalProb</span> <span class=\"o\">:</span> <span class=\"n\">IsProbabilityMeasure</span> <span class=\"o\">‹</span><span class=\"n\">MeasureSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">›</span><span class=\"bp\">.</span><span class=\"n\">volume</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prob</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">MeasureSpace.volume</span> <span class=\"n\">E</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"s2\">\"P[ \"</span> <span class=\"n\">E</span> <span class=\"s2\">\" ]\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">prob</span> <span class=\"n\">E</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsProbabilityMeasure</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">measure_univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">have</span> <span class=\"n\">obs</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">ProbSpace.totalProb</span> <span class=\"bp\">Ω</span> <span class=\"n\">_</span>\n    <span class=\"n\">exact</span> <span class=\"n\">measure_univ</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_le_one</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">):</span> <span class=\"n\">P</span><span class=\"o\">[</span> <span class=\"n\">E</span> <span class=\"o\">]</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">prob</span>\n  <span class=\"n\">exact</span><span class=\"bp\">?</span> <span class=\"c1\">-- Works and gives `MeasureTheory.prob_le_one`</span>\n</code></pre></div>",
        "id": 401646931,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1699830291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"373986\">Kalle Kytölä</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/401646484\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/401644572\">said</a>:</p>\n<blockquote>\n<p>Doesn't this mean that all probabilistic notation (e.g., <code>P[  ]</code>, <code>E[  ]</code>, etc.) would have to explicitly involve <code>μ</code>?</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Probability/Notation.html\">This Mathlib file</a> defines notations such as <code>P[X]</code> and <code>𝔼[X]</code>. It uses <code>MeasureSpace.volume</code> directly, but is meant to be used in probability theory context when one has one canonical probability measure (per space) at hand. I think you get the notation if you <code>open scoped ProbabilityTheory</code>, although I haven't used it.</p>\n</blockquote>\n<p>Yeah, I saw that, but was surprised to see this notation not used at all in the rest of Mathlib (and in particular I did not have any existing use cases to learn how to use the notation), so was wondering if it was deprecated or something.</p>",
        "id": 401646972,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699830348
    },
    {
        "content": "<p>Oh yeah Kalle is raising a good point. Probabilistic notation <em>is</em> already defined. So you should be able to use <code>[MeasureSpace Ω] [IsProbabilityMeasure (volume : Measure Ω]</code> wherever you would have used your <code>[ProbSpace Ω]</code>.</p>",
        "id": 401646976,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699830354
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/401646721\">said</a>:</p>\n<blockquote>\n<p>For the purpose of interfacing with existing Mathlib lemmas using <code>IsProbabilityMeasure</code> etc., how would one access the probabiliity measure in your code explicitly?</p>\n</blockquote>\n<p>Here's one approach:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ProbSpace</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">MeasureSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">,</span>\n  <span class=\"n\">IsProbabilityMeasure</span> <span class=\"n\">volume</span>\n\n<span class=\"c1\">-- the other lemmas from the above have been omitted</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">probMeasure</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"n\">volume</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">isProbabilityMeasureProbMeasure</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsProbabilityMeasure</span> <span class=\"o\">(</span><span class=\"n\">probMeasure</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">ProbSpace.toIsProbabilityMeasure</span>\n</code></pre></div>",
        "id": 401646994,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1699830363
    },
    {
        "content": "<p>I don't think the notation is deprecated or anything. It's just not used much because people want to avoid assuming there is one canonical measure on a given space. But for the purpose of your project it is a very sensible solution.</p>",
        "id": 401647056,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699830442
    },
    {
        "content": "<p>Adam's example becomes even shorter with <code>abbrev</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">ProbSpace</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">MeasureSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">,</span>\n  <span class=\"n\">IsProbabilityMeasure</span> <span class=\"n\">volume</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">probMeasure</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"n\">volume</span>\n</code></pre></div>\n<p>which means lean can already find the instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">IsProbabilityMeasure</span> <span class=\"o\">(</span><span class=\"n\">probMeasure</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 401647121,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699830515
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"373986\">@Kalle Kytölä</span>'s <code>instance</code> isn't necessary with this spelling, as it is generated automatically thanks to being in the <code>extends</code> clause</p>",
        "id": 401647160,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699830560
    },
    {
        "content": "<p>Yes, I understand that it is not necessary in the later clever approach, but I believe the lack of the instance was why Terry didn't get access to the probability results automatically in the original question. (That's why I referred to my proposal as \"pedestrian\", because it only recorded the necessary instance )</p>",
        "id": 401647279,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1699830702
    },
    {
        "content": "<p>Indeed, though if you know the instance is already around and Lean can't find it for some reason, usually there's a better solution than trying to reprove the instance \"from scratch\"</p>",
        "id": 401647348,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699830748
    },
    {
        "content": "<p>Going back a little;the problem with introducing such a <code>ProbSpace</code> class (into Mathlib) is that we'd end up with almost nothing stated about it, and whenever someone contributes something to mathlib about probability spaces, we would probably end up asking them to generalize it to probability measures instead. This is sort of the same fate that befell <code>VectorSpace</code>, which we eventually eliminated; it was great for teaching and for matching literature, but it provided no mathematical value from a Lean perspective over the <code>Module</code> that we already had.</p>",
        "id": 401647438,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699830848
    },
    {
        "content": "<p>(and even the teaching benefits of <code>VectorSpace</code> are marginal; presumably your students start to wonder why they can't find any results about vector spaces in mathlib, and they have to learn about <code>Module</code> anyway...)</p>",
        "id": 401647472,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699830904
    },
    {
        "content": "<p>I feel like these sorts of decisions create barriers to entry for incoming mathematicians.</p>",
        "id": 401647675,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699831101
    },
    {
        "content": "<p>With polymorphism I don't see why it's necessary to eliminate these sorts of extensions.  I'd much rather work in say <code>AddCommGroup</code> rather than in some <code>AddMonoid</code> class carrying around additional axioms as needed, even if most of the tools I used actually come from that more primitive class.</p>",
        "id": 401647824,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699831265
    },
    {
        "content": "<p>What are the drawbacks to adding some kind of  proxy lemmas for special cases (vector spaces) which are internally proved by something like <code>exact &lt;general_case_lemma&gt;</code>? Is it build time and library size?</p>",
        "id": 401648178,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1699831664
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/401647675\">said</a>:</p>\n<blockquote>\n<p>I feel like these sorts of decisions create barriers to entry for incoming mathematicians.</p>\n</blockquote>\n<p>There are currently many barriers. However there are fewer barriers than there were 6 years ago, when there was no documentation for any of the systems which was suitable for mathematicians, and Q&amp;As were mostly being done with email mailing lists (so nothing in real time). Asking many questions on the Lean chatroom (first Gitter, now Zulip) seemed to be the only way into the subject at the time, and those of us who were around back then are still extremely grateful to the computer scientists who spent a lot of time answering our basic questions. </p>\n<p>It's very helpful to hear suggestions about how the software can be made easier for mathematicians, because there certainly exist people who are not prepared to expose their ignorance on Zulip, or would rather learn by reading something than asking questions. For questions like this, I am hoping that they will go away over time as mathlib's coverage of basic notions gets better, and more worked examples appear online explaining how to do basic stuff. Mathematics In Lean <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a> is an attempt to do this, but mathematics is a big subject and there are still plenty of gaps.</p>",
        "id": 401648233,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1699831690
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/401647824\">said</a>:</p>\n<blockquote>\n<p>With polymorphism I don't see why it's necessary to eliminate these sorts of extensions.  I'd much rather work in say <code>AddCommGroup</code> rather than in some <code>AddMonoid</code> class carrying around additional axioms as needed, even if most of the tools I used actually come from that more primitive class.</p>\n</blockquote>\n<p>I think the key distinction here is between what you as a user with a specific goal in mind should do, and what mathlib, which wants to work for as many users as possible, should do. For your own development, you should absolutely only focus on the generality you care about, especially if it it makes your proofs easier or more readable. But if you end up contributing it to mathlib, it will slowly evolve to more general cases until you no longer recognize it as the code you wrote!</p>",
        "id": 401648395,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699831864
    },
    {
        "content": "<p>Sure, but as long as the general version of the code is automatically inherited by whatever specific class extensions or instances one actually works with, this should be largely invisible to the end user.  I can't imagine the process of refactoring the code to the more abstract class being all <em>that</em> timeconsuming, compared with creating the initial version of the code in the first place.</p>",
        "id": 401648730,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699832268
    },
    {
        "content": "<p>especially if one abstracts out the trivial lemmas early on and relies on them as much as possible, rather than using the specific implementation-dependent components of the class.</p>",
        "id": 401648806,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699832345
    },
    {
        "content": "<p>Regarding probability in mathlib, my understanding is that right now it is an open question how to design it in a way such that natural steps you'd take in a paper proof can be easily realized in Lean. I don't know the details very well, but for example being able to do things like say \"now let X be a independent uniform random variable on {0,1}\" and have everything in sight be automatically with respect to a sample space that's a cartesian product with the original one. The lack of material here is as I understand it is simply from lack of development -- maybe you'll be the one to solve it for mathlib <span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<p>Regarding <code>VectorSpace</code>, this is what the definition would look like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">VectorSpace</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">Module</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">where</span>\n<span class=\"c1\">-- no body</span>\n</code></pre></div>\n<p>It's not good to have this as a <code>class</code> like this because then realizing you can generalize results gets epsilon more difficult, but I believe there's no harm in having this as an abbreviation. (I've made a mechanism where you could write aliases for the <code>variable?</code> command -- this command suggests a completed <code>variable</code> command with any missing typeclasses -- there's an example for <code>VectorSpace</code> in the test file but I never put it into mathlib proper.) In the long run, I think having more specialized versions of everything is a great idea, but in the short term I believe the abstract way mathlib is developed helps keep development costs down.</p>\n<p>Just to mention \"API\" -- we tend to throw it around loosely around here. It's meant to refer to the definitions and theorems that users of a theory are meant to use (vs more internal material that actually unfolds definitions and breaks abstractions). \"Application programming interface\" is how CS people refer to the public interface of a library, and it's sort of fitting since it's applications of the theory.</p>",
        "id": 401648884,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1699832422
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/401648884\">said</a>:</p>\n<blockquote>\n<p>Regarding probability in mathlib, my understanding is that right now it is an open question how to design it in a way such that natural steps you'd take in a paper proof can be easily realized in Lean. I don't know the details very well, but for example being able to do things like say \"now let X be a independent uniform random variable on {0,1}\" and have everything in sight be automatically with respect to a sample space that's a cartesian product with the original one. The lack of material here is as I understand it is simply from lack of development -- maybe you'll be the one to solve it for mathlib <span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n</blockquote>\n<p>Actually, I already had a brief discussion about this on the Zulip at <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Working.20with.20big-O.20notation.20like.20an.20analyst/near/397910850\">stream:Is+there+code+for+X? topic:Working+with+big-O+notation+like+an+analyst near:397910850</a> [by the way - how does one properly cite prior threads in Zulip?].  In my ideal world, random variables would not be modeled by a single sample space, but on something resembling an element of a filter on the category of all sample spaces, and then independent copies of random variables could be introduced by restricting to a smaller element of this filter; one would almost never touch the sample space directly except for some foundational lemmas, and manipulate random variables almost exactly like how one already manipulates deterministic quantities.  But that's a lengthy discussion for another time perhaps.</p>",
        "id": 401649434,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699833174
    },
    {
        "content": "<p>I'd like to see an approach like that work (let's use pro-objects instead of amateur-objects!). One question there is whether it can be designed such that mathlib users can work with it in simpler cases without realizing how sophisticated it is underneath.</p>\n<p>(Re zulip, I don't know about proper, but I tend to write a link like you did and then work <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Working.20with.20big-O.20notation.20like.20an.20analyst/near/397910850\">a link to the discussion</a> into my sentence, unless you mean cite as in cite in a paper, in which case I don't know.)</p>\n<p>Going back to generality in mathlib, one dream I have is that there will be textbook-like frontend libraries to mathlib that give a standard treatment of a subject in an appropriate level of generality, but then all the proofs are (ideally) corollaries of mathlib theorems. That way (1) you can use such frontend in a project or for teaching if it's sufficient for your needs and (2) you can learn how to get around mathlib by starting with math that you're more familiar with.</p>",
        "id": 401650936,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1699834297
    },
    {
        "content": "<p>Hmm, one drawback of going through <code>MeasureSpace</code> is that the probability is currently having the type of <code>ENNReal</code> rather than <code>NNReal</code>.  I am vaguely aware of some automatic coercion in <code>IsProbabilityMeasure</code> that had previously magically converted the type to <code>NNReal</code> but am not sure how to activate this now in the current version of the class.</p>",
        "id": 401651001,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699834333
    },
    {
        "content": "<p>(regarding citing zulip, you already have done the important part correctly; links to <em>messages</em> like yours are permalinks even if the thread is renamed, but links to <em>threads</em> always go to the last message, and can break)</p>",
        "id": 401651754,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699834874
    },
    {
        "content": "<p>Ah, OK, the problem is that <code>probMeasure</code> now has the type of <code>Measure Ω</code> rather than <code>ProbabilityMeasure Ω</code>.  Hmm, just need to find the right coercion operation, I guess.</p>",
        "id": 401651887,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699834969
    },
    {
        "content": "<p>I think you might have a better time with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.ProbabilityMeasure#doc\">docs#MeasureTheory.ProbabilityMeasure</a> after all</p>",
        "id": 401652175,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699835143
    },
    {
        "content": "<p>So perhaps:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ProbSpace</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">MeasureSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">,</span> <span class=\"n\">IsProbabilityMeasure</span> <span class=\"n\">volume</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simps</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">prob</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ProbabilityMeasure</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">volume</span><span class=\"o\">,</span> <span class=\"n\">inferInstance</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>(<code>simps</code> here just generates the trivial lemma that <code>prob.toMeasure = volume</code>)</p>",
        "id": 401652368,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699835249
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> what is an amateur object? In any case, I think it’s worthwhile to keep the monadic approach in mind as well. Just in the last few days I had to generate some random things, and working monadically was extremely convenient, and do notation allows you to work with random variables as though they are deterministic. See here <a href=\"http://github.com/adamtopaz/lean_pdist\">github.com/adamtopaz/lean_pdist</a></p>",
        "id": 401652486,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1699835307
    },
    {
        "content": "<p>(It's just a silly joke -- the filter-like thing <span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> was talking about sounded like some pro- construction, which of course is for professionals.)</p>",
        "id": 401652605,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1699835390
    },
    {
        "content": "<p>Of course lean’s do notation won’t work as is for the Giry monad.</p>",
        "id": 401652610,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1699835396
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/401652368\">said</a>:</p>\n<blockquote>\n<p>So perhaps:</p>\n</blockquote>\n<p>This is now giving the right types, but all the methods now break (I guess because <code>ProbabilityMeasure</code> doesn't inherit everything from <code>Measure</code> or something?):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ProbSpace</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">MeasureSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">,</span>\n  <span class=\"n\">IsProbabilityMeasure</span> <span class=\"n\">volume</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simps</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">lemmasOnly</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">probMeasure</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ProbabilityMeasure</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">volume</span><span class=\"o\">,</span> <span class=\"n\">inferInstance</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prob</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">probMeasure</span> <span class=\"bp\">Ω</span> <span class=\"n\">E</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"s2\">\"P[ \"</span> <span class=\"n\">E</span> <span class=\"s2\">\" ]\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">prob</span> <span class=\"n\">E</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_univ</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">[(</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)]</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n  <span class=\"n\">IsProbabilityMeasure.measure_univ</span> <span class=\"c1\">-- no longer works</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_mono</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≤</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"bp\">≤</span> <span class=\"n\">P</span><span class=\"o\">[</span><span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"n\">OuterMeasure.mono</span> <span class=\"n\">_</span> <span class=\"n\">h</span>  <span class=\"c1\">-- no longer works</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_le_one</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">[</span> <span class=\"n\">E</span> <span class=\"o\">]</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">prob_univ</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">prob_mono</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_le_one'</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">[</span> <span class=\"n\">E</span> <span class=\"o\">]</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">prob</span>\n  <span class=\"n\">exact</span> <span class=\"n\">MeasureTheory.prob_le_one</span> <span class=\"c1\">-- no longer works</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_eq</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">[</span> <span class=\"n\">E</span> <span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">probMeasure</span> <span class=\"bp\">Ω</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 401652929,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699835538
    },
    {
        "content": "<p>Ah, it's just a matter of using the <code>ProbabilityMeasure</code> methods instead of the <code>Measure</code> methods.  Now things seem to work properly.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ProbSpace</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">MeasureSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">,</span>\n  <span class=\"n\">IsProbabilityMeasure</span> <span class=\"n\">volume</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simps</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">lemmasOnly</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">probMeasure</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ProbabilityMeasure</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">volume</span><span class=\"o\">,</span> <span class=\"n\">inferInstance</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prob</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">probMeasure</span> <span class=\"bp\">Ω</span> <span class=\"n\">E</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"s2\">\"P[ \"</span> <span class=\"n\">E</span> <span class=\"s2\">\" ]\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">prob</span> <span class=\"n\">E</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_univ</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">[(</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)]</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">MeasureTheory.ProbabilityMeasure.coeFn_univ</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_mono</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≤</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"bp\">≤</span> <span class=\"n\">P</span><span class=\"o\">[</span><span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">MeasureTheory.ProbabilityMeasure.apply_mono</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_le_one</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">[</span> <span class=\"n\">E</span> <span class=\"o\">]</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">MeasureTheory.ProbabilityMeasure.apply_le_one</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_eq</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">[</span> <span class=\"n\">E</span> <span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">probMeasure</span> <span class=\"bp\">Ω</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 401653605,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699835889
    },
    {
        "content": "<p>OK I think I can work with this class, it seems I can readily import anything I need from the existing <code>ProbabilityMeasure</code> methods.</p>",
        "id": 401654071,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699836115
    },
    {
        "content": "<p>I would strongly recommend dropping <code>def prob</code>, it's hiding from Lean that you're working with a probability measure</p>",
        "id": 401654186,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699836153
    },
    {
        "content": "<p>I tried but I don't know then how to get the P[ E ] notation to figure out what Ω is.</p>",
        "id": 401654311,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699836225
    },
    {
        "content": "<p>Just to show off how dot notation could be used here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">prob_univ</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">[(</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)]</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">probMeasure</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coeFn_univ</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_mono</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≤</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"bp\">≤</span> <span class=\"n\">P</span><span class=\"o\">[</span><span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">probMeasure</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">apply_mono</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_le_one</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">[</span> <span class=\"n\">E</span> <span class=\"o\">]</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">probMeasure</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">apply_le_one</span> <span class=\"n\">E</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prob_eq</span> <span class=\"o\">[</span><span class=\"n\">ProbSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">[</span> <span class=\"n\">E</span> <span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">probMeasure</span> <span class=\"bp\">Ω</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 401654315,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1699836228
    },
    {
        "content": "<p>Ok, there's something pretty nasty going on with <code>ProbabilityMeasure</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ProbabilityMeasure</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"k\">#check</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"c1\">-- (fun s =&gt; ENNReal.toNNReal (↑↑↑P s)) x : NNReal</span>\n</code></pre></div>\n<p>I think you've found a rather sharp edge</p>",
        "id": 401654723,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699836416
    },
    {
        "content": "<p>I actually want to have the probability return a <code>NNReal</code> rather than an <code>ENNReal</code>, even if it means that it is a bit harder then to access the more general measure theory lemmas that assume an <code>ENNReal</code> valued measure.</p>",
        "id": 401654938,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699836509
    },
    {
        "content": "<p>But I assume it is easier to automatically coerce a probability measure to a measure than the other way around, so I would think this isn't a problem?</p>",
        "id": 401655268,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699836672
    },
    {
        "content": "<p>My comment above is a remark that something got broken during the port from Lean 3 to Lean 4 with ProbabilityMeasure; compare <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.ProbabilityMeasure.coeFn_univ#doc\">docs#MeasureTheory.ProbabilityMeasure.coeFn_univ</a> (which is a mess of <code>fun</code> and arrows) with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.probability_measure.coe_fn_univ\">docs3#measure_theory.probability_measure.coe_fn_univ</a> (which is easy to read). I've made <a href=\"#narrow/stream/287929-mathlib4/topic/Bad.20CoeFun.20instances.20on.20FiniteMeasure.20and.20ProbabilityMeasure/near/401656710\">a new thread</a> to discuss that issue.</p>",
        "id": 401656249,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699837118
    },
    {
        "content": "<p>OK.  Well as long as the existing methods don't break when cleaning them up, it should be fine on my end; I can still read the documentation even though there are quite a few coercion arrows.</p>\n<p>For what it's worth, I've started a new project at <a href=\"https://github.com/teorth/pfr\">https://github.com/teorth/pfr</a> to start working with probability spaces (my immediate goal is to start proving some of the Shannon entropy inequalities; I don't plan to comprehensively develop the theory of probability spaces, but perhaps some of the material I end up developing can end up part of such a larger goal).</p>",
        "id": 401660206,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699838987
    },
    {
        "content": "<p>I'm arriving after the battle, but let me summarize how we do probability in mathlib currently. Typically, we would have </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">MeasureTheory</span> <span class=\"n\">ProbabilityTheory</span> <span class=\"n\">ENNReal</span> <span class=\"n\">NNReal</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MeasureSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsProbabilityMeasure</span> <span class=\"o\">(</span><span class=\"n\">ℙ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">Ω</span><span class=\"o\">)]</span>\n</code></pre></div>\n<p>and then start working with <code>ℙ</code>. The drawback is that the probability of an event is an extended positive real, not a real. We should probably introduce a notation <code>ℙᵣ</code> for the real-valued version, but I don't think this has been done yet. The notations such as <code>𝔼</code> for the expectation are available. For an example, see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ProbabilityTheory.strong_law_ae#doc\">docs#ProbabilityTheory.strong_law_ae</a>, where you will see how we speak of independent identically random variables also.</p>",
        "id": 401700025,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1699858987
    },
    {
        "content": "<p>We also have a good deal on conditional expectations, with handy notations such as <code>𝔼[X|m]</code> (see the file <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Probability/Notation.lean\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Probability/Notation.lean</a> for typical notations we use), and martingales. See for instance <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Submartingale.ae_tendsto_limitProcess#doc\">docs#MeasureTheory.Submartingale.ae_tendsto_limitProcess</a> for the almost sure convergence of <code>L^1</code> submartingales.</p>",
        "id": 401700236,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1699859155
    },
    {
        "content": "<p>Using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.ProbabilityMeasure#doc\">docs#MeasureTheory.ProbabilityMeasure</a> is <em>not</em> the usual way to use a probability measure: it is rather for when you want to consider a bunch of probability measures on a given space, and speak of properties in the space of probability measures, like weak convergence.</p>",
        "id": 401700497,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1699859287
    },
    {
        "content": "<p>There are still big holes in the library. IMHO, the two main ones are:</p>\n<ul>\n<li>We don't have the Kolmogorv extension theorem (yet, although it is in the works), so there is no direct way to construct a sequence of iid random variables. On the other hand, nothing prevents you from assuming the existence of such a sequence and working from there, as in the strong law of large numbers above.</li>\n<li>We don't have any Markov chain theory.</li>\n</ul>\n<p>We also miss Brownian motion, characteristic functions, stable laws, entropy, and so on.</p>",
        "id": 401700737,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1699859429
    },
    {
        "content": "<p>Let me add a short example of how to use the probability notations, and how mathlib deals with default measures on a measure space:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Probability.Notation</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span> <span class=\"n\">ProbabilityTheory</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">ENNReal</span> <span class=\"n\">NNReal</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MeasureSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsProbabilityMeasure</span> <span class=\"o\">(</span><span class=\"n\">ℙ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">Ω</span><span class=\"o\">)]</span>\n\n<span class=\"c1\">-- ℙ is notation for the measure, with values in ℝ≥0∞. We don't have ℝ≥0 or ℝ valued versions (yet?)</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSet</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℙ</span> <span class=\"n\">A</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">ℙ</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">prob_compl_eq_one_sub</span> <span class=\"n\">hA</span>\n\n<span class=\"c1\">-- For any measure μ, `μ[X]` is notation for `∫ ω, X ω ∂μ`, hence the expectation can be obtained</span>\n<span class=\"c1\">-- by writing `ℙ[X]`. We also have the notation `𝔼[⬝]`, which is `∫ ω, X ω ∂ℙ`.</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℙ</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"bp\">𝔼</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">𝔼</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"bp\">∫</span> <span class=\"n\">ω</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"n\">ω</span> <span class=\"bp\">∂</span><span class=\"n\">ℙ</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- In the example below, `Integrable X` means the same as `Integrable X ℙ`. This is done by the</span>\n<span class=\"c1\">-- `volume_tac` tactic in the definition, which used ℙ if no measure is given:</span>\n<span class=\"c1\">-- `def Integrable {α} {_ : MeasurableSpace α} (f : α → β) (μ : Measure α := by volume_tac) `</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hX</span> <span class=\"o\">:</span> <span class=\"n\">Integrable</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">ω</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"n\">ω</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">𝔼</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n  <span class=\"k\">calc</span> <span class=\"n\">ℙ</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"bp\">≤</span> <span class=\"bp\">𝔼</span><span class=\"o\">[(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)]</span> <span class=\"o\">:=</span> <span class=\"n\">integral_mono</span> <span class=\"n\">hX</span> <span class=\"o\">(</span><span class=\"n\">integrable_const</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n  <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"c1\">-- Several other definitions can use the default measure ℙ when the measure is not provided:</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∫</span> <span class=\"n\">ω</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"n\">ω</span> <span class=\"bp\">=</span> <span class=\"bp\">∫</span> <span class=\"n\">ω</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"n\">ω</span> <span class=\"bp\">∂</span><span class=\"n\">ℙ</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"c1\">-- this is used a lot in the analysis files with integrals w.r.t. the Lebesgue measure.</span>\n\n<span class=\"c1\">-- In Mathlib, you will find almost sure equalities written like this: `X =ᵐ[μ] Y`. But we have</span>\n<span class=\"c1\">-- notation that does not need the measure if you want to use ℙ</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">=ₐₛ</span> <span class=\"n\">Y</span> <span class=\"bp\">↔</span> <span class=\"n\">X</span> <span class=\"bp\">=ᵐ</span><span class=\"o\">[</span><span class=\"n\">ℙ</span><span class=\"o\">]</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.rfl</span>\n</code></pre></div>\n<p>The main way we avoid writing the measure everywhere is by adding <code>volume_tac</code> to definitions. You will probably encounter several definitions that should use it but don't: there is not a lot of code written about <code>MeasureSpace</code>, so the use of volume_tac is not very well tested.</p>",
        "id": 401703737,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1699861131
    },
    {
        "content": "<p>About the Kolmogorov extension theorem: we have a full proof with Peter Pfaffelhuber, but it still needs to be translated into PRs to mathlib. I'll be doing that soon (perhaps slowly).</p>",
        "id": 401703923,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1699861230
    },
    {
        "content": "<p>I am working on something related to what you are doing. On <a href=\"https://github.com/leanprover-community/mathlib4/tree/RD_kl\">branch#RD_kl</a> , I proved positivity of the Kullback-Leibler divergence and a Donsker-Varadhan duality formula. I see that we both proved some basic properties of  <code>x * log x</code> (see the KullbackLeibler.lean file here: <a href=\"https://github.com/leanprover-community/mathlib4/compare/RD_kl\">https://github.com/leanprover-community/mathlib4/compare/RD_kl</a> ).</p>",
        "id": 401704399,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1699861482
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/401700025\">said</a>:</p>\n<blockquote>\n<p>I'm arriving after the battle, but let me summarize how we do probability in mathlib currently. Typically, we would have </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">MeasureTheory</span> <span class=\"n\">ProbabilityTheory</span> <span class=\"n\">ENNReal</span> <span class=\"n\">NNReal</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MeasureSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsProbabilityMeasure</span> <span class=\"o\">(</span><span class=\"n\">ℙ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">Ω</span><span class=\"o\">)]</span>\n</code></pre></div>\n<p>and then start working with <code>ℙ</code>. </p>\n</blockquote>\n<p>Hmm, this doesn't look convenient for my application at all.  Frequently I will be having a random variable <code>X : Ω → S</code> and a positive probability event <code>E : Set Ω</code>, and I will wish to create a new conditioned random variable <code>(X|E) : E → S</code> formed by conditioning <code>X</code> to <code>E</code>, which I would like to also endow with the structure of a probability space. So the sample space and the probability measure will change repeatedly, and is not something I can handle as a global <code>variable</code>.  (This is in order to be able to state and prove the entropy chain rule <code>H[X,Y] = H[Y] + H[X|Y]</code>, where <code>H[X|Y]</code> is defined as <code>∑ y, P[ Y = y ] H[ (X|Y=y) ]</code>, and then go on to prove the Shannon entropy inequalities and thence on to my actual application.)</p>\n<p>I think I'm still going to try to make the <code>ProbabilitySpace</code> class approach work for now.  I still need to figure out how to artificially handle this conditioning when the event <code>E</code> has probability zero (or is not measurable at all) but apart from that technical issue I think I can see how it is going to work for my application.  [Note that this sort of conditioning is not exactly the same as conditioning to a sub-sigma-algebra, which is what seems to be what is currently supported in Mathlib.]</p>",
        "id": 401704623,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699861577
    },
    {
        "content": "<p>There shouldn't be any problem to have locally an instance with the following: if you have a <code>MeasureSpace</code> instance on a space, with <code>[IsProbabilityMeasure (ℙ : Measure Ω)]</code>, then endow any subset with the normalized retricted probability measure, and declare this as a measure space with its canonical measure and register also automatically the fact that it is a probability measure. There is of course the issue of zero measure sets -- then use a Dirac mass or something arbitrary if it is nonempty. If if is empty, unfortunately, there is no way out.</p>",
        "id": 401706126,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1699862336
    },
    {
        "content": "<p>It's going to be really annoying if I have to submit a certificate of non-emptiness every time I want to invoke conditioning to an event.  The other option I was thinking of was to work with measures that are either probability measures or zero (with conditioning defined to produce the zero measure if the event has zero probability, and in particular is empty) and have some side lemmas to the effect that the conditioned measure is still a probability measure if the event conditioned to had positive probability.  Not a great solution but the best I can come up with so far.</p>",
        "id": 401707033,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699862679
    },
    {
        "content": "<p>Hmm, maybe I should work with a <code>FiniteMeasureSpace</code> class with an additional <code>isProbabilitySpace</code> attribute that is preserved in \"good\" cases but can be lost in \"bad\" operations such as conditioning to the empty set.  A bit unintuitive, but might be manageable.</p>",
        "id": 401707823,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699863020
    },
    {
        "content": "<p>You can just define the induced measure as the restricted measure divided by <code>ℙ E</code> (so you get a <code>MeasureSpace</code> instance on the subtype), register an instance that it's always a finite measure, and register another instance saying that it's a probability measure under the assumption <code>Fact (0 &lt; ℙ E)</code>.</p>",
        "id": 401707877,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1699863041
    },
    {
        "content": "<p>We have already classes <code>isFiniteMeasure μ</code> and <code>isProbabilityMeasure μ</code> for this.</p>",
        "id": 401708006,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1699863091
    },
    {
        "content": "<p>Yeah OK I think I will try this.  Good thing I only just got started on this project, this would have been much more of a pain if I had realized I had to do this refactoring a thousand lines of code into the project.</p>",
        "id": 401708196,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699863152
    },
    {
        "content": "<p>Ah and now I don't have to futz around with completely artificial Dirac measures either (using a Classical choice function or something to select the location of the mass).</p>",
        "id": 401708475,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699863243
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/401707877\">said</a>:</p>\n<blockquote>\n<p>You can just define the induced measure as the restricted measure divided by <code>ℙ E</code> (so you get a <code>MeasureSpace</code> instance on the subtype), register an instance that it's always a finite measure, and register another instance saying that it's a probability measure under the assumption <code>Fact (0 &lt; ℙ E)</code>.</p>\n</blockquote>\n<p>That normalized restricted measure can be obtained with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ProbabilityTheory.cond#doc\">docs#ProbabilityTheory.cond</a></p>",
        "id": 401708520,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1699863252
    },
    {
        "content": "<p>Except that <code>cond</code> is a measure on the whole space, not on the subtype.</p>",
        "id": 401708756,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1699863341
    },
    {
        "content": "<p>Here is a rough sketch of what it could look like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Probability.StrongLaw</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Probability.ConditionalProbability</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">MeasureTheory.Measure.Subtype.measureSpace</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">MeasureTheory</span> <span class=\"n\">ProbabilityTheory</span> <span class=\"n\">ENNReal</span> <span class=\"n\">NNReal</span>\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Subtype.probSpace</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MeasureSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">MeasureSpace</span> <span class=\"n\">E</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"n\">Measure.comap</span> <span class=\"n\">Subtype.val</span> <span class=\"o\">(</span><span class=\"n\">ProbabilityTheory.cond</span> <span class=\"n\">ℙ</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">local</span> <span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">Subtype.probSpace</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MeasureSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">IsFiniteMeasure</span> <span class=\"o\">(</span><span class=\"n\">ℙ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">IsFiniteMeasure</span> <span class=\"o\">(</span><span class=\"n\">ℙ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">Ω</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ℙ</span> <span class=\"n\">E</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">IsProbabilityMeasure</span> <span class=\"o\">(</span><span class=\"n\">ℙ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Integrable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">Integrable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">IsProbabilityMeasure</span> <span class=\"o\">(</span><span class=\"n\">ℙ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">Ω</span><span class=\"o\">)]</span>\n\n<span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 401710309,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1699863839
    },
    {
        "content": "<p>I am trying this approach but I get into issues with lemmas about that comap of Subtype.val asking for <code>MeasurableSet E</code>, which is not something the instance mechanism will find on its own.</p>",
        "id": 401710895,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1699864006
    },
    {
        "content": "<p>Right. One would need to add a <code>[Fact (MeasurableSet E)]</code> in addition to <code>[Fact (0 &lt; ℙ E)]</code>.</p>",
        "id": 401711291,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1699864121
    },
    {
        "content": "<p>Yes. I worry that the experience with this will not be very smooth, because we never use measurability as a <code>Fact</code> anywhere in the library, but I don't see another way.</p>",
        "id": 401711631,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1699864213
    },
    {
        "content": "<p>(Personally, to avoid dependent type hell, I would probably try to work on the original space as much as possible, with the families of measures <code>cond E</code> over varying <code>E</code> -- but only experimentation can tell what works best).</p>",
        "id": 401711639,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1699864217
    },
    {
        "content": "<p>OK, I think this is how I will start, using a sort of \"ProbabilitySpacesWithZero\" type, which is a <code>MeasureSpace</code> equipped with a raw finite measure <code>volume</code>, which may possibly vanish.  The actual measure used in applications will be the normalized measure in which one divides <code>volume</code> by its total mass; this will usually be a probability measure, except when <code>volume</code> is zero, in which case one gets the zero measure instead.  To condition to an event, one simply restricts the raw measure to the event; no need to perform additional normalization, and now conditioning to empty events works just fine.  I got as far as making the barest definitions below; I am intrigued by the idea of making conditional instances of <code>ProbabilityMeasure</code> contingent on a nondegeneracy condition, but will try to work this out later.  Tentatively I think a lot of the foundational theory I wanted to build for probability spaces will also work for probability spaces with zero, with only an occasional additional hypothesis of nondegeneracy needed in various places.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"sd\">/-- In this project, a ProbabilitySpace is modeled by a MeasureSpace with a finite volume measure that can potentially vanish.  The probability measure is then the normalization of this probability measure, bearing in mind that it may be zero. Thus we also consider a measure space with the zero measure to be a (degenerate) example of a ProbabilitySpace-/</span>\n<span class=\"kd\">class</span> <span class=\"n\">ProbabilitySpace</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">MeasureSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">,</span> <span class=\"n\">IsFiniteMeasure</span> <span class=\"n\">volume</span>\n\n<span class=\"sd\">/-- The raw, unnormalized measure.  Would only be directly used in foundational lemmas typically. --/</span>\n<span class=\"kd\">def</span> <span class=\"n\">ProbabilitySpace.rawMeasure</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ProbabilitySpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"n\">volume</span>\n\n<span class=\"sd\">/-- The raw measure interpreted as a finite measure. Again, only used in foundational lemmas. --/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simps</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">lemmasOnly</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">ProbabilitySpace.rawFiniteMeasure</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ProbabilitySpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">FiniteMeasure</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">volume</span><span class=\"o\">,</span> <span class=\"n\">inferInstance</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/-- The total mass of the raw measure. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">ProbabilitySpace.rawMass</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ProbabilitySpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">NNReal</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ProbabilitySpace.rawFiniteMeasure</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"n\">Set.univ</span>\n\n<span class=\"sd\">/-- The assertion that a probability space is nondegenerate. --/</span>\n<span class=\"kd\">def</span> <span class=\"n\">ProbabilitySpace.isNondeg</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ProbabilitySpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ProbabilitySpace.rawMass</span> <span class=\"bp\">Ω</span>\n\n<span class=\"sd\">/-- The normalized measure associated to a probability space -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">ProbabilitySpace.measure</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ProbabilitySpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ProbabilitySpace.rawMass</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">•</span> <span class=\"n\">volume</span>\n\n<span class=\"sd\">/-- The normalized finite measure associated to a probability space -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">ProbabilitySpace.finiteMeasure</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ProbabilitySpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">FiniteMeasure</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ProbabilitySpace.rawMass</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">•</span><span class=\"o\">(</span><span class=\"n\">ProbabilitySpace.rawFiniteMeasure</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- prob Ω E is the probability of E in Ω. -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">ProbabilitySpace.prob</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ProbabilitySpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ProbabilitySpace.finiteMeasure</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"n\">E</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"s2\">\"P[ \"</span> <span class=\"n\">E</span> <span class=\"s2\">\" ]\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ProbabilitySpace.prob</span> <span class=\"n\">E</span>\n</code></pre></div>",
        "id": 401786913,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699889118
    },
    {
        "content": "<p>There is no point in your class <code>ProbabilitySpace</code>: you could (should?) just write <code>[MeasureSpace Ω] [IsFiniteMeasure (volume : Measure Ω)]</code>. I guess you would prefer to have one single assumption instead of two for psychological reasons, but in practice it doesn't make any difference. These assumptions will typically be in a <code>variable</code> block in the top of your file, written there once and for all, so they won't clutter your statements.</p>\n<p>In the same way, the standard way to invoke a real Banach space is <code>[NormedAddCommGroup E] [NormedSpace ℝ E] [CompleteSpace E]</code>. We could have introduced a shortcut <code>[RealBanachSpace E]</code>, but in fact there is no point in doing so (although it took us collectively some time to become convinced of this).</p>",
        "id": 401789210,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1699889682
    },
    {
        "content": "<p>I'm still not convinced of this - I think there should be a way to write <code>[RealBanachSpace E]</code> that indeed does expand to what we usually write. I think there was some progress to do this automatically via <code>variables!/?</code>, did <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> talk about this recently?</p>",
        "id": 401789677,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1699889790
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/401789210\">said</a>:</p>\n<blockquote>\n<p>There is no point in your class <code>ProbabilitySpace</code>: you could (should?) just write <code>[MeasureSpace Ω] [IsFiniteMeasure (volume : Measure Ω)]</code>. I guess you would prefer to have one single assumption instead of two for psychological reasons, but in practice it doesn't make any difference. These assumptions will typically be in a <code>variable</code> block in the top of your file, written there once and for all, so they won't clutter your statements.</p>\n</blockquote>\n<p>I'm <em>not</em> going to be working with a single probability space and a single measure; there will be a <em>lot</em> of them.  A typical thing that will happen for instance in my application is that I will start with two random variables <code>X</code>, <code>Y</code> on a probability space <code>Ω</code> with some raw measure <code>volume</code>, and I will start to need to consider the conditioned random variables <code>(X|Y=y)</code> defined on a conditioned probability space <code>Y⁻¹'({y})</code> with the restricted volume measure (and later, I will be taking conditional independent trials, and other various constructions).  I can't just choose a single ambient sample space and set it as a global <code>variable</code>, and so with the orthodox approach I <em>am</em> going to encounter a lot of clutter in my notation.  For instance, I will frequently be summing over <code>y</code> expressions such as <code>P [ Y = y ] H[ X | Y = y ]</code> that involve random variables on different probability spaces (I am vaguely worried about the \"dependent type hell\" alluded to earlier that this will entail, but I will cross that bridge when I come to it).</p>",
        "id": 401793009,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699890584
    },
    {
        "content": "<p>The single variable line at the top, together with instances saying that the measure induced on a subtype is finite if the initial one is finite, should likely be enough for the setting you are describing. </p>\n<p>This is probably clear to you, but let me emphasize this. Assume that at the top of your file you have a line</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MeasureSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsFiniteMeasure</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">Ω</span><span class=\"o\">)]</span>\n</code></pre></div>\n<p>then you prove a lemma <code>foo</code> about <code>Ω</code>, and then you want to prove another lemma <code>bar</code> which, in the course of the proof, will use <code>foo</code> but on a subtype of <code>Ω</code>. Then your lemma <code>foo</code> will apply perfectly well, even though it's not to the same <code>Ω</code>: once <code>foo</code> is proved, it will apply to any finite measure space you will ever encounter.</p>",
        "id": 401795352,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1699891104
    },
    {
        "content": "<p>It's not the lemmas so much that I'm thinking about, but the notation, and in particular my desire to not label probabilistic notation such as probability <code>P[ ]</code> or Shannon entropy <code>H[ ]</code> with explicit measures.</p>\n<p>Here is a specific use case I have in mind.  At some point I will prove the Shannon inequality <code>H[ X, Y ] ≤ H[ X ] + H[ Y ]</code> whenever <code>X : Ω → S</code>,  <code>Y : Ω → T</code> are two random variables (taking values in some finite sets <code>S T</code>).  From this inequality I want to deduce the conditional counterpart <code>H[ X, Y | Z ] ≤ H[ X | Z ] + H[ Y | Z ]</code>, where <code>Z : Ω → U</code> is some further random variable.  The natural way to do this is to expand <code>H[ X, Y | Z ] = ∑ z : U, P[ Z = z ] * H[ X, Y | Z = z ]</code>, and similarly for <code>H[ X | Z ]</code> and <code>H[ Y | Z ]</code>.  One then applies the unconditional Shannon inequality for the conditioned random variables <code>(X | Z = z)</code>, <code>(Y | Z = z)</code> for each <code>z : U</code>, and then the conditional inequality will follow from <code>gcongr</code>.  Note here it will be convenient to permit conditioning even if the event <code>Z=z</code> has zero measure.  </p>\n<p>In expressions such as <code>∑ z : U, P[ Z = z ] * H[ X, Y | Z = z ]</code>, multiple probability spaces and probability measures are in play, and I would prefer to not have to explicitly note all this data in my notation.  I believe that a <code>ProbabilitySpace</code> class will handle this nicely (for instance, the <code>P[ ]</code> notation already defined does not make explicit reference to the measure).  I don't see how to easily express assertions such as <code>H[ X, Y | Z ] = ∑ z : U, P[ Z = z ] * H[ X, Y | Z = z ]</code> in a lemma just using global <code>variable</code>s.</p>",
        "id": 401798658,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699891811
    },
    {
        "content": "<p>The <code>ProbabilitySpace</code> class is exactly equivalent to the two assumptions <code>MeasureSpace</code> and <code>IsFiniteMeasure volume</code>. Whenever you expect that Lean will be able to infer <code>ProbabilitySpace</code> using typeclass inference, it would also be able to infer <code>MeasureSpace</code> and <code>IsFiniteMeasure volume</code>. I am not saying that the <code>ProbabilitySpace</code> approach is bad, I'm saying that it is completely equivalent to the <code>[MeasureSpace ...] [IsFiniteMeasure ...]</code> approach.</p>",
        "id": 401801289,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1699892349
    },
    {
        "content": "<p>How can I make the notation <code>P[ E ]</code> work without explicit reference to a probability measure if I am using the <code>[Measure space ...] [IsFiniteMeasure ...]</code> approach with multiple probability spaces in play even on the same line?</p>\n<p>e.g. <code>P[ E ∧ F ] = P[ F ] * P [ E | F ]</code> where <code>E | F</code> should be interpreted as the event <code>E</code> restricted to the probability subspace <code>F</code> endowed with the conditional probability measure.</p>",
        "id": 401801945,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699892489
    },
    {
        "content": "<p>When you write <code>P [E]</code> where <code>E</code> is a set in some type <code>α</code>, then Lean will understand that you want to use the canonical volume on <code>α</code>. It will then look for a <code>MeasureSpace α</code> instance. Either this one is available in the variables line, or it can be constructed from other instances. For example, if you have registered that a subtype of a <code>MeasureSpace</code> is also a <code>MeasureSpace</code>, then Lean will use this instance, and construct the measure you are looking for from the ambient measure.</p>",
        "id": 401804016,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1699892981
    },
    {
        "content": "<p>OK.  I still think I prefer to package it conceptually as a single package, similar to how for instance <code>[Group ...]</code> is not commonly deconstructed into <code>[DivInvMonoid ...] [mul_left_inv ...]</code>.  (Also I get to manipulate probabilities as <code>NNReal</code>s rather than <code>ENNReal</code>s, which lets me avoid some annoying casting issues.)</p>",
        "id": 401804749,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699893185
    },
    {
        "content": "<p>If you want NNReals, you can still define:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The canonical measure `volume` as a probability measure -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simps</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">prob</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">MeasureSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsFiniteMeasure</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">Ω</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">ProbabilityMeasure</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">volume</span><span class=\"o\">,</span> <span class=\"n\">inferInstance</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 401805033,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699893262
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span>, do you think mathlib should have this definition?</p>",
        "id": 401805107,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699893283
    },
    {
        "content": "<p>No. <code>ProbabilityMeasure Ω</code> is for the case you want to study the set of all probability measures (with its topology for instance). If you just have one probability measure, it should be a normal measure to benefit from the huge API. What we should definitely have is a way (either notation or definition) to access the value of <code>P s</code> as a real number (or an NNReal), but this should be an API extension around <code>Measure</code>.</p>",
        "id": 401806177,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1699893623
    },
    {
        "content": "<p>Could you PR a docstring for <code>ProbabilityMeasure</code> advising the use of <code>IsProbabilityMeasure</code> in those cases instead?</p>",
        "id": 401807772,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699894168
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/401789677\">said</a>:</p>\n<blockquote>\n<p>I think there was some progress to do this automatically via <code>variables!/?</code>, did <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> talk about this recently?</p>\n</blockquote>\n<p>Unfortunately, the <code>variable?</code> mechanism is too simple here and fails because pretty printing isn't round tripping. (Yes, it needs to depend on pretty printing...) It seems to work if you set <code>pp.analyze</code> to true, but I wouldn't count on it, so I'll just say this doesn't work at the moment.</p>\n<p>The issue is that <code>IsFiniteMeasure (volume : Measure Ω)</code> pretty prints as <code>IsFiniteMeasure ℙ</code>, without reference to <code>Ω</code>.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>example</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Probability.Notation</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span> <span class=\"n\">ProbabilityTheory</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">ENNReal</span> <span class=\"n\">NNReal</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">variable_alias</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">ProbabilitySpace</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">MeasureSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsFiniteMeasure</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">Ω</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">variable</span><span class=\"bp\">?</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ProbabilitySpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Can not satisfy requirements for [IsFiniteMeasure ℙ] due to metavariables.</span>\n\n<span class=\"cm\">(Use `set_option trace.variable? true` for step-by-step details.)</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c1\">-- This actually works:</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.analyze</span> <span class=\"n\">true</span>\n<span class=\"kd\">variable</span><span class=\"bp\">?</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ProbabilitySpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span>\n<span class=\"c1\">-- It fails if you do `Type*`, but that's a bug in `variable?`.</span>\n</code></pre></div>\n</div></div>",
        "id": 401817845,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1699897926
    },
    {
        "content": "<p>What if you don't <code>open scoped ProbabilityTheory</code>? [terribly unsatisfactory, I know]</p>",
        "id": 401828992,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1699902655
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> I am interested in where your adventures in probability in Lean take you (I have run into some difficulties in it before - actually, at that time as it happens I was using your published set of notes on elementary probability theory as a handy guide, which were very useful!)</p>\n<p>In cryptography the situation is even worse than in mainstream mathematics, because there people use probability all the time and they don't even pretend to think about the fact that there's a measure underneath. A nightmare when you try to formalise! But so it goes.</p>",
        "id": 402731048,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700237477
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/402731048\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> I am interested in where your adventures in probability in Lean take you (I have run into some difficulties in it before - actually, at that time as it happens I was using your published set of notes on elementary probability theory as a handy guide, which were very useful!)</p>\n<p>In cryptography the situation is even worse than in mainstream mathematics, because there people use probability all the time and they don't even pretend to think about the fact that there's a measure underneath. A nightmare when you try to formalise! But so it goes.</p>\n</blockquote>\n<p>In the end we used the standard Mathlib <code>MeasurableSpace</code> and <code>Measure</code> packages in our project; see <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/mathlib-only.20approach.20to.20entropy\">https://leanprover.zulipchat.com/#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/mathlib-only.20approach.20to.20entropy</a> .  The one thing was we permitted the underlying measure to not be a probability measure, but when defining probabilistic notions (such as entropy) we first normalized the measure to be a probability measure (or to be the zero measure, if the underlying measure had zero or infinite mass).  This for instance made conditioning, even to an empty event, straightforward; one simply restricts the underlying measure.  In a way this models \"Probability spaces with zero\", but it seems a lot of probability theory survives if one allows for the possibility that the probability measure actually vanishes.</p>",
        "id": 402731634,
        "sender_full_name": "Terence Tao",
        "timestamp": 1700237667
    },
    {
        "content": "<p>Thanks, I'll give that a read. Interesting that it works out that way. In cryptography I've sometimes seen a use of sub-probability measures, which one doesn't encounter that often in a first study of probability but I imagine would slot in fairly effortlessly using that approach, as most of the time it wouldn't be relevant.</p>",
        "id": 402733887,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700238451
    },
    {
        "content": "<p>Subprobability measures also occasionally show up in analysis, because the weak limit of a probability measure can be merely a subprobability measure if some of the mass \"escapes to infinity\".</p>",
        "id": 402735982,
        "sender_full_name": "Terence Tao",
        "timestamp": 1700239148
    },
    {
        "content": "<p>That makes sense. In a cryptography/algorithmic context, the escaped mass represents the fact that the probability that a program terminates at all is not one, so if your distribution is one of possible final states, you need to account for non-termination.</p>",
        "id": 402737579,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700239738
    },
    {
        "content": "<p>When working in cryptography, using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PMF#doc\">docs#PMF</a> seems like a good option, since all the spaces you work over will be finite/discrete anyway, and you avoid needing to work with measures at all.</p>",
        "id": 403300295,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1700540981
    },
    {
        "content": "<p>See you'd think they'd be finite but alas.</p>",
        "id": 403338190,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700559240
    },
    {
        "content": "<p>But yeah I think that's basically the way to go.</p>",
        "id": 403338329,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700559276
    },
    {
        "content": "<p>The issue I find is that cryptographers are not very rigorous in their use of probability...</p>",
        "id": 403338414,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700559300
    },
    {
        "content": "<p>Also you do get applications where you discretise continuous distributions.</p>",
        "id": 403338873,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700559394
    },
    {
        "content": "<p>I think it might be worth having an API for finite discrete probability anyway. For most CS, people are going to be working with Fintypes, Finsets etc, and it gets very tedious when working with coercions and such all the time.</p>",
        "id": 403341295,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700559990
    },
    {
        "content": "<p>If nothing else, it will be a nice way to show CS people how to do their day to day proofs in lean. Invoking measure theory is a bad idea for that use case.</p>",
        "id": 403342382,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700560275
    },
    {
        "content": "<p>I agree, I've said this many many many times before.</p>",
        "id": 403346256,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700561244
    },
    {
        "content": "<p>Every time I suggest it I get told it's a bad idea ;)</p>",
        "id": 403346290,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700561255
    },
    {
        "content": "<p>I actually wrote most of one once</p>",
        "id": 403346322,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700561270
    },
    {
        "content": "<p>To be fair one of the issues is that you do get little wrinkles which are hard to resolve.</p>",
        "id": 403346499,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700561327
    },
    {
        "content": "<p>As I recall I based it on FinSupp?</p>",
        "id": 403346660,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700561382
    },
    {
        "content": "<p>Though the fact that that is noncomputable might make it annoying for many applications.</p>",
        "id": 403350120,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700562492
    },
    {
        "content": "<p>I started writing one three days ago</p>",
        "id": 403351612,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700562980
    },
    {
        "content": "<p>I want to have a discrete math library that picks and chooses what we want from mathlib</p>",
        "id": 403351660,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700563002
    },
    {
        "content": "<p>I started with probability theory</p>",
        "id": 403351848,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700563061
    },
    {
        "content": "<p>The biggest issues I have encountered so far come from coercions</p>",
        "id": 403351913,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700563082
    },
    {
        "content": "<p>I guess I can share this \"library\" (it is too new, contains very little, and I am not too confident about my design choices) since it isn't connected to any of my ongoing work projects.</p>",
        "id": 403352718,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700563375
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/403346290\">said</a>:</p>\n<blockquote>\n<p>Every time I suggest it I get told it's a bad idea ;)</p>\n</blockquote>\n<p>I think it would be a bad idea to develop the theory of probability twice in parallel, once for finite spaces and once in general.<br>\nHowever, it might be a good idea to have definitions specific to finite spaces that are more easily usable than the general ones, provided that whenever possible the proofs of their properties are done by applying the more general results.</p>",
        "id": 403353318,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1700563582
    },
    {
        "content": "<p>Yes, I agree it shouldn't exist in parallel, but I seemed to recall some resistance to even that before.</p>",
        "id": 403353483,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700563646
    },
    {
        "content": "<p>I totally agree with that approach.</p>",
        "id": 403353533,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700563664
    },
    {
        "content": "<p>Remy the issue is, TCS culture is very different from  research math culture. If I tell TCS folks that they can prove something but there is just this hitch with coercions and measurability they'll lose interest</p>",
        "id": 403353543,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700563667
    },
    {
        "content": "<p>Yeah, as someone who sits awkwardly astride the two, I also agree with that.</p>",
        "id": 403353727,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700563721
    },
    {
        "content": "<p>Also, we work a lot with interconnected horizontal abstractions rather than vertical abstractions.</p>",
        "id": 403353772,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700563739
    },
    {
        "content": "<p>We do have an InformationTheory folder currently in Mathlib but it really only contains my definitions for a Hamming space. In an ideal world where I have infinite money and time to organise us that is where I would like to put the TCS-world stuff.</p>",
        "id": 403354005,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700563816
    },
    {
        "content": "<p>What would probably be good in general is a work plan, to work out what abstractions and content we would need. But this is moving away from the topic of this thread.</p>",
        "id": 403354151,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700563868
    },
    {
        "content": "<p>I find that in CS, the best way to start something is to not plan too much</p>",
        "id": 403354549,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700564005
    },
    {
        "content": "<p>(which is a bit ironic)</p>",
        "id": 403354580,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700564018
    },
    {
        "content": "<p>Here's the <a href=\"https://github.com/Shreyas4991/DiscreteMathLean\">repository</a>. I only started it this saturday. So it is brand new, has very little, and the few proofs it has could do with polishing.</p>",
        "id": 403360260,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700565934
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 403362150,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1700566656
    },
    {
        "content": "<p>Yes - I am not sure about some of your definitions. And if we <em>can</em> possibly build on the existing foundation, even if obscuring the measure-theoretic approach, that may be better.</p>\n<p>I am not sure why your \"prob\" function is part of the Probability class, because surely it is implied by <code>pmf</code>. Or vice versa, if you like.</p>",
        "id": 403375563,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700571470
    },
    {
        "content": "<p>Yes that's true. I'll change that. My immediate goal is to get to a point where I can talk about concentration bounds easily. I am really looking forward to that inequality rewriting tactic to make life simpler</p>",
        "id": 403376336,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700571713
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"350992\">Rémy Degenne</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/403353318\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/403346290\">said</a>:</p>\n<blockquote>\n<p>Every time I suggest it I get told it's a bad idea ;)</p>\n</blockquote>\n<p>I think it would be a bad idea to develop the theory of probability twice in parallel, once for finite spaces and once in general.<br>\nHowever, it might be a good idea to have definitions specific to finite spaces that are more easily usable than the general ones, provided that whenever possible the proofs of their properties are done by applying the more general results.</p>\n</blockquote>\n<p>I think I found the perfect counter argument to this. A few years ago, in the linked message and a few preceding messages <a href=\"#narrow/stream/116395-maths/topic/Univalence/near/190540494\">Kevin was explaining how words like \"constructivisim\" or \"different types of equality\" are complete anathema to working mathematicians</a> . An analogous argument applies in the case of most theoretical CS folks for functional analysis / measure theory /infinite graphs or anything more advanced than very basic abstract algebra. Although a fraction of the community working in ML theory is quite comfortable with measure theoretic analysis and many of us have math backgrounds, just uttering those words could be enough to send most people  in an algorithms or complexity theory group running away (jokes aside they'll ask you to describe stuff in elementary ways). Most of the math we work with can be taught to students right out of high school.</p>",
        "id": 403996229,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700843982
    },
    {
        "content": "<p>This is why I think a discrete probablility class is not a bad idea, although I can see that it is not a great value-add to Mathlib</p>",
        "id": 403996305,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700844005
    },
    {
        "content": "<p>Developing the same thing twice can be very expensive; here it could mean some combination of:</p>\n<ul>\n<li>every probability theory contributor now has to do twice as much work, resulting in fewer contributions</li>\n<li>probability theory users find gaps in the API twice as often</li>\n<li>Maintainers have to manage increasingly diverging APIs</li>\n</ul>",
        "id": 404005423,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700849332
    },
    {
        "content": "<p>I get why this is not going to work for Mathlib. Hence the proposal and initiation of a complementary library from the discrete math side, that puts the needs of TCS people first, but picks and chooses from Mathlib as required.</p>",
        "id": 404005779,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700849585
    },
    {
        "content": "<p>I think building a simplified interface that sits atop mathlib would be a very reasonable idea for a downstream project</p>",
        "id": 404005894,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700849660
    },
    {
        "content": "<p>It is not about the technical aspect. I have learnt from first hand experience that I cannot sell this to theoreticians unless they see that they can do proofs in their way.</p>",
        "id": 404005939,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700849719
    },
    {
        "content": "<p>I like this idea, particularly if it comes with some <code>example</code> code that people not already expert in Lean can start playing with immediately.</p>",
        "id": 404008254,
        "sender_full_name": "Terence Tao",
        "timestamp": 1700851357
    },
    {
        "content": "<p>I outlined some heuristics for such a library in the README here: <a href=\"https://github.com/Shreyas4991/DiscreteMathLean\">https://github.com/Shreyas4991/DiscreteMathLean</a> </p>\n<p>I like the idea of having such examples and will add it to the aims. I only started it last Saturday and have not spent more than 2 hours with it, so there isn't much content yet.</p>",
        "id": 404011218,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700853519
    },
    {
        "content": "<p>Some of the methods in <a href=\"https://teorth.github.io/pfr/docs/PFR/Entropy/Measure.html\">https://teorth.github.io/pfr/docs/PFR/Entropy/Measure.html</a> could be useful for this library, e.g., <a href=\"https://teorth.github.io/pfr/docs/find/?pattern=integral_eq_sum#doc\">pfr#integral_eq_sum</a> and <a href=\"https://teorth.github.io/pfr/docs/find/?pattern=ae_iff_of_fintype#doc\">pfr#ae_iff_of_fintype</a></p>",
        "id": 404011737,
        "sender_full_name": "Terence Tao",
        "timestamp": 1700853864
    },
    {
        "content": "<p>Those results probably belong in mathlib itself</p>",
        "id": 404017885,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700858522
    },
    {
        "content": "<p>Yeah I'm not really sure about a library that depends on Mathlib but is separate to it. I would much rather have discrete maths in Mathlib, which we can do, and this still doesn't stop theoreticians doing \"proofs in their way\".</p>",
        "id": 404356689,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701072476
    },
    {
        "content": "<p>Clearly mathlib needs to eventually have a defined scope, but I would find it very disheartening if something like a usable API for discrete probability is considered to be outside it. </p>\n<p>It would be telling everyone working in discrete probability (which is hardly a niche area) that 'mathlib is not for you', and forcing an API to exist in some other project, which is just kicking the 'parallel API' problem can down the road. </p>\n<p>To me this would be like dropping linear algebra support for matrices in mathlib because everything is just a linear map.</p>",
        "id": 406337834,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1701878750
    },
    {
        "content": "<p>I think mathlib developers do want a discrete probability API. So what you point out is already not an issue.</p>\n<p>They just want it to be a front end to the measure theoretic version. It will take a lot of API development before a discrete math person can stay entirely in the discrete world with the API.  So if a TCS (theoretical CS) person comes up with the purely discrete argument for a probability lemma, it is not clear if <br>\na) Mathlib will want that proof as opposed to a more general proof <br>\nb) The TCS person will want to invest effort into this more general proof when we don't need it at all. <br>\nThis also applies to theorems in graphs where infinite graphs are involved for another example.</p>",
        "id": 406341357,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1701879902
    },
    {
        "content": "<p>I think the thing mathlib would want to avoid is an API for discrete probability that is not connected to the rest of the library. I would hope that we could create a usable API that is connected</p>",
        "id": 406341407,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701879916
    },
    {
        "content": "<p>Thanks, those comments clarify things. Perhaps being lenient in accepting PRs where (a) might apply would mitigate some of the problems. </p>\n<p>An existing example that springs to mind is <code>Matrix.rank_transpose</code>, which is clearly there in insufficient generality, but is better than nothing.</p>",
        "id": 406342133,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1701880148
    },
    {
        "content": "<p>I think insufficiently general results are much less of a problem than insufficiently general definitions</p>",
        "id": 406558585,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701960516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/406558585\">said</a>:</p>\n<blockquote>\n<p>insufficiently general definitions</p>\n</blockquote>\n<p>That's basically most of TCS if \"sufficiently\" is defined from a pure math perspective.</p>",
        "id": 406561804,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1701961399
    },
    {
        "content": "<p>As well as a lot of discrete maths. </p>\n<p><code>SimpleGraph</code> is certainly an insufficiently general definition (the clue is in ‘Simple’!). There is already a good amount of stuff in the API (eg paths) that really should be defined in at least the multigraph setting, and generalizing isn’t just a matter of flipping a switch.</p>\n<p>I think the genuine problem is partly nothing to do with formalization - it’s that if you go to a graph theory conference and ask everyone what a graph is, you’ll get answers that are not just cosmetically different, but inequivalent. </p>\n<p>I don’t know if this problem is peculiar to combinatorics, but it clearly hasn’t been resolved. If there were an obvious way to define a combinatorial object that contains multigraphs and hypergraphs that didn’t have significant tradeoffs, I’d have tried to PR it.</p>",
        "id": 406926726,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1702122537
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> and I have been thinking about this specific problem quite a lot, and we have a solution for multigraphs (not including hypergraphs). It's currently stuck on small technicalities.</p>",
        "id": 406927123,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702122817
    },
    {
        "content": "<p>I have had similar issues with defining linear codes.</p>",
        "id": 406960889,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1702145981
    },
    {
        "content": "<p>In theory this is very easy.</p>",
        "id": 406960895,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1702145987
    },
    {
        "content": "<p>In practice there are just a number of little technical hitches and different definitions that trying to find something that lies flat is very frustrating!</p>",
        "id": 406960963,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1702146014
    }
]