[
    {
        "content": "<p>I recently had need of the following lemma regarding subsets of <code>Fin (N+1)</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Iio</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">erase</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">castSucc</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Iio</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">castSucc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">&lt;-</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">map_inj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">valEmbedding</span><span class=\"o\">)]</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">map_valEmbedding_Iio</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">coe_castSucc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">map_erase</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">val_succ</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Iic_erase</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>Perhaps one could add this lemma to Mathlib, but that's not my main concern here (I imagine this particular lemma might only have a niche use).  I was wondering instead if it is worth developing some general <code>nify</code> tactic (similar to <code>rify</code>, <code>zify</code>, or <code>qify</code>, that converts statements concerning elements (as well as sets and Finsets) in <code>Fin</code> types into equivalent statements regarding their analogues in <code>ℕ</code>; in the example above, this hypothetical tactic would basically automatically perform the first two lines of the given proof.  I'm not sure if this would be widely useful though.  (I needed it because I chose to work with various sums over <code>Fin N</code>, which I was using to index a finite sequence of objects.  It's possible that I could have avoided some technicalities by indexing over a more general <code>Finset</code> instead, but the <code>Fin</code> API was reasonably adequate for my purposes, except for missing the above lemma.  My initial attempt to prove the lemma from first principles was absolutely disgusting; it was only after realizing that one should map everything through <code>Fin.valEmbedding</code> that the above short proof became apparent.  So I was wondering whether one could formalize this general strategy as a tactic.)</p>\n<p>EDIT: okay, it turns out for my example that actually the conversions were unnecessary, so maybe the suggestion is not a good one...</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Iio_of_succ_eq_Iic_of_castSucc</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Iio</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Iic</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">castSucc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Iio</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">erase</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">castSucc</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Iio</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">castSucc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Iio_of_succ_eq_Iic_of_castSucc</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- this line seems necessary despite being proven by `rfl`</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Iic_erase</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>It can also be golfed to a one-line proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Iio</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">erase</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">castSucc</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Iio</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">castSucc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Iic_erase</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">castSucc</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 465252528,
        "sender_full_name": "Terence Tao",
        "timestamp": 1724697838
    },
    {
        "content": "<p>My first reaction is that this would make sense to have, though it would be good to figure out what <code>nify</code> should be expected to do. With <code>zify</code> and <code>qify</code>, the main obstructions they work with are (1) turning nat subtraction into int subtraction and (2) turning int division into rational division. What hypotheses could <code>nify</code> work with to turn Fin operations into Nat operations? I suppose it could the obvious ones, for example if <code>a * b &lt; n</code> then you can \"nify\" the <code>*</code>.</p>",
        "id": 465254189,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724698500
    }
]