[
    {
        "content": "<p>In math, we regularly write (imprecise) things like: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi><mo>+</mo><mover accent=\"true\"><mi>z</mi><mo>ˉ</mo></mover><mo>=</mo><mn>2</mn><mi mathvariant=\"normal\">ℜ</mi><mi>z</mi></mrow><annotation encoding=\"application/x-tex\"> z + \\bar z = 2 \\Re z </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5678em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5678em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1944em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">2ℜ</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span></span>, where <span class=\"tex-error\">$$ z \\in \\C $$</span>. It's imprecise because do I want this equation to be interpreted over <span class=\"tex-error\">$$\\C$$</span>, or am I implicitly applying some coercion to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> on the left, with a proof that the imaginary part is zero, etc. What's the \"right\" way in mathlib to deal with such issues? For example, one can show:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- simp -- does nothing</span>\n  <span class=\"c1\">-- exact? -- fails</span>\n  <span class=\"n\">ext</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Complex.add_re</span><span class=\"o\">,</span> <span class=\"n\">Complex.conj_re</span><span class=\"o\">]</span>\n    <span class=\"n\">ring_nf</span>\n    <span class=\"n\">simp</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Complex.add_im</span><span class=\"o\">,</span> <span class=\"n\">Complex.conj_im</span><span class=\"o\">]</span>\n    <span class=\"n\">ring_nf</span>\n    <span class=\"n\">simp</span>\n</code></pre></div>\n<p>This of course coerces the right side to <span class=\"tex-error\">$$\\C$$</span>, so it can be compared with the left side. Note that <code>simp</code> and <code>exact?</code> fail (but copilot completes the proof by itself!... after suggesting the ugly <code>ext</code>...)</p>\n<p>Similarly, one can write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- exact? -- fails</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Complex.add_re</span><span class=\"o\">,</span> <span class=\"n\">Complex.conj_re</span><span class=\"o\">]</span>\n  <span class=\"n\">ring</span>\n</code></pre></div>\n<p>but this is not the \"spirit\" of the math version, because I shouldn't be taking real parts on the left, I should be doing some coercion together with a proof that the imaginary part is zero. What's the \"right\" way to express such ideas, and what tactics make it all work?... Thanks!</p>",
        "id": 389298247,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1693955058
    },
    {
        "content": "<p>I'm not necessarily saying this is the \"best\" way, but if you wanted, you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=realPart#doc\">docs#realPart</a> instead of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Complex.re#doc\">docs#Complex.re</a>. This is <code>(z + conj z) / 2 : ℝ</code> (modulo fiddly details).</p>",
        "id": 389298705,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1693955340
    },
    {
        "content": "<p>Maybe <code>z + conj z = (2 * z.re :)</code> (which should be the same as <code>z + conj z = (2 * z.re : ℝ)</code> here) captures the idea better than <code>z + conj z = 2 * z.re</code>? This is saying that <code>z + conj z</code> lies in the image of the coercion from <code>ℝ</code> by giving an explicit witness.</p>",
        "id": 389299061,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693955526
    },
    {
        "content": "<p>For example, this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Module</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">ComplexStarModule</span> <span class=\"n\">ComplexConjugate</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">ℜ</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_add</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 389299396,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1693955705
    },
    {
        "content": "<p>The <code>norm_cast</code> tactic by the way should be able to \"real-ize\" expressions and equalities that are morally real, by pushing the cast outward as far as possible. (I think I don't really understand the question actually. Maybe Jireh's suggestion gets at it better.)</p>",
        "id": 389299750,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693955904
    },
    {
        "content": "<p>I have no good solution but this is definitely something we need to think about, it makes working with Hilbert spaces quite annoying for bad reasons sometimes</p>",
        "id": 389300675,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1693956494
    },
    {
        "content": "<p>Sorry, I realized what I said was kind of stupid, but I'll try to have a better answer later.</p>",
        "id": 389314140,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1693963006
    },
    {
        "content": "<p>Not sure how relevant this is to your case, but I recently had to formalise a bunch of inequalities between real numbers, whose intermediate steps involved manipulating complex number expressions. The only way I've found to formalise those is by talking about the norm of the coercion of the LHS being smaller than some sum of norms being equal to the RHS.</p>",
        "id": 389321077,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1693966343
    },
    {
        "content": "<p>Obviously this isn't simpler than what you had, but I think these additional declarations are things we would probably want, and once we have those, the original result is quite simple. </p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Module</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">ComplexStarModule</span> <span class=\"n\">Complex</span> <span class=\"n\">ComplexConjugate</span>\n\n<span class=\"sd\">/-- The natural `ℝ`-linear equivalence between `selfAdjoint ℂ` and `ℝ`. -/</span>\n<span class=\"kd\">@[simps apply symm_apply]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Complex.selfAdjointEquiv</span> <span class=\"o\">:</span> <span class=\"n\">selfAdjoint</span> <span class=\"n\">ℂ</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">z</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span>\n  <span class=\"n\">invFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">conj_ofReal</span> <span class=\"n\">x</span><span class=\"o\">⟩</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">z</span> <span class=\"bp\">↦</span> <span class=\"n\">Subtype.ext</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">conj_eq_iff_re.mp</span> <span class=\"n\">z.property.star_eq</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Complex.coe_selfAdjointEquiv</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">selfAdjoint</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">selfAdjointEquiv</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">realPart_apply_coe</span><span class=\"o\">,</span> <span class=\"n\">selfAdjointEquiv_symm_apply</span><span class=\"o\">]</span>\n    <span class=\"n\">using</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">Subtype.val</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Complex.selfAdjointEquiv.left_inv</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">realPart_ofReal</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ℜ</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">realPart_apply_coe</span><span class=\"o\">,</span> <span class=\"n\">conj_ofReal</span><span class=\"o\">,</span> <span class=\"n\">star_def</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">two_smul</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)]</span>\n  <span class=\"n\">simp</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">imaginaryPart_ofReal</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℑ</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext1</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">conj_ofReal</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Complex.coe_realPart</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ℜ</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">nth_rw</span> <span class=\"mi\">1</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">re_add_im</span> <span class=\"n\">z</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">map_add</span><span class=\"o\">,</span> <span class=\"n\">AddSubmonoid.coe_add</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">smul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">realPart_I_smul</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">realPart_apply_coe</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"k\">calc</span>\n  <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">ℜ</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_add</span><span class=\"o\">]</span>\n  <span class=\"n\">_</span>          <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Complex.coe_realPart</span><span class=\"o\">]</span>\n</code></pre></div>\n</div></div>\n<p>Note that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=realPart#doc\">docs#realPart</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=imaginaryPart#doc\">docs#imaginaryPart</a> are relatively new, so the API is lacking. I have just written some additional bits which may be useful for other things that are not included above; I will PR them sometime soon.</p>\n<p>As for what is the appropriate way to phrase things. I think the first way is correct (<code>z + conj z = z.re</code>) although it takes place in <code>ℂ</code>. If you want it to take place in <code>ℝ</code>, then using <code>ℜ z</code> is at least one way to do it. For example, you can write with the above:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">selfAdjointEquiv</span> <span class=\"o\">(</span><span class=\"n\">ℜ</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span>\n  <span class=\"n\">ofReal_injective</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">selfAdjointEquiv_apply</span><span class=\"o\">,</span> <span class=\"n\">Complex.coe_realPart</span><span class=\"o\">,</span> <span class=\"n\">ofReal_re</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 389350496,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1693983624
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> what exactly are the issues you have encountered with Hilbert spaces?</p>",
        "id": 389350690,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1693983698
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252920\">@Alex Kontorovich</span> personally, I would probably stick with the first version you had. However, if you want an elementary proof that is close to what you might do on paper, consider this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"k\">calc</span>\n  <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">z.re</span> <span class=\"bp\">+</span> <span class=\"n\">z.im</span> <span class=\"bp\">*</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">z.re</span> <span class=\"bp\">+</span> <span class=\"n\">z.im</span> <span class=\"bp\">*</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"n\">_</span>          <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">z.re</span>                                   <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">re_add_im</span><span class=\"o\">,</span> <span class=\"n\">conj_ofReal</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">ring</span>\n</code></pre></div>\n<p>or, if you prefer to make Lean infer different things:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"k\">calc</span>\n  <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">_</span>        <span class=\"o\">:=</span> <span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">re_add_im</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">;</span> <span class=\"kd\">by</span> <span class=\"n\">congrm</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">h</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"bp\">$</span><span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"n\">_</span>          <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">re_add_im</span><span class=\"o\">,</span> <span class=\"n\">conj_ofReal</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">ring</span>\n</code></pre></div>\n<p>Note the use of the features of the new <code>congrm</code> tactic, which is super useful for things like this.</p>",
        "id": 389478222,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694018776
    },
    {
        "content": "<p>And no <code>ext</code> required!</p>",
        "id": 389478248,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694018787
    },
    {
        "content": "<p>Nobody has posted a thought-free proof (i.e. only use tactics, don't need to know any lemma names):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Module</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">ComplexStarModule</span> <span class=\"n\">ComplexConjugate</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">ring</span>\n</code></pre></div>",
        "id": 389485265,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694020840
    },
    {
        "content": "<p>That's already much better, thanks! But I guess my question is more of a philosophical one, closer in spririt to <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span>'s <code>Complex.selfAdjointEquiv</code>. That is, when my mind sees <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi><mo>+</mo><mover accent=\"true\"><mi>z</mi><mo>ˉ</mo></mover></mrow><annotation encoding=\"application/x-tex\">z + \\bar z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5678em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5678em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1944em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span></span></span></span>, it sees it as a real number... Anyway, moving on. Thanks all</p>",
        "id": 389504475,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1694028792
    },
    {
        "content": "<p>Does the following code look like what you want?<br>\nBasically the idea is to:</p>\n<ol>\n<li>Define a type class of Complexes that can become reals <code>RealizableComlpex</code>. </li>\n<li>Then define a coercion from this class to the Reals. </li>\n<li>Finally for the particular case I am interested in I provide the instance of the <code>RealizableComplex</code> class in this case it was called <code>instRealizable_C_add_conj</code></li>\n</ol>\n<p>In principle all these intsances can be hidden inside a library somewhere, the use just writes the last three lines.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Module</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">ComplexConjugate</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">old_conj_sumx</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"bp\">;</span> <span class=\"n\">ring</span><span class=\"bp\">;</span>\n  <span class=\"n\">done</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">RealizableComplex</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">im_zero</span> <span class=\"o\">:</span> <span class=\"n\">z.im</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">RealizableComplex</span> <span class=\"n\">z</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">CoeDep</span> <span class=\"n\">ℂ</span> <span class=\"n\">z</span> <span class=\"n\">ℝ</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">z.re</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">instRealizable_C_add_conj</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">RealizableComplex</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">im_zero</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">good_conj_sumx</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">instRealizable_C_add_conj</span> <span class=\"n\">z</span>\n  <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">z.re</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">ring</span>\n\n<span class=\"c1\">-- Should be hidden inside the library somewhere.</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">RealizableComplex</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">instRealizable_C_add_conj</span> <span class=\"n\">z</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">better_conj_sumx</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">ring</span>\n</code></pre></div>\n<p>My use case was getting the determinant of hermitian matrices to act like a real number, so I needed one instance. But if you want this to be every case where some operation on complex numbers leads to a real number this might require a lot of instances.</p>\n<p>One point worth mentioning here. I still have to add the small arrow to nudge lean in the direction of using real numbers. I am sure someone with a bit more expertise can get rid of the need for the small arrow.</p>",
        "id": 389525470,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1694039153
    },
    {
        "content": "<p>This is quite nice, thanks! Yes I suppose I'll need to make a list of things that should be \"Realizable\"... Or alternatively, give up on the philosophy and just apply <code>.re</code>... (Might be less painful...)</p>",
        "id": 389528790,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1694041114
    },
    {
        "content": "<p>I don't want to rain on Mohanad's parade, but unfortunately I need to point out some issues with this approach. This isn't going to be well-behaved since the class depends on a term <code>z : ℂ</code>. if you have a <code>RealizableComplex z</code> instance, you won't get a <code>RealizableComplex w</code> instance for free if <code>z = w</code>, unless they happen to be (reducibly, I think?) defeq. What that means in practice is that wherever you see something like <code>↑(z + conj z)</code> where <code>↑</code> is the <code>CoeDep</code> coercion above, you won't be able to rewrite the <code>z + conj z</code> to something else without losing the <code>↑</code>, so yeah ... that sucks.</p>\n<p>Another issue: as written, the <code>CoeDep</code> instance only allows Lean to find the coercion automatically (if it can find a <code>RealizableComplex</code> instance), but it won't pretty print the <code>↑</code> in the infoview unless we add the <code>@[coe]</code> attribute to <code>Complex.re</code>. But (I think, I'm not sure about this) I don't think we can apply it selectively, so then I think we would see <code>↑z</code> for <code>z.re</code> for <em>any</em> <code>z : ℂ</code>. And without the <code>coe</code> attribute, this is just a feature of input syntax. The theorems would still be <code>(z + conj z).re = 2 * z.re</code>.</p>\n<p>Then there's potential issues surrounding coercions back and forth between <code>ℝ</code> and <code>ℂ</code>. This is probably pretty minor and not actually a problem though.</p>",
        "id": 389532387,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694043510
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"497480\">@MohanadAhmed</span> if you need a real-valued determinant for Hermitian matrices, you can always just define one. And also, do both of you know about the <code>lift</code> tactic? For <code>z  : ℂ</code>, you can <code>lift z to ℝ using hz</code> where <code>hz : z.im = 0</code>. This is pretty handy, and I think may do a lot of what you might want, but maybe I'm wrong.</p>",
        "id": 389532646,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694043691
    },
    {
        "content": "<p>No I didn't know about the lift tactic. So thanks for that. <br>\nBut I guess since it is a tactic I cannot use it in the lemma statement right?</p>",
        "id": 389533173,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1694044002
    },
    {
        "content": "<p>I mean, technically you can, but you shouldn't.</p>",
        "id": 389556129,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694056327
    },
    {
        "content": "<p>I remember noticing years ago that when defining norms on the complexes it was useful to have a bespoke function <code>norm_sq</code> from the complexes <em>to the reals</em> sending a+bi to a^2+b^2. Similarly there will be a trace function nowadays from the complexes to the reals sending a+bi to 2a (this will be defined in some huge generality). Then you just need the lemma that trace, coerced, is z + conj z and things should be fine.</p>",
        "id": 389577165,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694066290
    },
    {
        "content": "<p>Kevin, I cannot understate how much I hate <code>norm_sq</code> <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 389586604,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1694070596
    },
    {
        "content": "<p>I'm sure the real reason that Kevin likes it is that it's computable /s</p>",
        "id": 389587065,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694070780
    },
    {
        "content": "<p>Kevin, I claim that the canonical way to spell that map is what I wrote above: <code>selfAdjointEquiv (\\Re z)</code>. Do you disagree? It sounds like you have something else in mind.</p>",
        "id": 389616282,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694080435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/complex.2Freal.20coercion.20nightmare/near/389532387\">said</a>:</p>\n<blockquote>\n<p>Another issue: as written, the <code>CoeDep</code> instance only allows Lean to find the coercion automatically (if it can find a <code>RealizableComplex</code> instance), but it won't pretty print the <code>↑</code> in the infoview unless we add the <code>@[coe]</code> attribute to <code>Complex.re</code>. But (I think, I'm not sure about this) I don't think we can apply it selectively, so then I think we would see <code>↑z</code> for <code>z.re</code> for <em>any</em> <code>z : ℂ</code>. And without the <code>coe</code> attribute, this is just a feature of input syntax. The theorems would still be <code>(z + conj z).re = 2 * z.re</code>.<br>\n</p>\n</blockquote>\n<p>Well I learned something new on this one. I didn't know about <code>@[coe]</code>.  If I understood this correctly the issue you mention can  be mitigated by adding an intermediary between <code>Complex.re</code> and  <code>CoeDep</code>. In the code below I called it <code>hidden_re</code>. Now the pretty printer the coercion arrow shows up behind the <code>z + conj z</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Module</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">ComplexConjugate</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">RealizableComplex</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">im_zero</span> <span class=\"o\">:</span> <span class=\"n\">z.im</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">@[coe]</span>\n<span class=\"kd\">def</span> <span class=\"n\">hidden_re</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"n\">Complex.re</span> <span class=\"n\">z</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">hidden_re_is_re</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">hidden_re</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">RealizableComplex</span> <span class=\"n\">z</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">CoeDep</span> <span class=\"n\">ℂ</span> <span class=\"n\">z</span> <span class=\"n\">ℝ</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">hidden_re</span> <span class=\"n\">z</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">instRealizable_C_add_conj</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">RealizableComplex</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">im_zero</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">RealizableComplex</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">instRealizable_C_add_conj</span> <span class=\"n\">z</span>\n\n<span class=\"c1\">-- All above Should be hidden inside the library somewhere.</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">better_conj_sumx</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">ring</span>\n</code></pre></div>\n<p><a href=\"/user_uploads/3121/ENiP7nPLHKEgXAr8hi8G62-B/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/ENiP7nPLHKEgXAr8hi8G62-B/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/ENiP7nPLHKEgXAr8hi8G62-B/image.png\"></a></div>",
        "id": 389635477,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1694086303
    },
    {
        "content": "<p>Yes, that would solve that particular problem, but it introduces new ones. Now you either need to duplicate lemmas or else pass from <code>hidden_re</code> to <code>re</code> all the time. This would be mitigated by making it an <code>abbrev</code>. However, no matter what you'll always end up with <code>hidden_re</code> littered throughout your theorem statements, it will just be displayed as an up arrow.</p>",
        "id": 389661216,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694093778
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/complex.2Freal.20coercion.20nightmare/near/389616282\">said</a>:</p>\n<blockquote>\n<p>Kevin, I claim that the canonical way to spell that map is what I wrote above: <code>selfAdjointEquiv (\\Re z)</code>. Do you disagree? It sounds like you have something else in mind.</p>\n</blockquote>\n<p>I've been travelling all day and I couldn't even read your solution because of the stupid android font bug.  But now I've seen it and yes it's not what I had in mind but maybe it works here. Part of the set-up fills me with dread because we'll need all of this stuff when we do the theory of CM number fields and these are not <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>-modules so everything will need to be refactored/generalised. A CM field is a field like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi><mo stretchy=\"false\">(</mo><msqrt><mn>2</mn></msqrt><mo separator=\"true\">,</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}(\\sqrt{2},i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1572em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Q</span><span class=\"mopen\">(</span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9072em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">2</span></span></span><span style=\"top:-2.8672em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1328em;\"><span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span> which has a well-defined star, and a \"real part\" / \"imaginary part\" function etc etc. For a general number field there can be more than one \"complex conjugation\" (coming from different embeddings into the complexes) but for a CM field there is a unique one.</p>",
        "id": 389674178,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694096577
    },
    {
        "content": "<p>Kevin, for those can't you just use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=selfAdjointPart#doc\">docs#selfAdjointPart</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=skewAdjointPart#doc\">docs#skewAdjointPart</a> ?</p>",
        "id": 389685575,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694099237
    },
    {
        "content": "<p>Yes! I see, the point of RealPart is registering that it's a linear map. I guess I'd want some analogue one day but not today :-)</p>",
        "id": 389689522,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694100225
    },
    {
        "content": "<p>no, they're both linear maps (in fact, probably <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=realPart#doc\">docs#realPart</a> should be reducible, whoops!), and in your case you would probably choose <code>R := ℚ</code>. The point is that in a <code>ℂ</code>-module we can get <code>z = x + I • y</code> where <code>y</code> is <em>also</em> <code>selfAdjoint</code>, as opposed to just considering <code>I • y</code> as <code>skewAdjoint</code>. In particular, the module is span (over <code>ℂ</code>) of the selfadjoint elements. Many arguments in C⋆-algebra theory first reduce to the selfadjoint case.</p>\n<p>It's possible this is just unnecessary overhead though. I haven't determined that yet.</p>",
        "id": 389690645,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694100484
    },
    {
        "content": "<p>No, it's defined as <code>selfAdjointPart Real</code>, it's just a wrapper for this common case. <code>selfAdjointPart</code> is already linear.</p>",
        "id": 389690764,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1694100503
    },
    {
        "content": "<p>Thanks for the explanations!</p>",
        "id": 389690826,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694100517
    }
]