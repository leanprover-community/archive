[
    {
        "content": "<p>Let <code>F : C =&gt; D</code> be a functor, and let <code>y : D</code>.</p>\n<p>Then one can consider the category where objects are <code>(x, u)</code> with <code>x : C</code> and <code>u : F.obj x -&gt; y</code>. This is like <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Comma/Over/Basic.html#CategoryTheory.Over\">CategoryTheory.Over</a> but across a functor.</p>\n<p>Is this in Mathlib?</p>",
        "id": 529574191,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752929051
    },
    {
        "content": "<p>Context: given a scheme <code>X</code>, I want to consider the category of rings <code>R</code> equipped with a \"structural morphism\" <code>Spec R -&gt; X</code>.</p>",
        "id": 529574230,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752929087
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Comma#doc\">docs#CategoryTheory.Comma</a> ?</p>",
        "id": 529574293,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1752929153
    },
    {
        "content": "<p>actually i think it's <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Comma/StructuredArrow/Basic.html#CategoryTheory.CostructuredArrow\">CategoryTheory.CostructuredArrow</a> , thanks</p>",
        "id": 529574378,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752929278
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> I was like 200 lines deep in this proof that every <code>P : Psh(Aff/X)</code> (defined above) has a left Kan extension to <code>Psh(Aff)</code> until...</p>\n<p>I realised that none of my lines require any property at all for rings and schemes, so they can all be generalised, so in general:</p>\n<p>If <code>F : C =&gt; D</code> is a functor (between locally small categories) and <code>X : D</code> then every presheaf on <code>CostructuredArrow F X</code> has a pointwise left Kan extension (along the projection functor <code>CostructuredArrow F X =&gt; C^op</code> to a presheaf on <code>C^op</code> (i.e. copresheaf on <code>C</code>).</p>\n<p>Yet I cannot find any lemma like this in Mathlib. Before I spend more hours of my life on this, is this already in Mathlib?</p>",
        "id": 529622512,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752974807
    },
    {
        "content": "<p>(To be clear, <code>P</code> extends to the functor that sends <code>c : C^op</code> to <code>(u : F(c) ⟶ D) × P(u)</code></p>",
        "id": 529622607,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752974968
    },
    {
        "content": "<p>MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CostructuredArrow</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵖ</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">HasPointwiseLeftKanExtension</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CostructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">proj</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">HasPointwiseLeftKanExtensionAt</span>\n<span class=\"w\">  </span><span class=\"c1\">-- 100 more lines of proof</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">HasLeftKanExtension</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CostructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">proj</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n</code></pre></div>",
        "id": 529622879,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752975433
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Comma/Presheaf/Basic.html#CategoryTheory.OverPresheafAux.YonedaCollection\">CategoryTheory.OverPresheafAux.YonedaCollection</a> feels similar but I think my result is more general</p>",
        "id": 529623540,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752976533
    },
    {
        "content": "<p>Made <a href=\"https://github.com/leanprover-community/mathlib4/pull/27309\">#27309</a></p>",
        "id": 529695440,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753025279
    },
    {
        "content": "<p>I am a bit late because you went ahead and coded the thing, but I think it would be much nicer to have a result that  makes no assumption on size and does not require the target category to be <code>Type</code>.</p>\n<p>Here, the key result is the computation of the category \"Between\" that you made via the \"partition\".</p>\n<p>I think your result follows from a combination of more general facts</p>\n<ol>\n<li>The category that computes the value at <code>c</code> of the left Kan extension you consider (which you call <code>Between F d c</code>) admits a functor to a discrete category (in this case, <code>Discrete (CostructuredArrow F d)</code>).</li>\n<li>If a category <code>C</code> admits a functor <code>p</code> to a category <code>D</code> such that <code>D</code> is discrete, the colimit of a functor out of <code>C</code> is given by the coproduct of the colimits of the restrictions at each fibers of <code>p</code>. In your case, you have identified that the relevant fibers have a terminal object, thus the computation of the colimit of each such fiber is easy.</li>\n</ol>\n<p>I think result 2. itself is an instance of the more general facts that 1) a functor to a discrete category is automatically a cofibered category 2) colimits out of a cofibered category can be computed \"fiberwise\": first do the colimit of each fibers, and then the colimit of each diagram you obtain.</p>\n<p>Note that all of this happens purely at the level of diagrams and so <code>Type u</code> or size only enters the picture at the very very end, where you use that fiberwise you have enough colimits in type.</p>",
        "id": 529705777,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1753036838
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> it’s not too late, because in my mental picture it’s less effort to generalise existing code than to come up with the most general code at the first go.</p>\n<p>I appreciate your generalisations a lot! Do you know if what you call cofibrred category is already in mathlib? if not, what is the closest thing we have?</p>",
        "id": 529706048,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753037092
    },
    {
        "content": "<p>We have fibered categories for sure (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Functor.IsFibered#doc\">docs#CategoryTheory.Functor.IsFibered</a>), and a cofibered category could be defined as <code>F.op.IsFibered</code> (even if I’d prefer it if there was also a \"dual\" typeclass to <code>IsFibered</code>)<br>\nfor the point about computation of colimits in cofibered categories we have <a href=\"https://tqft.net/mathlib4files/CategoryTheory/Limits/Shapes/Grothendieck\">file#CategoryTheory/Limits/Shapes/Grothendieck</a> which treats the special case of a strict Grothendieck construction but I don’t think that this is sufficient here sadly.</p>",
        "id": 529706287,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1753037320
    },
    {
        "content": "<p>(Note that the full generalization here is probably quite a lot of work compared to the original thing though!)</p>",
        "id": 529706360,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1753037385
    },
    {
        "content": "<p>Probably 2. is provable without all the full cofibered category picture</p>",
        "id": 529706443,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1753037470
    },
    {
        "content": "<p>I think I would be satisfied to do 2 itself without the more general picture of cofibered category.</p>",
        "id": 529706457,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753037494
    },
    {
        "content": "<p>what is the closest result we have to 2?</p>",
        "id": 529706603,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753037683
    },
    {
        "content": "<p>Not sure that there’s much better than doing it by hand within current mathlib... I’d need to think a bit if we have better. Note that already the statement contains a possible evil: the \"fibers\" of a functor can either be understood in the \"strict\" or \"weak\" sense. In the strict sense, they will mention equality of objects, so \"evil\". In the weak (= non-evil) sense, the fiber can be defined as the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.CategoricalPullback#doc\">docs#CategoryTheory.Limits.CategoricalPullback</a> of the functor along <code>fromPunit</code> at the relevant point, but the API for categorical pullbacks is a bit new and not yet stable.</p>",
        "id": 529707168,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1753038320
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> i've made <a href=\"https://github.com/leanprover-community/mathlib4/pull/27321\">#27321</a> for the fiberwise colimit</p>",
        "id": 529764401,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753079448
    },
    {
        "content": "<p>something amazing happened: through the CI process it was discovered that <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/FiberedCategory/Fiber.html#CategoryTheory.Functor.Fiber\">CategoryTheory.Functor.Fiber</a> already exists, which is a testament to the effectiveness of following the naming convention!</p>",
        "id": 529773945,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753081881
    },
    {
        "content": "<p>this allows me to potentially use more existing API</p>",
        "id": 529773979,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753081887
    },
    {
        "content": "<p><code>Functor.Fiber</code> is the \"evil one\", though.</p>",
        "id": 529776335,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1753082317
    },
    {
        "content": "<p>yes, the one in my PR is also evil</p>",
        "id": 529780242,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753083005
    },
    {
        "content": "<p>At least, in the case of a functor to a discrete category we're lucky that the \"non-evil\" and \"evil\" fibers are equivalent (for a general functor, this is not the case)</p>",
        "id": 529780641,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1753083071
    },
    {
        "content": "<p>I’d like to hear <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span>’s opinion for this case but I think mathlib would prefer minimizing evil that is not \"necessary\", and here I think it’s not a necessary one.</p>",
        "id": 529787401,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1753084240
    },
    {
        "content": "<p>I guess I could try to use the pullback as well, but I’m not sure if that would make it harder or easier.</p>",
        "id": 529791493,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753084947
    },
    {
        "content": "<p>is it really less evil if it’s “equivalent”?</p>",
        "id": 529791622,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753084969
    },
    {
        "content": "<p>I would think that in <a href=\"https://github.com/leanprover-community/mathlib4/pull/27321\">#27321</a>, <code>Fiber</code> should refer to <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/FiberedCategory/Fiber.html#CategoryTheory.Functor.Fiber\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/FiberedCategory/Fiber.html#CategoryTheory.Functor.Fiber</a></p>",
        "id": 529794786,
        "sender_full_name": "Joël Riou",
        "timestamp": 1753085499
    },
    {
        "content": "<p>It is less \"evil\" in the sense that when <em>working</em> with it, you do not have goals that asks you for equality of objects, or results that produce such, and the constructions have far less chance of accidentally leaking <code>eqToHom</code>'s everywhere. I can see happening cases where you want to \"compute\" the restriction of the diagram at a given fiber (say, because you know it’s naturally isomorphic to a \"better\" functor, for which you know how to compute the colimit), and then that alone will bring some <code>eqToHom</code> hell etc.</p>",
        "id": 529794893,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1753085519
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/over.20category.20via.20a.20functor/near/529794786\">said</a>:</p>\n<blockquote>\n<p>I would think that in <a href=\"https://github.com/leanprover-community/mathlib4/pull/27321\">#27321</a>, <code>Fiber</code> should refer to <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/FiberedCategory/Fiber.html#CategoryTheory.Functor.Fiber\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/FiberedCategory/Fiber.html#CategoryTheory.Functor.Fiber</a></p>\n</blockquote>\n<p>Can you explain why you feel the naive fiber is what we want here?</p>",
        "id": 529795137,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1753085559
    },
    {
        "content": "<p>I am only saying that there is no need to duplicate the definition of the naive fiber.</p>",
        "id": 529817728,
        "sender_full_name": "Joël Riou",
        "timestamp": 1753089244
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> yes, I am aware that it's duplicated, and I actually just finished deduplicating it. But I think it would also be important to also discuss whether to use the \"naive\" version or the \"less evil\" version</p>",
        "id": 529818201,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753089323
    },
    {
        "content": "<p>(Note that in favor of using the \"non-evil\" one, it makes the result also true if <code>D</code> is merely equivalent to a discrete category, because we can then freely replace <code>C</code> and <code>D</code> by equivalent categories (as long as we track the coherence with <code>F</code>), but since mathlib has no typeclass asserting a category is \"weakly discrete\", it’s not the nicest to state in the current state of afairs and would be yet an other detour.)</p>",
        "id": 529818955,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1753089453
    },
    {
        "content": "<p>Currently, we only have <code>IsDiscrete</code>. Unless we have reasons to develop essentially discrete categories, I think it is very much fine to use the naive fiber.</p>",
        "id": 529820177,
        "sender_full_name": "Joël Riou",
        "timestamp": 1753089659
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> I've updated the PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/27321\">#27321</a>.</p>\n<p>(btw I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/FiberedCategory/Fiber.html#CategoryTheory.Functor.Fiber.fiberInclusion\">CategoryTheory.Functor.Fiber.fiberInclusion</a> should have explicit <code>p</code> and <code>S</code> and I will do that in a PR)</p>",
        "id": 529821320,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753089852
    },
    {
        "content": "<p>Well, that’s a bit disappointing to me because I’m working hard with <code>CategoricalPullback</code> to make it so that we can talk about things like fibers in an actually equivalence-invariant way (one hope being that one day we will have constructors for fibered categories/cartesian morphisms that do not mention equality of objects or functors, <a href=\"https://gradmath.org/wp-content/uploads/2020/10/Mazel-Gee-GJM-2019.pdf\">that’s claimed to be possible</a>). But then so be it.</p>\n<p>I just hope this will not cause \"eqToHom contamination\" whenever we want to rely on the content of this PR.</p>",
        "id": 529822887,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1753090117
    },
    {
        "content": "<p>i'll try to use the non-evil version in another file locally and see what happens</p>",
        "id": 529823466,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753090219
    },
    {
        "content": "<p>made <a href=\"https://github.com/leanprover-community/mathlib4/pull/27323\">#27323</a> to make fiberInclusion explicit</p>",
        "id": 529825055,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753090503
    },
    {
        "content": "<p>That a functor is a fibered category in the sense of Grothendieck is not invariant under pre/post-composition with equivalences. If we want to allow a little bit more flexibility, I think that the best we could do here would be to use a<code>HasFibers</code> assumption from the fibered category.</p>",
        "id": 529828434,
        "sender_full_name": "Joël Riou",
        "timestamp": 1753091054
    },
    {
        "content": "<p>I guess the point is that the notion of fibration linked is <em>different</em> from the one of Grothendieck and that it does recover the notion if the functor is furthermore an isofibration (which is the \"non-equivalence invariant\" part). The claims in the link is that this notion works just as well as Grothendieck’s for most purposes (critically, it should provide a straightening/unstraightening equivalence of (probably bi-)categories between fibrations over <code>C</code> and pseudofunctors from <code>LocallyDiscrete C</code> to <code>Cat</code>, which is most of what we want.). Eventually I’d love to be able to work on bringing this notion to Mathlib, because I feel it’s much much more flexible than <code>HasFiber</code> which bundles an equality of functors.</p>",
        "id": 529833754,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1753091885
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> I now have a version using <code>CategoricalPullback</code>.</p>",
        "id": 529855905,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753095257
    },
    {
        "content": "<p><a href=\"https://github.com/kckennylau/EllipticCurve/blob/07f6e9052b76ee63e85143cca10f788c461c89b7/EllipticCurve/Grassmannians/FiberColimitPullback.lean\">https://github.com/kckennylau/EllipticCurve/blob/07f6e9052b76ee63e85143cca10f788c461c89b7/EllipticCurve/Grassmannians/FiberColimitPullback.lean</a></p>",
        "id": 529856084,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753095277
    },
    {
        "content": "<p>Nice, did you have any pain point working with that compared to the other fiber? So that maybe I can know what to work on when making the general definition.</p>",
        "id": 529866754,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1753096460
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> not really, i just used the first part of the file (in both versions) to define the API so that they are \"the same object\" to any user, and the proofs didn't need to be changed</p>",
        "id": 529867382,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753096527
    },
    {
        "content": "<p>this relates to the question i asked above: is it really less evil if they are equivalent?</p>",
        "id": 529867607,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753096550
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/over.20category.20via.20a.20functor/near/529791622\">said</a>:</p>\n<blockquote>\n<p>is it really less evil if it’s “equivalent”?</p>\n</blockquote>",
        "id": 529867728,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753096563
    },
    {
        "content": "<p>Well, looking at the proof they still bundle all the eqToHom/equality of object that you can’t avoid because the base is discrete. Meaning i may have made too much noise about this for too little of an outcome. I guess the approach with the naive fiber will at least lead to less duplication.</p>",
        "id": 529868980,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1753096813
    },
    {
        "content": "<p>(I was secretly wondering, after you've looked at the alternate version, whether there's a \"different\" way to remove the eqToHom)</p>",
        "id": 529869135,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753096864
    },
    {
        "content": "<p>My main worry was about spilling goals with equality of objects/eqToHom everywhere.</p>",
        "id": 529869197,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1753096882
    },
    {
        "content": "<p>I guess I can test it by using it for the over category theorem</p>",
        "id": 529869472,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753096972
    }
]