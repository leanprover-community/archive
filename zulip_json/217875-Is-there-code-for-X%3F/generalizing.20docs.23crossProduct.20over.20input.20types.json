[
    {
        "content": "<p>Currently, the definition of CrossProduct only works with input/output type <code>(Fin 3 -&gt; Real)</code>. I think it would be useful to generalise this definition so that it also works with types such as <code>EuclideanSpace ‚Ñù (Fin 3)</code> (at present, using <code>EuclideanSpace ‚Ñù (Fin 3)</code> as input still yields a <code>Fin 3 -&gt; Real</code> as output, which can make it harder to get the L2 norm of the cross product...). I'm not sure what the right way would be to write such a generalised definition. Any help would be very appreciated! <br>\nFor more details on why this is relevant see <a href=\"https://github.com/leanprover-community/mathlib4/pull/20920\">#20920</a></p>",
        "id": 495919239,
        "sender_full_name": "Vedant Gupta",
        "timestamp": 1737852977
    },
    {
        "content": "<p>I don't have an answer to this generalization, but I left a comment on the PR showing how you can make do without it for now</p>",
        "id": 495921204,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737854966
    },
    {
        "content": "<p>Ok, here's the generalization I'd suggest:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- in the existing file</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">CrossProduct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V3</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">V3</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">   </span><span class=\"n\">crossProduct</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V3</span><span class=\"w\"> </span><span class=\"bp\">‚Üí‚Çó</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">V3</span><span class=\"w\"> </span><span class=\"bp\">‚Üí‚Çó</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">V3</span>\n<span class=\"w\">   </span><span class=\"c1\">-- all the lie axioms</span>\n<span class=\"w\">   </span><span class=\"n\">crossProduct_self</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">   </span><span class=\"n\">liebniz_crossProduct</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">export</span><span class=\"w\"> </span><span class=\"n\">CrossProduct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">crossProduct</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- theorems about cross products only, from the lie structure</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CrossProduct</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"c1\">-- theorems about `Fin 3 -&gt; R` and `Matrix.dotProduct` and `![x, y, z]`</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- in a new file</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CrossProduct</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"c1\">-- theorems about `EuclideanSpace` and `inner` and `!‚ÇÇ[x, y, z]`</span>\n\n<span class=\"c1\">-- theorems linking the two spellings via `WithLP.equiv`</span>\n</code></pre></div>",
        "id": 495921814,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737855572
    },
    {
        "content": "<p>Just to remark that probably if phi:V_3-&gt;V_3 is any linear isomorphism then my guess is that phi \\circ crossProduct probably also satisfies the axioms so this is an extremely weak structure to be allowed the name <code>CrossProduct</code>.</p>",
        "id": 495922684,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1737856414
    },
    {
        "content": "<p>That doesn't sound like a problem to me, the same comment about composing with linear morphisms applies to choices of norm, and we don't attempt to encode the choice in <code>NormedSpace</code></p>",
        "id": 495923011,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737856728
    },
    {
        "content": "<p>Really the typeclass only needs to exist to 1) provide notation and 2) save us from copying the first 10 or so lemmas</p>",
        "id": 495923028,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737856748
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/generalizing.20docs.23crossProduct.20over.20input.20types/near/495921814\">said</a>:</p>\n<blockquote>\n<p>Ok, here's the generalization I'd suggest:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- in the existing file</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">CrossProduct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V3</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">V3</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">   </span><span class=\"n\">crossProduct</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V3</span><span class=\"w\"> </span><span class=\"bp\">‚Üí‚Çó</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">V3</span><span class=\"w\"> </span><span class=\"bp\">‚Üí‚Çó</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">V3</span>\n<span class=\"w\">   </span><span class=\"c1\">-- all the lie axioms</span>\n<span class=\"w\">   </span><span class=\"n\">crossProduct_self</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">   </span><span class=\"n\">liebniz_crossProduct</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Isn't it Lie bracket?</p>",
        "id": 495925766,
        "sender_full_name": "Jz Pan",
        "timestamp": 1737859349
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/generalizing.20docs.23crossProduct.20over.20input.20types/near/495921814\">said</a>:</p>\n<blockquote>\n<p><code>liebniz_crossProduct</code></p>\n</blockquote>\n<p>The guy was called <em>Leibniz</em> <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> <span aria-label=\"flag germany\" class=\"emoji emoji-1f1e9-1f1ea\" role=\"img\" title=\"flag germany\">:flag_germany:</span></p>",
        "id": 495950525,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1737883454
    },
    {
        "content": "<p>Eric Weiser must have developed an incompatible muscle memory...</p>",
        "id": 495951120,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1737883953
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/generalizing.20docs.23crossProduct.20over.20input.20types/near/495923011\">said</a>:</p>\n<blockquote>\n<p>That doesn't sound like a problem to me, the same comment about composing with linear morphisms applies to choices of norm, and we don't attempt to encode the choice in <code>NormedSpace</code></p>\n</blockquote>\n<p>Sure, but what I'm saying is \"the cross product\" is a special canonical thing on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mn>3</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\R^3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span></span></span>, there aren't lots of choices of \"the cross product\", so I'm objecting to the name <code>CrossProduct</code> for something which there might be many of (for example it would I think be quite odd to mathematicians if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> was a cross product). </p>\n<p>However to be honest I don't really understand the Leibniz rule conceptually. The first axiom just says that you have a linear map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"normal\">Œõ</mi><mn>2</mn></msup><mo stretchy=\"false\">(</mo><msub><mi>V</mi><mn>3</mn></msub><mo stretchy=\"false\">)</mo><mo>‚Üí</mo><msub><mi>V</mi><mn>3</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\Lambda^2(V_3)\\to V_3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\">Œõ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> sending <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>‚àß</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a\\wedge b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5556em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚àß</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[a,b]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">]</span></span></span></span>, but <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">[</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>c</mi><mo stretchy=\"false\">]</mo><mo>+</mo><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">[</mo><mi>b</mi><mo separator=\"true\">,</mo><mi>c</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>a</mi><mo stretchy=\"false\">]</mo><mo>+</mo><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">[</mo><mi>c</mi><mo separator=\"true\">,</mo><mi>a</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">[[a,b],c]+[[b,c],a]+[[c,a],b]=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[[</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[[</span><span class=\"mord mathnormal\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[[</span><span class=\"mord mathnormal\">c</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> might put a lot of constraints on it which I don't understand. It's not going to rule out the zero map though. In short I'm just suggesting that the class might need a different name.</p>",
        "id": 495967611,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1737898133
    },
    {
        "content": "<p>I'm not convinced about a typeclass for the cross product. Maybe I could be persuaded if I can find time to appreciate the issue here but it's just the Lie algebra <code>ùî∞ùî¨(3)</code>.</p>",
        "id": 495981036,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1737909286
    },
    {
        "content": "<p>If we can get <a href=\"https://github.com/leanprover-community/mathlib4/tree/morrison-daniel%2Fhodge-star\">branch#morrison-daniel/hodge-star</a> merged (which is blocked by our <a href=\"https://github.com/leanprover-community/mathlib4/pull/11155\">#11155</a>) then we'll be able to define a cross product on any three-dim space with orientation and metric. That's probably the right generality.</p>",
        "id": 495981221,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1737909440
    },
    {
        "content": "<p>I think the typeclass proposed above is an improvement over the current <code>crossProduct</code>, but indeed removing <code>crossProduct</code> in its current form entirely in favor of what you define would probably be better</p>",
        "id": 495986851,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737913576
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/generalizing.20docs.23crossProduct.20over.20input.20types/near/495921204\">said</a>:</p>\n<blockquote>\n<p>I don't have an answer to this generalization, but I left a comment on the PR showing how you can make do without it for now</p>\n</blockquote>\n<p>Thanks everyone! Would it makes sense for me to move ahead with <a href=\"https://github.com/leanprover-community/mathlib4/pull/20920\">#20920</a> using this makeshift solution <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>? If not, how would y'all recommend I move ahead given there are a couple options here?</p>",
        "id": 496010447,
        "sender_full_name": "Vedant Gupta",
        "timestamp": 1737932676
    },
    {
        "content": "<p>I think you should wrap up <a href=\"https://github.com/leanprover-community/mathlib4/pull/20920\">#20920</a> with the ugly-but-type-correct <code>WithLp.equiv</code>s for now. As a follow up, we can see if Oliver can be convinced that <code>CrossProduct</code> is a useful intermediate step, or can convince me that it is not!</p>",
        "id": 496013196,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737935259
    }
]