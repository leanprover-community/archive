[
    {
        "content": "<p>I was wondering if there is a way to argue about the computational complexity of implementations of certain algorithms in Lean.</p>\n<p>For example, consider the two implementations of search:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">findIndex</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">1</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">              </span><span class=\"k\">else</span>\n<span class=\"w\">                </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">findIndex</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">;</span>\n<span class=\"w\">                </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">                  </span><span class=\"bp\">-</span><span class=\"mi\">1</span>\n<span class=\"w\">                </span><span class=\"k\">else</span>\n<span class=\"w\">                  </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>and </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">binarySearchLowHi</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">low</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hi</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">low</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">low</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"bp\">;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mid</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">               </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">               </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">;</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_i_lt_n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mid</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"gr\">sorry</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ^ NOTE:</span>\n<span class=\"w\">    </span><span class=\"c1\">-- This proof is required to ensure that</span>\n<span class=\"w\">    </span><span class=\"c1\">-- list.get can be called with the index `i`</span>\n<span class=\"w\">    </span><span class=\"c1\">-- without any runtime errors.</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mid_val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">mid</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h_i_lt_n</span><span class=\"bp\">⟩;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">mid_val</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">mid</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">mid_val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">binarySearchLowHi</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mid</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hi</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">binarySearchLowHi</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">low</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mid</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">low</span>\n<span class=\"n\">decreasing_by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">rename_i</span><span class=\"w\"> </span><span class=\"n\">h_hi_leq_low</span>\n<span class=\"w\">  </span><span class=\"c1\">-- We only have to prove termination for the recursive case when</span>\n<span class=\"w\">  </span><span class=\"c1\">-- `low &lt;= hi`. This is because the base case is already covered by the `if low &gt; hi then -1` line.</span>\n<span class=\"w\">  </span><span class=\"c1\">-- We rename the hypothesis to `h_hi_leq_low` to make it more readable.</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h_hi_leq_low</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_sum_mod_2_eq_0_or_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h_sum_mod_2_eq_0_or_1</span>\n<span class=\"w\">  </span><span class=\"n\">rename_i</span><span class=\"w\"> </span><span class=\"n\">h_sum_mod_2_eq_0</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h_sum_mod_2_eq_0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c1\">-- at this point, prove that hi - ((low + hi) / 2 + 1) &lt; hi - low</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">rename_i</span><span class=\"w\"> </span><span class=\"n\">h_sum_mod_2_eq_1</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h_sum_mod_2_eq_1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c1\">-- at this point, prove that hi - ((low + hi - 1) / 2 + 1) &lt; hi - low</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>How can I state that binary search is faster than the simple search given the list is sorted</p>",
        "id": 499985738,
        "sender_full_name": "Amitayush Thakur",
        "timestamp": 1739688659
    },
    {
        "content": "<p>This isn't true, because a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List#doc\">docs#List</a> is a linked list, so it's actually less efficient and can be <code>O(n log(n))</code></p>",
        "id": 499987015,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1739689982
    },
    {
        "content": "<p>However, in any case, due to function extensionality (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=funext#doc\">docs#funext</a>) you can't state this directly about the function</p>",
        "id": 499987045,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1739690027
    },
    {
        "content": "<p>Okay agreed, my implementation may not use Array where I would have been able to write it more efficiently. </p>\n<p>However, my question is more general. Can we argue about the time complexity of functions in general? But It seems that based on <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Core.html#funext\">https://leanprover-community.github.io/mathlib4_docs/Init/Core.html#funext</a>, we cannot state that one function is faster than another. However, I was wondering if we could define some form of measure to describe the number of computations needed to execute the function.</p>",
        "id": 499987560,
        "sender_full_name": "Amitayush Thakur",
        "timestamp": 1739690554
    },
    {
        "content": "<p>Yes you can. I’m from my phone so it’s hard to search, but there were past discussions here on Zulip (and I think some still open PRs) with several approaches. One fairly straightforward option is to replace your function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">f : \\alpha \\to \\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>f</mi><mo>ˉ</mo></mover><mo>:</mo><mi>α</mi><mo>→</mo><mi>β</mi><mo>×</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\bar{f} : \\alpha \\to \\beta \\times \\N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0257em;vertical-align:-0.1944em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8312em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span><span style=\"top:-3.2634em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.0833em;\"><span class=\"mord\">ˉ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1944em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>, where the extra natural number you carry around is your complexity measure (eg: number of comparisons, arithmetical ops, etc). Then you prove all your usual complexity results about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>f</mi><mo>ˉ</mo></mover><mn>.2</mn></mrow><annotation encoding=\"application/x-tex\">\\bar{f}.2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0257em;vertical-align:-0.1944em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8312em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span><span style=\"top:-3.2634em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.0833em;\"><span class=\"mord\">ˉ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1944em;\"><span></span></span></span></span></span><span class=\"mord\">.2</span></span></span></span> and use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>f</mi><mo>ˉ</mo></mover><mn>.1</mn></mrow><annotation encoding=\"application/x-tex\">\\bar{f}.1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0257em;vertical-align:-0.1944em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8312em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span><span style=\"top:-3.2634em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.0833em;\"><span class=\"mord\">ˉ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1944em;\"><span></span></span></span></span></span><span class=\"mord\">.1</span></span></span></span> for correctness and applications</p>",
        "id": 499998302,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1739701020
    },
    {
        "content": "<p>There is an open PR with a more principled approach to this</p>",
        "id": 500005172,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739707348
    },
    {
        "content": "<p>Do you know its number? I'd be interested in reviewing that</p>",
        "id": 500006438,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1739708601
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/20924\">#20924</a></p>",
        "id": 500012125,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739713517
    },
    {
        "content": "<p>Interesting discussions! I have also been thinking about this question. Ideally, I want to be able to state a spec of a function that talks about both its return value and its complexity. E.g. in the format of the challenges  at <a href=\"http://www.codeproofarena.com:8000/\">Code with Proofs: Arena</a>. And then given a function implementation and proof that it satisfies the spec, I know that the  function is both correct and efficient. </p>\n<p>I have been  experimenting with the monadic approach: use a monad to count the operation we want to keep track of. E.g. to count the number of the addition operations of an implementation of Fibonacci, a spec would be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"n\">ma</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ma</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"bp\">⟩</span>\n\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">increment</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">((),</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">countingOp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">increment</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Original recursive implementation</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">      </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"c1\">-- Linear-time implementation of f</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fLinear</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">fLinear_correct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">fLinear</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">fLinear_op_calls</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span>\n<span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cnt</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"bp\">-&gt;</span>\n<span class=\"w\">  </span><span class=\"o\">((</span><span class=\"n\">fLinear</span><span class=\"w\"> </span><span class=\"n\">countingOp</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">cnt</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"m\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">cnt</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">cnt</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"n\">cnt</span>\n<span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Here one can't avoid the counting by simply using +, since <code>op</code> could be something other than addition.</p>\n<p>A linear time implementation would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Linear-time implementation of f</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fLinear</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">loop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">        </span><span class=\"n\">loop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">    </span><span class=\"n\">loop</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>(proof exercise for the reader)</p>\n<p>One nice thing is that once I am satisfied that fLinear has the right properties, I can turn off the counting and just use fLinear with minimum overhead.</p>",
        "id": 500106534,
        "sender_full_name": "GasStationManager",
        "timestamp": 1739778911
    },
    {
        "content": "<p>I kind of suspect that this is not perfectly secure, that someone could potentially cheat by somehow \"hacking\" the monad. The PR linked above seems more secure, and seems great for proving lower bounds, but perhaps not so easy to express general algorithms in that formalism. Is  there something in  between? Maybe using metaprogramming to make a secure version?</p>",
        "id": 500109391,
        "sender_full_name": "GasStationManager",
        "timestamp": 1739779779
    }
]