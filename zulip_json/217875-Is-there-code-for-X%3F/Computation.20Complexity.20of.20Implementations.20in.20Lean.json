[
    {
        "content": "<p>I was wondering if there is a way to argue about the computational complexity of implementations of certain algorithms in Lean.</p>\n<p>For example, consider the two implementations of search:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">findIndex</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">1</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">              </span><span class=\"k\">else</span>\n<span class=\"w\">                </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">findIndex</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">;</span>\n<span class=\"w\">                </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">                  </span><span class=\"bp\">-</span><span class=\"mi\">1</span>\n<span class=\"w\">                </span><span class=\"k\">else</span>\n<span class=\"w\">                  </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>and </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">binarySearchLowHi</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">low</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hi</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">low</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">low</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"bp\">;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mid</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">               </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">               </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">;</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_i_lt_n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mid</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"gr\">sorry</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ^ NOTE:</span>\n<span class=\"w\">    </span><span class=\"c1\">-- This proof is required to ensure that</span>\n<span class=\"w\">    </span><span class=\"c1\">-- list.get can be called with the index `i`</span>\n<span class=\"w\">    </span><span class=\"c1\">-- without any runtime errors.</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mid_val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">mid</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h_i_lt_n</span><span class=\"bp\">⟩;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">mid_val</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">mid</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">mid_val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">binarySearchLowHi</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mid</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hi</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">binarySearchLowHi</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">low</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mid</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">low</span>\n<span class=\"n\">decreasing_by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">rename_i</span><span class=\"w\"> </span><span class=\"n\">h_hi_leq_low</span>\n<span class=\"w\">  </span><span class=\"c1\">-- We only have to prove termination for the recursive case when</span>\n<span class=\"w\">  </span><span class=\"c1\">-- `low &lt;= hi`. This is because the base case is already covered by the `if low &gt; hi then -1` line.</span>\n<span class=\"w\">  </span><span class=\"c1\">-- We rename the hypothesis to `h_hi_leq_low` to make it more readable.</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h_hi_leq_low</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_sum_mod_2_eq_0_or_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h_sum_mod_2_eq_0_or_1</span>\n<span class=\"w\">  </span><span class=\"n\">rename_i</span><span class=\"w\"> </span><span class=\"n\">h_sum_mod_2_eq_0</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h_sum_mod_2_eq_0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c1\">-- at this point, prove that hi - ((low + hi) / 2 + 1) &lt; hi - low</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">rename_i</span><span class=\"w\"> </span><span class=\"n\">h_sum_mod_2_eq_1</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h_sum_mod_2_eq_1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c1\">-- at this point, prove that hi - ((low + hi - 1) / 2 + 1) &lt; hi - low</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>How can I state that binary search is faster than the simple search given the list is sorted</p>",
        "id": 499985738,
        "sender_full_name": "Amitayush Thakur",
        "timestamp": 1739688659
    },
    {
        "content": "<p>This isn't true, because a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List#doc\">docs#List</a> is a linked list, so it's actually less efficient and can be <code>O(n log(n))</code></p>",
        "id": 499987015,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1739689982
    },
    {
        "content": "<p>However, in any case, due to function extensionality (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=funext#doc\">docs#funext</a>) you can't state this directly about the function</p>",
        "id": 499987045,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1739690027
    },
    {
        "content": "<p>Okay agreed, my implementation may not use Array where I would have been able to write it more efficiently. </p>\n<p>However, my question is more general. Can we argue about the time complexity of functions in general? But It seems that based on <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Core.html#funext\">https://leanprover-community.github.io/mathlib4_docs/Init/Core.html#funext</a>, we cannot state that one function is faster than another. However, I was wondering if we could define some form of measure to describe the number of computations needed to execute the function.</p>",
        "id": 499987560,
        "sender_full_name": "Amitayush Thakur",
        "timestamp": 1739690554
    },
    {
        "content": "<p>Yes you can. I’m from my phone so it’s hard to search, but there were past discussions here on Zulip (and I think some still open PRs) with several approaches. One fairly straightforward option is to replace your function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">f : \\alpha \\to \\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>f</mi><mo>ˉ</mo></mover><mo>:</mo><mi>α</mi><mo>→</mo><mi>β</mi><mo>×</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\bar{f} : \\alpha \\to \\beta \\times \\N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0257em;vertical-align:-0.1944em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8312em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span><span style=\"top:-3.2634em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.0833em;\"><span class=\"mord\">ˉ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1944em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>, where the extra natural number you carry around is your complexity measure (eg: number of comparisons, arithmetical ops, etc). Then you prove all your usual complexity results about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>f</mi><mo>ˉ</mo></mover><mn>.2</mn></mrow><annotation encoding=\"application/x-tex\">\\bar{f}.2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0257em;vertical-align:-0.1944em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8312em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span><span style=\"top:-3.2634em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.0833em;\"><span class=\"mord\">ˉ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1944em;\"><span></span></span></span></span></span><span class=\"mord\">.2</span></span></span></span> and use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>f</mi><mo>ˉ</mo></mover><mn>.1</mn></mrow><annotation encoding=\"application/x-tex\">\\bar{f}.1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0257em;vertical-align:-0.1944em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8312em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span><span style=\"top:-3.2634em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.0833em;\"><span class=\"mord\">ˉ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1944em;\"><span></span></span></span></span></span><span class=\"mord\">.1</span></span></span></span> for correctness and applications</p>",
        "id": 499998302,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1739701020
    },
    {
        "content": "<p>There is an open PR with a more principled approach to this</p>",
        "id": 500005172,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739707348
    },
    {
        "content": "<p>Do you know its number? I'd be interested in reviewing that</p>",
        "id": 500006438,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1739708601
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/20924\">#20924</a></p>",
        "id": 500012125,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739713517
    },
    {
        "content": "<p>Interesting discussions! I have also been thinking about this question. Ideally, I want to be able to state a spec of a function that talks about both its return value and its complexity. E.g. in the format of the challenges  at <a href=\"http://www.codeproofarena.com:8000/\">Code with Proofs: Arena</a>. And then given a function implementation and proof that it satisfies the spec, I know that the  function is both correct and efficient. </p>\n<p>I have been  experimenting with the monadic approach: use a monad to count the operation we want to keep track of. E.g. to count the number of the addition operations of an implementation of Fibonacci, a spec would be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"n\">ma</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ma</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"bp\">⟩</span>\n\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">increment</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">((),</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">countingOp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">increment</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Original recursive implementation</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">      </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"c1\">-- Linear-time implementation of f</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fLinear</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">fLinear_correct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">fLinear</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">fLinear_op_calls</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span>\n<span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cnt</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"bp\">-&gt;</span>\n<span class=\"w\">  </span><span class=\"o\">((</span><span class=\"n\">fLinear</span><span class=\"w\"> </span><span class=\"n\">countingOp</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">cnt</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"m\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">cnt</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">cnt</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"n\">cnt</span>\n<span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Here one can't avoid the counting by simply using +, since <code>op</code> could be something other than addition.</p>\n<p>A linear time implementation would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Linear-time implementation of f</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fLinear</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">loop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">        </span><span class=\"n\">loop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">    </span><span class=\"n\">loop</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>(proof exercise for the reader)</p>\n<p>One nice thing is that once I am satisfied that fLinear has the right properties, I can turn off the counting and just use fLinear with minimum overhead.</p>",
        "id": 500106534,
        "sender_full_name": "GasStationManager",
        "timestamp": 1739778911
    },
    {
        "content": "<p>I kind of suspect that this is not perfectly secure, that someone could potentially cheat by somehow \"hacking\" the monad. The PR linked above seems more secure, and seems great for proving lower bounds, but perhaps not so easy to express general algorithms in that formalism. Is  there something in  between? Maybe using metaprogramming to make a secure version?</p>",
        "id": 500109391,
        "sender_full_name": "GasStationManager",
        "timestamp": 1739779779
    },
    {
        "content": "<p>I'm pondering formalizing PolyTime in Lean. It looks like funext makes it impossible to refer to a specific implementation of a function. E.g, given:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fib_impl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>one can prove <code>h : fib_impl = fib</code>. So regardless of what definition of <code>PolyTime</code> one could think up, given <code>t : PolyTime fib_impl</code> we get <code>h ▸ t : PolyTime fib</code>.</p>\n<p>In other words Lean's value of a function only refers to its semantics. To define PolyTime we have to somehow refer to its implementation. Maybe this could somehow be possible by extracting elaborated <code>Lean.Expr</code> of a function and defining PolyTime on it?</p>\n<p>One more though is that maybe we could define PolyTime to mean \"there exists a polynomial implementation of this function\". This definition would not contradict funext.</p>",
        "id": 540074457,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1758132274
    },
    {
        "content": "<p>You'd have to formalize an algorithm in some separate way, using Turing Machines or Lambda Calculus or whatever your favorite model of computation is</p>",
        "id": 540078544,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1758133768
    },
    {
        "content": "<p>I think we want polytime to be independent of what the compiler is doing</p>",
        "id": 540078581,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758133781
    },
    {
        "content": "<p>Then you can talk about the number of operations employed in an algorithm, and then you can formalize computational complexity as some equivalence class of this function</p>",
        "id": 540078751,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1758133834
    },
    {
        "content": "<p>You could use the free monad from CSLib, which you can instantiate with an effect for an \"addition oracle\"</p>",
        "id": 540079665,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758134169
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Computation.20Complexity.20of.20Implementations.20in.20Lean/near/540078544\">said</a>:</p>\n<blockquote>\n<p>You'd have to formalize an algorithm in some separate way, using Turing Machines or Lambda Calculus or whatever your favorite model of computation is</p>\n</blockquote>\n<p>The point is, that elaborated <code>Lean.Expr</code> is already Lambda Calculus term.</p>",
        "id": 540114045,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1758149567
    },
    {
        "content": "<p>it's actually a Lean Expr term</p>",
        "id": 540114115,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758149611
    },
    {
        "content": "<p>depending on which variant of lambda calculus you use it may not be a lambda calculus term</p>",
        "id": 540114142,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758149629
    },
    {
        "content": "<p>I agree, it's some Lambda Calculus. I think it's similar, but not exactly, to the usual System F.<br>\nIt still should be possible to define PTIME in terms of number of beta-reductions of <code>Lean.Expr</code>.</p>",
        "id": 540114795,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1758150025
    },
    {
        "content": "<p>Remember the natural number <code>n</code> is represented as <code>n</code> applications of <code>Nat.succ</code> to <code>Nat.zero</code></p>",
        "id": 540115014,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758150147
    },
    {
        "content": "<p>well...</p>",
        "id": 540115244,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758150282
    },
    {
        "content": "<p>It could also be <code>Lean.Expr.lit</code>? I don't know when it's used and how the Nat optimization works.</p>",
        "id": 540115258,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1758150290
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Computation.20Complexity.20of.20Implementations.20in.20Lean/near/540115258\">said</a>:</p>\n<blockquote>\n<p>It could also be <code>Lean.Expr.lit</code>? I don't know when it's used and how the Nat optimization works.</p>\n</blockquote>\n<p>there's a whole list of optimizations for reducing applications of certain function on nat literals</p>",
        "id": 540115695,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758150551
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.reduceNat%3F#doc\">docs#Lean.Meta.reduceNat?</a></p>",
        "id": 540115705,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758150554
    },
    {
        "content": "<p>The distinction between binary and unary representation of numbers is important and completely changes what is PTIME and what isn't. So this distinction will also have to be somehow made in Lean.</p>",
        "id": 540115877,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1758150673
    },
    {
        "content": "<p>My understanding is that Lean has two different types of optimizations: Compiler-level optimizations, which only affect the behavior of code at runtime and during <code>native_decide</code>, and kernel-level optimizations, which affect the typechecking of code.</p>\n<p>Most optimizations are compiler-level (you'll see them @[implemented_by] or @[extern] annotations, and maybe also @[csimp]) but there is a kernel-level optimization for Nat which makes arithmetic in Nat use the GNU MultiPrecision library (GMP), which makes reducing integers close to linear time (maybe logarithmic time?) in the number of bits in the number, rather than exponential time in the number of bits in the number.</p>",
        "id": 540115971,
        "sender_full_name": "Niels Voss",
        "timestamp": 1758150725
    },
    {
        "content": "<p>there's also the thing about reducing well-foundedness proofs being slow</p>",
        "id": 540116147,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758150837
    },
    {
        "content": "<p>You might want to check out <a href=\"https://proofassistants.stackexchange.com/q/2018/6046\">https://proofassistants.stackexchange.com/q/2018/6046</a> and <a href=\"https://proofassistants.stackexchange.com/q/1976/6046\">https://proofassistants.stackexchange.com/q/1976/6046</a></p>",
        "id": 540116175,
        "sender_full_name": "Niels Voss",
        "timestamp": 1758150853
    },
    {
        "content": "<p>it seems a bit dangerous to be inspecting expressions of \"real-world\" objects and then outputting things to the \"real world\"</p>",
        "id": 540116193,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758150867
    },
    {
        "content": "<p>(where \"real world\" means the world that Lean thinks it is in)</p>",
        "id": 540116211,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758150878
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Computation.20Complexity.20of.20Implementations.20in.20Lean/near/540116211\">said</a>:</p>\n<blockquote>\n<p>(where \"real world\" means the world that Lean thinks it is in)</p>\n</blockquote>\n<p>what's \"real world\" I don't get it</p>",
        "id": 540116352,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758150964
    },
    {
        "content": "<p>well it depends on whether you believe there is anything beyond the <code>Expr</code>essions</p>",
        "id": 540116403,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758150992
    },
    {
        "content": "<p>I still don't get it</p>",
        "id": 540116424,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758151006
    },
    {
        "content": "<p>like, only countably many real numbers are actually expressable, but there are uncountably many real numbers</p>",
        "id": 540116469,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758151033
    },
    {
        "content": "<p>we have well over 10 different layers of abstraction from the hardware to the Lean program, most of which could be called a \"real world\"</p>",
        "id": 540116531,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758151065
    },
    {
        "content": "<p>and I still don't know if you're referring to any of them</p>",
        "id": 540116544,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758151073
    },
    {
        "content": "<p>probably not</p>",
        "id": 540116572,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758151090
    },
    {
        "content": "<p>I guess ultimately, you have to define a model of computation, and then prove stuff about that. Proving properties about your model of computation is pure math, and can be done in Lean. Translating your lean functions to meta-versions of those functions in your model of computation can be done, but maybe not in a verifiable way (not sure about this). Claiming that your model of computation matches the model of computation in reality is outside the domain of pure math and cannot be formalized in Lean.</p>",
        "id": 540116574,
        "sender_full_name": "Niels Voss",
        "timestamp": 1758151092
    },
    {
        "content": "<p>Exactly! Thank you for saying that clearly!</p>",
        "id": 540116775,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1758151213
    },
    {
        "content": "<p>So my idea is, to define model of computation directly on <code>Lean.Expr</code>. You already have to trust in Lean compiler to do elaboration from Lean language to <code>Lean.Expr</code> that preserves semantics. Lean language is high-level and easier to write in. While <code>Lean.Expr</code> is much simpler and it's easier to define \"computation\" and \"complexity\" on it. This approach makes it possible to prove things about complexity of programs written in high-level Lean language.</p>\n<p>I think that this approach is what is being proposed in the first answer to this question. <a href=\"https://proofassistants.stackexchange.com/questions/2018/what-proof-assistants-can-reason-about-the-complexity-of-its-own-programs\">https://proofassistants.stackexchange.com/questions/2018/what-proof-assistants-can-reason-about-the-complexity-of-its-own-programs</a><br>\nAlthough, I'm not sure whether the author meant to use <code>Lean.Expr</code> or <code>TSyntax</code>.<br>\nEDIT: I think the author meant to use <code>TSyntax</code>. But that would require defining the semantics of Lean's syntax, which would be pretty problematic. And would make it impossible to work with user-defined elaborated syntax.</p>",
        "id": 540117259,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1758151528
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Computation.20Complexity.20of.20Implementations.20in.20Lean/near/540116469\">said</a>:</p>\n<blockquote>\n<p>like, only countably many real numbers are actually expressable, but there are uncountably many real numbers</p>\n</blockquote>\n<p>I think you could define real numbers to be only these real numbers there are expressable in Lean, and that wouldn't change anything from the Lean side. Every theorem would still be true and you wouldn't be able to prove more theorems (in Lean itself).</p>",
        "id": 540122204,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1758154671
    },
    {
        "content": "<p>but there are uncountably many real numbers</p>",
        "id": 540123589,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758155598
    },
    {
        "content": "<p>and countably many expressible ones</p>",
        "id": 540123599,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758155607
    },
    {
        "content": "<p>you should clarify what you mean by that</p>",
        "id": 540123633,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758155616
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Computation.20Complexity.20of.20Implementations.20in.20Lean/near/540117259\">said</a>:</p>\n<blockquote>\n<p>So my idea is, to define model of computation directly on <code>Lean.Expr</code>. You already have to trust in Lean compiler to do elaboration from Lean language to <code>Lean.Expr</code> that preserves semantics. Lean language is high-level and easier to write in. While <code>Lean.Expr</code> is much simpler and it's easier to define \"computation\" and \"complexity\" on it. This approach makes it possible to prove things about complexity of programs written in high-level Lean language.</p>\n<p>I think that this approach is what is being proposed in the first answer to this question. <a href=\"https://proofassistants.stackexchange.com/questions/2018/what-proof-assistants-can-reason-about-the-complexity-of-its-own-programs\">https://proofassistants.stackexchange.com/questions/2018/what-proof-assistants-can-reason-about-the-complexity-of-its-own-programs</a><br>\nAlthough, I'm not sure whether the author meant to use <code>Lean.Expr</code> or <code>TSyntax</code>.<br>\nEDIT: I think the author meant to use <code>TSyntax</code>. But that would require defining the semantics of Lean's syntax, which would be pretty problematic. And would make it impossible to work with user-defined elaborated syntax.</p>\n</blockquote>\n<p>This is still a highly underspecified approach though. You don't just get away with saying that you are in a lambda calculus in complexity. What kind of semantics do you have for that calculus? And what sort of operation are you even counting as a computation step. Lean.Expr answers you none of these questions and depending on your answer to these questions your proofs might end up looking vastly different.</p>",
        "id": 540157572,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1758178349
    },
    {
        "content": "<p>To add to all the above, the query/free monad approach can let you capture complexity in many models.</p>",
        "id": 540182496,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1758186099
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Computation.20Complexity.20of.20Implementations.20in.20Lean/near/540157572\">said</a>:</p>\n<blockquote>\n<p>This is still a highly underspecified approach though.</p>\n</blockquote>\n<p>That's why I called it \"idea\". I'm currently exploring it. I appreciate the comments, especially pointing out the problems with that approach. IIrc for an untyped lambda calculus if you apply beta-reductions in a normal order (i.e. left to right) and count number of beta-reductions you get a definition of complexity that is equivalent to a typical definition in turing machines up to some linear term. I.e. you can simulate beta-reduction on turing machine and you can simulate turing machines in lambda calculus, both in linear time. But that's for untyped lambda calculus, no idea if the result applies for System F, or specifically for <code>Lean.Expr</code> in this case.</p>",
        "id": 540209163,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1758194994
    },
    {
        "content": "<p>You also have to keep in mind that turing machines are not necessarily the model of complexity you want to aim for. e.g. RAM machines are much more interesting if you want to talk about \"real world\" algorithms.</p>",
        "id": 540219139,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1758198022
    },
    {
        "content": "<p>Speaking of RAM machines, you need to be really careful about what a word means in this RAM, and what operations are unit operations. That being said, the relevant conceptual content in algorithms can be expressed at a higher level of abstraction than the RAM model.</p>",
        "id": 540219923,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1758198252
    },
    {
        "content": "<p>In many cases it is more important to know that you can solve a problem by so many max s-t flow queries, or reachability queries, than it is to know the exact complexity.</p>",
        "id": 540220340,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1758198381
    },
    {
        "content": "<p>RAM machine model also gives exactly the same PTIME class I think?</p>",
        "id": 540241741,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1758204012
    },
    {
        "content": "<p>My use-case for formalizing complexity is in cryptography, e.g. zero-knowledge proofs.</p>",
        "id": 540241891,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1758204050
    }
]