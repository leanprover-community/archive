[
    {
        "content": "<p>Is there really no better way to write the additive subgroup consisting of all <code>n ‚Ä¢ g</code> for <code>g : G</code>, where <code>G</code> is a commutative additive group, than</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">QuotientAddGroup</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nsmulAddMonoidHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span>\n</code></pre></div>\n<p>?<br>\n(For <code>n = 2</code>, there is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddSubgroup.even#doc\">docs#AddSubgroup.even</a>, but I was unable to find a more general version.)<br>\nIdeally, I would want to write <code>n ‚Ä¢ G</code> (which pretty certainly will not work), or at least <code>n ‚Ä¢ (‚ä§ : Subgroup G)</code>.</p>",
        "id": 563708849,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1765742119
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddSubgroup.zmultiples#doc\">docs#AddSubgroup.zmultiples</a> ?</p>",
        "id": 563709036,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1765742381
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddSubgroup.zmultiples#doc\">docs#AddSubgroup.zmultiples</a></p>",
        "id": 563709038,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765742383
    },
    {
        "content": "<p>That's not what I want: I want <code>g</code> to vary, with <code>n</code> fixed.</p>",
        "id": 563709066,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1765742422
    },
    {
        "content": "<p>oh</p>",
        "id": 563709091,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765742448
    },
    {
        "content": "<p>Does <code>n ‚Ä¢ (‚ä§ : AddSubgroup G)</code> not work?</p>",
        "id": 563709097,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1765742453
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">SMul</span><span class=\"w\"> </span><span class=\"n\">‚Ñ§</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AddSubgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 563709127,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1765742481
    },
    {
        "content": "<p><code>open scoped Pointwise</code></p>",
        "id": 563709209,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1765742628
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">Pointwise</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">SMul</span><span class=\"w\"> </span><span class=\"n\">‚Ñ§</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AddSubgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- failn't</span>\n</code></pre></div>",
        "id": 563709216,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765742634
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddSubgroup.pointwiseMulAction#doc\">docs#AddSubgroup.pointwiseMulAction</a> is the instance</p>",
        "id": 563709257,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1765742692
    },
    {
        "content": "<p>And while we are at it, is there a more idiomatic way to state that a <code>s : Set G</code> contains representatives of all cosets than</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">SurjOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">QuotientAddGroup</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚ä§</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddSubgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>?<br>\nThere is the left hand side of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddSubgroup.leftCoset_cover_const_iff_surjOn#doc\">docs#AddSubgroup.leftCoset_cover_const_iff_surjOn</a>, but it doesn't appear to be more convenient to use...</p>",
        "id": 563709792,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1765743514
    },
    {
        "content": "<p>cosets of which subgroup?</p>",
        "id": 563710945,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1765744907
    },
    {
        "content": "<p>Cosets of <code>n ‚Ä¢ G</code>. (But which subgroup should not matter so  much...)</p>",
        "id": 563710968,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1765744956
    },
    {
        "content": "<p><code>s ‚Ä¢ H = ‚ä§</code>, where <code>H</code> is the subgroup?</p>",
        "id": 563711630,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1765745895
    },
    {
        "content": "<p>or are you looking for a more faithful translation rather than an equivalent statement</p>",
        "id": 563711642,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1765745913
    },
    {
        "content": "<p>(actually I think I assumed we're using multiplication, so maybe we need <code>+·µ•</code> instead)</p>",
        "id": 563711694,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1765745992
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddSubgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">Pointwise</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ContainsRepresentativesOfAllCosets</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">+·µ•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span>\n<span class=\"c1\">-- or `Set.univ` if `‚ä§` is weird here</span>\n</code></pre></div>",
        "id": 563711811,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1765746105
    },
    {
        "content": "<p>Compare <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddSubgroup.leftCoset_cover_const_iff_surjOn#doc\">docs#AddSubgroup.leftCoset_cover_const_iff_surjOn</a> ...<br>\nI'll see if it looks better.</p>",
        "id": 563712936,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1765747393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/n.20.E2.80.A2.20G.20as.20a.20subgroup.3F/near/563712936\">said</a>:</p>\n<blockquote>\n<p>Compare <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddSubgroup.leftCoset_cover_const_iff_surjOn#doc\">docs#AddSubgroup.leftCoset_cover_const_iff_surjOn</a> ...<br>\nI'll see if it looks better.</p>\n</blockquote>\n<p><code>leftCoset_cover_const_iff_surjOn</code> is really auxiliary to the main results in the file <code>CosetCover</code> which are, by and large, the ones mentioned the file's docstring.</p>\n<p>If anything, it would be nice to eliminate <code>leftCoset_cover_const_iff_surjOn</code> in favour of some more generally useful lemma defined closer to the root of the hierarchy.</p>\n<p>I don't know if something like the following would help.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Setoid</span><span class=\"bp\">.</span><span class=\"n\">Partition</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">GroupTheory</span><span class=\"bp\">.</span><span class=\"n\">Coset</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">Pointwise</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">leftCosets</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">Setoid</span><span class=\"bp\">.</span><span class=\"n\">isPartition_leftCosets</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"bp\">.</span><span class=\"n\">IsPartition</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">leftCosets</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">leftCosets</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">notMem_setOf_iff</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">push_neg</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">smul_mem_smul_set</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">one_mem</span>\n<span class=\"w\">  </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">H</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">leftCosets</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">leftCoset_eq_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mem_leftCoset_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">QuotientGroup</span><span class=\"bp\">.</span><span class=\"n\">eq</span><span class=\"o\">]</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚ãÉ‚ÇÄ</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">leftCosets</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Setoid</span><span class=\"bp\">.</span><span class=\"n\">isPartition_leftCosets</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sUnion_eq_univ</span>\n</code></pre></div>",
        "id": 564690719,
        "sender_full_name": "Richard Copley",
        "timestamp": 1766149179
    },
    {
        "content": "<p>I'm now stating the condition that <code>n ‚Ä¢ G</code> has finite index in <code>G</code> as <code>(nsmulAddMonoidHom (Œ± := G) n).range.FiniteIndex</code>, to avoid the problems mentioned in <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/SMul.20diamond.20on.20subsets/near/563827186\">#mathlib4 &gt; SMul diamond on subsets @ üí¨</a> . It's less nice to read, but easier to work with. (See <a href=\"https://github.com/MichaelStollBayreuth/Heights/blob/master/Heights/Descent.lean\">here</a>.)</p>",
        "id": 564706318,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1766154009
    }
]