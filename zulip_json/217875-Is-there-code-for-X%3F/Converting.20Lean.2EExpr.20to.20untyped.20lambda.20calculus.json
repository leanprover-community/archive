[
    {
        "content": "<p>Is there maybe some code that does type erasure on Lean.Expr?</p>",
        "id": 565364555,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766663660
    },
    {
        "content": "<p>I believe there is some type of intermediate language generated as part of the compiler pipeline, which is discussed in \"Counting Immutable Beans\", but I think it's still quite far from untyped lambda calculus.</p>\n<p>What is the purpose of the translation to untyped lambda calculus? Does it need to be runnable?</p>",
        "id": 565384428,
        "sender_full_name": "Niels Voss",
        "timestamp": 1766685677
    },
    {
        "content": "<p>I want to create a framework where you can prove a statement like \"REACHABILITY ∈ P\" by implementing polynomial algorithm for REACHABILITY in Lean. The idea is to convert Lean.Expr to untyped lambda calculus and then to TM. The proof of TM implementation being polynomial can be obtained from untyped lambda calculus implementation being polynomial (with call-by-value computational model, see <a href=\"https://www.ps.uni-saarland.de/Publications/documents/ForsterSmolka_2017_L-Computability.pdf\">https://www.ps.uni-saarland.de/Publications/documents/ForsterSmolka_2017_L-Computability.pdf</a>).</p>",
        "id": 565385495,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766687401
    },
    {
        "content": "<p>Are you following <a class=\"stream-topic\" data-stream-id=\"513188\" href=\"/#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/with/563449404\">#CSLib &gt; Proposal on Time Complexity</a> and <a class=\"stream-topic\" data-stream-id=\"513188\" href=\"/#narrow/channel/513188-CSLib/topic/proofs.20with.20Std.2EDo/with/560417249\">#CSLib &gt; proofs with Std.Do</a>?<br>\nBasically, are you doing this because you're not aware of existing solutions or because you believe a better solution exists?</p>",
        "id": 565391793,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766698174
    },
    {
        "content": "<p>I haven't read through entire <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/with/563449404\">#CSLib &gt; Proposal on Time Complexity</a>, but I think it's a discussion about query model i.e. <a href=\"https://api.cslib.io/docs/Cslib/Algorithms/Lean/TimeM.html#Cslib.Algorithms.Lean.TimeM\">Cslib.Algorithms.Lean.TimeM</a>. There are a few comments in this topic saying that it's possible to relate query model to computational models, but I don't think there is any existing solution atm. I'm trying a different approach.</p>",
        "id": 565413040,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766730214
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 565414847,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766732183
    },
    {
        "content": "<p>wdym, Boole and Std.Do are direct competitors to what you're suggesting IIUC</p>",
        "id": 565427074,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766742622
    },
    {
        "content": "<p>Does Boole refers to <a href=\"https://github.com/Yu-Maryland/BoolE\">https://github.com/Yu-Maryland/BoolE</a> ? I also don't understand Std.Do very well. Isn't it for proving properties about monadic programs? And from what I read about BoolE, it's about automation for that. I fail to see where is computational model and time complexity in there? It's definitely useful for proving correctness and properties of time complexity in e.g. query model and any computational model with imperative style algorithms. What I suggested is a different model than query model. So I guess it is in some sense a competitor to Std.Do because it's not imperative? Though, it might be that Std.Do would also be useful for me, because it might be easier to reason about time complexity in weak call-by-value λ-calculus with it. Also, you said that there's existing solution, but I couldn't find any information about work for relating query model with any computational model.</p>",
        "id": 565428532,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766743812
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Converting.20Lean.2EExpr.20to.20untyped.20lambda.20calculus/near/565428532\">said</a>:</p>\n<blockquote>\n<p>Does Boole refers to <a href=\"https://github.com/Yu-Maryland/BoolE\">https://github.com/Yu-Maryland/BoolE</a> ?</p>\n</blockquote>\n<p>No, it's an upcoming solution by Amazon/CSLib for implementing and analyzing algorithms in Lean, probably with a DSL.<br>\nThere aren't many details on it yet, and I'm not sure what the timeline on it is; they said August in multiple places but I guess that was postponed.</p>\n<p>I might be missing some nuance as your message about different models goes over my head, but here's what I understand, correct me if I'm wrong:</p>\n<p>You (and many <a href=\"#narrow/channel/513188-CSLib/topic/Getting.20Started.3A.20Contributing.20Algorithm.20Proofs.20to.20CSLib/with/562595712\">other</a> <a href=\"#narrow/channel/113488-general/topic/cook.20levin.2C.20np.20completeness.20of.20SAT/with/560908873\">people</a>, including myself) are looking for a way to prove statements in complexity theory / algorithms (such as <code>REACHABILITY ∈ P</code> that you mentioned), by implementing an algorithm and analyzing its complexity in Lean.<br>\nThere are multiple existing solutions:</p>\n<ul>\n<li><a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a></li>\n<li><a href=\"https://github.com/leanprover/cslib/pull/201\">cslib#201</a></li>\n<li><code>Std.Do</code></li>\n<li>Waiting for Boole to be released</li>\n</ul>\n<p>There might be differences in what they are counting exactly to analyze complexity, but they're trying to solve the same issue.<br>\nIIUC you're suggesting converting Lean code to a lambda calculus term or TM, which sounds pretty similar to how you can implement analyzable algorithms in Lean code using <code>Std.Do</code></p>",
        "id": 565449237,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766760926
    },
    {
        "content": "<p>I think he is describing Sebastian's solution</p>",
        "id": 565449892,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766761372
    },
    {
        "content": "<p>Which is similar to <a href=\"https://github.com/leanprover/cslib/pull/201\">cslib#201</a> upto a point</p>",
        "id": 565449915,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766761390
    },
    {
        "content": "<p>Sebastian instead wants to tag a list of lean declarations whose calls are to be counted and then compile a lean function marked with a suitable attribute to TimeM</p>",
        "id": 565449952,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766761428
    },
    {
        "content": "<p>I like the idea in principle but it will super hard in practice, especially if the costs of operations depend on the size of their inputs</p>",
        "id": 565450009,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766761475
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"933054\">@Snir Broshi</span> except for Boole, which I couldn't find any information about, I don't see how any of the existing solutions you mention can be directly used to prove anything in terms of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/TMComputable.html#Turing.TM2ComputableInPolyTime\">Turing.TM2ComputableInPolyTime</a> (this is mathlib's definition of <code>f ∈ P</code>).</p>",
        "id": 565504237,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766832976
    },
    {
        "content": "<p>you prove that a given model can be simulated by a TM in polytime and then express <code>f</code> in that model</p>",
        "id": 565511333,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766842243
    },
    {
        "content": "<p>Yeah, so what I want to do is to prove that Lean.Expr can be simulated in polytime, and then you can express <code>f</code> in Lean (which gets elaborated to Lean.Expr). And I think what Snir Broshi is speaking about are only tools for making models, yet, there isn't any high-level computational model implemented in Lean yet.</p>",
        "id": 565515421,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766847789
    },
    {
        "content": "<p>Nope there isn’t. I am not sure it is worth doing it either. The recursive definition you write in lean goes through a compiler that will make a bazillion choices on how to evaluate a Lean.Expr. This includes beta/eta reduction strategies, tail call optimisation, reference counting and so on.</p>",
        "id": 565519517,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766854279
    },
    {
        "content": "<p>You can try enforcing a simple execution cost model making simple assumptions on lean’s execution of Exprs but that might not give you this poly time simulation you are looking for</p>",
        "id": 565519539,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766854338
    },
    {
        "content": "<p>But the computational model I'll define will be different from the one defined by the compiler. What compiler is doing doesn't matter.</p>",
        "id": 565519602,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766854481
    },
    {
        "content": "<p>Ah, sorry, that's what you said in the second paragraph. I think, the simplified model is fine for stuff like polytime, but I might be wrong. I think all optimizations you mentioned doesn't even affect time complexity more than the linear factor in the sense of big O notation. Reference counting greatly affects size complexity though.</p>",
        "id": 565519650,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766854572
    },
    {
        "content": "<p>What’s your beta reduction strategy?</p>",
        "id": 565520247,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766855186
    },
    {
        "content": "<p>That’s going to make a huge difference</p>",
        "id": 565520263,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766855197
    },
    {
        "content": "<p>And then you have to somehow avoid being able to rewrite with an equivalent function that reduces differently but is extensionally equal</p>",
        "id": 565520290,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766855232
    },
    {
        "content": "<p>Ah yes, you would have to use Lean.Expr directly in complexity proofs for that reason. Which would require reimplementing many tactics to make it easier. Though I would hope that most proofs would get dispatched automatically.</p>",
        "id": 565520423,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766855390
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Converting.20Lean.2EExpr.20to.20untyped.20lambda.20calculus/near/565520247\">said</a>:</p>\n<blockquote>\n<p>What’s your beta reduction strategy?</p>\n</blockquote>\n<p>Call-by-value, as described in this paper: <a href=\"https://www.ps.uni-saarland.de/Publications/documents/ForsterSmolka_2017_L-Computability.pdf\">https://www.ps.uni-saarland.de/Publications/documents/ForsterSmolka_2017_L-Computability.pdf</a></p>",
        "id": 565522621,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766858058
    }
]