[
    {
        "content": "<p>During the project described in <a href=\"#narrow/channel/287929-mathlib4/topic/The.20.60Ext.60.20functor\">here</a>, we encountered the following lemma. But after struggling on relevant things for a day, I really don't know how I should prove this. Can anyone help me on that? (I think this is true mathematically, but please correct me if I'm wrong). Thanks in advance!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Abelian</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">uC</span><span class=\"w\"> </span><span class=\"n\">uC'</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uC</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">uC'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">uC</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Abelian</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasExt</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">CatCenter</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">End</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">ùü≠</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">homCommute</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CatCenter</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Ext</span><span class=\"bp\">.</span><span class=\"n\">mk‚ÇÄ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">postcomp</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">add_zero</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ext</span><span class=\"bp\">.</span><span class=\"n\">mk‚ÇÄ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">precomp</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">zero_add</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 510869201,
        "sender_full_name": "Wang Jingting",
        "timestamp": 1744100674
    },
    {
        "content": "<p>About how we've attempted to work on this: The first attempt is to remove the <code>SmallShiftedHom</code> involved in the theorem and move things into the derived category, but we got stuck here because the shifting functor is just isomorphic to the identity functor when shifting 0 rather than equal to the identity endofunctor.</p>",
        "id": 510870330,
        "sender_full_name": "Wang Jingting",
        "timestamp": 1744101002
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Jo√´l Riou</span> could you take a look on this? Thanks!</p>",
        "id": 510870426,
        "sender_full_name": "Wang Jingting",
        "timestamp": 1744101025
    },
    {
        "content": "<p>I already have code showing that the derived category of a <code>R</code>-linear is <code>R</code>-linear, which shall imply this compatibility. I have some PRs <a href=\"https://github.com/leanprover-community/mathlib4/pull/23777\">#23777</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/23779\">#23779</a> towards this direction.</p>",
        "id": 510871908,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1744101436
    },
    {
        "content": "<p>The good thing is that only the version where alpha is the scalar multiplication will be used, but I think this generalization works as well?</p>",
        "id": 510872179,
        "sender_full_name": "Wang Jingting",
        "timestamp": 1744101516
    },
    {
        "content": "<p>Are there anything in specific we could refer to? We are really stuck at the point where things are squeezed into <code>SmallHom</code>, <code>SmallShiftedHom</code>, ... And the other part is also sort of hard for us. Thanks a lot!</p>",
        "id": 510872637,
        "sender_full_name": "Wang Jingting",
        "timestamp": 1744101669
    },
    {
        "content": "<p>Note: We have the homomorphism from <code>CatCenter C</code> to <code>CatCenter (HomologicalComplex C c)</code> now, so that should probably help?</p>",
        "id": 510873344,
        "sender_full_name": "Wang Jingting",
        "timestamp": 1744101870
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"750070\">Wang Jingting</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Commutative.20morphisms.20involving.20Ext.20functor/near/510872179\">said</a>:</p>\n<blockquote>\n<p>The good thing is that only the version where alpha is the scalar multiplication will be used, but I think this generalization works as well?</p>\n</blockquote>\n<p>I prefer developing the API for <code>R</code>-linear categories. In a subsequent PR, I will show this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">CategoryTheory.Linear.ofRingMorphism</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preadditive</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">œÜ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚Üí+*</span><span class=\"w\"> </span><span class=\"n\">CatCenter</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Linear</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">C</span>\n</code></pre></div>\n<p>so that your statement is not really a generalization of mine.</p>",
        "id": 510874064,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1744102059
    },
    {
        "content": "<p>That's certainly reasonable, but I think that in order to make the lemma work, we'd have to show some compatibility in the construction of Ext?</p>",
        "id": 510874724,
        "sender_full_name": "Wang Jingting",
        "timestamp": 1744102224
    },
    {
        "content": "<p>P.S. Are there some useful suggestions on how we could unpack the <code>SmallHom</code>/<code>SmallShiftedHom</code>?</p>",
        "id": 510875080,
        "sender_full_name": "Wang Jingting",
        "timestamp": 1744102328
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"750070\">Wang Jingting</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Commutative.20morphisms.20involving.20Ext.20functor/near/510875080\">said</a>:</p>\n<blockquote>\n<p>P.S. Are there some useful suggestions on how we could unpack the <code>SmallHom</code>/<code>SmallShiftedHom</code>?</p>\n</blockquote>\n<p>There are bijective maps towards morphisms in the derived category, along with some compatibility lemmas.</p>",
        "id": 510875389,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1744102433
    },
    {
        "content": "<p>Or can I just leave the space for the \"linear\" version of the composition of the <code>Ext</code> functor? Like hoping that </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bilinearComp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Ext</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚Üí+</span><span class=\"w\"> </span><span class=\"n\">Ext</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí+</span><span class=\"w\"> </span><span class=\"n\">Ext</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>could become </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bilinearComp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Linear</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Ext</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚Üí‚Çó</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Ext</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí‚Çó</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Ext</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>with certain defEq properties between the two?</p>",
        "id": 510879021,
        "sender_full_name": "Wang Jingting",
        "timestamp": 1744103453
    },
    {
        "content": "<p>If you plan to update something like this in a future PR, I guess this version will work for us as well?</p>",
        "id": 510879160,
        "sender_full_name": "Wang Jingting",
        "timestamp": 1744103498
    },
    {
        "content": "<p>I have implemented the <code>R</code>-module structure on <code>Ext</code> groups and the expected compatibilities at <a href=\"https://github.com/leanprover-community/mathlib4/commit/3deb64826b2a9c619fbbf047acd9a48f046ab8b8\">https://github.com/leanprover-community/mathlib4/commit/3deb64826b2a9c619fbbf047acd9a48f046ab8b8</a><br>\n(It will take a few PRs before this gets into mathlib.)</p>",
        "id": 510892328,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1744107249
    },
    {
        "content": "<p>Thanks a lot! Then I guess we'll be depending on your PRs.</p>",
        "id": 510896519,
        "sender_full_name": "Wang Jingting",
        "timestamp": 1744108658
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"750070\">Wang Jingting</span> has marked this topic as resolved.</p>",
        "id": 510898269,
        "sender_full_name": "Notification Bot",
        "timestamp": 1744109224
    }
]