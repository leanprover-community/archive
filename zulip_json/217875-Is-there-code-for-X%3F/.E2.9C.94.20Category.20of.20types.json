[
    {
        "content": "<p>how can I use the fact that Lean types form a category? For example I would like to do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Closed</span><span class=\"bp\">.</span><span class=\"n\">Cartesian</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Closed</span><span class=\"bp\">.</span><span class=\"n\">Types</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Limits</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">point_surjective</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasTerminal</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⊤_</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⊤_</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">point_surjective_function_is_surjective</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">point_surjective</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Surjective</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>where I use the fact there is a terminal type. The error <code>typeclass instance problem is stuck, it is often due to metavariables, HasTerminal ?m.17622</code> when I try to assume <code>point_surjective f</code>. I found the instance <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Closed/Types.html#CategoryTheory.instCartesianClosedType\">CategoryTheory.instCartesianClosedType</a> which seems to be what I need.</p>",
        "id": 465029827,
        "sender_full_name": "mdnestor",
        "timestamp": 1724606512
    },
    {
        "content": "<p>you're probably missing an import. Please provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 465029911,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724606593
    },
    {
        "content": "<p>ok, I edited to included my current imports</p>",
        "id": 465029983,
        "sender_full_name": "mdnestor",
        "timestamp": 1724606671
    },
    {
        "content": "<p>the issue is that in the theorem you use a function, not a hom.</p>",
        "id": 465029998,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724606696
    },
    {
        "content": "<p>Try this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">point_surjective_function_is_surjective</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">point_surjective</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Function.Surjective</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 465030008,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724606705
    },
    {
        "content": "<p>That does work. Though I'm a bit confused what is the difference between a function and a hom between types. For example <code>Function.Surjective</code> takes a function between types but still accepts a hom.</p>",
        "id": 465030258,
        "sender_full_name": "mdnestor",
        "timestamp": 1724606999
    },
    {
        "content": "<p>I see under <code>CategoryTheory.Types</code> they are equal</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">types_hom</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 465030449,
        "sender_full_name": "mdnestor",
        "timestamp": 1724607162
    },
    {
        "content": "<p>The issue is that the type class system needs to know what category structure to use in your definition. If you just give a plain function, it has no way to know this.</p>",
        "id": 465031037,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1724607761
    },
    {
        "content": "<p>That makes sense. Another way to write the statement is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">point_surjective_function_is_surjective</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">point_surjective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">asHom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)):</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Surjective</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>where <code>asHom</code> converts from function to hom in the category of types. For whatever reason this is preferable to me.</p>",
        "id": 465031511,
        "sender_full_name": "mdnestor",
        "timestamp": 1724608244
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"519306\">mdnestor</span> has marked this topic as resolved.</p>",
        "id": 465031526,
        "sender_full_name": "Notification Bot",
        "timestamp": 1724608267
    }
]