[
    {
        "content": "<p>I am wondering if there already is infrastructure to add \"has common right multiples\" to a class? Ex: one might have a monoid with common right multiples (for all a and b in the monoid, there exist c and d in the monoid such that a<em>c=b</em>d). </p>\n<p>The only place I have seen this mentioned is in the OreSet file. (An OreSet  essentially is a cancellative monoid with common multiples).</p>\n<p>End goal: I am working on applying the Ore Localization to a braid monoid (which is a <strong>presented</strong> monoid that is cancellative and has left/right common multiples). So somehow I will need to combine presented monoid and ore set. My current thought is to do PresentedMonoid + IsCancelMul + (a new mixin I make for common multiples), but I am very open to suggestions otherwise!</p>",
        "id": 479603135,
        "sender_full_name": "Hannah Fechtner",
        "timestamp": 1730260565
    },
    {
        "content": "<p>(note that Zulip slightly mangled your post because you didn't quote <code>a*b=c*d</code> so it interpreted it as \"emphasize b=c as it's a word enclosed by <code>*</code>s\").</p>\n<p>I don't think a prop-valued mixin is going to cause too many problems and my instinct is that it might be a nice way to solve your problem. I don't recall having seen the concept before in mathlib. If you go via the mixin route then probably you have to make an additive version too but this will just boil down to putting <code>@[to_additive]</code> in front of all your lemmas and writing the definition twice.</p>",
        "id": 479663775,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1730288586
    },
    {
        "content": "<p>Thanks! Ideally, I'd like to make it carry data (functions which give the left-hand factors to make the common multiple), like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A mixin for common left multiples. -/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">LeftCommonMul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\">  </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">cl₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">G</span>\n<span class=\"w\">  </span><span class=\"n\">cl₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">G</span>\n<span class=\"w\">  </span><span class=\"n\">cl_spec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">cl₁</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">cl₂</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>So it cannot be a prop-valued mixin. Since it's carrying data, should it not be a mixin? Is there anywhere I can read up on this? I've been looking at Eric Wieser's thesis</p>",
        "id": 479720024,
        "sender_full_name": "Hannah Fechtner",
        "timestamp": 1730305324
    },
    {
        "content": "<p>This looks fine as a Type-valued mixin on a purely technical point of view. However the data is highly non-canonical, right? Why do you need it to be data?</p>",
        "id": 479720493,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730305480
    },
    {
        "content": "<p>I am not certain that I do! My current thought process: I would like to make everything constructive when I can. Also, for my particular use case, there is a canonical common multiple in the braid monoid (built of delta braids, which are basically half-twists)</p>",
        "id": 479721549,
        "sender_full_name": "Hannah Fechtner",
        "timestamp": 1730305796
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"622371\">Hannah Fechtner</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/common.20left.2Fright.20multiples/near/479721549\">said</a>:</p>\n<blockquote>\n<p>I would like to make everything constructive when I can</p>\n</blockquote>\n<p>That's not how we do it in mathlib <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>  </p>\n<p><span class=\"user-mention silent\" data-user-id=\"622371\">Hannah Fechtner</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/common.20left.2Fright.20multiples/near/479721549\">said</a>:</p>\n<blockquote>\n<p>for my particular use case, there is a canonical common multiple</p>\n</blockquote>\n<p>This might be a convincing argument, but in what exactly is it canonical?</p>",
        "id": 479722375,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730306037
    },
    {
        "content": "<p>Basically, when I proved that the braid monoid has common left multiples, I constructed the multiples. I'd prefer, if possible, not to lose that information when I prove that the braid monoid is a LeftCommonMul and then state theorems about LeftCommonMul structures. Does that make sense?</p>",
        "id": 479722434,
        "sender_full_name": "Hannah Fechtner",
        "timestamp": 1730306044
    },
    {
        "content": "<p>I hear this, but is it not imaginable that someone one day proves that the braid monoid has left common multiples by a different choice of multiples? or maybe only different in some cases? or even equal but not definitionally so?</p>",
        "id": 479723078,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730306243
    },
    {
        "content": "<p>that is surely possible!</p>",
        "id": 479723929,
        "sender_full_name": "Hannah Fechtner",
        "timestamp": 1730306507
    },
    {
        "content": "<p>I am happy to switch it. I am very much out of my league in terms of understanding how this all works. Would you be able to explain why the OreSet instance looks more like \"data\" and this shouldn't be? Not questioning you, just confused about what mixins are!</p>",
        "id": 479724286,
        "sender_full_name": "Hannah Fechtner",
        "timestamp": 1730306638
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/GroupTheory/OreLocalization/OreSet.html#OreLocalization.OreSet\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/GroupTheory/OreLocalization/OreSet.html#OreLocalization.OreSet</a></p>",
        "id": 479724465,
        "sender_full_name": "Hannah Fechtner",
        "timestamp": 1730306699
    },
    {
        "content": "<p>(pro-tip: type <code>docs#OreLocalization.OreSet</code> and it will render as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OreLocalization.OreSet#doc\">docs#OreLocalization.OreSet</a>)</p>",
        "id": 479727103,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730307609
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"622371\">Hannah Fechtner</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/common.20left.2Fright.20multiples/near/479724286\">said</a>:</p>\n<blockquote>\n<p>Would you be able to explain why the OreSet instance looks more like \"data\" and this shouldn't be?</p>\n</blockquote>\n<p>Hmm, no, they are very similar indeed, unless numerators and denominators in an Ore set are unique somehow? I dont think they are</p>",
        "id": 479727365,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730307708
    },
    {
        "content": "<p>In that case, my concerns about non-canonicity might be unfounded</p>",
        "id": 479727529,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730307755
    },
    {
        "content": "<p>Yes when you localise there is no canonical choice of numerator or denominator in general. If R is an integral domain with field of fractions K and if x is in K then the ideal of denominators of x is the elements of R which when you multiply by x you remain in R. This is an ideal but in general it's not even principal!</p>",
        "id": 479756667,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1730318982
    },
    {
        "content": "<p>so would the preferred method be to define it as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A mixin for common left multiples. -/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">LeftCommonMul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\">  </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">common_left_mul</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>",
        "id": 480559781,
        "sender_full_name": "Hannah Fechtner",
        "timestamp": 1730772034
    },
    {
        "content": "<p>That certainly looks safe. To be clear, your previous approach might be fine. It simply has the possibility not to be, and I can't tell you for sure whether it will or not</p>",
        "id": 480667526,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730796164
    }
]