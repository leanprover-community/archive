[
    {
        "content": "<p>Does anyone know of any formalizations of partial commutative monoids theory? I need them for my current project in Lean. <br>\nThere are some <a href=\"https://github.com/imdea-software/fcsl-pcm\">attempts in Coq</a>, I don't know of any in Lean4</p>",
        "id": 468969660,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1725938998
    },
    {
        "content": "<p>What is a partial commutative monoid?</p>",
        "id": 468994556,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725949084
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Partial.20Commutative.20Monoids/near/468994556\">said</a>:</p>\n<blockquote>\n<p>What is a partial commutative monoid?</p>\n</blockquote>\n<p>This is like a monoid, but an operation might be partial. I am interested in it, because <em>pcm</em>s are commonly used in computer science to formalize program logics.</p>",
        "id": 468996511,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1725949855
    },
    {
        "content": "<p>Aha. Is it ok to totalize the operation and study <code>Option M</code> instead? Because then there might be some theory in mathlib...</p>",
        "id": 468996947,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725949991
    },
    {
        "content": "<p>It sounds quite related to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CommMonoidWithZero#doc\">docs#CommMonoidWithZero</a></p>",
        "id": 468997135,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725950056
    },
    {
        "content": "<p>Where you would treat <code>0</code> as NaN</p>",
        "id": 468997175,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725950078
    },
    {
        "content": "<p>Yes, I guess, In theory I could derive a pcm instance from <code>ComMonoid (Option M)</code> and vice versa. But I was hoping that some has already done that<br>\nThanks!</p>",
        "id": 468997803,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1725950364
    },
    {
        "content": "<p>Are you also interested in homomorphisms between pcms? Are those always total, or also partial?</p>",
        "id": 468999598,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725950845
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Partial.20Commutative.20Monoids/near/468999598\">said</a>:</p>\n<blockquote>\n<p>Are you also interested in homomorphisms between pcms? Are those always total, or also partial?</p>\n</blockquote>\n<p>I know that pcm homomorphisms are applicable in computer science for program logic, but I do not think I will need those in my project. <br>\nAccording to <a href=\"https://github.com/imdea-software/fcsl-pcm/blob/a7c3e041cf1ba3f629dbdc5a4c153c50371855ba/pcm/morphism.v#L586\">Coq pcm formalization</a> those morphisms can be partial.</p>",
        "id": 469000623,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1725951240
    },
    {
        "content": "<p>Ok, in that case, I think the category of <code>CommMonoidWithZero</code> objects and <code>MonoidHom</code> morphisms is equivalent to the category of pcms with partial homs.</p>",
        "id": 469002057,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725951629
    },
    {
        "content": "<p>So I hope you can apply the theory that we have about <code>CommMonoidWithZero</code> in your project.</p>",
        "id": 469002258,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725951666
    },
    {
        "content": "<p>The only definition we've seen here is \"like a monoid, but an operation may be partial\". It would be a good exercise to either prove or disprove that pcm structures on a type correspond to monoid with zero structures on the corresponding option type sending <code>none</code> to <code>0</code>. This may or may not work out, depending on what the actual definition of pcm is.</p>",
        "id": 469037282,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725959710
    },
    {
        "content": "<p>I gave the coq formalization only a quick look. But I believe, usually these PCMs (and also that coq formaliazation) are defined in ITPs by defining a predicate <code>valid</code> that captures exactly these elements which are considered defined. Thus usually PCMs have not only one undefined element, but multiple. </p>\n<p>This formalization of PCMs may make it more complicated to proof the equivalence to <code>CommMonoidWithZero</code>.</p>\n<p>Personally, I prefer the <code>Option M</code> variant in my projects, but I don't require exotic PCMs, for which I believe the other PCM definition is more convient.</p>",
        "id": 469050850,
        "sender_full_name": "Ira Fesefeldt",
        "timestamp": 1725963060
    },
    {
        "content": "<p>There is also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Part#doc\">docs#Part</a></p>",
        "id": 469072421,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1725970279
    },
    {
        "content": "<p>I think the right mathematical abstraction is to develop something like \"algebra relative to a monad\". Partial operations would correspond to the <code>Option</code> monad. Hyperoperations would correspond to the <code>Set</code> monad, etc. Essentially you work in the Kleisli category.</p>",
        "id": 469081722,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725972670
    }
]