[
    {
        "content": "<p>Do we have this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.TensorProduct</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">TensorProduct</span>\n<span class=\"n\">suppress_compilation</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- A tensor product of submodules injects into the image of the submodules under the tensor product -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">TensorProduct.subModuleDistrib</span> <span class=\"o\">(</span><span class=\"n\">W₁</span> <span class=\"n\">W₂</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">W₁</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">W₂</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">Submodule.map₂</span> <span class=\"o\">(</span><span class=\"n\">TensorProduct.mk</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">W₁</span> <span class=\"n\">W₂</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">LinearMap.codRestrict</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">TensorProduct.map</span> <span class=\"n\">W₁.subtype</span> <span class=\"n\">W₂.subtype</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">fun</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n      <span class=\"n\">induction</span> <span class=\"n\">c</span> <span class=\"n\">using</span> <span class=\"n\">TensorProduct.induction_on</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">map_zero</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">zero_mem</span> <span class=\"n\">_</span>\n      <span class=\"bp\">|</span> <span class=\"n\">add</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">map_add</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">add_mem</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span>\n      <span class=\"bp\">|</span> <span class=\"n\">tmul</span> <span class=\"n\">w₁</span> <span class=\"n\">w₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">Submodule.apply_mem_map₂</span> <span class=\"n\">_</span> <span class=\"n\">w₁.prop</span> <span class=\"n\">w₂.prop</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- but it also surjects, right?</span>\n<span class=\"kd\">def</span> <span class=\"n\">Submodule.tensorProductDistrib</span> <span class=\"o\">(</span><span class=\"n\">W₁</span> <span class=\"n\">W₂</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Submodule.map₂</span> <span class=\"o\">(</span><span class=\"n\">TensorProduct.mk</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">W₁</span> <span class=\"n\">W₂</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">W₁</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">W₂</span> <span class=\"o\">:=</span>\n  <span class=\"c1\">-- can we do this constructively?</span>\n  <span class=\"gr\">sorry</span>\n\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">TensorProduct.submoduleDistribEquiv</span> <span class=\"o\">{</span><span class=\"n\">W₁</span> <span class=\"n\">W₂</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">W₁</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">W₂</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">Submodule.map₂</span> <span class=\"o\">(</span><span class=\"n\">TensorProduct.mk</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">W₁</span> <span class=\"n\">W₂</span> <span class=\"o\">:=</span>\n  <span class=\"n\">LinearEquiv.ofLinear</span>\n    <span class=\"o\">(</span><span class=\"n\">TensorProduct.subModuleDistrib</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">Submodule.tensorProductDistrib</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"gr\">sorry</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(inspired by one of <span class=\"user-mention\" data-user-id=\"400544\">@Richard Copley</span>'s threads)</p>",
        "id": 401630906,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699812762
    },
    {
        "content": "<p>I feel like for that sorry I need</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- If a function is defined on every element of a supremum, and agrees on the intersection, then it can be extended globally. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">suprLift</span> <span class=\"o\">{</span><span class=\"n\">N</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">hj</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hj</span><span class=\"o\">⟩)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">⨆</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>which I guess is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.iUnionLift#doc\">docs#Set.iUnionLift</a> but for submodules</p>",
        "id": 401631296,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699813092
    },
    {
        "content": "<p>As you saw, I had been looking at the same thing, with <code>LinearMap.mul'</code> composed.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.TensorProduct</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.TensorProductBasis</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.TensorAlgebra.Basic</span>\n\n<span class=\"n\">suppress_compilation</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">TensorProduct</span> <span class=\"n\">Submodule</span> <span class=\"n\">LinearMap</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">Basis.tensorMul</span> <span class=\"o\">{</span><span class=\"n\">ι₁</span> <span class=\"n\">ι₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">W₁</span> <span class=\"n\">W₂</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">TensorAlgebra</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)}</span>\n    <span class=\"o\">(</span><span class=\"n\">ℰ₁</span> <span class=\"o\">:</span> <span class=\"n\">Basis</span> <span class=\"n\">ι₁</span> <span class=\"n\">R</span> <span class=\"n\">W₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ℰ₂</span> <span class=\"o\">:</span> <span class=\"n\">Basis</span> <span class=\"n\">ι₂</span> <span class=\"n\">R</span> <span class=\"n\">W₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Basis</span> <span class=\"o\">(</span><span class=\"n\">ι₁</span> <span class=\"bp\">×</span> <span class=\"n\">ι₂</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">W₁</span> <span class=\"bp\">*</span> <span class=\"n\">W₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">W₁</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">W₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">incl'</span> <span class=\"o\">:</span> <span class=\"n\">W₁</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">W₂</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">TensorAlgebra</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n    <span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">TensorAlgebra</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">mapIncl</span> <span class=\"n\">W₁</span> <span class=\"n\">W₂</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">incl</span> <span class=\"o\">:</span> <span class=\"n\">W₁</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">W₂</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">W₁</span> <span class=\"bp\">*</span> <span class=\"n\">W₂</span> <span class=\"o\">:=</span> <span class=\"n\">LinearMap.codRestrict</span> <span class=\"n\">_</span> <span class=\"n\">incl'</span> <span class=\"o\">(</span><span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">x</span>\n    <span class=\"n\">induction</span> <span class=\"n\">x</span> <span class=\"n\">using</span> <span class=\"n\">TensorProduct.induction_on</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.map_zero</span><span class=\"o\">]</span> <span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">Submodule.zero_mem</span> <span class=\"o\">(</span><span class=\"n\">W₁</span> <span class=\"bp\">*</span> <span class=\"n\">W₂</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">tmul</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">mul_mem_mul</span> <span class=\"n\">x.property</span> <span class=\"n\">y.property</span>\n    <span class=\"bp\">|</span> <span class=\"n\">add</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">ihx</span> <span class=\"n\">ihy</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.map_add</span><span class=\"o\">]</span> <span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">Submodule.add_mem</span> <span class=\"o\">(</span><span class=\"n\">W₁</span> <span class=\"bp\">*</span> <span class=\"n\">W₂</span><span class=\"o\">)</span> <span class=\"n\">ihx</span> <span class=\"n\">ihy</span><span class=\"o\">)</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">inj</span> <span class=\"o\">:</span> <span class=\"n\">LinearMap.ker</span> <span class=\"n\">incl</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">surj</span> <span class=\"o\">:</span> <span class=\"n\">LinearMap.range</span> <span class=\"n\">incl</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">W₁</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">W₂</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">W₁</span> <span class=\"bp\">*</span> <span class=\"n\">W₂</span> <span class=\"o\">:=</span>\n    <span class=\"n\">LinearEquiv.ofBijective</span> <span class=\"n\">incl</span> <span class=\"o\">⟨</span><span class=\"n\">ker_eq_bot.mp</span> <span class=\"n\">inj</span><span class=\"o\">,</span> <span class=\"n\">range_eq_top.mp</span> <span class=\"n\">surj</span><span class=\"o\">⟩</span>\n\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">Basis.tensorProduct</span> <span class=\"n\">ℰ₁</span> <span class=\"n\">ℰ₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">e</span>\n</code></pre></div>\n<p>I thought I was stuck on showing that there are no zero-divisors with respect to <code>⊗ₜ[R]</code> (this isn't true, right?). But in fact even without the <code>mul'</code>, that is, for your <code>TensorProduct.subModuleDistrib</code>, I can't see how to get the injectivity (though it feels terribly obvious).</p>\n<p>Did I miss something subtle in your post? Were you just planning to go for bijectivity immediately?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.TensorProduct</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">TensorProduct</span>\n<span class=\"n\">suppress_compilation</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- A tensor product of submodules injects into the image of the submodules under the tensor product -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">TensorProduct.subModuleDistrib</span> <span class=\"o\">(</span><span class=\"n\">W₁</span> <span class=\"n\">W₂</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">W₁</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">W₂</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">Submodule.map₂</span> <span class=\"o\">(</span><span class=\"n\">TensorProduct.mk</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">W₁</span> <span class=\"n\">W₂</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">LinearMap.codRestrict</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">TensorProduct.map</span> <span class=\"n\">W₁.subtype</span> <span class=\"n\">W₂.subtype</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">fun</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n      <span class=\"n\">induction</span> <span class=\"n\">c</span> <span class=\"n\">using</span> <span class=\"n\">TensorProduct.induction_on</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">map_zero</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">zero_mem</span> <span class=\"n\">_</span>\n      <span class=\"bp\">|</span> <span class=\"n\">add</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">map_add</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">add_mem</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span>\n      <span class=\"bp\">|</span> <span class=\"n\">tmul</span> <span class=\"n\">w₁</span> <span class=\"n\">w₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">Submodule.apply_mem_map₂</span> <span class=\"n\">_</span> <span class=\"n\">w₁.prop</span> <span class=\"n\">w₂.prop</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Right?</span>\n<span class=\"kn\">open</span> <span class=\"n\">Submodule</span> <span class=\"n\">LinearMap</span> <span class=\"k\">in</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">TensorProduct.subModuleDistrib_inj</span> <span class=\"o\">(</span><span class=\"n\">W₁</span> <span class=\"n\">W₂</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">LinearMap.ker</span> <span class=\"o\">(</span><span class=\"n\">subModuleDistrib</span> <span class=\"n\">W₁</span> <span class=\"n\">W₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">subModuleDistrib</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">ker_codRestrict</span><span class=\"o\">,</span> <span class=\"n\">ker_eq_bot'</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span>\n  <span class=\"n\">induction</span> <span class=\"n\">x</span> <span class=\"n\">using</span> <span class=\"n\">TensorProduct.induction_on</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">intro</span> <span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">tmul</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">map_tmul</span><span class=\"o\">,</span> <span class=\"n\">subtype_apply</span><span class=\"o\">,</span> <span class=\"n\">subtype_apply</span><span class=\"o\">]</span>\n    <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">u.val</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">v.val</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">W₁</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">W₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"bp\">|</span> <span class=\"n\">add</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">ihu</span> <span class=\"n\">ihv</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 401643303,
        "sender_full_name": "Richard Copley",
        "timestamp": 1699826524
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> You didn't prove injectivity at all! Recall the definition of flatness:<br>\n<a href=\"/user_uploads/3121/8UhGSrIOQ18uv24VRwbCFZPu/image.png\">image.png</a><br>\nwhich says if <code>M</code> is not flat, then for some <code>I : Submodule R R</code>, the map <code>I ⊗ M → R ⊗ M</code> is not injective. However, we can't take <code>M = R</code> since <code>R</code> is flat as an <code>R</code>-module. To construct a counterexample in the setting where <code>W₁</code> and <code>W₂</code> are submodules of the same <code>R</code>-module <code>M</code>, we may take <code>W₁ = I ⊕ 0</code> and <code>W₂ = 0 ⊕ M</code> as submodules of <code>R ⊕ M</code>.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/8UhGSrIOQ18uv24VRwbCFZPu/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/8UhGSrIOQ18uv24VRwbCFZPu/image.png\"></a></div><p>On the other hand, surjectivity should be easy enough using <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Module/Submodule/Bilinear.html#Submodule.map%E2%82%82_le\">docs#Submodule.map₂_le</a>.</p>",
        "id": 401652949,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1699835549
    },
    {
        "content": "<p>What do you mean, I must have proved it because I said so in the docstring <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 401653987,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699836066
    },
    {
        "content": "<p>It's not clear to me how <code>Submodule.map₂_le</code> helps with the converse; it's not clear to me which submodule I should compare to</p>",
        "id": 401654046,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699836096
    },
    {
        "content": "<p>You want to show <code>Submodule.map₂ ...</code> is contained in the range of <code>W₁ ⊗[R] W₂ →ₗ[R] M ⊗[R] M</code>, right?</p>",
        "id": 401654481,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1699836290
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Submodule</span> <span class=\"n\">LinearMap</span> <span class=\"k\">in</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">TensorProduct.subModuleDistrib_surj</span> <span class=\"o\">(</span><span class=\"n\">W₁</span> <span class=\"n\">W₂</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">LinearMap.range</span> <span class=\"o\">(</span><span class=\"n\">subModuleDistrib</span> <span class=\"n\">W₁</span> <span class=\"n\">W₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">subModuleDistrib</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">range_codRestrict</span><span class=\"o\">,</span> <span class=\"n\">comap_subtype_eq_top</span><span class=\"o\">,</span> <span class=\"n\">map₂_le</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">m</span> <span class=\"n\">hm</span> <span class=\"n\">n</span> <span class=\"n\">hn</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">mem_range</span><span class=\"o\">]</span>\n  <span class=\"n\">use</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">hm</span><span class=\"o\">⟩</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"o\">⟩</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">map_tmul</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 401655088,
        "sender_full_name": "Richard Copley",
        "timestamp": 1699836586
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">TensorProduct.subModuleDistrib_surjective</span> <span class=\"o\">(</span><span class=\"n\">W₁</span> <span class=\"n\">W₂</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Function.Surjective</span> <span class=\"o\">(</span><span class=\"n\">TensorProduct.subModuleDistrib</span> <span class=\"n\">W₁</span> <span class=\"n\">W₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">LinearMap.range_eq_top</span><span class=\"o\">,</span> <span class=\"n\">TensorProduct.subModuleDistrib</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.range_codRestrict</span><span class=\"o\">,</span> <span class=\"n\">Submodule.comap_subtype_eq_top</span><span class=\"o\">,</span> <span class=\"n\">Submodule.map₂_le</span><span class=\"o\">]</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">Subtype.forall'</span><span class=\"o\">]</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x₁</span> <span class=\"n\">x₂</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">x₁</span> <span class=\"bp\">⊗ₜ</span> <span class=\"n\">x₂</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 401655617,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699836827
    },
    {
        "content": "<p>Darn, you beat me to it</p>",
        "id": 401655636,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699836838
    },
    {
        "content": "<p>Nerdsniped by <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span>. Here's some work towards the first <code>TODO</code> in <code>Mathlib.RingTheory.Flat</code>. The next part (extending from ideals of <code>R</code> to submodules of a general module) seems extremely difficult if you look at <a href=\"https://stacks.math.columbia.edu/tag/00HD\">Stacks</a>. Less so if you look at Dummit and Foote or AtiMac.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.TensorProduct.RightExactness</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.Flat</span>\n\n<span class=\"c1\">-- Remove the `FG` condition from `Module.Flat.iff_rTensor_injective`</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n<span class=\"n\">suppress_compilation</span>\n<span class=\"kn\">open</span> <span class=\"n\">TensorProduct</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- When `I` and `J` are submodules of `N` and `h` is a proof of `I ≤ J`,</span>\n<span class=\"c1\">-- let `φ M N h` be the tensor product of the inclusion `I → J` and the identity `M → M`</span>\n<span class=\"kd\">def</span> <span class=\"n\">φ</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">≤</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">J</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">I.subtype</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">J</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h.subset</span> <span class=\"n\">x.property</span>\n  <span class=\"n\">LinearMap.rTensor</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"n\">I.subtype.codRestrict</span> <span class=\"n\">J</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- alternative spelling \"map (I.subtype.codRestrict J h) LinearMap.id\"</span>\n\n<span class=\"c1\">-- Applying φ to a simple tensor `i ⊗ₜ m`</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">φ_tmul</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">≤</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">φ</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(⟨</span><span class=\"n\">i.val</span><span class=\"o\">,</span> <span class=\"n\">h.subset</span> <span class=\"n\">i.property</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">φ</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.rTensor_tmul</span><span class=\"o\">]</span> <span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- φ respects (preserves? reflects? commutes with?) the preorder on submodules</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">φ_comp</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hIJ</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">≤</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hJK</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">≤</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">φ</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">hJK</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">φ</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">hIJ</span> <span class=\"bp\">=</span> <span class=\"n\">φ</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">(</span><span class=\"n\">hIJ.trans</span> <span class=\"n\">hJK</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- Next line should be `ext` but importing `TensorProduct.RightExactness` breaks it</span>\n  <span class=\"n\">refine</span> <span class=\"n\">TensorProduct.ext</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.ext</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.ext</span> <span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">))</span>\n  <span class=\"n\">simp</span><span class=\"bp\">?</span> <span class=\"o\">[</span><span class=\"n\">φ_tmul</span><span class=\"o\">]</span> <span class=\"n\">says</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.compr₂_apply</span><span class=\"o\">,</span> <span class=\"n\">mk_apply</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.coe_comp</span><span class=\"o\">,</span>\n      <span class=\"n\">Function.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">φ_tmul</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Trivial. The two linear maps concerned are related by composition with the equivalence `eM`.</span>\n<span class=\"kn\">open</span> <span class=\"n\">LinearMap</span> <span class=\"o\">(</span><span class=\"n\">rTensor</span> <span class=\"n\">ext</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">φ_top_injective_iff</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">Function.Injective</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">M</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">le_top</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">≤</span> <span class=\"bp\">⊤</span><span class=\"o\">))</span> <span class=\"bp\">↔</span>\n      <span class=\"n\">Function.Injective</span> <span class=\"o\">(</span><span class=\"n\">rTensor</span> <span class=\"n\">M</span> <span class=\"n\">I.subtype</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- `e : ⊤ ≃ₗ R`</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"o\">(</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">subtype</span> <span class=\"k\">with</span>\n    <span class=\"n\">invFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"o\">⟩</span>\n    <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"o\">}</span>\n  <span class=\"c1\">-- `eM : ⊤ ⊗ M ≃ₗ R ⊗ M`.</span>\n  <span class=\"k\">let</span> <span class=\"n\">eM</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">R</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">LinearEquiv.ofLinear</span>\n    <span class=\"o\">(</span><span class=\"n\">rTensor</span> <span class=\"n\">M</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rTensor</span> <span class=\"n\">M</span> <span class=\"n\">e.symm</span><span class=\"o\">)</span>\n    <span class=\"c1\">-- Note: specify `ext` lemmas explicitly because others that work poorly here may be visible</span>\n    <span class=\"o\">(</span><span class=\"n\">TensorProduct.ext</span> <span class=\"o\">(</span><span class=\"n\">ext</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">ext</span> <span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span><span class=\"o\">)))</span>\n    <span class=\"o\">(</span><span class=\"n\">TensorProduct.ext</span> <span class=\"o\">(</span><span class=\"n\">ext</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">ext</span> <span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span><span class=\"o\">)))</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">rTensor</span> <span class=\"n\">M</span> <span class=\"n\">I.subtype</span> <span class=\"bp\">=</span> <span class=\"n\">eM</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">φ</span> <span class=\"n\">M</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">le_top</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">≤</span> <span class=\"bp\">⊤</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">refine</span> <span class=\"n\">TensorProduct.ext</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.ext</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.ext</span> <span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">))</span>\n    <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.compr₂_apply</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.compr₂_apply</span><span class=\"o\">,</span> <span class=\"n\">mk_apply</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.rTensor_tmul</span><span class=\"o\">,</span>\n      <span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">φ_tmul</span><span class=\"o\">]</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">eM.symm</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">rTensor</span> <span class=\"n\">M</span> <span class=\"n\">I.subtype</span> <span class=\"bp\">=</span> <span class=\"n\">φ</span> <span class=\"n\">M</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">le_top</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">≤</span> <span class=\"bp\">⊤</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">refine</span> <span class=\"n\">LinearMap.ext</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n    <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">LinearEquiv.coe_coe</span><span class=\"o\">,</span> <span class=\"n\">eM.symm_apply_eq</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">]</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">.</span> <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">h₁</span><span class=\"o\">]</span> <span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">eM.injective.comp</span> <span class=\"n\">h</span>\n  <span class=\"bp\">.</span> <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h₂</span><span class=\"o\">]</span> <span class=\"bp\">;</span>  <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">eM.symm.injective.comp</span> <span class=\"n\">h</span>\n\n<span class=\"c1\">-- If `I ≤ R` and `x : I ⊗ M`, there is an f.g. ideal `J ≤ I` such that `x` is</span>\n<span class=\"c1\">-- the image of some `y : J ⊗ M`</span>\n<span class=\"c1\">-- (cf. Dummit &amp; Foote (ed. 3), pp. 400, 401, proof of Corollary 42)</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"k\">in</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_fg_le_eq_rTensor_subtype_codRestrict_apply</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">⊗</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">J.FG</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hJ</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">≤</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⊗</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">φ</span> <span class=\"n\">M</span> <span class=\"n\">R</span> <span class=\"n\">hJ</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">x</span> <span class=\"n\">using</span> <span class=\"n\">TensorProduct.induction_on</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"bp\">⊥</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"n\">Finset.coe_empty</span> <span class=\"bp\">▸</span> <span class=\"n\">Submodule.span_empty</span><span class=\"o\">⟩,</span> <span class=\"n\">zero_le</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"n\">tmul</span> <span class=\"n\">i</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"n\">hle</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"bp\">∙</span> <span class=\"n\">i.val</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">I</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Submodule.span_singleton_le_iff_mem</span> <span class=\"n\">i.val</span> <span class=\"n\">I</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">i.property</span>\n    <span class=\"k\">let</span> <span class=\"n\">i'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"bp\">∙</span> <span class=\"n\">i.val</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">i.val</span><span class=\"o\">,</span> <span class=\"n\">Submodule.mem_span_singleton_self</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨(</span><span class=\"n\">R</span> <span class=\"bp\">∙</span> <span class=\"n\">i.val</span><span class=\"o\">),</span> <span class=\"n\">Submodule.fg_span_singleton</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hle</span><span class=\"o\">,</span> <span class=\"n\">i'</span> <span class=\"bp\">⊗ₜ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">φ_tmul</span><span class=\"o\">]⟩</span>\n  <span class=\"bp\">|</span> <span class=\"n\">add</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">ihx</span> <span class=\"n\">ihy</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">J₁</span><span class=\"o\">,</span> <span class=\"n\">hFG₁</span><span class=\"o\">,</span> <span class=\"n\">hJ₁</span><span class=\"o\">,</span> <span class=\"n\">y₁</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ihx</span>\n    <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">J₂</span><span class=\"o\">,</span> <span class=\"n\">hFG₂</span><span class=\"o\">,</span> <span class=\"n\">hJ₂</span><span class=\"o\">,</span> <span class=\"n\">y₂</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ihy</span>\n    <span class=\"k\">let</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">φ</span> <span class=\"n\">M</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">le_sup_left</span> <span class=\"o\">:</span> <span class=\"n\">J₁</span> <span class=\"bp\">≤</span> <span class=\"n\">J₁</span> <span class=\"bp\">⊔</span> <span class=\"n\">J₂</span><span class=\"o\">)</span> <span class=\"n\">y₁</span> <span class=\"bp\">+</span> <span class=\"n\">φ</span> <span class=\"n\">M</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">le_sup_right</span> <span class=\"o\">:</span> <span class=\"n\">J₂</span> <span class=\"bp\">≤</span> <span class=\"n\">J₁</span> <span class=\"bp\">⊔</span> <span class=\"n\">J₂</span><span class=\"o\">)</span> <span class=\"n\">y₂</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">J₁</span> <span class=\"bp\">⊔</span> <span class=\"n\">J₂</span><span class=\"o\">,</span> <span class=\"n\">Submodule.FG.sup</span> <span class=\"n\">hFG₁</span> <span class=\"n\">hFG₂</span><span class=\"o\">,</span> <span class=\"n\">sup_le</span> <span class=\"n\">hJ₁</span> <span class=\"n\">hJ₂</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">unfold_let</span> <span class=\"n\">z</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">map_add</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">φ_comp</span><span class=\"o\">,</span> <span class=\"n\">φ_comp</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- If `φ M R ‹I ≤ ⊤› : I ⊗[R] M →ₗ[R] R ⊗[R] M` is injective for every finitely generated</span>\n<span class=\"c1\">-- ideal `I` of `R` then it is injective for every ideal `I` of `R`.</span>\n<span class=\"c1\">-- (Dummit &amp; Foote (ed. 3), p. 406, part of exercise 10.25(b))</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">rTensor_subtype_injective_of_forall_fg'</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">I.FG</span> <span class=\"bp\">→</span> <span class=\"n\">Function.Injective</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">M</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">le_top</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">≤</span> <span class=\"bp\">⊤</span><span class=\"o\">)))</span> <span class=\"bp\">→</span>\n      <span class=\"bp\">∀</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">Function.Injective</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">M</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">le_top</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">≤</span> <span class=\"bp\">⊤</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span> <span class=\"n\">I</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span> <span class=\"c1\">-- injective_iff_map_eq_zero cannot find this</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">injective_iff_map_eq_zero</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx₀</span>\n  <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">J</span><span class=\"o\">,</span> <span class=\"n\">hfg</span><span class=\"o\">,</span> <span class=\"n\">hle</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">exists_fg_le_eq_rTensor_subtype_codRestrict_apply</span> <span class=\"n\">x</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">hy₀</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">hy₀</span><span class=\"o\">,</span> <span class=\"n\">map_zero</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">φ_comp</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx₀</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span> <span class=\"c1\">-- injective_iff_map_eq_zero cannot find this</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">injective_iff_map_eq_zero</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">J</span> <span class=\"n\">hfg</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">hx₀</span>\n\n<span class=\"c1\">-- Simplify the statement of the previous result.</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">rTensor_subtype_injective_of_forall_fg</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">I.FG</span> <span class=\"bp\">→</span> <span class=\"n\">Function.Injective</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.rTensor</span> <span class=\"n\">M</span> <span class=\"n\">I.subtype</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n      <span class=\"bp\">∀</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">Function.Injective</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.rTensor</span> <span class=\"n\">M</span> <span class=\"n\">I.subtype</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">φ_top_injective_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">rTensor_subtype_injective_of_forall_fg'</span> <span class=\"n\">M</span>\n\n<span class=\"c1\">-- Remove the `FG` condition from `Module.Flat.iff_rTensor_injective`</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">iff_rTensor_injective'</span> <span class=\"o\">:</span>\n    <span class=\"n\">Module.Flat</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">Function.Injective</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.rTensor</span> <span class=\"n\">M</span> <span class=\"n\">I.subtype</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">Module.Flat.iff_rTensor_injective</span><span class=\"o\">]</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"n\">rTensor_subtype_injective_of_forall_fg</span> <span class=\"n\">M</span>\n  <span class=\"bp\">.</span> <span class=\"n\">refine</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"n\">I</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"n\">I</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>\n</code></pre></div>",
        "id": 402545286,
        "sender_full_name": "Richard Copley",
        "timestamp": 1700164612
    },
    {
        "content": "<p>Nice! I think you're now in a position to review (or co-author?) <a href=\"https://github.com/leanprover-community/mathlib4/pull/7225\">#7225</a> <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 402546331,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1700164927
    },
    {
        "content": "<p>You might also like to watch Jujian's talk: <a href=\"https://www.youtube.com/watch?v=Xp8gViooBXU\">https://www.youtube.com/watch?v=Xp8gViooBXU</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"Xp8gViooBXU\" href=\"https://www.youtube.com/watch?v=Xp8gViooBXU\"><img src=\"https://uploads.zulipusercontent.net/5ea0716c936b2b599ad3b7027673b0dc1b2450d0/68747470733a2f2f692e7974696d672e636f6d2f76692f5870386756696f6f4258552f64656661756c742e6a7067\"></a></div><p>The Zulip thread is <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/323718734\">here</a></p>",
        "id": 402549443,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1700166015
    }
]