[
    {
        "content": "<p>What is the best way of obtaining the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">UniformSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">UniformSpace</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsHomeomorph</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>It doesn't look like there are a lot of results in Mathlib that allow to transport topological properties via homeomorphisms...</p>",
        "id": 521475520,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1748724896
    },
    {
        "content": "<p>How about with a map?</p>",
        "id": 521475564,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1748724938
    },
    {
        "content": "<p><code>f</code> <em>is</em> a map ??</p>",
        "id": 521475623,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1748724972
    },
    {
        "content": "<p>Maybe I misunderstand the question, but <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> is complete and homeomorphic to, say <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mo>−</mo><mi>π</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo separator=\"true\">,</mo><mi>π</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(-\\pi/2,\\pi/2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"mord\">/2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"mord\">/2</span><span class=\"mclose\">)</span></span></span></span>, which is not complete.</p>\n<p>Completeness is a metric property (or well, a uniformity property, I guess), so just homeomorphisms don't preserve it. (Isometries would of course preserve it.)</p>",
        "id": 521475673,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1748725027
    },
    {
        "content": "<p>OK; maybe one needs more properties. In my use case, I have two equivalent absolute values on the real numbers (one is the standard one), and I want to show that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> is complete w.r.t. the other one.</p>",
        "id": 521475779,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1748725132
    },
    {
        "content": "<p>Is it enough if <code>f</code> maps the uniformities to each other?</p>",
        "id": 521475810,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1748725169
    },
    {
        "content": "<p>How would I write this down?</p>",
        "id": 521475948,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1748725251
    },
    {
        "content": "<p>Is the following reasonable?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">completeSpace_of_comap_uniformity</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">UniformSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">UniformSpace</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">uniformity</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">uniformity</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 521476453,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1748725735
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsometryEquiv.completeSpace#doc\">docs#IsometryEquiv.completeSpace</a>. It sounds like in your case you don't have an isometry but a bilipschitz map (which also preserves completeness). I don't know how those are called in Mathlib off the top of my head.</p>",
        "id": 521476455,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1748725737
    },
    {
        "content": "<p>The relation is not linear: one absolute value (= metric) is a power of the other.</p>",
        "id": 521476488,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1748725778
    },
    {
        "content": "<p>But they certainly induce the same uniformities...</p>",
        "id": 521476501,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1748725796
    },
    {
        "content": "<p>It seems like I have to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniformSpace.complete_of_cauchySeq_tendsto#doc\">docs#UniformSpace.complete_of_cauchySeq_tendsto</a> and bash through the filters. I'll try that tomorrow (CEST) unless a better idea has emerged by then.</p>",
        "id": 521476828,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1748726063
    },
    {
        "content": "<p>I don't understand your exact situation, but we also have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Cauchy.map#doc\">docs#Cauchy.map</a>. So if your homeomorphism is uniformly continuous (maybe in both directions, depending on what you want), using your mentioned <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniformSpace.complete_of_cauchySeq_tendsto#doc\">docs#UniformSpace.complete_of_cauchySeq_tendsto</a> may not be too bad. (Also I still don't know if Mathlib has something more direct. Are there any results about homeomorphisms which are uniformly continuous in both directions?)</p>",
        "id": 521477013,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1748726223
    },
    {
        "content": "<p>I think we only have local uniform continuity provided by <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Order/Ring/Abs.html#abs_pow_sub_pow_le\">abs_pow_sub_pow_le</a>.</p>",
        "id": 521477280,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1748726410
    },
    {
        "content": "<p>More precisely, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Order/Field/Basic.html#uniform_continuous_npow_on_bounded\">uniform_continuous_npow_on_bounded</a> which makes it easy to show that a power of a Cauchy sequence is still Cauchy. But Michael is probably interested in real powers, not just natural powers ...</p>",
        "id": 521477648,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1748726718
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/MetricSpace/Holder.html#HolderWith.uniformContinuous\">HolderWith.uniformContinuous</a> is probably useful <del>but the triangle inequality fails one way or the other so not both X and Y can be PseudoEMetricSpace ...</del></p>",
        "id": 521479557,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1748728383
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/If.20X.20and.20Y.20are.20homeomorphic.20and.20X.20is.20complete.2C.20then.20Y.20is/near/521476453\">said</a>:</p>\n<blockquote>\n<p>Is the following reasonable?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">completeSpace_of_comap_uniformity</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">UniformSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">UniformSpace</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">uniformity</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">uniformity</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsUniformInducing.isComplete_range#doc\">docs#IsUniformInducing.isComplete_range</a></p>",
        "id": 521481713,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1748730573
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> is it? that gets you to <code>IsComplete (Set.range f)</code>, not <code>CompleteSpace Y</code></p>\n<p>I think you might need the additional fact that <code>f</code> is surjective so you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsUniformInducing.completeSpace_congr#doc\">docs#IsUniformInducing.completeSpace_congr</a></p>",
        "id": 521484702,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1748734188
    },
    {
        "content": "<p>though if you also have <code>IsHomeomorph f</code> then you've already got surjectivity</p>",
        "id": 521484855,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1748734327
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/If.20X.20and.20Y.20are.20homeomorphic.20and.20X.20is.20complete.2C.20then.20Y.20is/near/521479557\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/MetricSpace/Holder.html#HolderWith.uniformContinuous\">HolderWith.uniformContinuous</a> is probably useful</p>\n</blockquote>\n<p>I think you can use this to build a <code>UniformEquiv</code> quite easily, and then you can apply <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniformEquiv.completeSpace_iff#doc\">docs#UniformEquiv.completeSpace_iff</a></p>",
        "id": 521498944,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1748746798
    },
    {
        "content": "<p>Maybe I’m missing something, but both of your uniformities are (additive) group uniformities right ? If so, showing that they induce the same topology is enough to know that they induce the same uniformity.</p>",
        "id": 521522213,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1748763157
    },
    {
        "content": "<p>Is there a ready-made result in Mathlib that shows that?</p>",
        "id": 521527886,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1748767066
    },
    {
        "content": "<p>A message was moved from this topic to <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/Uniform.20structures.20on.20.E2.84.9D/with/521478377\">#Is there code for X? &gt; Uniform structures on ℝ</a> by <span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span>.</p>",
        "id": 521567156,
        "sender_full_name": "Notification Bot",
        "timestamp": 1748791988
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsUniformAddGroup.toUniformSpace_eq#doc\">docs#IsUniformAddGroup.toUniformSpace_eq</a> as well as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=isUniformAddGroup_of_addCommGroup#doc\">docs#isUniformAddGroup_of_addCommGroup</a></p>",
        "id": 521568972,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1748793120
    },
    {
        "content": "<p>Thanks everybody!</p>\n<p>I now have the following (<code>equiv₂ v₁ v₂</code> is the ring isomorphism between <code>WithAbs v₁</code> and <code>WithAbs v₂</code> whose underlying map is the identity, and I had already shown that it is continuous when the two absolute values are equivalent).</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"w\"> </span><span class=\"n\">v₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AbsoluteValue</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">v₁</span><span class=\"w\"> </span><span class=\"bp\">≈</span><span class=\"w\"> </span><span class=\"n\">v₂</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">uniformContinuous_equiv₂_of_isEquiv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UniformContinuous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">equiv₂</span><span class=\"w\"> </span><span class=\"n\">v₁</span><span class=\"w\"> </span><span class=\"n\">v₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">uniformContinuous_of_continuousAt_zero</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">continuous_equiv₂</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">continuousAt</span>\n\n<span class=\"sd\">/-- If `v₁` and `v₂` are equivalent absolute values on `F`, then `WithAbs.equiv₂ v₁ v₂`</span>\n<span class=\"sd\">is an equivalence of uniformities. This gives the `UniformEquiv`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">uniformEquivOfIsEquiv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WithAbs</span><span class=\"w\"> </span><span class=\"n\">v₁</span><span class=\"w\"> </span><span class=\"bp\">≃ᵤ</span><span class=\"w\"> </span><span class=\"n\">WithAbs</span><span class=\"w\"> </span><span class=\"n\">v₂</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">UniformEquiv</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">equiv₂</span><span class=\"w\"> </span><span class=\"n\">v₁</span><span class=\"w\"> </span><span class=\"n\">v₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">uniformContinuous_equiv₂_of_isEquiv</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">uniformContinuous_equiv₂_of_isEquiv</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- The underlying equivalence of `uniformEquivOfIsEquiv h` is `WithAbs.equiv₂ _ _`. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">uniformEquiv_eq_equiv₂</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">uniformEquivOfIsEquiv</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toEquiv</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">equiv₂</span><span class=\"w\"> </span><span class=\"n\">v₁</span><span class=\"w\"> </span><span class=\"n\">v₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toEquiv</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- If `v₁` and `v₂` are equivalent absolute values on `F` and `F` is complete</span>\n<span class=\"sd\">with respect to `v₁`, then `F` is also complete with respect to `v₂`. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">completeSpace_of_isEquiv</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">WithAbs</span><span class=\"w\"> </span><span class=\"n\">v₁</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">WithAbs</span><span class=\"w\"> </span><span class=\"n\">v₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">uniformEquivOfIsEquiv</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">completeSpace_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"bp\">‹</span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">WithAbs</span><span class=\"w\"> </span><span class=\"n\">v₁</span><span class=\"o\">)</span><span class=\"bp\">›</span>\n</code></pre></div>",
        "id": 521592753,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1748806583
    }
]