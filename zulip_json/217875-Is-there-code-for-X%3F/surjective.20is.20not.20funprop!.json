[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Surjective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">`Function.Surjective id` is not a `fun_prop` goal!</span>\n<span class=\"cm\">Maybe you forgot marking `Function.Surjective` with `@[fun_prop]`.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fun_prop</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Surjective</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fun_prop</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">surjective_id</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Surjective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span>\n</code></pre></div>",
        "id": 527865719,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752060113
    },
    {
        "content": "<p>Why is <code>Function.Surjective</code> not marked as <code>fun_prop</code>?</p>",
        "id": 527865786,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752060143
    },
    {
        "content": "<p>Nobody has done it yet. <br>\nI think it would be good to mark <code>Surjective</code> and friends as <code>fun_prop</code>, I think this was recently suggested elsewhere on Zulip.</p>",
        "id": 527867454,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1752060747
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> I want to do it. Which file should I do this in? I see that <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/FunProp.html\">Mathlib.Tactic.FunProp</a> is imported by:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>Mathlib.Tactic.FunProp.Differentiable\nMathlib.Topology.Defs.Basic\nMathlib.MeasureTheory.MeasurableSpace.Embedding\nMathlib.Tactic.FunProp.ContDiff\nMathlib.Tactic.ContinuousFunctionalCalculus\nMathlib\nMathlib.Tactic\n</code></pre></div>\n<p>which all seem to be quite late in the import hierarchy compared to <code>Mathlib/Logic/Function/Defs.lean</code> which contains the definitions of injective, surjective, and bijective.</p>",
        "id": 527952457,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752089300
    },
    {
        "content": "<p>Yeah, somewhere under <code>Mathlib.Tactic.FunProp</code></p>",
        "id": 527955691,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1752090818
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> are you referring to the file itself, or a new file? If it's a new file, where should I put the new file?</p>",
        "id": 527985232,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752108322
    },
    {
        "content": "<p>Is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Injective#doc\">docs#Function.Injective</a> a <code>fun_prop</code> property? Can you put it together with that if it is?</p>",
        "id": 527985289,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752108363
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> you should only need to import <code>Mathlib.Tactic.FunProp.Attr</code> in order to mark them as <code>@[fun_prop]</code>, and this file has very lightweight imports.</p>",
        "id": 528001671,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1752123637
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> Are you saying I should import M.T.FunProp.Attr from M.Logic.Function.Defs?</p>",
        "id": 528039549,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752140454
    },
    {
        "content": "<p>I'm not Jireh, but that's how I read the message.</p>",
        "id": 528040869,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1752140820
    },
    {
        "content": "<p>Yes. The imports for <code>Mathlib.Logic.Function.Defs</code> are so minimal that the <code>large-import</code> tag might get placed on it anyway, but if so and someone complains we can have a discussion.</p>",
        "id": 528084052,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1752154586
    },
    {
        "content": "<p>(<a href=\"#narrow/channel/287929-mathlib4/topic/.60fun_prop.60.20for.20Injective.2FSurjective.2FBijective.3F/near/524160547\">#mathlib4 &gt; &#96;fun_prop&#96; for Injective/Surjective/Bijective? @ üí¨</a> )</p>",
        "id": 533664627,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754846189
    },
    {
        "content": "<p>Indeed, the only reason I haven't done it myself is that I've been waiting til I have the attention to write a script to find all the lemmas that <em>prove</em> injective/etc</p>",
        "id": 533765365,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1754911275
    },
    {
        "content": "<p>and automatically <code>fun_prop</code> them, as I expect there to be hundreds if not thousands of them ^.^;</p>",
        "id": 533765480,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1754911302
    },
    {
        "content": "<p>ah, I should add that I have made a very small start at <a href=\"https://github.com/leanprover-community/mathlib4/pull/28191\">#28191</a></p>",
        "id": 533768258,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754912133
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"359992\">@Robert Maxton</span> <a href=\"https://loogle.lean-lang.org/?q=‚ä¢+Function.Injective+_\">Loogle</a> already exists</p>",
        "id": 533768471,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754912178
    },
    {
        "content": "<p>Loogle exists, but I don't see an amazing way of tying it into a script, and for that matter I don't even see a way to get more than the first 200 results ^.^;</p>",
        "id": 533772600,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1754912274
    },
    {
        "content": "<p>I think <code>#loogle</code> exists as a command if you do the right things</p>",
        "id": 533772775,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754912300
    },
    {
        "content": "<p>Would it also make sense to have fun_prop for <code>Monotone</code>/<code>Antitone</code>?</p>\n<p>Btw I was recently running into the annoyance that the <code>Monotone</code>/<code>Antitone</code> lemmas are also useful in their unfolded form, since <code>gcongr</code> currently only takes that form. Any advice on what to do here? State them only in one form, or have some automation to get both forms?</p>",
        "id": 533778022,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1754913782
    },
    {
        "content": "<p>yes</p>",
        "id": 533778088,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754913799
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/surjective.20is.20not.20funprop!/near/533778022\">said</a>:</p>\n<blockquote>\n<p>since <code>gcongr</code> currently only takes that form</p>\n</blockquote>\n<p>change gcongr?</p>",
        "id": 533778174,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754913823
    },
    {
        "content": "<p>There is another reason to prefer the expanded form, at least when dealing with a lambda function (<code>Monotone fun x =&gt; ...</code>), namely that the lambda may not get beta-reduced:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">monotone_mul_left_of_nonneg</span><span class=\"w\"> </span><span class=\"n\">zero_le_two</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"c1\">-- this : (fun x =&gt; 2 * x) a ‚â§ (fun x =&gt; 2 * x) b</span>\n</code></pre></div>\n<p>But yes it would make sense to prove only the <code>Monotone</code> version for non-lambda functions.</p>",
        "id": 534188833,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1755076261
    },
    {
        "content": "<p>I also today ran into wanting <code>StrictMono</code> and <code>StrictAnti</code> as well.<br>\nOn that note,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">sqrt_mono</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Monotone</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">sqrt_le_sqrt</span>\n</code></pre></div>\n<p>was missing too...</p>",
        "id": 534542666,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755197890
    },
    {
        "content": "<p>Note that the naming convention is to call it <code>sqrt_monotone</code>, as we are referring to the definition <code>Monotone</code>. I have a PR somewhere to fix this, which I'll get back to after the fix to <code>gcongr</code> gets merged in <a href=\"https://github.com/leanprover-community/mathlib4/pull/28339\">#28339</a></p>",
        "id": 534543347,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1755198186
    },
    {
        "content": "<p>or rather <code>monotone_sqrt</code>.</p>",
        "id": 534563608,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1755207234
    },
    {
        "content": "<p>No, the naming convention specifically says to use <code>monotone</code> and friends as suffixes. Similarly for <code>surjective</code> and friends</p>",
        "id": 534566078,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1755208737
    },
    {
        "content": "<p>I always forget that one. I really dislike that convention.</p>",
        "id": 534566312,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1755208835
    },
    {
        "content": "<p>Well, <a href=\"https://github.com/leanprover-community/mathlib4/pull/28550\">#28550</a> should be an easy review at least</p>",
        "id": 534827897,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755441943
    }
]