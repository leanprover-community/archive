[
    {
        "content": "<p>I'm quite certain this must exist somewhere, but I'm not sure how to search efficiently. I'm looking for a function essentially of type <code>Nat -&gt; Bool</code> with the (proven) property that the result is <code>true</code> iff the argument is prime.<br>\nIdeally this would have better runtime than naÃ¯vely checking all numbers between 2 and <code>n</code>.<br>\nIs there code for my X?</p>",
        "id": 531565380,
        "sender_full_name": "Simon Dima",
        "timestamp": 1753783180
    },
    {
        "content": "<p>I don't think we have good prime tests yet. You're welcome to write one!</p>",
        "id": 531566360,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753783461
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> wrote one, actually</p>",
        "id": 531566471,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1753783496
    },
    {
        "content": "<p>and where would one be able to find it?</p>",
        "id": 531566588,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753783529
    },
    {
        "content": "<p>Let's wait for him to tell us <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 531566674,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1753783554
    },
    {
        "content": "<p>on the other hand we already have <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Nat/Prime/Defs.html#Nat.prime_def_le_sqrt\">Nat.prime_def_le_sqrt</a> to reduce the complexity to O(sqrt(N))</p>",
        "id": 531567206,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753783716
    },
    {
        "content": "<p>While we wait I found this message on an old thread</p>\n<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Tactic.2FData.20for.20a.20natural.20number.20not.20to.20be.20a.20prime.20number/near/525287880\">said</a>:</p>\n<blockquote>\n<p>As I mentioned earlier in the thread, I have a tactic which does this, which you can see on this example here: <a href=\"https://github.com/b-mehta/mathlib4/blob/large-prime/Mathlib/V2/Prime.lean#L622\">https://github.com/b-mehta/mathlib4/blob/large-prime/Mathlib/V2/Prime.lean#L622</a> The thing itself has the ability to call mathematica to generate and self-replace with a certificate, or sage (except that the sage server went down after I made it) or compute it natively (although this is too slow for this example), or you can just paste in a certificate from mathematica. That file also contains proofs for much larger primes</p>\n</blockquote>",
        "id": 531567611,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753783828
    },
    {
        "content": "<p>Mathlib's <code>decidablePrime</code> and <code>decidablePrime'</code> seem to be respectively the \"check until n\" and \"check until âˆšn\" algorithms</p>",
        "id": 531601335,
        "sender_full_name": "Simon Dima",
        "timestamp": 1753793600
    },
    {
        "content": "<p>If I'm understanding Bhavik's code right, it looks like it runs as meta code during tactic time, and I'm not sure how easy it would be to obtain a regular function from it.</p>",
        "id": 531601794,
        "sender_full_name": "Simon Dima",
        "timestamp": 1753793727
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"893179\">@Simon Dima</span> why do you need such a function?</p>",
        "id": 531604065,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753794294
    },
    {
        "content": "<p>I'm working on comparing various methods of generating executable code from proof assistants, currently benchmarking a hand-rolled extraction to (basically) OCaml compared to Lean's compiler.<br>\nI'm looking for computational code which has some propositional content mixed in to prove it correct but which is later removed by the compilation/extraction process, in order to have benchmarks which actually correspond to the \"write verified code in a proof assistant, get correct executables\" workflow. The existing benchmarks of Lean as a programming language basically don't use propositional content. Verified primality testing came to mind as a function which is easy to specify and which, I hoped, might have a preexisting proven implementation with a nontrivial algorithm</p>",
        "id": 531605775,
        "sender_full_name": "Simon Dima",
        "timestamp": 1753794726
    },
    {
        "content": "<p>The goal being to compile a program which takes a number on standard input and outputs whether it was prime, using (a) the Lean compiler and (b) my janky setup which goes through OCaml, and measuring the runtime of both on some large numbers</p>",
        "id": 531606402,
        "sender_full_name": "Simon Dima",
        "timestamp": 1753794877
    },
    {
        "content": "<p>I don't have any particular reason to be interested specifically in primality testing, though, so if you know of any other functions (on simple types like Nat or Bool) that have interesting computational behavior and also are proven correct, that would certainly be an interesting benchmark to look at!</p>",
        "id": 531607141,
        "sender_full_name": "Simon Dima",
        "timestamp": 1753795071
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"893179\">Simon Dima</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Computational.20primality.20testing/near/531601794\">said</a>:</p>\n<blockquote>\n<p>If I'm understanding Bhavik's code right, it looks like it runs as meta code during tactic time, and I'm not sure how easy it would be to obtain a regular function from it.</p>\n</blockquote>\n<p>This is correct, what I built was a tactic which verified a prime certificate generated elsewhere (failing if the elsewhere thinks it's not prime), rather than code which checks primality</p>",
        "id": 531629778,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1753800484
    },
    {
        "content": "<p>On the other hand, there's <a class=\"message-link\" href=\"/#narrow/channel/113488-general/topic/new.20monadic.20program.20verification.20framework/near/530240164\">#general &gt; new monadic program verification framework @ ðŸ’¬</a>, which is still trial division, but does have this property. It's checking up to the square root though, so it's slightly better than the most naive algorithm. Scrolling in that thread, you can find my proof of correctness for it, and a shorter proof for the version which doesn't stop at the square root.</p>",
        "id": 531630154,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1753800579
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Computational.20primality.20testing/near/531629778\">said</a>:</p>\n<blockquote>\n<p>This is correct, what I built was a tactic which verified a prime certificate generated elsewhere (failing if the elsewhere thinks it's not prime), rather than code which checks primality</p>\n</blockquote>\n<p><a href=\"https://github.com/b-mehta/mathlib4/blob/large-prime/Mathlib/V2/Certify.lean#L385-L391\">This bit</a> looks somewhat like a Lean function to generate such a certificate, or am I mistaken?</p>",
        "id": 531630364,
        "sender_full_name": "Simon Dima",
        "timestamp": 1753800639
    },
    {
        "content": "<p>It is! \"elsewhere\" has three options: mathematica, sage, or Lean (so I suppose \"elsewhere\" was a bad term to use). I suppose one could verify correctness of this function</p>",
        "id": 531630945,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1753800783
    },
    {
        "content": "<p>I see, so given the current state one could compose together the certificate generation and verification to get a function which either outputs \"n is certainly prime\" (guaranteed to be correct) or an error where the certificate generator generated an invalid certificate</p>",
        "id": 531631901,
        "sender_full_name": "Simon Dima",
        "timestamp": 1753801023
    },
    {
        "content": "<p>Right. The intention was to have a tactic which, given a prime, produces a proof of correctness for that specific prime, which is what's in the file you're looking at</p>",
        "id": 531632825,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1753801257
    }
]