[
    {
        "content": "<p>I would like to define an object property to check if an object of a category is a connected object. Currently, I have this code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">ObjectProperty</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">Preserves</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">Hom</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">Currying</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Extensive</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Opposite</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">FinitaryExtensive</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">hom_functor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">hom'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">curryObj</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">C</span>\n<span class=\"w\">  </span><span class=\"n\">hom'</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Opposite</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Predicate to check if an object $X$ is a Z-Object as described by</span>\n<span class=\"sd\">    Rudolf E. Hoffmann:</span>\n<span class=\"sd\">    $$</span>\n<span class=\"sd\">    \\Hom[\\mathsf{C}]{X}{\\cdot} \\text{ preserves colimits}</span>\n<span class=\"sd\">    $$</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">is_zobj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">ObjectProperty</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">  </span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">PreservesColimits</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hom_functor</span><span class=\"w\">  </span><span class=\"n\">X</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I have based this code on this definition: <a href=\"https://ncatlab.org/nlab/show/connected+object\">https://ncatlab.org/nlab/show/connected+object</a></p>\n<p>I am unsure if this is the correct way to define the covariant Hom functor, or if I should do it some other way. I would suppose that mathlib would already have the covariant Hom functor defined somewhere, but I could only find the Hom bifunctor in <code>Mathlib.CategoryTheory.Functor.Hom</code>.<br>\nSorry if this is a stupid question. This is my first post here.</p>",
        "id": 523111117,
        "sender_full_name": "Luca Happel",
        "timestamp": 1749481531
    },
    {
        "content": "<p>This is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.coyoneda#doc\">docs#CategoryTheory.coyoneda</a>.</p>",
        "id": 523112562,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749481979
    },
    {
        "content": "<p>Also, note that your definition of \"Z-object\" is incorrect (currently it states that the hom-functor preserves all small colimits, edit:  <a href=\"https://kerodon.net/tag/03WS\">I think these are called atomic objects</a>), we apparently don’t have a general <code>PreservesCoproducts</code> typeclass, but you can see how it’s stated in <a href=\"https://tqft.net/mathlib4files/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Products\">file#Mathlib/CategoryTheory/Limits/Preserves/Shapes/Products</a>. it’s something like <code>∀ {J : Type u} (f : J → C), PreservesColimit (Discrete.functor f) (coyoneda.obj (op X))</code></p>",
        "id": 523116174,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749483174
    },
    {
        "content": "<p>If I were to use your suggestion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">FinitaryExtensive</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">is_zobj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ObjectProperty</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">),</span>\n<span class=\"w\">  </span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">PreservesColimit</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Discrete</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">coyoneda</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Opposite</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Wouldn't that mean I would only consider small colimits, because <code>Type = Type 0</code>? If I were to use this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">is_zobj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ObjectProperty</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">),</span>\n<span class=\"w\">  </span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">PreservesColimit</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Discrete</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">coyoneda</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Opposite</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>where I have changed <code>J</code> to be of Type <code>Type u</code>, would that mean I also allow large colimits?</p>",
        "id": 523126101,
        "sender_full_name": "Luca Happel",
        "timestamp": 1749485715
    },
    {
        "content": "<p>The former states that you preserve all \"0-small\" coproducts, the second that you preserve all u-small coproducts, objects of <code>Type u</code> are never <code>u</code>-large. I think the definition you want to go for really depends on <code>C</code>. Currently when you write <code>[Category C]</code>, you do not specify any universe level in which the morphisms of <code>C</code> live, this is why the pattern you usually see in Mathlib is either</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>in which case nothing is said about universes,<br>\nor</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>in which you specify the size of the type of objects of <code>C</code> to be <code>u</code>-small and the type of morphisms between two objects to be <code>v</code>-small</p>\n<p>I’ve never thought about the right size constraints for connected objects in the case where the two universe levels are different, but when <code>C</code> is u-small (i.e <code>{C : Type u} [Category.{u} C]</code>, which has an abbrev <code>{C : Type u} [SmallCategory C]</code>), you probably want <code>u</code>-small coproducts. In this situation when people say \"small coproducts\" they usually mean coproduct of size not exceeding the size of <code>C</code>, so <code>u</code>-small coproducts really.</p>",
        "id": 523128968,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749486773
    },
    {
        "content": "<p>Wait no, I’m confused, and probably meant that when <code>C</code> is <em>locally</em> <code>u</code>-small, you want <code>u</code>-small coproducts (even though when <code>C</code> itself is <code>u</code>-small, the preservation of coproduct hyp will simply be empty for coproducts that don’t exist in <code>C</code>, but I’m not sure it’s what you want). Sorry for this... In any case I think for statement involving preservation of colimits like this you want to specify universe levels for <code>C</code> and its hom-types.</p>",
        "id": 523131874,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749487759
    }
]