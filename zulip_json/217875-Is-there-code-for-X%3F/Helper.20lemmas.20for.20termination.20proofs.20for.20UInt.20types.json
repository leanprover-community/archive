[
    {
        "content": "<p>There are several lemmas that it would be convenient to have on, say, UInt64 such as 'n \\neq 0 =&gt; (n - 1) &lt; n`. These are of course not difficult to prove, but they are the types of things I'd have hoped would be in the standard library somewhere (analogous lemmas exist for Nats).</p>\n<p>Do these exist somewhere?</p>",
        "id": 564910155,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766343882
    },
    {
        "content": "<p>Is this true? What if <code>n - 1</code> underflows?</p>",
        "id": 564910862,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1766344912
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Helper.20lemmas.20for.20termination.20proofs.20for.20UInt.20types/near/564910862\">said</a>:</p>\n<blockquote>\n<p>Is this true? What if <code>n - 1</code> underflows?</p>\n</blockquote>\n<p>It can't with <code>n ≠ 0</code> assumption.</p>",
        "id": 564911055,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766345187
    },
    {
        "content": "<p>You're looking for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UInt64.sub_lt#doc\">docs#UInt64.sub_lt</a> I think?</p>",
        "id": 564911069,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766345211
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt64</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">UInt64</span><span class=\"bp\">.</span><span class=\"n\">sub_lt</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">lia</span>\n</code></pre></div>",
        "id": 564911143,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766345276
    },
    {
        "content": "<p>We probably should add <code>Uint64.sub_one_lt</code> to API, to match the analogous Nat lemma.</p>",
        "id": 564911288,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766345515
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"1006649\">@cmlsharp</span> It would be helpful, if you could list other missing lemmas.</p>",
        "id": 564911330,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766345556
    },
    {
        "content": "<p>I'll leave that call to Markus</p>",
        "id": 564911333,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766345562
    },
    {
        "content": "<p>Aah sorry, you're talking about <em>unsigned</em> integers. I just call these <em>naturals</em> <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 564911441,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1766345685
    },
    {
        "content": "<p>I'll try put together a list when I get back to my laptop. In general, just from a usability perspective it would be nice if there were analogous UInt* lemmas with identical names for all applicable Nat lemmas (resp Int*/Int lemmas).</p>",
        "id": 564912592,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766347096
    },
    {
        "content": "<p>This is something I'd be willing to submit as a PR to the standard library if there's interest in that.</p>",
        "id": 564912650,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766347173
    },
    {
        "content": "<p>Could we avoid redundancy by defining these lemmas for a class of mathematical objects that includes both <code>Nat</code> and <code>UInt64</code>? It might be nicer to generalize instead of duplicate.</p>",
        "id": 564913856,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1766348934
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Helper.20lemmas.20for.20termination.20proofs.20for.20UInt.20types/near/564913856\">said</a>:</p>\n<blockquote>\n<p>Could we avoid redundancy by defining these lemmas for a class of mathematical objects that includes both <code>Nat</code> and <code>UInt64</code>? It might be nicer to generalize instead of duplicate.</p>\n</blockquote>\n<p>It would make finding the theorems on loogle harder though.</p>",
        "id": 564913897,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766348993
    },
    {
        "content": "<p>would it? I figure you could just search for <code>?a - 1 &lt; ?a</code></p>",
        "id": 564914128,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1766349272
    },
    {
        "content": "<p>also if we follow naming conventions (e.g. <code>sub_one_lt_self_iff_ne_bot</code>) it might not even require searching Loogle</p>",
        "id": 564914254,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1766349407
    },
    {
        "content": "<p>E.g. <code>0 &lt; ?_</code> timeouts, but <code>Nat, 0 &lt; ?_</code> doesn't. Also, if your pattern doesn't include numeral literals, than you might need to add <code>Nat</code> to query, to filter out irrelevant lemmas.</p>",
        "id": 564914332,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766349505
    },
    {
        "content": "<p>would be cool if Loogle could use instance synthesis as part of its search</p>",
        "id": 564914465,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1766349656
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Helper.20lemmas.20for.20termination.20proofs.20for.20UInt.20types/near/564914465\">said</a>:</p>\n<blockquote>\n<p>would be cool if Loogle could use instance synthesis as part of its search</p>\n</blockquote>\n<p>Can you elaborate a bit on this?</p>",
        "id": 564914682,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766349889
    },
    {
        "content": "<p>I think, that if I use <code>A</code> in search, then loogle shoud be able to find theorems for classes, which <code>A</code> is instance of. E.g. if I search for <code>Nat, ?a ≤ max ?a ?b</code> it will find only <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Nat/MinMax.html#Nat.le_max_left\">Nat.le_max_left</a>. But it won't find <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Defs/LinearOrder.html#le_max_left\">le_max_left</a>. It only worked here, because <code>le_max_left</code> was duplicated for Nat.</p>",
        "id": 564915017,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766350341
    },
    {
        "content": "<p>yeah it might be (effectively) impossible but the idea would be that if your search includes <code>Nat</code> then Loogle will include lemmas that don't mention <code>Nat</code> explicitly but have typeclass requirements that <code>Nat</code> satisfies</p>",
        "id": 564915091,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1766350489
    },
    {
        "content": "<p>like <code>exact?</code>?</p>",
        "id": 564915197,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766350623
    },
    {
        "content": "<p>hmm... yeah I suppose so</p>",
        "id": 564915215,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1766350648
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Helper.20lemmas.20for.20termination.20proofs.20for.20UInt.20types/near/564913856\">said</a>:</p>\n<blockquote>\n<p>Could we avoid redundancy by defining these lemmas for a class of mathematical objects that includes both <code>Nat</code> and <code>UInt64</code>? It might be nicer to generalize instead of duplicate.</p>\n</blockquote>\n<p>It would also make it impossible to use dot notation.</p>",
        "id": 564916009,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766351891
    },
    {
        "content": "<p>Ah that would be rather unfortunate as well. One perhaps unsatisfying option is just to use metaprogramming for this rather than class instances. Think for example what Rust does for its various integral types. There’s no “trait” that gives i64, i32, i16, etc a “unsigned_abs” method, rather concrete implementations are created via macro.</p>\n<p>On the one hand, sure it is unsatisfying because you can’t really abstract over these in the conventional way, but you still get the duplication-saving benefits. I think for the rather small handful of primitive types in the standard library this more ad hoc approach is fine (but I’m new to the lean ecosystem, so perhaps this is a serious faux pas)</p>",
        "id": 564916902,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766353278
    },
    {
        "content": "<p>There are already macros for UInt: <a href=\"https://github.com/leanprover/lean4/blob/b87d2c0fb9c16d73571a208a08af1967450e7b87/src/Init/Data/UInt/Lemmas.lean#L26\">https://github.com/leanprover/lean4/blob/b87d2c0fb9c16d73571a208a08af1967450e7b87/src/Init/Data/UInt/Lemmas.lean#L26</a></p>",
        "id": 564917206,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766353781
    }
]