[
    {
        "content": "<p><code>ℤₘ₀</code> is mathlib's notation for <code>WithZero (Multiplicative Int)</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">scoped</span><span class=\"o\">[</span><span class=\"n\">DiscreteValuation</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"s2\">\"ℤₘ₀\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">WithZero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Multiplicative</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Having been supervising a student who is using it, I'm struggling to find things like a decent induction principle for it. Do we have something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">RingTheory</span><span class=\"bp\">.</span><span class=\"n\">Valuation</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">DiscreteValuation</span><span class=\"w\"> </span><span class=\"c1\">-- for ℤₘ₀ notation</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Multiplicative</span><span class=\"w\"> </span><span class=\"c1\">-- so I can type `ofAdd` instead of `Multiplicative.ofAdd`</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Zm0</span><span class=\"bp\">.</span><span class=\"n\">induction_on</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤₘ₀</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">of_int</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ofAdd</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multiplicative</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤₘ₀</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"n\">WithZero</span><span class=\"bp\">.</span><span class=\"n\">recZeroCoe</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">of_int</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>? If not, do we want it or is there some trick I'm missing whereby we can avoid this boilerplate? Furthermore, what to do about the namespace? Is it OK to make a new namespace Zmo for basic results about this type? It's a fundamental object in Lean's set-up of the theory of discrete valuations.</p>",
        "id": 451347425,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1720957433
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/14729\">#14729</a> will help here</p>",
        "id": 451350336,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720960828
    },
    {
        "content": "<p>With that, you can at least write <code>cases' x with x &lt;;&gt; [skip, cases x]</code> or</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>or similar</p>",
        "id": 451350534,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720961041
    }
]