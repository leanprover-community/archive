[
    {
        "content": "<p>Is there code for this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">not_dvd_pow_sub_one</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hnp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∣</span> <span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 371772866,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1688316656
    },
    {
        "content": "<p>I don't like the look of statements which involve natural subtraction. How did you even end up with that as a hypothesis? I should think <code>a % p = b % p</code> is a better way of saying \"p divides a - b and by the way I can prove a&gt;=b\".</p>",
        "id": 371782163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1688319854
    },
    {
        "content": "<p>The minus one comes from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.card_units#doc\">docs#Fintype.card_units</a></p>",
        "id": 371782454,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1688319982
    },
    {
        "content": "<p>The theorem I am ultimately trying to prove is that the subgroup of units of a field, cast to the field, is not zero, here is what I have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Sylow</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Subgroup.Finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Polynomial.Eval</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.OrderOfElement</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.FieldTheory.Finite.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">BigOperators</span> <span class=\"n\">Classical</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">not_dvd_pow_sub_one</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hnp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∣</span> <span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">foobar</span> <span class=\"n\">n</span> <span class=\"n\">hn</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hk</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hnp</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hnp</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pow_add</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hnp</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hnp</span>\n  <span class=\"c1\">-- exact</span>\n<span class=\"c1\">-- aesop</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.dvd_iff_mod_eq_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hnp</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.sub_mod</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">zify</span> <span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hnp</span> <span class=\"n\">hp</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Int.sub_emod</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hnp</span>\n  <span class=\"c1\">-- simp at hnp</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">foob</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"n\">hn</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hnp</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">zero_sub</span><span class=\"o\">,</span> <span class=\"n\">dvd_neg</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hnp</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">EuclideanDomain.mod_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hnp</span> <span class=\"c1\">-- This should simplify the</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">Int.emod_eq_of_lt</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">]</span>\n  <span class=\"gr\">sorry</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">subgroup_of_units_card_ne_zero</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Subgroup</span> <span class=\"o\">(</span><span class=\"n\">Units</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">)))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span>\n  <span class=\"c1\">-- Group of units of a finite field of order p^n is p^n-1</span>\n  <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">char_p</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">CharP.exists</span> <span class=\"n\">F</span>\n  <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">hnp</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">FiniteField.card</span> <span class=\"n\">F</span> <span class=\"n\">p</span>\n  <span class=\"k\">have</span> <span class=\"n\">card_units_F</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">Fintype.card_units</span> <span class=\"n\">F</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hnp</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">card_units_F</span>\n  <span class=\"c1\">-- As a subgroup, G's card must divide this</span>\n  <span class=\"k\">have</span> <span class=\"n\">hl</span> <span class=\"o\">:=</span> <span class=\"n\">Subgroup.card_subgroup_dvd_card</span> <span class=\"n\">G</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">card_units_F</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hl</span>\n  <span class=\"c1\">-- To equal zero when cast to field, subgroup card must be multiple of p</span>\n  <span class=\"n\">intro</span> <span class=\"n\">heq0</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[(</span><span class=\"n\">charP_iff</span> <span class=\"n\">F</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">char_p</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">heq0</span>\n  <span class=\"c1\">-- This implies p ∣ p^n - 1</span>\n  <span class=\"k\">have</span> <span class=\"n\">hdvd</span> <span class=\"o\">:=</span> <span class=\"n\">dvd_trans</span> <span class=\"n\">heq0</span> <span class=\"n\">hl</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">PNat.val</span> <span class=\"n\">at</span> <span class=\"n\">hdvd</span>\n  <span class=\"n\">clear</span> <span class=\"n\">heq0</span> <span class=\"n\">hl</span> <span class=\"n\">card_units_F</span> <span class=\"n\">hnp</span> <span class=\"n\">char_p</span> <span class=\"n\">G</span>\n  <span class=\"c1\">-- This should lead to a contradiction, but this is hard to prove in lean due to tsub hell</span>\n  <span class=\"n\">apply</span> <span class=\"n\">not_dvd_pow_sub_one</span> <span class=\"n\">p</span> <span class=\"n\">n.val</span>\n  <span class=\"n\">exact</span> <span class=\"n\">PNat.pos</span> <span class=\"n\">n</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Nat.Prime.two_le</span> <span class=\"n\">hp</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hdvd</span>\n</code></pre></div>",
        "id": 371782741,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1688320074
    },
    {
        "content": "<p>What I think I want to do is move to the integers mod <code>p</code> and simplify, is there a standard way to convert a statement a % p = 0 into \"a cast to Zmod p\" = 0</p>",
        "id": 371784373,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1688320731
    },
    {
        "content": "<p>Ok I've got it down to something much simpler</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">not_dvd_of_lt</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"bp\">∣</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span><span class=\"bp\">?</span>\n</code></pre></div>\n<p>Is this somewhere? Edit: managed to solve this via <code>Int.mod_eq_of_lt</code></p>",
        "id": 371785729,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1688321217
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/not_dvd_pow_sub_one/near/371782454\">said</a>:</p>\n<blockquote>\n<p>The minus one comes from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.card_units#doc\">docs#Fintype.card_units</a></p>\n</blockquote>\n<p>I think that it would be better to write that lemma as card(units) + 1 = card(thing). Note that a+1=b implies b-1=a but not the other way around,  so my suggestion is a better lemma.</p>",
        "id": 371786800,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1688321620
    },
    {
        "content": "<p>Ok, but then how am I supposed to apply transitivity of divisibility?</p>",
        "id": 371786966,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1688321689
    },
    {
        "content": "<p>you can still talk about p divides a or p divides b, you just are in better shape because there's no natural subtraction</p>",
        "id": 371787104,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1688321731
    },
    {
        "content": "<p>I'm still confused. The crux of my proof is that <code>p | card G</code> and <code>card G | p^n - 1</code>, so there's a contradiction. I'm not even sure how I express the second one without nat subtraction.</p>",
        "id": 371787325,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1688321817
    },
    {
        "content": "<p>Hmm, I guess the idea is that I use <code>p | card G</code> and <code>card G | card (Units F)</code> to prove <code>p | card (Units F)</code>, and then I also have <code>p | card F &lt;-&gt; p | card (Units F) + 1</code> and then I somehow show that a number greater than 1 can't divide <code>k</code> and <code>k+1</code> at the same time?</p>",
        "id": 371790622,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1688322904
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">not_dvd_pow_sub_one</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hnp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∣</span> <span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Nat.modEq_iff_dvd'</span> <span class=\"o\">(</span><span class=\"n\">one_le_pow_of_one_le</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">)]</span> <span class=\"n\">at</span> <span class=\"n\">hnp</span> <span class=\"c1\">-- no more nat subtraction</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">dvd_pow_self</span> <span class=\"n\">p</span> <span class=\"n\">hn.ne'</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Nat.modEq_zero_iff_dvd</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">refine</span> <span class=\"n\">Nat.zero_ne_one</span> <span class=\"bp\">$</span> <span class=\"n\">Nat.ModEq.eq_of_abs_lt</span> <span class=\"o\">(</span><span class=\"n\">hnp.trans</span> <span class=\"n\">this</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"n\">exact_mod_cast</span> <span class=\"n\">hp</span>\n</code></pre></div>",
        "id": 371790738,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1688322958
    },
    {
        "content": "<p>After seeing how this can still be proved without <code>tsub</code>, I think I agree that <code>card_units</code> would be better off expressed in terms of <code>add</code>. Maybe the biggest objection is the aesthetics: I feel for some reason like I am more used to expressing this theorem the way it's currently written, maybe because I think of <code>totient p</code> as being <code>p-1</code> for prime <code>p</code> (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.totient_prime#doc\">docs#Nat.totient_prime</a> also seems to use tsub). At the very least, there should be primed versions of these lemmas to express them without tsub.</p>",
        "id": 371799725,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1688326453
    },
    {
        "content": "<p>Here is a proof with nat subtraction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Order.Lemmas</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Pow</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">not_dvd_pow_sub_one</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hnp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∣</span> <span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∣</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">mt</span> <span class=\"n\">Nat.dvd_one.1</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">ne_of_gt</span> <span class=\"n\">hp</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.dvd_add_iff_right</span> <span class=\"n\">hnp</span><span class=\"o\">,</span> <span class=\"n\">Nat.sub_add_cancel</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">exacts</span> <span class=\"o\">[</span><span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">dvd_pow_self</span> <span class=\"n\">_</span> <span class=\"n\">hn.ne'</span><span class=\"o\">),</span> <span class=\"n\">Nat.one_le_pow</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">lt_of_lt_of_le</span> <span class=\"n\">two_pos</span> <span class=\"n\">hp</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 371800419,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1688326778
    },
    {
        "content": "<p>I have a question on your <code>subgroup_of_units_card_ne_zero</code>. Since <code>G</code> is a group, it must contains <code>1</code> whose image in <code>F</code> is also <code>1</code>.  So I think <code>(Fintype.card G : F) ≠ 0</code> is trivial?</p>",
        "id": 371811797,
        "sender_full_name": "Jz Pan",
        "timestamp": 1688332095
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"366779\">@Jz Pan</span> What if <code>card F | card G</code>? (It's clear that <code>card G</code> itself is not zero, but not that it's nonzero as an element of <code>F</code>.)</p>",
        "id": 371813040,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1688332756
    },
    {
        "content": "<p>Sorry I am confused by the theorem name. So you mean the characteristic of <code>F</code> does not divide the size of <code>G</code>. I got it.</p>",
        "id": 371821049,
        "sender_full_name": "Jz Pan",
        "timestamp": 1688337560
    }
]