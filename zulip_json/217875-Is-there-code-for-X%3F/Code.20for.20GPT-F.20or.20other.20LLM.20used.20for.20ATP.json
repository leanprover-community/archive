[
    {
        "content": "<p>Hi there, does anyone know how can I find the code/API for GPT-F? I want to replicate some of OpenAI's work and figure out some of the weaknesses of the current ATP, I've checked Jesss Michael Han's repo and it seems like the API is no longer available (<a href=\"https://github.com/jesse-michael-han/lean-gptf/issues/12\">https://github.com/jesse-michael-han/lean-gptf/issues/12</a>). I tried to email him and got no response...</p>",
        "id": 357732093,
        "sender_full_name": "Dongwei Jiang",
        "timestamp": 1683856954
    },
    {
        "content": "<p>The API is turned off.  There is a similar API from Meta AI based on the hypertree proof search paper however. ( <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general/topic/api.20suggestion.20vscode.20integration\">#general &gt; api suggestion vscode integration</a>)  I believe that is still up.  Also, the code to generate the data for this paper is still available from two repositories.  You can find a lot of the repos listed in <a class=\"stream-topic\" data-stream-id=\"219941\" href=\"/#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/What.20is.20the.20AMI.20project.27s.20vision.20for.20AI.20in.20Lean.3F\">#Machine Learning for Theorem Proving &gt; What is the AMI project's vision for AI in Lean?</a></p>",
        "id": 357815054,
        "sender_full_name": "Jason Rute",
        "timestamp": 1683885414
    },
    {
        "content": "<p>Also cross posting is discouraged.</p>",
        "id": 357815173,
        "sender_full_name": "Jason Rute",
        "timestamp": 1683885446
    },
    {
        "content": "<p>Thank you for directing me towards the model developed by Meta. It certainly appears to be quite promising. However, what I am particularly interested in is an end-to-end solution, one that encompasses not only the model but also the search algorithm, such as a priority queue, that assembles the entire proof from individual proof steps. My interest in this is primarily to gain a more in-depth understanding of the current model's errors on benchmarks like miniF2F, and potentially to classify these errors using insightful heuristics, such as proof length, proof tree depth, the number of lemmas used, and so forth.</p>\n<p>While I am aware that there are repositories containing the original data used for training the model, it seems that my current best course of action is to gather this data, reformat it to structures like \"GOAL &lt;GOAL&gt; PROOFSTEP &lt;PROOFSTEP&gt;\", and train it on open-source models, such as LLAMA, correct?</p>\n<p>I also want to apologize for any confusion caused by my cross-posting. I assure you it won't happen again.</p>",
        "id": 357937901,
        "sender_full_name": "Dongwei Jiang",
        "timestamp": 1683911021
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"616750\">@Dongwei Jiang</span> I don't think there is an easy way to completely reproduce either paper.  The easiest might be as you said to (1) get the data, (2) train your own language model, and (3) run a proof search with your model.</p>\n<p>As for (1), I mention the repositories where the original data came from, but at the same time, I think there are better approaches now to getting the data including Mario's AST extractor, and (I don't think it is released yet, so I don't want to share more, but) I know someone is making a special tool for this sort of thing.</p>\n<p>As for (3), lean-gym might be a good choice.  It isn't supported anymore, but I think it is also the environment that OpenAI used for later papers.  If you use the code we used for the PACT paper (which I think is on Jesse's repo), then I think that also has some support for the FairSeq library, and if you know metaprogramming in Lean, it would be easy to use any similar LLM interface.</p>",
        "id": 358122290,
        "sender_full_name": "Jason Rute",
        "timestamp": 1683989392
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> Sorry for the delay in responding and thank you for your advice! I've been tied up working on the code. Here's what I've accomplished so far and my plans moving forward:</p>\n<p>1  I've extracted data from the PACT paper, using guidelines from <a href=\"https://github.com/jesse-michael-han/lean-step-public\">lean-step-public</a>.<br>\n2  For the second step, I've decided to use LLAMA as my base model for fine-tuning. I've had some success with the <a href=\"https://github.com/tloen/alpaca-lora\">alpaca-lora</a> project, but there's more work needed for successful fine-tuning, like setting parameters and handling vocab.<br>\n3  For the third step, I've looked at <a href=\"https://github.com/jesse-michael-han/lean-tpe-public\">lean-tpe-public</a>. It seems to only contain beam search code (in Lean), and I didn't find a best-first search as there's no passing of score. I also checked <a href=\"https://github.com/jesse-michael-han/lean-gptf/tree/master\">lean-gptf</a>, which seems to have something similar to best-first search. <a href=\"https://github.com/openai/lean-gym\">lean-gym</a> didn't seem helpful in this regard. I'll still need to figure out how Lean works and how to tie all these steps together.</p>\n<p>If you have any other suggestions or comments, I'd appreciate them! Once I've managed to recreate some of these paper's methods using these open-source tools, I'll document it to help anyone else who might want to work on it in the future.</p>",
        "id": 359916607,
        "sender_full_name": "Dongwei Jiang",
        "timestamp": 1684596668
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"616750\">@Dongwei Jiang</span> I'm a bit confused:</p>\n<blockquote>\n<p>1 I've extracted data from the PACT paper, using guidelines from lean-step-public.</p>\n</blockquote>\n<p>That is some of the data we used for PACT, but it doesn't have the most important part, the tactics!  You need to get them from another source, like <a href=\"https://github.com/jasonrute/lean_proof_recording\">https://github.com/jasonrute/lean_proof_recording</a></p>\n<blockquote>\n<p>3 For the third step, I've looked at lean-tpe-public. It seems to only contain beam search code (in Lean), and I didn't find a best-first search as there's no passing of score.</p>\n</blockquote>\n<p>That is has best first search.  It is implemented in <a href=\"https://github.com/jesse-michael-han/lean-tpe-public/blob/master/src/evaluation.lean\">https://github.com/jesse-michael-han/lean-tpe-public/blob/master/src/evaluation.lean</a>.  I don't know what you are saying about beam-search.  The fairseq API uses beam search decoding, while the openai api uses sampling (with a temperature parameter) for decoding, but to my understanding that is only where beam search is used.</p>\n<blockquote>\n<p>I also checked lean-gptf, which seems to have something similar to best-first search.</p>\n</blockquote>\n<p>That to my understanding doesn't have any search (or if it does, it was never fully implemented).  It is just a tactic to make tactic suggestions.</p>\n<blockquote>\n<p>lean-gym didn't seem helpful in this regard.</p>\n</blockquote>\n<p>LeanGym is probably the easiest way to interact with Lean.  You have to do all the search on the python side, but you can easily implement your own best-first search algorithm (or iterated depth first search, or MCTS, or whatever).</p>",
        "id": 359972420,
        "sender_full_name": "Jason Rute",
        "timestamp": 1684627550
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> Thank you for your response! I have to admit, my understanding of these repositories is not as deep as I'd like it to be, so your help is really appreciated. You're right, the <a href=\"https://github.com/jesse-michael-han/lean-step-public\">lean-step-public</a> repository is mainly for classification tasks like proof step classification and seq2seq tasks, such as theorem name prediction and next-lemma prediction. But what I need is the tactics task, so I've started extracting data from your repository.</p>\n<p>When it comes to the search part, I have missed the evaluation file you mentioned, probably because I'm not very familiar with Lean. I'll definitely dig into it more. And thanks again for explaining the other two repositories!</p>",
        "id": 360133595,
        "sender_full_name": "Dongwei Jiang",
        "timestamp": 1684713146
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> Thank you for your previous response; it has been immensely helpful. I've since dived further into your repository, read  the <a href=\"https://leanprover.github.io/introduction_to_lean/\">introduction to Lean</a> and the first five chapters of <a href=\"https://leanprover.github.io/theorem_proving_in_lean/tactics.html\">theorem proving in Lean</a>, and I've come across a few additional points that I'd appreciate your insights on.</p>\n<p>With respect to tactics data generation, I've read your <a href=\"https://github.com/jasonrute/lean_proof_recording/blob/master/data_examples.ipynb\">notebook</a> and I have generated the 'cleaned_training_data'. However, I'm uncertain about the formatting of data for LLM fine-tuning. Should the data be presented in the \"GOAL &lt;TacticState&gt; PROOFSTEP &lt;Tactic&gt;\" format? Or, should I just keep the 'GOAL' as a condition (as it will be provided by Lean) and just fine-tune the 'Tactic' part?</p>\n<p>In terms of the search, I'm still familiarizing myself with lean-tpe-public and it seems I need to implement something similar to the fairseq API considering my usage of a custom language model. However, I've noticed that the documentation surrounding the fairseq API is somewhat limited, and I'm curious if you could provide any additional insights to aid in my understanding of it (like how does the fairseq API work and what do I need to make the search work with custom language model).</p>\n<p>Furthermore, I have a question about debugging. I'm curious to know if it's possible to debug this Lean project in a similar manner to how we typically handle debugging in a Python project? My preliminary research suggests that this might not be <a href=\"https://leanprover.github.io/lean4/doc/dev/debugging.html\">possible</a>, but I thought it worth inquiring nonetheless.</p>",
        "id": 361782456,
        "sender_full_name": "Dongwei Jiang",
        "timestamp": 1685289977
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"616750\">Dongwei Jiang</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Code.20for.20GPT-F.20or.20other.20LLM.20used.20for.20ATP/near/361782456\">said</a>:</p>\n<blockquote>\n<p>With respect to tactics data generation, I've read your <a href=\"https://github.com/jasonrute/lean_proof_recording/blob/master/data_examples.ipynb\">notebook</a> and I have generated the 'cleaned_training_data'. However, I'm uncertain about the formatting of data for LLM fine-tuning. Should the data be presented in the \"GOAL &lt;TacticState&gt; PROOFSTEP &lt;Tactic&gt;\" format? Or, should I just keep the 'GOAL' as a condition (as it will be provided by Lean) and just fine-tune the 'Tactic' part?</p>\n</blockquote>\n<p>How you train your model is up to you.  If you are using an encoder-decoder architecture, you would probably put the proof state as the input and the tactic as the target (generating a loss only for the tactic).  If you were using a decoder-only architecture, as we did in the paper, then you would have to let the model know where the proof state ends and the tactic begins.  (Also, you need to decide if you want to mask the loss on the input.  I believe we didn't.  IIRC, we trained on all the tokens.)  That is the purpose of the GOAL and PROOFSTEP tags.  The other purpose also was that we put in lots of other auxiliary tasks like predicting lemma names.  To do this, we wanted the model to know which task it was working on, so we used other tags besides GOAL and PROOFSTEP to signify the type of data that was to follow.  This is basically a form of prompt engineering, and you could do it many different ways.</p>\n<blockquote>\n<p>In terms of the search, I'm still familiarizing myself with lean-tpe-public and it seems I need to implement something similar to the fairseq API considering my usage of a custom language model. However, I've noticed that the documentation surrounding the fairseq API is somewhat limited, and I'm curious if you could provide any additional insights to aid in my understanding of it (like how does the fairseq API work and what do I need to make the search work with custom language model).</p>\n</blockquote>\n<p>The main API we used is actually the OpenAI api which was really simple.  We used curl to call the API and used Lean's JSON functionality to parse the response.  You should just need to figure out the API for the language model you use.    Having said that see below about Lean Gym.</p>\n<blockquote>\n<p>Furthermore, I have a question about debugging. I'm curious to know if it's possible to debug this Lean project in a similar manner to how we typically handle debugging in a Python project? My preliminary research suggests that this might not be <a href=\"https://leanprover.github.io/lean4/doc/dev/debugging.html\">possible</a>, but I thought it worth inquiring nonetheless.</p>\n</blockquote>\n<p>The document you referenced was for Lean 4, but all this data and tools you are referencing is for Lean 3.   Of course you can debug with print statements, and such, but there isn't a nice debugger for Lean 3.  But let's back up.  I think if you really want to use lean-tpe-public, you will need to learn Lean 3 meta-programming which is different from learning Lean 3 and may not be a good use of your time.  I'd recommend either partnering with someone who knows Lean 3 meta-programming well, or instead using <a href=\"https://github.com/openai/lean-gym\">Lean Gym</a>.  Lean Gym basically replaces lean-tpe-public and is what Open AI (I think) used for later lean projects.  It handles all the meta-programming for you, and exposes everything you need in a Python API.  You can do whatever tree search you want in Python, call whatever language model interface, and generally have much more control and less pain.  <strong>TL;DR use Lean Gym instead of lean-tpe-public.</strong></p>\n<p>Now, I know others are working on tools to make all this easier for both Lean 3 and Lean 4, especially Lean 4.  When those tools come out this should be less painful for ML researchers like yourself.</p>",
        "id": 362033068,
        "sender_full_name": "Jason Rute",
        "timestamp": 1685394396
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span>  Thank you so much for the information!</p>\n<p>1  The clarification regarding the training data is appreciated. I'm using LLAMA, so I will follow the same training data organization method in your paper.<br>\n2  The purpose of Lean Gym is much clearer now. With the help of <strong>run_tac</strong> and the state information provided by REFL, implementing my own search algorithm appears much more feasible. I have implemented a Python wrapper for the REFL API already and I'm planning to start with a best-first search.<br>\n3  Your advice on collaborating with a mathematician resonates with me. I believe such a partnership could be beneficial. I'll look into making connections in the \"new members\" thread.</p>\n<p>Thanks again for your suggestions.</p>",
        "id": 362752274,
        "sender_full_name": "Dongwei Jiang",
        "timestamp": 1685625668
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> ,</p>\n<p>I hope you're doing well. First, let me express my gratitude for your invaluable advice so far. Following your guidance, I've proceeded with data preparation, model training, and search. However, I'm observing that the model is underperforming, failing to prove anything in miniF2F.</p>\n<p>Given this context, I've encountered a couple of queries related to the training data derived from your repository, which I've organized as per the PACT paper (\"GOAL \" + line from train.src + \" PROOFSTEP \" + line from train.tgt).</p>\n<p>1  I've noticed certain keys appearing multiple times in train.src, associated with different train.tgt entries. For instance, the first two lines in train.src are the same, but the first two lines in train.tgt are different:</p>\n<p>train.src</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">buffer</span> <span class=\"n\">α</span><span class=\"o\">,</span>   <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>  <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b.size</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span>   <span class=\"bp\">⊢</span> <span class=\"n\">b.write</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">b.write'</span> <span class=\"n\">i</span> <span class=\"n\">v</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">buffer</span> <span class=\"n\">α</span><span class=\"o\">,</span>   <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>  <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b.size</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span>   <span class=\"bp\">⊢</span> <span class=\"n\">b.write</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">b.write'</span> <span class=\"n\">i</span> <span class=\"n\">v</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>  <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span>  <span class=\"n\">b_fst</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>  <span class=\"n\">b_snd</span> <span class=\"o\">:</span> <span class=\"n\">array</span> <span class=\"n\">b_fst</span> <span class=\"n\">α</span><span class=\"o\">,</span>  <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">buffer.size</span> <span class=\"o\">⟨</span><span class=\"n\">b_fst</span><span class=\"o\">,</span> <span class=\"n\">b_snd</span><span class=\"o\">⟩</span>  <span class=\"bp\">⊢</span> <span class=\"n\">buffer.write</span> <span class=\"o\">⟨</span><span class=\"n\">b_fst</span><span class=\"o\">,</span> <span class=\"n\">b_snd</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">buffer.write'</span> <span class=\"o\">⟨</span><span class=\"n\">b_fst</span><span class=\"o\">,</span> <span class=\"n\">b_snd</span><span class=\"o\">⟩</span> <span class=\"n\">i</span> <span class=\"n\">v</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>  <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span>  <span class=\"n\">b_fst</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>  <span class=\"n\">b_snd</span> <span class=\"o\">:</span> <span class=\"n\">array</span> <span class=\"n\">b_fst</span> <span class=\"n\">α</span><span class=\"o\">,</span>  <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">buffer.size</span> <span class=\"o\">⟨</span><span class=\"n\">b_fst</span><span class=\"o\">,</span> <span class=\"n\">b_snd</span><span class=\"o\">⟩</span>  <span class=\"bp\">⊢</span> <span class=\"o\">⟨</span><span class=\"n\">b_fst</span><span class=\"o\">,</span> <span class=\"n\">b_snd.write</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"n\">v</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">b_fst</span><span class=\"o\">,</span> <span class=\"n\">b_snd.write'</span> <span class=\"n\">i</span> <span class=\"n\">v</span><span class=\"o\">⟩</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">buffer</span> <span class=\"n\">α</span><span class=\"o\">,</span>   <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>  <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b.size</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span>   <span class=\"bp\">⊢</span> <span class=\"n\">b.write</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">b.write'</span> <span class=\"n\">i</span> <span class=\"n\">v</span>\n</code></pre></div>\n<p>train.tgt</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">cases</span> <span class=\"n\">b</span><span class=\"bp\">;</span> <span class=\"n\">unfold</span> <span class=\"n\">write</span> <span class=\"n\">write'</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">array.write_eq_write'</span><span class=\"o\">]</span>\n<span class=\"n\">cases</span> <span class=\"n\">b</span><span class=\"bp\">;</span> <span class=\"n\">unfold</span> <span class=\"n\">write</span> <span class=\"n\">write'</span>\n<span class=\"n\">unfold</span> <span class=\"n\">write</span> <span class=\"n\">write'</span>\n<span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">array.write_eq_write'</span><span class=\"o\">]</span>\n<span class=\"n\">cases</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>Upon inspection, it seems that one of them acts as the \"master tactic\", while the others function as \"sub-tactics\". Although it's understandable because of the way we traced the data, I'm concerned this might be causing ambiguity during training. Given our step-by-step proofing approach, would it be advisable to remove the \"master tactics\" from training (by deleting the longest entry with the same key)?</p>\n<p>2  I've attempted to prove some theorems in Lean Gym using training data. However, I find that the intermediate tactics state from a theorem in Lean Gym bears similarities to the traced tactic state, albeit with subtle differences. Take the theorem \"complex.tan_neg\" as an example:</p>\n<p>lean-gym output:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">lean</span> <span class=\"c1\">--run src/repl.lean</span>\n<span class=\"o\">[</span><span class=\"s2\">\"init_search\"</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"s2\">\"complex.tan_neg\"</span><span class=\"o\">,</span> <span class=\"s2\">\"\"</span><span class=\"o\">]]</span>\n<span class=\"o\">{</span><span class=\"s2\">\"error\"</span><span class=\"o\">:</span><span class=\"n\">null</span><span class=\"o\">,</span><span class=\"s2\">\"proof_steps\"</span><span class=\"o\">:[],</span><span class=\"s2\">\"search_id\"</span><span class=\"o\">:</span><span class=\"s2\">\"0\"</span><span class=\"o\">,</span><span class=\"s2\">\"tactic_state\"</span><span class=\"o\">:</span><span class=\"s2\">\"⊢ ∀ (x : ℂ), complex.tan (-x) = -complex.tan x\"</span><span class=\"o\">,</span><span class=\"s2\">\"tactic_state_id\"</span><span class=\"o\">:</span><span class=\"s2\">\"0\"</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>train.src corresponding data:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span>   <span class=\"bp\">⊢</span> <span class=\"n\">complex.tan</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">complex.tan</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>train.tgt corresponding data:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">tan</span><span class=\"o\">,</span> <span class=\"n\">neg_div</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>the lemma in original mathlib:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">tan_neg</span> <span class=\"o\">:</span> <span class=\"n\">tan</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">tan</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">tan</span><span class=\"o\">,</span> <span class=\"n\">neg_div</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I had assumed that the \"tactic_state\" from Lean Gym would be exactly the same as the entries in train.src. But that does not seem to be the case. Is there any more processing I need to do during the search?</p>\n<p>Lastly, I wanted to share that I have connected with another Lean enthusiast who also has a keen interest in ATP. This connection was facilitated through a professor I'm collaborating with. Your recommendation has indeed been helpful!</p>\n<p>Thank you for your patience and support as I navigate this learning curve.</p>",
        "id": 365112383,
        "sender_full_name": "Dongwei Jiang",
        "timestamp": 1686401222
    },
    {
        "content": "<p>I'll get back to you later when I have more time (maybe tomorrow or Monday), but screenshots are hard to follow.  It is better to use markdown <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a>.</p>",
        "id": 365175527,
        "sender_full_name": "Jason Rute",
        "timestamp": 1686421568
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Code.20for.20GPT-F.20or.20other.20LLM.20used.20for.20ATP/near/365175527\">said</a>:</p>\n<blockquote>\n<p>I'll get back to you later when I have more time (maybe tomorrow or Monday), but screenshots are hard to follow.  It is better to use markdown <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a>.</p>\n</blockquote>\n<p>Thanks for the info! I've replaced the screenshot with markdown.</p>",
        "id": 365211031,
        "sender_full_name": "Dongwei Jiang",
        "timestamp": 1686440939
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"616750\">@Dongwei Jiang</span> I’m very interested to hear about your reproduction.  I personally wasn’t involved in the model training side of the PACT paper so I’m especially curious to see how it goes.  </p>\n<p>As for the duplication, that is due to compound tactics, e.g. tactics with semicolons.   We left them in there for the PACT paper and it let the model produce proofs with semicolon tactics for example.   I don’t know what is best, but that is what we did.  We did however (if I recall correctly) remove any exact duplicates where the proofstate-tactic pair were the exact same.  As for the goal mismatch, what you are seeing is due to the following:  when you write a theorem in Lean, you often use the pattern:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"bp\">…</span>\n</code></pre></div>\n<p>But Lean stores the theorem as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>This does lead to a discrepancy.  Since in the former the first goal is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|-</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>But in the latter the first goal is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">|-</span> <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>To get to the first goal, you need the tactic <code>intro x</code>.  After that the proof should be the same.  I don’t think this was a big deal in practice (as there still was a lot of data using <code>intro x</code>), but I could be mistaken.</p>\n<p>Nonetheless you do have to make sure the goals are processed the same way in the data and in Lean Gym.  After the <code>intro x</code> in my example you should expect the goals to be exactly the same, including little things like making sure there are tabs separating the hypotheses instead of new lines.</p>\n<p>It would also be a good idea to check you can prove theorems found in the training data.</p>",
        "id": 365221490,
        "sender_full_name": "Jason Rute",
        "timestamp": 1686447572
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> Thanks for your detailed explanations on duplication and goal mismatch issues. They were very helpful!</p>\n<p>I'm currently finetuning LLAMA on the Lean data. The initial results aren't stellar, perhaps due to the domain difference between original LLAMA training and Lean states/tactics. It's also possible that the LORA/PEFT setup I've used might need adjustments.</p>\n<p>I'll be sure to share my training setup and results when there's substantial progress. Thank you for your continued support!</p>",
        "id": 365566682,
        "sender_full_name": "Dongwei Jiang",
        "timestamp": 1686577192
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span>  Just circling back with a few more updates on my LLAMA finetuning. Using the standard Alpaca repo, I've successfully finetuned the 7B LLAMA model with 4 A100 80G on the data from your repo. During training, LLAMA demonstrates solid performance on the validation set.</p>\n<p>However, when testing on miniF2F, the accuracy is only around 11% with argmax for Pass at 1. The generated proofs are mostly simple one-liners like <code>norm_num, ring, or linarith</code>. I think the result underscores the need for adding more contextual information to tactic generation - a concept similar to premise selection in ReProver or PACT, which I plan to explore further.</p>\n<p>Simultaneously, I've been dabbling in <a href=\"https://github.com/Some-random/lean-example/blob/main/src/example2.lean\">formalizing natural language reasoning problems</a> to Lean, with a focus on using ATP for problem-solving. This approach, I believe, could help reduce hallucination in LLM during reasoning and leverage the power of ATP models for proof generation on natural language problems. So this might slow my progress on conventional theorem proving.</p>",
        "id": 376843676,
        "sender_full_name": "Dongwei Jiang",
        "timestamp": 1689827038
    },
    {
        "content": "<p>I wonder if this thread should get moved to <a class=\"stream\" data-stream-id=\"219941\" href=\"/#narrow/stream/219941-Machine-Learning-for-Theorem-Proving\">#Machine Learning for Theorem Proving</a> .  I think people their should find your progress interesting?</p>",
        "id": 376881363,
        "sender_full_name": "Jason Rute",
        "timestamp": 1689840391
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"616750\">@Dongwei Jiang</span> </p>\n<blockquote>\n<p>the accuracy is only around 11% with argmax for Pass at 1</p>\n</blockquote>\n<p>To be clear, what does this mean, especially the argmax part?  Are you using a proof search like best first search, or just taking the top-1 tactic at each step until failure?</p>",
        "id": 376884255,
        "sender_full_name": "Jason Rute",
        "timestamp": 1689841008
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span>  Yes, you're correct. I'm currently utilizing a strategy of taking the top-1 tactic at each step until failure. While a best-first search approach might offer improved results, I guess its impact could be marginal at this stage, as the model seems primarily to be matching tactic states that follow simpler proofs like norm_num, ring, or linarith, rather than constructing robust chains of mathematical reasoning.</p>\n<p>Regarding my work on formalizing natural language reasoning tasks, I'd be delighted to collaborate with anyone interested. So I suppose I'll post something about it in the machine learning channel.</p>",
        "id": 376916596,
        "sender_full_name": "Dongwei Jiang",
        "timestamp": 1689847480
    },
    {
        "content": "<p>I just stumbled on <a href=\"https://leandojo.org/\">https://leandojo.org/</a> which seems to be quite new for lean</p>",
        "id": 388922752,
        "sender_full_name": "Marcello Seri",
        "timestamp": 1693811420
    },
    {
        "content": "<p>See also <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Releasing.20LeanDojo\">https://leanprover.zulipchat.com/#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Releasing.20LeanDojo</a></p>",
        "id": 388922900,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1693811493
    }
]