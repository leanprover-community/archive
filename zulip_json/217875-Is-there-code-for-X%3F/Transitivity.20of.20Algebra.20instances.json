[
    {
        "content": "<p>I couldn't find the following in Mathlib</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">compHom</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and I have got two questions</p>\n<ul>\n<li>Is this the right way to say this, or there is a better way in Mathlib?</li>\n<li>When I attempt to turn this into an instance, I got the following error. Why is it?</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">cannot</span><span class=\"w\"> </span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"n\">synthesization</span><span class=\"w\"> </span><span class=\"n\">order</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">        </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">          </span><span class=\"o\">[</span><span class=\"n\">inst_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst_2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">C</span>\n<span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">remaining</span><span class=\"w\"> </span><span class=\"n\">arguments</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">metavariables</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">B</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">✝⁴</span><span class=\"w\"> </span><span class=\"n\">CommSemiring</span><span class=\"bp\">.</span><span class=\"n\">toSemiring</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">✝²</span>\n</code></pre></div>",
        "id": 555436249,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1763060653
    },
    {
        "content": "<p>If you need an instance of <code>Algebra A C</code>, Lean would need to guess the <code>B</code> out of thin-air, which is impossible. Remember that instances work backwards from how you state them.</p>",
        "id": 555437207,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1763060884
    },
    {
        "content": "<p>Therefore the standard way to <em>assume</em> this in the statement of a theorem is by <code>[Algebra A B] [Algebra B C] [Algebra A C] [IsScalarTower A B C]</code>, and if you actually construct the algebra instances then you use compHom or some other way</p>",
        "id": 555437437,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1763060958
    },
    {
        "content": "<p>I see. I am not super familiar with the usage of IsScalarTower yet, but good to learn an example of its usage! I'll try formulating my statements in that way</p>",
        "id": 555437745,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1763061066
    },
    {
        "content": "<p>Note that it took us quite a lot of time to realize that the good design choice is <code>IsScalarTower</code>, this is a beautiful piece of formalization.</p>",
        "id": 555438741,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1763061377
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"873350\">@Weiyi Wang</span> <a href=\"https://loogle.lean-lang.org/?q=%E2%8A%A2+IsScalarTower+_+_+_+%E2%86%92+%28_+%3A+Prop%29\">https://loogle.lean-lang.org/?q=%E2%8A%A2+IsScalarTower+_+_+_+%E2%86%92+%28_+%3A+Prop%29</a></p>",
        "id": 555439078,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1763061487
    },
    {
        "content": "<p>There is a subtlety here, which shows up in lots of different places. Here's another one: if you have a topological space and you want to say \"now put the Borel sigma algebra on it\" you don't just magically construct a sigma algebra in the middle of your proof, you put the extra assumptions <code>[MeasurableSpace X] [BorelSpace X]</code> -- the first is a \"random\" sigma algebra and the second is the assumption that it's the Borel sigma algebra. Similarly here you don't want to <em>make</em> <code>Algebra A C</code>, you want to assume C has a random A-algebra structure and then put the hypothesis that the triangle commutes into the typeclass system. This way you're getting the typeclass system to work for you, instead of fighting against it. The problem with your def is that it can't be an instance, because if C is already an A-algebra then you just made a second A-algebra structure on it, and it's equal to the one you already had but, crucially, the proof might not be <code>rfl</code> so now typeclass inference is going to break. By asking typeclass inference to supply the A-algebra structure you avoid this problem.</p>",
        "id": 555576706,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1763123689
    },
    {
        "content": "<p>I think it's fine to magically construct the new structure in the middle of your proof, you just don't want to do that in the middle of your statement</p>",
        "id": 555584081,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763126051
    },
    {
        "content": "<p>By the same token as <code>[TopologicalSpace X] [MeasurableSpace X] [BorelSpace X]</code>,<br>\nwe should have <code>[UniformSpace X] [TopologicalSpace X] [UniformityInducesTopology X]</code></p>",
        "id": 555614051,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1763133496
    },
    {
        "content": "<p>Things start to get out of hand if we also have <code>NormInducesDist</code> and <code>DistInducesTopology</code> as well</p>",
        "id": 555614677,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1763133647
    },
    {
        "content": "<p>I'm not sure what you mean. A topological space and a measurable space are orthogonal structures in general, and then <code>BorelSpace X</code> says they are related. While a uniform structure always gives rise to a topology, so it would be very weird to have them separately. It would be a little bit like having <code>[Ring R] [AddCommGroup R] [RingInducesAddCommGroup R]</code>.</p>",
        "id": 555614815,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1763133675
    },
    {
        "content": "<p>Is <code>Algebra.compHom C (algebraMap A B)</code> the idiomatic way to stitch together two <code>Algebra</code>s in the middle of a proof? Is there nothing like <code>def Algebra.comp [Algebra A B] [Algebra B C] : Algebra A C</code>?</p>",
        "id": 565527828,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1766864905
    },
    {
        "content": "<p>Why are some instances orthogonal (topology and measure) but some aren't (ring and group, topology and uniformity)? IIUC this is only based on what people want to do with it right? If there were interesting maths to be done where the same type is a ring and a group that aren't related, we would have <code>RingInducesGroup</code>?<br>\nAlso, thoughts on <a href=\"https://github.com/leanprover-community/mathlib4/pull/32891\">#32891</a>? (a metric unrelated to the topology)</p>",
        "id": 565533511,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766873848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400289\">Artie Khovanov</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Transitivity.20of.20Algebra.20instances/near/565527828\">said</a>:</p>\n<blockquote>\n<p>Is <code>Algebra.compHom C (algebraMap A B)</code> the idiomatic way to stitch together two <code>Algebra</code>s in the middle of a proof? Is there nothing like <code>def Algebra.comp [Algebra A B] [Algebra B C] : Algebra A C</code>?</p>\n</blockquote>\n<p>Maybe <code>algebraize [(algebraMap B C).comp (algebraMap A B)]</code>. It might give you <code>IsScalarTower A B C</code> for free if you are lucky.</p>",
        "id": 565533673,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1766874130
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Transitivity.20of.20Algebra.20instances/near/565533511\">said</a>:</p>\n<blockquote>\n<p>Why are some instances orthogonal (topology and measure) but some aren't (ring and group, topology and uniformity)? IIUC this is only based on what people want to do with it right? If there were interesting maths to be done where the same type is a ring and a group that aren't related, we would have <code>RingInducesGroup</code>?<br>\nAlso, thoughts on <a href=\"https://github.com/leanprover-community/mathlib4/pull/32891\">#32891</a>? (a metric unrelated to the topology)</p>\n</blockquote>\n<p>A ring is mathematically defined as a group with extra structure. Meanwhile topologies and measures are just different kinds of structures, where it so happens you can sometimes create one using the other.</p>",
        "id": 565534011,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1766874655
    },
    {
        "content": "<p>I agree but I think these are the extremes, whereas the inner-product/norm/metric/uniformity/topology chain seems a bit more fluid to me.<br>\nAlso I once wanted to have the <code>CommMonoid</code> on <code>Int</code> where the operation is <code>max</code>, and at the same time have the usual <code>Ring</code> structure.<br>\nCan we not have something like <code>DistInducesTopology</code> and the rest, and add some fancy macros to make them easier to handle?<br>\n(slightly tangential: made me think of having a <code>@to_classes</code> that converts every <code>FooHom</code> in a statement to <code>FooHomClass</code>)</p>",
        "id": 565534883,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766876227
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Transitivity.20of.20Algebra.20instances/near/565533673\">said</a>:</p>\n<blockquote>\n<p>Maybe <code>algebraize [(algebraMap B C).comp (algebraMap A B)]</code>. It might give you <code>IsScalarTower A B C</code> for free if you are lucky.</p>\n</blockquote>\n<p>Thank you this worked! It even game me the scalar tower in 1/2 cases.</p>",
        "id": 565540804,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1766885594
    }
]