[
    {
        "content": "<p>Is there code for a computable breadth first traversal of a directed graph, ie for computing the epsilon closure of a non deterministic finite state automaton?</p>",
        "id": 437375746,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715055222
    },
    {
        "content": "<p>You mean for mathlib graphs? I'm not aware of this</p>",
        "id": 437378060,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1715056989
    },
    {
        "content": "<p>Ok. Thank you.</p>",
        "id": 437378634,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715057467
    },
    {
        "content": "<p>The mathlib simple graph is not defined in terms of any computable graph representation</p>",
        "id": 437381462,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715059804
    },
    {
        "content": "<p>The translation to and from an adjacency matrix is also defined using Props</p>",
        "id": 437381638,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715060000
    },
    {
        "content": "<p>Edit: the closest i could find after a more recent search now was this: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/EpsilonNFA.html#%CE%B5NFA.stepSet\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/EpsilonNFA.html#%CE%B5NFA.stepSet</a></p>",
        "id": 437382045,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715060394
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 437382049,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715060397
    },
    {
        "content": "<p>The step function is defined as a set</p>",
        "id": 437382114,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715060415
    },
    {
        "content": "<p>Just what I am looking for. Thank you!</p>",
        "id": 437382466,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715060738
    },
    {
        "content": "<p>Am I right in that that is not computable because <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/EpsilonNFA.html#%CE%B5NFA.%CE%B5Closure\">εNFA.εClosure</a> is not computable? Or is εClosure computable?</p>",
        "id": 437383887,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715061815
    },
    {
        "content": "<p>It is an inductive Prop</p>",
        "id": 437384977,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715062528
    },
    {
        "content": "<p>Not computable in any meaningful sense</p>",
        "id": 437384997,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715062538
    },
    {
        "content": "<p>I see. I guess that means the NFA computed from the εNFA is not computable either. Which means that a regular expression translated to a εNFA is also not going to be computable.</p>",
        "id": 437385229,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715062681
    },
    {
        "content": "<p>The mathlib docs for NFA say that for actual NFAs, fintype instances must be provided for the state and alphabet type</p>",
        "id": 437385371,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715062762
    },
    {
        "content": "<p>Fintype implies that there is an explicit list of elements of the type</p>",
        "id": 437385414,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715062802
    },
    {
        "content": "<p>That being said, I don't think it provides a representation that we would normally work with in CS.</p>",
        "id": 437385492,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715062837
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/NFA.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/NFA.html</a></p>",
        "id": 437385524,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715062858
    },
    {
        "content": "<p>That would be ok, except that the only way I currently (and just recently learned) to compute a regexp is to first translate it to a εNFA.</p>",
        "id": 437385678,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715062948
    },
    {
        "content": "<p>There is an old algorithm that skips the epsilon nfa step and directly computes a dfa. Let me see if I can recall the name. Basically it constructs a tree from the regexp respecting the priority rules for operators and computes states as subsets of the tree's leaf nodes</p>",
        "id": 437385829,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715063044
    },
    {
        "content": "<p>Please check this, but I think it is called the McNaughton Yamada construction</p>",
        "id": 437386048,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715063183
    },
    {
        "content": "<p>The DFA version has the potential for an exponential expansion of the number of states though, right? The NFA can be computed in O(m), where m is the length of the string to match, at the expense of greater mem usage?</p>",
        "id": 437386070,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715063194
    },
    {
        "content": "<p>That is the one I learned, but it goes to a εNFA first I think.</p>",
        "id": 437386262,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715063288
    },
    {
        "content": "<p>The McNaughton yamada construction is often confused with the Thomson construction but is different.</p>",
        "id": 437386290,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715063301
    },
    {
        "content": "<p>The epsilon NFA construction is Thompson's</p>",
        "id": 437386323,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715063320
    },
    {
        "content": "<p>Hmm. Ok.</p>",
        "id": 437386442,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715063401
    },
    {
        "content": "<p>NFAs can be much more succinct that DFAs at the cost of computation.</p>",
        "id": 437386490,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715063406
    },
    {
        "content": "<p>I mean, when evaluating the possible outcomes of the NFA, one is practically re doing the powerset construction</p>",
        "id": 437386526,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715063438
    },
    {
        "content": "<p>The NFA will run faster though right, at the cost of mem usage? (my reference: <a href=\"https://swtch.com/~rsc/regexp/regexp1.html\">https://swtch.com/~rsc/regexp/regexp1.html</a>)</p>",
        "id": 437386753,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715063579
    },
    {
        "content": "<p>Or maybe that is what you meant.</p>",
        "id": 437386950,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715063699
    },
    {
        "content": "<p>Maybe what they are doing there is running what is essentially the NFA converted to a DFA.</p>",
        "id": 437387145,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715063778
    },
    {
        "content": "<p>Basically with an NFA, in order to test acceptance, you have to try out every non deterministic choice when the automaton is run</p>",
        "id": 437387182,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715063798
    },
    {
        "content": "<p>Yes.</p>",
        "id": 437387276,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715063862
    },
    {
        "content": "<p>There are two practical factors to consider: </p>\n<ol>\n<li>how many queries are you making against this automaton ? The dfa construction precomputes the reachable state set, whereas with an NFA one is potentially repeating this computation with each query.</li>\n<li>Quite often the reachable state set in the dfa won't be exponentially larger in cardinality than the nfa</li>\n</ol>",
        "id": 437387566,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715064007
    },
    {
        "content": "<p>Yes, I see, the DFA would probably be better for the use case I have in mind.</p>",
        "id": 437387812,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715064138
    },
    {
        "content": "<p>Anyway, to return to your original question, I would suggest: <del>Construct a fintype based epsilon nfa</del> (add a fintype constraint to the state type and alphabet type) and define a computable BFS based epsilon closure function, and then there are two options:</p>\n<ol>\n<li>\n<p>Prove that the definition is equivalent to the existing inductive prop definition and get the downstream theorems from mathlib for free. But proving this equivalence might be hard. Perhaps the reflection feature of LeanSSR is useful for this.</p>\n</li>\n<li>\n<p>Freshly prove those downstream theorems directly from definition. This might be more legwork, but the proofs could be more \"natural\".</p>\n</li>\n</ol>",
        "id": 437388190,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715064332
    },
    {
        "content": "<p>Sounds reasonable. What is LeanSSR?</p>",
        "id": 437388376,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715064425
    },
    {
        "content": "<p>It is a new library from Vladimir Goldstein and Ilya Sergey, which provides a library for small scale reflection tactics</p>",
        "id": 437388540,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715064511
    },
    {
        "content": "<p>This tactic language is used in Coq's mathcomp</p>",
        "id": 437388605,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715064542
    },
    {
        "content": "<p>LeanSSR brings a version with better UX to Lean</p>",
        "id": 437388658,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715064565
    },
    {
        "content": "<p>Ok, I'm not familiar with reflection tactics.</p>",
        "id": 437388689,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715064583
    },
    {
        "content": "<p>I'll have to look it up.</p>",
        "id": 437388760,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715064605
    },
    {
        "content": "<p>Thank you.</p>",
        "id": 437388800,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715064626
    },
    {
        "content": "<p>I don't have deep familiarity myself. This library is very new</p>",
        "id": 437388865,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715064667
    },
    {
        "content": "<p>But the authors are on this zulip, and might be able to provide more help with that</p>",
        "id": 437388925,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715064708
    },
    {
        "content": "<p>Arguably that reflection tactic is largely the <code>decide</code> that mathlib already has</p>",
        "id": 437500933,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715103957
    },
    {
        "content": "<p>I am not going to argue that point. <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> the better UX claim is not as spicy as it sounds. It is mentioned in the paper (points 1,2, and 3 in page 2).  This was also mentioned in zulip</p>",
        "id": 437503209,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715104857
    },
    {
        "content": "<p>Indeed, let's not rehash the discussion <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428306623\">in that thread</a> any further</p>",
        "id": 437506127,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715105971
    },
    {
        "content": "<p>It might be nice, performance-wise, to compare a lazily unfolded epsilon closure using Thunks, with an eagerly precomputed one. It would be harder to prove anything about it though.</p>",
        "id": 437737587,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715205843
    },
    {
        "content": "<p>This is an attempt at code to do a breadth first traversal of a graph, beginning at a given vertex. I'm wondering if anyone might know a more efficient/clearer/simpler way to do it. I didn't find a lot of resources online that I could easily follow for how to do it functionally/recursively. I also haven't figured out how to prove that it terminates yet.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span>\n<span class=\"kd\">def</span> <span class=\"n\">breadth_first_traversal_aux</span>\n  <span class=\"o\">{</span><span class=\"n\">Vertex</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">Vertex</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">outside</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">boundary</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">inside</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Vertex</span> <span class=\"bp\">×</span> <span class=\"n\">Vertex</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">List</span> <span class=\"n\">Vertex</span> <span class=\"o\">:=</span>\n  <span class=\"c1\">-- All of the vertices that are outside and adjacent to at least one vertex in the boundary.</span>\n  <span class=\"k\">let</span> <span class=\"n\">next</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Vertex</span> <span class=\"o\">:=</span> <span class=\"n\">List.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">out</span> <span class=\"o\">:</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Vertex</span><span class=\"o\">),</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">boundary</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">out</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span><span class=\"o\">)</span> <span class=\"n\">outside</span>\n  <span class=\"k\">if</span> <span class=\"n\">next</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span>\n  <span class=\"k\">then</span> <span class=\"n\">inside</span> <span class=\"bp\">∪</span> <span class=\"n\">boundary</span>\n  <span class=\"k\">else</span> <span class=\"n\">breadth_first_traversal_aux</span> <span class=\"o\">(</span><span class=\"n\">outside</span> <span class=\"bp\">\\</span> <span class=\"n\">next</span><span class=\"o\">)</span> <span class=\"n\">next</span> <span class=\"o\">(</span><span class=\"n\">inside</span> <span class=\"bp\">∪</span> <span class=\"n\">next</span><span class=\"o\">)</span> <span class=\"n\">edges</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  `breadth_first_traversal V E start` := All of the vertices in `V` that are reachable from the vertex `start` by following a sequence of zero or more edges in `E`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">breadth_first_traversal</span>\n  <span class=\"o\">{</span><span class=\"n\">Vertex</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">Vertex</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">vertices</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Vertex</span> <span class=\"bp\">×</span> <span class=\"n\">Vertex</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"o\">:</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">List</span> <span class=\"n\">Vertex</span> <span class=\"o\">:=</span>\n  <span class=\"n\">breadth_first_traversal_aux</span> <span class=\"n\">vertices</span> <span class=\"o\">[</span><span class=\"n\">start</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">start</span><span class=\"o\">]</span> <span class=\"n\">edges</span>\n</code></pre></div>",
        "id": 437771399,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715232782
    },
    {
        "content": "<p>You don't need a separate <code>inside</code> and <code>boundary</code> set within a bfs function. The batteries (formerly std) library would almost certainly have a queue data structure</p>",
        "id": 437777501,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715237866
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> Std.Queue</p>",
        "id": 437777556,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715237885
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Queue.html#Std.Queue\">Std.Queue</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Queue.html#Std.Queue.empty\">Std.Queue.empty</a>, and <a href=\"https://loogle.lean-lang.org/?q=Std.Queue\">17 more</a></p>",
        "id": 437777558,
        "sender_full_name": "loogle",
        "timestamp": 1715237886
    },
    {
        "content": "<p>You can implement a bfs in the usual way with a queue. Since you would add at least one element each iteration to the list of visited nodes, the termination parameter could be (no. Of vertices - length of visited nodes list)</p>",
        "id": 437777820,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715238075
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> Batteries.Queue</p>",
        "id": 437778134,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715238318
    },
    {
        "content": "<p><span aria-label=\"exclamation\" class=\"emoji emoji-2757\" role=\"img\" title=\"exclamation\">:exclamation:</span> unknown identifier 'Batteries.Queue'<br>\nDid you mean <a href=\"https://loogle.lean-lang.org/?q=%22Batteries.Queue%22\"><code>\"Batteries.Queue\"</code></a>?</p>",
        "id": 437778137,
        "sender_full_name": "loogle",
        "timestamp": 1715238319
    },
    {
        "content": "<p>4 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/stream/217875-Is-there-code-for-X.3F/topic/loogle.20on.20newly.20renamed.20Batteries\">#Is there code for X? &gt; loogle on newly renamed Batteries</a> by <span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span>.</p>",
        "id": 437781199,
        "sender_full_name": "Notification Bot",
        "timestamp": 1715240410
    },
    {
        "content": "<p>With the exisiting implementation, the recursive call is only made when the cardinality of <code>outside</code> strictly decreases</p>",
        "id": 437782192,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715241068
    },
    {
        "content": "<p>so something like the following might work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">breadth_first_traversal_aux</span>\n  <span class=\"o\">{</span><span class=\"n\">Vertex</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">Vertex</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">outside</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">boundary</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">inside</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Vertex</span> <span class=\"bp\">×</span> <span class=\"n\">Vertex</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">List</span> <span class=\"n\">Vertex</span> <span class=\"o\">:=</span>\n  <span class=\"c1\">-- All of the vertices that are outside and adjacent to at least one vertex in the boundary.</span>\n  <span class=\"k\">let</span> <span class=\"n\">next</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Vertex</span> <span class=\"o\">:=</span> <span class=\"n\">List.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">out</span> <span class=\"o\">:</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Vertex</span><span class=\"o\">),</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">boundary</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">out</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span><span class=\"o\">)</span> <span class=\"n\">outside</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">next</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span>\n  <span class=\"k\">then</span> <span class=\"n\">inside</span> <span class=\"bp\">∪</span> <span class=\"n\">boundary</span>\n  <span class=\"k\">else</span> <span class=\"n\">breadth_first_traversal_aux</span> <span class=\"o\">(</span><span class=\"n\">outside</span> <span class=\"bp\">\\</span> <span class=\"n\">next</span><span class=\"o\">)</span> <span class=\"n\">next</span> <span class=\"o\">(</span><span class=\"n\">inside</span> <span class=\"bp\">∪</span> <span class=\"n\">next</span><span class=\"o\">)</span> <span class=\"n\">edges</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">outside.length</span>\n<span class=\"n\">decreasing_by</span>\n  <span class=\"n\">simp_wf</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 437782219,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715241097
    },
    {
        "content": "<p>But it will be complicated to show this, because you also have to prove that the <code>next</code> set atually came from <code>outside</code> using lemmas for <code>List.filter</code></p>",
        "id": 437782352,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715241181
    },
    {
        "content": "<p>Thank you. Like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span>\n<span class=\"kd\">def</span> <span class=\"n\">breadth_first_traversal_aux</span>\n  <span class=\"o\">{</span><span class=\"n\">Vertex</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">Vertex</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Vertex</span> <span class=\"bp\">×</span> <span class=\"n\">Vertex</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">visited</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">queue</span> <span class=\"o\">:</span> <span class=\"n\">Std.Queue</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">List</span> <span class=\"n\">Vertex</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">queue.dequeue</span><span class=\"bp\">?</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Option.some</span> <span class=\"o\">(</span><span class=\"n\">current</span><span class=\"o\">,</span> <span class=\"n\">queue</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">frontier</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">edges.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Vertex</span> <span class=\"bp\">×</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">e.fst</span> <span class=\"bp\">=</span> <span class=\"n\">current</span> <span class=\"bp\">∧</span> <span class=\"n\">e.snd</span> <span class=\"bp\">∉</span> <span class=\"n\">visited</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">Prod.snd</span>\n\n    <span class=\"n\">breadth_first_traversal_aux</span> <span class=\"n\">edges</span> <span class=\"o\">(</span><span class=\"n\">visited</span> <span class=\"bp\">++</span> <span class=\"n\">frontier</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">queue.enqueueAll</span> <span class=\"n\">frontier</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Option.none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">visited</span>\n\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  `breadth_first_traversal E start` := All of the vertices that are reachable from the vertex `start` by following a sequence of zero or more edges in `E`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">breadth_first_traversal</span>\n  <span class=\"o\">{</span><span class=\"n\">Vertex</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">Vertex</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Vertex</span> <span class=\"bp\">×</span> <span class=\"n\">Vertex</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"o\">:</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">List</span> <span class=\"n\">Vertex</span> <span class=\"o\">:=</span>\n  <span class=\"n\">breadth_first_traversal_aux</span> <span class=\"n\">edges</span> <span class=\"o\">[</span><span class=\"n\">start</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">Std.Queue.empty.enqueue</span> <span class=\"n\">start</span><span class=\"o\">)</span>\n\n\n<span class=\"k\">#eval</span> <span class=\"n\">breadth_first_traversal</span> <span class=\"o\">[]</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"k\">#eval</span> <span class=\"n\">breadth_first_traversal</span> <span class=\"o\">[(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)]</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">]</span>\n<span class=\"k\">#eval</span> <span class=\"n\">breadth_first_traversal</span> <span class=\"o\">[(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)]</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">]</span>\n<span class=\"k\">#eval</span> <span class=\"n\">breadth_first_traversal</span> <span class=\"o\">[(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">)]</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">]</span>\n<span class=\"k\">#eval</span> <span class=\"n\">breadth_first_traversal</span> <span class=\"o\">[(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)]</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I'm not sure how to set it up to prove that it terminates. I would guess it would be on the number of elements in the queue, but I'm not sure how to say that.</p>",
        "id": 437929997,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715321565
    },
    {
        "content": "<p>I guess the size of the queue is not strictly decreasing.</p>",
        "id": 437932717,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715323549
    },
    {
        "content": "<p>The number  of non-visited vertices decreases</p>",
        "id": 437939305,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715327154
    },
    {
        "content": "<p>As long as the graph is connected it reaches zero</p>",
        "id": 437942137,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715328554
    },
    {
        "content": "<p>We don't want to assume it is completely connected though right? If that was the case, wouldn't the result always just be the set of all of the vertices in the graph?</p>",
        "id": 438029573,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715366234
    },
    {
        "content": "<p>This is almost there, except where the number of edges is 0.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">breadth_first_traversal_aux</span>\n  <span class=\"o\">{</span><span class=\"n\">Vertex</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">Vertex</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Vertex</span> <span class=\"bp\">×</span> <span class=\"n\">Vertex</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">visited</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">queue</span> <span class=\"o\">:</span> <span class=\"n\">Std.Queue</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">List</span> <span class=\"n\">Vertex</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">queue.dequeue</span><span class=\"bp\">?</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Option.some</span> <span class=\"o\">(</span><span class=\"n\">current</span><span class=\"o\">,</span> <span class=\"n\">next</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">frontier</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">edges.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Vertex</span> <span class=\"bp\">×</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">e.fst</span> <span class=\"bp\">=</span> <span class=\"n\">current</span> <span class=\"bp\">∧</span> <span class=\"n\">e.snd</span> <span class=\"bp\">∉</span> <span class=\"n\">visited</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">Prod.snd</span>\n\n    <span class=\"n\">breadth_first_traversal_aux</span> <span class=\"n\">edges</span> <span class=\"o\">(</span><span class=\"n\">visited</span> <span class=\"bp\">++</span> <span class=\"n\">frontier</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">next.enqueueAll</span> <span class=\"n\">frontier</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Option.none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">visited</span>\n  <span class=\"n\">termination_by</span> <span class=\"n\">edges.length</span> <span class=\"bp\">-</span> <span class=\"n\">visited.length</span>\n  <span class=\"n\">decreasing_by</span>\n    <span class=\"n\">simp_wf</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Vertex</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"n\">Vertex</span>\n<span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Vertex</span> <span class=\"bp\">×</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span>\n<span class=\"n\">visited</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Vertex</span>\n<span class=\"n\">queue</span> <span class=\"o\">:</span> <span class=\"n\">Std.Queue</span> <span class=\"n\">Vertex</span>\n<span class=\"n\">current</span> <span class=\"o\">:</span> <span class=\"n\">Vertex</span>\n<span class=\"n\">next</span> <span class=\"o\">:</span> <span class=\"n\">Std.Queue</span> <span class=\"n\">Vertex</span>\n<span class=\"n\">frontier</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Vertex</span> <span class=\"o\">:=</span> <span class=\"n\">List.map</span> <span class=\"n\">Prod.snd</span> <span class=\"o\">(</span><span class=\"n\">List.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">decide</span> <span class=\"o\">(</span><span class=\"n\">e.1</span> <span class=\"bp\">=</span> <span class=\"n\">current</span> <span class=\"bp\">∧</span> <span class=\"n\">e.2</span> <span class=\"bp\">∉</span> <span class=\"n\">visited</span><span class=\"o\">))</span> <span class=\"n\">edges</span><span class=\"o\">)</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">edges.length</span> <span class=\"bp\">-</span>\n    <span class=\"o\">(</span><span class=\"n\">visited.length</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">List.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">decide</span> <span class=\"o\">(</span><span class=\"n\">e.1</span> <span class=\"bp\">=</span> <span class=\"n\">current</span><span class=\"o\">)</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"bp\">!</span><span class=\"n\">decide</span> <span class=\"o\">(</span><span class=\"n\">e.2</span> <span class=\"bp\">∈</span> <span class=\"n\">visited</span><span class=\"o\">))</span> <span class=\"n\">edges</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span>\n  <span class=\"n\">edges.length</span> <span class=\"bp\">-</span> <span class=\"n\">visited.length</span>\n</code></pre></div>",
        "id": 438038148,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715370826
    },
    {
        "content": "<p>In truth I don't think I need to use a breadth first traversal of the graph per se. For the epsilon closure I just need to compute the subset of the vertices in the graph that are connected to a given vertex. I am assuming that there may be, and likely are, parts of the graph that are disjoint.</p>",
        "id": 438041657,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715372752
    },
    {
        "content": "<p><a href=\"https://github.com/pthomas505/FOL/blob/89f15a82c48a2455fd38a049fb9f1e09a6b56f4f/FOL/Computing/NA.lean#L41-L208\">Got it</a> for depth first traversal using this <a href=\"https://www.isa-afp.org/browser_info/current/AFP/Depth-First-Search/document.pdf\">paper</a> and help from <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> .<br>\n<a href=\"#narrow/stream/348111-batteries/topic/depth.20first.20search/near/439481437\">https://leanprover.zulipchat.com/#narrow/stream/348111-batteries/topic/depth.20first.20search/near/439481437</a></p>",
        "id": 438142025,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1715471496
    },
    {
        "content": "<p>I have some different DFS implementations (two of them have proofs) at <a href=\"https://negiizhao.github.io/Algorithm/Algorithm/Graph/DFS.html\">https://negiizhao.github.io/Algorithm/Algorithm/Graph/DFS.html</a>, one of which may be adapted to a more generalized form in the future to support BFS and other vertex visit orders.</p>",
        "id": 440329599,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1716472786
    },
    {
        "content": "<p>(They are built on some heavier infrastructure... But probably could be modified to a lighter version)</p>",
        "id": 440330838,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1716473088
    }
]