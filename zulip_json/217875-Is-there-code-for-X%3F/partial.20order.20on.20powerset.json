[
    {
        "content": "<p>Does mathlib 4 know about the partial order <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"script\">P</mi><mo stretchy=\"false\">(</mo><mi>S</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo>⊆</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\mathcal{P}(S), \\subseteq)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathcal\" style=\"margin-right:0.08222em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mclose\">)</span></span></span></span> on a powerset?</p>",
        "id": 449780089,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1720417946
    },
    {
        "content": "<p>Yes, there is <code>Lattice (Set X)</code></p>",
        "id": 449785169,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1720420358
    },
    {
        "content": "<p>Thank you. Where can I find the corresponding instance (I don't see it in <code>Mathlib.Order.Lattice</code>)?</p>",
        "id": 449788523,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1720421759
    },
    {
        "content": "<p>I'm guessing <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Lattice.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Lattice.html</a></p>",
        "id": 449789400,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1720422137
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 449820031,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1720431174
    },
    {
        "content": "<p>You can find it with <code>#synth Lattice (Set X)</code></p>",
        "id": 449822850,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720432101
    },
    {
        "content": "<p>In <code>Mathlib.Data.Set.Lattice</code>, I found <code>Set.completeAtomicBooleanAlgebra</code> of type  <code>CompleteAtomicBooleanAlgebra (Set \\a)</code>, so my question becomes how to get the underlying preorder from <code>Set.completeAtomicBooleanAlgebra</code>?</p>",
        "id": 449852676,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1720441409
    },
    {
        "content": "<p>generally, lean should be able to infer that by itself...<br>\nif <code>#synth CompleteAtomicBooleanAlgebra (Set a)</code> works, lean figures out the rest. is there a reason why you're asking?</p>",
        "id": 449854525,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1720441773
    },
    {
        "content": "<p>do you have a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> perhaps?</p>",
        "id": 449854688,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1720441812
    },
    {
        "content": "<p>E.g., this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Lattice</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>",
        "id": 449854982,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1720441918
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span>  You're right, Lean is perfectly able to infer <code>Preorder a</code> for <code>Set a</code>, but I want to consider <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mtext>Set a</mtext><mo separator=\"true\">,</mo><mo>⊇</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\text{Set a}, \\supseteq)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">Set a</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊇</span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mclose\">)</span></span></span></span> (not <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mtext>Set a</mtext><mo separator=\"true\">,</mo><mo>⊆</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\text{Set a}, \\subseteq)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">Set a</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mclose\">)</span></span></span></span>).</p>",
        "id": 449855451,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1720442060
    },
    {
        "content": "<p>Ah, maybe something something <code>OrderDual</code>?</p>",
        "id": 449855943,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1720442164
    },
    {
        "content": "<p><code>(Set \\alpha)^\\od</code></p>",
        "id": 449856079,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1720442202
    },
    {
        "content": "<p>I need to give <code>\\alpha^\\od</code> as an explicit argument to <code>GaloisConnection</code>, but then I also need to give a term of type <code>Preorder a</code> and I can't give <code>OrderDual.instCompleteAtomicBooleanAlgebra</code>.</p>",
        "id": 449857116,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1720442443
    },
    {
        "content": "<p>right, because a preorder on <code>Set a</code> is not a preorder on <code>a</code>. you could try <code>inferInstance</code> as an argument and see if it works?</p>",
        "id": 449858915,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1720442829
    },
    {
        "content": "<p>also, i think a pattern like <code>(@GaloisConnection a^\\od) l u</code> should compile, making lean find the argument itself. i.e, you can stop specifying inferred arguments at any point, and continue with the explicit ones.</p>",
        "id": 449859909,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1720443009
    },
    {
        "content": "<p>also, you can write <code>GaloisConnection (α:= αᵒᵈ)</code></p>",
        "id": 449861092,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1720443210
    },
    {
        "content": "<p>Sorry, I got confused, <code>@GaloisConnection (Set α) ((Set β)^\\od) _ _ arg1 arg2</code> works fine and this is what I want. Thank you, all.</p>",
        "id": 449861205,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1720443233
    },
    {
        "content": "<p>As <span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> mentioned, this is more ergonomic </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">GaloisConnection</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵈ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">arg1</span><span class=\"w\"> </span><span class=\"n\">arg2</span>\n</code></pre></div>\n<p>and generally preferred</p>",
        "id": 449864120,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1720444044
    },
    {
        "content": "<p>You shouldn't have to pass alpha and beta at all</p>",
        "id": 449864358,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720444120
    },
    {
        "content": "<p>If you need to pass them, then <code>arg1</code> and <code>arg2</code> have the wrong types</p>",
        "id": 449864402,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720444136
    },
    {
        "content": "<p>My point was stylistic.</p>",
        "id": 449865137,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1720444356
    },
    {
        "content": "<p>You should add <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderDual.toDual#doc\">docs#OrderDual.toDual</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderDual.ofDual#doc\">docs#OrderDual.ofDual</a> to your functions to make them have correct types</p>",
        "id": 449882969,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1720448365
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/partial.20order.20on.20powerset/near/449864120\">said</a>:</p>\n<blockquote>\n<p>As <span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> mentioned, this is more ergonomic </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">GaloisConnection</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵈ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">arg1</span><span class=\"w\"> </span><span class=\"n\">arg2</span>\n</code></pre></div>\n<p>and generally preferred</p>\n</blockquote>\n<p>Good to know!</p>",
        "id": 449886180,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1720449269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/partial.20order.20on.20powerset/near/449864402\">said</a>:</p>\n<blockquote>\n<p>If you need to pass them, then <code>arg1</code> and <code>arg2</code> have the wrong types</p>\n</blockquote>\n<p>Got it!</p>",
        "id": 449886311,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1720449297
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/partial.20order.20on.20powerset/near/449854525\">said</a>:</p>\n<blockquote>\n<p>generally, lean should be able to infer that by itself...<br>\nif <code>#synth CompleteAtomicBooleanAlgebra (Set a)</code> works, lean figures out the rest. is there a reason why you're asking?</p>\n</blockquote>\n<p>Is this <code>#synth</code> command documented?</p>",
        "id": 450079739,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1720508153
    },
    {
        "content": "<p>My understanding is that it was meant to be a debugging tool very early on.  However, it proved to be so useful that it was kept, but still maintained its status of for-internal-use-even-though-everyone-uses-it.</p>",
        "id": 450095284,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1720512419
    },
    {
        "content": "<p>Using it is very easy, though: <code>#synth whatever</code> gets the typeclass system working to see if it can come up with a <code>whatever</code> instance!  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 450095609,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1720512498
    },
    {
        "content": "<p>If you don't like it, you could alternatively use <code>#check (inferInstance : whatever)</code>, which should have a similar effect</p>",
        "id": 450095770,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1720512549
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/partial.20order.20on.20powerset/near/450095770\">said</a>:</p>\n<blockquote>\n<p>If you don't like it, you could alternatively use <code>#check (inferInstance : whatever)</code>, which should have a similar effect</p>\n</blockquote>\n<p>Would this give you the lemma that gives you the instance?</p>",
        "id": 450096002,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1720512608
    },
    {
        "content": "<p>that's a fair point, it doesn't...</p>",
        "id": 450096311,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1720512710
    },
    {
        "content": "<p>or actually, it does?</p>",
        "id": 450096570,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1720512798
    },
    {
        "content": "<p>I am suspicious of <code>inferInstance</code>: I think that it hides the information of which lemma it used.</p>",
        "id": 450096626,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1720512826
    },
    {
        "content": "<p>it takes a bit extra though... you can click on <code>inferInstance</code> in the infoview to expand the arguments, which then shows you the lemmas used</p>",
        "id": 450096757,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1720512862
    },
    {
        "content": "<p>Ah, yes, nice trick!</p>",
        "id": 450097197,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1720513010
    },
    {
        "content": "<p>honestly, i can't think of a reason to use <code>#check</code> with <code>inferInstance</code> over <code>#synth</code> in this case though. i just wanted to mention that it is an alternative.</p>",
        "id": 450097215,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1720513016
    },
    {
        "content": "<p>I personally really like <code>#synth</code>.</p>",
        "id": 450097282,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1720513043
    },
    {
        "content": "<p>I really missed #synth in Lean 3 so was very pleased when it filled the much-needed gap in Lean 4; however as Edward is pointing out, Lean 4 has so many other goodies that it's now a bit easier to get away without it :-)</p>",
        "id": 450169998,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1720531003
    },
    {
        "content": "<p>I would love for <code>#synth</code> to display the whole tree of instances it found, not just the first step.</p>",
        "id": 450190526,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1720536283
    },
    {
        "content": "<p>Yes, many's the time I've typed <code>#synth bar</code> only to be told <code>Foo.toBar</code> and then I have to <code>#synth foo</code></p>",
        "id": 450197426,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1720538161
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/partial.20order.20on.20powerset/near/450190526\">said</a>:</p>\n<blockquote>\n<p>I would love for <code>#synth</code> to display the whole tree of instances it found, not just the first step.</p>\n</blockquote>\n<p>Oh, that may not be hard to implement...</p>",
        "id": 450211384,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1720540913
    },
    {
        "content": "<p>I think <code>#synth</code> already does this? <code>#instances</code> only does the first step, but <code>#synth</code> does the whole inference. However only the first step will usually be visible because most instances are written with square bracket hypotheses, and these are hidden in the standard pretty printing settings. Perhaps the pretty printer should treat <code>[]</code> arguments as explicit for pretty printing purposes when the root node is an instance?</p>",
        "id": 450569863,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1720647039
    },
    {
        "content": "<p>Or should have an option to do this.</p>",
        "id": 450607049,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1720663406
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/partial.20order.20on.20powerset/near/449882969\">said</a>:</p>\n<blockquote>\n<p>You should add <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderDual.toDual#doc\">docs#OrderDual.toDual</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderDual.ofDual#doc\">docs#OrderDual.ofDual</a> to your functions to make them have correct types</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> , do you mean I should write the following? </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">leftAdjMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">toDual</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>(resp.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">rightAdjMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵈ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ofDual</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>)<br>\nInstead of something like </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">leftAdjMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵈ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>(resp.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">rightAdjMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵈ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>)<br>\nconsidering the fact I want <code>leftAdjMap</code> (resp. <code>rightAdjMap</code>) to have type <code>Set α \\r (Set β)ᵒᵈ</code> (resp. <code>(Set β)ᵒᵈ \\r  </code>Set α).</p>",
        "id": 451996589,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1721206670
    },
    {
        "content": "<p>You should write both the expected return type and the ofDual / toDuals</p>",
        "id": 452026256,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721212910
    },
    {
        "content": "<p>The return type alone is enough to make the GaloisInsertion have the right type, but your proofs will be awkward when you unfold the definition without the casting functions</p>",
        "id": 452026487,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721212965
    }
]