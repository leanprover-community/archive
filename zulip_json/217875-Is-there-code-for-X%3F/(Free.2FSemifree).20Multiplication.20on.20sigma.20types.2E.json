[
    {
        "content": "<p>Here's a notion.</p>\n<p>Suppose I have  <code>β : ℕ → Type u</code> such that I have an instance <code>HMul (β n) (β n) (β (n + 1))</code> for all n. Consider <code>Sigma β</code>. I could define a free semigroup on this with <code>FreeSemiGroup (Sigma β)</code>. Is it possible to define \"the free semigroup on <code>Sigma β</code>, respecting the <code>HMul</code> on the <code>β n</code>\" - i.e. if I have (n, a) and (n, b) in <code>Sigma β</code>, then in this \"semi-free semigroup\" their product will be (n + 1, a*b), but if I also have <code>(m, c)</code>, then <code>(n, a)*(m, c)*(n, b)</code> won't interact unless <code>m = n</code>.</p>",
        "id": 483469105,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1732104601
    },
    {
        "content": "<p>This feels like a <em>reasonably</em> natural definition but if it exists I can't find it - is there a better way to do things like this?</p>",
        "id": 483469238,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1732104633
    },
    {
        "content": "<p>Effectively I want to lift the set of hetrogenous multiplications on the <code>β n</code> into one (associative) multiplication on <code>Sigma β</code>.</p>",
        "id": 483469734,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1732104816
    },
    {
        "content": "<p>What do you mean by \"won't interact\"?</p>",
        "id": 483472404,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732105775
    },
    {
        "content": "<p>As in a free multiplication, <code>(n, a)*(m, c)*(n, b)</code> simply \"has no meaning\" outside of what it is.</p>",
        "id": 483472554,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1732105817
    },
    {
        "content": "<p>It \"doesn't cancel down\" (I appreciate this language is imprecise).</p>",
        "id": 483472603,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1732105832
    },
    {
        "content": "<p>Ah, but crucially you also mean \"still type-checks\"!</p>",
        "id": 483472986,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732105963
    },
    {
        "content": "<p>Ah, yes, sorry - indeed!</p>",
        "id": 483473016,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1732105975
    },
    {
        "content": "<p>It's still a member of the type.</p>",
        "id": 483473049,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1732105984
    },
    {
        "content": "<p>Member? Do we say member for type? It typechecks, yes.</p>",
        "id": 483473083,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1732105999
    },
    {
        "content": "<p>I suppose ultimately this is a quotient by a suitable relation.</p>",
        "id": 483473228,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1732106048
    },
    {
        "content": "<p>Or something of that kind. I want <code>(n, a)*(n, b) ~ (n + 1, a*b)</code> and suchlike.</p>",
        "id": 483473305,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1732106086
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Monoid.CoprodI#doc\">docs#Monoid.CoprodI</a> looks somewhat related, though obviously doesn't use <code>HMul</code></p>",
        "id": 483475798,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732106860
    },
    {
        "content": "<p>No, nothing really seems to use HMul.</p>",
        "id": 483475890,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1732106882
    },
    {
        "content": "<p>Not sure about the transitivity of this relation.</p>",
        "id": 483488652,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1732110818
    }
]