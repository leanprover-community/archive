[
    {
        "content": "<p>I'm trying to prove some facts about the definition of <code>typein</code> on the order type of the ordinals.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">typein_ordinal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Also, why can't Lean find this instance?</span>\n<span class=\"w\">    </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IsWellOrder</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"n\">typein</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">lift</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 472933095,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1727367620
    },
    {
        "content": "<p>For future reference, this code works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">typein_ordinal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"c1\">-- TODO: Why can't Lean find this instance?</span>\n<span class=\"w\">    </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IsWellOrder</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"n\">typein</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">lift</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IsWellOrder</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">le_antisymm</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">by_contra!</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">enum</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"bp\">⟨</span><span class=\"n\">lift</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">typein_lt_type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">typein_enum</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lift_inj</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">        </span><span class=\"n\">conv_rhs</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">typein_enum</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lt_self_iff_false</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">conv_rhs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">enum_typein</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">enum_lt_enum</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">by_contra!</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"n\">lt_lift_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">o'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ho'₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ho'₂</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"n\">o'</span><span class=\"w\"> </span><span class=\"n\">ho'₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">typein_inj</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">ho'₁</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ho'₂</span><span class=\"bp\">.</span><span class=\"n\">ne</span><span class=\"w\"> </span><span class=\"n\">ho'₁</span>\n</code></pre></div>",
        "id": 473149910,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1727453345
    },
    {
        "content": "<p>This seems like something that should be in Mathlib. I couldn't find anything about <code>@typein Ordinal</code> or <code>@enum Ordinal</code>, which surprised me.</p>",
        "id": 473158992,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1727455847
    },
    {
        "content": "<p>I think this should be def-eq to <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/SetTheory/Ordinal/Arithmetic.html#Ordinal.type_subrel_lt\"><code>Ordinal.type_subrel_lt</code></a></p>",
        "id": 473159516,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1727455952
    },
    {
        "content": "<p>Ah, it is. Should that result be reformulated using <code>typein</code>?</p>",
        "id": 473160570,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1727456160
    },
    {
        "content": "<p>It should. I think <span class=\"user-mention\" data-user-id=\"565854\">@Nir Paz</span> has a PR renaming this theorem, so it might be a good idea to reformulate it while we're at it.</p>",
        "id": 473160784,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1727456192
    },
    {
        "content": "<p>It's <a href=\"https://github.com/leanprover-community/mathlib4/pull/16929\">#16929</a>. Should I reformulate it with the <code>haveI</code> and the TODO? It's really weird it doesn't synth</p>",
        "id": 473173193,
        "sender_full_name": "Nir Paz",
        "timestamp": 1727459796
    },
    {
        "content": "<p>Actually giving it <code>Ordinal.{u}</code> explicitly fixes it, even though when it fails to synth otherwise it looks like it filled in <code>Ordinal.{u}</code> itself.</p>",
        "id": 473173951,
        "sender_full_name": "Nir Paz",
        "timestamp": 1727459983
    },
    {
        "content": "<p>Changed it</p>",
        "id": 473180441,
        "sender_full_name": "Nir Paz",
        "timestamp": 1727461221
    }
]