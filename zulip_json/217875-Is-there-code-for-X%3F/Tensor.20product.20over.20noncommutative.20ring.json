[
    {
        "content": "<p>Is there tensor product over noncommutative rings? <code>TensorProduct</code> requires <code>[CommRing R]</code> and so does <code>ModuleCat.monoidalCategory</code></p>",
        "id": 480720986,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1730813330
    },
    {
        "content": "<p>Can you be more precise? What are you tensoring and what isn't commutative? There are three types involved here</p>",
        "id": 480721872,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1730813615
    },
    {
        "content": "<p>I want <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M \\otimes_R N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is a left <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is a right <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> isn't necessarily commutative, which should be an abelian group</p>",
        "id": 480722286,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1730813749
    },
    {
        "content": "<p>I don't know how \"right <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module\" works in Lean either, I'm not familiar with the algebra side of Mathlib at all, hence the question :0</p>",
        "id": 480722394,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1730813771
    },
    {
        "content": "<p>My understanding is that if R isn't commutative then to make a right R-module you just make it a left R^op module. If you import mathlib and open TensorProduct does it Just Work? Sorry, not at a computer right now</p>",
        "id": 480722687,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1730813868
    },
    {
        "content": "<p>I see, but then R still isn't commutative so the <code>TensorProduct</code> doesn't work</p>",
        "id": 480722891,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1730813899
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs\">#docs4</a> TensorProduct</p>",
        "id": 480722910,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1730813908
    },
    {
        "content": "<p>how do you use this again</p>",
        "id": 480722944,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1730813917
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TensorProduct#doc\">docs4#TensorProduct</a></p>",
        "id": 480722970,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1730813930
    },
    {
        "content": "<p>It requires</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span><span class=\"w\"> </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">TensorProduct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u_4</span><span class=\"w\"> </span><span class=\"n\">u_5</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 480723013,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1730813944
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TensorProduct#doc\">docs#TensorProduct</a></p>",
        "id": 480723126,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1730813990
    },
    {
        "content": "<p>Huh, do we really not have this?</p>",
        "id": 480723781,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1730814185
    },
    {
        "content": "<p><span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span> i want to tensor over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> for non-commutative <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></p>",
        "id": 480724224,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1730814312
    },
    {
        "content": "<p>seems like a massive task to work on as well...</p>",
        "id": 480724297,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1730814333
    },
    {
        "content": "<p>Oh there is a draft PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/8638\">#8638</a>. <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> hello <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>",
        "id": 480724533,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1730814391
    },
    {
        "content": "<p>Oh I disagree -- sounds like a nice project! Just copy the commutative case and do 150 lines and then stop. You'll make the world a better place!</p>",
        "id": 480724664,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1730814427
    },
    {
        "content": "<p>You can just start by making NonCommTensorProduct and then do the refactor of TensorProduct later</p>",
        "id": 480724938,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1730814503
    },
    {
        "content": "<p>That's true, I guess the work is just copying the commutative case and mess around with stuff. But since there's a draft PR I'll wait for the (co)author and see if they're working on it <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>",
        "id": 480725114,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1730814555
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"579936\">Gareth Ma</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Tensor.20product.20over.20noncommutative.20ring/near/480724224\">said</a>:</p>\n<blockquote>\n<p><span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span> i want to tensor over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> for non-commutative <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></p>\n</blockquote>\n<p>Just to be sure, do you want to take the tensor product over <code>k[G]</code> (which is going to be a <code>k</code>-vector space), or take the tensor product over <code>k</code> and define a linear action of <code>G</code>? (These two are not the same. A certain formulation of the latter is in the file <code>Mathlib.RepresentationTheory.Action.Monoidal</code>.)</p>",
        "id": 480736987,
        "sender_full_name": "Joël Riou",
        "timestamp": 1730817915
    },
    {
        "content": "<p>It's the former, for e.g. induced representations</p>",
        "id": 480743221,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1730819465
    },
    {
        "content": "<p>If all you want is induced representations then you can just make them as something like functions from G to V (an H-rep) satisfying f(hg)=h.f(g) or whatever.</p>",
        "id": 480754780,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1730822758
    },
    {
        "content": "<p>Oh yeah, I don't think defining induced rep with this tensor product is \"natural\" anyways, but you want it as a theorem</p>",
        "id": 480755047,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1730822840
    },
    {
        "content": "<p>that the <code>(Rep.induced something something).\\rho.asModule</code> is isomorphic to the tensor product construction</p>",
        "id": 480755247,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1730822884
    },
    {
        "content": "<p>The nice thing about defining induced rep as a tensor product is that you get <a href=\"https://en.wikipedia.org/wiki/Frobenius_reciprocity#Module_theory\">Frobenius reciprocity</a> as a special case of  <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ModuleCat.extendRestrictScalarsAdj#doc\">docs#ModuleCat.extendRestrictScalarsAdj</a>, which is immediate from <code>uncurryEquiv</code> <a href=\"https://github.com/leanprover-community/mathlib4/blob/50bf8ebbc306bae0c21ecb3203b131455fa784a7/Mathlib/LinearAlgebra/TensorProduct.lean#L684\">here</a>. This adjunction has been a major motivation of my draft PR.</p>\n<p>Currently, TensorProduct uses R-action on both factors and require them be Modules, but the left factor should really be a R^mop-Module by mathematical convention. For a commutative ring R, R^mop and R are isomorphic rings by the identity map, and a R^mop-Module is the same as an R-Module. But for a noncommutative ring R, a R^mop-MulAction will not give rise to a R-MulAction.</p>\n<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/8638\">#8638</a> I changed TensorProduct to require R^mop-Module on left factor and generalized results when possible, and I plan to define the \"commutative tensor product\" that takes two R-Modules in another file, by making the left R-Module a R^mop-Module using commutativity. Note that this can't be a global instance, because there are existing R- and R^mop-Module instances on R itself defined for [Semiring R], which are propositionally but not definitionally equal for commutative R, because one is left multiplication and the other is right multiplication.</p>\n<p>The current state of <a href=\"https://github.com/leanprover-community/mathlib4/pull/8638\">#8638</a> is mostly my experiment to see which results generalize to the noncommutative setting and in which ways they generalize. The type of many declarations are changed (e.g. R-LinearMap is changed to R^mop-LinearMap), which will be disruptive downstream in Mathlib. I think a better approach is to create a new file TensorProduct.General, and put the generalized declarations under the TensorProduct.General namespace. In the current file TensorProduct.Basic, we don't add or remove declarations, but change the constructions / proofs to use the generalized declarations when possible. I might try to implement this this weekend.</p>\n<p>(Remark: If we relax [Module] to [SMul] in TensorProduct, we could avoid changing one of the R to R^mop, because a R^mop-SMul does give rise to a R-SMul, and if you make this a local/temporary instance, you can \"define the general/noncommutative tensor product in terms of the existing/commutative tensor product\", but I think this approach is mathematically dubious.)</p>",
        "id": 480821650,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1730853088
    },
    {
        "content": "<p>There was a very long thread about this in the past, which culminated in a refactor of <code>Algebra</code> to imply actions on both sides (so that we don't need separate types for tensor products of noncommutative algebras). The PR was mostly lost to the porting tide.</p>",
        "id": 480950261,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1730908437
    },
    {
        "content": "<p>(See <a class=\"stream-topic\" data-stream-id=\"116395\" href=\"/#narrow/channel/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products\">#maths &gt; left vs right modules in tensor products</a>  and <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Noncommutative.20ring.20things\">#mathlib4 &gt; Noncommutative ring things</a> )</p>",
        "id": 480970974,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1730915157
    },
    {
        "content": "<p>Here's a new idea: similar to semilinear maps, we can generalize TensorProduct to take a R-module M and a S-module N together with a RingHom σ from S to R^dma (defeq to R^mop with same ring structure). In this setting, the tensor-Hom adjunction becomes the correspondence between <code>M ⊗[σ] N →+ P</code> and <code>N →ₛₗ[σ] M →+ P</code>. One can take σ to be <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Ring/Equiv.html#RingEquiv.toOpposite\">RingEquiv.toOpposite</a> if R=S is commutative, or <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Ring/Equiv.html#RingEquiv.opOp\">RingEquiv.opOp</a> if R is S^mop. This generalized TensorProduct isn't quite symmetric in the two factors, and RingHomInvPair can be used to express the necessary condition for TensorProduct.comm ...</p>",
        "id": 481046429,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1730956323
    },
    {
        "content": "<p>Is there any precedent for doing this with <code>σ = star</code>?</p>",
        "id": 481077279,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1730971748
    },
    {
        "content": "<p>I think there is precedent when <code>\\sigma = Frob</code>.</p>",
        "id": 481110445,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1730983044
    }
]