[
    {
        "content": "<p>Hi, there is a result in math saying that: Let <code>R</code> be a commutative ring, the canonical map <code>R → R ⊗[ℤ] ℚ</code> is <code>r ↦ r ⊗[ℤ] (1 : ℚ)</code>. Its kernel is precisely the <code>ℤ</code>-torsion submodule of <code>R</code>, i.e. the elements annihilated by some nonzero integer. I was wondering that is there a theorem in Mathlib related to this result. Thanks in advance!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">TensorProduct</span><span class=\"w\"> </span><span class=\"n\">LinearMap</span><span class=\"w\"> </span><span class=\"n\">Submodule</span>\n\n<span class=\"c1\">-- Let R be any commutative ring.</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">The canonical `ℤ`-linear map from a ring `R` to `R ⊗[ℤ] ℚ`</span>\n<span class=\"sd\">that sends an element `r` to `r ⊗ 1`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">canonicalMapToTensorRat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℤ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℤ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"c1\">-- This is a curried form of the tensor product's universal bilinear map.</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">TensorProduct</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">The kernel of the canonical map `r ↦ r ⊗ 1` from a ring `R` to `R ⊗[ℤ] ℚ`</span>\n<span class=\"sd\">is precisely the `ℤ`-torsion submodule of `R`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">kernel_canonicalMapToTensorRat_eq_torsion</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">canonicalMapToTensorRat</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">torsion</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 543117542,
        "sender_full_name": "Wenrong Zou",
        "timestamp": 1759612835
    },
    {
        "content": "<p>you can generalise from ring to AddCommGrp</p>",
        "id": 543117797,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759613169
    },
    {
        "content": "<p>you can gneralise from (Z, Q, torsion) to any ring R with (R, non zero divisors, R-torsion)</p>",
        "id": 543117814,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759613197
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Kernel.20of.20a.20tensor.20product/near/543117814\">said</a>:</p>\n<blockquote>\n<p>you can gneralise from (Z, Q, torsion) to any ring R with (R, non zero divisors, R-torsion)</p>\n</blockquote>\n<p>I think it needs to be divisible by R</p>",
        "id": 543117884,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759613278
    },
    {
        "content": "<p>sorry i meant (Z, Q, torsion, AbGrp) to (R, Frac(R), R-torsion, R-Mod)</p>",
        "id": 543117914,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759613317
    },
    {
        "content": "<p>i forgot to say \"localize\"</p>",
        "id": 543117923,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759613328
    },
    {
        "content": "<p>Thank you for help!</p>",
        "id": 543146363,
        "sender_full_name": "Wenrong Zou",
        "timestamp": 1759652148
    },
    {
        "content": "<p>I formalized part of proof in the version of (Z, Q, torsion, AbGrp), but I cannot solve one sorry. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">TensorProduct</span><span class=\"w\"> </span><span class=\"n\">LinearMap</span><span class=\"w\"> </span><span class=\"n\">Submodule</span>\n\n<span class=\"c1\">-- Let R be any additive commutative group.</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">The canonical `ℤ`-linear map from a ring `R` to `R ⊗[ℤ] ℚ`</span>\n<span class=\"sd\">that sends an element `r` to `r ⊗ 1`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">canonicalMapToTensorRat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℤ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℤ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span>\n<span class=\"w\">      </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℤ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">map_add'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TensorProduct</span><span class=\"bp\">.</span><span class=\"n\">add_tmul</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">map_smul'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TensorProduct</span><span class=\"bp\">.</span><span class=\"n\">smul_tmul'</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">}</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">The kernel of the canonical map `r ↦ r ⊗ 1` from a ring `R` to `R ⊗[ℤ] ℚ`</span>\n<span class=\"sd\">is precisely the `ℤ`-torsion submodule of `R`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">kernel_canonicalMapToTensorRat_eq_torsion</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">canonicalMapToTensorRat</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">torsion</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mem_torsion_iff</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">canonicalMapToTensorRat</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">canonicalMapToTensorRat</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">aux</span>\n\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">canonicalMapToTensorRat</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mem_torsion_iff</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">    </span><span class=\"k\">calc</span>\n<span class=\"w\">      </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⊗ₜ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">smul_tmul</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">          </span><span class=\"k\">calc</span>\n<span class=\"w\">            </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">              </span><span class=\"n\">aesop</span>\n<span class=\"w\">            </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">              </span><span class=\"n\">simp</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">aux</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">one_div</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">zero_tmul</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 543147819,
        "sender_full_name": "Wenrong Zou",
        "timestamp": 1759653870
    },
    {
        "content": "<p>Try the contrapositive</p>",
        "id": 543152975,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759660198
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"641254\">Wenrong Zou</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Kernel.20of.20a.20tensor.20product/near/543147819\">said</a>:</p>\n<blockquote>\n<p>AbGrp</p>\n</blockquote>\n<p>your code still says CommRing</p>",
        "id": 543153054,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759660270
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Kernel.20of.20a.20tensor.20product/near/543153054\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"641254\">Wenrong Zou</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Kernel.20of.20a.20tensor.20product/near/543147819\">said</a>:</p>\n<blockquote>\n<p>AbGrp</p>\n</blockquote>\n<p>your code still says CommRing</p>\n</blockquote>\n<p>Here, I want to use CommRing is because I also want to say the ring characteristics of </p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>R</mi><msub><mo>⊗</mo><mi mathvariant=\"double-struck\">Z</mi></msub><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">R \\otimes_{\\mathbb{Z}} \\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3322em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathbb mtight\">Z</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8556em;vertical-align:-0.1667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span></span></p>\n<p>is zero. We cannot define ringChar for R is AbGrp.</p>",
        "id": 543154041,
        "sender_full_name": "Wenrong Zou",
        "timestamp": 1759661603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Kernel.20of.20a.20tensor.20product/near/543152975\">said</a>:</p>\n<blockquote>\n<p>Try the contrapositive</p>\n</blockquote>\n<p>Thanks. I will try it.</p>",
        "id": 543154106,
        "sender_full_name": "Wenrong Zou",
        "timestamp": 1759661703
    },
    {
        "content": "<p>Just a remark that people will likely be tempted to request the analogous result in the context of an arbitrary <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsLocalization#doc\">docs#IsLocalization</a> (your case will then follow from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Rat.IsFractionRing#doc\">docs#Rat.IsFractionRing</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instIsLocalizationIntPosRat#doc\">docs#instIsLocalizationIntPosRat</a>).</p>",
        "id": 543165833,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1759673973
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Kernel.20of.20a.20tensor.20product/near/543165833\">said</a>:</p>\n<blockquote>\n<p>Just a remark that people will likely be tempted to request the analogous result in the context of an arbitrary <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsLocalization#doc\">docs#IsLocalization</a> (your case will then follow from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Rat.IsFractionRing#doc\">docs#Rat.IsFractionRing</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instIsLocalizationIntPosRat#doc\">docs#instIsLocalizationIntPosRat</a>).</p>\n</blockquote>\n<p>Thank you for your help! Using localization to describe it will be much better. Thanks.</p>",
        "id": 543167170,
        "sender_full_name": "Wenrong Zou",
        "timestamp": 1759675285
    }
]