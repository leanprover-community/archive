[
    {
        "content": "<p>Hi, I have the data</p>\n<blockquote>\n<p>l : List \\Nat<br>\nf: \\Nat \\to \\Nat</p>\n</blockquote>\n<p>and I want to prove</p>\n<blockquote>\n<p>List.sum (<a href=\"http://List.map\">List.map</a> f l) = \\sum i in range (List.length l), f l[i]</p>\n</blockquote>\n<p>Surely this is already in the library?  I can't use List.sum_toFinset because I don't know that l has no duplicates.  Presumably one needs to first show either</p>\n<blockquote>\n<p>List.sum l = \\sum i in range (List.length l), l[i]</p>\n</blockquote>\n<p>or</p>\n<blockquote>\n<p>l = <a href=\"http://List.map\">List.map</a> (fun i =&gt; l[i]) (range (List.length l))</p>\n</blockquote>\n<p>but again I can't find either of these statements in the library.</p>",
        "id": 396774273,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697393646
    },
    {
        "content": "<p>Do you want this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.FinRange</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sum_map_comp_get_finRange</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">List.sum</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">l.get</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">List.finRange</span> <span class=\"n\">l.length</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n    <span class=\"n\">List.sum</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"n\">f</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">List.map_map</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>PS: I found out later that much shorter proof (than I first thought) was possible.</p>",
        "id": 396774748,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1697394155
    },
    {
        "content": "<p>Well strictly speaking I would prefer Finset.sum (Finset.range l.length) (fun i =&gt; f (l.get i))  but i can probably use what you wrote also (because I think I see how to use List.sum_toFinset to get from one to the other)</p>",
        "id": 396775055,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697394504
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> for how to quote code on Zulip, by the way. And by far the best way to ask a question is to post fully working Lean code and to ask \"how do I fill in this sorry\" (otherwise different people might have different interpretations of what your question actually is, as we just saw).</p>",
        "id": 396775240,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697394720
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> Don't worry; I'll MWE it for you.</p>",
        "id": 396775354,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1697394818
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> (Nat -&gt; Finset (Fin ?a))</p>",
        "id": 396775429,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1697394882
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Finset/Image.html#Finset.fin\">Finset.fin</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/Composition.html#Composition.boundaries\">Composition.boundaries</a>, and <a href=\"https://loogle.lean-lang.org/?q=%28Nat%20-%3E%20Finset%20%28Fin%20%3Fa%29%29\">3 more</a></p>",
        "id": 396775431,
        "sender_full_name": "loogle",
        "timestamp": 1697394883
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.univ#doc\">docs#Finset.univ</a></p>",
        "id": 396775642,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1697395096
    },
    {
        "content": "<p>And I would <em>definitely</em> recommend asking the question you _want_ to be answered, rather than some intermediate question which you believe should suffice to answer the question you want to be answered. 99 times out of 100 you don't prove results about finsets by first proving results about lists (unless it's 2017 and you're writing <code>Mathlib.Data.Finset.Basic</code>). The API for finsets should be solid.</p>",
        "id": 396775914,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697395405
    },
    {
        "content": "<p>OK I will try to write a sorry for what I actually want, which is to enumerate a sum over a multiset as a sum over a range instead.  Here it goes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.BigOperators.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Multiset.Basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Multiset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">),</span> <span class=\"n\">Multiset.sum</span> <span class=\"o\">(</span><span class=\"n\">Multiset.map</span> <span class=\"n\">f</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Finset.sum</span> <span class=\"o\">(</span><span class=\"n\">Finset.range</span> <span class=\"o\">(</span><span class=\"n\">Multiset.card</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 396776190,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697395689
    },
    {
        "content": "<p>At any rate, here are two variants of what you might need:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.BigOperators.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.FinRange</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">List</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sum_map_get</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">finRange</span> <span class=\"n\">l.length</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">l.get</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"bp\">=</span> <span class=\"n\">l.sum</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">length_cons</span><span class=\"o\">,</span> <span class=\"n\">finRange_succ_eq_map</span><span class=\"o\">,</span> <span class=\"n\">map_cons</span><span class=\"o\">,</span> <span class=\"n\">get_cons_zero</span><span class=\"o\">,</span> <span class=\"n\">map_map</span><span class=\"o\">,</span>\n      <span class=\"n\">sum_cons</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">sum_map_get</span> <span class=\"n\">l</span><span class=\"o\">]</span>\n    <span class=\"n\">congr</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sum_map_comp_get</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n     <span class=\"bp\">∀</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">finRange</span> <span class=\"n\">l.length</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">l.get</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">l.map</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"o\">::</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">length_cons</span><span class=\"o\">,</span> <span class=\"n\">finRange_succ_eq_map</span><span class=\"o\">,</span> <span class=\"n\">map_cons</span><span class=\"o\">,</span> <span class=\"n\">get_cons_zero</span><span class=\"o\">,</span> <span class=\"n\">map_map</span><span class=\"o\">,</span>\n      <span class=\"n\">sum_cons</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">sum_map_comp_get</span> <span class=\"n\">f</span> <span class=\"n\">l</span><span class=\"o\">]</span>\n    <span class=\"n\">congr</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">List</span>\n</code></pre></div>",
        "id": 396776314,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1697395853
    },
    {
        "content": "<p>But I'll wait for your actual question to come before claiming it is really what you need <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 396776336,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1697395893
    },
    {
        "content": "<p>OK I just edited my previous comment with what I actually need.</p>",
        "id": 396776413,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697395966
    },
    {
        "content": "<p>Actually, this sounds like a weird intermediate lemma, which makes me think you took a wrong turn somewhere. What's the lemma you are trying to prove with this?</p>",
        "id": 396776577,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1697396162
    },
    {
        "content": "<p>I want to show that a monic polynomial of degree n over the complex numbers can be expressed as <code>\\prod i in range n, Polynomial.X - Polynomial.C( z i )</code> for some function <code>z: \\Nat \\to \\C</code>.  <code>Polynomial.eq_prod_roots_of_splits</code> gets me a factorization over a multiset but I wanted a product over range n instead.</p>",
        "id": 396776830,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697396410
    },
    {
        "content": "<p>Why do you care that it's indexed by <code>ℕ</code>, or by <code>range n</code>?</p>",
        "id": 396776872,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1697396457
    },
    {
        "content": "<p>In combinatorics, we learned long ago that formalisation was much less painful if we considered our finite sets to be unordered, rather than indexing them by 0, ..., n - 1.</p>",
        "id": 396776970,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1697396542
    },
    {
        "content": "<p>I'm using this fact to study elementary symmetric polynomials in n variables.  Basically, I want to show that the coefficients of such a monic polynomial arise as elementary symmetric polynomials of n numbers</p>",
        "id": 396776976,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697396551
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 396777018,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1697396596
    },
    {
        "content": "<p>Yes, precisely! Your end result does not mention indices, but your proof introduces them. I'm not claiming it is unnecessary, but I'm saying you should be suspicious of that.</p>",
        "id": 396777045,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1697396641
    },
    {
        "content": "<p>I'm inducting on n at some point.  In principle I could do this using a more abstract labeling of the n variables than <code>range n</code>, but it seems slightly more convenient to use the standard labels here.  (I also decided to artificially extend the label set to the entire natural numbers because it then makes the induction on n a bit easier.)</p>",
        "id": 396777149,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697396761
    },
    {
        "content": "<p>I'm betting that a much better induction principle here will be to induct on some indexing finset instead of inducting on its size <code>n</code>.</p>",
        "id": 396777304,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1697396905
    },
    {
        "content": "<p>Here's the lemma you asked for, but beware of what I told you: Ordering is evil but finset induction is your friend...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.BigOperators.Basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Multiset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">Multiset.sum</span> <span class=\"o\">(</span><span class=\"n\">Multiset.map</span> <span class=\"n\">f</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n      <span class=\"n\">Finset.sum</span> <span class=\"o\">(</span><span class=\"n\">Finset.range</span> <span class=\"o\">(</span><span class=\"n\">Multiset.card</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">A</span> <span class=\"n\">using</span> <span class=\"n\">Multiset.induction</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">A</span> <span class=\"n\">ih</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ih</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">Function.update</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">Multiset.card</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Multiset.map_cons</span><span class=\"o\">,</span> <span class=\"n\">Multiset.sum_cons</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">Multiset.card_cons</span><span class=\"o\">,</span> <span class=\"n\">Finset.range_succ</span><span class=\"o\">,</span>\n      <span class=\"n\">Finset.mem_range</span><span class=\"o\">,</span> <span class=\"n\">lt_self_iff_false</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">not_false_eq_true</span><span class=\"o\">,</span> <span class=\"n\">Finset.sum_insert</span><span class=\"o\">,</span>\n      <span class=\"n\">Function.update_same</span><span class=\"o\">,</span> <span class=\"n\">add_right_inj</span><span class=\"o\">]</span>\n    <span class=\"n\">refine</span> <span class=\"n\">Finset.sum_congr</span> <span class=\"n\">rfl</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Function.update_noteq</span> <span class=\"o\">(</span><span class=\"n\">Finset.mem_range.1</span> <span class=\"n\">hx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 396777340,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1697396958
    },
    {
        "content": "<p>More concretely, I would be very happy for you to point me where exactly you think you need <em>ordered</em> indices in your code.</p>",
        "id": 396777474,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1697397106
    },
    {
        "content": "<p>I guess I don't actually use the ordering, other than to add or remove the final variable in the ordered set of zeroes when I do induction on n.  On the other hand I've already written several hundred lines of code with the zeroes enumerated by natural numbers, so it would be easier for me just to use the code you just provided.  </p>\n<p>Actually now that I look at it I also see an alternate route to getting what I want that fits with the notation I already have in place (namely, a fundamental theorem of algebra where the linear factors are indexed by natural numbers), which is just to induct on degree and use the fact that every polynomial has at least one root, rather than use the library-provided splitting into a product over a multiset.  Anyway, I have a number of options on how to proceed now and I think one of them will work for me.  Thanks to everyone for your help!</p>",
        "id": 396777981,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697397670
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Summing.20over.20a.20list.20with.20duplicates/near/396776970\">said</a>:</p>\n<blockquote>\n<p>In combinatorics, we learned long ago that formalisation was much less painful if we considered our finite sets to be unordered, rather than indexing them by 0, ..., n - 1.</p>\n</blockquote>\n<p>I just want to really emphasise this point, and add that this was talked about in more detail in Yaël and I's paper on formalising the regularity lemma, as well as in the Isabelle paper on the same topic, but has been mentioned outside of the context of formalisation too!</p>",
        "id": 396778476,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1697398293
    },
    {
        "content": "<p>I will say though that regardless of how natural and convenient it is to use \"non-evil\" notation in formalization, a large fraction of working mathematicians are much more comfortable with \"evil\" notation in practice, and the formal language should support both options.  For instance, the consider the following two forms of the fundamental theorem of algebra:</p>\n<p><strong>Theorem 1.</strong>  If $P(z)$ is a monic polynomial of degree $n$, then $P(z) = \\prod_{j=1}^n (z-z_j)$, where $z_1,\\dots,z_n$ are the roots of $P$ (counting multiplicity, and ordered arbitrarily).</p>\n<p><strong>Theorem 2.</strong>  If $P(z)$ is a monic polynomial of degree $n$, then $P(z) = \\prod_{w \\in R} (z-w)$, where $R$ is the multiset of roots of $P$ (which has cardinality $n$).</p>\n<p>I agree that Theorem 2 is the more natural, \"non-evil\" choice, and is the version that is currently in the mathlib.  But Theorem 1 is the form that most working mathematicians are familiar with, and many would prefer to work with that version, to the point where formalization may become more inconvenient for them if they were forced to only use Theorem 2 and not Theorem 1.  So there should be some support for making \"evil\" choices such as labeling a multiset, choosing a basis for a vector space, a local coordinate system for a manifold, and other operations that might not be strictly necessary for a proof but align better with actual mathematical practice by actual mathematicians.</p>",
        "id": 396778860,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697398738
    },
    {
        "content": "<p>With double dollars:</p>\n<p><strong>Theorem 1.</strong> If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(z)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">)</span></span></span></span> is a monic polynomial of degree <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>z</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msubsup><mo>∏</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo stretchy=\"false\">(</mo><mi>z</mi><mo>−</mo><msub><mi>z</mi><mi>j</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(z) = \\prod_{j=1}^n (z-z_j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2401em;vertical-align:-0.4358em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8043em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.044em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>z</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>z</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">z_1,\\dots,z_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.044em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.044em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> are the roots of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> (counting multiplicity, and ordered arbitrarily).</p>\n<p><strong>Theorem 2.</strong> If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(z)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">)</span></span></span></span> is a monic polynomial of degree <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>z</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mo>∏</mo><mrow><mi>w</mi><mo>∈</mo><mi>R</mi></mrow></msub><mo stretchy=\"false\">(</mo><mi>z</mi><mo>−</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(z) = \\prod_{w \\in R} (z-w)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0771em;vertical-align:-0.3271em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3271em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mclose\">)</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is the multiset of roots of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> (which has cardinality <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>).</p>",
        "id": 396778967,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1697398860
    },
    {
        "content": "<blockquote>\n<p>So there should be some support for making \"evil\" choices such as labeling a multiset, choosing a basis for a vector space, a local coordinate system for a manifold, and other operations that might not be strictly necessary for a proof but align better with actual mathematical practice by actual mathematicians.</p>\n</blockquote>\n<p>Agreed! We definitely do have support for labelling and ordering a multiset and choosing a basis for a vector space (I'm not personally certain about a local coordinate system), but it's not yet as convenient as it could be to use</p>",
        "id": 396779071,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1697398981
    },
    {
        "content": "<p>Fwiw, the fundamental theorem of symmetric polynomials is in <a href=\"https://github.com/leanprover-community/mathlib4/pull/6593\">#6593</a>. (If you're doing this mostly for practice, please disregard)</p>",
        "id": 396779160,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1697399070
    },
    {
        "content": "<p>I think it's also worth mentioning that there are times when picking an ordering with {0,...,n-1} is simply necessary, so that's another reason to have good support for it. (I agree with Yaël that it's probably not here, but I can also see that it's convenient in this case!)</p>",
        "id": 396779254,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1697399197
    },
    {
        "content": "<p>Yeah my formalization of a proof of the fundamental theorem of symmetric polynomials is such an example; an linear order on the variables is necessary to lexicographically linearly order the monomials. Rather than working with an order, I simply first prove the result for <code>Fin n</code> and then transfer to an arbitrary Fintype.</p>\n<p>I think <span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> probably need <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.coeff_eq_esymm_roots_of_card#doc\">docs#Polynomial.coeff_eq_esymm_roots_of_card</a> rather than the fundamental theorem though.</p>",
        "id": 396783135,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1697403853
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Summing.20over.20a.20list.20with.20duplicates/near/396783135\">said</a>:</p>\n<blockquote>\n<p>I think <span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> probably need <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.coeff_eq_esymm_roots_of_card#doc\">docs#Polynomial.coeff_eq_esymm_roots_of_card</a> rather than the fundamental theorem though.</p>\n</blockquote>\n<p>D'oh!  I already spent several hours proving Vieta's formula, didn't realize it was already in the library.  Ah well, no harm done, I guess.</p>",
        "id": 396783318,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697404101
    },
    {
        "content": "<p>It will probably be very interesting for you to compare your formalization with what was already there. It's a really good way to learn new tricks. Just as in ordinary math learning, it is more interesting to see the solution to an exercise after spending time thinking about it rather that looking at it immediately.</p>",
        "id": 396783963,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1697404922
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Summing.20over.20a.20list.20with.20duplicates/near/396778860\">said</a>:</p>\n<blockquote>\n<p>I will say though that regardless of how natural and convenient it is to use \"non-evil\" notation in formalization, a large fraction of working mathematicians are much more comfortable with \"evil\" notation in practice, and the formal language should support both options.  For instance, the consider the following two forms of the fundamental theorem of algebra:</p>\n</blockquote>\n<p>Maybe you are reading the word \"evil\" in a much stronger sense than what Yaël intended (as you can guess from his name, English is not his native language). Of course I agree that both forms should be supported. But I personally feel that being challenged on that kind of little detail is part of the pleasure of formalized mathematics. I certainly spend a lot less time numbering things on paper now. We mathematicians clearly have an habit of describing any finite collection of objects as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">x_1, \\dots, x_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> without considering whether imposing an order serves any purpose at all. And then the next sentence is often: \"up to reordering, we can assume...\" when there was no need to order anything anyway. I find it refreshing to think a bit about such habits, even if the final output is to mostly continue doing what we are used to do (and certainly nobody here will tell you how you should do mathematics...).</p>",
        "id": 396784342,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1697405447
    },
    {
        "content": "<p>Might I add (again) that we should be regularly documenting and disseminating insights like this one, gleaned from the act of formalization! I, for one, believe them to have actual mathematical content...</p>",
        "id": 396789409,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1697411383
    },
    {
        "content": "<p>I am trying now to work with multisets as suggested and am running into a <em>weird</em> problem regarding the DecidableEq type, of all things, which is preventing me from manipulating multiset expressions properly.</p>\n<p>It's hard to explain so let me mock up some code to illustrate the issue.  Here I am trying to give a slight reformulation of the product rule for polynomials:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.BigOperators.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Multiset.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.FinRange</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Polynomial.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Polynomial.Derivative</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Polynomial</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Multiset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Polynomial</span> <span class=\"n\">ℝ</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P'</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Polynomial</span> <span class=\"n\">ℝ</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">Polynomial</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"bp\">=</span> <span class=\"n\">Multiset.prod</span> <span class=\"o\">(</span><span class=\"n\">Multiset.map</span> <span class=\"n\">P</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">derivative</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">P'_i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">derivative</span> <span class=\"n\">Q</span> <span class=\"bp\">=</span> <span class=\"n\">Multiset.sum</span> <span class=\"o\">(</span><span class=\"n\">Multiset.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Multiset.prod</span> <span class=\"o\">(</span><span class=\"n\">Multiset.map</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">Multiset.erase</span> <span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">P'</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">derivative_prod</span><span class=\"o\">]</span>\n  <span class=\"n\">congr</span>\n  <span class=\"n\">funext</span> <span class=\"n\">i</span>\n  <span class=\"n\">congr</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The argument <em>almost</em> works, but at the end there is a mismatch between the <code>DecidableEq</code> type <code>Classical.propDecidable</code> (which Lean assigns to the expression <code>Multiset.erase A i</code> coming out of <code>derivative_prod</code> and the <code>DecidableEq</code> type <code>instDecidableEqNat</code> that <em>I</em> get assigned whenever I try to write down <code>Multiset.erase A i</code>.  What is going on, and how could I close the argument here?</p>",
        "id": 396792136,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697414411
    },
    {
        "content": "<p>This is an error in the statement of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.derivative_prod#doc\">docs#Polynomial.derivative_prod</a>, which is missing a <code>[DecidableEq ι]</code> argument</p>",
        "id": 396792356,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697414606
    },
    {
        "content": "<p>It seems using <code>congr!</code> rather than <code>congr</code> also fixes it.</p>",
        "id": 396792368,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1697414629
    },
    {
        "content": "<p>Okaay... that fixes the immediate issue, I guess.  I still don't understand why the DecidableEq types are assigned differently in different contexts, but maybe I don't need to understand in order to close the arguments.</p>",
        "id": 396792586,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697414829
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> Here's a post from <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> on this subject</p>\n<blockquote>\n<p>My short (and incomplete and opinionated) tutorial for mathematicians who don't want to learn much about decidability but still want to contribute to mathlib:</p>\n</blockquote>\n<p>which I find myself referring to often:<br>\n<a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260169891\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260169891</a></p>",
        "id": 396792698,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1697414942
    },
    {
        "content": "<p>(I am definitely one of said mathematicians!)</p>",
        "id": 396792722,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1697414972
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Summing.20over.20a.20list.20with.20duplicates/near/396792356\">said</a>:</p>\n<blockquote>\n<p>This is an error in the statement of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.derivative_prod#doc\">docs#Polynomial.derivative_prod</a>, which is missing a <code>[DecidableEq ι]</code> argument</p>\n</blockquote>\n<p>Fixed in <a href=\"https://github.com/leanprover-community/mathlib4/pull/7702\">#7702</a>!</p>",
        "id": 396792843,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697415066
    },
    {
        "content": "<p>Kyle's step two is missing the important \"complain on Zulip\", which sometimes makes the problem go away!</p>",
        "id": 396792936,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697415134
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Summing.20over.20a.20list.20with.20duplicates/near/396792698\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> Here's a post from <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> on this subject</p>\n<blockquote>\n<p>My short (and incomplete and opinionated) tutorial for mathematicians who don't want to learn much about decidability but still want to contribute to mathlib:</p>\n</blockquote>\n<p>which I find myself referring to often:<br>\n<a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260169891\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260169891</a></p>\n</blockquote>\n<p>Thanks, that is helpful.  Are these sorts of issues things that magically disappear if one adds in <code>open classical</code> at the beginning of the code? Because I am strongly tempted to do that just to not have to deal with these issues.</p>",
        "id": 396793159,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697415311
    },
    {
        "content": "<p>Unfortunately that can sometimes make the problem worse</p>",
        "id": 396793196,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697415339
    },
    {
        "content": "<p>(in particular, the reason you're running into trouble is because someone did that in mathlib, and my PR removes it)</p>",
        "id": 396793268,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697415378
    },
    {
        "content": "<p>But for personal lean code that is not intended to end up in the mathlib, is there a downside, assuming that I would be perfectly fine with a nonconstructive proof<br>\n?</p>",
        "id": 396793346,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697415468
    },
    {
        "content": "<p>If the proof compiles there is no downside for you. The downside is that you might cause more confusing errors in downstream proofs that leverage your lemmas</p>",
        "id": 396793404,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697415493
    },
    {
        "content": "<p>If only Mathlib were a purely classical library ...</p>",
        "id": 396793457,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697415560
    },
    {
        "content": "<p><code>congr!</code> as Heather suggests will probably get you out of those situations without too much pain</p>",
        "id": 396793468,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697415568
    },
    {
        "content": "<p>OK I will try that first.</p>",
        "id": 396793505,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697415599
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> has marked this topic as resolved.</p>",
        "id": 396935058,
        "sender_full_name": "Notification Bot",
        "timestamp": 1697472276
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> , just FYI, we generally avoid marking topics as resolved on Zulip because it doesn't serve much purpose, and in addition it has the unfortunate side effect of breaking all links to the thread. Unfortunately, we can't just disable the \"resolve topic\" feature.</p>",
        "id": 396939874,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697474327
    },
    {
        "content": "<p>The other way of viewing that information is \"never link to threads, only ever link to a specific message\". Linking to a thread is pretty useless anyway since it leads to the last message; but you almost never want that, because who knows what the last message will be when someone cllcks your link.</p>",
        "id": 396940086,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697474413
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252920\">Alex Kontorovich</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Summing.20over.20a.20list.20with.20duplicates/near/396789409\">said</a>:</p>\n<blockquote>\n<p>Might I add (again) that we should be regularly documenting and disseminating insights like this one, gleaned from the act of formalization! I, for one, believe them to have actual mathematical content...</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> maybe you should write a blog post about that?</p>",
        "id": 396940163,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697474450
    },
    {
        "content": "<p>Sorry, I misread, perhaps that should be directed at <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 396940322,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697474506
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Summing.20over.20a.20list.20with.20duplicates/near/396940163\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"252920\">Alex Kontorovich</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Summing.20over.20a.20list.20with.20duplicates/near/396789409\">said</a>:</p>\n<blockquote>\n<p>Might I add (again) that we should be regularly documenting and disseminating insights like this one, gleaned from the act of formalization! I, for one, believe them to have actual mathematical content...</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> maybe you should write a blog post about that?</p>\n</blockquote>\n<p>Yeah this might be useful, I think both Yaël and I find ourselves explaining this particular one very often, so it would be nice to have something concrete to point at.</p>",
        "id": 396941229,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1697474878
    }
]