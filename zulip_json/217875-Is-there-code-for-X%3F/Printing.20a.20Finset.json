[
    {
        "content": "<p>Hi,<br>\nI have started learning theorem proving in Lean as a part of my coursework. I have a type X which is an abbreviation to Lean.Name</p>\n<p>I also have a Finset X (Finset of type X), where Finset is as defined in Mathlib.Data.Basic.Finset</p>\n<p>I am looking for a method to print this finset, and send the contents of this finset to a out.txt file.</p>",
        "id": 540332328,
        "sender_full_name": "Dhruv Chaurasiya",
        "timestamp": 1758234216
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myFinset</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">image</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">myFinset</span>\n<span class=\"c1\">-- outputs: {0, 1, 4, 9, 16, 25, 36, 49, 64, 81}</span>\n</code></pre></div>",
        "id": 540332692,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758234299
    },
    {
        "content": "<p>but what are you doing with Lean.Name?</p>",
        "id": 540332776,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758234322
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IO.FS.withFile#doc\">docs#IO.FS.withFile</a> might be useful</p>",
        "id": 540332787,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758234325
    },
    {
        "content": "<p>The instances for printing a finset are all unsafe (you could sort it first but...)</p>",
        "id": 540333035,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758234372
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Printing.20a.20Finset/near/540332776\">said</a>:</p>\n<blockquote>\n<p>but what are you doing with Lean.Name?</p>\n</blockquote>\n<p>So for my task, i have some sets, say set1, set2, set3. These have different type of properties and the elements of set1 have some relation r1 with elements of set2, and r2 with elements of set3 and so on. </p>\n<p>For an example my Finset could be {\"uid\",\"sid\",\"cid\"} where uid is the name of set containings user_ids, sid and cid are defined similarly, and user with id1 follows some special properties,</p>",
        "id": 540336092,
        "sender_full_name": "Dhruv Chaurasiya",
        "timestamp": 1758235024
    },
    {
        "content": "<p>I wouldn't recommend doing metaprogramming when you're just starting out</p>",
        "id": 540339108,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758235927
    },
    {
        "content": "<p>just use the set <code>uid</code> instead of the name <code>\"uid\"</code></p>",
        "id": 540339173,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758235935
    },
    {
        "content": "<p>Can you please elaborate on the metaprogramming, and are you suggesting that I use a Set named uid and store all the user_id's there? I may not know all the Sets i have to create beforehand and also all their contents, like in between the execution I might have to introduce some extra Set because I got more information.</p>",
        "id": 540339838,
        "sender_full_name": "Dhruv Chaurasiya",
        "timestamp": 1758236112
    },
    {
        "content": "<p>can you give me more context? how are you storing the user ids? what is uid?</p>",
        "id": 540339912,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758236139
    },
    {
        "content": "<p>please don't use names like this</p>",
        "id": 540340637,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758236294
    },
    {
        "content": "<p>you can store a list of all the finsets instead</p>",
        "id": 540340652,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758236310
    },
    {
        "content": "<p>User Id is a generic example here.</p>\n<p>The problem statements goes like this.</p>\n<p>I will have some facts which are predicates.</p>\n<p>So a fact would look like A(set1,set2 ... set n), here A is a property which takes its input from set1 set2 ... set n.</p>\n<p>I would get these properties as inputs, for example A(a1,a2), where a1 belongs to set1 and a2 belongs to set2. The statement A(a1,a2) means a1 and a2 are related by property A.</p>\n<p>I can have a arbitrary numbers of these properties each having their different domain.</p>\n<p>Then I would be provided with some relations between these properties, like for an example A(a1) &lt;= B(a1,a2) for all a1.</p>\n<p>I have to create a lattice which represents all such relations.</p>",
        "id": 540341863,
        "sender_full_name": "Dhruv Chaurasiya",
        "timestamp": 1758236574
    },
    {
        "content": "<p>definitely don't need names for this</p>",
        "id": 540342325,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758236680
    },
    {
        "content": "<p>but depending on what kind of domain you allow this could be tricky</p>",
        "id": 540342456,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758236716
    },
    {
        "content": "<p>I don't know how you even learnt about Lean.Name, just don't use it</p>",
        "id": 540342529,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758236769
    },
    {
        "content": "<p>If you guys say so, there might be some other way to do it ,<br>\nIn my problem i would require a lattice structure and then some extra constraints on that lattice. Only inputs I would get is sets with all there elements, the predicates i mentioned (A(a1,a2)) and the relation between those predicates (A(a1) &lt;= B(a1,a2)).</p>\n<p>Then I have to prove some theorems related to them and construct some other structures on top of the lattice.</p>\n<p>I thought finsets would help me model these relationships. If you could suggest anything else, that would be appreciated</p>",
        "id": 540344356,
        "sender_full_name": "Dhruv Chaurasiya",
        "timestamp": 1758237482
    },
    {
        "content": "<p>what's the ordering?</p>",
        "id": 540344637,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758237545
    },
    {
        "content": "<p>sounds like some sort of presented lattice?</p>",
        "id": 540345380,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758237728
    },
    {
        "content": "<p>The ordering is not fixed, Let me give an example from my paper, say we have 3 properties U, A,P</p>\n<p>We have U(a1) &lt;= A(a1,b)  for all a1, where b is anything approved by the domain of A</p>\n<p>A(a1,b) &lt;= B(a2,b) for all b</p>\n<p>P(a1,b1) &lt;= P(a1,b1) for all a1</p>\n<p>We in our inputs would get all valid U(a1), A(a1,b1) and P(a1,b1).</p>\n<p>We have a top and bottom defined, so lub and glb are well defined.</p>\n<p>We have to construct the lattice for this scenario, and then I have some other properties to prove. My initial goal is to devise a method  which takes this rules as an input and  generates me a lattice structure which I could use later on. We could have any number  of such relations and any number of predicates.</p>",
        "id": 540347161,
        "sender_full_name": "Dhruv Chaurasiya",
        "timestamp": 1758238149
    },
    {
        "content": "<p>is the goal to construct the lattice?</p>",
        "id": 540348196,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758238377
    },
    {
        "content": "<p>what are your domains allowed to be</p>",
        "id": 540348353,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758238417
    },
    {
        "content": "<p>is the collection of allowed domains fixed throughout the construction</p>",
        "id": 540348549,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758238455
    },
    {
        "content": "<p>this sounds like some sort of presented lattice</p>",
        "id": 540348717,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758238497
    },
    {
        "content": "<p>Initial goal, yes. But it's step 1 for my work. Then I have some 10 lemmas I need to prove for a general lattice, and then 1 big theorem which has around 12 cases.</p>",
        "id": 540348740,
        "sender_full_name": "Dhruv Chaurasiya",
        "timestamp": 1758238502
    },
    {
        "content": "<p>Yes the domains are fixed once given.</p>",
        "id": 540348775,
        "sender_full_name": "Dhruv Chaurasiya",
        "timestamp": 1758238527
    },
    {
        "content": "<p>are these concrete properties</p>",
        "id": 540348931,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758238658
    },
    {
        "content": "<p>or are they more like signatures</p>",
        "id": 540348955,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758238683
    },
    {
        "content": "<p>Please elaborate on signatures?</p>",
        "id": 540349052,
        "sender_full_name": "Dhruv Chaurasiya",
        "timestamp": 1758238787
    },
    {
        "content": "<p>Like the form of a predicate without an actual predicate behind it <a href=\"https://ncatlab.org/nlab/show/signature+(in+logic)\">https://ncatlab.org/nlab/show/signature+(in+logic)</a></p>",
        "id": 540349258,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758239000
    },
    {
        "content": "<p>Maybe you could just say what you're doing</p>",
        "id": 540349461,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758239175
    },
    {
        "content": "<p>and I could look it up online</p>",
        "id": 540349467,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758239183
    },
    {
        "content": "<p>I am proving some results on secure information flow, it's a new work yet to be published. My supervisor asked me to formalize all the proofs using Lean before we go for publishing.</p>\n<p>And the properties are Signatures.</p>",
        "id": 540349788,
        "sender_full_name": "Dhruv Chaurasiya",
        "timestamp": 1758239432
    },
    {
        "content": "<p>knowing what I know right now I would suggest you have</p>\n<ul>\n<li>a type <code>ι</code> representing your types</li>\n<li>a type <code>Pred</code> representing your predicates</li>\n<li>a function <code>numArgs : Pred → Nat</code> giving the arity of each predicate</li>\n<li>a function <code>argTypes : (p : Pred) → Fin (numArgs p) → ι</code> giving the type of each argument</li>\n</ul>",
        "id": 540354570,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758243633
    },
    {
        "content": "<p>sounds good, i would try to implement this method. Thanks</p>",
        "id": 540355971,
        "sender_full_name": "Dhruv Chaurasiya",
        "timestamp": 1758244690
    }
]