[
    {
        "content": "<p>Do we have a version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=tsum_mul_tsum_of_summable_norm#doc\">docs#tsum_mul_tsum_of_summable_norm</a> for finite products.</p>\n<p>My use case is (roughly) to show <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∏</mo><mrow><mi>p</mi><mo>∣</mo><mi>n</mi></mrow></msub><mfrac><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>p</mi></mrow><mrow><mn>1</mn><mo>−</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>p</mi></mrow></mfrac><mo>=</mo><msub><mo>∑</mo><mrow><mi>r</mi><mi>a</mi><mi>d</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>r</mi><mi>a</mi><mi>d</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></msub><mfrac><mn>1</mn><mi>m</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\prod_{p\\mid n}\\frac{1/p}{1-1/p}=\\sum_{rad(m)=rad(n)} \\frac{1}{m}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.53em;vertical-align:-0.52em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2253em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span><span class=\"mrel mtight\">∣</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4747em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1/</span><span class=\"mord mathnormal mtight\">p</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1/</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.52em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.3198em;vertical-align:-0.4747em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2253em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal mtight\">a</span><span class=\"mord mathnormal mtight\">d</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">m</span><span class=\"mclose mtight\">)</span><span class=\"mrel mtight\">=</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal mtight\">a</span><span class=\"mord mathnormal mtight\">d</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4747em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>. For my application I only need a bound on this product, so I have a workaround of bounding <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>p</mi></mrow><mrow><mn>1</mn><mo>−</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>p</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{1/p}{1-1/p}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.53em;vertical-align:-0.52em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1/</span><span class=\"mord mathnormal mtight\">p</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1/</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.52em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> by a finite sum, but I suspect the infinite case will end up having a nicer proof.</p>",
        "id": 379524302,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1690553806
    },
    {
        "content": "<p>If you only have a finite product you should be using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.prod#doc\">docs#Finset.prod</a> rather than <code>tprod</code> and we have a wealth of lemmas for that.</p>",
        "id": 379525291,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690554003
    },
    {
        "content": "<p>I am! Maybe I should clarify that I expand <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>p</mi></mrow><mrow><mn>1</mn><mo>−</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>p</mi></mrow></mfrac><mo>=</mo><msub><mo>∑</mo><mrow><mi>m</mi><mo>≥</mo><mn>1</mn></mrow></msub><mfrac><mn>1</mn><msup><mi>p</mi><mi>m</mi></msup></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{1/p}{1-1/p} = \\sum_{m\\ge 1} \\frac{1}{p^m} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.53em;vertical-align:-0.52em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1/</span><span class=\"mord mathnormal mtight\">p</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1/</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.52em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.3262em;vertical-align:-0.4811em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mrel mtight\">≥</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3949em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5935em;\"><span style=\"top:-2.786em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4811em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>. I'm looking for a lemma about a <code>Finset.prod</code> of a <code>tsum</code>.</p>",
        "id": 379526331,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1690554185
    },
    {
        "content": "<p>Can you ask your question in lean by writing a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> with a <code>sorry</code> in ? This is by far the most efficient way of asking such a question.</p>",
        "id": 379526685,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690554246
    },
    {
        "content": "<p>I haven’t searched extensively, but it’s likely than we don’t have this lemma. Shouldn’t be too hard to add though.</p>",
        "id": 379526935,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690554291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/finite.20product.20of.20infinite.20sums/near/379526685\">zei</a>:</p>\n<blockquote>\n<p>Can you ask your question in lean by writing a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> with a <code>sorry</code> in ? This is by far the most efficient way of asking such a question.</p>\n</blockquote>\n<p>Something like this, though the assumptions might be off a little.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Normed.Field.InfiniteSum</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Normed.Group.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span> <span class=\"n\">Finset</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">prod_tsum_of_summable_norm</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span>  <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">NormedCommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">CompleteSpace</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Summable</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">‖</span><span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"bp\">‖</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Summable</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">‖∏</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s.attach</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">‖</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 379527521,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1690554383
    },
    {
        "content": "<p>You should add imports to the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> so that everything compiles <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 379527822,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690554436
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/finite.20product.20of.20infinite.20sums/near/379526935\">zei</a>:</p>\n<blockquote>\n<p>I haven’t searched extensively, but it’s likely than we don’t have this lemma. Shouldn’t be too hard to add though.</p>\n</blockquote>\n<p>But yeah, it should just follow by induction.</p>",
        "id": 379528314,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1690554531
    },
    {
        "content": "<p>Induction-ing your way back to <code>Prod</code>s is probably not the best way to deal with this, going from iterated binary product to Pi types will likely makes things more complicated</p>",
        "id": 379529937,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690554835
    },
    {
        "content": "<p>The cleanest way to do that, which will require quite a bit of work, would be to make a \"finite product\" API parallel to the \"binary product\" one, starting with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasSum.mul_eq#doc\">docs#HasSum.mul_eq</a>. We want these result anyway.</p>",
        "id": 379533496,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690555456
    },
    {
        "content": "<p>But I realize this does not fully solve the problem, and we can't avoid any induction at this first step. That said, I still think the inductive argument will be cleaner if you do not try to get back to an actual <code>Prod</code> type.</p>",
        "id": 379533963,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690555546
    },
    {
        "content": "<p>Do we have any version of the Fubini theorem (for measures/infinte sums/finite sums, I just want an example) for n-ary products?</p>",
        "id": 379534957,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690555719
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.prod_sum#doc\">docs#Finset.prod_sum</a> ?</p>",
        "id": 379535208,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1690555772
    },
    {
        "content": "<p>Indeed, thanks!</p>",
        "id": 379535431,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690555813
    },
    {
        "content": "<p>I haven't looked at it very closely, but maybe I should've stated the theorem in terms of Finset.pi rather than pi types.</p>",
        "id": 379535873,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1690555905
    },
    {
        "content": "<p>That doesn't work: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.pi#doc\">docs#Finset.pi</a> is the product of finsets as a finset, but the point is you want to sum over an infinite type.</p>",
        "id": 379536755,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690556062
    },
    {
        "content": "<p>I repeat my disclaimer.<br>\nAlso I haven't thought through all the consequences, but my guess would be that if you had an equivalence</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Basic</span>\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">insert_pi_equiv</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hj</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">j</span> <span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">j</span> <span class=\"bp\">×</span> <span class=\"o\">((</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>the inductive argument wouldn't be too bad. Maybe you'd run into trouble with subtypes, but <code>tsum</code> and <code>Summable</code> seem to interact very well with equivalences.</p>",
        "id": 379537333,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1690556166
    },
    {
        "content": "<p>Yes for sure you can make it work. I was thinking there has to be a clever way to avoid it, but since we have to <code>pi</code> option of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasSum.prod_fiberwise#doc\">docs#HasSum.prod_fiberwise</a> I'm getting pretty sure we actually need to get back to binary products.</p>",
        "id": 379539226,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690556502
    },
    {
        "content": "<p>As to how to build the desired bijection, you can have a look at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.Set.insert#doc\">docs#Equiv.Set.insert</a> and combine it with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.sumArrowEquivProdArrow#doc\">docs#Equiv.sumArrowEquivProdArrow</a></p>",
        "id": 379540993,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690556801
    },
    {
        "content": "<p>There's a general principle that's quite useful in a lot of elementary number theory: if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is multiplicative and supported on square-free numbers, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∏</mo><mrow><mi>p</mi><mo>∣</mo><mi>n</mi></mrow></msub><mrow><mo fence=\"true\">(</mo><mn>1</mn><mo>+</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>p</mi><mo stretchy=\"false\">)</mo><mo fence=\"true\">)</mo></mrow><mo>=</mo><msub><mo>∑</mo><mrow><mi>d</mi><mo>∣</mo><mi>n</mi></mrow></msub><mi>f</mi><mo stretchy=\"false\">(</mo><mi>d</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\prod_{p\\mid n}\\left(1+f(p)\\right) = \\sum_{d\\mid n}f(d)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2247em;vertical-align:-0.4747em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2253em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span><span class=\"mrel mtight\">∣</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4747em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">)</span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2247em;vertical-align:-0.4747em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2253em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">d</span><span class=\"mrel mtight\">∣</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4747em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">)</span></span></span></span>. I think it would be useful to develop API for this, if it doesn't exist already. (Or you could just ask that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> be multiplicative, and then restrict that identity to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> which are square-free...)</p>",
        "id": 379577022,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1690563761
    },
    {
        "content": "<p>I do have this result in my project, but there's one snag that arithmetic functions are defined to be 0 at 0, so products of that form aren't naturally arithmetic functions.</p>",
        "id": 379578476,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1690564082
    },
    {
        "content": "<p>You could of course just state it without making it an arithmetic function, and that's fine, but it would still be nice to be able to state the fact that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∏</mo><mrow><mi>p</mi><mo>∣</mo><mi>n</mi></mrow></msub><mi>f</mi><mo stretchy=\"false\">(</mo><mi>p</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\prod_{p\\mid n} f(p)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2247em;vertical-align:-0.4747em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2253em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span><span class=\"mrel mtight\">∣</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4747em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">)</span></span></span></span> is multiplicative for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>...</p>",
        "id": 379579006,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1690564200
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"585783\">Arend Mellendijk</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/finite.20product.20of.20infinite.20sums/near/379578476\">said</a>:</p>\n<blockquote>\n<p>I do have this result in my project, but there's one snag that arithmetic functions are defined to be 0 at 0, so products of that form aren't naturally arithmetic functions.</p>\n</blockquote>\n<p>Perhaps you're in luck: 1/0 is defined to be 0...?</p>",
        "id": 379579500,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1690564304
    },
    {
        "content": "<p>Sadly <code>Nat.factors 0 = []</code> and the empty product is one</p>",
        "id": 379579830,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1690564375
    },
    {
        "content": "<p>Argh, right. Yeah, the API will be quite annoying. Unless someone invests in API for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">N</mi><mo>+</mo></msub><mo>:</mo><mo>=</mo><mo stretchy=\"false\">{</mo><mi>n</mi><mo>:</mo><mi mathvariant=\"double-struck\">N</mi><mi mathvariant=\"normal\">/</mi><mi mathvariant=\"normal\">/</mi><mi>n</mi><mo mathvariant=\"normal\">≠</mo><mn>0</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\N_+:=\\{n : \\N // n \\neq 0\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8972em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2583em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mord\">//</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">}</span></span></span></span>, which perhaps is better for these applications anyway?...</p>",
        "id": 379580561,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1690564554
    },
    {
        "content": "<p><a href=\"https://github.com/FLDutchmann/selberg-sieve4/blob/f8f3c17a9349370fef01d9e8716681b138a095c9/SelbergSieve/ForArithmeticFunction.lean#L72\">here</a>'s what it would look like if you make that product into an arithmetic function, by the way.</p>",
        "id": 379580590,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1690564561
    },
    {
        "content": "<p>Either way you'd have to write a wrapper around that product to make it into an arithmetic function</p>",
        "id": 379580909,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1690564638
    },
    {
        "content": "<p>That said if you're not too invested in that product being an arithmetic function, I was going to PR that result quite soon, I've just been blocked by <a href=\"https://github.com/leanprover-community/mathlib4/pull/5798\">#5798</a></p>",
        "id": 379581758,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1690564811
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PNat#doc\">docs#PNat</a> and they are used when developing a theory of cyclotomic fields, because (similar to multiplicative functions) nobody could work out any kind of sensible answer to the question \"what are the 0th roots of unity?\". </p>\n<p>Another possibility, which I am coming round to, is that we have a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NeZero#doc\">docs#NeZero</a> typeclass which you can just attach to a natural number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> and now let typeclass inference do the work of checking that a product of nonzero numbers is nonzero etc.</p>",
        "id": 379584701,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690565461
    },
    {
        "content": "<p>What API for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PNat#doc\">docs#PNat</a> is missing?</p>",
        "id": 379584735,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1690565469
    },
    {
        "content": "<p>Do <code>ring</code> and <code>linarith</code> work on it?</p>",
        "id": 379584884,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690565508
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.PNat.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">PNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ring</span> <span class=\"c1\">-- nope</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">PNat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span> <span class=\"c1\">-- nope</span>\n</code></pre></div>\n<p>On the other hand do goals come up which need these tactics, or is it all about divisibility and products? The positive naturals are a free abelian monoid on the primes and so perhaps the 1 and multiplication are far more important than addition or inequalities.</p>",
        "id": 379585875,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690565694
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 379586233,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1690565750
    },
    {
        "content": "<p>I've definitely run into weird arithmeticy goals with pnat</p>",
        "id": 379586809,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1690565831
    },
    {
        "content": "<p>To be clear, the biggest thing I've run into with <code>ArithmeticFunction</code> is that I can't just state <code>IsMultiplicative fun n =&gt;  ∏ p in n.factors.toFinset, f p </code> because <code>ArithmeticFunction</code> is a type synonym for a zero-hom. By itself that isn't a massive problem, but then if you choose to define <code>prodDistinctFactors f : ArithmeticFunction R</code>, then you also want to phrase Alex's statement in terms of that new function, which is just quite ugly.</p>",
        "id": 379588768,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1690566140
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic\">said</a></p>\n<blockquote>\n<p>On the other hand do goals come up which need these tactics, or is it all about divisibility and products?</p>\n</blockquote>\n<p>If you're sifting out primes less than <code>y</code>, inequalities do come up.</p>",
        "id": 379589312,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1690566226
    },
    {
        "content": "<p>And in general a big thing about sieves is that they can get you to additive statements about the primes, so thinking about <code>PNat</code> as a monoid isn't very helpful there.</p>",
        "id": 379590903,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1690566466
    },
    {
        "content": "<p>The multiplicative function thing: you just send 0 to 0 in the definition (if x = 0 then 0 else actual definition), and then you make API using <code>if_neg</code> which means that whatever approach you use for positive naturals (PNat or NeZero) you'll never notice the \"if\" is there. The absence of ring and linarith is a worry -- you might want to ping an expert like <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> to ask whether <code>ring</code> or <code>linarith</code> are going to work on <code>PNat</code> any time soon -- and if the answer is \"no I've got a standard library to manage\" then I would go with <code>NeZero</code> and I suspect things will be fine.</p>",
        "id": 379592577,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690566750
    },
    {
        "content": "<p>Maybe the better objection to PNat is that there are a lot of sums over <code>Nat.divisors n</code>, so you would either have to duplicate all that api for <code>PNat</code> or write down a lot of <code>ne_zero_of_mem_divisors</code></p>",
        "id": 379596957,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1690567664
    },
    {
        "content": "<p>Well morally <code>Nat.divisors</code> should be for <code>PNat</code> anyway, right?</p>",
        "id": 379602437,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690569049
    },
    {
        "content": "<p><del> Ultimately the ring you are interested in is <code>MonoidAlgebra Complex PNat</code>, is that right? </del></p>",
        "id": 379602858,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690569152
    },
    {
        "content": "<p><del> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MonoidAlgebra#doc\">docs#MonoidAlgebra</a> </del></p>",
        "id": 379603046,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690569210
    },
    {
        "content": "<p>Ah no sorry because you don’t want restriction on the support <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span></p>",
        "id": 379603182,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690569243
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"585783\">Arend Mellendijk</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/finite.20product.20of.20infinite.20sums/near/379589312\">said</a>:</p>\n<blockquote>\n<p>If you're sifting out primes less than <code>y</code>, inequalities do come up.</p>\n</blockquote>\n<p>Oh you're doing the Selberg sieve, very nice! I'm not sure which exposition you're following, but in case you're interested, here is the treatment I prefer (written for Brun's theorem, that the sum of reciprocal twin primes converges, but it's practically the general setting...): <a href=\"https://sites.math.rutgers.edu/~alexk/files/BrunSelberg.pdf\">https://sites.math.rutgers.edu/~alexk/files/BrunSelberg.pdf</a></p>",
        "id": 379609507,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1690570835
    },
    {
        "content": "<p>Thanks! My original plan was actually to formalise Brun's theorem. I mostly followed Heath-Brown's exposition (<a href=\"https://arxiv.org/abs/math/0209360\">https://arxiv.org/abs/math/0209360</a>) with Koukoulopoulos' book as a reference, because they both give a general statement in elementary terms.</p>",
        "id": 379619980,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1690573469
    },
    {
        "content": "<blockquote>\n<p>you might want to ping an expert like <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> to ask whether <code>ring</code> or <code>linarith</code> are going to work on <code>PNat</code> any time soon -- and if the answer is \"no I've got a standard library to manage\"</p>\n</blockquote>\n<p>It's \"no, there are some technical issues with making it work or else it would have been done in the initial version\"</p>",
        "id": 379648390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1690583099
    },
    {
        "content": "<p>the short version is that it's not a semiring so most of the lemmas don't apply</p>",
        "id": 379648536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1690583154
    },
    {
        "content": "<p>TBH I'm surprised mathlib hasn't invented a quasi-positive-semiring or something for this yet</p>",
        "id": 379648646,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1690583191
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"585783\">Arend Mellendijk</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/finite.20product.20of.20infinite.20sums/near/379619980\">said</a>:</p>\n<blockquote>\n<p>Thanks! My original plan was actually to formalise Brun's theorem. I mostly followed Heath-Brown's exposition (<a href=\"https://arxiv.org/abs/math/0209360\">https://arxiv.org/abs/math/0209360</a>) with Koukoulopoulos' book as a reference, because they both give a general statement in elementary terms.</p>\n</blockquote>\n<p>Will you do the Fundamental Theorem of Sieve Theory? I.e. Iwaniec's theorem, which for bizarre historical reasons is termed the \"Rosser sieve\" in the literature... (eventually Henryk was so fed up with this, he started calling it the \"Beta Sieve\"...)</p>",
        "id": 379648744,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1690583242
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/finite.20product.20of.20infinite.20sums/near/379648646\">said</a>:</p>\n<blockquote>\n<p>TBH I'm surprised mathlib hasn't invented a quasi-positive-semiring or something for this yet</p>\n</blockquote>\n<p>Yeah we need <code>toadditive</code> on <code>NonUnital</code> stuff to make <code>NonZerotalSemiring</code> :-)</p>",
        "id": 379650709,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690584176
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252920\">Alex Kontorovich</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/finite.20product.20of.20infinite.20sums/near/379577022\">said</a>:</p>\n<blockquote>\n<p>There's a general principle that's quite useful in a lot of elementary number theory: if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is multiplicative and supported on square-free numbers, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∏</mo><mrow><mi>p</mi><mo>∣</mo><mi>n</mi></mrow></msub><mrow><mo fence=\"true\">(</mo><mn>1</mn><mo>+</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>p</mi><mo stretchy=\"false\">)</mo><mo fence=\"true\">)</mo></mrow><mo>=</mo><msub><mo>∑</mo><mrow><mi>d</mi><mo>∣</mo><mi>n</mi></mrow></msub><mi>f</mi><mo stretchy=\"false\">(</mo><mi>d</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\prod_{p\\mid n}\\left(1+f(p)\\right) = \\sum_{d\\mid n}f(d)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2247em;vertical-align:-0.4747em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2253em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span><span class=\"mrel mtight\">∣</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4747em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">)</span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2247em;vertical-align:-0.4747em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2253em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">d</span><span class=\"mrel mtight\">∣</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4747em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">)</span></span></span></span>. I think it would be useful to develop API for this, if it doesn't exist already. (Or you could just ask that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> be multiplicative, and then restrict that identity to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> which are square-free...)</p>\n</blockquote>\n<p>This is addressed in <a href=\"https://github.com/leanprover-community/mathlib4/pull/6662\">#6662</a> (in the second form, since I found it easier to work with completely multiplicative functions in my application)</p>",
        "id": 385917060,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1692366138
    }
]