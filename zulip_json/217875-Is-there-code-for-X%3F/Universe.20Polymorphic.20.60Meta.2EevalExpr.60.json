[
    {
        "content": "<p>Is there a universe-polymorphic version of the <code>MetaM</code> monad? I would like to use <code>Meta.evalExpr</code> on an <code>Expr</code> that lives in a higher universe level.</p>",
        "id": 530894966,
        "sender_full_name": "Paul Mure",
        "timestamp": 1753507401
    },
    {
        "content": "<p>Since you're already in unsafe, might as well use unsafeCast:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">HighUniverse</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">20</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hi</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">there</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">evalExpr</span><span class=\"w\"> </span><span class=\"n\">NonScalar</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">HighUniverse</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HighUniverse</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"n\">val</span>\n<span class=\"w\">  </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"This thing is: {repr val}\"</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">HighUniverse</span><span class=\"bp\">.</span><span class=\"n\">hi</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 530930134,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1753527728
    },
    {
        "content": "<p>I'm not sure unsafe means having a license to do anything unsafe ‚Äî¬†would you mind justifying why this unsafe cast is OK? Also, could you help us understand why <code>NonScalar</code> is the correct dummy type to use here?</p>\n<p>Is there any sort of API available to determine what dummy type to use?</p>",
        "id": 530962346,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1753543873
    },
    {
        "content": "<p>Yeah, you're right; <code>evalExpr</code> doesn't really care about the type you input so anything is fine that isn't a fixed width integer or a floating point value; <code>NonScalar</code> should work just as well as <code>Nat</code> or <code>Int</code> (just needs to be a <code>tobj</code>) but the intention is a bit clearer with <code>NonScalar</code>; then the <code>unsafeCast</code> is basically what <code>evalExpr</code> does anyways but explicitly.</p>",
        "id": 530970133,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1753547457
    },
    {
        "content": "<p>I take it that <code>NonScalar</code> works even though <code>HighUniverse</code> is represented by a <code>u8</code> because it's using the polymorphic <code>evalExpr</code>, which works with a boxed result?</p>",
        "id": 530970937,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1753547853
    },
    {
        "content": "<p>Yeah, equivalent code is produced whether you use <code>UInt8</code> or <code>NonScalar</code> and then apply the cast.</p>",
        "id": 530974518,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1753549561
    },
    {
        "content": "<p>The only thing you need to make sure is that it doesn't unbox the result, as when specifying <code>UInt8</code></p>",
        "id": 530974598,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1753549597
    },
    {
        "content": "<p>Is there any chance of <a href=\"https://github.com/leanprover/lean4/pull/3010\">lean4#3010</a> going through which would make it possible to build a manual version of a universe-polymorphic <code>MetaM</code> downstream without repeating absolutely everything?</p>",
        "id": 531119187,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753614866
    },
    {
        "content": "<p>Can you explain somewhere what this is about? Someone manually building a copy of MetaM downstream seems undesirable?</p>",
        "id": 531123991,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1753616710
    },
    {
        "content": "<p>Are you asking for this from Paul or me, or both?</p>",
        "id": 531130546,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753619153
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>, although anyone with a really important use case could answer! :-)</p>",
        "id": 531231635,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1753658364
    },
    {
        "content": "<p>Here's an argument for universe-polymorphic <code>IO</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MyInterface</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span>\n\n<span class=\"c1\">-- implementations</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyInterface</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyInterface</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">natAbs</span>\n<span class=\"w\">  </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"c1\">--wrapper type for polymorphism</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">MyInterface</span><span class=\"bp\">.</span><span class=\"n\">Bundled</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyInterface</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span>\n\n<span class=\"c1\">-- initial register handlers</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">initVal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MyInterface</span><span class=\"bp\">.</span><span class=\"n\">Bundled</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚ü®</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"bp\">‚ü©</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"bp\">‚ü©</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- doesn't work with IO.ref :(</span>\n<span class=\"n\">initialize</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MyInterface</span><span class=\"bp\">.</span><span class=\"n\">Bundled</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">initVal</span>\n</code></pre></div>",
        "id": 531232638,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753658797
    },
    {
        "content": "<p>My understanding is that the <code>MyInterface.Bundled</code> example there is a fairly common pattern (probably with bad names), and essentially implements the mechanism behind a C++ <code>vtable</code> and virtual methods</p>",
        "id": 531232721,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753658833
    },
    {
        "content": "<p>(we get a lot of users asking about heterogenous lists, and this is one of the strategies I've seen answered with)</p>",
        "id": 531234461,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753659580
    },
    {
        "content": "<p>I'm really hoping here for a bigger picture use case: i.e. some project or potential project that isn't happening or is significantly hobbled by this. I understand that some code doesn't compile with the current IO and MetaM. :-)</p>\n<p>The <code>vtable</code> pointer is helpful. But is this something that anyone in the Lean world is actually missing?</p>",
        "id": 531234506,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1753659600
    },
    {
        "content": "<p>Any such code can ultimately use unsafeCast so I think significant hobbling is not going to happen here.</p>",
        "id": 531234900,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753659761
    },
    {
        "content": "<p>I guess in that regard the example I give above can be solved with an <code>UnsafeUDrop x</code> type that puts something in lower universe, which I think I've seem somewhere.</p>",
        "id": 531234996,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753659801
    },
    {
        "content": "<p>(if someone remembers what I'm thinking of, we should add it to the docstring for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ULift#doc\">docs#ULift</a>)</p>",
        "id": 531235315,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753659928
    },
    {
        "content": "<p>Here's a prototype that is probably dangerous:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Squash any type to `Type 0` so that it can be used with IO. -/</span>\n<span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">USquash!</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">rawDown</span><span class=\"w\"> </span><span class=\"bp\">::</span>\n<span class=\"w\">    </span><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">rawUp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NonScalar</span>\n\n<span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">USquash!</span><span class=\"bp\">.</span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">USquash!</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">rawUp</span>\n<span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">USquash!</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">USquash!</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">USquash!</span><span class=\"bp\">.</span><span class=\"n\">rawDown</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(edit: as discussed at <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/universe.20polymorphic.20IO/near/290576618\">#lean4 &gt; universe polymorphic IO @ üí¨</a> )</p>",
        "id": 531236472,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753660435
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> I'm working on a compiler project where I would like to turn an untyped AST of a DSL into an intrinsically-typed PHOAS version. The details gets a bit complicated; but roughly, this allows me to get type-checking and some type-inference for free using Lean's mvar unification during elaboration. </p>\n<p>The problem is that the resulting the PHOAS representation lives in <code>Type 1</code>. I think I can work around this by having a command that inserts a <code>def</code> containing the thing I want. Then calling whatever function I need to call on the resulting definition in meta-lean. But it would be better if I can just have an <code>IO</code> monad returning the <code>Type 1</code> PHOAS syntax directly.</p>",
        "id": 531267826,
        "sender_full_name": "Paul Mure",
        "timestamp": 1753674477
    }
]