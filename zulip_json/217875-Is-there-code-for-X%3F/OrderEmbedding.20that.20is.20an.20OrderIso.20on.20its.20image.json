[
    {
        "content": "<p>I have an <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderEmbedding#doc\">docs#OrderEmbedding</a> that can be <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderIso#doc\">docs#OrderIso</a> on its image, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mulTwo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">↪</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">OrderEmbedding</span><span class=\"bp\">.</span><span class=\"n\">ofMapLEIff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">lia</span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">replicateZero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">↪</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">OrderEmbedding</span><span class=\"bp\">.</span><span class=\"n\">ofMapLEIff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">replicate</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">replicate_le_replicate</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>The problem is that <code>OrderEmbedding</code> only provides inequalities over sups/infs (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderEmbedding.le_map_sup#doc\">docs#OrderEmbedding.le_map_sup</a> / <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderEmbedding.map_inf_le#doc\">docs#OrderEmbedding.map_inf_le</a>) rather than equalities (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderIso.map_sup#doc\">docs#OrderIso.map_sup</a> / <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderIso.map_inf#doc\">docs#OrderIso.map_inf</a>).</p>\n<p>Is there a type for that? (hopefully where I don't have to provide an inverse function, but it's not a deal breaker)<br>\nAnd is there a nice condition under which an <code>OrderEmbedding</code> satisfies equalities for sups/infs/top/bot?<br>\n(e.g. <code>Real.arctan</code> is an order embedding but it doesn't preserve top/bot)</p>",
        "id": 564614132,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766116255
    },
    {
        "content": "<p>Sorry, I don't understand what your question is. Any order embedding is an order isomorphism on its image.</p>",
        "id": 564640821,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1766132517
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/OrderEmbedding.20that.20is.20an.20OrderIso.20on.20its.20image/near/564640821\">said</a>:</p>\n<blockquote>\n<p>Sorry, I don't understand what your question is. Any order embedding is an order isomorphism on its image.</p>\n</blockquote>\n<p>Yes there's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderEmbedding.orderIso#doc\">docs#OrderEmbedding.orderIso</a>, but that converts the image to a <code>Subtype</code>, so it loses most of its lattice structure (sup/inf/top/bot).</p>\n<p>What I meant was: What hypotheses do I have to add on <code>f</code> to the following code to make the theorems hold, and is there already such an existing type that extends <code>OrderEmbedding</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompleteDistribLattice</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompleteDistribLattice</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">↪</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">map_bot</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">map_top</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">map_inf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">map_sup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">isMax_apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsMax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">IsMax</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">isMin_apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsMin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">IsMin</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>These theorems are true for the two embeddings I gave as examples above (at least the applicable theorems after adjusting the typeclasses)</p>",
        "id": 564655013,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766137512
    },
    {
        "content": "<p><code>OrderEmbedding</code> provides similar theorems but with inequalities, similar to a Galois connection, whereas I'm looking for something more like a group/ring homomorphism - preserve the structure</p>",
        "id": 564655692,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766137741
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LatticeHom#doc\">docs#LatticeHom</a>. If you separately assume injectivity, then you get what you asked for</p>",
        "id": 564657523,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1766138359
    },
    {
        "content": "<p>Ooh there's even a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BoundedLatticeHom#doc\">docs#BoundedLatticeHom</a> and a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CompleteLatticeHom#doc\">docs#CompleteLatticeHom</a>, this looks exactly like what I was looking for, thanks!<br>\nThough now the problem becomes finding a \"simple\" way to construct such a hom, like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderEmbedding.ofMapLEIff#doc\">docs#OrderEmbedding.ofMapLEIff</a> for embeddings. Is there a single condition I can prove that'll provide all the fields for a lattice hom, or is there no way to avoid proving the sup/inf/top/bot theorems?</p>",
        "id": 564663205,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766140200
    },
    {
        "content": "<p>A simple way is to have a Galois connection</p>",
        "id": 564663494,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1766140285
    },
    {
        "content": "<p>I didn't find any relation between <code>GaloisConnection</code>/<code>GaloisInsertion</code>/<code>GaloisCoinsertion</code> and <code>LatticeHom</code>/<code>BoundedLatticeHom</code>/<code>CompleteLatticeHom</code>, how can it help?<br>\n(also creating an inverse function is daunting)</p>",
        "id": 564665533,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766140900
    },
    {
        "content": "<p>See <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=GaloisConnection.l_sup#doc\">docs#GaloisConnection.l_sup</a> and alike</p>",
        "id": 564665859,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1766140986
    }
]