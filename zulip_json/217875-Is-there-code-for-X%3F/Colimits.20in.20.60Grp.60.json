[
    {
        "content": "<p>Does mathlib have colimits in the category <code>Grp</code> of groups? The file <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Category/Grp/Colimits.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Category/Grp/Colimits.html</a> where such colimits should be if they exist has as its title \"<strong>The category of additive commutative groups has all colimits</strong>\", so I'm guessing the answer is \"no\".<br>\nI was thinking of writing a proof that the universe lifting functor <code>Grp.uliftFunctor</code>preserves small colimits (it does <em>not</em> preserve all colimits), but I don't know how to do it without the explicit construction of such colimits, so I guess I won't. I'm mostly interested in <code>CommGrp.uliftFunctor</code> anyway, which does preserve all colimits because <code>CommGrp</code> has a cogenerator.</p>",
        "id": 489064338,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734249918
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span></p>",
        "id": 489071593,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1734257615
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Colimits.20in.20.60Grp.60/near/489064338\">said</a>:</p>\n<blockquote>\n<p>... the universe lifting functor <code>Grp.uliftFunctor</code>preserves small colimits (it does <em>not</em> preserve all colimits)</p>\n</blockquote>\n<p>Funnily I made the same observation in <a class=\"message-link\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/tensor.20products.20commute.20with.20direct.20limits/near/275178330\">#Is there code for X? &gt; tensor products commute with direct limits @ ðŸ’¬</a> </p>\n<p>I recall it's in mathlib that colimits exist if coproducts and coequalizers exist. It's also true that colimits are preserved if coproducts and coequalizers are, right?</p>",
        "id": 489080330,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1734265567
    },
    {
        "content": "<p>I also recently noticed that the construction <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/DirectLimit.html#AddCommGroup.DirectLimit\">AddCommGroup.DirectLimit</a> actually works for all colimits (if you generalize the Preorder to an arbitrary indexing category), and you might use that as well.</p>",
        "id": 489080663,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1734265882
    },
    {
        "content": "<p>No, it is not true that colimits are preserved if coproducts and coequalizers are, because the colimit of a functor <code>F : J â¥¤ Grp.{u} </code> could exist without the coproduct of all <code>F.obj j</code> existing, if <code>J</code> is a big category relative to the universe <code>u</code>.</p>",
        "id": 489081021,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734266274
    },
    {
        "content": "<p>I am currently writing a proof that <code>AddCommGrp.uliftFunctor</code> preserves <em>all</em> colimits that doesn't use any construction of colimits but uses the cogenerator <code>AddCircle (1 : â„š)</code> of <code>AddCommGrp.{u}</code>, similar to the proof in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Limits/Preserves/Ulift.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Limits/Preserves/Ulift.html</a> (that uses the generator <code>Prop</code> for <code>Type u</code> but doesn't really explain what it is doing). This is actually much simpler than using a specific construction of colimits.</p>",
        "id": 489081213,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734266437
    },
    {
        "content": "<p>As for the functor <code>Grp.uliftFunctor : Grp.{u} â¥¤ Grp.{max v u}</code>, it does not preserve all colimits. It does preserve colimits indexed by <code>u</code>-small categories, but since I was unable to find a construction of such colimits in mathlib (I cannot even find a construction of small coproducts in <code>Grp</code>), and since I am not planning to write such a construction, I cannot prove it.</p>",
        "id": 489081487,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734266720
    },
    {
        "content": "<p>This all started from me needing the fact that <code>AddCommGroup.uliftFunctor</code>is a faithful exact functor, so I do not want to get distracted too much.</p>",
        "id": 489081556,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734266769
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Colimits.20in.20.60Grp.60/near/489080330\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Colimits.20in.20.60Grp.60/near/489064338\">said</a>:</p>\n<blockquote>\n<p>... the universe lifting functor <code>Grp.uliftFunctor</code>preserves small colimits (it does <em>not</em> preserve all colimits)</p>\n</blockquote>\n<p>Funnily I made the same observation in <a class=\"message-link\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/tensor.20products.20commute.20with.20direct.20limits/near/275178330\">#Is there code for X? &gt; tensor products commute with direct limits @ ðŸ’¬</a> </p>\n<p>I recall it's in mathlib that colimits exist if coproducts and coequalizers exist. It's also true that colimits are preserved if coproducts and coequalizers are, right?</p>\n</blockquote>\n<p>I had found the same flavor of counterexample to show that <code>Grp.uliftFunctor</code> does not preserve colimits. Funnily, you don't mention the thing that I wanted, which is that <code>AddCommGrp.uliftFunctor</code> does, though of course it follows easily from the existence of a cogenerator in <code>Type</code>. (I am not touching <code>Module</code> categories, I have enough trouble with universes as it is without bring more into play.)</p>",
        "id": 489081959,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734267154
    },
    {
        "content": "<p>Sorry for not being precise. I meant that if it preserves coproducts of a certain size (i.e. with J in a certain universe) then it preserves coproducts of that size.</p>\n<p>Cogenerators are mentioned in <a class=\"message-link\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/tensor.20products.20commute.20with.20direct.20limits/near/274922926\">#Is there code for X? &gt; tensor products commute with direct limits @ ðŸ’¬</a> <br>\nI acutally authored the proof in Type. But I think there's a shorter proof in mathlib now ...</p>",
        "id": 489082056,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1734267248
    },
    {
        "content": "<p>Yes, the file credits Dagur Asgeirsson and you, and I could see the similarities between the proof you linked and the one in mathlib.</p>",
        "id": 489082111,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734267323
    },
    {
        "content": "<p>I think in mathlib there's now an Equiv between an abstract colimit in Type and a Quot type, which could be used to remove my code completely.</p>",
        "id": 489082248,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1734267479
    },
    {
        "content": "<p>This? (And the results around it.)<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Limits/Types.html#CategoryTheory.Limits.Types.hasColimit_iff_small_quot\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Limits/Types.html#CategoryTheory.Limits.Types.hasColimit_iff_small_quot</a></p>",
        "id": 489082357,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734267599
    },
    {
        "content": "<p>I would prefer not to remove your code, as it is less category-dependent, i.e. it is easier to adapt to other algebraic categories that have a small cogenerator, even if we don't have a nice explicit construction of colimits for them.</p>",
        "id": 489082461,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734267670
    },
    {
        "content": "<p>It's just a pity that it doesn't explain what it is doing.</p>",
        "id": 489082492,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734267719
    },
    {
        "content": "<p>PRs documenting code always welcome! I was experimenting with this to see how other people would react, e.g. <a href=\"https://github.com/leanprover-community/mathlib4/blob/07a5460913024dd3de0201e48e227f5e9f5c843d/Mathlib/Topology/Algebra/Module/ModuleTopology.lean#L126-L136\">here</a>, <a href=\"https://github.com/leanprover-community/mathlib4/blob/07a5460913024dd3de0201e48e227f5e9f5c843d/Mathlib/Topology/Algebra/Module/ModuleTopology.lean#L222-L250\">here</a> and lots more occurrences in that file, i.e. actually explaining what my code did. Nobody seemed to object!</p>",
        "id": 489082596,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734267827
    },
    {
        "content": "<p>Well Kevin, I recently proved that the adjoint of a triangulated functor is triangulated, and decided to see if I could PR it, which is going to take a lot of effort. I could do that, or I could document other people's code, but I'm not sure I can do both.</p>",
        "id": 489082689,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734267906
    },
    {
        "content": "<p>Fair point! I think that my personal preference would be you doing adjoints of triangulated functors :-)</p>",
        "id": 489082731,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734267950
    },
    {
        "content": "<p>(I will of course try to document my own code sufficiently.)</p>",
        "id": 489082790,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734267965
    },
    {
        "content": "<p>There was a \"funny\" moment during that project, where one line of informal math became about 1000 lines of code. Ah, category theory... <br>\n(It was the proof that, if a functor commutes with shifts, so does its left/right adjoint. Because \"commuting with shifts\" is not a property, it's a structure, and a structure that needs to satisfy some compatibilities, and I don't think anybody ever checks these compatibilities in informal math.)</p>",
        "id": 489082923,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734268126
    },
    {
        "content": "<blockquote>\n<p>I cannot even find a construction of small coproducts in <code>Grp</code></p>\n</blockquote>\n<p>There's actually <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Monoid.CoprodI.instGroup#doc\">docs#Monoid.CoprodI.instGroup</a></p>",
        "id": 489088038,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1734273147
    },
    {
        "content": "<p>Ah, thanks! So having coproducts in the category <code>Grp</code> should be easy from that. Now I just hope you don't find cokernels, because I would have to find another excuse not to show that <code>Grp.uliftFunctor</code> commutes with small colimits. <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 489105142,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734287439
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Colimits.20in.20.60Grp.60/near/489082689\">said</a>:</p>\n<blockquote>\n<p>Well Kevin, I recently proved that the adjoint of a triangulated functor is triangulated, and decided to see if I could PR it, which is going to take a lot of effort. I could do that, or I could document other people's code, but I'm not sure I can do both.</p>\n</blockquote>\n<p>I did this already about one year ago in <a href=\"https://github.com/leanprover-community/mathlib4/blob/jriou_localization/Mathlib/CategoryTheory/Triangulated/Adjunction.lean\">https://github.com/leanprover-community/mathlib4/blob/jriou_localization/Mathlib/CategoryTheory/Triangulated/Adjunction.lean</a> and <a href=\"https://github.com/leanprover-community/mathlib4/blob/jriou_localization/Mathlib/CategoryTheory/Shift/Adjunction.lean\">https://github.com/leanprover-community/mathlib4/blob/jriou_localization/Mathlib/CategoryTheory/Shift/Adjunction.lean</a> (the code is still draft...)</p>",
        "id": 489109618,
        "sender_full_name": "JoÃ«l Riou",
        "timestamp": 1734291913
    },
    {
        "content": "<p>Well I figured that somebody must have done it, but at this point it was easier to just prove it myself than to look for code in people's branches. It's hard enough to find theorems in mathlib.</p>",
        "id": 489111678,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734293852
    },
    {
        "content": "<p>Obviously it's nice to not have to duplicate work, but sometimes it is either hard to avoid, or realistically the correct way to get things moving. The existence of work in draft shouldn't obstruct others from redoing and completing something. And in the alternative, starting to do so sometimes kick starts new progress on the work in draft, which is also positive!</p>",
        "id": 489115867,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1734297735
    },
    {
        "content": "<p>So interesting fact about colimits in <code>AddCommGrp</code>: the file <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Category/Grp/Colimits.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Category/Grp/Colimits.html</a> provides an <code>HasColimit K</code> instance for every <code>K : J â¥¤ AddCommGroup.{u}</code> if <code>J : Type u</code> and we have a <code>Category.{u,u} J</code> instance, but <em>not</em> if we have a <code>Category.{v,u} J</code> instance with <code>v</code> another universe. <br>\nOf course the construction of colimits should work as soon as the set of objects of <code>J</code> is <code>u</code>-small, so I'm guessing something went wrong somewhere in the universe soup.</p>",
        "id": 489119050,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734300693
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">JoÃ«l Riou</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Colimits.20in.20.60Grp.60/near/489109618\">said</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">did</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">already</span><span class=\"w\"> </span><span class=\"n\">about</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"n\">year</span><span class=\"w\"> </span><span class=\"n\">ago</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">https</span><span class=\"o\">:</span><span class=\"bp\">//</span><span class=\"n\">github</span><span class=\"bp\">.</span><span class=\"n\">com</span><span class=\"bp\">/</span><span class=\"n\">leanprover</span><span class=\"bp\">-</span><span class=\"n\">community</span><span class=\"bp\">/</span><span class=\"n\">mathlib4</span><span class=\"bp\">/</span><span class=\"n\">blob</span><span class=\"bp\">/</span><span class=\"n\">jriou_localization</span><span class=\"bp\">/</span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">/</span><span class=\"n\">Triangulated</span><span class=\"bp\">/</span><span class=\"n\">Adjunction</span><span class=\"bp\">.</span><span class=\"n\">lean</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">https</span><span class=\"o\">:</span><span class=\"bp\">//</span><span class=\"n\">github</span><span class=\"bp\">.</span><span class=\"n\">com</span><span class=\"bp\">/</span><span class=\"n\">leanprover</span><span class=\"bp\">-</span><span class=\"n\">community</span><span class=\"bp\">/</span><span class=\"n\">mathlib4</span><span class=\"bp\">/</span><span class=\"n\">blob</span><span class=\"bp\">/</span><span class=\"n\">jriou_localization</span><span class=\"bp\">/</span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">/</span><span class=\"n\">Shift</span><span class=\"bp\">/</span><span class=\"n\">Adjunction</span><span class=\"bp\">.</span><span class=\"n\">lean</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">still</span><span class=\"w\"> </span><span class=\"n\">draft</span><span class=\"bp\">...</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I'm using a different definition of compatibility of <code>CommShift</code> with adjunctions, though it's easy to see it's equivalent. Your definition is more elegant, but the one I use makes it obvious that <code>CommShift.iso</code> isomorphisms for the left adjoint determine those for the right adjoint and vice versa, which then simplifies the construction of the <code>CommShift</code> structure on the adjoint (or rather the verification that it satisfies the required compatibilities, this becomes almost obvious). I'll see if I can merge the two in a satisfactory way.</p>\n<p>I haven't looked at the details of your proof that the right adjoint preserves triangulated functors (mathematically this is the hardest part, but it Lean this was the more straightforward part for me); it seems that you use a more direct approach than me, I went through the five lemma and an adjunction <code>homEquiv</code> upgraded to categories of abelian groups, which is super natural mathematically but caused me some technical trouble in Lean.</p>\n<p>I also wrote some code to get the other direction (right adjoint to left adjoint) for \"free\" using opposite categories, becase I need both directions for my application. It's not very difficult but you need to add a bunch of \"compatibility with opposites\" lemmas in a variety of places.</p>",
        "id": 489499246,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734445875
    },
    {
        "content": "<p>Yes, I did the diagram chase in a down to earth way because at the time we did not have universe-heterogeneous versions of the <code>5</code>-lemma for unbundled abelian groups (and I am not sure we have it now).<br>\nAt the time I wrote this code, <code>CategoryTheory.Adjunction.Mates</code> was not as developed as it is know. It should be possible to get cleaner definitions and proofs using that.</p>",
        "id": 489527169,
        "sender_full_name": "JoÃ«l Riou",
        "timestamp": 1734453363
    },
    {
        "content": "<p>No, it was awful, I had to apply universe lift functors everywhere to use the five lemma, and then I realized that mathlib did not know that the universe lift functor for abelian groups was exact. (Though it hopefully soon will, I finished writing the commutation with colimits and it's ready to PR.)<br>\nI also had a nasty fight with <code>ShiftSequence</code>s, because somehow I ended up with several instances of them on the same functor, that were equal but Lean did not realize that. And every time I try to use <code>ComposableArrows</code>, it's awkward because <code>simp</code> often does not simplify statements about them so I have to know exactly what I want to prove and use <code>change</code>. But I'm pretty happy about how it turned out, except for the <code>ShiftSequence</code> stuff; there were some timeouts.</p>",
        "id": 489529507,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734454072
    },
    {
        "content": "<p>Making <code>attribute [local simp] Precomp.map</code> and/or <code>set_option simprocs false</code> may help for the <code>ComposableArrows</code> issue (which appeared after a change in Lean core).</p>",
        "id": 489545402,
        "sender_full_name": "JoÃ«l Riou",
        "timestamp": 1734459271
    },
    {
        "content": "<p>Which simproc causes the problem here?</p>",
        "id": 489594718,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1734480880
    },
    {
        "content": "<p>I made the <code>CommShift</code> for adjunctions (+ equivalences) stuff into a PR (<a href=\"https://github.com/leanprover-community/mathlib4/pull/20033\">#20033</a>), so you can have a look at it. It might be too long for a PR, I'm not sure.<br>\nThe main difference with JoÃ«l's code (except for some cleanup of stuff that has made its way into mathlib since) is the fact that I introduce the compatibility condition separately for each element of the group and prove that it implies that the commutation isomorphism on one adjoint determine that on the other, which simplifies the proof of the compatibilities later.</p>",
        "id": 489723138,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734516968
    },
    {
        "content": "<p>(My TODO says \"do the other direction using opposite categories\", but the code became simple enough that it might okay to just do it directly.)</p>",
        "id": 489731975,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734519988
    },
    {
        "content": "<p>In this context, working with the opposite category is a little bit painful, but here, using <code>OppositeShift</code> (which does not change the sign of the shift) may be an option, even though it may be easier to do the dual case directly (in another PR).<br>\nFor <code>Adjunction.left/rightAdjoint_isTriangulated</code>, it will probably be more painful (as the signs are changed), but at some point, we should develop an API for triangulated functors and duality (<code>F</code> is triangulated iff <code>F.op/F.leftOp/F.rightOp</code> is, etc). (I still have not PRed the painful proof that the opposite category of a triangulated category is triangulated, i.e. the octahedron axioms dualises.)</p>",
        "id": 489738488,
        "sender_full_name": "JoÃ«l Riou",
        "timestamp": 1734522237
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Colimits.20in.20.60Grp.60/near/489594718\">said</a>:</p>\n<blockquote>\n<p>Which simproc causes the problem here?</p>\n</blockquote>\n<p>I do not remember exactly, but it had to do with natural numbers.</p>",
        "id": 489738641,
        "sender_full_name": "JoÃ«l Riou",
        "timestamp": 1734522279
    },
    {
        "content": "<p>I wrote some code to prove that <code>F.op</code> is triangulated if <code>F</code> is (and vice versa), but I did not touch <code>leftOp</code> and <code>rightOp</code>:<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/compare/master...SM.AdjointTriangulated#diff-546cff707f4054447b28780149cda9090fb308564e57893467ee88a44c4dd3b2\">https://github.com/leanprover-community/mathlib4/compare/master...SM.AdjointTriangulated#diff-546cff707f4054447b28780149cda9090fb308564e57893467ee88a44c4dd3b2</a></p>\n<p>(Please ignore the <code>omit</code>s, I didn't put my lemmas in the correct order.)</p>",
        "id": 489740562,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734522960
    },
    {
        "content": "<p>(The part with the signs is fun, you have to take the opposite <code>CommShift</code> <em>then</em> pull it back by the <code>n â†¦ -n</code> morphism.</p>",
        "id": 489741146,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734523139
    },
    {
        "content": "<p>As for <code>Adjunction.CommShift</code> in the other direction, I do have a proof written down with <code>OppositeShift</code>, but I'm not sure that it will be shorter than a direct proof (even after cleanup).</p>",
        "id": 489741411,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1734523220
    },
    {
        "content": "<p>I have another question about the file <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Category/Grp/Colimits.html#The-category-of-additive-commutative-groups-has-all-colimits\">Mathlib.Algebra.Category.Grp.Colimits</a>. The beginning says \"TODO: In fact, inÂ <code>AddCommGrp</code>Â there is a much nicer model of colimits as quotients of finitely supported functions, and we really should implement this as well (or instead).\" I do agree with that sentiment, I just wonder if the fact that <code>DFinsupp J</code> requires <code>DecidableEq J</code> would cause problems. (It seems to me that, if we are doing colimits in the category of groups, we are past worrying about decidability issues, but I might be missing something.)</p>",
        "id": 491895678,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1736013961
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Colimits.20in.20.60Grp.60/near/491895678\">said</a>:</p>\n<blockquote>\n<p>I do agree with that sentiment, I just wonder if the fact that <code>DFinsupp J</code> requires <code>DecidableEq J</code> would cause problems.</p>\n</blockquote>\n<p>I think there would be no issue if you put <code>DecidableEq J</code> as an assumption in the definitions, but not in the statement of certain lemmas (e.g. proving <code>HasColimitsOfShape</code>).</p>",
        "id": 491902333,
        "sender_full_name": "JoÃ«l Riou",
        "timestamp": 1736019467
    },
    {
        "content": "<p>Ah yes, I forgot that I can just start the proof of a lemma with <code>classical</code>...</p>",
        "id": 491903035,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1736020098
    }
]