[
    {
        "content": "<p>There is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MonoidHom.noncommPiCoprod#doc\">docs#MonoidHom.noncommPiCoprod</a> but that didn't seem to exist for a coproduct of two, <br>\nso I quickly wrote this this morning. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Group.Prod</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! # Morphisms to a coproduct of two monoids -/</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">MulHom</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semigroup</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→ₙ*</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→ₙ*</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Commute</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- Coproduct of two `MulHom`s with the same codomain:</span>\n<span class=\"sd\">`f.noncommCoprod g (p : M × N) = f p.1 * g p.2`. -/</span>\n<span class=\"kd\">@[to_additive</span>\n<span class=\"kd\">      \"Coproduct of two `AddHom`s with the same codomain:</span>\n<span class=\"kd\">      `f.noncommCoprod g (p : M × N) = f p.1 + g p.2`.\"]</span>\n<span class=\"kd\">def</span> <span class=\"n\">noncommCoprod</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">×</span> <span class=\"n\">N</span> <span class=\"bp\">→ₙ*</span> <span class=\"n\">P</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">mn</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">mn.fst</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">mn.snd</span><span class=\"o\">)</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">mn</span> <span class=\"n\">mn'</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Prod.fst_mul</span><span class=\"o\">,</span> <span class=\"n\">Prod.snd_mul</span><span class=\"o\">,</span> <span class=\"n\">map_mul</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_assoc</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"n\">congr_arg₂</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"n\">congr_arg₂</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span>\n    <span class=\"n\">apply</span> <span class=\"n\">comm</span>\n\n<span class=\"kd\">@[to_additive (attr := simp)]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">noncommCoprod_apply</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">×</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f.noncommCoprod</span> <span class=\"n\">g</span> <span class=\"n\">comm</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">p.1</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"n\">p.2</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[to_additive (attr := simp)]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">noncommCoprod_apply'</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">×</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">f.noncommCoprod</span> <span class=\"n\">g</span> <span class=\"n\">comm</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">p.2</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">p.1</span> <span class=\"o\">:=</span>\n  <span class=\"n\">comm</span> <span class=\"n\">p.1</span> <span class=\"n\">p.2</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">comp_noncommCoprod</span> <span class=\"o\">{</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semigroup</span> <span class=\"n\">Q</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→ₙ*</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">h.comp</span> <span class=\"o\">(</span><span class=\"n\">f.noncommCoprod</span> <span class=\"n\">g</span> <span class=\"n\">comm</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n      <span class=\"o\">(</span><span class=\"n\">h.comp</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">noncommCoprod</span> <span class=\"o\">(</span><span class=\"n\">h.comp</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">coe_comp</span><span class=\"o\">,</span> <span class=\"n\">Function.comp_apply</span><span class=\"o\">]</span>\n        <span class=\"n\">exact</span> <span class=\"n\">Commute.map</span> <span class=\"o\">(</span><span class=\"n\">comm</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">ext</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n\n<span class=\"kd\">end</span> <span class=\"n\">MulHom</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MonoidHom</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MulOneClass</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MulOneClass</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→*</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→*</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Commute</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- Coproduct of two `MonoidHom`s with the same codomain:</span>\n<span class=\"sd\">`f.noncommCoprod g (p : M × N) = f p.1 * g p.2`. -/</span>\n<span class=\"kd\">@[to_additive</span>\n<span class=\"kd\">      \"Coproduct of two `AddMonoidHom`s with the same codomain:</span>\n<span class=\"kd\">      `f.noncommCoprod g (p : M × N) = f p.1 + g p.2`.\"]</span>\n<span class=\"kd\">def</span> <span class=\"n\">noncommCoprod</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">×</span> <span class=\"n\">N</span> <span class=\"bp\">→*</span> <span class=\"n\">P</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">mn</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">mn.fst</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">mn.snd</span><span class=\"o\">)</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">mn</span> <span class=\"n\">mn'</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Prod.fst_mul</span><span class=\"o\">,</span> <span class=\"n\">Prod.snd_mul</span><span class=\"o\">,</span> <span class=\"n\">map_mul</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_assoc</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"n\">congr_arg₂</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"n\">congr_arg₂</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span>\n    <span class=\"n\">apply</span> <span class=\"n\">comm</span>\n  <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Prod.fst_one</span><span class=\"o\">,</span> <span class=\"n\">Prod.snd_one</span><span class=\"o\">,</span> <span class=\"n\">map_one</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[to_additive (attr := simp)]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">noncommCoprod_apply</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">×</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f.noncommCoprod</span> <span class=\"n\">g</span> <span class=\"n\">comm</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">p.1</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"n\">p.2</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[to_additive (attr := simp)]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">noncommCoprod_apply'</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">×</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">f.noncommCoprod</span> <span class=\"n\">g</span> <span class=\"n\">comm</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">p.2</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">p.1</span> <span class=\"o\">:=</span>\n  <span class=\"n\">comm</span> <span class=\"n\">p.1</span> <span class=\"n\">p.2</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">comp_noncommCoprod</span> <span class=\"o\">{</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">Q</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→*</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">h.comp</span> <span class=\"o\">(</span><span class=\"n\">f.noncommCoprod</span> <span class=\"n\">g</span> <span class=\"n\">comm</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n      <span class=\"o\">(</span><span class=\"n\">h.comp</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">noncommCoprod</span> <span class=\"o\">(</span><span class=\"n\">h.comp</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">coe_comp</span><span class=\"o\">,</span> <span class=\"n\">Function.comp_apply</span><span class=\"o\">]</span>\n        <span class=\"n\">exact</span> <span class=\"n\">Commute.map</span> <span class=\"o\">(</span><span class=\"n\">comm</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">ext</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MonoidHom</span>\n</code></pre></div>",
        "id": 392662237,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1695458471
    },
    {
        "content": "<p>Do we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MonoidHom.coprod#doc\">docs#MonoidHom.coprod</a> ?</p>",
        "id": 392664753,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695459438
    },
    {
        "content": "<p>Yes, but it assumes commutativity of the target.</p>",
        "id": 392668191,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1695461076
    },
    {
        "content": "<p>(I should have said that, sorry…)</p>",
        "id": 392668197,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1695461089
    },
    {
        "content": "<p>I think it's probably reasonable to PR the above; but make sure to reference it from the docstring of the <code>.coprod</code> version (and vice versa)</p>",
        "id": 392669549,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695461647
    },
    {
        "content": "<p>Do you mean indicating that function in the docstring of the <code>.coprod</code> version (sth such as \"commutative case\") and conversely \"for the commutative case, see…\" ?</p>",
        "id": 392675883,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1695464114
    },
    {
        "content": "<p>PR : <a href=\"https://github.com/leanprover-community/mathlib4/pull/7335\">#7335</a></p>",
        "id": 392683517,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1695467696
    }
]