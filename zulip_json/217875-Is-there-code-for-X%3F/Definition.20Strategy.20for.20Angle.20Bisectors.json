[
    {
        "content": "<p>I'am working on formalizing angle bisector definitions and facing a design choice between specificity and generality.</p>\n<p><strong>Option 1: Focus on 2-angle bisectors</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bisectorDir</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">‖</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">-ᵥ</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-ᵥ</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-ᵥ</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">-ᵥ</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p><strong>Rationale:</strong></p>\n<ul>\n<li>2-angle bisectors are the most commonly used in geometry</li>\n<li>They have many unique properties (incenter, excenter theorems, etc.)</li>\n<li>Direct computational approach for the most frequent use case</li>\n</ul>\n<p><strong>Option 2: General n-angle bisector definition</strong></p>\n<ul>\n<li>More theoretically complete</li>\n<li>2-angle case becomes a special instance</li>\n<li>Better alignment with mathematical generality principles</li>\n</ul>\n<p><strong>Question:</strong> What's the recommended approach for mathlib4? Should I prioritize the common use case or go with the more general n-angle definition?</p>",
        "id": 537580415,
        "sender_full_name": "Li Jiale",
        "timestamp": 1756953691
    },
    {
        "content": "<p>do both</p>",
        "id": 537620512,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1756975538
    },
    {
        "content": "<p>I've thought a lot about API design for angle bisectors over the past few years. There are several different definitions that would be relevant in the end, both for inner product spaces (bisectors between vectors and bisectors between oriented subspaces) and for affine spaces over those. Most of my recent PRs have been working towards setting up the link between incenter/excenter and angle bisectors (in n dimensions, not just two dimensions) based on how I think this theory ought to be set up.</p>\n<p>I'm not sure what you mean by \"n-angle bisector\".</p>\n<p>If you mean e.g. trisectors - multiplying an angle by some real number other than 1/2 - then those ought to be separate from bisectors (with API linking them, of course). For example, there is a meaningful notion of the submodule of vectors with equal angles to two given vectors (which unfortunately fails to correspond with an informal notion of bisector when the two vectors are in the same direction, when the informal bisector is the span of that vector, not the whole space), but no such trisector submodule.</p>\n<p>If you mean bisectors in n dimensions, which is the appropriate general form for relating to incenter and excenter, then various API needs to be set up around orientations of submodules; you have, essentially, a consistent family of orientations for faces of a simplex (in two dimensions these correspond to arrows cycling round the triangle, for example) and can define a submodule (and similarly an affine subspace) bisecting the angle between two such oriented submodules (note than this is an (n-1)-dimensional submodule bisecting the angle between two (n-1)-dimensional oriented submodules, given an (n-2)-dimensional space lying in both submodules and an orthogonal 2-dimensional space with which each has 1-dimensional intersection). (Bisectors between two vectors / three points in n dimensions are also mathematically meaningful, just not what's needed for relating to incenter / excenter.)</p>\n<p>But that's probably not the most convenient form for working with in practice in two dimensions, which is why I've been PRing things about the location of touchpoints - knowing betweenness properties relating touchpoints and vertices is on the critical path for being able to prove more concrete lemmas about equality of oriented angles involving vertices and incenter / excenter, which is more likely to be useful if you look at the details of what you actually need for formalizing concrete problems involving those points (I'm working on IMO 2024 P4). (Statements involving bisecting angles where one of the three points is a touchpoint are easy given the API I've set up so far for incenter / excenter. The information about locations of touchpoints is in order to translate that to statements involving vertices and not touchpoints.)</p>",
        "id": 537634559,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1756979793
    },
    {
        "content": "<p>I don't think <code>bisectorDir</code> should be there; bisectors for vectors should be set up in terms of two vectors rather than three points, and it looks like it gets the wrong result for two vectors pointing in opposite directions. My inclination is that the core definitions for bisectors between vectors should be set up as the kernel of an appropriate linear map (so automatically a submodule), and then ones that do the right thing for vectors in the same direction built on top of that (and results in the oriented case, and bisectors between oriented submodules in n dimensions, also built on top of that).</p>",
        "id": 537635614,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1756980131
    },
    {
        "content": "<p>Do we already have a definition for the un-oriented bisector, </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">InnerProductGeometry</span><span class=\"bp\">.</span><span class=\"n\">bisector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v₁</span><span class=\"w\"> </span><span class=\"n\">v₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">eqLocus</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">v₁</span><span class=\"bp\">‖⁻¹</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">innerₛₗ</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">v₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">v₂</span><span class=\"bp\">‖⁻¹</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">innerₛₗ</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">v₂</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">copy</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">angle</span><span class=\"w\"> </span><span class=\"n\">v₁</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">angle</span><span class=\"w\"> </span><span class=\"n\">v₂</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> I have a proof of this somewhere -/</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- The affine hyperplane bisecting the angle between three points -/</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">EuclideanGeometry</span><span class=\"bp\">.</span><span class=\"n\">bisector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p₁</span><span class=\"w\"> </span><span class=\"n\">p₂</span><span class=\"w\"> </span><span class=\"n\">p₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AffineSubspace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">InnerProductGeometry</span><span class=\"bp\">.</span><span class=\"n\">bisector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p₁</span><span class=\"w\"> </span><span class=\"bp\">-ᵥ</span><span class=\"w\"> </span><span class=\"n\">p₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p₃</span><span class=\"w\"> </span><span class=\"bp\">-ᵥ</span><span class=\"w\"> </span><span class=\"n\">p₂</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toAffineSubspace</span><span class=\"bp\">.</span><span class=\"n\">comap</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">AffineEquiv</span><span class=\"bp\">.</span><span class=\"n\">vaddConst</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">p₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">toAffineMap</span>\n</code></pre></div>",
        "id": 537639588,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756981543
    },
    {
        "content": "<p>We don't have any of the definitions. My inclination is to treat the property about equal angles in what you have as <code>InnerProductGeometry.bisector</code> as a theorem rather than using <code>copy</code> to get defeq for that property. I also think at least four definitions are needed for bisectors between vectors as submodules, where the one you have would be something like <code>fullIntBisector</code> and then a definition <code>intBisector</code> would be derived from it that corresponds more closely to a conventional informal definition (as in: as long as the two vectors are nonzero, the intersection with any two-dimensional space containing both of them is precisely one-dimensional, so the bisector of the angle between two vectors in the same direction is the span of those two vectors, and the bisector is itself one-dimensional except for the special case of two vectors in opposite directions; equivalently, the oriented angle is bisected in any such two-dimensional subspace). And then two definitions <code>fullExtBisector</code> and <code>extBisector</code> for the external bisectors. And then corresponding affine definitions for all of those.</p>",
        "id": 537641683,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1756982321
    },
    {
        "content": "<p>Thanks for the detailed guidance! Based on your suggestions, I've drafted these core definitions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Layer 1: Complete definitions (kernel-based)</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fullIntBisector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">‖</span><span class=\"n\">v</span><span class=\"bp\">‖</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">innerₛₗ</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">u</span><span class=\"bp\">‖</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">innerₛₗ</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fullExtBisector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">‖</span><span class=\"n\">v</span><span class=\"bp\">‖</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">innerₛₗ</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">u</span><span class=\"bp\">‖</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">innerₛₗ</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Layer 2: Practical definitions (branching on same/opposite direction)</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">intBisector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">classical</span>\n<span class=\"w\">  </span><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⊥</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SameRay</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">span</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">ho</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SameRay</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">fullIntBisector</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">span</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"bp\">‖</span><span class=\"n\">v</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">u</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">extBisector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">classical</span>\n<span class=\"w\">  </span><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⊥</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SameRay</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">fullExtBisector</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">ho</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SameRay</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">span</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">span</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"bp\">‖</span><span class=\"n\">v</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">u</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Layer 3: Affine versions</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">affineIntBisector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AffineSubspace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">through</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">intBisector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-ᵥ</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">-ᵥ</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">affineExtBisector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AffineSubspace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">through</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">extBisector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-ᵥ</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">-ᵥ</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Does this layered approach look reasonable?</p>",
        "id": 537828427,
        "sender_full_name": "Li Jiale",
        "timestamp": 1757064180
    },
    {
        "content": "<p>I claim the defeq is slightly nicer with <code>eqLocus</code>, but I guess it doesn't matter too much</p>",
        "id": 537829319,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757064470
    },
    {
        "content": "<p>I think the affine and vector versions can be distinguished by being in different namespaces rather than needing different names, but I don't know what's most convenient to use in practice.</p>\n<p>I'd be inclined to use term-mode <code>if</code> to define <code>intBisector</code> and <code>extBisector</code> rather than defining data in tactic mode. Also, if the definitions are set up correctly, <code>fullExtBisector</code> can be defined in terms of <code>fullIntBisector</code>, and <code>extBisector</code> in terms of <code>intBisector</code>, by negating one of the vectors, and then this can be proved equivalent to other definitions when setting up API.</p>\n<p>What's <code>through</code>? We discussed renaming <code>AffineSubspace.mk'</code> (see <a href=\"https://github.com/leanprover-community/mathlib4/pull/23546\">#23546</a>), but I'm not sure that reached a conclusion.</p>",
        "id": 537831415,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1757065128
    }
]