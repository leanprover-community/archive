[
    {
        "content": "<p>I'm looking for a standard definition of HLists. There's lots of different ones floating around, including <a href=\"https://www.leanprover.cn/lean4/examples/deBruijn.lean.html\">this one from the lean docs</a> and <a href=\"https://github.com/Kha/do-supplement/blob/master/Do/Formal.lean\">this one which avoids the universe level bump</a>.</p>\n<p>Is this something people just define as-necessary in their own projects? I can't find a \"standard\" definition or package anywhere, like on reservoir, but I'm also brand new to Lean, so I might just be looking wrong.</p>\n<p>For what it's worth, I can't use the universe pattern to implement a \"naive\" HList, because I'm using indexed families and the universe pattern /already/; that is, I'm using HLists to define Product / Sum types in a system where I'm using the universe pattern to define the \"base\" types.</p>",
        "id": 525489446,
        "sender_full_name": "neil",
        "timestamp": 1750761979
    },
    {
        "content": "<p>Can you give an example of how you want to use it? One of the reasons I think there has not been a standard HList definition is because it's usually the wrong tool and you should use <code>Prod</code> instead</p>",
        "id": 525514512,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750770443
    },
    {
        "content": "<p>so I have this tarski-universe representation of \"primitive types\" for a bytestring de-/serialization framework I'm working on:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">TagExpr</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Missing</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Bytes</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Option</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">vExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TagExpr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Missing</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">vExpr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Missing</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">vExpr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">vExpr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Bytes</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">vExpr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Bytes</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">vExpr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">Option</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">vExpr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I'd like to build products of vExprs on top of this, so something like <code>[ vExpr Int .Int , vExpr Bool .Bool ,  vExpr Bool (.List 4) , vExpr Int (.Option) ]</code> to represent the type of a (deserialized) bytestring which has, in order, an int, a bool, a list of four booleans, and an optional integer.</p>\n<p>Because vExpr is an indexed family, this is not <code>Array vExpr</code>, especially since I'm instantiating <code>\\a</code> to different types in each position (to correspond to the \"natural\" host type representation for each of the vExpr constructors).  It looks like the natural way to represent products is, then, a heterogeneous list of fully-applied vExprs types.</p>",
        "id": 525622057,
        "sender_full_name": "neil",
        "timestamp": 1750816112
    },
    {
        "content": "<p>I was thinking of using a definition similar to this one, from the first link in my post:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\">      </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">PUnit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">αs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"n\">αs</span>\n</code></pre></div>\n<p>, plus also seeing if I could refine the type of <code>\\a</code> to force the elements to be some instantiation of <code>vExpr</code>. Now, this one seems to just use Prod, as you've mentioned, which also avoids a universe-level bump.</p>",
        "id": 525622552,
        "sender_full_name": "neil",
        "timestamp": 1750816530
    },
    {
        "content": "<p>You could also do a <code>List (Sigma (fun t =&gt; Sigma (vExpr t)))</code></p>",
        "id": 525623778,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750817344
    },
    {
        "content": "<p>hmm, that might work, though you need two type parameters ofc</p>",
        "id": 525624100,
        "sender_full_name": "neil",
        "timestamp": 1750817596
    },
    {
        "content": "<p>I just tried to make the HList defn above / the prod defn have some sort of restriction to vExprs, and at least my naive attempts don't work because match isn't capable of doing what I need it to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">tester</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bar</span>\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">tester</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">vs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">vs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\">      </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">PUnit</span>\n<span class=\"w\">  </span><span class=\"c1\">-- let's just try implementing what we want directly:</span>\n<span class=\"w\">  </span><span class=\"c1\">-- this doesn't work; lean says</span>\n<span class=\"w\">  </span><span class=\"c1\">-- &gt; invalid pattern, constructor or constant marked with '[match_pattern]'</span>\n<span class=\"w\">  </span><span class=\"c1\">-- &gt; expected</span>\n<span class=\"w\">  </span><span class=\"c1\">-- | a@(vExpr _ _) :: as =&gt; a × HList as</span>\n<span class=\"w\">  </span><span class=\"c1\">-- `Int` is a pattern variable, /not/ the actual Int type constructor, so this</span>\n<span class=\"w\">  </span><span class=\"c1\">-- doesn't work.</span>\n<span class=\"w\">  </span><span class=\"c1\">-- | a@Int :: as =&gt; a × HList as</span>\n<span class=\"w\">  </span><span class=\"c1\">-- maybe we can use a namespace to force `match` to treat the type name as a</span>\n<span class=\"w\">  </span><span class=\"c1\">-- literal name and not a pattern variable?</span>\n<span class=\"w\">  </span><span class=\"c1\">-- that doesn't work either.</span>\n<span class=\"w\">  </span><span class=\"c1\">-- | a@tester.Foo :: as =&gt; a × HList as</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">αs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"n\">αs</span>\n\n<span class=\"bp\">#</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">compiles</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">even</span><span class=\"w\"> </span><span class=\"n\">though</span><span class=\"w\"> </span><span class=\"n\">we</span><span class=\"w\"> </span><span class=\"n\">want</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">reject</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"n\">bare</span><span class=\"w\"> </span><span class=\"ss\">`Int</span><span class=\"bp\">`.</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">vprod_example</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Int</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">vExpr</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Int</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">vExpr</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">Option</span><span class=\"o\">))]</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">vprod_example</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">vprod_example</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 525624191,
        "sender_full_name": "neil",
        "timestamp": 1750817671
    },
    {
        "content": "<p>I'll try the Sigma approach but I feel like that might be difficult to work with, whereas the prod approach is very simple</p>",
        "id": 525624218,
        "sender_full_name": "neil",
        "timestamp": 1750817697
    },
    {
        "content": "<p>frankly I prooooobably don't need vProd to be so fancy, because whatever theorems I have in mind ultimately are stated in terms of signatures, not vExprs directly, so I don't really have to work over the entirety of vExpr / vProd, only the subset which can be instantiated from some corresponding signature.</p>\n<p>but maybe it would be nice to have vProd disallow non-vExpr-family(?) types, just in case I need to work with it directly in some proofs (e.g. induction over vProd should guarantee that the head element, in the inductive case, is of the form <code>vExpr \\a g</code>)</p>",
        "id": 525624387,
        "sender_full_name": "neil",
        "timestamp": 1750817832
    },
    {
        "content": "<p>Do you only want the types in the list to be <code>vExpr _ _</code>?</p>",
        "id": 525624421,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750817855
    },
    {
        "content": "<p>that would be nice, yes</p>",
        "id": 525624429,
        "sender_full_name": "neil",
        "timestamp": 1750817864
    },
    {
        "content": "<p>Then how about just</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">vs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">TagExpr</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">vs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\">      </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">PUnit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">αs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">vExpr</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"n\">αs</span>\n</code></pre></div>",
        "id": 525624529,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750817934
    },
    {
        "content": "<p>...</p>",
        "id": 525624544,
        "sender_full_name": "neil",
        "timestamp": 1750817942
    },
    {
        "content": "<p>why do I even bother</p>",
        "id": 525624560,
        "sender_full_name": "neil",
        "timestamp": 1750817948
    },
    {
        "content": "<p>yeah, that should work. im going to go take a cold shower now</p>",
        "id": 525624588,
        "sender_full_name": "neil",
        "timestamp": 1750817972
    },
    {
        "content": "<p>I will also take a shower</p>",
        "id": 525624602,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750817985
    },
    {
        "content": "<p>still wrapping my head around all these idioms for programming with dependent types</p>",
        "id": 525624612,
        "sender_full_name": "neil",
        "timestamp": 1750817995
    },
    {
        "content": "<p>oh, also, is there some way to make it so that you don't need to have a concluding <code>.unit</code> in some value of type <code>HList foos</code>? Would that just have to be something syntactic / via a helper function that adds a <code>Punit.unit</code> onto the end of the value?</p>\n<p>I'm assuming there's not really a good way to handle this at the level of the defn of HList because Prod doesn't have something that corresponds to <code>\\. ++ []</code>.</p>",
        "id": 525624996,
        "sender_full_name": "neil",
        "timestamp": 1750818313
    },
    {
        "content": "<p>yup, mod that last question regarding <code>PUnit.unit</code>, the following does exactly what I want:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">vProd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">TagExpr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">PUnit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">vs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">vExpr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">vProd</span><span class=\"w\"> </span><span class=\"n\">vs</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">vprod_example</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">vProd</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Int</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">Option</span><span class=\"o\">))]</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">vprod_example</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">.</span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">vprod_example</span><span class=\"o\">)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">vProd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">TagExpr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">PUnit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">vs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">vExpr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">vProd</span><span class=\"w\"> </span><span class=\"n\">vs</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">vprod_example</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">vProd</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Int</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">Option</span><span class=\"o\">))]</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">vprod_example</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">.</span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">vprod_example</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and I guess I can use a bit of syntax magic to handle inserting the final .unit appropriately</p>",
        "id": 525625955,
        "sender_full_name": "neil",
        "timestamp": 1750819119
    },
    {
        "content": "<p>So I would set it up more like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">vType</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Missing</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Bytes</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">vType</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">vType</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ty₁</span><span class=\"w\"> </span><span class=\"n\">ty₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">vType</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">vType</span><span class=\"bp\">.</span><span class=\"n\">toType</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">vType</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Missing</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Bytes</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ByteArray</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"bp\">.</span><span class=\"n\">toType</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"bp\">.</span><span class=\"n\">toType</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Prod</span><span class=\"w\"> </span><span class=\"n\">ty₁</span><span class=\"w\"> </span><span class=\"n\">ty₂</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ty₁</span><span class=\"bp\">.</span><span class=\"n\">toType</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">ty₂</span><span class=\"bp\">.</span><span class=\"n\">toType</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">vType</span><span class=\"bp\">.</span><span class=\"n\">Tuple</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">vType</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">vType</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tys</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Prod</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">Tuple</span><span class=\"w\"> </span><span class=\"n\">tys</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">vprod_example</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">vType</span><span class=\"bp\">.</span><span class=\"n\">Tuple</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">Int</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Int</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Bool</span><span class=\"o\">]</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(((</span><span class=\"mi\">4</span><span class=\"o\">:</span><span class=\"n\">Int</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"o\">:</span><span class=\"n\">Int</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">())</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">vprod_example</span><span class=\"bp\">.</span><span class=\"n\">toType</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 525650985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750836924
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"931836\">neil</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.22standard.22.20HList.20definition/near/525624996\">said</a>:</p>\n<blockquote>\n<p>oh, also, is there some way to make it so that you don't need to have a concluding <code>.unit</code> in some value of type <code>HList foos</code>? Would that just have to be something syntactic / via a helper function that adds a <code>Punit.unit</code> onto the end of the value?</p>\n</blockquote>\n<p>This is actually pretty easy:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">vs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">TagExpr</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">vs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\">      </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">PUnit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">vExpr</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">αs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">vExpr</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"n\">αs</span>\n</code></pre></div>",
        "id": 525677913,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750845976
    },
    {
        "content": "<p>yeah, I have been running on too little sleep lately so I'm missing all sorts of obvious bits. I thought there would be some sort of issue with it needing to be a 1-tuple, but... that's not how any of this works</p>",
        "id": 525695158,
        "sender_full_name": "neil",
        "timestamp": 1750852241
    },
    {
        "content": "<p>a couple notes for posterity:</p>\n<ol>\n<li>you don't really want to do <code>match vs with | [] =&gt; ... | [s] =&gt; ... | s :: ss =&gt; ..</code> since, because the match arms have independent contexts, you don't know that <code>ss != []</code>. Instead, you should do a nested match, like</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">vs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\">  </span><span class=\"c1\">-- singleton [s] case</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\">  </span><span class=\"c1\">-- don't need to bind anything here, we just need the evidence 'h'</span>\n</code></pre></div>",
        "id": 526171281,
        "sender_full_name": "neil",
        "timestamp": 1751078737
    },
    {
        "content": "<p>What about <code>match vs with | [] =&gt; ... | [s] =&gt; ... | s :: ss :: sss =&gt; ...</code></p>",
        "id": 526171372,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751078924
    },
    {
        "content": "<ol start=\"2\">\n<li>for my particular use case, using a big Prod wasn't actually very useful, because I needed to ensure that these types \"lined up\" with certain other types, so now I'm just using iterables with sigma types.</li>\n</ol>\n<p>For example, for \"chunking\" a bytestring representing a product into a sequence of bytestrings, each sized appropriately for the corresponding field of the product, I have the type</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- sExpr is some type of signatures, e.g. .Int, (.List .Int 4), etc.</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">sProduct</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">sExpr</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">sProduct</span><span class=\"bp\">.</span><span class=\"n\">bitType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sP</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sProduct</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">\\</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sExpr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">bitType</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>you might notice that I'm not really using <code>sP</code> in the last definition, so it remains to be seen if this will cause problems later (i.e. I need to ensure that the elements of the bitType vector line up with elements of the given sProduct...)</p>",
        "id": 526171455,
        "sender_full_name": "neil",
        "timestamp": 1751079041
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.22standard.22.20HList.20definition/near/526171372\">said</a>:</p>\n<blockquote>\n<p>What about <code>match vs with | [] =&gt; ... | [s] =&gt; ... | s :: ss :: sss =&gt; ...</code></p>\n</blockquote>\n<p>yeah, you can do this instead, so you get the nice singleton case, but then you do have to use <code>ss :: sss</code> whenever you want the tail. Maybe you could do <code>s :: ss@(_ :: _)</code>? I'll check that after</p>",
        "id": 526171496,
        "sender_full_name": "neil",
        "timestamp": 1751079105
    },
    {
        "content": "<p>also mario sorry I didn't even see your reply!</p>",
        "id": 526171513,
        "sender_full_name": "neil",
        "timestamp": 1751079130
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.22standard.22.20HList.20definition/near/525650985\">said</a>:</p>\n<blockquote>\n<p>So I would set it up more like this:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">vType</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Missing</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Bytes</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">vType</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">vType</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ty₁</span><span class=\"w\"> </span><span class=\"n\">ty₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">vType</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">vType</span><span class=\"bp\">.</span><span class=\"n\">toType</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">vType</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Missing</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Bytes</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ByteArray</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"bp\">.</span><span class=\"n\">toType</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"bp\">.</span><span class=\"n\">toType</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Prod</span><span class=\"w\"> </span><span class=\"n\">ty₁</span><span class=\"w\"> </span><span class=\"n\">ty₂</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ty₁</span><span class=\"bp\">.</span><span class=\"n\">toType</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">ty₂</span><span class=\"bp\">.</span><span class=\"n\">toType</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">vType</span><span class=\"bp\">.</span><span class=\"n\">Tuple</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">vType</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">vType</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tys</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Prod</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">Tuple</span><span class=\"w\"> </span><span class=\"n\">tys</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">vprod_example</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">vType</span><span class=\"bp\">.</span><span class=\"n\">Tuple</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">Int</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Int</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Bool</span><span class=\"o\">]</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(((</span><span class=\"mi\">4</span><span class=\"o\">:</span><span class=\"n\">Int</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"o\">:</span><span class=\"n\">Int</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">())</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">vprod_example</span><span class=\"bp\">.</span><span class=\"n\">toType</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I see. So there's a couple significant ways this differs from the way I set things up:</p>\n<ol>\n<li>Your vType is really more like what I'm using for signatures, or a type which describes the type of the data to de-/serialize. There's no analogue of a \"value type\" structure, because you're using host language types (Lean's Int, Prod, etc.) directly.</li>\n</ol>\n<p>I prototyped this in Haskell previously and it was nice to have a value type representation because then you could have recursion schemes and such over it. That's not really so important, because (1) that's not relevant in Lean and (2) the only real use-case I have in mind for these values is to instantiate some sort of \"real\" product type (or Lean <code>structure</code>), in which case I don't need a \"generic\" way to traverse vTypes, because the \"real\" product type would define a corresponding vType.</p>\n<p>I'll keep this in mind as I implement more of my prototype and see if I can simplify the two-tier sExpr/vExpr thing I have into something like your vType.</p>\n<ol start=\"2\">\n<li>prod is just part of vType, rather than a separate construction. My ultimate goal is to implement a sort of \"compatibility checking algorithm\", such that given two signatures (or vTypes), it's possible to determine whether a bytestring serialized according to one can be deserialized according to the other, and so I thought it would be nice to have prod be a separate type, but I suppose that doesn't really matter; if you have two signatures and one of them isn't a prod, well, that's incompatible on its face. So, maybe, it's fine to do this, too.</li>\n</ol>\n<p>I also have some theorems in mind which involve comparing product signatures where, say, one is the same as the other, but has a missing in the position where the other has an optional, and whether that causes compatibility problems, but I think these can also be safely rephrased with a signature definition which includes product.</p>",
        "id": 526177047,
        "sender_full_name": "neil",
        "timestamp": 1751086134
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"931836\">neil</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.22standard.22.20HList.20definition/near/526177047\">said</a>:</p>\n<blockquote>\n<ol>\n<li>Your vType is really more like what I'm using for signatures, or a type which describes the type of the data to de-/serialize. There's no analogue of a \"value type\" structure, because you're using host language types (Lean's Int, Prod, etc.) directly.</li>\n</ol>\n</blockquote>\n<p>I'm not sure what you mean by \"value type\" structure, as I see it that's <code>vType</code>. I wasn't really liking your <code>vExpr</code> because it does not assert any relationship between the type <code>α</code> and the tag</p>",
        "id": 526177128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751086257
    },
    {
        "content": "<blockquote>\n<p>I prototyped this in Haskell previously</p>\n</blockquote>\n<p>Note that <code>vType</code> is explicitly taking advantage of dependent types, so it's no surprise you wouldn't be able to do the same kind of thing in haskell</p>",
        "id": 526177160,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751086311
    },
    {
        "content": "<blockquote>\n<p>I also have some theorems in mind which involve comparing product <br>\nsignatures where, say, one is the same as the other, but has a missing <br>\nin the position where the other has an optional, and whether that causes<br>\n compatibility problems, but I think these can also be safely rephrased <br>\nwith a signature definition which includes product.</p>\n</blockquote>\n<p>You can do this by having a \"subtype\" relation on <code>vType</code>, and an associated function from the underlying lean types when the subtype relation holds</p>",
        "id": 526177219,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751086424
    },
    {
        "content": "<p>Note also that I took a wild guess on what <code>Missing.toType</code> should be. <code>Unit</code> is appropriate if the missing data is unrecoverable, but you may also want to use <code>ByteArray</code> or similar if you want to retain the data unparsed</p>",
        "id": 526177293,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751086534
    },
    {
        "content": "<blockquote>\n<p>My ultimate goal is to implement a sort of \"compatibility checking algorithm\", such that given two signatures (or vTypes), it's possible to determine whether a bytestring serialized according to one can be deserialized according to the other</p>\n</blockquote>\n<p>Note that this is also solved using the \"subtype function\" I mentioned. You just have a syntactic notion of subtype (which you can do by defining it by recursion on <code>vType</code>), and you can add the appropriate nontrivial cast operations there, e.g. <code>A -&gt; Option A</code> or <code>Int -&gt; Bytes</code> or whatever, as long as you can write the function which coerces the corresponding values. (You will also want to prove that it commutes with parsing.)</p>",
        "id": 526177530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751086870
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.22standard.22.20HList.20definition/near/526177128\">said</a>:</p>\n<blockquote>\n<p>I wasn't really liking your <code>vExpr</code> because it does not assert any relationship between the type <code>α</code> and the tag</p>\n</blockquote>\n<p>That was sort of the point; in Haskell, since there's not dependent types, I was using vExpr to structure both the partially-parsed bytestring AND the result of parsing. So something like <code>vExpr Bytestring TagExpr.Int</code> would represent a chunk of a bytestring \"intended\" to be parsed into an integer, and <code>vExpr Integer TagExpr.Int</code> would represent that parsed integer.  Those two types--a bytestring type, and some sort of host language type--were basically the only ones I anticipated being used, but theoretically if you had other functions from bytestrings to &lt;something&gt;, e.g. if you were doing the Gibbon-style \"compile high-level functions to functions on bytestrings\", you could have something else there too.</p>\n<p>As such, there's no general relationship between the type parameter and the tag, but it sort of has to be that way to be useful in the first place. Also, if you're doing recursion schemes or whatever, that also requires the type parameter to be \"free\" or whatever, as I understand it.</p>",
        "id": 526187730,
        "sender_full_name": "neil",
        "timestamp": 1751098205
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.22standard.22.20HList.20definition/near/526177219\">said</a>:</p>\n<blockquote>\n<p>You can do this by having a \"subtype\" relation on <code>vType</code>, and an associated function from the underlying lean types when the subtype relation holds</p>\n</blockquote>\n<p>I think this is what I'll wind up having to implement this as.</p>",
        "id": 526187776,
        "sender_full_name": "neil",
        "timestamp": 1751098260
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.22standard.22.20HList.20definition/near/526177293\">said</a>:</p>\n<blockquote>\n<p>Note also that I took a wild guess on what <code>Missing.toType</code> should be. <code>Unit</code> is appropriate if the missing data is unrecoverable, but you may also want to use <code>ByteArray</code> or similar if you want to retain the data unparsed</p>\n</blockquote>\n<p>unrelated to the present discussion, but yes, I would say Unit. My idea for Missing is that it be used to represent a part of the signature that just isn't present in the data. That way, you have some way of reasoning directly about things like \"you deleted field <a href=\"https://github.com/leanprover-community/mathlib4/pull/2\">#2</a>, so when some other node tries to deserialize a bytestring you produced and that node expects field <a href=\"https://github.com/leanprover-community/mathlib4/pull/2\">#2</a> to be an Integer, we can show that field <a href=\"https://github.com/leanprover-community/mathlib4/pull/2\">#2</a> is just 'not present' rather than accidentally trying to treat the serialized content of field <a href=\"https://github.com/leanprover-community/mathlib4/pull/3\">#3</a> as the content for field <a href=\"https://github.com/leanprover-community/mathlib4/pull/2\">#2</a> and then just completely messing up the parsing\".</p>\n<p>So, something that takes 0 bits in the serialized representation, and then you can have a header (which, in your case, could just be vTypes serialized directly, and in my case, would be the type tags + recursive type parameters) which indicates which positions are Missing.</p>\n<p>There are some systems which allow you to retain and inspect unparsed / unrecognized portions of the input bytestring, but I don't want to allow that in my system</p>",
        "id": 526188121,
        "sender_full_name": "neil",
        "timestamp": 1751098722
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.22standard.22.20HList.20definition/near/526177530\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>My ultimate goal is to implement a sort of \"compatibility checking algorithm\", such that given two signatures (or vTypes), it's possible to determine whether a bytestring serialized according to one can be deserialized according to the other</p>\n</blockquote>\n<p>Note that this is also solved using the \"subtype function\" I mentioned. You just have a syntactic notion of subtype (which you can do by defining it by recursion on <code>vType</code>), and you can add the appropriate nontrivial cast operations there, e.g. <code>A -&gt; Option A</code> or <code>Int -&gt; Bytes</code> or whatever, as long as you can write the function which coerces the corresponding values. (You will also want to prove that it commutes with parsing.)</p>\n</blockquote>\n<p>Yeah, this is more or less how I had built this when I built the \"non-formal\" version of this system. I'm new to formal methods, though, so I haven't really worked with quotients and such directly (also what little experience I have is with Rocq, which doesn't really seem to encourage or play well with this style). So so far, my goal with this iteration has been to get some experience with non-trivial dependently typed programming, and then I'll probably implement a second version which might involve some rearchitecting in order to deliver simpler or more direct statements and proofs of the theorems of interest.</p>",
        "id": 526188246,
        "sender_full_name": "neil",
        "timestamp": 1751098850
    },
    {
        "content": "<p>In any case, thanks for the attention--I really didn't anticipate you spending time on my stuff!</p>",
        "id": 526188286,
        "sender_full_name": "neil",
        "timestamp": 1751098895
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.22standard.22.20HList.20definition/near/526177160\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I prototyped this in Haskell previously</p>\n</blockquote>\n<p>Note that <code>vType</code> is explicitly taking advantage of dependent types, so it's no surprise you wouldn't be able to do the same kind of thing in haskell</p>\n</blockquote>\n<p>worth noting that I am using dependent type features to compute the desired vExpr from my sExpr type, like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">sExpr</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Missing</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Bytes</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elem_type</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sExpr</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elem_type</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sExpr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">sExpr</span><span class=\"bp\">.</span><span class=\"n\">asType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sExpr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Missing</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">vExpr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Missing</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">vExpr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">vExpr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Bytes</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">vExpr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Bytes</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">elem_type</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">vExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elem_type</span><span class=\"bp\">.</span><span class=\"n\">asType</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Option</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">elem_type</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">vExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elem_type</span><span class=\"bp\">.</span><span class=\"n\">asType</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>so the main difference is that I do have a two-level model with sExpr and vExpr, whereas you have a \"one-level\" model with vType, but we both use dependently compute the result type corrresponding to a signature.</p>\n<p>EDIT: I removed a section about <code>.asType</code> being useless because it doesn't unroll properly, when actually what that section demonstrated is that what I wanted wasn't <code>.asType</code>, but actual <code>fmap</code>. I got to figure this out twice because, for whatever reason, I forgot to update the comments in my code...</p>",
        "id": 526189348,
        "sender_full_name": "neil",
        "timestamp": 1751099862
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"931836\">neil</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.22standard.22.20HList.20definition/near/526188121\">said</a>:</p>\n<blockquote>\n<p>My idea for Missing is that it be used to represent a part of the signature that just isn't present in the data.</p>\n</blockquote>\n<p>Isn't that just <code>Option</code>?</p>",
        "id": 526205719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751119294
    },
    {
        "content": "<p>I would expect <code>Missing</code> to mean something like a repaired portion of the stream which is not parseable</p>",
        "id": 526205781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751119356
    },
    {
        "content": "<blockquote>\n<p>so I haven't really worked with quotients and such directly</p>\n</blockquote>\n<p>I think you won't need quotients, at least nothing I have seen so far would suggest it</p>",
        "id": 526205829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751119402
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.22standard.22.20HList.20definition/near/526205719\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"931836\">neil</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.22standard.22.20HList.20definition/near/526188121\">said</a>:</p>\n<blockquote>\n<p>My idea for Missing is that it be used to represent a part of the signature that just isn't present in the data.</p>\n</blockquote>\n<p>Isn't that just <code>Option</code>?</p>\n</blockquote>\n<p>Missing is useful, and distinct from option, because it lets me reason about \"this field was deleted\" in a way that is important for the distributed systems application I'm trying to address. Broadly, if you have \"positional product types\" and you delete a field, you want to record which field got deleted, so that you can potentially retain some backwards/forwards compatibility.</p>\n<p>e.g. given <code>p1 : [ int , option int , bool ]</code> and <code>p2 : [ int , missing , bool ]</code>, where p2 is \"delete a field from p1\", <code>deserialize p2 (serialize p1 _)</code> and <code>deserialize p1 (serialize p2 _)</code> should both succeed. In both cases, you need to know that position 2 should be skipped, and the serialized data will have content for position 3 immediately after position 1.</p>",
        "id": 526254882,
        "sender_full_name": "neil",
        "timestamp": 1751185320
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.22standard.22.20HList.20definition/near/526205781\">said</a>:</p>\n<blockquote>\n<p>I would expect <code>Missing</code> to mean something like a repaired portion of the stream which is not parseable</p>\n</blockquote>\n<p>now very off-topic but I've never encountered a use case for \"we kept around some unparseable data\", nor can I think of one that's actually liable to arise, nor did I hear of anyone else needing it, though lots of ser/des frameworks tout it as a feature (including protobuf iirc)</p>",
        "id": 526255065,
        "sender_full_name": "neil",
        "timestamp": 1751185575
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.22standard.22.20HList.20definition/near/525650985\">said</a>:</p>\n<blockquote>\n<p><code>| .Prod ty₁ ty₂ =&gt; ty₁.toType × ty₂.toType</code></p>\n</blockquote>\n<p>I think I'm going to have to do something like this, as I've run into the following problems:</p>\n<ol>\n<li>\n<p>I have a version using Sigma types instead, so that vProd is basically <code>Vector (\\S (s : sExpr), f(s) n</code>, but that has the problem that the type itself no longer reflects the specifics of the given signature, which means that some of the nice qualities of dependent typing fall away. E.g. if I'm looking to generate signatures, de-/serialization functions, and structures from a single definition, if all the types involved carry specific information about what generated them, then various proofs and constructions should go through easily.</p>\n</li>\n<li>\n<p>I have a version using Products, making types like <code>(.Int , .Option .Bool, .List .Int 3)</code>, but while this is a sufficiently specific type, it's very difficult to work with generically (e.g. how do you write a generic <code>map</code> function?), even if you have specific type information (e.g. you have the generating signature, but given that you use specific <code>match</code> syntax to traverse these values, do you have to generate /syntax/ to use them?).</p>\n</li>\n<li>\n<p>I have started on a version using a more specific version of heterogeneous lists, but I'm running into some issues with dependent elimination, which I'll elaborate in a separate message, in case it should be moved.</p>\n</li>\n</ol>",
        "id": 526518022,
        "sender_full_name": "neil",
        "timestamp": 1751340616
    },
    {
        "content": "<p>(that was my suggestion to begin with <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span> so I'm glad you're trying it)</p>",
        "id": 526519511,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751341765
    },
    {
        "content": "<p>well, I haven't actually gone down that road quite yet, Mario; I think I want to try implementing more of the ser/des functionality and formulating and proving some theorems first, so that if/when I do change this implementation, I can get a sense of the pros and cons of each approach</p>",
        "id": 527091958,
        "sender_full_name": "neil",
        "timestamp": 1751590819
    },
    {
        "content": "<p>along those lines, I finally figured out how to work with these HList things productively yesterday, and it's actually fairly nice. <code>MHList.map</code> and <code>MHList.cast</code> are pretty much everything I need, at the moment, and eventually I think I'll just need something like <code>.fold</code> or <code>.apply</code>, so that I can take an MHList representing a parsed bytestring and pass it to a function which constructs a <code>structure</code> or some other, more useful, host language representation.</p>\n<p>The trick for working with these sorts of dependent types seems to be that you need to carry around the indices/values which parametrize the type, and then you have to match on the indices and the value together, so that discriminating on the former refines the structure of the latter.</p>",
        "id": 527092199,
        "sender_full_name": "neil",
        "timestamp": 1751591007
    },
    {
        "content": "<p>that module:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- MHList (Motivated Heterogeneous List)</span>\n<span class=\"sd\">This type represents a heterogeneous list, each of whose elements have the type</span>\n<span class=\"sd\">corresponding to their position in the type itself. There are two interesting</span>\n<span class=\"sd\">structural components: those of the values and of the type itself.</span>\n\n<span class=\"sd\">The values are represented by a big Product, or something of the form `(_, _,</span>\n<span class=\"sd\">...)`. The \"singleton\" element is just a naked value, rather than some sort of</span>\n<span class=\"sd\">1-Tuple or a Prod terminated by `PUnit`, for convenience.</span>\n\n<span class=\"sd\">The type of that product, namely the MHList itself, is represented indirectly,</span>\n<span class=\"sd\">by means of a list of /indices/ and a /motive/. The motive is a function which</span>\n<span class=\"sd\">computes a Type from an index value.  The overall type, then, is the Product</span>\n<span class=\"sd\">type formed by applying the motive to each of the indices in sequence.</span>\n\n<span class=\"sd\">So, we could represent a heterogeneous list of `Vector Nat 1` followed by</span>\n<span class=\"sd\">`Vector Nat 2` by</span>\n\n<span class=\"sd\">  (#v[1], #v[1, 2]) : MHList (Vector Nat ·) [1, 2]</span>\n<span class=\"sd\">-/</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">MHList</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">PUnit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MHList</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">)</span>\n\n\n<span class=\"c1\">-- NOTE: it would be nice if there were some way to 'infer' new_motive, but I</span>\n<span class=\"c1\">-- don't think that's possible; you'd need to extract the /expression/ of the</span>\n<span class=\"c1\">-- return type of f, since it's supposed to be a dependent function of `α`.</span>\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Apply a function to each element of an HList, producing a new MHList.</span>\n\n<span class=\"sd\">The function needs to be a bit fancy, as it works over a heterogeneous list, and</span>\n<span class=\"sd\">additionally the function which computes its return type must be provided</span>\n<span class=\"sd\">explicitly in order to serve as the new motive for the result MHList.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MHList</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ms</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MHList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">new_motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">new_motive</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MHList</span><span class=\"w\"> </span><span class=\"n\">new_motive</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ms</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ms</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ms</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ms</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">MHList</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">ms</span><span class=\"w\"> </span><span class=\"n\">new_motive</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Cast an MHList, from `MHList motive as` to `MHList newMotive bs`, provided that</span>\n<span class=\"sd\">the element types remain constant; that is, `as.map motive = bs.map newMotive`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MHList</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ms</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MHList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span>\n<span class=\"w\">                      </span><span class=\"o\">(</span><span class=\"n\">newMotive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"w\">                      </span><span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">newMotive</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MHList</span><span class=\"w\"> </span><span class=\"n\">newMotive</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ms</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">bs'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ms</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"c1\">-- NOTE: we need to give lean some help so that this match expression can</span>\n<span class=\"w\">    </span><span class=\"c1\">-- rule out unreachable cases in which as' and bs' have differing lengths.</span>\n<span class=\"w\">    </span><span class=\"c1\">-- We do this by refining eq to relate to as' and bs' directly, then</span>\n<span class=\"w\">    </span><span class=\"c1\">-- discriminating on it in addition to as' and bs'.</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">eq'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bs'</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">newMotive</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">as'</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">eq</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">as'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hbs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bs'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ms</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">eq'</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">castBisA</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">newMotive</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">assumption</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">fullCast</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MHList</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">MHList</span><span class=\"w\"> </span><span class=\"n\">newMotive</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">          </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">MHList</span><span class=\"w\"> </span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">fullCast</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ms</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">casts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">newMotive</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">bs'</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">newMotive</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">as'</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">          </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">has</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hbs</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">assumption</span>\n\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">eqHead</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">newMotive</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">casts</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">eqHead</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">m</span>\n\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">eqTail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bs'</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">newMotive</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">as'</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">casts</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ms'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hbs</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">MHList</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">ms</span><span class=\"w\"> </span><span class=\"n\">newMotive</span><span class=\"w\"> </span><span class=\"n\">bs'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">eqTail</span><span class=\"o\">)</span>\n\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">m'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ms'</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 527092216,
        "sender_full_name": "neil",
        "timestamp": 1751591027
    },
    {
        "content": "<p>I had three or four abortive experiments before working this one out, including one which tried to implement <code>.map</code> by taking an <code>HList</code> of functions, which... didn't really work well at all</p>",
        "id": 527092568,
        "sender_full_name": "neil",
        "timestamp": 1751591340
    }
]