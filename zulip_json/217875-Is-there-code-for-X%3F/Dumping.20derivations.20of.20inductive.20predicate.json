[
    {
        "content": "<p>So I have an inductive predicate <code>Finset A -&gt; A -&gt; Prop</code>, and I'd like to \"dump\" the derivation to a string, so that I can make simple programs computing such derivations and then outputting them.</p>\n<p>Is there a simple way to do that ?</p>",
        "id": 406280370,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701860267
    },
    {
        "content": "<p>Can you give a mwe that indicates the behavior you want?</p>",
        "id": 406296190,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701866292
    },
    {
        "content": "<p>I'll write something but basically take GlimpseOfLean, in the file intuitionistic propositional logic, I'd like to dump a specific derivation of <code>ProvableFrom</code></p>",
        "id": 406303130,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701868862
    },
    {
        "content": "<p>It's very helpful if you can write a self-contained example on Zulip itself, even if you just copy-paste from GlimpseOfLean</p>",
        "id": 406303398,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701868958
    },
    {
        "content": "<p>Yeah I'll write that in a sec, I'm afk for a few minutes</p>",
        "id": 406303473,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701868994
    },
    {
        "content": "<p>Here it is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Basic</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Variable</span> <span class=\"o\">:=</span> <span class=\"n\">String</span>\n\n<span class=\"c1\">-- Formulas</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">bot</span>\n<span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"o\">:</span> <span class=\"n\">Variable</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">and</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">or</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">imp</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n<span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HAnd</span> <span class=\"n\">Formula</span> <span class=\"n\">Formula</span> <span class=\"n\">Formula</span> <span class=\"n\">where</span>\n  <span class=\"n\">hAnd</span> <span class=\"o\">:=</span> <span class=\"n\">Formula.and</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HOr</span> <span class=\"n\">Formula</span> <span class=\"n\">Formula</span> <span class=\"n\">Formula</span> <span class=\"n\">where</span>\n  <span class=\"n\">hOr</span> <span class=\"o\">:=</span> <span class=\"n\">Formula.or</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"s2\">\"#\"</span> <span class=\"n\">v</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Formula.var</span> <span class=\"n\">v</span>\n<span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">27</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"s2\">\" ⟹ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Formula.imp</span>\n\n<span class=\"kd\">instance</span><span class=\"o\">:</span> <span class=\"n\">Bot</span> <span class=\"n\">Formula</span> <span class=\"n\">where</span>\n  <span class=\"n\">bot</span> <span class=\"o\">:=</span> <span class=\"n\">Formula.bot</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">hygiene</span> <span class=\"n\">false</span>\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">27</span> <span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"o\">:=</span><span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"s2\">\" ⊢ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Sequent</span>\n\n<span class=\"c1\">-- Derivations</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Sequent</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">Ax</span> <span class=\"o\">:</span> <span class=\"bp\">#</span><span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"bp\">Γ</span> <span class=\"bp\">→</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"bp\">#</span><span class=\"n\">v</span>\n<span class=\"bp\">|</span> <span class=\"n\">ExFalso</span> <span class=\"o\">:</span> <span class=\"bp\">⊥</span> <span class=\"bp\">∈</span> <span class=\"bp\">Γ</span> <span class=\"bp\">→</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">G</span>\n<span class=\"bp\">|</span> <span class=\"n\">AndI</span> <span class=\"o\">:</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">A</span> <span class=\"bp\">&amp;&amp;&amp;</span> <span class=\"n\">B</span>\n<span class=\"bp\">|</span> <span class=\"n\">AndE</span> <span class=\"o\">:</span> <span class=\"n\">insert</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">B</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">insert</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">&amp;&amp;&amp;</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span>\n<span class=\"bp\">|</span> <span class=\"n\">OrI1</span> <span class=\"o\">:</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">|||</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">OrI2</span> <span class=\"o\">:</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">|||</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">OrE</span> <span class=\"o\">:</span> <span class=\"n\">insert</span> <span class=\"n\">A</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">insert</span> <span class=\"n\">B</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">insert</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">|||</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span>\n<span class=\"bp\">|</span> <span class=\"n\">ImpI</span> <span class=\"o\">:</span> <span class=\"n\">insert</span> <span class=\"n\">A</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⟹</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Now the ImpE rules, that are exploded by cases</span>\n<span class=\"c1\">-- Γ, a, B ⊢ C → Γ, a, a ⇒ B ⊢ C</span>\n<span class=\"bp\">|</span> <span class=\"n\">ImpEAtom</span> <span class=\"o\">:</span> <span class=\"n\">insert</span> <span class=\"bp\">#</span><span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">B</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">insert</span> <span class=\"bp\">#</span><span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"o\">(</span><span class=\"bp\">#</span><span class=\"n\">v</span> <span class=\"bp\">⟹</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span>\n<span class=\"bp\">|</span> <span class=\"n\">ImpEBot</span> <span class=\"o\">:</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">insert</span> <span class=\"o\">(</span><span class=\"bp\">⊥</span> <span class=\"bp\">⟹</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span>\n<span class=\"bp\">|</span> <span class=\"n\">ImpEAnd</span> <span class=\"o\">:</span> <span class=\"n\">insert</span> <span class=\"o\">(</span><span class=\"n\">A₁</span> <span class=\"bp\">⟹</span> <span class=\"n\">A₂</span> <span class=\"bp\">⟹</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">insert</span> <span class=\"o\">((</span><span class=\"n\">A₁</span> <span class=\"bp\">&amp;&amp;&amp;</span> <span class=\"n\">A₂</span><span class=\"o\">)</span> <span class=\"bp\">⟹</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span>\n<span class=\"bp\">|</span> <span class=\"n\">ImpEOr</span> <span class=\"o\">:</span> <span class=\"n\">insert</span> <span class=\"o\">(</span><span class=\"n\">A₁</span> <span class=\"bp\">⟹</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"o\">(</span><span class=\"n\">A₂</span> <span class=\"bp\">⟹</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">insert</span> <span class=\"o\">((</span><span class=\"n\">A₁</span> <span class=\"bp\">|||</span> <span class=\"n\">A₂</span><span class=\"o\">)</span> <span class=\"bp\">⟹</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span>\n<span class=\"bp\">|</span> <span class=\"n\">ImpEImp</span> <span class=\"o\">:</span> <span class=\"n\">insert</span> <span class=\"n\">A₁</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"o\">(</span><span class=\"n\">A₂</span> <span class=\"bp\">⟹</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span> <span class=\"bp\">⊢</span> <span class=\"n\">A₂</span> <span class=\"bp\">→</span> <span class=\"n\">insert</span> <span class=\"n\">B</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">insert</span> <span class=\"o\">((</span><span class=\"n\">A₁</span> <span class=\"bp\">⟹</span> <span class=\"n\">A₂</span><span class=\"o\">)</span> <span class=\"bp\">⟹</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Sequent.dump</span> <span class=\"o\">(</span><span class=\"n\">S</span><span class=\"o\">:</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span><span class=\"o\">):</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 406304400,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701869326
    },
    {
        "content": "<p>And the point of interest being the function <code>Sequent.dump</code></p>",
        "id": 406304537,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701869384
    },
    {
        "content": "<p>Especially, this tentative implementation fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">tactic 'cases' failed, nested error:</span>\n<span class=\"cm\">tactic 'induction' failed, recursor 'Sequent.casesOn' can only eliminate into Prop</span>\n<span class=\"cm\"> after processing</span>\n<span class=\"cm\">  _, _</span>\n<span class=\"cm\">the dependent pattern matcher can solve the following kinds of equations</span>\n<span class=\"cm\">- &lt;var&gt; = &lt;term&gt; and &lt;term&gt; = &lt;var&gt;</span>\n<span class=\"cm\">- &lt;term&gt; = &lt;term&gt; where the terms are definitionally equal</span>\n<span class=\"cm\">- &lt;constructor&gt; = &lt;constructor&gt;, examples: List.cons x xs = List.cons y ys, and List.cons x xs = List.nil</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Sequent.dump</span> <span class=\"o\">(</span><span class=\"n\">S</span><span class=\"o\">:</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span><span class=\"o\">):</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">S</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">Ax</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"Ax\"</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 406305041,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701869567
    },
    {
        "content": "<p>Right, you can't ask a <code>Prop</code> \"how were you constructed\" unless you promise you are only going to use that information to  prove something</p>",
        "id": 406305593,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701869772
    },
    {
        "content": "<p>That's what</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic</span> <span class=\"bp\">'</span><span class=\"n\">induction'</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">recursor</span> <span class=\"bp\">'</span><span class=\"n\">Sequent.casesOn'</span> <span class=\"n\">can</span> <span class=\"n\">only</span> <span class=\"n\">eliminate</span> <span class=\"n\">into</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>means</p>",
        "id": 406305625,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701869782
    },
    {
        "content": "<p>Then here goes my other question: what if I have <code>Decidable (G |- C)</code>, then I can turn my Prop into a bool and use that ?</p>",
        "id": 406305840,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701869851
    },
    {
        "content": "<p>Nonono, you're off by one level.</p>",
        "id": 406306016,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701869893
    },
    {
        "content": "<p>What's your end goal here: do you just want to see how a proof was built, or do you want to prove things about how the proof was built?</p>",
        "id": 406306111,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701869929
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Dumping.20derivations.20of.20inductive.20predicate/near/406306016\">said</a>:</p>\n<blockquote>\n<p>Nonono, you're off by one level.</p>\n</blockquote>\n<p>Oh, because <code>Bool: Type 1</code> right ?</p>",
        "id": 406306117,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701869931
    },
    {
        "content": "<p>If the former, you can just use <code>#print some_sequent_proof</code> and it will show you the construction</p>",
        "id": 406306175,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701869947
    },
    {
        "content": "<p>Which is fine because <code>#print</code> operates in the meta-theory on <code>Expr</code> objects</p>",
        "id": 406306244,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701869968
    },
    {
        "content": "<p>Here's an example of what Eric is saying: If <code>h : p ∨ q</code>, you can't say \"Oh I'll map <code>h</code> to <code>0</code> if it came from <code>p</code> and to <code>1</code> if it came from <code>q</code>\" because it could come from both <code>p</code> and <code>q</code>!</p>",
        "id": 406306261,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701869974
    },
    {
        "content": "<p>If you replace <code>p ∨ q</code> by <code>p || q</code>, you still get the same problem.</p>",
        "id": 406306321,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701869997
    },
    {
        "content": "<p>My goal is to make a simple \"prover\" app for intuitionistic propositional logic, to which you give your context + goal, and it autoproves (if a proof exists)</p>",
        "id": 406306588,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701870055
    },
    {
        "content": "<p>For that I thus need to output the resulting derivation</p>",
        "id": 406306646,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701870067
    },
    {
        "content": "<p>I don't think your conclusion necessarily follows there, it's quite possible that inspecting the <code>Expr</code> would work for you</p>",
        "id": 406306897,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701870122
    },
    {
        "content": "<p>Unless you want to prove the app itself is correct</p>",
        "id": 406306962,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701870129
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Dumping.20derivations.20of.20inductive.20predicate/near/406306962\">said</a>:</p>\n<blockquote>\n<p>Unless you want to prove the app itself is correct</p>\n</blockquote>\n<p>That I am fine doing be reasonning directly in the formalisation</p>",
        "id": 406307124,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701870165
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Dumping.20derivations.20of.20inductive.20predicate/near/406306897\">said</a>:</p>\n<blockquote>\n<p>I don't think your conclusion necessarily follows there, it's quite possible that inspecting the <code>Expr</code> would work for you</p>\n</blockquote>\n<p>How would I do that then ?</p>",
        "id": 406307159,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701870173
    },
    {
        "content": "<p>The other easy way out is to replace</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Sequent</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Sequent</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n</code></pre></div>\n<p>but that might make things unpleasant for you elsewhere</p>",
        "id": 406307274,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701870195
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"658705\">Thomas Vigouroux</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Dumping.20derivations.20of.20inductive.20predicate/near/406307159\">said</a>:</p>\n<blockquote>\n<p>How would I do that then ?</p>\n</blockquote>\n<p>Can you add an example proof in your code so that I can demonstrate how to print it?</p>",
        "id": 406307422,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701870228
    },
    {
        "content": "<p>Yup, because having that as a predicate helps for proving things like consistency and completeness</p>",
        "id": 406307553,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701870249
    },
    {
        "content": "<p>Here's an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">Variable</span> <span class=\"o\">:=</span> <span class=\"s2\">\"v\"</span>\n<span class=\"kd\">def</span> <span class=\"n\">u</span><span class=\"o\">:</span> <span class=\"n\">Variable</span> <span class=\"o\">:=</span> <span class=\"s2\">\"u\"</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Sequent.orComm</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"bp\">#</span><span class=\"n\">u</span> <span class=\"bp\">|||</span> <span class=\"bp\">#</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"bp\">⊢</span> <span class=\"bp\">#</span><span class=\"n\">v</span> <span class=\"bp\">|||</span> <span class=\"bp\">#</span><span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">insert_emptyc_eq</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">OrE</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">OrI2</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Ax</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">insert_emptyc_eq</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_singleton</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">OrI1</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Ax</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">insert_emptyc_eq</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_singleton</span><span class=\"o\">]</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 406308181,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701870384
    },
    {
        "content": "<p>I'd really like to get the derivation printed out for <code>Sequent.orComm</code> in a way that I have control over</p>",
        "id": 406308324,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701870421
    },
    {
        "content": "<p>I guess</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"n\">Sequent.orComm</span>\n<span class=\"c1\">-- theorem Sequent.orComm : Sequent {#u ||| #v} (#v ||| #u) :=</span>\n<span class=\"c1\">-- Eq.mpr (id ((insert_emptyc_eq (#u ||| #v)).symm ▸ Eq.refl (Sequent {#u ||| #v} (#v ||| #u))))</span>\n<span class=\"c1\">--   (Sequent.OrE</span>\n<span class=\"c1\">--     (Sequent.OrI2</span>\n<span class=\"c1\">--       (Sequent.Ax</span>\n<span class=\"c1\">--         (of_eq_true (((congrArg (Membership.mem #u) (insert_emptyc_eq #u)).trans _auxLemma.1).trans (eq_self #u)))))</span>\n<span class=\"c1\">--     (Sequent.OrI1</span>\n<span class=\"c1\">--       (Sequent.Ax</span>\n<span class=\"c1\">--         (of_eq_true (((congrArg (Membership.mem #v) (insert_emptyc_eq #v)).trans _auxLemma.1).trans (eq_self #v))))))</span>\n</code></pre></div>\n<p>isn't very helpful</p>",
        "id": 406308652,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701870490
    },
    {
        "content": "<p>(it's easy to write your own function in <code>CoreM</code> that gives that output, but presumably you don't want the <code>Eq.mpr</code>s?</p>",
        "id": 406308783,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701870521
    },
    {
        "content": "<p>Well it kinda is, but let's say I'd like to output to be:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>u || v |- v || u by OrE\n. u |- v || u by OrI2\n  u |- u by Ax\n. v |- v || u by OrI1\n  v |- v by Ax\n</code></pre></div>",
        "id": 406309397,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701870658
    },
    {
        "content": "<p>I think you understood what I meant</p>",
        "id": 406309566,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701870695
    },
    {
        "content": "<p>I think <code>inductive Sequent : Finset Formula → Formula → Type</code> is going to be the best approach here</p>",
        "id": 406310040,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701870800
    },
    {
        "content": "<p>You can maybe have both</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">SequentData</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Sequent</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>with the same constructors, and then hopefully show that the former implies the latter</p>",
        "id": 406310234,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701870843
    },
    {
        "content": "<p>It seems like the desired output more closely matches the tactic steps and the goal state at each step. That would also result in the desired outcome of different tactic proofs for the same proposition giving different outputs. Would it be possible to have a tactic that records the tactics used during a proof which makes this record available elsewhere?</p>",
        "id": 406310455,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1701870910
    },
    {
        "content": "<p>Changing to <code>-&gt; Type</code> typecheks (and I have proofs about soundness and related), so I guess that's good</p>",
        "id": 406310559,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701870944
    },
    {
        "content": "<p>Okay but now it complains about depending on  <code>lemma</code>s which don't have executable code</p>",
        "id": 406311772,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701871291
    },
    {
        "content": "<p>Nvm, I just had to change to <code>def</code></p>",
        "id": 406311877,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701871314
    },
    {
        "content": "<p>It works great now, that you very much !</p>",
        "id": 406311935,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701871324
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"658705\">Thomas Vigouroux</span> has marked this topic as resolved.</p>",
        "id": 406311964,
        "sender_full_name": "Notification Bot",
        "timestamp": 1701871327
    },
    {
        "content": "<p>Sorry to bother again, but in the process I'd like to print out a <code>Finset Formula</code>.<br>\nI am fine with the order changing, apparently it requires me to use <code>choice</code> which I don't want, how would I do ?</p>",
        "id": 406326789,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701875668
    },
    {
        "content": "<p>My first guess was to do something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">finsetFmlToString</span><span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n<span class=\"bp\">|</span> <span class=\"bp\">∅</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"\"</span>\n<span class=\"bp\">|</span> <span class=\"n\">insert</span> <span class=\"n\">A</span> <span class=\"bp\">∅</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">A.toString</span>\n<span class=\"bp\">|</span> <span class=\"n\">insert</span> <span class=\"n\">A</span> <span class=\"n\">S</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">A.toString</span> <span class=\"bp\">++</span> <span class=\"s2\">\", \"</span> <span class=\"bp\">++</span> <span class=\"n\">S.toString</span>\n</code></pre></div>\n<p>But that does not work because <code>insert</code> is not a match pattern</p>",
        "id": 406327316,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701875840
    },
    {
        "content": "<p>A <code>Finset</code> is a <code>List</code> without duplicate, quotiented out by permutation. Hence it is an element of a quotient of a thing you can print.</p>",
        "id": 406327913,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701876004
    },
    {
        "content": "<p>While I follow to theory, I'm not sure about the steps to go from that to an actual working conversion from <code>Finset</code> to String...</p>",
        "id": 406328307,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701876102
    },
    {
        "content": "<p>I mean, have you tried it? <code>#print your_finset</code></p>",
        "id": 406328506,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701876153
    },
    {
        "content": "<p>yeah</p>",
        "id": 406328678,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701876205
    },
    {
        "content": "<p>That works, but how do I get the actual value so that I can manipulate it ?</p>",
        "id": 406328736,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701876224
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=repr#doc\">docs#repr</a></p>",
        "id": 406328771,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701876235
    },
    {
        "content": "<p>Well... <code>unsafe instance Finset.instReprFinset</code></p>",
        "id": 406329404,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701876375
    },
    {
        "content": "<p>What do you mean?</p>",
        "id": 406329498,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701876403
    },
    {
        "content": "<p>Because it is unsafe I cannot use it in any other block that unsafe ?</p>",
        "id": 406329580,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701876426
    },
    {
        "content": "<p>And that's fine, right? You're trying to prove things about it.</p>",
        "id": 406329824,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701876487
    },
    {
        "content": "<p>Well not really, I'm really just wanting to get it to dump the value</p>",
        "id": 406329955,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701876527
    },
    {
        "content": "<p>I'm not using it to any other thing than dumping it to the screen</p>",
        "id": 406330029,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701876549
    },
    {
        "content": "<p>So <code>unsafe</code> is fine and there's no reason to be scared.</p>",
        "id": 406330069,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701876558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Dumping.20derivations.20of.20inductive.20predicate/near/406330069\">said</a>:</p>\n<blockquote>\n<p>So <code>unsafe</code> is fine and there's no reason to be scared.</p>\n</blockquote>\n<p>I realized it as I was typing it <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span> </p>\n<p>Thanks for your help !</p>",
        "id": 406330139,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701876580
    },
    {
        "content": "<p>Okay, so I think I've got something working !</p>\n<p>The following proof</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Sequent.orComm</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"bp\">#</span><span class=\"n\">u</span> <span class=\"bp\">|||</span> <span class=\"bp\">#</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"bp\">⊢</span> <span class=\"bp\">#</span><span class=\"n\">v</span> <span class=\"bp\">|||</span> <span class=\"bp\">#</span><span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">insert_emptyc_eq</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">OrE</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">OrI2</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Ax</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">insert_emptyc_eq</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_singleton</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">OrI1</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Ax</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">insert_emptyc_eq</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_singleton</span><span class=\"o\">]</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>Dumps the following derivation:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>{(u | v)} |- (v | u) OrE\n  {u} |- (v | u) OrIR\n  {u} |- u.\n\n  {v} |- (v | u) OrIL\n  {v} |- v.\n</code></pre></div>",
        "id": 406332148,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701877142
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">finsetFmlToString</span><span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">s.image</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">A.toString</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sort.intercalate</span> <span class=\"s2\">\", \"</span>\n</code></pre></div>",
        "id": 406334920,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1701877959
    },
    {
        "content": "<p>Little remark though, now that I have the dumping algorithm done, I can create a binary that just dumps a derivation</p>\n<p>Sadly that binary is 91M, which seems huge.<br>\nIs there a way to reduce the binary size?</p>",
        "id": 406338006,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701878791
    },
    {
        "content": "<p>Okay so it turns out that the fact that I changed to <code>-&gt; Type</code> is a little anoying when doing proofs.</p>\n<p>Is there any other way to get around that ? Furthermore, I have trouble understanding <em>why</em> this proble arises in the first place, is there any reason why one could not eliminate a <code>T -&gt; Prop</code> to anything other than <code>Prop</code> ?</p>",
        "id": 406529893,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701951131
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"658705\">Thomas Vigouroux</span> has marked this topic as unresolved.</p>",
        "id": 406529915,
        "sender_full_name": "Notification Bot",
        "timestamp": 1701951139
    },
    {
        "content": "<p>There's one reason: it's inconsistent. <span aria-label=\"point down\" class=\"emoji emoji-1f447\" role=\"img\" title=\"point down\">:point_down:</span><br>\n<span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Dumping.20derivations.20of.20inductive.20predicate/near/406306261\">said</a>:</p>\n<blockquote>\n<p>Here's an example of what Eric is saying: If <code>h : p ∨ q</code>, you can't say \"Oh I'll map <code>h</code> to <code>0</code> if it came from <code>p</code> and to <code>1</code> if it came from <code>q</code>\" because it could come from both <code>p</code> and <code>q</code>!</p>\n</blockquote>",
        "id": 406530057,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701951199
    },
    {
        "content": "<p>Oh, right</p>",
        "id": 406530100,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701951215
    },
    {
        "content": "<p>So then, I have to just work around that in my proofs, right ?</p>",
        "id": 406530156,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701951241
    },
    {
        "content": "<p>I don't really know. It seems you're confusing proving and printing.</p>",
        "id": 406530464,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701951358
    },
    {
        "content": "<p>How so?<br>\nPrinting is just actually showing the object to the screen, proving is about constructing functions to build my objects, right?</p>",
        "id": 406530954,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701951540
    },
    {
        "content": "<p>Do you have an example of a proof where <code>Type</code> gets in the way?</p>",
        "id": 406530979,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701951549
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Dumping.20derivations.20of.20inductive.20predicate/near/406530979\">said</a>:</p>\n<blockquote>\n<p>Do you have an example of a proof where <code>Type</code> gets in the way?</p>\n</blockquote>\n<p>Yup, give me a sec and I'll send it here</p>",
        "id": 406531053,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701951573
    },
    {
        "content": "<p>It sounds like the problem is that there are proof steps that aren't actually part of your inductive type (eg Eq.mpr), and you're having to choose between having them appear in the print output, or not using them in the proofs</p>",
        "id": 406531226,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701951618
    },
    {
        "content": "<p>Hmm there's probably that</p>",
        "id": 406531420,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701951692
    },
    {
        "content": "<p>I'll send you the example in a few minutes</p>",
        "id": 406531466,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701951707
    },
    {
        "content": "<p>So basically I have this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lseq.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.BigOperators.Basic</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">Completeness</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Formula.weight</span><span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"bp\">⊥</span> <span class=\"bp\">|</span> <span class=\"bp\">#</span><span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">A</span> <span class=\"bp\">&amp;&amp;&amp;</span> <span class=\"n\">B</span> <span class=\"bp\">|</span> <span class=\"n\">A</span> <span class=\"bp\">⟹</span> <span class=\"n\">B</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">A.weight</span> <span class=\"bp\">+</span> <span class=\"n\">B.weight</span>\n<span class=\"bp\">|</span> <span class=\"n\">A</span> <span class=\"bp\">|||</span> <span class=\"n\">B</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">A.weight</span> <span class=\"bp\">+</span> <span class=\"n\">B.weight</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">setWeight</span> <span class=\"o\">(</span><span class=\"n\">S</span><span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Formula</span><span class=\"o\">):</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">S.sum</span> <span class=\"n\">Formula.weight</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">zeroWeight</span> <span class=\"o\">(</span><span class=\"n\">hC</span><span class=\"o\">:</span> <span class=\"n\">C.weight</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">Γ</span><span class=\"o\">:</span> <span class=\"n\">setWeight</span> <span class=\"bp\">Γ</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">):</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">cases</span> <span class=\"n\">C</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">bot</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">have</span> <span class=\"bp\">Γ</span><span class=\"n\">ne</span> <span class=\"o\">:</span> <span class=\"bp\">Γ.</span><span class=\"n\">Nonempty</span>\n    <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n    <span class=\"c\">/-</span>\n<span class=\"cm\">    tactic 'cases' failed, nested error:</span>\n<span class=\"cm\">    tactic 'induction' failed, recursor 'Exists.casesOn' can only eliminate into Prop</span>\n\n<span class=\"cm\">    case bot</span>\n<span class=\"cm\">    Γ: Finset Formula</span>\n<span class=\"cm\">    hΓ: setWeight Γ = 0</span>\n<span class=\"cm\">    h: Γ ⊨ Formula.bot</span>\n<span class=\"cm\">    hC: Formula.weight Formula.bot = 0</span>\n<span class=\"cm\">    Γne: Finset.Nonempty Γ</span>\n<span class=\"cm\">    x✝: ∃ x, x ∈ Γ</span>\n<span class=\"cm\">    ⊢ Sequent Γ Formula.bot</span>\n<span class=\"cm\">    -/</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">hA</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.Nonempty.bex</span> <span class=\"bp\">Γ</span><span class=\"n\">ne</span>\n  <span class=\"o\">}</span>\n  <span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">|</span> <span class=\"n\">and</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n  <span class=\"bp\">|</span> <span class=\"n\">or</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n  <span class=\"bp\">|</span> <span class=\"n\">imp</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Formula.weight</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hC</span>\n  <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Completeness</span>\n</code></pre></div>\n<p>I have removed some hypothesis (thus the sorry in the <code>have</code>)</p>",
        "id": 406532351,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701952017
    },
    {
        "content": "<p>(The actual proof does not work, but that's not the question here, right ?)</p>",
        "id": 406532875,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701952222
    },
    {
        "content": "<p>Ah, what you're seeing here is that by changing <code>Prop</code> into <code>Type</code>, you are now forcing yourself to use only constructive proofs (in a much stronger sense than usual); so using <code>Finset.Nonempty</code> isn't going to work for you, as you can't use it to \"construct\" a witness</p>",
        "id": 406533488,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701952483
    },
    {
        "content": "<p>Note the above isn't a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> as <code> Lseq.Basic</code> doesn't exist for me</p>",
        "id": 406533539,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701952508
    },
    {
        "content": "<p>Oh, right, sorry for that!<br>\nSo I have to construct it manually then, right?</p>",
        "id": 406560629,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701961100
    },
    {
        "content": "<p>Oh okay, so I have found <code>Finset.choose</code> which seems to help a litle, but my problem is that I can prove existence but now unicity...</p>",
        "id": 406562641,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701961665
    },
    {
        "content": "<p>Why is it that it's necessary to try to work with this inductive type as a <code>Type</code>? Tactics are themselves programs that manipulate the <code>Expr</code>s representing a terms, with no need to have the terms be able to be evaluated. (For example, the <code>tauto</code> tactic is able to automatically prove classical propositional logic.)</p>\n<p>If you really need to output terms and leave Lean, in principle you should be able to take a theorem and output a derivation. It will take some figuring out for how to transform the proof terms into the desired output.</p>\n<p>Something that's related is <code>#explode</code>, which is like <code>#print</code> but gives Fitch-style proof tables. <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/Explode.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/Explode.html</a></p>",
        "id": 406575834,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701965481
    },
    {
        "content": "<p>I guess you said you wanted to do intuitionistic propositional logic -- maybe using <code>Prop</code> is cheating, since it allows you to use classical logic to prove <code>Sequent</code>s exist</p>",
        "id": 406576049,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701965540
    },
    {
        "content": "<p>I am not sure I follow what you mean</p>",
        "id": 406576263,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1701965617
    }
]