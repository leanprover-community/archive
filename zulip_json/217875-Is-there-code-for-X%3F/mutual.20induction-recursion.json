[
    {
        "content": "<p>I am new to Lean and am starting by porting some existing Agda to Lean. I have just stumbled upon the fact that Lean mutual blocks are purely inductive or purely recursive. Unfortunately, I have several instances of the mixture in the Agda that I am porting. Is there an existing well-known solution to this problem in Lean?</p>",
        "id": 562979331,
        "sender_full_name": "Allen Brown",
        "timestamp": 1765379730
    },
    {
        "content": "<p>can you share some of the code?</p>",
        "id": 563038886,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765396912
    },
    {
        "content": "<p>I think that the following Agda snippet can be understood without its antecedent imports and opens:</p>\n<p>data Multiplicity : Set where<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/pull/0\">#0</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/1\">#1</a> #ω : Multiplicity</p>\n<p>mutual<br>\n  data Type : Set₁ where<br>\n    Pure : Set → Type<br>\n    Chan : Multiplicity → Multiplicity → Type → Type<br>\n    Pair : (t : Type) → (f : ⟦ t ⟧ → Type) → Type</p>\n<p>⟦_⟧ : Type → Set<br>\n  ⟦ Pure A ⟧     = A<br>\n  ⟦ Chan _ _ _ ⟧ = ⊤<br>\n  ⟦ Pair t f ⟧   = Σ ⟦ t ⟧ λ x → ⟦ f x ⟧</p>\n<p>The definition of the inductive type, Type, exhibits one call to  ⟦_⟧ while the definition of the recursive function, ⟦_⟧, matches on each of Type's constructors. Of course, my problem is that an analogous \"mutual\" construction using \"inductive\" and \"def\" is not available in L∃∀N.</p>",
        "id": 563174359,
        "sender_full_name": "Allen Brown",
        "timestamp": 1765455922
    },
    {
        "content": "<p>(see <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> and you can edit your post to make it look nicer)</p>",
        "id": 563179567,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765457651
    },
    {
        "content": "<p>I should have added that the analogous (to the Agda) L∃∀N code that I wanted to write is:</p>\n<p>mutual</p>\n<p>inductive πType : Type 1 where</p>\n<div class=\"codehilite\"><pre><span></span><code>| Pure : Type → πType\n\n| Chan : Multiplicity → Multiplicity → πType → πType\n</code></pre></div>\n\n<p>def blind : πType → Type 1</p>\n<div class=\"codehilite\"><pre><span></span><code>| Pure A =&gt; A\n\n| Chan _ _ _ =&gt; Unit\n</code></pre></div>\n\n<p>end</p>\n<p>In VS-Code this provokes the message</p>\n<p>invalid mutual block: either all elements of the block must be inductive/structure declarations, or they must all be definitions/theorems/abbrevs</p>",
        "id": 563201394,
        "sender_full_name": "Allen Brown",
        "timestamp": 1765463553
    },
    {
        "content": "<p>I suppose you mean this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Multiplicity</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">omega</span>\n\n<span class=\"kn\">mutual</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">πType</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">chan</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multiplicity</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">πType</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">πType</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">blind</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">πType</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">blind</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">πType</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">chan</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">blind</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">blind</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>The problem is that Lean doesn't support inductive-recursive constructions, however there are some workarounds to this problem, e.g. using an index:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Multiplicity</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">omega</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">πType</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">blind</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">πType</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">chan</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multiplicity</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">πType</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">πType</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">πType</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">πType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">πType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Sigma</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 563509410,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1765555506
    },
    {
        "content": "<p>Thank you for your suggestion. If I correctly understand your underlying insight, it is that rather than mutually defining an inductive type and a function by structural recursion on that type, instead define the graph of the function as an indexed inductive type. With that in mind, I believe that the following effectively reproduces the original Agda:</p>\n<p>inductive Multiplicity : Type where</p>\n<p>| ç0 | ç1 | çω</p>\n<p>inductive πType : (filtered : Type) → Type 1 where</p>\n<p>| pure (α : Type) : πType α</p>\n<p>| chan {α : Type} (a b : Multiplicity) (t : πType α) : πType Unit</p>\n<p>| pair {α : Type} {β : α → Type}</p>\n<p>(t : πType α) (f : (a : α) →  πType (β a)) : πType (Σ a : α, β a)</p>\n<p>def filter : πType α → Type</p>\n<p>| _ =&gt; α</p>\n<p>notation \"⟦\" t:arg \"⟧\" =&gt; filter t</p>",
        "id": 563778494,
        "sender_full_name": "Allen Brown",
        "timestamp": 1765792858
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a></p>",
        "id": 563789942,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765795875
    }
]