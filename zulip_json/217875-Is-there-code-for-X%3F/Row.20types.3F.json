[
    {
        "content": "<p>I'm trying to see if I can implement something like row types. Like a record whose fields can be manipulated, and where you can specify that a function takes a record that has at least fields <code>x : Int</code> and <code>y : ?any</code> and it will accept any arbitrary record type as long as it has those two fields.</p>\n<p>I'm trying to do this with a subtype of <code>Std.HashMap</code> that contains <code>String</code>s as keys and whose key labels and value types are listed in the type index, but finding it quite difficult to do this. Has someone tried doing something like this before?</p>",
        "id": 506813580,
        "sender_full_name": "aron",
        "timestamp": 1742413075
    },
    {
        "content": "<p>What is <code>?any</code>?</p>",
        "id": 506813873,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742413183
    },
    {
        "content": "<p>Oh just a placeholder for any type. My point being that unlike for the field <code>x</code> which must have the specific type <code>Int</code>, I don't care what type the field <code>y</code>has, just that the record has such a field</p>",
        "id": 506821670,
        "sender_full_name": "aron",
        "timestamp": 1742415969
    },
    {
        "content": "<p>This becomes more useful if you think of a function like <code>{ r | y : a } -&gt; a</code></p>\n<p>That's the Elm notation for row types. In that example the <code>r</code> represents the full record type, and the <code>a</code> is a type variable that unifies with whatever type the <code>y</code> field in its input value has</p>",
        "id": 506822575,
        "sender_full_name": "aron",
        "timestamp": 1742416310
    },
    {
        "content": "<p>Are you sure you want <em>any</em> type?</p>",
        "id": 506824158,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742416939
    },
    {
        "content": "<p><code>Std.HashMap Int (Sigma fun t : Type =&gt; t)</code> map integers to arbitrary types.</p>",
        "id": 506824703,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742417154
    },
    {
        "content": "<p>But since you are now effectively quantifying over all <code>Type</code>s this ends up being a <code>Type 1</code>.</p>",
        "id": 506825299,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742417364
    },
    {
        "content": "<p>ok so let's just worry about concrete types for now</p>",
        "id": 506826341,
        "sender_full_name": "aron",
        "timestamp": 1742417727
    },
    {
        "content": "<p>like how would you encode a row type that has <code>x : Int</code> and <code>y : String</code> fields but which can be extended with more fields</p>",
        "id": 506826748,
        "sender_full_name": "aron",
        "timestamp": 1742417862
    },
    {
        "content": "<p>If it's extended then it's not the same type anymore?</p>",
        "id": 506829372,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742418849
    },
    {
        "content": "<p>We have structure types</p>",
        "id": 506829386,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742418857
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">getInt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">x</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"\"</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">37</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- 0</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">getInt</span>\n<span class=\"c1\">-- 0</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"bp\">.</span><span class=\"n\">getInt</span>\n</code></pre></div>",
        "id": 506829737,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742419012
    },
    {
        "content": "<p>You could use typeclasses to achieve this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">HasField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">field</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">IncludesX</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasField</span><span class=\"w\"> </span><span class=\"n\">IncludesX</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">type_of</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">field</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">x</span>\n\n<span class=\"c1\">-- optional custom notation</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">noWs</span><span class=\"w\"> </span><span class=\"s2\">\".!\"</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span>\n<span class=\"kn\">macro_rules</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"bp\">.!$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">HasField</span><span class=\"bp\">.</span><span class=\"n\">field</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">quote</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">getId</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">actWithX</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasField</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.!</span><span class=\"n\">x</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IncludesX</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">actWithX</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n</code></pre></div>",
        "id": 506830913,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742419536
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> ah interesting, I don't think I knew you could extend structure types like that.</p>\n<p>But if I'm not mistaken, you still can't have a lean function that takes <em>any</em> structure type containing a particular field, can you? To say that my function <code>f</code> takes any structure containing a field <code>x : Int</code> and have it accept both <code>Foo</code>s and <code>Bar</code>s alike?</p>\n<p>E.g. this doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getX</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">x</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myX</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">getX</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\".\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mf\">0.1</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Whereas row polymorphism would let you do something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getX</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">x</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myX</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">getX</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\".\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mf\">0.1</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 507720882,
        "sender_full_name": "aron",
        "timestamp": 1742813806
    },
    {
        "content": "<p>My <code>[HasField α `x (fun _ =&gt; Int)]</code> above does exactly that</p>",
        "id": 507723903,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742814494
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> ooh interesting... <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span> I really like the <code>.!x</code> notation you've implemented!</p>\n<p>If I'm understanding your code correctly this requires you to implement a separate instance of <code>HasField</code> for every permutation of field name × field type you might want to use?</p>\n<p>Is there a way to automatically infer the return type at least so you only have to make a new instance per field name, not per name × type? I don't understand exactly how <code>outParam</code> works, but is it not possible to use it to make the return type be inferred from the getter function you use for <code>β</code> in each instance?</p>\n<p>I'm trying this but it doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">HasField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">field</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">IncludesX</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">IncludesX</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">field</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">x</span>\n<span class=\"c1\">--           ^^^</span>\n</code></pre></div>",
        "id": 507732718,
        "sender_full_name": "aron",
        "timestamp": 1742816433
    },
    {
        "content": "<p>Also, with your implementation you still have to manually make sure that the <code>Name</code> you want to use in the <code>.!&lt;name&gt;</code> notation matches the field name of the underlying structure you want to make a getter for, right?</p>",
        "id": 507732866,
        "sender_full_name": "aron",
        "timestamp": 1742816463
    },
    {
        "content": "<p>No, you can't avoid needing an instance for every (type, field) pair</p>",
        "id": 507746729,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742819584
    },
    {
        "content": "<p>But you can generate them automatically with a metaprogram</p>",
        "id": 507746758,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742819590
    },
    {
        "content": "<p>Edited above to use <code>type_of%</code> to make it a little clearer how to write such a program</p>",
        "id": 507746859,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742819611
    },
    {
        "content": "<p>oh that's really nice! mm ok I need to look more into metaprogramming in lean because if there are more of these little things that can make my code simpler and more general I want to know about them</p>",
        "id": 508016887,
        "sender_full_name": "aron",
        "timestamp": 1742907913
    }
]