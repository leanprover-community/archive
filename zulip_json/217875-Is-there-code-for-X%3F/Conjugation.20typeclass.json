[
    {
        "content": "<p>Is there any general way to represent adjunction-like types or families of types that have a meaningful \"conjugation\" operation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>y</mi><mrow><mo>‚àí</mo><mn>1</mn></mrow></msup><mi>x</mi><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y^{-1}xy</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0085em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">‚àí</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span>? <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Adjunction#doc\">docs#CategoryTheory.Adjunction</a> itself sort of counts, but universe levels in the category theory library are generally stricter than we'd like for something like this I think.</p>\n<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.conj#doc\">docs#Equiv.conj</a>, but that's restricted to a) <code>Equiv</code>s and b) single types that are c) inverse 'on the nose'.</p>\n<p>If not, is this something we want in Mathlib?</p>",
        "id": 532381517,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1754083763
    },
    {
        "content": "<p>in what kind of generality are you thinking? are you thinking of something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MulAction%3F#doc\">docs#MulAction?</a></p>",
        "id": 532381932,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1754084030
    },
    {
        "content": "<p>Extreme generality, one step up from a notational typeclass. Ideally it'd be something that lets the definition of 'inverse' and 'identity' be type-dependent, but I'd settle for just being built off of (families of)  <code>EquivLike</code>(s).</p>",
        "id": 532382318,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1754084250
    },
    {
        "content": "<p><code>MulAction</code> is definitely too narrow; at the least I'd like to be able to tag <code>ULift</code> and <code>Shrink</code>, for example, as well as any other similar \"morally a natural transformation between families of types\" structures.</p>",
        "id": 532382395,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1754084300
    },
    {
        "content": "<p>Are <code>ULift</code> and <code>Shrink</code> conjugations?</p>",
        "id": 532382529,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754084381
    },
    {
        "content": "<p>what are they conjugating?</p>",
        "id": 532382552,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754084395
    },
    {
        "content": "<p>exactly... i feel like i'm missing the common pattern?</p>",
        "id": 532382561,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1754084400
    },
    {
        "content": "<p>they aren't conjugations, but you can define conjugations on them and they're frequently used -- <code>Equiv.ulift (f (Equiv.ulift.symm ...)</code></p>",
        "id": 532382624,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1754084433
    },
    {
        "content": "<p>Can you define what a conjugation is?</p>",
        "id": 532382630,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754084434
    },
    {
        "content": "<p>are you looking for a functor?</p>",
        "id": 532382841,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754084545
    },
    {
        "content": "<p>Not quite... I think in categorical terms, the thing I'm looking for is basically a pseudonatural equivalence?<br>\n... Yeah, the general version is a pseudonatural equivalence, and the more specific version that does things up to strict equality is just a natural isomorphism</p>",
        "id": 532383112,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1754084714
    },
    {
        "content": "<p>e.g. the only thing stopping us from defining a natural isomorphism between the (<code>_root_.</code>) <code>Functor</code>s <code>ULift</code> and <code>ùü≠ Type</code> is universe levels</p>",
        "id": 532383219,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1754084769
    },
    {
        "content": "<p>actually I think the problem is your functors have different targets</p>",
        "id": 532383296,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754084826
    },
    {
        "content": "<p>In what sense?</p>",
        "id": 532383339,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1754084852
    },
    {
        "content": "<p>well I guess if it's <code>ULift.{u, u}</code> then they have the same target and you can define a natural isomorphism (which is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.uliftFunctorTrivial#doc\">docs#CategoryTheory.uliftFunctorTrivial</a>)</p>",
        "id": 532383455,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754084918
    },
    {
        "content": "<p>oh, well, yeah, but that's the universe level thing I'm talking about</p>",
        "id": 532383515,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1754084946
    },
    {
        "content": "<p>oh ok</p>",
        "id": 532383547,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754084960
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quandle#doc\">docs#Quandle</a> might be unfamiliar, but it's an algebraic structure encoding conjugation-like operations.</p>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quandle.Conj#doc\">docs#Quandle.Conj</a> is a group as a quandle, where the action is conjugation (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quandle.conj_act_eq_conj#doc\">docs#Quandle.conj_act_eq_conj</a>)</p>\n<p>Quandles (more generally racks) have enveloping groups (defined in that file), and it satisfies the adjunction <code>(R ‚Üí‚óÉ Quandle.Conj G) ‚âÉ (EnvelGroup R ‚Üí* G)</code>, and so there's a universal property that rack homomorphisms to the conjugation quandle of a group factors through the enveloping group of the rack.</p>\n<p>I don't remember what conditions you need for the homomorphism from a rack to the conjugation quandle of its enveloping group to be injective. But at least this all suggests that this is a generalization of conjugation. Maybe not the generalization you want, but it could be worth a look.</p>",
        "id": 532396442,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754093953
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Conjugation.20typeclass/near/532396442\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quandle#doc\">docs#Quandle</a> might be unfamiliar, but it's an algebraic structure encoding conjugation-like operations.</p>\n</blockquote>\n<p><del>now you're just making up words</del></p>\n<p>it does seem important to note that this encodes an action by some type <em>on the same type</em></p>",
        "id": 532448457,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1754136362
    },
    {
        "content": "<p>I believe it's Conway who was having fun making up words here</p>",
        "id": 532451315,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1754138701
    },
    {
        "content": "<p>\"Quandle\" is due to David Joyce. Conway was involved in the study a couple decades before, but used the word \"wrack\".</p>",
        "id": 532473641,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754155986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Conjugation.20typeclass/near/532448457\">said</a>:</p>\n<blockquote>\n<p>on the same type</p>\n</blockquote>\n<p>Yes, a quandle itself is a type acting on itself, but there's a more general structure (augmented quandles) where you have a group G acting on a set Q, with a function Q -&gt; G such that Q acting on itself via this function is a quandle. For example, if Q is a normal subgroup of G, G acts on Q by conjugation, and Q -&gt; G is the inclusion map, you've got an augmented quandle.</p>\n<p>Anyway, this is unlikely to help with Robert's question, even if there were some categorification of quandles that helps organize it. Re-reading the thread more carefully, I see the more general question might be 'how can we organize universe lifting/unlifting arguments better'.</p>",
        "id": 532474648,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754156931
    },
    {
        "content": "<p>At least partially, yes. I mean, I <em>also</em> want to have a nice interface for e.g. conjugating a functor by a family of categorical equivalences, but I don't mind if that turns out to be best handled separately.</p>",
        "id": 532495831,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1754176308
    }
]