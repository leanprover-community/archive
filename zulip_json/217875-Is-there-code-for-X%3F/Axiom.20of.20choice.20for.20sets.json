[
    {
        "content": "<p>I recently needed a choice function for existential statements restricted to sets, to wit:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">property</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n</code></pre></div>\n<p>Are these already in Mathlib by some other name?  Or is the use of sets as subtypes discouraged?</p>",
        "id": 508373804,
        "sender_full_name": "Terence Tao",
        "timestamp": 1743021799
    },
    {
        "content": "<p>Is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Exists.choose#doc\">docs#Exists.choose</a> not good enough?</p>",
        "id": 508374077,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743021899
    },
    {
        "content": "<p><code>Exists.choose</code> doesn't work for bounded existential quantifiers like Terry has here.</p>",
        "id": 508374392,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1743022006
    },
    {
        "content": "<p>There is nothing wrong with the definition, but in practice it is <code>⟨_, (Classical.choose_spec h).1⟩</code>. I would use it as an <code>abbrev</code> or something very reducible, since otherwise it is just a barrier to use all the existing library about <code>choose</code> and <code>choose_spec</code>.</p>",
        "id": 508374876,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1743022184
    },
    {
        "content": "<p>You can also just rewrite your existential as over the subtype:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">exists</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">exists_prop</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>then you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Exists.choose#doc\">docs#Exists.choose</a> as Aaron indicated.</p>",
        "id": 508375079,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1743022240
    },
    {
        "content": "<p>This would be my approach unless you need to have it repeatedly. And if that is the case, it would at least make me question whether there's a better way by avoiding subtypes (but perhaps there isn't).</p>",
        "id": 508375368,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1743022338
    },
    {
        "content": "<p>Note that if we had <code>Set.choose</code>, there would be no reason not to have <code>Finset.choose</code> too. <span aria-label=\"face with diagonal mouth\" class=\"emoji emoji-1fae4\" role=\"img\" title=\"face with diagonal mouth\">:face_with_diagonal_mouth:</span></p>",
        "id": 508376460,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1743022723
    },
    {
        "content": "<p>In my application, <code>α</code> is a <code>Preorder</code> but <code>s</code> <code>IsDirected</code>, and I need tools that only work on directed types (in particular, I want to use <code>Filter.atTop (α := s)</code>, which only behaves as I want because <code>IsDirected s</code>), so I wanted to work with the subtype <code>s</code> at least some of the time; on the other hand, many of my other tools most naturally live in <code>α</code>, in particular it is slightly more natural to quantify over <code>x ∈ s</code> rather than <code>x:s</code>.  I guess I could refactor more things to live in <code>s</code> rather than <code>α</code> and rely on the implicit type conversion, but I had the impression that the Mathlib style was to prefer to minimize the use of subtypes</p>",
        "id": 508377471,
        "sender_full_name": "Terence Tao",
        "timestamp": 1743023095
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Axiom.20of.20choice.20for.20sets/near/508376460\">said</a>:</p>\n<blockquote>\n<p>Note that if we had <code>Set.choose</code>, there would be no reason not to have <code>Finset.choose</code> too. <span aria-label=\"face with diagonal mouth\" class=\"emoji emoji-1fae4\" role=\"img\" title=\"face with diagonal mouth\">:face_with_diagonal_mouth:</span></p>\n</blockquote>\n<p>We already have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.choose#doc\">docs#Finset.choose</a>, which is unique choice for finsets</p>",
        "id": 508378162,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743023383
    },
    {
        "content": "<p>Just noting that we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DirectedOn#doc\">docs#DirectedOn</a>, although it doesn't solve your issue.</p>",
        "id": 508379472,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1743023916
    },
    {
        "content": "<p>You're not working with approximate identities in some function space, perchance, are you? Either way, you might have a look at some work I did in a similar situation when I developed the canonical approximate identity in a C⋆-algebra: see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CStarAlgebra.directedOn_nonneg_ball#doc\">docs#CStarAlgebra.directedOn_nonneg_ball</a> and the rest of that file.</p>",
        "id": 508379818,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1743024077
    },
    {
        "content": "<p>Terry, the other possibility if you work with the subset <code>s</code> enough as a subtype is to give it an actual <code>def</code>, especially if it has properties beyond <code>IsDirected</code>. Then you can set up enough API that it's not so painful to go back and forth between <code>s</code> and <code>α</code>, and you don't have to feel bad about doing so.</p>",
        "id": 508380717,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1743024464
    },
    {
        "content": "<p>The code is at <a href=\"https://github.com/teorth/equational_theories/pull/1135\">equational#1135</a>.  The task is basically completed and I should have no further need of directed sets in the rest of the project, so I'm happy with it as is (I made the one change of turning <code>Set.choose</code> into an <code>abbrev</code>, though.)</p>",
        "id": 508381062,
        "sender_full_name": "Terence Tao",
        "timestamp": 1743024600
    },
    {
        "content": "<p>There was a separate minor issue actually in that there wasn't quite a lemma to turn <code>IsChain</code> into <code>IsDirected</code> so I had to add that as well by gluing together three or four existing lemmas.</p>",
        "id": 508381273,
        "sender_full_name": "Terence Tao",
        "timestamp": 1743024660
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Axiom.20of.20choice.20for.20sets/near/508374876\">said</a>:</p>\n<blockquote>\n<p>There is nothing wrong with the definition, but in practice it is <code>⟨_, (Classical.choose_spec h).1⟩</code>. I would use it as an <code>abbrev</code> or something very reducible, since otherwise it is just a barrier to use all the existing library about <code>choose</code> and <code>choose_spec</code>.</p>\n</blockquote>\n<p>I'm not sure there is much \"all the existing library about <code>choose</code> and <code>choose_spec</code>\", in fact I think you just listed the entire library right there, those two functions. This is kind of the point of the axiom of choice, you know literally nothing other than the <code>choose_spec</code> lemma</p>",
        "id": 508381654,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743024790
    },
    {
        "content": "<p>it's not a huge burden to have a few variations on the interface with their own two functions</p>",
        "id": 508381723,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743024817
    },
    {
        "content": "<p>we already have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.choice#doc\">docs#Classical.choice</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.epsilon#doc\">docs#Classical.epsilon</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.indefiniteDescription#doc\">docs#Classical.indefiniteDescription</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.choose#doc\">docs#Classical.choose</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Exists.choose#doc\">docs#Exists.choose</a></p>",
        "id": 508381859,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743024859
    },
    {
        "content": "<p>and of course <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=zorn_subset#doc\">docs#zorn_subset</a> and friends</p>",
        "id": 508382322,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743025040
    },
    {
        "content": "<p>that one's actually not a function though, interestingly enough</p>",
        "id": 508382468,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743025092
    },
    {
        "content": "<p>ah, you're right</p>",
        "id": 508382545,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743025130
    },
    {
        "content": "<p>if it's a theorem then you really only need the one theorem in order to provide the complete API, for global choice principles you need the function and its axiom</p>",
        "id": 508382593,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743025149
    },
    {
        "content": "<p>unless the function has a dependent enough type like <code>Classical.indefiniteDescription</code> that no additional theorem is needed</p>",
        "id": 508382690,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743025197
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Axiom.20of.20choice.20for.20sets/near/508382468\">said</a>:</p>\n<blockquote>\n<p>that one's actually not a function though, interestingly enough</p>\n</blockquote>\n<p>btw, am i right that this means that mathlib's zorn's lemma does not imply mathlib's choice?</p>",
        "id": 508382846,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743025253
    },
    {
        "content": "<p>that is correct</p>",
        "id": 508382878,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743025270
    },
    {
        "content": "<p>curious</p>",
        "id": 508382903,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743025280
    },
    {
        "content": "<p>mathlib uses an axiom called \"global choice\" in the set theory literature, which is stronger than choice</p>",
        "id": 508382922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743025293
    },
    {
        "content": "<p>The equivalent statement in ZFC would be \"there is a proper class well ordering function on the universe\"</p>",
        "id": 508383089,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743025357
    },
    {
        "content": "<p>it means that anything choicy becomes not merely existing but definable</p>",
        "id": 508383145,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743025380
    },
    {
        "content": "<p>with ZFC alone it is still the case that there is no definable well order of the reals</p>",
        "id": 508383195,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743025404
    },
    {
        "content": "<p>They are very closely related though, and in particular they are equiconsistent. In a world where lean only assumed <code>Nonempty (∀A, Nonempty A -&gt; A)</code> which is equivalent to the (weak) axiom of choice, you could have a nullary typeclass <code>[Choicy.{u}]</code> defined as <code>∀A : Sort u, Nonempty A -&gt; A</code> and use it to define things as we normally do, and then you can discharge this assumption once you get to the \"end\", if it's a theorem you wanted to prove</p>",
        "id": 508383963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743025720
    },
    {
        "content": "<p>is there a version of zorn's lemma that's equivalent to global choice though? i.e. is it just a quirk of mathlib's formulation that they're not equivalent?</p>",
        "id": 508384241,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743025835
    },
    {
        "content": "<p>zorn's lemma is supposed to be equivalent to the axiom of choice, not global choice</p>",
        "id": 508384372,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743025896
    },
    {
        "content": "<p>if you wanted something equivalent to global choice then you need global zorn</p>",
        "id": 508384411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743025919
    },
    {
        "content": "<p>just replacing the existential quantifier with a subtype should do the trick</p>",
        "id": 508384504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743025946
    },
    {
        "content": "<p>another fun fact: HoTT is consistent with the axiom of choice, but inconsistent with global choice</p>",
        "id": 508384671,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743026032
    },
    {
        "content": "<p>iirc, similarly, global choice is consistent with weak univalence but not actual univalence?</p>",
        "id": 508384853,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743026103
    },
    {
        "content": "<p>don't quote me on that tho</p>",
        "id": 508384945,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743026142
    },
    {
        "content": "<p>I've never heard of weak univalence before, do you know where you heard about it?</p>",
        "id": 508385124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743026222
    },
    {
        "content": "<p>either on this zulip or on the lean discord (not xena)</p>",
        "id": 508385328,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743026309
    },
    {
        "content": "<p>i seem to recall it's <code>Equiv a b -&gt; a = b</code>?</p>",
        "id": 508385376,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743026335
    },
    {
        "content": "<p>I think that one is consistent with lean, it forces the cardinality model though which is a bit weird</p>",
        "id": 508385619,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743026418
    },
    {
        "content": "<p>i think <span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> was the one who mentioned it on the discord, they likely will know more</p>",
        "id": 508385820,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743026498
    },
    {
        "content": "<p>he won't hear you unless you speak up: <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span></p>",
        "id": 508386040,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743026585
    },
    {
        "content": "<p>i know, but i thought that since this is kinda off-topic, if you wanted to know more, you could dm him instead of polluting the thread</p>",
        "id": 508386527,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743026785
    },
    {
        "content": "<p>and if you are satisfied, no need to ping him</p>",
        "id": 508386591,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743026815
    },
    {
        "content": "<p>He's busy dealing with 30 incoming final Lean projects for his (formerly my) course :-)</p>",
        "id": 508403433,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743035703
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Axiom.20of.20choice.20for.20sets/near/508376460\">said</a>:</p>\n<blockquote>\n<p>Note that if we had <code>Set.choose</code>, there would be no reason not to have <code>Finset.choose</code> too. <span aria-label=\"face with diagonal mouth\" class=\"emoji emoji-1fae4\" role=\"img\" title=\"face with diagonal mouth\">:face_with_diagonal_mouth:</span></p>\n</blockquote>\n<p><code>Finset.choose</code> does not need the axiom of choice and is a computable def (but need <code>DecidablePred P</code> instead), since by definition one can enumerate elements of a <code>Finset</code> and check that if <code>P</code> is satisfied for them.</p>",
        "id": 508434240,
        "sender_full_name": "Jz Pan",
        "timestamp": 1743054773
    },
    {
        "content": "<p>My recollection is that <code>Equiv a b -&gt; a = b</code>, together with Quot.sound, implies global choice (and hence LEM), which Chris H told me about: <a href=\"https://gist.github.com/ChrisHughes24/730522373e1d95cbcf961625af5b8eab\">https://gist.github.com/ChrisHughes24/730522373e1d95cbcf961625af5b8eab</a>. I agree with Mario that it should be consistent and forces the cardinality model</p>",
        "id": 508485696,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1743073616
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Axiom.20of.20choice.20for.20sets/near/508434240\">said</a>:</p>\n<blockquote>\n<p><code>Finset.choose</code> does not need the axiom of choice and is a computable def</p>\n</blockquote>\n<p>When I made this comment, I was referring not to the existing <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.choose#doc\">docs#Finset.choose</a> (which takes a unique existential), but the analogue of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Exists.choose#doc\">docs#Exists.choose</a> and <code>Set.choose</code> which would simply take a bounded existential.</p>",
        "id": 508501442,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1743078280
    }
]