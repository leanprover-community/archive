[
    {
        "content": "<p>What progress (if any) has been made towards infinity categories in Lean?</p>",
        "id": 408745535,
        "sender_full_name": "Andrea Bourque",
        "timestamp": 1702956612
    },
    {
        "content": "<p>IIRC we have simplicial sets but nobody has needed infinity categories yet</p>",
        "id": 408784397,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702963764
    },
    {
        "content": "<p>I am also interested in  (infinity,1)-categories in lean.</p>",
        "id": 408933319,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1702992274
    },
    {
        "content": "<p>I don't think there's any obstruction to making the quasicategory definition</p>",
        "id": 408955371,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702999220
    },
    {
        "content": "<p>Here's a start that I created some time ago.</p>\n<ul>\n<li>As you can see, the definition can be made in a few lines.</li>\n<li>The first minor objective would be to show that the nerve of a 1-category is a quasicategory. Back then this was quite annoying. But recently <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> has added quite some API for chains of arrows in categories. So with a bit of refactoring and gluing, this should now be quite doable.</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.AlgebraicTopology.SimplicialSet</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.AlgebraicTopology.Nerve</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># Kan complexes and quasicategories</span>\n\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span> <span class=\"n\">CategoryTheory.Limits</span> <span class=\"n\">Opposite</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Simplicial</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">SSet</span>\n\n<span class=\"sd\">/-- A *Kan complex* is a simplicial set `S` if it satisfies the following horn-filling condition:</span>\n<span class=\"sd\">for every `n : ℕ` and `0 ≤ i ≤ n`,</span>\n<span class=\"sd\">every map of simplicial sets `σ₀ : Λ[n, i] → S` can be extended to a map `σ : Δ[n] → S`. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">Kan_complex</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">SSet</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">hornFilling</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">⦄</span> <span class=\"o\">⦃</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)⦄</span> <span class=\"o\">(</span><span class=\"n\">σ₀</span> <span class=\"o\">:</span> <span class=\"bp\">Λ</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"bp\">⟶</span> <span class=\"n\">S</span><span class=\"o\">),</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"bp\">Δ</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"bp\">⟶</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">σ₀</span> <span class=\"bp\">=</span> <span class=\"n\">hornInclusion</span> <span class=\"n\">n</span> <span class=\"n\">i</span> <span class=\"bp\">≫</span> <span class=\"n\">σ</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- A *quasicategory* is a simplicial set `S` if it satisfies the following horn-filling condition:</span>\n<span class=\"sd\">for every `n : ℕ` and `0 &lt; i &lt; n`,</span>\n<span class=\"sd\">every map of simplicial sets `σ₀ : Λ[n, i] → S` can be extended to a map `σ : Δ[n] → S`.</span>\n\n<span class=\"sd\">[Kerodon, 003A] -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">quasicategory</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">SSet</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">hornFilling</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">⦄</span> <span class=\"o\">⦃</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)⦄</span> <span class=\"o\">(</span><span class=\"n\">σ₀</span> <span class=\"o\">:</span> <span class=\"bp\">Λ</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"bp\">⟶</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_h0</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_hn</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Fin.last</span> <span class=\"n\">n</span><span class=\"o\">),</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"bp\">Δ</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"bp\">⟶</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">σ₀</span> <span class=\"bp\">=</span> <span class=\"n\">hornInclusion</span> <span class=\"n\">n</span> <span class=\"n\">i</span> <span class=\"bp\">≫</span> <span class=\"n\">σ</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Every Kan complex is a quasicategory.</span>\n\n<span class=\"sd\">[Kerodon, 003C] -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">SSet</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Kan_complex</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">quasicategory</span> <span class=\"n\">S</span> <span class=\"n\">where</span>\n  <span class=\"n\">hornFilling</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">σ₀</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">Kan_complex.hornFilling</span> <span class=\"n\">σ₀</span>\n\n<span class=\"c1\">-- TODO: move</span>\n<span class=\"kd\">instance</span> <span class=\"n\">fin_two_zero_le_one</span> <span class=\"o\">:</span> <span class=\"n\">ZeroLEOneClass</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">zero_le_one</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">nerve</span>\n\n<span class=\"c1\">-- TODO: move</span>\n<span class=\"sd\">/-- A constructor for `n`-simplices of the nerve of a category,</span>\n<span class=\"sd\">by specifying `n+1` objects and a morphism between each of the `n` pairs of adjecent objects. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">nerve.mk</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mor</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">obj</span> <span class=\"n\">i.castSucc</span> <span class=\"bp\">⟶</span> <span class=\"n\">obj</span> <span class=\"n\">i.succ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">nerve</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">])</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- TODO: move</span>\n<span class=\"kd\">def</span> <span class=\"n\">nerve.source</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">nerve</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]))</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">f.obj</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- TODO: move</span>\n<span class=\"kd\">def</span> <span class=\"n\">nerve.target</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">nerve</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]))</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">f.obj</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- TODO: move</span>\n<span class=\"kd\">def</span> <span class=\"n\">nerve.arrow</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">nerve</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]))</span> <span class=\"o\">:</span> <span class=\"n\">source</span> <span class=\"n\">f</span> <span class=\"bp\">⟶</span> <span class=\"n\">target</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n  <span class=\"n\">f.map</span> <span class=\"o\">(</span><span class=\"n\">homOfLE</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">zero_le_one</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- TODO: move</span>\n<span class=\"kn\">open</span> <span class=\"n\">SimplexCategory</span> <span class=\"k\">in</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">nerve.source_eq</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">nerve</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]))</span> <span class=\"o\">:</span>\n    <span class=\"n\">source</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">nerve</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">δ</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">op</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- TODO: move</span>\n<span class=\"kn\">open</span> <span class=\"n\">SimplexCategory</span> <span class=\"k\">in</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">nerve.target_eq</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">nerve</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]))</span> <span class=\"o\">:</span>\n    <span class=\"n\">target</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">nerve</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">δ</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">op</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">nerve</span>\n\n<span class=\"sd\">/-- The nerve of a category is a quasicategory.</span>\n\n<span class=\"sd\">[Kerodon, 0032] -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">quasicategory</span> <span class=\"o\">(</span><span class=\"n\">nerve</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">hornFilling</span> <span class=\"n\">n</span> <span class=\"n\">i</span> <span class=\"n\">σ₀</span> <span class=\"n\">h₀</span> <span class=\"n\">hₙ</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">horn</span> <span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span> <span class=\"o\">:=</span>\n      <span class=\"k\">fun</span> <span class=\"n\">j</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span><span class=\"n\">SimplexCategory.Hom.mk</span> <span class=\"o\">(</span><span class=\"n\">OrderHom.const</span> <span class=\"n\">_</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">swap</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">unop_op</span><span class=\"o\">,</span> <span class=\"n\">SimplexCategory.len_mk</span><span class=\"o\">,</span> <span class=\"n\">asOrderHom</span><span class=\"o\">,</span> <span class=\"n\">SimplexCategory.Hom.toOrderHom_mk</span><span class=\"o\">,</span>\n        <span class=\"n\">OrderHom.const_coe_coe</span><span class=\"o\">,</span> <span class=\"n\">Set.union_singleton</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Set.univ_subset_iff</span><span class=\"o\">,</span> <span class=\"n\">Set.subset_def</span><span class=\"o\">,</span>\n        <span class=\"n\">Set.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_insert_iff</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_range</span><span class=\"o\">,</span> <span class=\"n\">Function.const_apply</span><span class=\"o\">,</span> <span class=\"n\">exists_const</span><span class=\"o\">,</span>\n        <span class=\"n\">forall_true_left</span><span class=\"o\">,</span> <span class=\"n\">not_forall</span><span class=\"o\">]</span>\n      <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n      <span class=\"bp\">·</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">Fin.last</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">hₙ.ne'</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h₀.trans</span> <span class=\"n\">hₙ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne</span><span class=\"o\">]</span>\n      <span class=\"bp\">·</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h₀.ne</span><span class=\"o\">]</span>\n    <span class=\"k\">let</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"bp\">Δ</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"bp\">⟶</span> <span class=\"n\">nerve</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n      <span class=\"n\">yonedaEquiv.symm</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">nerve.mk</span> <span class=\"n\">C</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">j</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">j</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">use</span> <span class=\"n\">σ</span>\n    <span class=\"n\">swap</span>\n    <span class=\"bp\">·</span> <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">σ₀.app</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">j</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n    <span class=\"n\">swap</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">horn</span> <span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">])</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">SimplexCategory.Hom.mk</span> <span class=\"o\">⟨</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">j.castSucc</span><span class=\"o\">,</span> <span class=\"n\">j.succ</span><span class=\"o\">],</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">σ₀.app</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">])</span> <span class=\"n\">e</span>\n    <span class=\"n\">swap</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Fin.monotone_iff_le_succ</span><span class=\"o\">]</span>\n      <span class=\"n\">dsimp</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Matrix.cons_val_succ</span><span class=\"o\">,</span> <span class=\"n\">Matrix.cons_val_fin_one</span><span class=\"o\">,</span> <span class=\"n\">Fin.le_iff_val_le_val</span><span class=\"o\">,</span> <span class=\"n\">Fin.val_succ</span><span class=\"o\">,</span>\n        <span class=\"n\">Fin.forall_fin_one</span><span class=\"o\">,</span> <span class=\"n\">Fin.castSucc_zero</span><span class=\"o\">,</span> <span class=\"n\">Matrix.cons_val_zero</span><span class=\"o\">,</span> <span class=\"n\">Fin.coe_castSucc</span><span class=\"o\">,</span>\n        <span class=\"n\">le_add_iff_nonneg_right</span><span class=\"o\">]</span>\n    <span class=\"n\">swap</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">unop_op</span><span class=\"o\">,</span> <span class=\"n\">SimplexCategory.len_mk</span><span class=\"o\">,</span> <span class=\"n\">asOrderHom</span><span class=\"o\">,</span> <span class=\"n\">SimplexCategory.Hom.toOrderHom_mk</span><span class=\"o\">,</span>\n        <span class=\"n\">OrderHom.const_coe_coe</span><span class=\"o\">,</span> <span class=\"n\">Set.union_singleton</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Set.univ_subset_iff</span><span class=\"o\">,</span> <span class=\"n\">Set.subset_def</span><span class=\"o\">,</span>\n        <span class=\"n\">Set.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_insert_iff</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_range</span><span class=\"o\">,</span> <span class=\"n\">Function.const_apply</span><span class=\"o\">,</span> <span class=\"n\">exists_const</span><span class=\"o\">,</span>\n        <span class=\"n\">forall_true_left</span><span class=\"o\">,</span> <span class=\"n\">not_forall</span><span class=\"o\">,</span> <span class=\"n\">not_or</span><span class=\"o\">,</span> <span class=\"n\">unop_op</span><span class=\"o\">,</span> <span class=\"n\">not_exists</span><span class=\"o\">,</span> <span class=\"n\">Fin.forall_fin_two</span><span class=\"o\">]</span>\n      <span class=\"n\">dsimp</span>\n      <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">j.castSucc</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n      <span class=\"bp\">·</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">Fin.last</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n        <span class=\"n\">cases</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Nat.zero_eq</span><span class=\"o\">,</span> <span class=\"n\">Fin.last</span><span class=\"o\">,</span> <span class=\"n\">Fin.zero_eta</span><span class=\"o\">,</span> <span class=\"n\">Fin.not_lt_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hₙ</span>\n        <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hₙ.ne'</span><span class=\"o\">,</span> <span class=\"n\">not_false_eq_true</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h₀.trans</span> <span class=\"n\">hₙ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne</span><span class=\"o\">,</span> <span class=\"n\">Fin.succ_eq_last_succ</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">]</span>\n          <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Fin.lt_iff_val_lt_val</span><span class=\"o\">,</span> <span class=\"n\">Fin.val_last</span><span class=\"o\">,</span> <span class=\"n\">Fin.val_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₀</span> <span class=\"n\">hₙ</span>\n          <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Fin.castSucc_eq_zero_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n          <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">Fin.last</span><span class=\"o\">,</span> <span class=\"n\">Fin.ext_iff</span><span class=\"o\">,</span> <span class=\"n\">Fin.val_zero</span><span class=\"o\">]</span>\n          <span class=\"n\">linarith</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h₀</span><span class=\"o\">,</span> <span class=\"n\">hₙ</span><span class=\"o\">]</span>\n      <span class=\"bp\">·</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h₀.ne</span><span class=\"o\">,</span> <span class=\"n\">Fin.succ_ne_zero</span> <span class=\"n\">j</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"k\">let</span> <span class=\"n\">φ</span> <span class=\"o\">:=</span> <span class=\"n\">nerve.arrow</span> <span class=\"n\">f</span>\n      <span class=\"c1\">-- let δ := fun (i : Fin 2) ↦ (nerve C).map (SimplexCategory.δ i).op</span>\n      <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">horn</span> <span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]))</span> <span class=\"bp\">↦</span>\n        <span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">σ₀.naturality</span> <span class=\"o\">(</span><span class=\"n\">SimplexCategory.δ</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"o\">)</span> <span class=\"n\">e</span>\n      <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">types_comp</span><span class=\"o\">,</span> <span class=\"n\">Function.comp</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n      <span class=\"n\">refine</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">≫</span> <span class=\"n\">φ</span> <span class=\"bp\">≫</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n      <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nerve.source_eq</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">this</span><span class=\"o\">]</span>\n        <span class=\"n\">apply</span> <span class=\"n\">eqToHom</span>\n        <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">horn</span> <span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">SimplexCategory.δ</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"n\">j.castSucc</span>\n        <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n        <span class=\"n\">apply</span> <span class=\"n\">Subtype.ext</span>\n        <span class=\"n\">apply</span> <span class=\"n\">SimplexCategory.Hom.ext'</span>\n        <span class=\"n\">apply</span> <span class=\"n\">OrderHom.ext</span>\n        <span class=\"n\">apply</span> <span class=\"n\">funext</span>\n        <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">Fin.forall_fin_one</span><span class=\"o\">]</span>\n        <span class=\"n\">rfl</span>\n      <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nerve.target_eq</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">this</span><span class=\"o\">]</span>\n        <span class=\"n\">apply</span> <span class=\"n\">eqToHom</span>\n        <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">horn</span> <span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">SimplexCategory.δ</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"n\">j.succ</span>\n        <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n        <span class=\"n\">apply</span> <span class=\"n\">Subtype.ext</span>\n        <span class=\"n\">apply</span> <span class=\"n\">SimplexCategory.Hom.ext'</span>\n        <span class=\"n\">apply</span> <span class=\"n\">OrderHom.ext</span>\n        <span class=\"n\">apply</span> <span class=\"n\">funext</span>\n        <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">Fin.forall_fin_one</span><span class=\"o\">]</span>\n        <span class=\"n\">rfl</span>\n    <span class=\"n\">apply</span> <span class=\"n\">NatTrans.ext</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">funext</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Opposite.rec</span>\n    <span class=\"n\">apply</span> <span class=\"n\">SimplexCategory.rec</span>\n    <span class=\"n\">intro</span> <span class=\"n\">m</span>\n    <span class=\"n\">ext</span> <span class=\"n\">f</span>\n    <span class=\"n\">refine</span> <span class=\"n\">CategoryTheory.Functor.ext</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span>\n      <span class=\"gr\">sorry</span>\n    <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">SSet</span>\n</code></pre></div>",
        "id": 408956334,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1702999514
    },
    {
        "content": "<p>Pinging <span class=\"user-mention\" data-user-id=\"488744\">@Jack McKoen</span> who is working on related things right now</p>",
        "id": 408964670,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1703002045
    },
    {
        "content": "<p>I think the best plan is to formalize lifting properties (the <a href=\"https://ncatlab.org/nlab/show/Joyal-Tierney+calculus\">Joyal–Tierney calculus</a>) and maybe weak factorization systems in general categories since they will be repeatedly used in quasicat theory. Are those in mathlib yet?</p>",
        "id": 409190692,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1703080525
    },
    {
        "content": "<p>Several people have been working on WFS. I lost track of what the current status is...</p>",
        "id": 409193070,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1703081306
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"404479\">@Trebor Huang</span>: the basic definitions of lifting properties are in mathlib (<code>CategoryTheory.LiftingProperties</code>).</p>",
        "id": 409237134,
        "sender_full_name": "Joël Riou",
        "timestamp": 1703095509
    },
    {
        "content": "<p>Ah, when I typed in \"lifting\" in the docs searchbar the suggestions are dominated by <code>liftRing</code> so I thought there was none</p>",
        "id": 409309361,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1703134000
    },
    {
        "content": "<p>Is this some search priority issue to be fixed?</p>",
        "id": 409309379,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1703134016
    },
    {
        "content": "<p>The branch <code>quasicat</code> now contains a sorry-free proof that the nerve of a category is a quasicategory.</p>",
        "id": 410550355,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1703947538
    },
    {
        "content": "<p>It was a pretty nasty fight with DTT.</p>",
        "id": 410550410,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1703947572
    },
    {
        "content": "<p>What about DTT made it tough? Maybe we should rethink the simplicial API?</p>",
        "id": 410551781,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1703948968
    },
    {
        "content": "<p>An <code>n</code>-simplex of the nerve is a functor from <code>Fin (n+1)</code> to <code>C</code>. Now you can map <code>i -&gt; (i+1)</code> through such a functor to get a morphism in <code>C</code>. That same morphism will also be a <code>1</code>-simplex. But not in a defeq way.</p>",
        "id": 410552555,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1703949653
    },
    {
        "content": "<p>Aha. But if we use some inductive analogue of <code>Fin</code> (I don’t know if <code>Fin’</code> will quite work) then we should get good defeq behavior</p>",
        "id": 410552853,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1703949866
    },
    {
        "content": "<p>Using functors from Fin to talk about sequences of composable morphisms is a nice trick, but if it’s tedious to use, then perhaps we should come up with a bespoke inductive definition after all</p>",
        "id": 410553025,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1703950007
    },
    {
        "content": "<p>Maybe. I think <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> already wrote a very good API for <code>ComposableArrows</code></p>",
        "id": 410553373,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1703950307
    },
    {
        "content": "<p>I think I rather want to explore playing out the whole proof in the arrow category of <code>C</code>. I think it would save on a whole lot of <code>eqToHom</code>s.</p>",
        "id": 410553435,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1703950346
    },
    {
        "content": "<p>Anyway: <a href=\"https://github.com/leanprover-community/mathlib4/pull/9357\">#9357</a> is the first PR, containing the bare definitions of Kan complex and quasicategory.</p>",
        "id": 410553452,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1703950376
    },
    {
        "content": "<p>Left a few comments</p>",
        "id": 410554216,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1703951077
    },
    {
        "content": "<p>Let me ping <span class=\"user-mention\" data-user-id=\"488744\">@Jack McKoen</span> again since he also had a def of a Kan complex on his branch</p>",
        "id": 410554359,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1703951190
    },
    {
        "content": "<p>We should also write a delaborator for</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">scoped</span><span class=\"o\">[</span><span class=\"n\">Simplicial</span><span class=\"o\">]</span> <span class=\"kd\">notation</span> <span class=\"s2\">\"Λ[\"</span> <span class=\"n\">n</span> <span class=\"s2\">\", \"</span> <span class=\"n\">i</span> <span class=\"s2\">\"]\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">SSet.horn</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">i</span>\n</code></pre></div>",
        "id": 410554558,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1703951388
    },
    {
        "content": "<p>If we change <code>notation</code> to <code>notation3</code> does it make things better? I seem to recall <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> saying something along those lines.</p>",
        "id": 410554640,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1703951461
    },
    {
        "content": "<p>Thanks! That worked: <a href=\"https://github.com/leanprover-community/mathlib4/pull/9358\">#9358</a></p>",
        "id": 410555489,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1703952223
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/9360\">#9360</a> provides an alternative hornfilling condition</p>",
        "id": 410567512,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1703964687
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/9362\">#9362</a> adds some trivial prerequisites on cardinalities of explicit finsets.</p>",
        "id": 410571324,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1703968445
    },
    {
        "content": "<p>I left a minicomment and delegated it.</p>",
        "id": 410572273,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1703969462
    },
    {
        "content": "<p>Thanks</p>",
        "id": 410573311,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1703970490
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/9363\">#9363</a> is the next one in line. But it depends on the finset-cardinalities PR.</p>",
        "id": 410573326,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1703970519
    },
    {
        "content": "<ul>\n<li><del> <a href=\"https://github.com/leanprover-community/mathlib4/pull/9357\">#9357</a> basic definitions </del></li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/9360\">#9360</a> alternative horn filling condition</li>\n<li><del> <a href=\"https://github.com/leanprover-community/mathlib4/pull/9362\">#9362</a> bounds on cardinalities of explicit finsets </del></li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/9363\">#9363</a> constructors for subsimplices of horns</li>\n</ul>",
        "id": 410700870,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704095076
    },
    {
        "content": "<p>deleted message</p>",
        "id": 411996780,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1704827647
    },
    {
        "content": "<p>(Sorry ignore the above, I missed a comment above)</p>",
        "id": 411997359,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1704827893
    },
    {
        "content": "<p>Maybe it would be nice to have a <code>github  project</code> for quasicategories, to track progress in this direction and list the important steps that would need to be taken to develop their theory. Do people think this is an appropriate of these projects? If so I am happy to put some work into to developing one - although I think maintainers  have to create them on Mathlib4.</p>",
        "id": 421515290,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1707938358
    },
    {
        "content": "<p>I think this is a good idea. But we should select a good “target” to help coordinate work. The infinity categorical yoneda lemma is a possible target</p>",
        "id": 421516062,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707938628
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Agreed, and I think the infinity-cat Yoneda lemma seems a good target. Another possible one is the definition of a infinity-topos.  But Yoneda is probably better.</p>",
        "id": 421518030,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1707939248
    },
    {
        "content": "<p>I made an empty project here: <a href=\"https://github.com/orgs/leanprover-community/projects/18\">https://github.com/orgs/leanprover-community/projects/18</a></p>",
        "id": 421518182,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707939308
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Thanks :)</p>",
        "id": 421518430,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1707939397
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Could I possibly have write access for the project? Doesn't seem to let me edit it by default.</p>",
        "id": 421519348,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1707939762
    },
    {
        "content": "<p>hmmm... I don't remember how to do that. Can another maintainer help out?</p>",
        "id": 421519516,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707939833
    },
    {
        "content": "<p>Oh ok I see how to do it now. What's your github username <span class=\"user-mention\" data-user-id=\"653351\">@Joseph Tooby-Smith</span> ?</p>",
        "id": 421519669,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707939876
    },
    {
        "content": "<p>jstoobysmith</p>",
        "id": 421519711,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1707939896
    },
    {
        "content": "<p>you should have an invite in your inbox</p>",
        "id": 421519790,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707939928
    },
    {
        "content": "<p>Yep that worked! Thanks <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span></p>",
        "id": 421520085,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1707940035
    },
    {
        "content": "<p>It's a nontrivial result that the functors between ∞-categories form an ∞-category (and, I guess, necessary for the statement of the Yoneda lemma). Maybe that can be added to the list in the github project</p>",
        "id": 421532159,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1707944529
    },
    {
        "content": "<p>There’s also the question of managing universes… for example, maybe we want the category of anima to have zero cells in level 1, and all higher cells in level 0?</p>",
        "id": 421532737,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707944759
    },
    {
        "content": "<p>The current simplicial sets framework doesn’t make this easy</p>",
        "id": 421532802,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707944772
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"519559\">@Dagur Asgeirsson</span> I added this....on which note:</p>\n<p>Do you (and <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> ) think the format of the list is ok/have any suggestions?<br>\n I added Kerodon tags to make it easier to find references to things. Although I'm not sure about the stability of these tags.</p>",
        "id": 421534715,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1707945596
    },
    {
        "content": "<p>Re functors: IIRC there’s an adjunction between quasicats and ssets and it’s useful for constructing the qcat structure on functors, right? I guess this adjunction could be part of the list as well.</p>",
        "id": 421534852,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707945653
    },
    {
        "content": "<p>Kerodon tags are a great idea!</p>",
        "id": 421534906,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707945676
    },
    {
        "content": "<p>Can the Kerodon tags be linkified?</p>",
        "id": 421535219,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1707945820
    },
    {
        "content": "<p>It doesn't appear so in any nice way from the UI :(</p>",
        "id": 421536233,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1707946239
    },
    {
        "content": "<p>The format of the list is fine I think, I guess it will evolve over time. This GitHub projects UI seems kind of limited though</p>",
        "id": 421536311,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1707946274
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span> You can link to them in the comments of the entry. E.g. if you click the title of the first entry <code>Define: homotopy of morphisms in an infinity-cat</code>, I've put a link there.</p>",
        "id": 421536349,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1707946293
    },
    {
        "content": "<p>Thanks! </p>\n<p>It would make your life easier if you could make a template and access the fields as variables though</p>",
        "id": 421536770,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1707946468
    },
    {
        "content": "<p>How can I \"claim\" one of these goals?</p>",
        "id": 421541330,
        "sender_full_name": "Jack McKoen",
        "timestamp": 1707948400
    },
    {
        "content": "<p>Assign yourself?</p>",
        "id": 421541425,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1707948459
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"488744\">@Jack McKoen</span> you might need write access... if so, let me know.</p>",
        "id": 421541465,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707948480
    },
    {
        "content": "<p>I think I need write access (unless I just can't find the option on mobile)</p>",
        "id": 421541844,
        "sender_full_name": "Jack McKoen",
        "timestamp": 1707948645
    },
    {
        "content": "<p>you should have access now.</p>",
        "id": 421541923,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707948690
    },
    {
        "content": "<p>Thanks, works now</p>",
        "id": 421542079,
        "sender_full_name": "Jack McKoen",
        "timestamp": 1707948764
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"488744\">@Jack McKoen</span>  <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>  I'd like to mention that these efforts will help a lot with my work with Jiazhen Xia available here:</p>\n<p><a href=\"https://github.com/linlib/TheWhiteheadTheoremandTwoVariations/blob/main/TheWhiteheadTheoremandTwoVariations.pdf\">https://github.com/linlib/TheWhiteheadTheoremandTwoVariations/blob/main/TheWhiteheadTheoremandTwoVariations.pdf</a></p>\n<p>Is it ok if I lobby for a few things?</p>\n<p>I think it is a good idea to use a certain four categories:</p>\n<ol>\n<li><code>∞-Cat : Category quasicategory</code></li>\n<li><code>∞-Grpd : Category Kan_complex</code></li>\n<li><code>D(∞-Cat) : Category quasicategory</code></li>\n<li><code>D(∞-Grpd) : Category Kan_complex</code></li>\n</ol>\n<p>The second two can be created from the first two using the work in Jack's presentation at Lean together.  The repository I linked to contains a definition of the first two in the file of <code>TheWhiteheadTheoremandTwoVariations.lean</code>.</p>\n<p>I wonder if down the road, having these categories and the definitions of functors and natural transformations that they allow for would save a lot of effort. I'm thinking about how the components of each of the functors on the first pages of the files <a href=\"https://github.com/linlib/TheWhiteheadTheoremandTwoVariations/blob/main/TheWhiteheadTheoremandTwoVariations.pdf\">here</a> and <a href=\"https://github.com/linlib/ThePuppeSequenceandTwoVariations/blob/main/ThePuppeSequenceandTwoVariations.pdf\">here</a> could be more cumbersome without forming these categories.</p>\n<p>P.S. Jiazhen and I are excited to be submitting our definition of CW-complexes and proof of the Whitehead theorem within a few weeks. We are also working on two variations of the Puppe sequence. Together, these six theorems give an alternative definition of ∞-Cat.</p>",
        "id": 421596129,
        "sender_full_name": "Dean Young",
        "timestamp": 1707982300
    },
    {
        "content": "<p><a href=\"https://github.com/linlib/ThePuppeSequenceandTwoVariations/blob/main/ThePuppeSequenceandTwoVariations.pdf\">https://github.com/linlib/ThePuppeSequenceandTwoVariations/blob/main/ThePuppeSequenceandTwoVariations.pdf</a></p>",
        "id": 421596423,
        "sender_full_name": "Dean Young",
        "timestamp": 1707982466
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>  Jiazhen and I would also be greatly excited to join this project. Would it be ok if we get write privileges and tackle a few of these goals?</p>",
        "id": 421597258,
        "sender_full_name": "Dean Young",
        "timestamp": 1707982955
    },
    {
        "content": "<p>Can Jiazhen and I take 11 and 12? We were already going to show those in the Whitehead theorem repo. Maybe  you could give write privileges to <code>linlib</code> and  <code>jzxia</code>.</p>",
        "id": 421598741,
        "sender_full_name": "Dean Young",
        "timestamp": 1707983796
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"488744\">@Jack McKoen</span>  I have already done some work in the defining homotopies direction.  See: </p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/10006\">https://github.com/leanprover-community/mathlib4/pull/10006</a></p>\n<p>I'm fairly new to lean so it's a bit of a mess though. In particular, the above uses:</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/9935\">https://github.com/leanprover-community/mathlib4/pull/9935</a></p>\n<p>which is now waiting on another pull-request (plus some tidying on my part).</p>",
        "id": 421637777,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1707998365
    },
    {
        "content": "<p>Unrelated to the above: All the goals in this project now have links to the appropriate Kerodon page in their comments (click the title of the goal to see the comments).</p>",
        "id": 421639732,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1707999082
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"559197\">@Dean Young</span> I'm happy to give you write access to the project, but I would need your (and Jiazhen's) github user name(s).</p>",
        "id": 421642879,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1708000168
    },
    {
        "content": "<p>Oh, I just noticed your second message with the user names. I'll add those now.</p>",
        "id": 421643329,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1708000301
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Thank you! We have access now, and we are excited to work on 11 and 12 (space of morphisms).</p>",
        "id": 421645817,
        "sender_full_name": "Jiazhen Xia",
        "timestamp": 1708001133
    },
    {
        "content": "<p>Let me just mention here that there is a proof in the file <code>Wombat.lean</code> of the <code>quasicat</code> branch that the nerve of a category is a quasicategory. I currently don't have the time to PR this to mathlib (maybe sometime in the future?). But anybody interested should feel free to PR (parts of it). I don't claim any copyright etc yaddayadda</p>",
        "id": 421647271,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1708001647
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"653351\">@Joseph Tooby-Smith</span> Given what you already have done I think it makes sense for you to take care of 1 and 2. I'll work on something else :)</p>",
        "id": 421694633,
        "sender_full_name": "Jack McKoen",
        "timestamp": 1708014840
    },
    {
        "content": "<p>I created a draft PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/16458\">#16458</a><br>\nIt contains ~460 lines of code, proving that the nerve of a category is a quasicategory.<br>\nIt needs some massaging to make it mathlib ready, but I don't have much time for that atm.<br>\nIf you like this topic, please feel free to adopt this PR.</p>",
        "id": 467332867,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725387918
    },
    {
        "content": "<p>Ping <span class=\"user-mention\" data-user-id=\"488744\">@Jack McKoen</span> <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span></p>",
        "id": 467333421,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725388117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.28infinity.2C.201.29-categories/near/410550355\">said</a>:</p>\n<blockquote>\n<p>The branch <code>quasicat</code> now contains a sorry-free proof that the nerve of a category is a quasicategory.</p>\n</blockquote>\n<p>Hopefully someone adopts it this time (this was in december)!</p>",
        "id": 467333437,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1725388121
    },
    {
        "content": "<p>All those <code>eqToHom</code>s make me sad</p>",
        "id": 467333584,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725388179
    },
    {
        "content": "<p>FYI, I did merge today's master into the branch. So no need to do awkward bumping</p>",
        "id": 467334320,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725388432
    },
    {
        "content": "<p>The <code>eqToHom</code>s make me sad. But they are not the worst part. <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span></p>",
        "id": 467334470,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725388491
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> what would you say the worst part is?</p>",
        "id": 467539871,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1725457244
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"653351\">@Joseph Tooby-Smith</span> after reading this old thread I wanted to let you and your collaborators (if you can help me find them) know about a new blueprint project I'm in the process of setting up (<a href=\"https://emilyriehl.github.io/infinity-cosmos\">https://emilyriehl.github.io/infinity-cosmos</a>) and will create a channel for here very soon. The aim is to develop some of the formal (read 2-categorical) theory of (oo,1)-categories which means that if someone wants to do the hard work of showing that quasi-categories satisfy a certain list of axioms (defining an \"oo-cosmos\") then a whole bunch of theorems will follow.</p>",
        "id": 467541485,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1725457580
    },
    {
        "content": "<p>Most of the early formalization work will involve simplicially enriched categories or 2-categories stuff but there is a little bit of quasi-category theory needed too, and part of why I wanted to get in touch is to see whether you (or anyone else) has already done it.</p>",
        "id": 467541899,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1725457642
    },
    {
        "content": "<p>BTW <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> and I recently completed a construction of the left adjoint to the nerve and a proof that this adjunction is reflective (and thus, as a corollary, that Cat has colimits). This is all contained in the file \"HomotopyCat.lean\" in the repository I just linked from (currently broken in a way I don't understand due to some attempted renaming; I'll fix this later today). We're in the process of moving everything into a mathlib branch currently here: <a href=\"https://github.com/leanprover-community/mathlib4/tree/CatHasColimits\">https://github.com/leanprover-community/mathlib4/tree/CatHasColimits</a></p>",
        "id": 467543098,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1725457819
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> ! I ended up dropping the ball  on this (another Lean project I'm working on has taken most of my time) - so never really made any progress on quasi-categories. Your blueprint project looks great though! I'm excited to see where it goes, and I'm looking forward to having more about higher-categories in Lean.</p>",
        "id": 467545900,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1725458286
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> , I've been working on formalizing some quasi-category theory in <a href=\"https://github.com/mckoen/quasicategory\">this repo</a>. What in particular do you think you will need?</p>\n<p>My main goal at the moment is to formalize <a href=\"https://kerodon.net/tag/0066\">https://kerodon.net/tag/0066</a> (Fun(S, D) is a quasicat when D is), so if you need anything that goes into this proof, I might have already done it or will be doing it soon. In any case I'd be happy to help with the quasi-category bit of your project.</p>",
        "id": 467609556,
        "sender_full_name": "Jack McKoen",
        "timestamp": 1725469720
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.28infinity.2C.201.29-categories/near/467539871\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> what would you say the worst part is?</p>\n</blockquote>\n<p><code>filler_succ_aux</code> is pretty terrible</p>",
        "id": 467610011,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725469816
    },
    {
        "content": "<p>And when you need a doubly-primed name, that's also a bit of a smell that something isn't optimal</p>",
        "id": 467610176,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725469860
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"488744\">@Jack McKoen</span> in general I'd be happy to know about anything that you've got. Your goal is <span aria-label=\"fire\" class=\"emoji emoji-1f525\" role=\"img\" title=\"fire\">:fire:</span> so let me know in particular when you've got it :)</p>",
        "id": 467670575,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1725487964
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"653351\">@Joseph Tooby-Smith</span> a few months ago you mentioned you formalized something about the homotopy relation for 1-simplices. If so, and if you're willing to share your code, we'll take </p>\n<p><a href=\"https://emilyriehl.github.io/infinity-cosmos/blueprint/sec-simplicial-sets.html#defn:1-simplex-htpy\">https://emilyriehl.github.io/infinity-cosmos/blueprint/sec-simplicial-sets.html#defn:1-simplex-htpy</a></p>\n<p>and perhaps some of the following lemmas off the initial to-do list.</p>",
        "id": 467671208,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1725488297
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> The stuff I did on 1-simplies can be found here: </p>\n<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/10006/files#diff-d9401595c03bcfddf1ecc22aa64fe6a62f82ae75b237ef92269c4c42f967f04f\">https://github.com/leanprover-community/mathlib4/pull/10006/files#diff-d9401595c03bcfddf1ecc22aa64fe6a62f82ae75b237ef92269c4c42f967f04f</a></li>\n</ul>\n<p>Other stuff I've done for infinity categories are:</p>\n<ul>\n<li>Define the join of augmented simplicial sets: <br>\n<a href=\"https://github.com/leanprover-community/mathlib4/pull/11021\">https://github.com/leanprover-community/mathlib4/pull/11021</a></li>\n</ul>\n<p>And some stuff related to the augmented simplex category: </p>\n<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/10190\">https://github.com/leanprover-community/mathlib4/pull/10190</a></li>\n</ul>\n<p>I did all of this stuff when I was still pretty new to lean, so I can't claim it is any good, and it definitely needs a refactor.</p>",
        "id": 467673191,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1725489341
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span>  do your plans include model structures?</p>\n<p>One of the cited papers is \"K. S. Brown. Abstract homotopy theory and generalized sheaf cohomology. <em>Trans. Amer. Math. Soc.</em>, 186:419–458, 1973.\"</p>",
        "id": 467937983,
        "sender_full_name": "Dean Young",
        "timestamp": 1725559210
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"739358\">@Dean Young</span> not initially no but we likely will want proofs of related results. The citation is for Brown's axiomatization of a category of fibrant objects. Some proofs of results that hold in that setting would be great to have. (See Appendix C of \"Element of oo-category theory\" with <span class=\"user-mention\" data-user-id=\"752279\">@Dom Verity</span>; this isn't yet part of the blueprint.)</p>",
        "id": 467960683,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1725564204
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> ok thanks for this.</p>\n<p>Previously we had these thoughts about how to define an internal hom:<br>\n• [I,Δⁿ] has the (inner) horn lifting condition<br>\n• [I.X] has the (inner) horn lifting condition when X does<br>\n• [X, Y] has the (inner) horn lifting condition when Y does</p>",
        "id": 468455159,
        "sender_full_name": "Dean Young",
        "timestamp": 1725732686
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"739358\">@Dean Young</span> is \"I\" something special here?</p>",
        "id": 468631175,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1725830738
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span>  Sorry, meant Δ¹!</p>",
        "id": 468633070,
        "sender_full_name": "Dean Young",
        "timestamp": 1725831573
    },
    {
        "content": "<p>That makes sense. </p>\n<p>Some thoughts for the first point: once we know that the homotopy category functor preserves finite products (a pain to prove I fear but something we will need soon) it follows formally (using the fact that <code>ho(N C) = C</code> that the nerve preserves exponentials. So then [I,Δ^n] is a nerve of a category and thus a quasi-category (thanks to Johan). </p>\n<p>Though actually this requires the observation that Δ^n is the nerve of Fin n+1, which might not have been proven yet.</p>",
        "id": 468637688,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1725835488
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"653351\">@Joseph Tooby-Smith</span> I'm still new to Lean so all my code needs lots of editing... </p>\n<p>If you don't mind, I think the best thing to do would be to leave the homotopy category stuff on the to-do list but point to your PR. That might spur some attention to it and then revisions can happen there. Does this feel okay to you?</p>",
        "id": 468637792,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1725835593
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> That seems like a great idea! I'd be fine with this.</p>",
        "id": 468734401,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1725874400
    },
    {
        "content": "<p>There is a new channel open to discuss this project here: <a class=\"stream\" data-stream-id=\"455414\" href=\"/#narrow/stream/455414-Infinity-Cosmos\">#Infinity-Cosmos</a></p>",
        "id": 468862221,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1725901193
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"488744\">@Jack McKoen</span> over in the new <a class=\"stream\" data-stream-id=\"455414\" href=\"/#narrow/stream/455414-Infinity-Cosmos\">#Infinity-Cosmos</a> branch I've invited some golfing on some existing quasi-category theory code. I didn't put your work in progress on the list because I wasn't sure whether it was at the stage that you'd like some outside eyeballs. But if you'd like me to add it, I'd be very happy to. No pressure either way.</p>",
        "id": 468873455,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1725904198
    },
    {
        "content": "<p><del>(whoops, deleted, I didn't check the above channel)</del></p>",
        "id": 468910472,
        "sender_full_name": "Amelia Livingston",
        "timestamp": 1725913890
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.28infinity.2C.201.29-categories/near/468873455\">said</a>:</p>\n<blockquote>\n<p>I've invited some golfing on some existing quasi-category theory code. I didn't put your work in progress on the list because I wasn't sure whether it was at the stage that you'd like some outside eyeballs.</p>\n</blockquote>\n<p>My code is definitely not ready for golfing <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> I am actively working on it, but thanks Emily</p>",
        "id": 468916024,
        "sender_full_name": "Jack McKoen",
        "timestamp": 1725915868
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span>  Thanks for this insight!</p>",
        "id": 468927005,
        "sender_full_name": "Dean Young",
        "timestamp": 1725919909
    },
    {
        "content": "<p>For those following along: The \"cat has colimits\" PR series is now up at <a href=\"https://github.com/leanprover-community/mathlib4/pull/16784\">#16784</a> <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span>. The unblocked PRs are <a href=\"https://github.com/leanprover-community/mathlib4/pull/16779\">#16779</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/16780\">#16780</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/16781\">#16781</a></p>",
        "id": 470048961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726261547
    },
    {
        "content": "<p><img alt=\":merge:\" class=\"emoji\" src=\"https://avatars.zulip.com/3121/emoji/images/37577b95.png\" title=\"merge\"> <span aria-label=\"peace sign\" class=\"emoji emoji-270c\" role=\"img\" title=\"peace sign\">:peace_sign:</span> <span aria-label=\"writing\" class=\"emoji emoji-270d\" role=\"img\" title=\"writing\">:writing:</span></p>",
        "id": 470079367,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726281904
    }
]