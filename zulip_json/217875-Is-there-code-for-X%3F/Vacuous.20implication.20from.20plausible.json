[
    {
        "content": "<p>If we can show (part of) the hypothesis cannot be satisfied using <code>plausible</code>, is there a tactic that proves the result by vacuous implication. What I am missing is extracting the proof of the contradiction from <code>plausible</code>.</p>",
        "id": 482116869,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1731487186
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> Can I do this?</p>",
        "id": 482120322,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1731488269
    },
    {
        "content": "<p>I see <code>Testable.checkIO</code> with which I should be able to work.</p>",
        "id": 482121439,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1731488627
    },
    {
        "content": "<p>You can't use that to actually construct a proof from the meta level that you can put to close a goal. Instead what you should do is extract the counter example values from a TestResult and then using that write some meta code that does the proof that False is in the context. The counter example that is presented there is not really meant for...any but the infoviews consumption really, given that it is just a <code>List String</code>. So you would probably need to modify TestResult to contain a more expressive representation of counter examples</p>",
        "id": 482123816,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1731489367
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Vacuous.20implication.20from.20plausible/near/482123816\">said</a>:</p>\n<blockquote>\n<p>You can't use that to actually construct a proof from the meta level that you can put to close a goal. Instead what you should do is extract the counter example values from a TestResult and then using that write some meta code that does the proof that False is in the context. The counter example that is presented there is not really meant for...any but the infoviews consumption really, given that it is just a <code>List String</code>. So you would probably need to modify TestResult to contain a more expressive representation of counter examples</p>\n</blockquote>\n<p>Thanks. Yes, I was thinking in terms of extracting from <code>.faliure pf ..</code>. </p>\n<p>It seems it would be convenient to have a <code>vacuous</code> tactic proving results by using <code>plausible</code> to contradict hypothesis. Will experiment.</p>",
        "id": 482127205,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1731490379
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> I wrote some code that does work in principle, but (as it involves using <code>reduce</code> on a large scale`) causes crashes in larger cases. I am copying it below.</p>\n<p>I could not figure out a better way to lift the term proof in <code>TestResult</code> to an expression proof. I see that you mentioned modifying <code>TestResult</code> to have more. Is that what you meant? Is there an option short of lifting everything to Meta level, requiring <code>ToExpr</code> and constructing proof expressions at each stage?</p>\n<p>Here is my code in case anyone can see improvements.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Plausible</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"n\">Plausible</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Plausible.Testable.checkDirect</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Testable</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cfg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Configuration</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{})(</span><span class=\"n\">defaultSeed</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TestResult</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">seed</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cfg.randomSeed.getD</span><span class=\"w\"> </span><span class=\"n\">defaultSeed</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">suite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RandT</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TestResult</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Testable.runSuite</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">cfg</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">runRandWith</span><span class=\"w\"> </span><span class=\"n\">seed</span><span class=\"w\"> </span><span class=\"n\">suite</span>\n<span class=\"w\">  </span><span class=\"n\">res.run</span>\n\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">getProof</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVar</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">mkConst</span><span class=\"w\"> </span><span class=\"ss\">``Nat</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVar</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``List</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">mkConst</span><span class=\"w\"> </span><span class=\"ss\">``String</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">np</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``Not</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">contra</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVar</span><span class=\"w\"> </span><span class=\"n\">np</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">fExpr</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppOptM</span><span class=\"w\"> </span><span class=\"ss\">``TestResult.failure</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">contra</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">fExpr</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">contra</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">none</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">findDisproof</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">try</span>\n<span class=\"w\">    </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isProp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Decorations.addDecorations</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">synthInstance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``Testable</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">p'</span><span class=\"o\">])</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">cfg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Configuration</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{}</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">cfg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Configuration</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">cfg</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"n\">traceDiscarded</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cfg.traceDiscarded</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isTracingEnabledFor</span><span class=\"w\"> </span><span class=\"ss\">`plausible.discarded</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">traceSuccesses</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cfg.traceSuccesses</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isTracingEnabledFor</span><span class=\"w\"> </span><span class=\"ss\">`plausible.success</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">traceShrink</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cfg.traceShrink</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isTracingEnabledFor</span><span class=\"w\"> </span><span class=\"ss\">`plausible.shrink.steps</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">traceShrinkCandidates</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cfg.traceShrinkCandidates</span>\n<span class=\"w\">      </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isTracingEnabledFor</span><span class=\"w\"> </span><span class=\"ss\">`plausible.shrink.candidates</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">defaultSeed</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">IO.rand</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1000000</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">testResult</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppOptM</span><span class=\"w\"> </span><span class=\"ss\">``Testable.checkDirect</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toExpr</span><span class=\"w\"> </span><span class=\"n\">cfg</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toExpr</span><span class=\"w\"> </span><span class=\"n\">defaultSeed</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">testResult</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">testResult</span><span class=\"w\"> </span><span class=\"c1\">-- times out</span>\n<span class=\"w\">    </span><span class=\"n\">getProof</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">testResult</span>\n<span class=\"w\">  </span><span class=\"n\">catch</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">logWarning</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"Failed to find disproof: {e.toMessageData}\"</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">none</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">proveVacuous</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">forallE</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">withLocalDecl</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">b.instantiate1</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">contra</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">findDisproof</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"c1\">-- proof of ¬d</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">contra</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">contra</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">pfFalse</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppM'</span><span class=\"w\"> </span><span class=\"n\">contra</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">pfBody</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppOptM</span><span class=\"w\"> </span><span class=\"ss\">``False.elim</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pfFalse</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">mkLambdaFVars</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">pfBody</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">none</span>\n\n<span class=\"n\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"find_disproof\"</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Term.elabType</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"c1\">-- logInfo m!\"Finding disproof of {p}\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">disproof</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">findDisproof</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">disproof</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">contra</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"c1\">-- logInfo m!\"Found disproof: {contra}\"</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">contra</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">logWarning</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"No disproof found\"</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">mkConst</span><span class=\"w\"> </span><span class=\"ss\">``False</span>\n\n<span class=\"k\">#check</span><span class=\"w\"> </span><span class=\"n\">find_disproof</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"n\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"prove_vacuous\"</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Term.elabType</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">vacuous</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">proveVacuous</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">vacuous</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">pf</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">pf</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">logWarning</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"No vacuous proof found\"</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">mkConst</span><span class=\"w\"> </span><span class=\"ss\">``False</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">fun a =&gt; False.elim (Nat.not_le_of_not_ble_eq_true (fun h =&gt; Bool.noConfusion h) a) : 2 &lt; 1 → 1 ≤ 3</span>\n<span class=\"cm\">-/</span>\n<span class=\"k\">#check</span><span class=\"w\"> </span><span class=\"n\">prove_vacuous</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n\n<span class=\"k\">#check</span><span class=\"w\"> </span><span class=\"n\">find_disproof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"c1\">-- times out</span>\n</code></pre></div>",
        "id": 482959961,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1731919117
    },
    {
        "content": "<p>Running plausible within reduction is not a good idea. You should instead modify <code>TestResult</code> to actually return you the values of the counter example, so something along the lines of <code>HashMap FVarId Expr</code> most likely. Then use that counter example to build a proof term at the meta level and submit that proof term to the kernel.</p>",
        "id": 482960875,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1731919423
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Vacuous.20implication.20from.20plausible/near/482960875\">said</a>:</p>\n<blockquote>\n<p>Running plausible within reduction is not a good idea. You should instead modify <code>TestResult</code> to actually return you the values of the counter example, so something along the lines of <code>HashMap FVarId Expr</code> most likely. Then use that counter example to build a proof term at the meta level and submit that proof term to the kernel.</p>\n</blockquote>\n<p>Thanks. I take it that means copying and modifying most of the file <code>Testable.lean</code>. Is that correct?</p>",
        "id": 482961526,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1731919623
    },
    {
        "content": "<p>I suppose I can avoid stuff not needed for counterexamples.</p>",
        "id": 482961653,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1731919661
    },
    {
        "content": "<p>I think it mostly comes down to modifying the <code>addVarInfo</code> function there, you probably want to do this on a fork of plausible</p>",
        "id": 482961895,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1731919729
    },
    {
        "content": "<p>Do you mean that the failure case should have additional info besides the string, and this is added in <code>addVarInfo</code>?</p>",
        "id": 482962523,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1731919913
    },
    {
        "content": "<p>It should record the <code>Expr</code> that is being assigned to the variable at the very least.</p>",
        "id": 482962946,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1731920039
    },
    {
        "content": "<p>It seems to me that just recording the proof expression may be easiest.</p>",
        "id": 482963127,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1731920090
    },
    {
        "content": "<p>There may even be no variables, for instance when proved using <code>decide</code>.</p>",
        "id": 482963200,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1731920114
    },
    {
        "content": "<p>Also an option yes</p>",
        "id": 482963457,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1731920185
    },
    {
        "content": "<p>Let me work on this then.</p>",
        "id": 482963582,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1731920225
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> I have opened a PR at <a href=\"https://github.com/leanprover-community/plausible/pull/7\">https://github.com/leanprover-community/plausible/pull/7</a>. This lifts (some of) the code to expression level and uses this to introduce two new tactics:</p>\n<ul>\n<li>The <code>vacuous</code> tactic tries to negate (a part of the) hypothesis to prove by vacuous implication.</li>\n<li>The <code>random_search</code> tactic negates the goal and tries to disprove it.</li>\n</ul>\n<p>These will probably rarely come up in human proofs but I feel will be very much needed for AI generated code.</p>\n<p>The design is a little complex but is the best I could come up with. Suggestions on improving the code are very welcome (<span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> and <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> - please let me know if you have any design suggestions).</p>",
        "id": 484202571,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1732504029
    },
    {
        "content": "<p>I don't think that duplicating what basically amounts to the entire code base is a reasonable thing to do as a design. We should instead work to integrate this with the already existing code base through a refactoring. Currently there aren't that many implementors of typeclasses in plausible so we can still change the interface .</p>",
        "id": 484237969,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1732524444
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Vacuous.20implication.20from.20plausible/near/484237969\">said</a>:</p>\n<blockquote>\n<p>I don't think that duplicating what basically amounts to the entire code base is a reasonable thing to do as a design. We should instead work to integrate this with the already existing code base through a refactoring. Currently there aren't that many implementors of typeclasses in plausible so we can still change the interface .</p>\n</blockquote>\n<p>One issue is that to construct proofs we need a <code>ToExpr</code> for the proxies of what is sampled. So, for example, the <code>MyType</code> does not work as is.</p>",
        "id": 484238365,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1732524559
    },
    {
        "content": "<p>So there will be fewer instances of <code>MetaTestable</code> than of <code>Testable</code>.</p>",
        "id": 484238460,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1732524586
    },
    {
        "content": "<p>Other than that, I agree that duplication is not good. Part of the reason for duplication was just not to break things.</p>",
        "id": 484239117,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1732524766
    },
    {
        "content": "<p>The specific <code>MyType</code> example can be made to work with a <code>decide</code> as all values are going to be concrete but the point is correct yes. Still I don't think that splitting up the plausible eco system into two type classes is something that can be sustainable in the long term, surely there must be some good design alternative here somewhere.</p>",
        "id": 484239241,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1732524803
    },
    {
        "content": "<p>I agree that splitting into two type classes is not desirable.</p>",
        "id": 484240282,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1732525073
    },
    {
        "content": "<p>One option I can think of is replacing the <code>Expr</code> arguments in <code>.failure</code> as well as <code>run</code> with <code>Option Expr</code>. We then have lower priority instances in the absence of <code>ToExpr</code> and higher priority ones in the presence of these.</p>",
        "id": 484241882,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1732525506
    },
    {
        "content": "<p>This would mean generation of proof expressions is best-effort.</p>",
        "id": 484242046,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1732525552
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266304\">Siddhartha Gadgil</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Vacuous.20implication.20from.20plausible/near/484238365\">said</a>:</p>\n<blockquote>\n<p>One issue is that to construct proofs we need a <code>ToExpr</code> for the proxies of what is sampled. So, for example, the <code>MyType</code> does not work as is.</p>\n</blockquote>\n<p>One proposed refactor is that everything should be sampling from <code>Expr</code> in the first place, rather than sampling from <code>MyType</code> and converting to <code>Expr</code></p>",
        "id": 484280559,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732536082
    },
    {
        "content": "<p>It seems reasonable to me. No need of a proxy and just generate expressions. One can try to have elaborators to construct new instances</p>",
        "id": 484282589,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1732536658
    },
    {
        "content": "<p>Sure we can try that approach as well</p>",
        "id": 484282732,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1732536706
    },
    {
        "content": "<p>I have redesigned the code so that <code>SampleableExt</code> has a field <code>proxyExpr?</code>to optionally map proxy types to expressions. With this I could get rid of most of the differences between <code>MetaTestable</code> and <code>Testable</code>, so that the former can hopefully replace the latter.</p>\n<p>There is unfortunately one regression, which is the instance <a href=\"https://github.com/siddhartha-gadgil/plausible/blob/09bbbef47eb23c99ebc47468a1b156a9d115da7a/Plausible/Functions.lean#L129\">Pi.sampleableExt</a>. The new field is adding universe constraints which Lean is not able to solve. I really do not understand these things well (never used <code>ULift</code>), so help is greatly appreciated : <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> </p>\n<p>I did not go with the switching to expressions only as I find it much harder to get expressions correct without the typed code to guide me.</p>\n<p>Besides the regression, does it look reasonable to try to switch <code>Testable</code> to <code>MetaTestable</code>? I can make replacements in the PR.</p>",
        "id": 484509610,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1732626440
    },
    {
        "content": "<p>Regarding type-correct expressions, Qq is a good option</p>",
        "id": 484517154,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732628706
    },
    {
        "content": "<p>For switching to exprs generally, I suspect that we want to drop typeclasses entirely and switch to a more simproc/norm_num/positivity-style registration mechanism</p>",
        "id": 484517295,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732628749
    },
    {
        "content": "<p>The good news is that the regression is fixed. So carrying along expressions has parity with the original plausible code. Unfortunately it is a lot slower.</p>\n<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I should start using Qq - it looks really nice. The other approach is currently out of my experience/skill</p>\n<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> What seems the best plan. I can make <code>MetaTestable</code> to be the new <code>Testable</code> with the new <code>Sampleable</code>. This allows for disproofs and hence the new tactics. The only catch is the slow running, as can be seen at <a href=\"https://github.com/siddhartha-gadgil/plausible/blob/2217b44d355f131ff73875ddea577d440838f0a6/Test/Testable.lean#L30\">https://github.com/siddhartha-gadgil/plausible/blob/2217b44d355f131ff73875ddea577d440838f0a6/Test/Testable.lean#L30</a>.</p>",
        "id": 485101607,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1732887707
    },
    {
        "content": "<p>Have you collected any profile data on what it is doing that is slower?</p>",
        "id": 485122715,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1732894796
    },
    {
        "content": "<p>Not yet</p>",
        "id": 485122869,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1732894856
    },
    {
        "content": "<p>What is the best way to profile</p>",
        "id": 485122926,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1732894885
    },
    {
        "content": "<p>Given that you are now doing meta programming I would suggest <code>set_option trace.profiler true</code> as a first step.</p>",
        "id": 485123305,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1732895028
    },
    {
        "content": "<p>Below is what I got. I don't understand it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Elab.command</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">21</span><span class=\"bp\">.</span><span class=\"mi\">713837</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">MetaTestable.check</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a.y</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b.x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a.x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b.y</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">012368</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">Plausible.MetaTestable</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">Plausible.NamedBinder</span><span class=\"w\"> </span><span class=\"s2\">\"a\"</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"o\">),</span>\n<span class=\"w\">          </span><span class=\"n\">Plausible.NamedBinder</span><span class=\"w\"> </span><span class=\"s2\">\"b\"</span>\n<span class=\"w\">            </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Plausible.NamedBinder</span><span class=\"w\"> </span><span class=\"s2\">\"a._@.Test.Testable._hyg.275\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a.y</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b.x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a.x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b.y</span><span class=\"o\">))))</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"kd\">def</span><span class=\"bp\">.</span><span class=\"n\">processPreDef</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">21</span><span class=\"bp\">.</span><span class=\"mi\">581367</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">process</span><span class=\"w\"> </span><span class=\"n\">pre</span><span class=\"bp\">-</span><span class=\"n\">definitions</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">compiler</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">21</span><span class=\"bp\">.</span><span class=\"mi\">580126</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">compiling</span><span class=\"w\"> </span><span class=\"n\">old</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">_eval</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Seems like \"process pre-definitions\" are taking all the time.</p>",
        "id": 485131131,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1732897928
    },
    {
        "content": "<p>Perhaps clicking on the <code>▼</code> will give you more details?</p>",
        "id": 485132290,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1732898290
    },
    {
        "content": "<p>It seems more like compiling the code is taking the whole time here</p>",
        "id": 485132300,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1732898295
    },
    {
        "content": "<p>The downward arrow is already clicked, it's the compiler node below, if its a right pointing arrow it's not yet clicked</p>",
        "id": 485132377,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1732898322
    },
    {
        "content": "<p>It may not be a regression then. I was puzzled because if I do not pass a type expression as an argument, the <code>MetaTestable.check</code> function should behave just like the <code>Testable.check</code> function</p>",
        "id": 485132997,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1732898479
    },
    {
        "content": "<p>The reason it is taking so long to compile is most likely that because there is a type class mechanism involved the entire hierarchy of functions that are involved are getting specialized and compiled on the fly here. This is also an issue that was already present in the regular Testable approach. However now that you extended the type class to contain expression generating code as well you need to compile even more code.</p>\n<p>This issue would indeed be solved by:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Vacuous.20implication.20from.20plausible/near/484517295\">said</a>:</p>\n<blockquote>\n<p>For switching to exprs generally, I suspect that we want to drop typeclasses entirely and switch to a more simproc/norm_num/positivity-style registration mechanism</p>\n</blockquote>\n<p>as there would be much less specialisation left to do</p>",
        "id": 485133290,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1732898636
    },
    {
        "content": "<p>I see. Is there a way to make them compile in advance</p>",
        "id": 485133529,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1732898744
    },
    {
        "content": "<p>No that's not how specialisation works</p>",
        "id": 485133601,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1732898764
    },
    {
        "content": "<p>When Lean encounters a function that has a type class argument it explicitly substitutes in whatever TC synthesis figured out for that argument for compilation. So whenever you present the compiler with a new call to check with a new <code>p</code> it is going to make a completely new set of compiled definitions for all of the things involved in executing the code of that <code>[Testable p]</code> instance. As you cannot know a priori what <code>p</code> are going to be there you cannot precompile.</p>\n<p>If instead we used an attribute like <code>@[plausible MyType]</code> on functions of type  <code>SomeMetaGenMonad Expr</code> and then call these functions when we need to generate a value of type <code>MyType</code> that function does not have any TC argument so there is no need to be specialised -&gt; we can use an already compiled version from the library itself.</p>",
        "id": 485134421,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1732899148
    },
    {
        "content": "<p>While what Henrik says is true, it isn't in my mind the primary reason that typeclasses are the wrong tool here; using a registration mechanism instead lets us match on partial expressions, or lets us restrict to things like \"is an expression in a ring\" (by just failing the handler if this condition isn't met) which can't be captured by typeclass alone</p>",
        "id": 485149114,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732907169
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> I am thinking of giving this a shot. I am asking for suggestions because I am a bit confused about some things even if I am willing to give up some generality (which I am for a first pass).</p>\n<ul>\n<li>Have an attribute @[plausible MyType]<code> for functions that will be </code>SomeMetaGenMonad Expr`.</li>\n<li>The attribute is registered in some environment extension similar to <code>symm</code> except by <code>MyType</code>.</li>\n<li>As a first pass, one can simply try to match <code>MyType</code> with <code>isDefEq</code> as there are not that many generators.</li>\n<li>However, <code>MyType</code> may really be a type family. So it seems one should instantiate <code>MVar</code>'s and fill in to get a type. Then <code>isDefEq</code> will solve instantiating some of them.</li>\n<li>In case some of the metavariables are not assigned by <code>isDefEq</code>, one should assume these are meant to be generated. So we recurse here (with some bound on depth). Some may be assigned involving other metavariables adding a twist to the tale. </li>\n<li>It seems that as generators will not be common, one can store them without indexing in an environment extension. Also, it is not obvious to me how to use discriminant trees here.</li>\n<li>One should have tactics <code>plausible using</code> to try to close using some tactic, instead of depending on decidable equality.</li>\n<li>As I implemented earlier, the same mechanism can be used to prove existential results by a search.</li>\n</ul>",
        "id": 498714994,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1739181374
    },
    {
        "content": "<p>The above will not work, depending on too much magic. It seems that, just as instances are often based on the presence of other typeclasses and use samples from them, the attribute should be in general more like <code>@[plausible MyType from ...]</code>, and the generated expression depending on other expressions.</p>",
        "id": 498737388,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1739187391
    },
    {
        "content": "<p>For simprocs and norm_num, this is handled by just allowing a handler to say \"actually I can't help here after all\"</p>",
        "id": 498737762,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739187493
    },
    {
        "content": "<p>I mean what is the way to annotate: can generate <code>List A</code> if we have a way to generate <code>A</code></p>",
        "id": 498737957,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1739187550
    },
    {
        "content": "<p>Annotate with <code>List _</code></p>",
        "id": 498738000,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739187566
    },
    {
        "content": "<p>Then in the handler, pattern match and recurse like we do in the norm_num handlers</p>",
        "id": 498738071,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739187592
    },
    {
        "content": "<p>I see. Thanks. I have not done pattern matching with underscores before, but will learn (starting with the basic cases where they are arguments).</p>\n<p>But does the expression not depend on the value in the underscore?</p>",
        "id": 498738480,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1739187717
    },
    {
        "content": "<p>I suppose the expressions can be lambdas with generated arguments filled in.</p>",
        "id": 498738993,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1739187851
    },
    {
        "content": "<p>Am I correct that when elaborating underscores just become meta-variables? <br>\nIf I have an expression like <code>_ + _</code>, we should get meta-variables for both the underscores as well as all the <code>HAdd</code> parameters. Are these distinguished by one of them being \"synthetic\"?</p>",
        "id": 498739730,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1739188095
    },
    {
        "content": "<p>I don't remember exactly how the <code>@[norm_num patt]</code> attribute works. I think the pattern elaboration is handled by the discrtree machinery. To actually extract the value of the _ for the case in question, I would usually recommend <code>~q(List $a)</code> matching</p>",
        "id": 498744427,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739189415
    },
    {
        "content": "<p>I think building a dumb set of machinery by cargo-culting <code>positivity</code> would be reasonable straightforward</p>",
        "id": 498745426,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739189732
    },
    {
        "content": "<p>But if you want to do things like \"sample lists of primes of length 4\" efficiently, expressed via separate hypotheses, you might need a different design</p>",
        "id": 498745645,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739189790
    },
    {
        "content": "<p>I will start with trying to make something that works, though may not be optimal in brevity, syntax or coverage. If this works I can try to refine.</p>",
        "id": 498746277,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1739189998
    },
    {
        "content": "<p>I guess for the above example, sampling from <code>List.Vector Nat.Primes 4</code> would be enough for a first attempt</p>",
        "id": 498752605,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739191863
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I am hoping to revisit and work on this. As I understand, what you are suggesting is roughly treating generation of expressions like tactic proofs, except that we look for not just one term of a type.</p>\n<p>Currently plausible uses typeclass inference to figure out how to build terms of a type from those of other types, then generates terms of other types and pushes forward. Instead one can have a <em>pull</em> based approach where we start with a desired type and use specific tactics determined by the annotations to work backwards to something for which we can generate terms. Is this roughly correct?</p>",
        "id": 516704834,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1746630971
    },
    {
        "content": "<p>I think I'd argue that the current implementation is also \"pull\"-based, as typeclass search works that way in general</p>",
        "id": 516705776,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746631236
    },
    {
        "content": "<p>Fair enough. I was more concerned if my interpretation of the new design is correct, with the functions to be constructed similar to the <code>MVarId -&gt; List MVarId</code> functions that are used to make tactics often.</p>",
        "id": 516706228,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1746631360
    }
]