[
    {
        "content": "<p>I was looking for an instance of <code>HMul (Fin n) (Fin m) (Fin ((n-1)*(m-1) + 1))</code> in Mathlib, but couldn't find anything sort of similar. In general it seems like the usual arithmetic operations are not supported with <code>Fin</code>. Am I simply looking the wrong way?</p>",
        "id": 470702622,
        "sender_full_name": "Ayhon",
        "timestamp": 1726511006
    },
    {
        "content": "<p>I'm using this to prove some properties on indices, the instance I'm actually interested in is <code>HMul (Fin (2^h)) (Fin 3) (Fin (2^(h+1) - 1))</code> to show that if <code>i: Fin (2^h)</code> then <code>2*i: Fin (2^(h+1))</code> and <code>2*i + 1: Fin (2^(h+1))</code>.</p>",
        "id": 470703561,
        "sender_full_name": "Ayhon",
        "timestamp": 1726511243
    },
    {
        "content": "<p>if you want some kind of index pairing, i think using <code>Prod</code> should do, no?</p>",
        "id": 470703910,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726511337
    },
    {
        "content": "<p>Sorry, I'm not sure what you mean exactly. I'm quite new to Lean, this is the first project I'm developping with it</p>",
        "id": 470704040,
        "sender_full_name": "Ayhon",
        "timestamp": 1726511383
    },
    {
        "content": "<p>Isn't <code>Prod</code> used to make tuples? How does it relate?</p>",
        "id": 470704161,
        "sender_full_name": "Ayhon",
        "timestamp": 1726511411
    },
    {
        "content": "<p>i suppose my suggestion was a bit hasty... i was in the middle of being surprised that there would be a use for multiplication of <code>Fin</code>...</p>",
        "id": 470705101,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726511674
    },
    {
        "content": "<p>i think it would help to know what larger issue or design having this instance would help you make, because having this instance is (at first glance, to me) not desirable.</p>",
        "id": 470705382,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726511742
    },
    {
        "content": "<p>because this sounds like an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> problem</p>",
        "id": 470705440,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726511757
    },
    {
        "content": "<p>Hmm, you may be right. Let me give a bit more context into the problem I'm trying to solve.</p>\n<p>As a small little project to learn software verification in Lean, I've decided to try to develop a verified implementation of a segment tree. Segment trees are represented by a (2^h) array in memory, which can be indexed by <code>Fin (2^h)</code>. In particular, the segment tree stores its leaves in the positions <code>2^(h-1)</code> to <code>2^h - 1</code> of the array, and internal nodes in positions <code>1</code> to <code>2^(h-1) - 1</code>. For a given internal node at position <code>i</code>, its left child is obtained from doing <code>2*i</code> and its right child from doing <code>2*i+1</code>.</p>\n<p>Basically, the indices describe the path that must be taken from the root to the node, with <code>0</code>s being left and <code>1</code>s being right. I would now like to prove that if I'm given an internal node (represented by <code>Fin 2^(h-1)</code>), I can obtain its left or right child, and still have those be valid pointers (represented by <code>Fin 2^h</code>). In particular, I need to show that <code>2*i + 1 &lt; 2^(h+1)</code> if <code>i &lt; 2^h</code>.</p>\n<p>If we represent bounded numbers using<code>Fin n</code>, I thought it to be reasonable to expect an implementation of artihmetic operations which simply adapted the bounds they were subject to as needed. So <code>HAdd (Fin n) (Fin m) (Fin (n+m-1))</code> for example.</p>\n<p>Is there an easier way of working with numbers as strings of bits? I looked at the standard library, and all I could find were definitions like <code>Nat.binaryRec</code> which make it easier to work with natural numbers as if they were so, but not much else.</p>",
        "id": 470709107,
        "sender_full_name": "Ayhon",
        "timestamp": 1726512560
    },
    {
        "content": "<p>Ideally, I would like to work with <code>Fin (2^h)</code> as if it were a <code>Vector Bool h</code>, while still being able to index the segment tree</p>",
        "id": 470709408,
        "sender_full_name": "Ayhon",
        "timestamp": 1726512628
    },
    {
        "content": "<p>are you looking for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BitVector#doc\">docs#BitVector</a> ?</p>",
        "id": 470711199,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1726512988
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BitVec#doc\">docs#BitVec</a></p>",
        "id": 470711352,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726513025
    },
    {
        "content": "<p>Indeed <code>BitVec</code> is closer to what I was looking for, but I'd like it if addition didn't wrap around the end, but simply extend the amount of bits needed for its representation. I would like not to worry about overflows by proving that the numbers I need respect the required bounds. If this is not usually how this is achieved, is there a different way of doing so?</p>",
        "id": 470889949,
        "sender_full_name": "Ayhon",
        "timestamp": 1726557109
    },
    {
        "content": "<p>Usually it is best to work with total functions (that may have \"junk\" values in the parts of the domain you don't care about), and then prove theorems about the behaviour of these functions when the inputs satisfy the conditions you care about.</p>",
        "id": 470905709,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726560894
    },
    {
        "content": "<p>If that doesn't make sense, you may need to <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> a bit here, as I suspect you may be trying to do \"the wrong thing\".</p>",
        "id": 470905815,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726560930
    },
    {
        "content": "<p>I think you may have an easier time defining a segment tree inductively (only for the proof, not the program), proving everything there, and finally having a few lemmas showing the equivalence of that to a flat representation</p>",
        "id": 470909758,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726562179
    },
    {
        "content": "<p>It sounds like you are doing something like interval arithmetic at the type level which sounds a bit frightening but there has to be a way to automatically propagate bounds through a computation and the overall motivation does feel natural.</p>",
        "id": 471037689,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1726591909
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Multiplication.20of.20Fin.20numbers.3F/near/470909758\">said</a>:</p>\n<blockquote>\n<p>I think you may have an easier time defining a segment tree inductively (only for the proof, not the program), proving everything there, and finally having a few lemmas showing the equivalence of that to a flat representation</p>\n</blockquote>\n<p>Actually, that was a bit of my approach. I have a tree implementation of what a segment tree is, without relying on internal details. The thing is, I need these proofs to index the underlying array in the implementation. I guess I could add extra bound checks in the code and later prove that they're not needed, but since I'm already indexing with <code>Fin (2^h)</code> I thought I could use them instead.</p>",
        "id": 471053610,
        "sender_full_name": "Ayhon",
        "timestamp": 1726596304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"242586\">Vincent Beffara</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Multiplication.20of.20Fin.20numbers.3F/near/471037689\">said</a>:</p>\n<blockquote>\n<p>It sounds like you are doing something like interval arithmetic at the type level which sounds a bit frightening but there has to be a way to automatically propagate bounds through a computation and the overall motivation does feel natural.</p>\n</blockquote>\n<p>My original inspiration was this <a href=\"https://capnproto.org/news/2015-03-02-security-advisory-and-integer-overflow-protection.html\">CapNProto security advisory report</a>. I guess what I actually want is the proof that if <code>i &lt; n</code> and <code>j &lt; m</code> then <code>i*j&lt;(n-1)*(m-1)+1</code>, which doesn't really have to be tied to <code>Fin</code>. But it would believe it could be useful to have this done automatically. Although it could just be that I'm biased by my use case. ü§∑üèª</p>",
        "id": 471054535,
        "sender_full_name": "Ayhon",
        "timestamp": 1726596535
    },
    {
        "content": "<p>I'll try to give everyone's suggestions a go once I find the time. Thank you all for your feedback! I think thinking of these implementations as foral functions will help as a general directive to keep in the implementation.</p>",
        "id": 471054882,
        "sender_full_name": "Ayhon",
        "timestamp": 1726596600
    }
]