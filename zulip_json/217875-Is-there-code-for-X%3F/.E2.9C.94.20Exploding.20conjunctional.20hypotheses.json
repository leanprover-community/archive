[
    {
        "content": "<p>Suppose that via <code>intro</code>, I can get a \"conjunctive\" hypotheses like <code>(∃ x, p x) ∧ r</code>, or <code>(∃ x, p x ∧ r)</code> in my goal. Is there a way to introduce it in such a way, that all the trivially entailed hypotheses are automatically introduced along the way? In this case, I am looking for a tactic that also makes <code>x</code>, <code>(_: px)</code>, and <code>(_: r)</code> available as hypotheses in both cases.</p>\n<p>I am currently working through Theorem Proving in Lean 4.  And such a \"explosion\" of \"conjunctive\" hypotheses would enable me to leverage more automation in at least one exercise.</p>",
        "id": 466619038,
        "sender_full_name": "Sebastian Miele",
        "timestamp": 1725147932
    },
    {
        "content": "<p><code>rintro</code>. You can also use pattern matching syntax with  <code>obtain</code>. I am on my phone so typing out examples is hard. But I think you'll find many by searching this Zulip.</p>",
        "id": 466619349,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1725148262
    },
    {
        "content": "<p>Thank you! However, I suppose that <code>rintro</code> and friends are not what I am looking for in this case.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"n\">all_goals</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨_</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">repeat</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">constructor</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">assumption</span>\n</code></pre></div>\n<p>I want to replace <code>constructor; all_goals (first | intro ⟨_,_,_⟩ | intro ⟨⟨_,_⟩,_⟩)</code> by <code>constructor &lt;;&gt; \"intro and explode\"</code>. In particular, it would have to work on both, <code>(∃ x, p x) ∧ r</code>, and <code>(∃ x, p x ∧ r)</code>. As far as I understand, <code>rintro</code> or such would only work after one of them already has been chosen.</p>\n<p>This really is not important. In a sense, I just felt some dissatisfaction, because it somehow almost certainly is possible. And I felt like trying Zulip for the first time, and acted out on that. I am still at the beginning of learning Lean, and probably really only should ask such questions after having worked through all the books, and after having gained considerably more background and experience.</p>",
        "id": 466623195,
        "sender_full_name": "Sebastian Miele",
        "timestamp": 1725151768
    },
    {
        "content": "<p>I think there are better answers to this, but here are <del>two</del> three one-liners:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">aesop</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">tauto</span>\n</code></pre></div>",
        "id": 466663178,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1725179025
    },
    {
        "content": "<p>Here's a slightly longer one-liner</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hr</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hr</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hr</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hr</span><span class=\"bp\">⟩⟩</span>\n</code></pre></div>",
        "id": 466768847,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725229278
    },
    {
        "content": "<p>I can see the appeal in your hypothetical tactic, all that's really happening is repackaging proofs</p>",
        "id": 466768879,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725229307
    },
    {
        "content": "<p>Though maybe <code>tauto</code> is already your hypothetical tactic</p>",
        "id": 466768945,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725229336
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Exploding.20conjunctional.20hypotheses/near/466768879\">said</a>:</p>\n<blockquote>\n<p>I can see the appeal in your hypothetical tactic, all that's really happening is repackaging proofs</p>\n</blockquote>\n<p>Yes, I wanted to know whether this hypothetical tactic exists. I feel that it may make some proofs more readable. I didn't expect that <code>simp</code> or such would also work on propositions with quantifiers. That's nice, of course. But I wanted to try to find a proof that most closely resembles how I would do the proof on paper. <code>simp</code> and friends work, but they would be <em>too</em> short for that objective.</p>",
        "id": 466771011,
        "sender_full_name": "Sebastian Miele",
        "timestamp": 1725230687
    },
    {
        "content": "<p>I'll mark this as resolved. There probably is no such tactic (yet). But it has become very clear that Zulip and this community are great, and I am looking forward to become part of it. Thanks a lot. Best wishes!</p>",
        "id": 466771681,
        "sender_full_name": "Sebastian Miele",
        "timestamp": 1725231144
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"708788\">Sebastian Miele</span> has marked this topic as resolved.</p>",
        "id": 466771692,
        "sender_full_name": "Notification Bot",
        "timestamp": 1725231152
    },
    {
        "content": "<p>By the way, <code>simp</code> works here because (as you can see via <code>simp?</code>) it uses <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=exists_and_right#doc\">docs#exists_and_right</a></p>",
        "id": 467301949,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725379553
    },
    {
        "content": "<p>Oftentimes, such low-level logical proofs aren't really worth spending too much time on trying to be surgical with tactics. Either you use high-level automation if possible, or you use a term proof to do exactly what you want.</p>\n<p>Violeta already supplied the term proof (I wrote the same one independently), and Shreyas already suggested <code>tauto</code>, which is perfect for this goal.</p>",
        "id": 467303112,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725379789
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Exploding.20conjunctional.20hypotheses/near/467301949\">said</a>:</p>\n<blockquote>\n<p>By the way, <code>simp</code> works here because (as you can see via <code>simp?</code>) it uses <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=exists_and_right#doc\">docs#exists_and_right</a></p>\n</blockquote>\n<p>Didn't know about <code>simp?</code>, yet. Thank you!</p>",
        "id": 467397276,
        "sender_full_name": "Sebastian Miele",
        "timestamp": 1725418238
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Exploding.20conjunctional.20hypotheses/near/467303112\">said</a>:</p>\n<blockquote>\n<p>Oftentimes, such low-level logical proofs aren't really worth spending too much time on trying to be surgical with tactics. Either you use high-level automation if possible, or you use a term proof to do exactly what you want.</p>\n</blockquote>\n<p>Makes perfect sense.</p>",
        "id": 467397475,
        "sender_full_name": "Sebastian Miele",
        "timestamp": 1725418319
    }
]