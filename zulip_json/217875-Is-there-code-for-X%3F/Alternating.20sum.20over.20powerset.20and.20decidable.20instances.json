[
    {
        "content": "<p>Hi, this is a combination \"Is there code for X?/aaaaaah what did I do wrong\" message. It all started when I wondered whether the calculation of the sum of the (-1)^{card t} over the powerset of a finset was in mathlib. So something like that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">alternating_sum_powerset</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">finset.sum</span> <span class=\"o\">(</span><span class=\"n\">finset.powerset</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">t.card</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n<span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>Experienced Lean people will probably already sense trouble, because I am using <code>ite</code> on a <code>Prop</code> that has no reason to be decidable. But I have a <code>local attribute [instance] classical.prop_decidable</code> at the beginning of every file so I did not notice. </p>\n<p>My first question is: is there something like that in mathlib ?</p>\n<p>I did a quick search, didn't find it and decided to try and prove it. Here is my MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.powerset</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.ring</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.choose.sum</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">classical.prop_decidable</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">alternating_sum_powerset_aux</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">finset.powerset_len</span> <span class=\"n\">j</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">t.card</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"n\">j</span> <span class=\"bp\">*</span>\n<span class=\"o\">(</span><span class=\"n\">s.card.choose</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">@</span><span class=\"n\">finset.sum_congr</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">finset.powerset_len</span> <span class=\"n\">j</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">finset.powerset_len</span> <span class=\"n\">j</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">t.card</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">refl</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">finset.sum_const</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">finset.card_powerset_len</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">nsmul_eq_mul</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">finset.mem_powerset_len</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">hx.2</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">alternating_sum_powerset</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">finset.sum</span> <span class=\"o\">(</span><span class=\"n\">finset.powerset</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">t.card</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n<span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset.sum_powerset</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">@</span><span class=\"n\">finset.sum_congr</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">finset.range</span> <span class=\"o\">(</span><span class=\"n\">s.card</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">finset.range</span> <span class=\"o\">(</span><span class=\"n\">s.card</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">finset.powerset_len</span> <span class=\"n\">m</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">t.card</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"n\">m</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">s.card.choose</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">refl</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">finset.card_eq_zero</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">int.alternating_sum_range_choose</span> <span class=\"n\">s.card</span><span class=\"o\">,</span>  <span class=\"c1\">---- oh no ! :-((((</span>\n    <span class=\"o\">},</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">hm</span><span class=\"o\">,</span> <span class=\"n\">alternating_sum_powerset_aux</span> <span class=\"n\">s</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>And here is the beautiful error message that I got:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">type</span> <span class=\"n\">ascription</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"o\">(</span><span class=\"n\">finset.range</span> <span class=\"o\">(</span><span class=\"n\">s.card</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">s.card.choose</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n    <span class=\"bp\">@</span><span class=\"n\">ite</span> <span class=\"n\">ℤ</span> <span class=\"o\">(</span><span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nat.decidable_eq</span> <span class=\"n\">s.card</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"o\">(</span><span class=\"n\">finset.range</span> <span class=\"o\">(</span><span class=\"n\">s.card</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">s.card.choose</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n    <span class=\"bp\">@</span><span class=\"n\">ite</span> <span class=\"n\">ℤ</span> <span class=\"o\">(</span><span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">classical.prop_decidable</span> <span class=\"o\">(</span><span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>My interpretation of it is: <code>ite</code> expects its <code>Prop</code> to be decidable. In the statement of my lemma, <code>(s = ∅)</code> was decidable because I told Lean at the beginning that every <code>Prop</code> should be decidable; this reason carried over when I did the <code>rw</code> to make the <code>Prop</code> equal to <code>(s.card=0)</code>. But in the lemma that I was trying to use, the argument of <code>ite</code> is decidable because it is an equality between natural numbers, and there is an instance telling Lean that this is always decidable. So <code>exact</code> failed because the two <code>Prop</code>s in the <code>ite</code> were decidable for different reasons. At this point I threw my computer out of the window.</p>\n<p>Okay, so assuming this interpretation is correct, is there any elegant way to get out of this one ? What I did in real life was get rid of the <code>ite</code> by cutting my lemma into two sublemmas, one for a nonempty <code>finset</code> and one for the empty <code>finset</code>; this feels somewhat unsatisfying so I wonder if there was a better way.</p>",
        "id": 347859849,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1680957377
    },
    {
        "content": "<p>What happens if you replace your <code>local attribute</code> by <code>open_locale classical</code> at the top of the file?</p>",
        "id": 347860685,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1680957707
    },
    {
        "content": "<p>They both mean (roughly) the same thing, except that the latter gives the classical instances lower priority to avoid the kind of pickle that you're finding yourself in.</p>",
        "id": 347860907,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1680957787
    },
    {
        "content": "<p>Then the <code>rw</code> on the previous line fails, with the message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rewrite</span> <span class=\"n\">tactic</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">type</span> <span class=\"n\">correct</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_a</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span>\n    <span class=\"o\">(</span><span class=\"n\">finset.range</span> <span class=\"o\">(</span><span class=\"n\">s.card</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">s.card.choose</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span>\n      <span class=\"o\">((</span><span class=\"n\">finset.range</span> <span class=\"o\">(</span><span class=\"n\">s.card</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">s.card.choose</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">ite</span> <span class=\"n\">_a</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 347860964,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1680957817
    },
    {
        "content": "<p>What if you make it a <code>simp_rw</code> instead?</p>",
        "id": 347861077,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1680957850
    },
    {
        "content": "<p>And this time I cannot make any sense of the error message. :-(</p>",
        "id": 347861089,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1680957853
    },
    {
        "content": "<p>Now it works ! Woohoo !</p>",
        "id": 347861136,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1680957880
    },
    {
        "content": "<p>I did not know about this <code>simp_rw</code> tactic, I will add it to my list. I've had a lot of trouble with <code>rw</code> lately and the error messages were unhelpful (<code>motive is not type correct</code> followed by long jumbles I could not understand), so maybe it will help there too. Thanks so much !</p>",
        "id": 347861377,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1680957969
    },
    {
        "content": "<p>Do you know if the lemma is in mathlib already ?</p>",
        "id": 347861397,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1680957989
    },
    {
        "content": "<p>Long story short, these decidability issues are annoying but usually easily worked around. I say \"easily\" because it's often enough to turn a <code>rw</code> into a <code>simp_rw</code>, force unification of a proof term using <code>convert</code> or <code>congr</code>. And I say \"usually\" because I myself hit a case yesterday where the aforementioned tricks don't work <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span>.</p>",
        "id": 347861718,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1680958108
    },
    {
        "content": "<p>Yeah, \"motive is not type correct\" =&gt; use <code>simp_rw</code>. The reason behind this is that rewriting is the same as applying <code>eq.rec</code> with a suitable \"motive\" (understand, the argument to <code>eq.rec</code>). <code>rw</code> has some way of calculating what the motive should be, but it sometimes gets it wrong. <code>simp_rw</code> follows a more aggressive strategy and tends to succeed more often than <code>rw</code>.</p>",
        "id": 347862534,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1680958419
    },
    {
        "content": "<p>Thank you also for mentioning <code>convert</code>,  another tactic I did not know about but that will be immediately useful.</p>",
        "id": 347862779,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1680958526
    },
    {
        "content": "<p>Your lemma isn't in mathlib, but it's an easy corollary of an existing lemma. I have bad i<br>\nconnection at the moment so I shall guess <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.prod_add\">docs#finset.prod_add</a>.</p>",
        "id": 347862914,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1680958597
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum_pow_mul_eq_add_pow\">docs#finset.sum_pow_mul_eq_add_pow</a> for a more specialised version maybe?</p>",
        "id": 347863141,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1680958692
    },
    {
        "content": "<p>Yes, both lemmas would imply my result pretty quickly. Thanks to both of you !</p>",
        "id": 347863245,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1680958758
    },
    {
        "content": "<p>Well I'm really glad I asked that question, even though I had found a way around it. I just ran into a similar issue in a much more complicated situation (no MWE sorry, it would take a lot of time to extract one) where the problem was different instances of decidability but Lean didn't even tell me; I just had a <code>rw</code> that refused to work for unclear reasons. Thanks to this discussion I was able to figure it out, and <code>open_locale classical</code> (no <code>simp_rw</code> needed this time) solved the problem. Whew !</p>",
        "id": 347912929,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1680983761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Alternating.20sum.20over.20powerset.20and.20decidable.20instances/near/347859849\">said</a>:</p>\n<blockquote>\n<p>Experienced Lean people will probably already sense trouble, because I am using <code>ite</code> on a <code>Prop</code> that has no reason to be decidable. </p>\n</blockquote>\n<p>Actually, it is always possible to decide if a finset is empty; we just don't have the instance because it causes diamonds</p>",
        "id": 347918906,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680988513
    },
    {
        "content": "<p>(the algorithm is just check whether <code>S.card = 0</code>)</p>",
        "id": 347918924,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680988531
    }
]