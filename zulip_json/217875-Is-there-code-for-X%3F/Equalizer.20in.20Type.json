[
    {
        "content": "<p>Do we have explicit equalizer in Type? Specifically:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Equalizer</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>I would assume the answer is no because we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Algebra/Subalgebra/Basic.html#AlgHom.equalizer\">AlgHom.equalizer</a> whose underlying set is defined explicitly.</p>\n<p>But I would also assume yes because surely at some point we would have proved that the category <code>Type u</code> has equaliser...</p>",
        "id": 528056467,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752145861
    },
    {
        "content": "<p>Ok I did further digging on the last sentence,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Limits</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inferInstance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasEqualizer</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Types</span><span class=\"bp\">.</span><span class=\"n\">hasLimit</span>\n</code></pre></div>\n<p>and it seems that it was proved abstractly that <code>Type u</code> has all small limits (remember that <code>Has[...]</code> is a Prop), so... they might have avoided explicitly constructing it for the equaliser diagram explicitly</p>",
        "id": 528057181,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752146123
    },
    {
        "content": "<p>and I did more digging <a href=\"https://github.com/leanprover-community/mathlib4/blob/02c6431ffe61ac7571e0281242e025e54638ad42/Mathlib/CategoryTheory/Limits/Types/Limits.lean#L101-L108\">https://github.com/leanprover-community/mathlib4/blob/02c6431ffe61ac7571e0281242e025e54638ad42/Mathlib/CategoryTheory/Limits/Types/Limits.lean#L101-L108</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">limitCone</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cone</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Shrink</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">sections</span>\n</code></pre></div>",
        "id": 528057375,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752146193
    },
    {
        "content": "<p>so in conclusion I don't think this has been explicitly done in <code>Type u</code> and people probably thought \"but who needs the concrete construction\"</p>",
        "id": 528057824,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752146290
    },
    {
        "content": "<p>We have the dual as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Coequalizer#doc\">docs#Function.Coequalizer</a></p>",
        "id": 528064541,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1752148660
    },
    {
        "content": "<p>We probably have some general API about limits in concrete categories that will allow you to view the equalizer as the set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mtext> </mtext><mi mathvariant=\"normal\">∣</mi><mtext> </mtext><mi>f</mi><mi>x</mi><mo>=</mo><mi>g</mi><mi>x</mi><mo>=</mo><mi>y</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{(x,y) \\ | \\ f x = g x = y \\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\"> </span><span class=\"mord\">∣</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">gx</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">}</span></span></span></span>. What do you need this for?</p>",
        "id": 528074361,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1752151727
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> I have two corepresentable functors <code>F, G: C =&gt; Type</code> and an equaliser diagram <code>F -&gt;-&gt;G</code> and a third functor <code>H</code> isomorphic to the equaliser and I want to show (i.e. construct data) that <code>H</code> is also corepresentable</p>",
        "id": 528176826,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752192541
    },
    {
        "content": "<p>There is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.Types.equalizerIso#doc\">docs#CategoryTheory.Limits.Types.equalizerIso</a>. There are also things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.pullbackObjIso#doc\">docs#CategoryTheory.Limits.pullbackObjIso</a>, but the analogous <code>equalizerObjIso</code> doesn't exist yet I believe.</p>",
        "id": 528287306,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1752222187
    }
]