[
    {
        "content": "<p>So as people who saw me waffling on on Friday will know, I kind of got obsessed with a universes issue. Dagur had clear ideas in his head about what he wanted source and target universes to be for the functor from e.g. compact Hausdorff spaces to condensed sets. However if you follow your nose and just apply Yoneda, this takes you from <code>CompHaus.{u}</code> to <code>Condensed.{u} (Type u)</code> and the latter category doesn't have limits because it's a small category. So Dagur wanted various variants on this functor with some <code>u+1</code>s in. Of course the first idea is to just write down the ULift functor <code>Type u =&gt; Type (u+1)</code> and then \"use that <code>Condensed</code> is functorial\". Of course you can push forward presheaves -- but what about sheaves? I was told that this was in the library and was called <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.sheafCompose#doc\">docs#CategoryTheory.sheafCompose</a> , and indeed that looked good.</p>\n<p>The problems began when I tried to apply this theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">GrothendieckTopology</span> <span class=\"n\">CompHaus.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}}</span>\n\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.universes</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">PreservesLimitsOfSize</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Condensed.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">Condensed.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">D</span> <span class=\"o\">:=</span>\n  <span class=\"n\">sheafCompose</span> <span class=\"n\">J</span> <span class=\"n\">F</span> <span class=\"c1\">-- fails</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">type mismatch</span>\n<span class=\"cm\">  sheafCompose.{0, 1, ?u.52605, ?u.52604} J ?m.52914</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  Functor.{1, 1, max ?u.52605 1, max ?u.52604 1} (Sheaf.{0, 1, 1, ?u.52605} J ?m.52610)</span>\n<span class=\"cm\">    (Sheaf.{0, 1, 1, ?u.52604} J ?m.52612) : Type (max 1 (max ?u.52605 1) ?u.52604 1)</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  Functor.{max 1 v₁, max 1 v₂, max (max 1 v₁) u₁, max (max 1 v₂) u₂} (Condensed.{0, u₁, v₁} C)</span>\n<span class=\"cm\">    (Condensed.{0, u₂, v₂} D) : Type (max (max 1 v₁) (max 1 v₂) (max (max 1 v₁) u₁) (max 1 v₂) u₂)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>The universes don't add up. In fact if you switch universes on and look at <code>sheafCompose</code> you'll see that the morphism universes of both <code>C</code> and <code>D</code> have to be <code>max u v</code> where u,v are the universes for the base category with the topology -- but in particular they have to be <em>equal to each other</em>! Hence there is no way that you can use <code>sheafCompose</code> to go from <code>Type u</code> to <code>Type (u+1)</code> as Dagur wanted to do.</p>\n<p>I took serious wrong turns twice when trying to fix this (first time I was beaten by the <code>max u v = max u ?</code> issue, second time I specialised to large categories too early), but I've finally got it working at least for the base category being <code>CompHaus.{0}</code>, which is a start. The product condition that one needs to ensure a functor <code>F : C =&gt; D</code> gives us <code>Condensed.{0} C =&gt; Condensed.{0} D</code> is <code>PreservesLimitsOfSize.{1, 1, v₁, v₂, u₁, u₂} F</code>, which perhaps implies some weird universe inequality of the form \"if v1 and u1 are &gt;= 1 then u2 had better be too\" or some such thing?</p>\n<p>I have had to generalise several definitions in mathlib, and I modified them by adding a prime. The primed definitions are more universe-general. I will try to PR something coherent to mathlib. I am hoping that this time the changes I'm proposing don't break a bunch of stuff (my last two attempts have been failures).</p>\n<p><a href=\"https://gist.github.com/kbuzzard/229aa3180be3ffe9639956c38e5ed860\">Here</a> is the working gist, or look at the <code>kb-condensed-functoriality</code> branch of the Copenhagen repo.</p>",
        "id": 371610487,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1688264711
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/5659\">#5659</a> it builds :-) Now I should be able to define the obvious functor from <code>Condensed (Type u)</code> to <code>Condensed (Type max u v)</code>!</p>",
        "id": 371626151,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1688273812
    },
    {
        "content": "<p>On that branch, this code compiles:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Condensed.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Sites.Whiskering</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span> <span class=\"n\">Limits</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">x</span> <span class=\"n\">v₂</span> <span class=\"n\">v₁</span> <span class=\"n\">u₂</span> <span class=\"n\">u₁</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">[</span><span class=\"n\">PreservesLimitsOfSize</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Condensed.</span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">Condensed.</span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"n\">D</span> <span class=\"o\">:=</span>\n  <span class=\"n\">sheafCompose</span> <span class=\"n\">_</span> <span class=\"n\">F</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.universes</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"k\">#check</span> <span class=\"n\">foo</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\"> ...</span>\n<span class=\"cm\"> [inst✝² : PreservesLimitsOfSize.{x + 1, x + 1, v₁, v₂, u₁, u₂} F]</span>\n<span class=\"cm\"> ...</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>I think that instance is playing the role of <code>x&lt;=v1</code> etc. I had that code above on Thursday, but it just didn't compile back then because of the universe issue.</p>",
        "id": 371627670,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1688274703
    },
    {
        "content": "<p>Next universe question: there's a <code>ULift</code>-type functor from <code>CompHaus.{u}</code> to <code>CompHaus.{u+37}</code>. Do we have that sheaves (of types, say) for the usual topology at level u+37 pull back to sheaves at level u? u is Scholze's kappa (I'm assuming we don't have to sheafify)</p>",
        "id": 371629464,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1688275798
    },
    {
        "content": "<p>The theorem we need about ulift to prove that we can lift condensed sets is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Condensed.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Sites.Whiskering</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span> <span class=\"n\">Limits</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">CompHaus.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span>\n    <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">GrothendieckTopology.Cover.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">coherentTopology.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">CompHaus.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">CategoryTheory.Functor.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Opposite.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">}</span> <span class=\"n\">CompHaus.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n        <span class=\"n\">PreservesLimit.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">17</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">18</span><span class=\"o\">}</span>\n          <span class=\"o\">(</span><span class=\"n\">MulticospanIndex.multicospan.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">GrothendieckTopology.Cover.index.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">S</span> <span class=\"n\">P</span><span class=\"o\">))</span>\n          <span class=\"n\">uliftFunctor.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">17</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span>  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(that's just an example of universes we'd like it to apply to)</p>",
        "id": 371629831,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1688276022
    }
]