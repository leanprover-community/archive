[
    {
        "content": "<p>I am working on it, together with <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> and <span class=\"user-mention\" data-user-id=\"519559\">@Dagur Ásgeirsson</span> . We are in the common space right below the Auditorium.</p>",
        "id": 370007109,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1687862316
    },
    {
        "content": "<p><a href=\"https://dagur.sites.ku.dk/files/2022/01/condensed-foundations.pdf\">https://dagur.sites.ku.dk/files/2022/01/condensed-foundations.pdf</a> section 1.2.3</p>",
        "id": 370076781,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1687874643
    },
    {
        "content": "<p>So, we did not advance much but if you want you can pull</p>",
        "id": 370112748,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1687880364
    },
    {
        "content": "<p>Cool! I guess one project is to write the correct, error-free statement of <code>dagur115_vi_to_sheaf</code>?</p>",
        "id": 370128240,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1687883032
    },
    {
        "content": "<p>Yep</p>",
        "id": 370153353,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1687887778
    },
    {
        "content": "<p>The statement of <code>dagur115_vi_to_sheaf</code> now makes sense. But it's only for sheaves of types. I think this is what we should work with and then deduce it for more general categories from that</p>",
        "id": 370209903,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1687901184
    },
    {
        "content": "<p>Lemma <code>one'</code> is proved! I'll push after lunch</p>",
        "id": 370709288,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688032707
    },
    {
        "content": "<p>Great!</p>",
        "id": 370719243,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688034324
    },
    {
        "content": "<p>Do you think it also work for <code>Profinite</code> and <code>CompHaus</code>?</p>",
        "id": 370727201,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688035596
    },
    {
        "content": "<p>it is it true, right?)</p>",
        "id": 370727241,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688035601
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">isSheafForDagurSieveSingle</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">ExtrDisc</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Presieve</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">∈</span> <span class=\"n\">DagurSieveSingle</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ExtrDisc.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">IsSheafFor</span> <span class=\"n\">F</span> <span class=\"n\">S</span>\n</code></pre></div>\n<p>is done (modulo the fact that <code>CompHaus</code> preserves <code>Epi</code>).</p>",
        "id": 370835650,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688054013
    },
    {
        "content": "<p><a href=\"https://mathoverflow.net/questions/408839/is-a-closed-subset-of-an-extremally-disconnected-set-again-extremally-disconnect\">https://mathoverflow.net/questions/408839/is-a-closed-subset-of-an-extremally-disconnected-set-again-extremally-disconnect</a></p>\n<p><span class=\"user-mention\" data-user-id=\"519559\">@Dagur Ásgeirsson</span></p>",
        "id": 370858539,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688058161
    },
    {
        "content": "<p>Oh! Then we have to fix the proof that dagurCoverage is a coverage</p>",
        "id": 370859036,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688058263
    },
    {
        "content": "<p>I.e. ExtrDisc probably doesn’t have “pullbacks of right mono”</p>",
        "id": 370859136,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688058288
    },
    {
        "content": "<p>I’ll think more about this tonight or tomorrow</p>",
        "id": 370859222,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688058305
    },
    {
        "content": "<p>We should probably just use the \"weak pullbacks\" that Adam was talking about</p>",
        "id": 370861349,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688058718
    },
    {
        "content": "<p>Ok <span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> , we should forget about <code>HasPullbackOfRightMono</code>. The argument in my thesis that <code>dagurCoverage</code> is a coverage works if you replace the word \"closed\" by \"clopen\"</p>",
        "id": 370872168,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688060959
    },
    {
        "content": "<p>Indeed, any clopen subset of an <code>ExtrDisc</code> is <code>ExtrDisc</code></p>",
        "id": 370872673,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688061022
    },
    {
        "content": "<p>Unfortunately, I think this means that the stuff you guys have written about <code>isPullbackPresieve</code> doesn't apply to <code>ExtrDisc</code></p>",
        "id": 370873865,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688061219
    },
    {
        "content": "<p>I think that <code>isPullbackPresieve</code> is fine. The second (or the first one, I don't know) it is surely a pullback presieve</p>",
        "id": 370875591,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688061531
    },
    {
        "content": "<p>The point is that it may not be a coverage</p>",
        "id": 370875676,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688061548
    },
    {
        "content": "<p>Or you mean we need to change the definition of <code>DagurSieve</code>?</p>",
        "id": 370875947,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688061599
    },
    {
        "content": "<p>Coverage</p>",
        "id": 370876067,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688061610
    },
    {
        "content": "<p>Oh, I see. Then probably keeping on working on the proof that this is a Coverage does not really make sense. What do you think <span class=\"user-mention\" data-user-id=\"519559\">@Dagur Ásgeirsson</span> ?</p>",
        "id": 370876524,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688061694
    },
    {
        "content": "<p>I am more or less convinced that what I did it's ok <em>if</em> it is a coverage</p>",
        "id": 370877512,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688061868
    },
    {
        "content": "<p>Independently on how you prove it</p>",
        "id": 370877585,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688061884
    },
    {
        "content": "<p>Well, the problem is that I am sceptical that it be a coverage in the <code>mathlib</code> sense.</p>",
        "id": 370879737,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688062284
    },
    {
        "content": "<p>(I mean, if we really have a counterexample of a closed not clopen that does not turn out to be ExtrDisc)</p>",
        "id": 370880022,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688062328
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"519559\">@Dagur Ásgeirsson</span> I was thinking that actually things could (perhaps) be savaged. The images of an isomorphic <em>finite</em> presentation of an ExtrDisc as disjoint unions will probably be clopen, not only closed, by compactness. No? In that case, we could keep the strategy, including the <code>HasPullbackOfRightMono</code>.</p>",
        "id": 370885345,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688063346
    },
    {
        "content": "<p>I want to stress that  I am not particularly in love with that class, just that it <em>seemed</em> to work from the abstract point of view. <span aria-label=\"broken heart\" class=\"emoji emoji-1f494\" role=\"img\" title=\"broken heart\">:broken_heart:</span></p>",
        "id": 370885507,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688063387
    },
    {
        "content": "<p>Yes it they are definitely clopen and so the thing is definitely a coverage! I’m also thinking now that the <code>HasPullbackOfRightMono</code> approach works</p>",
        "id": 370897723,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688065837
    },
    {
        "content": "<p>I’m not entirely sure though</p>",
        "id": 370898169,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688065940
    },
    {
        "content": "<p>Maybe we need a class <code>HasPullbackOfDagurIsIso</code></p>",
        "id": 370898217,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688065958
    },
    {
        "content": "<p>Seriously, <code>Profinite</code> and <code>CompHaus</code> have <code>HasPullbackOfWhatever</code></p>",
        "id": 370898405,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688066003
    },
    {
        "content": "<p>(for obvious reasons)</p>",
        "id": 370898444,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688066013
    },
    {
        "content": "<p>then we need to take pullback wrt to those particular morphisms</p>",
        "id": 370898639,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688066051
    },
    {
        "content": "<p>We need to take pullbacks wrt to natural morphisms from coproduts. Maybe those tautologically always exists</p>",
        "id": 370899063,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688066156
    },
    {
        "content": "<p><em>to</em> coproduct</p>",
        "id": 370899145,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688066166
    },
    {
        "content": "<p>I think that a sensible thing to do now is to convince ourselves that <code>ExtrDisc HasPullBackOrRightMono</code>.</p>",
        "id": 370899509,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688066249
    },
    {
        "content": "<p>but this is surely false, isn't it?</p>",
        "id": 370899703,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688066287
    },
    {
        "content": "<p>take the inclusion of a closed <em>not</em> extremally disconnected set</p>",
        "id": 370899817,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688066312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/370899703\">said</a>:</p>\n<blockquote>\n<p>but this is surely false, isn't it?</p>\n</blockquote>\n<p>No, see <span class=\"user-mention\" data-user-id=\"519559\">@Dagur Ásgeirsson</span> 's reply to my comment that the images of a finite isomorphism from a disjoint unions are (probably?) <em>clopen</em> instead of closed.</p>",
        "id": 370899910,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688066336
    },
    {
        "content": "<p>Since clopen in ExtrDisc are still ExtrDisc, we could carry on the previous strategy, which we thought it would work because we believed \"closed in ED implies ED\" (and those images were certainly closed)</p>",
        "id": 370899989,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688066352
    },
    {
        "content": "<p>I mean, mono is not enough, inclusion of clopen is OK</p>",
        "id": 370900102,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688066384
    },
    {
        "content": "<p>Not sure to understand</p>",
        "id": 370900176,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688066402
    },
    {
        "content": "<p>Maybe I am confused</p>",
        "id": 370900246,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688066406
    },
    {
        "content": "<p>Oh, I see what you mean.</p>",
        "id": 370900494,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688066467
    },
    {
        "content": "<p>A mono is the inclusion of a subset right? A subset that of course is in <code>ExtrDisc</code> (since the mono is a morphism in the category)</p>",
        "id": 370900524,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688066477
    },
    {
        "content": "<p>Yes, you are right. Probably the correct class is <code>HasCoverageofSievesHavePullbacks</code></p>",
        "id": 370900622,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688066504
    },
    {
        "content": "<p>(or something like this) saying that there exists a collection of (pre)sieves made up of arrows along which arbitrary pull-backs exist. And this condition would be satisfied by <code>DagurSieveIso</code> by the above description about clopens.</p>",
        "id": 370900972,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688066584
    },
    {
        "content": "<p>I'm not following the details of the discussion, but I think Adam wrote <code>Mathlib/CategoryTheory/Sites/Coherent.lean</code> in order to get the coverage on ExtrDisc as smoothly as possible.</p>",
        "id": 370901617,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1688066754
    },
    {
        "content": "<p>The remaining bit amounts to showing that ExtrDisc is precoherent</p>",
        "id": 370901727,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1688066772
    },
    {
        "content": "<p>I just had a beer with him, and he's a little confused too <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 370901846,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688066795
    },
    {
        "content": "<p>Due to the beer?</p>",
        "id": 370901883,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1688066805
    },
    {
        "content": "<p>Oh no! This would be false for <code>DagurSieveSingle</code>, but that case can be savaged by using that objects in ED are projective.... I think we are heading towards a class <code>IsEquivtoExtrDisc</code>...</p>",
        "id": 370901940,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688066816
    },
    {
        "content": "<p>No, <code>precoherent</code> is perfectly fine</p>",
        "id": 370901976,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688066823
    },
    {
        "content": "<p>Ah ok</p>",
        "id": 370902027,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688066833
    },
    {
        "content": "<p>And where did Adam's confusion come from?</p>",
        "id": 370902094,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688066849
    },
    {
        "content": "<p>The point is the following: we would like to replace (meaning they're the same topology) the <code>precoherent</code> topology on <code>ExtrDiscr</code> with the topology generated by what we call the <code>DagurCoverage</code></p>",
        "id": 370902258,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688066885
    },
    {
        "content": "<p>Now, to specify a coverage I have to give you the <code>Presieve</code></p>",
        "id": 370902317,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688066902
    },
    {
        "content": "<p>Ah sure, then I follow. But <em>why</em>, at the end of the day?</p>",
        "id": 370902330,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688066906
    },
    {
        "content": "<p>those will be of type 1 or type 2</p>",
        "id": 370902358,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688066915
    },
    {
        "content": "<p>I mean, if we can show ExtrDisc is <code>Precoherent</code>, can't we live with the precoherent coverage?</p>",
        "id": 370902406,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688066930
    },
    {
        "content": "<p>type 1 are Presieve corresponding to inclusion to disjoint union</p>",
        "id": 370902470,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688066944
    },
    {
        "content": "<p>type 2 are made by a single Epi</p>",
        "id": 370902511,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688066955
    },
    {
        "content": "<p>Or the problem is that it does not give us the explicit description that we need to \"simply\" test AB5 for presheaves ( easy!)+<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ε</mi></mrow><annotation encoding=\"application/x-tex\">\\varepsilon</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">ε</span></span></span></span>?</p>",
        "id": 370902691,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688066996
    },
    {
        "content": "<p>The point is that we are able to prove (meaning we have a Lean proof) that this coverage generates the coherent topology</p>",
        "id": 370902792,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688067008
    },
    {
        "content": "<p><em>IF</em> it is a coverege</p>",
        "id": 370902843,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688067016
    },
    {
        "content": "<p>No no, I just mean he's not completely sure it is a coverage</p>",
        "id": 370902997,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688067048
    },
    {
        "content": "<p>Yeah sure. But again: <em>why</em> do we want to simplify our life through the DagurCoverage? If the Precoherent condition is met, why can't we simply work with the Coherent coverage as Johan suggests?</p>",
        "id": 370903122,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688067076
    },
    {
        "content": "<p>I thought that the problem came from the fact that the coherent coverage does not give us a sufficiently nice and explicit description of when a presheaf is actually a sheaf, and this is needed for the strategy that we sketched today to prove AB5 for <code>Cond</code>.</p>",
        "id": 370903675,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688067185
    },
    {
        "content": "<p>to prove that a presheaf that presevers (co?)products is a sheaf</p>",
        "id": 370903786,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688067214
    },
    {
        "content": "<p>Yeah, ok.</p>",
        "id": 370903895,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688067240
    },
    {
        "content": "<p>I guess I have to read the real definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Coverage#doc\">docs#CategoryTheory.Coverage</a> (something I should have done before probably)</p>",
        "id": 370904211,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688067314
    },
    {
        "content": "<p>Well, let's say that the true problem lies in checking <code>pullback</code> there. Because you need to show the <code>FactorsThrough</code> condition, and since the presieves in the covering are not required to satisfy any up-wards condition, you have really little room to play around. As soon as you have a map <code>T--&gt;Y</code> to the base, and you try to \"pull-back\" a sieve on <code>Y</code>to <code>T</code> to construct a sieve on <code>T</code>, you create new maps, and these are most likely outside the sieve you started with, precisely because it is not upwards closed.</p>",
        "id": 370904740,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688067454
    },
    {
        "content": "<p>But I am optimistic about the DagurCoverage still being a coverage...</p>",
        "id": 370905206,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688067571
    },
    {
        "content": "<p>I am convinced that dagurCoverage is a coverage, because ExtrDisc “HasPullbackOfRight<strong>Open</strong>Mono”; the covering maps in sieves of type 1 are open monos</p>",
        "id": 370906028,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688067774
    },
    {
        "content": "<p>The def is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">pullback</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Presieve</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">∈</span> <span class=\"n\">covering</span> <span class=\"n\">X</span><span class=\"o\">),</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">Presieve</span> <span class=\"n\">Y</span><span class=\"o\">),</span> <span class=\"n\">T</span> <span class=\"bp\">∈</span> <span class=\"n\">covering</span> <span class=\"n\">Y</span> <span class=\"bp\">∧</span> <span class=\"n\">T.FactorsThruAlong</span> <span class=\"n\">S</span> <span class=\"n\">f</span>\n</code></pre></div>",
        "id": 370906991,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688067982
    },
    {
        "content": "<p>to prove this I would start by a case splitting on <code>_ : S ∈ ...</code></p>",
        "id": 370907132,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688068020
    },
    {
        "content": "<p>What I mean is that the proof of this is in my thesis, the only problem is that it says closed where it should say clopen</p>",
        "id": 370908532,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688068369
    },
    {
        "content": "<p>Yes, indeed, I think that the strategy we currently have is OK. I really believe we should discuss this in front of a blackboard, but I am optimistic that everything can be salvaged.</p>",
        "id": 370909002,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688068465
    },
    {
        "content": "<p>salvaged* I hope</p>",
        "id": 370909577,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1688068615
    },
    {
        "content": "<p>Indeed... <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span> <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 370911466,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688069043
    },
    {
        "content": "<p>Hacking with (pre)coverages for 2 days is not helping my mental health <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 370911677,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688069095
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"519559\">@Dagur Ásgeirsson</span> <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> I think I will call it a night. See you tomorrow!</p>",
        "id": 370914250,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688069752
    },
    {
        "content": "<p>Good night! We'll figure it out tomorrow</p>",
        "id": 370914439,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688069793
    },
    {
        "content": "<p>Same here! I just merged master (to have some results we need) so don't forget to pull</p>",
        "id": 370915007,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688069948
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> what Dagur Filippo and Riccardo are working on is showing that the Grothendieck topology generated by the coherent coverage is also the one generated by a different coverage where covers are either singleton epis or inclusions of components of a finite coproduct. I don’t know exactly what the issue is because I haven’t been working with them but I’m guessing that the second thing might not be a coverage? </p>\n<p>For example if I take a cover associated to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>+</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X + Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> (coproduct) and a random map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Z</mi><mo>→</mo><mi>X</mi><mo>+</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Z \\to X + Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>, then it’s not clear to me how to get such a cover over Z which factors through the two-arrow-presieve associated to the incl of X and Y over that given map. But the characterization of the sheaf condition in terms of products doesn’t necessarily need a coverage. </p>\n<p>I think something that has a better chance of working is the one where covering presieves are given by finite coproducts of finite families of epis.</p>",
        "id": 370915931,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688070166
    },
    {
        "content": "<p>In LTE we did this using the very explicit description in terms of jointly surjective families, but it would be nice to have a more conceptual (and more general) categorical formulation!</p>",
        "id": 370916915,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688070407
    },
    {
        "content": "<p>Ah now I see the map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Z</mi><mo>→</mo><mi>X</mi><mo>+</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Z \\to X + Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is ok, because you have a decomposition of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span> as the coproduct of the preimage of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and the preimage of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>, and that splits <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span> into a disjoint union which factors over the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>, so it's ok :)</p>",
        "id": 370918684,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688070907
    },
    {
        "content": "<p>And if you start with an epi <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X \\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> and a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Z</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Z \\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> you pullback in CompHaus and take a projective presentation of the pullback to obtain an epi.</p>",
        "id": 370918824,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688070957
    },
    {
        "content": "<p>Let me see if I become obsessed with this or I prefer to sleep</p>",
        "id": 370921367,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688071719
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/370918824\">said</a>:</p>\n<blockquote>\n<p>And if you start with an epi <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X \\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> and a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Z</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Z \\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> you pullback in CompHaus and take a projective presentation of the pullback to obtain an epi.</p>\n</blockquote>\n<p>Can't you just take the identity of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span> and use projectivity?</p>",
        "id": 370921603,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688071792
    },
    {
        "content": "<p>Ah yeah that works too!</p>",
        "id": 370921831,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688071839
    },
    {
        "content": "<p>Although it shouldn't matter at the end of the day :)</p>",
        "id": 370921857,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688071846
    },
    {
        "content": "<p>I guess the key point here is that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ι</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>X</mi><mo>∐</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">\\iota : X \\to X \\coprod Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">ι</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∐</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> are extrdisc and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>Z</mi><mo>→</mo><mi>X</mi><mo>∐</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">f : Z \\to X \\coprod Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∐</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is any map from an extrdic, then the pullback of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ι</mi></mrow><annotation encoding=\"application/x-tex\">\\iota</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">ι</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> in CompHaus is again an extrdisc.</p>",
        "id": 370922632,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688072035
    },
    {
        "content": "<p>So perhaps the easiest way to formalize this is by saying something like <code>HasPullback (Sigma.\\iota _ _) f</code> for any <code>f</code> and Sigma.\\iota the inclusion for a finite coproduct.</p>",
        "id": 370922905,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688072116
    },
    {
        "content": "<p>Yes, I totally agree</p>",
        "id": 370922936,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688072128
    },
    {
        "content": "<p>I've run <code>killall lean</code> like 10 times and I still have have 15 lean processes running somehow. Time to shut down the computer. See you all tomorrow!</p>",
        "id": 370923648,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688072347
    },
    {
        "content": "<p>I'm working on proving that for <code>f</code> and <code>i</code> maps in <code>ExtrDisc</code> where <code>OpenEmbedding i</code>, then <code>HasPullback f i</code></p>",
        "id": 370924939,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688072695
    },
    {
        "content": "<p>I think the statement we need is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">π</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span> <span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">IsIso</span> <span class=\"o\">(</span><span class=\"n\">Sigma.desc</span> <span class=\"n\">π</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HasPullback</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 370927030,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688073237
    },
    {
        "content": "<p>with <code>C =ExtrDisc</code></p>",
        "id": 370927121,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688073249
    },
    {
        "content": "<p>I have the impression that we need that coproducts commute with pullbacks: we start with a covering of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><msub><mi>X</mi><mi>i</mi></msub><msub><mo stretchy=\"false\">}</mo><mi>i</mi></msub><mover><mo stretchy=\"true\" minsize=\"3.0em\">→</mo><mpadded width=\"+0.6em\" lspace=\"0.3em\"><mo lspace=\"0em\" rspace=\"0em\">∼</mo></mpadded></mover><mo>∐</mo><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\{ X_i \\}_i \\xrightarrow{\\sim} \\coprod X_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1288em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">}</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel x-arrow\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8788em;\"><span style=\"top:-3.322em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight x-arrow-pad\"><span class=\"mord mtight\"><span class=\"mrel mtight\">∼</span></span></span></span><span class=\"svg-align\" style=\"top:-2.689em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"hide-tail\" style=\"height:0.522em;min-width:1.469em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.011em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∐</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>Y</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">f : Y \\to X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>. Now, the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>Y</mi><mi>i</mi></msub><mo>:</mo><mo>=</mo><mi>Y</mi><msub><mo>×</mo><mi>X</mi></msub><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">Y_i := Y \\times_X X_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">×</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> exist, at least in <code>ExtrDiscr</code>, and using <code>pullback.fst</code> we get a morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>Y</mi><mi>i</mi></msub><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y_i \\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>, so a morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∐</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">\\coprod Y_i \\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∐</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>, but why is this an iso?</p>",
        "id": 370938241,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688077267
    },
    {
        "content": "<p>(we need it to be an iso to show that it is still in the covering)</p>",
        "id": 370938284,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688077286
    },
    {
        "content": "<p>This should follow by the explicit description of the pullback in this case (that is the pullback in Top) but maybe there is a more direct argument</p>",
        "id": 370938871,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688077502
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/370915931\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> what Dagur Filippo and Riccardo are working on is showing that the Grothendieck topology generated by the coherent coverage is also the one generated by a different coverage where covers are either singleton epis or inclusions of components of a finite coproduct. I don’t know exactly what the issue is because I haven’t been working with them but I’m guessing that the second thing might not be a coverage? <br>\n</p>\n</blockquote>\n<p>For the sake of terminology/keywords, the second thing is <em>superextensive</em>. The \"inclusions of components of a finite coproduct\" is the <em>extensive</em> pretopology/coverage. They also come in infinitary versions.</p>",
        "id": 370956395,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1688085359
    },
    {
        "content": "<p>Thanks! So it seems that what we need is that <code>ExtrDiscr</code> is an <em>extensive category</em>. This more or less by definition means that the <code>DagurSieveIso</code> form a coverage (known as the <em>extensive coverage</em>)</p>",
        "id": 371033007,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688110795
    },
    {
        "content": "<p>I totally agree with <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> that one point where I got stuck in proving that <code>FactorsThru</code> property of the Dagur \"coverage\" was in showing that the morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∐</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">\\coprod Y_i\\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∐</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is an iso. Shuold I add this to the file and try to finish the proof with that? The classes needed for <code>ExtrDisc</code> would still be the existence of pullback for embeddings (or the weaker <code>foo</code> suggested by Riccardo) plus the extensivity.</p>",
        "id": 371035743,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688111345
    },
    {
        "content": "<p>Is the following true? Take an extensive category <code>C</code> (whatever this means exactly) that is also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Precoherent#doc\">docs#CategoryTheory.Precoherent</a>. Than the coherent topology, meaning the topology generated by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.coherentCoverage#doc\">docs#CategoryTheory.coherentCoverage</a>, is generated by the <em>union</em> of the extensive coverage and the coverage given by one single morphism that is an effective epi (is this the regular coverage? I don't know)</p>",
        "id": 371035934,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688111390
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"300245\">Filippo A. E. Nuccio</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/371035743\">said</a>:</p>\n<blockquote>\n<p>I totally agree with <span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> that one point where I got stuck in proving that <code>FactorsThru</code> property of the Dagur \"coverage\" was in showing that the morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∐</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">\\coprod Y_i\\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∐</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is an iso. Shuold I add this to the file and try to finish the proof with that? The classes needed for <code>ExtrDisc</code> would still be the existence of pullback for embeddings (or the weaker <code>foo</code> suggested by Riccardo) plus the extensivity.</p>\n</blockquote>\n<p><code>foo</code> is needed, but not enough I think.</p>",
        "id": 371036244,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688111460
    },
    {
        "content": "<p>Why not?</p>",
        "id": 371036306,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688111469
    },
    {
        "content": "<p>It's just the existence of the pullback, you need that the pullback interacts well with disjoint union (this is not automatic)</p>",
        "id": 371036505,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688111509
    },
    {
        "content": "<p>But isnt' it the extensivity?</p>",
        "id": 371036650,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688111527
    },
    {
        "content": "<p>yes</p>",
        "id": 371036678,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688111532
    },
    {
        "content": "<p>That's what I meant by \" <code>foo</code> plus the extensivity\"</p>",
        "id": 371036765,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688111554
    },
    {
        "content": "<p>Sorry, then I agree</p>",
        "id": 371036790,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688111561
    },
    {
        "content": "<p><code>foo</code> is inside extensivity</p>",
        "id": 371036809,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688111569
    },
    {
        "content": "<p>Ah, I though that extensivity was that <em>if</em> the pullback exists, then it commutes with iso (in the sense that the pullback is again an iso)</p>",
        "id": 371037008,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688111627
    },
    {
        "content": "<p>\"Pullbacks of finite-coproduct injections along arbitrary morphisms exist and finite coproducts are disjoint and stable under pullback.\"</p>",
        "id": 371037122,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688111645
    },
    {
        "content": "<p>Sorry, then I agree <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 371037235,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688111673
    },
    {
        "content": "<p>Ah, but as a matter of fact the first bit is exactly <code>HasPullBackofMono</code></p>",
        "id": 371037323,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688111690
    },
    {
        "content": "<p>(restricted to Mono that are finite-coproducts)</p>",
        "id": 371037425,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688111709
    },
    {
        "content": "<p>We need open monos?</p>",
        "id": 371037438,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688111711
    },
    {
        "content": "<p>It is weaker, isn't it?</p>",
        "id": 371037490,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688111724
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/371037490\">said</a>:</p>\n<blockquote>\n<p>It is weaker, isn't it?</p>\n</blockquote>\n<p>What is \"it\"?</p>",
        "id": 371037565,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688111746
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"519559\">Dagur Ásgeirsson</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/371037438\">said</a>:</p>\n<blockquote>\n<p>We need open monos?</p>\n</blockquote>\n<p>I think we need clopen monos, rather.</p>",
        "id": 371037727,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688111780
    },
    {
        "content": "<p>We never consider an arbitrary mono, only those appearing as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>→</mo><mo>∐</mo><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">X_i \\to \\coprod X_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∐</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></p>",
        "id": 371037870,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688111809
    },
    {
        "content": "<p>monos are automatically closed</p>",
        "id": 371037877,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688111812
    },
    {
        "content": "<p>Ah right.</p>",
        "id": 371037908,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688111820
    },
    {
        "content": "<p>all continuous maps in fact</p>",
        "id": 371037938,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688111828
    },
    {
        "content": "<p>So you are asking if open Monos is enough? The argument we sketched yesterday using that in the finite coproduct case the injections from every piece of a <code>DagurIso</code> sieve are open by compactness shuold show it is enough.</p>",
        "id": 371037949,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688111831
    },
    {
        "content": "<p>I'm working on proving pullbacks exist for open monos</p>",
        "id": 371038677,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688111988
    },
    {
        "content": "<p>which should be enough, right?</p>",
        "id": 371038734,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688112003
    },
    {
        "content": "<p>OK, I will then try to add the hypothesis and close the proof that the Dagur coverage is indeed one? <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> , what are you working on? Have you already added something?</p>",
        "id": 371039014,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688112058
    },
    {
        "content": "<p>I have just pushed a statement of a lemma <code>Extensivity</code> with which I can close the first half of DagurCoverage (the piece that has to do with <code>DagurIso</code>)</p>",
        "id": 371064127,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688116697
    },
    {
        "content": "<p>In which file?</p>",
        "id": 371065447,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688116920
    },
    {
        "content": "<p>dagur</p>",
        "id": 371065536,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688116928
    },
    {
        "content": "<p>Well, to be honest I still need that a IsIso is a Mono, which is certailny true but I was too lazy to look at it in the library.</p>",
        "id": 371065657,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688116956
    },
    {
        "content": "<p>See line 86</p>",
        "id": 371065686,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688116964
    },
    {
        "content": "<p>Wow, we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.FinitaryExtensive#doc\">docs#CategoryTheory.FinitaryExtensive</a> !</p>",
        "id": 371098081,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688122374
    },
    {
        "content": "<p>This is probably the right way of stating things, but our approach is more direct</p>",
        "id": 371098255,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688122410
    },
    {
        "content": "<p>OK guys, I am sorry but there are some errors related (probably) to universes. DagurSpecial should be useless by now.</p>",
        "id": 371203591,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688138327
    },
    {
        "content": "<p>No problem, in any case I will only work on OpenEmbedding</p>",
        "id": 371220103,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688140931
    },
    {
        "content": "<p>We’ll figure out the universe issues eventually, it’s probably for very stupid reasons anyway</p>",
        "id": 371243932,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688145123
    },
    {
        "content": "<p>The idea of using the explicit construction is the good one.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">DagurOpenEmbedding</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ExtrDisc.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">OpenEmbedding</span> <span class=\"o\">(</span><span class=\"n\">Sigma.ι</span> <span class=\"n\">Z</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n</code></pre></div>\n<p>is done.</p>",
        "id": 371260955,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688148583
    },
    {
        "content": "<p>I agree,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">dagurCoverage</span>  <span class=\"o\">[</span><span class=\"n\">HasFiniteCoproducts</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasPullbackOfRightMono</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h_proj</span> <span class=\"o\">:</span> <span class=\"n\">EverythingIsProjective</span> <span class=\"n\">C</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">h_ext</span> <span class=\"o\">:</span> <span class=\"n\">Extensivity</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"n\">Coverage</span> <span class=\"n\">C</span>\n</code></pre></div>\n<p>is done and sorry-free, and this implies </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">final</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ExtrDisc.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">A</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"n\">PreservesFiniteProducts</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Presheaf.IsSheaf</span> <span class=\"o\">(</span><span class=\"n\">coherentTopology</span> <span class=\"n\">ExtrDisc</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>which is also sorry-free (provided we can prove that <code>EverythingIsProjective</code> in <code>ExtrDisc</code>, which is Gleason; and <code>Extensivity ExtrDisc</code> which should follow from <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> 's message above)</p>",
        "id": 371315631,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688163280
    },
    {
        "content": "<p>Unfortunately, though, the above <code>def dagurCoverage</code> does not work for <code>CompHaus</code> because <code>EverythingIsProjective CompHaus</code> is certainly false. In particular, the file <code>CompHaus.ExplicitSheaves</code> has an error.</p>",
        "id": 371315783,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688163359
    },
    {
        "content": "<p>Also , after playing a bit with universe variables, the file <code>dagur.lean</code> compiles quickly again.</p>",
        "id": 371315983,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688163435
    },
    {
        "content": "<p>Well <code>final</code> is certainly false for <code>Profinite</code> and <code>CompHaus</code></p>",
        "id": 371316038,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688163471
    },
    {
        "content": "<p>Yes, exactly.</p>",
        "id": 371316057,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688163481
    },
    {
        "content": "<p>I am pretty sure that the coverage is still a coverage, but for a different reason</p>",
        "id": 371316163,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688163509
    },
    {
        "content": "<p>We can with this later</p>",
        "id": 371316203,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688163524
    },
    {
        "content": "<p>I just wanted to mention that we do not even have a <code>dagurCoverage</code> for <code>CompHaus</code> or <code>Profinite</code> and we need to do something about the file. At any rage, for <code>ExtrDisc</code> the coverage is a coverage.</p>",
        "id": 371316233,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688163540
    },
    {
        "content": "<p>We can just comment everything gives an error</p>",
        "id": 371316476,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688163616
    },
    {
        "content": "<p>Let's make <code>final</code> really sorry free</p>",
        "id": 371316515,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688163631
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/371316476\">said</a>:</p>\n<blockquote>\n<p>We can just comment everything gives an error</p>\n</blockquote>\n<p>Can I let you do this since you were the one mainly working in the <code>CompHaus</code> folder?</p>",
        "id": 371316582,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688163661
    },
    {
        "content": "<p>For example ATM lean does not know that <code>ExtrDiscr</code> has coproducts</p>",
        "id": 371316614,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688163669
    },
    {
        "content": "<p>Sure</p>",
        "id": 371316625,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688163673
    },
    {
        "content": "<p>(it does? We need only finite coprodutcts, but there is sorried instance about arbitrary ones)</p>",
        "id": 371316773,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688163731
    },
    {
        "content": "<p>Wait, the disjoint union of compact is hardly compact</p>",
        "id": 371316825,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688163749
    },
    {
        "content": "<p>If they're infinitely many</p>",
        "id": 371316850,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688163759
    },
    {
        "content": "<p>Well, it's not so important</p>",
        "id": 371316885,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688163773
    },
    {
        "content": "<p>I am not sure I will work much during the week-end, but one low-hanging fuit is the <code>EveythingIsProjective</code> lemma from what we did in the <code>Gleason</code>folder.</p>",
        "id": 371316886,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688163773
    },
    {
        "content": "<p>Don't worry, enjoy Copenaghen</p>",
        "id": 371316953,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688163796
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/371316850\">said</a>:</p>\n<blockquote>\n<p>If they're infinitely many</p>\n</blockquote>\n<p>Well, at any rate as you see from the code-snippet above <code>dagurCoverage</code> requires <code>HasFiniteCoproducts</code> so this is really not a problem.</p>",
        "id": 371317066,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688163830
    },
    {
        "content": "<p>Yes yes, those are not a problem at all. I am just curious now, since it has coproducts it means that the forgetful functor does not preserve them, and it's an interesting thing</p>",
        "id": 371317406,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688163962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/371316773\">said</a>:</p>\n<blockquote>\n<p>(it does? We need only finite coprodutcts, but there is sorried instance about arbitrary ones)</p>\n</blockquote>\n<p>I proved that instance about <code>ExtrDisc</code> having finite coproducts. It is on an open PR, feel free to merge that PR to master.</p>\n<p>On that PR I also commented out the instance about arbitrary coproducts in <code>ExtrDisc</code> as I'm not sure it's true. And if I understand correctly, <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> confirms that it's not true, don't you?</p>",
        "id": 371324444,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1688167415
    },
    {
        "content": "<p>I don't know, surely if it is true it is not the disjoint union. Anyway we only need the finite case, thanks!</p>",
        "id": 371326091,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688168312
    },
    {
        "content": "<p>The category of compact Hausdorff spaces is cocomplete. Without checking, I presume you take the Stone-Čech compactification of the disjoint union in Top. The universal property of the compactification gives rise to the universal map needed by the definition of the colimit.</p>",
        "id": 371344148,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1688177054
    },
    {
        "content": "<p>This is easier to see for coproducts, coequalisers needs Hausdorffification, which is not simple to construct.</p>",
        "id": 371344273,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1688177109
    },
    {
        "content": "<p>Here's a fun fact I've not seen mentioned elsewhere: extremally disconnected spaces are the projective objects in the category of Hausdorff <em>regular</em> spaces <a href=\"https://doi.org/10.2307/2035286\">https://doi.org/10.2307/2035286</a></p>",
        "id": 371344639,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1688177287
    },
    {
        "content": "<p>Since the Stone–Čech compactification of a an extremally disconnected space is extremally disconnected (if I believe the unsourced comment here: <a href=\"https://math.stackexchange.com/questions/2814978/%c4%8cech-stone-compactification-of-extremally-disconnected-space?rq=1\">https://math.stackexchange.com/questions/2814978/%c4%8cech-stone-compactification-of-extremally-disconnected-space?rq=1</a>), this should means that arbitrary coproducts of compact Hausdorff extremally disconnected (=Stonean) spaces are given by the Stone–Čech compactification of the disjoint union.</p>",
        "id": 371345248,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1688177585
    },
    {
        "content": "<p>FYI I just merged master  in <code>dagur_ExtrDiscExplicitSheaves</code>. Don't forget to pull</p>",
        "id": 371398972,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688200278
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130272\">David Michael Roberts</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/371345248\">said</a>:</p>\n<blockquote>\n<p>Since the Stone–Čech compactification of a an extremally disconnected space is extremally disconnected (if I believe the unsourced comment here: <a href=\"https://math.stackexchange.com/questions/2814978/%c4%8cech-stone-compactification-of-extremally-disconnected-space?rq=1\">https://math.stackexchange.com/questions/2814978/%c4%8cech-stone-compactification-of-extremally-disconnected-space?rq=1</a>), this should means that arbitrary coproducts of compact Hausdorff extremally disconnected (=Stonean) spaces are given by the Stone–Čech compactification of the disjoint union.</p>\n</blockquote>\n<p>Another way to see this is to use Gleason's theorem along with the fact that an arbitrary coproduct of projectives is again projective (in any category). (Hence no need to use an unsourced comment :))</p>",
        "id": 371403058,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688201212
    },
    {
        "content": "<p>Which coproduct? I mean, in which category? <code>CompHaus</code> does not have coproducts, right?</p>",
        "id": 371404296,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688201464
    },
    {
        "content": "<p>It has finite ones</p>",
        "id": 371404897,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1688201594
    },
    {
        "content": "<p>But that's probably not what Adam was talking about...</p>",
        "id": 371405005,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1688201619
    },
    {
        "content": "<p>Yes, finite are fine in all three categories (<code>ExtrDisc</code>, <code>Profinite</code> and <code>CompHaus</code>), and this is done in the repo.</p>",
        "id": 371405064,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688201634
    },
    {
        "content": "<p>There was a sorried instance about arbitrary coproduct in <code>ExtrDiscr</code>, that it is probably true via Stone-Cech, but I dont see how to apply Gleason</p>",
        "id": 371405343,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688201685
    },
    {
        "content": "<p>In any case we don't need it, I am just curious</p>",
        "id": 371405396,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688201696
    },
    {
        "content": "<p>CompHaus has all colimits ;)</p>",
        "id": 371422709,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688205467
    },
    {
        "content": "<p>(They’re the stonecech compactification of the topological colimit)</p>",
        "id": 371422854,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688205490
    },
    {
        "content": "<p>And thus ExtrDisc has all coproducts by Gleason</p>",
        "id": 371424853,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688205934
    },
    {
        "content": "<p>I have some time at the airport… I’ll try to do this while I wait</p>",
        "id": 371424926,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688205955
    },
    {
        "content": "<p>Let me stress that we don't need it. BTW this <code>sorry</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">presentation</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">CompHaus</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ExtrDisc</span> <span class=\"n\">where</span>\n  <span class=\"n\">compHaus</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">projectivePresentation</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">p</span>\n  <span class=\"n\">extrDisc</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>in <code>ExtrDisc.Basic</code> is done, right?</p>",
        "id": 371425638,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688206108
    },
    {
        "content": "<p>That should follow from Gleason (even the direction of Gleason that’s in mathlib)</p>",
        "id": 371425877,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688206170
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"519559\">@Dagur Ásgeirsson</span> <span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> I made a little clean-up, moving stuff around. Now the construction of pullbacks in <code>ExtrDisc</code> is in its own file. Here is the situation: I think <code>final</code> depends on three <code>sorry</code>:</p>\n<ul>\n<li><code>Extensivity_ExtrDisc</code> in <code>ExtrDisc.ExplicitSheaves</code>: I am working on it.</li>\n<li><code>isPullbackSieve_DagurSieveIso</code> and <code>isSheafForDagurSieveIso</code> both in <code>Sieves.dagur</code>. These should be relatively easy given what we already have. (In any case we should move this file, since it is for <code>ExtrDiscr</code>)</li>\n</ul>\n<p>The file <code>Sieves.DagurSpecial</code> contains a bunch of <code>sorry</code>, but it is not used anywhere, we can ignore it.</p>",
        "id": 371428550,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688206762
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/371425877\">said</a>:</p>\n<blockquote>\n<p>That should follow from Gleason (even the direction of Gleason that’s in mathlib)</p>\n</blockquote>\n<p>Let me do it.</p>",
        "id": 371429475,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688206963
    },
    {
        "content": "<p><a href=\"https://github.com/adamtopaz/CopenhagenMasterclass2023/pull/22\">https://github.com/adamtopaz/CopenhagenMasterclass2023/pull/22</a></p>",
        "id": 371437358,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688208722
    },
    {
        "content": "<p>Feel free to merge once CI is happy</p>",
        "id": 371437793,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688208819
    },
    {
        "content": "<p>I guess you forgot <a href=\"https://github.com/adamtopaz/CopenhagenMasterclass2023/blob/86842557730ccad27973ea6eb59fd21ababc0e52/Condensed/Equivalence.lean#L72\">this</a> line</p>",
        "id": 371439896,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688209317
    },
    {
        "content": "<p>Oops <span aria-label=\"oops\" class=\"emoji emoji-1f643\" role=\"img\" title=\"oops\">:oops:</span></p>",
        "id": 371440321,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688209354
    },
    {
        "content": "<p>I’m sure it’s not the only one</p>",
        "id": 371440368,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688209369
    },
    {
        "content": "<p>do you think the power plug on my flight will be able to keep my laptop alive for 8 hours with lean running?</p>",
        "id": 371451489,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688211518
    },
    {
        "content": "<p>I guess we will see later :D</p>",
        "id": 371452758,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688211820
    },
    {
        "content": "<p>In my flight with WestJet we had real plugs</p>",
        "id": 371452963,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688211859
    },
    {
        "content": "<p><a href=\"https://github.com/adamtopaz/CopenhagenMasterclass2023/blob/762fb49ca640fa663e82a7a94afc8d8e72c7748a/ExtrDisc/Coproducts.lean#L52\">https://github.com/adamtopaz/CopenhagenMasterclass2023/blob/762fb49ca640fa663e82a7a94afc8d8e72c7748a/ExtrDisc/Coproducts.lean#L52</a></p>\n<p>I still have 6 hours in my flight... what's next?</p>",
        "id": 371501913,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688222504
    },
    {
        "content": "<p>Does this implies that if <code>pullback f g</code> exists in <code>ExtrDiscr</code> than <code>CompHaus</code> commute with it?</p>",
        "id": 371505350,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688223323
    },
    {
        "content": "<p>no, this is just for coproducts (over arbitrary sufficiently small types, not just finite ones)</p>",
        "id": 371505465,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688223358
    },
    {
        "content": "<p>Ah sure, <code>Discrete</code>, not <code>Fintype</code> or whatever</p>",
        "id": 371505674,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688223400
    },
    {
        "content": "<p>BTW pushing from 30000 feet in the air is really cool</p>",
        "id": 371506108,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688223497
    },
    {
        "content": "<p>Where have you been working on the ExtrDisc sheaf condition?</p>",
        "id": 371506575,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688223607
    },
    {
        "content": "<p>It seems that the equivalence <code>Sheaf ExtrDisc foobar \\equiv Condensed foobar</code> is sorry-free!</p>",
        "id": 371506747,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688223641
    },
    {
        "content": "<p>Here is our final theorem, in case you want to use to prove stuff about sheaves on condensed</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">final</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ExtrDisc.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">A</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"n\">PreservesFiniteProducts</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Presheaf.IsSheaf</span> <span class=\"o\">(</span><span class=\"n\">coherentTopology</span> <span class=\"n\">ExtrDisc</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 371507559,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688223827
    },
    {
        "content": "<p><del>You probably want to also assume <code>[HasFiniteBiproducts A]</code>.</del></p>",
        "id": 371508037,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688223945
    },
    {
        "content": "<p><del>You probably want to also assume <code>[HasFiniteBiproducts A]</code>.</del></p>",
        "id": 371508075,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688223959
    },
    {
        "content": "<p>Oh wait no nevermind that's needed for the colimit stuff</p>",
        "id": 371508336,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688224010
    },
    {
        "content": "<p>I am pretty sure we don't need it. Of course something depends on sorried statement, but this is the only one that mentions a category different from <code>Type u</code>, and its proof is sorry free.</p>",
        "id": 371508578,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688224069
    },
    {
        "content": "<p>no, you're right, you don't need it for just this statement.</p>",
        "id": 371508727,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688224093
    },
    {
        "content": "<p>What is left for AB5 now? Are there any stray sorries that are not actively worked on?</p>",
        "id": 371509339,
        "sender_full_name": "Nikolas Kuhn",
        "timestamp": 1688224235
    },
    {
        "content": "<p>the proof of <code>AB5</code> for CondensedAb is actually quite technical to formalize IIRC. I can start on that assuming the theorem that Riccardo mentioned.</p>",
        "id": 371510328,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688224478
    },
    {
        "content": "<p>Pushing </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ExtrDisc.Coherent</span>\n<span class=\"kn\">import</span> <span class=\"n\">Condensed.Equivalence</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ExtrDisc</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span> <span class=\"n\">Limits</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">sheafCondition</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ExtrDisc.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">PreservesFiniteProducts</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">↔</span>\n  <span class=\"n\">Presheaf.IsSheaf</span> <span class=\"o\">(</span><span class=\"n\">coherentTopology</span> <span class=\"n\">ExtrDisc</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">ExtrDisc</span>\n</code></pre></div>\n<p>to <code>Condensed/ExtrDiscSheafCondition.lean</code></p>",
        "id": 371512280,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688224919
    },
    {
        "content": "<p>Is it true that the forgetful functor to <code>CompHaus</code> preserves pullback? Assuming the existence in `ExtrDisc</p>",
        "id": 371527723,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688228776
    },
    {
        "content": "<p>I'm not sure.</p>",
        "id": 371535666,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688230844
    },
    {
        "content": "<p>I think yes: If you have a diagram Y -&gt; Z &lt;- X, suppose you have a fiber product V_E in <code> ExtrDisc</code> and let <code>V_C</code> be the one in <code>CompHaus</code> with free resolution P(V_C). Using the universal property in <code> CompHaus</code>, you have a continuous map p: V_E -&gt; V_C, which you can check to be surjective. But using the universal property of V_E, you have a <em>unique</em> (since it is determined by its projections to Y and X) lift of the map P(V_C) -&gt; V_C to a map P(V_C) -&gt; V_E. By the construction of the Stone Cech compactification, this means that V_E -&gt; V_C must be bijective, hence an iso by compactness.</p>",
        "id": 371552832,
        "sender_full_name": "Nikolas Kuhn",
        "timestamp": 1688236764
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> <span class=\"user-mention\" data-user-id=\"519559\">@Dagur Ásgeirsson</span> Thanks for moving things around and closing some sorries. I have tried to follow the thread but could not get if there are still things missing for the equivalence. The AB5 is another thread, no? I am asking simply to make it easier to understand what remains to be done...</p>",
        "id": 371568779,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688243491
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/371428550\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"519559\">Dagur Ásgeirsson</span> <span class=\"user-mention silent\" data-user-id=\"300245\">Filippo A. E. Nuccio</span> I made a little clean-up, moving stuff around. Now the construction of pullbacks in <code>ExtrDisc</code> is in its own file. Here is the situation: I think <code>final</code> depends on three <code>sorry</code>:</p>\n<ul>\n<li><code>Extensivity_ExtrDisc</code> in <code>ExtrDisc.ExplicitSheaves</code>: I am working on it.</li>\n<li><code>isPullbackSieve_DagurSieveIso</code> and <code>isSheafForDagurSieveIso</code> both in <code>Sieves.dagur</code>. These should be relatively easy given what we already have. (In any case we should move this file, since it is for <code>ExtrDiscr</code>)</li>\n</ul>\n<p>The file <code>Sieves.DagurSpecial</code> contains a bunch of <code>sorry</code>, but it is not used anywhere, we can ignore it.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> nobody is working on those I think</p>",
        "id": 371578103,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688247609
    },
    {
        "content": "<p>(Not that I will tonight... I was simply trying to understand <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> )</p>",
        "id": 371578166,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688247665
    },
    {
        "content": "<p>Extensivity for <code>ExtrDisc</code> is done, so its Dagur coverage is officially a coverage.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Coverage</span> <span class=\"n\">ExtrDisc.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">dagurCoverage</span> <span class=\"n\">ExtrDisc</span> <span class=\"n\">EverythingProj_ExtrDisc</span>\n  <span class=\"n\">Extensivity_ExtrDisc</span>\n\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">foo</span> <span class=\"c1\">-- 'foo' depends on axioms: [Quot.sound, propext, Classical.choice]</span>\n</code></pre></div>",
        "id": 371818842,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688336190
    },
    {
        "content": "<p>Tomorrow I will clean up my code, there is a lot of useless stuff.</p>",
        "id": 371818925,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688336232
    },
    {
        "content": "<p>We are really close to <code>final</code>.  The two remaining <code>sorry</code> are both in <code>Sieves.Dagur.lean</code> and should be quite easy (maybe even very easy).</p>",
        "id": 371819133,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688336350
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 371819252,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688336419
    },
    {
        "content": "<p>Great! How far away is the proof that this coverage generates the same topology as the coherent coverage?</p>",
        "id": 371819489,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688336573
    },
    {
        "content": "<p>I'm curious to see precisely what's used in that argument. Is it true for any precoherent category? (My guess is that some additional conditions are needed.)</p>",
        "id": 371819560,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688336628
    },
    {
        "content": "<p>I mean, for <code>foo</code> to be a coverage the category needs some additional conditions as well.</p>",
        "id": 371819642,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688336659
    },
    {
        "content": "<p>But I'm not sure whether those alone suffice.</p>",
        "id": 371819652,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688336670
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/371819489\">said</a>:</p>\n<blockquote>\n<p>Great! How far away is the proof that this coverage generates the same topology as the coherent coverage?</p>\n</blockquote>\n<p>This is already done, sorry free.</p>",
        "id": 371819712,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688336726
    },
    {
        "content": "<p>Awesome!</p>",
        "id": 371819745,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688336745
    },
    {
        "content": "<p>I assume you use the explicit description using joint surjectivity for that?</p>",
        "id": 371819812,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688336764
    },
    {
        "content": "<p>At least we should come up with some abstraction that works for <code>CompHaus</code>, <code>Profinite</code> and <code>ExtrDisc</code> at the same time.</p>",
        "id": 371819848,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688336804
    },
    {
        "content": "<p>The thing is the following: the presieves we consider are of type 1 or type 2:</p>\n<ul>\n<li>type 1: given by <code>Sigma.desc</code>, assuming it is an iso</li>\n<li>type 2: one single morphism, that is an epi</li>\n</ul>\n<p>First of all we need to prove that it is a coverage. I am <em>almost</em> sure that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.CategoryTheory.Extensive#doc\">docs#Mathlib.CategoryTheory.Extensive</a> implies that presieves of type 1 form a coverage and it is probably the good abstraction. We proved that it is a coverage by hand.</p>\n<p>For type 2 it's less clear to me. I think the standard name is the regular coverage, taking one single regular epi. For <code>ExtrDisc</code> it doesn't matter and the presieves form a  coverage because every object is projective. I think for <code>CompHaus</code> and <code>Profinite</code> this follows by the existence of pullbacks, but I didn't check. <span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> was working in this. Maybe in general we need a regular category, or whatever.</p>\n<p>In the proof that the Dagur topology is the same as the coherent one I think we use <code>effectiveEpiFamily_tfae</code>, so I don't know if there is a good abstraction for that. I again suspect that this can be related to regular categories, but my guess is purely based on what people talk about in the nlab.</p>",
        "id": 371820589,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688337259
    },
    {
        "content": "<p>the thing is, regular categories are usually assume to have all finite limits, so that's too restrictive for <code>ExtrDisc</code>.</p>",
        "id": 371820985,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688337506
    },
    {
        "content": "<p>I am less sure about that part, but the point is to ensure that presieves given by a single (regular/effective/whatever) epi form a coverage.</p>",
        "id": 371821350,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688337725
    },
    {
        "content": "<p>For <code>ExtriDiscr</code> it is because of projectivity of every object, that is a strange property.</p>",
        "id": 371821393,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688337747
    },
    {
        "content": "<p>BTW one of the two sorry above is done.</p>",
        "id": 371821407,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688337757
    },
    {
        "content": "<p>So it only remains</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">isSheafForDagurSieveIso</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Presieve</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">∈</span> <span class=\"n\">DagurSieveIso</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"n\">PreservesFiniteProducts</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Presieve.IsSheafFor</span> <span class=\"n\">F</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>(<code>DagurSieveIso</code> are presieves of type 1 above). The idea is to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Equalizer.Presieve.sheaf_condition#doc\">docs#CategoryTheory.Equalizer.Presieve.sheaf_condition</a> (but since the result in mathlib assumes <code>C</code> has <code>pullback</code> I had to generalize it by assuming only that the pullback of arrows in the presieve exist)</p>",
        "id": 371822023,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688338109
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/371821393\">said</a>:</p>\n<blockquote>\n<p>For <code>ExtriDiscr</code> it is because of projectivity of every object, that is a strange property.</p>\n</blockquote>\n<p>Yes, this is one way to see this for <code>ExtrDisc</code>. But there's another, which might generalize more widely (in terms of those \"weak\" pullbacks I mentioned last week): If <code>f : X -&gt; Y</code> is an epi, and <code>g : Z -&gt; Y</code> any morphism, you can pullback in <code>CompHaus</code> and resolve in <code>ExtrDisc</code> to see that singleton epis form a coverage.</p>",
        "id": 371822109,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688338163
    },
    {
        "content": "<p>So in some sense for any epi <code>f</code> and any <code>g</code>, there is <em>some</em> weak pullback of <code>f</code> and <code>g</code> which is an epi. I say \"some\" because those weak pullbacks are not unique upto iso like pullbacks are.</p>",
        "id": 371822313,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688338268
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/371822023\">said</a>:</p>\n<blockquote>\n<p>So it only remains</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">isSheafForDagurSieveIso</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Presieve</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">∈</span> <span class=\"n\">DagurSieveIso</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"n\">PreservesFiniteProducts</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Presieve.IsSheafFor</span> <span class=\"n\">F</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>(<code>DagurSieveIso</code> are presieves of type 1 above). The idea is to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Equalizer.Presieve.sheaf_condition#doc\">docs#CategoryTheory.Equalizer.Presieve.sheaf_condition</a> (but since the result in mathlib assumes <code>C</code> has <code>pullback</code> I had to generalize it by assuming only that the pullback of arrows in the presieve exist)</p>\n</blockquote>\n<p>I am going to sleep, but I think this one is false in general (but true for <code>ExtrDisc</code> and friends): morally it is true because in the usual diagram we take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub><msub><mo>×</mo><mi>X</mi></msub><msub><mi>U</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_i \\times_X U_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">×</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>, and by definition of our presieve we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>=</mo><mo>∐</mo><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">X = \\coprod U_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∐</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, so the pullback is the final object (being empty it's initial in <code>C</code>, but we work with <code>Cᵒᵖ</code>) and in particular <code>F</code> sends it to a singleton. But in general there is no reason for the pullback to be final, see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.BinaryCofan.isPullback_initial_to_of_isVanKampen#doc\">docs#CategoryTheory.BinaryCofan.isPullback_initial_to_of_isVanKampen</a>. In our case it shuld be easy to do it by hand.</p>",
        "id": 371823680,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688339220
    },
    {
        "content": "<p>I really think that the way to go for sieves of type 1 is with extensive categories... but I am too lazy to do it</p>",
        "id": 371823810,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688339300
    },
    {
        "content": "<p>I might give it a try in the afternoon, unless <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> or <span class=\"user-mention\" data-user-id=\"519559\">@Dagur Ásgeirsson</span> or <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> (or anyone else...) is already working on it.</p>",
        "id": 371895705,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688369297
    },
    {
        "content": "<p>I’m not working on anything at the moment. Great to see that it’s almost done!</p>",
        "id": 371916485,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688373850
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> I think you can do something similar to what you already did to prove that the coverage is a coverage: find some sort of categorical assumption (see my message above) and prove it.</p>",
        "id": 371928600,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688376241
    },
    {
        "content": "<p>Then we can prove that <code>ExtrDisc</code> has this property</p>",
        "id": 371928691,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688376251
    },
    {
        "content": "<p>Yes, that's what I had in mind -- and why I proposed to go for it. I'll keep you posted.</p>",
        "id": 371930406,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688376591
    },
    {
        "content": "<p>I think that a good start is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">isSheafForDagurSieveIso</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Presieve</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">∈</span> <span class=\"n\">DagurSieveIso</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"n\">PreservesFiniteProducts</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Presieve.IsSheafFor</span> <span class=\"n\">F</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine'</span> <span class=\"o\">(</span><span class=\"n\">Equalizer.Presieve.sheaf_condition'</span> <span class=\"n\">F</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">isPullbackSieve_DagurSieveIso</span> <span class=\"n\">hS</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">_</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hS</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">Z</span><span class=\"o\">,</span> <span class=\"n\">π</span><span class=\"o\">,</span> <span class=\"n\">hS</span><span class=\"o\">,</span> <span class=\"n\">HIso</span><span class=\"o\">⟩</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Limits.Types.type_equalizer_iff_unique</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">y</span> <span class=\"n\">hy</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 371966350,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688383394
    },
    {
        "content": "<p>What I am doing atm is just replacing the definition of the sieve of type 1 with the one that gives the coproduct definitionally. It's not necessary,  but it is surely nice to have.</p>",
        "id": 371981489,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688386327
    },
    {
        "content": "<p>But are you also keeping the old one, just in case?</p>",
        "id": 371981608,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688386360
    },
    {
        "content": "<p>Using a <code>'</code> or something?</p>",
        "id": 371981665,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688386373
    },
    {
        "content": "<p>I am not pushing anything, so don't worry</p>",
        "id": 371984413,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688386911
    },
    {
        "content": "<p>I mean, I will push it only when everything works</p>",
        "id": 371984642,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688386954
    },
    {
        "content": "<p>But at any rate what do you mean that you \"replace\" the definition? In the <code>dagur</code> file as well? So you need to fix the prove that it is a coverage?</p>",
        "id": 371985075,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688387026
    },
    {
        "content": "<p>Yes, but again, I am doing it.</p>",
        "id": 371985319,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688387064
    },
    {
        "content": "<p>The proof will just became easier</p>",
        "id": 371985380,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688387076
    },
    {
        "content": "<p>Mmm, forget about this, I now think it doesn't work.</p>",
        "id": 371990728,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688388056
    },
    {
        "content": "<p>It's possible that we don't need any particular categorical assumption here.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">isSheafForDagurSieveIso</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Presieve</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">∈</span> <span class=\"n\">DagurSieveIso</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"n\">PreservesFiniteProducts</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Presieve.IsSheafFor</span> <span class=\"n\">F</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine'</span> <span class=\"o\">(</span><span class=\"n\">Equalizer.Presieve.sheaf_condition'</span> <span class=\"n\">F</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">isPullbackSieve_DagurSieveIso</span> <span class=\"n\">hS</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">_</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hS</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">Z</span><span class=\"o\">,</span> <span class=\"n\">π</span><span class=\"o\">,</span> <span class=\"n\">hS</span><span class=\"o\">,</span> <span class=\"n\">HIso</span><span class=\"o\">⟩</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Limits.Types.type_equalizer_iff_unique</span><span class=\"o\">]</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">Equalizer.FirstObj</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">y</span> <span class=\"n\">hy</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Now, goal is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∃!</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">Equalizer.forkMap</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">S</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>and the type of <code>y</code> is <code>∏ fun f =&gt; F.obj f.fst.op</code> (in this product <code>f</code> satisfies <code>S</code>). The point is that there is an iso (since <code>F</code> preserves products)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">∏</span> <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span><span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span> <span class=\"bp\">//</span> <span class=\"n\">S</span> <span class=\"n\">f</span> <span class=\"o\">}</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">F.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">f.1</span><span class=\"o\">)</span> <span class=\"bp\">≅</span> <span class=\"n\">F.obj</span> <span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span><span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span> <span class=\"bp\">//</span> <span class=\"n\">S</span> <span class=\"n\">f</span> <span class=\"o\">}</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">f.1</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>and we can use the assumption of <code>S</code> to transport <code>φ y</code>to <code>F.obj X.op</code>.</p>",
        "id": 372009400,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688391424
    },
    {
        "content": "<p>Atm the I am trying to prove the instance</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Finite</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span><span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span> <span class=\"bp\">//</span> <span class=\"n\">S</span> <span class=\"n\">f</span> <span class=\"o\">})</span>\n</code></pre></div>\n<p>since otherwise we cannot even speak about <code>φ</code></p>",
        "id": 372009646,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688391466
    },
    {
        "content": "<p>Does anyone see a quick way of proving the finiteness? It is surprisingly annoying...</p>",
        "id": 372238381,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688463057
    },
    {
        "content": "<p>The elements in the <code>{</code> are in bijection with alpha, right?</p>",
        "id": 372239000,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688463188
    },
    {
        "content": "<p>Mathematically yes, but is difficult to convince Lean</p>",
        "id": 372239558,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688463305
    },
    {
        "content": "<p>Sure, sure, I was starting mathematically. I want to make sure we agree on what goes on <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 372239712,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688463332
    },
    {
        "content": "<p>The problem is that all types are dependent, so forget about sets</p>",
        "id": 372240247,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688463444
    },
    {
        "content": "<p>Ah, I am stupid: <code>π</code> is surjective from <code>α</code> to what we want.</p>",
        "id": 372241746,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688463768
    },
    {
        "content": "<p>I am now working on <code>isSheafForDagurSieveIso</code>. Still not clear if it is easy or not.</p>",
        "id": 372318694,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688478978
    },
    {
        "content": "<p>If someone wants to help I am now stuck because of <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Product.20and.20coproduct.20in.20the.20opposite.20category\">this</a> question</p>",
        "id": 372409929,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688502026
    },
    {
        "content": "<p>I'll start working on this again tomorrow. Do I understand correctly that once the remaining sorry in <code>isSheafForDagurSieveIso</code> is closed, we have a complete proof of <code>final</code> in <code>ExtrDisc/ExplicitSheaves</code>?</p>\n<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> do you want me to work on something related to that sorry? If that's close to done and you think you'll finish that by yourself, then I can start fixing <code>Profinite/ExplicitSheaves</code> and <code>CompHaus/ExplicitSheaves</code>. When that's done, we should make some TFAE statements for being a condensed set. Anything else?</p>",
        "id": 372419199,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688507014
    },
    {
        "content": "<p>Let me see if I can finish it in the next 48 hours</p>",
        "id": 372419347,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688507101
    },
    {
        "content": "<p>OK I now think there is something quite subtle. Let me explain, and hopefully I will also understand better.</p>\n<p>We start with an object <code>X</code> in a category <code>C</code> (with some properties) and a presieve <code>S : Presieve X</code> such that <code>hS : S ∈ DagurSieveIso X</code>. Given a functor <code>F : Cᵒᵖ ⥤ Type max u v</code> such that <code>PreservesFiniteProducts F</code>, we want to show that <code>Presieve.IsSheafFor F S</code>.</p>\n<p>Since <code>S ∈ DagurSieveIso X</code>, we have that <code>S = Presieve.ofArrows Z π</code>, where <code>α</code> is a <code>Fintype, </code>Z : α → C<code> and </code>(a : α) → Z a ⟶ X<code>. Moreover, we have </code>IsIso (Sigma.desc π)`. So far so good.</p>\n<p>The assumptions on <code>C</code> imply that <code>isPullbackSieve S</code>, so we can use the analogue of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Equalizer.Presieve.sheaf_condition#doc\">docs#CategoryTheory.Equalizer.Presieve.sheaf_condition</a> (we have already proved this). Via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.Types.type_equalizer_iff_unique#doc\">docs#CategoryTheory.Limits.Types.type_equalizer_iff_unique</a> what we have to prove now is the usual equalizer condition, I mean <a href=\"https://stacks.math.columbia.edu/tag/00VM\">this</a> one.</p>\n<p>The math proof, following the notations of the Stack project (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span></span></span></span> is our <code>X</code> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is <code>Z a</code>), is pretty simple: we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi><mo>∈</mo><msub><mo>∏</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub><mi mathvariant=\"script\">F</mi><mo stretchy=\"false\">(</mo><msub><mi>U</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">y \\in \\prod_{i \\in I} \\mathcal F(U_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0771em;vertical-align:-0.3271em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">I</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3271em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mrow><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">r</mi></mrow><mn>0</mn><mo>∗</mo></msubsup><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msubsup><mrow><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">r</mi></mrow><mn>1</mn><mo>∗</mo></msubsup><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{pr}_0^\\ast (y) = \\mathrm{pr}_1^\\ast (y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">pr</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-2.4519em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">pr</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-2.4519em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span>, and we have to prove that there is a unique <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi><mo>∈</mo><mi mathvariant=\"script\">F</mi><mo stretchy=\"false\">(</mo><mi>U</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">z \\in \\mathcal F(U)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span></span></span></span> such that its image is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span>. Now, we don't care about the condition (that morally is always satisfied since our covering is disjoint), and we use that, since <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">F</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span></span></span></span> sends coproduct to product we have that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∏</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub><mi mathvariant=\"script\">F</mi><mo stretchy=\"false\">(</mo><msub><mi>U</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mo>≅</mo><mi mathvariant=\"script\">F</mi><mo stretchy=\"false\">(</mo><mi>U</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\prod_{i \\in I} \\mathcal F(U_i) \\cong \\mathcal F(U)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0771em;vertical-align:-0.3271em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">I</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3271em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span></span></span></span> and we're done.</p>\n<p>In Lean, things are a little more complicated, since <code>X</code> is not literally the disjoint union, it is only isomorphic via <code>Sigma.desc π</code>, but this is not a real problem. Let me be totally precise. We have isomorphisms (I mean, we have in Lean)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"n\">F.obj</span> <span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Z</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">≅</span>  <span class=\"bp\">∏</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">F.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Z</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"bp\">∐</span> <span class=\"n\">Z</span> <span class=\"bp\">≅</span> <span class=\"n\">X</span>\n\n<span class=\"o\">(</span><span class=\"bp\">∐</span> <span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span> <span class=\"bp\">≅</span> <span class=\"bp\">∏</span> <span class=\"k\">fun</span> <span class=\"n\">z</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span>\n</code></pre></div>\n<p>so everything looks good, except that all these product/coproduct are indexed over <code>α</code>, and <em>this is not the index set of the product in stack project!</em> The index set there is given by <code>S</code>, so to be again completely precise in Lean it is (let me call it <code>T</code>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ</span><span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">),</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span> <span class=\"bp\">//</span> <span class=\"n\">S</span> <span class=\"n\">f</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>It is easy to construct a function <code>v : α → T</code>, that sends <code>a</code> to the arrow <code>π a</code> in the sigma type, and by definition this function is surjective. But <em>it is not injective</em> in general! Indeed <code>π</code> can a priori very well give two times the same morphism. At the beginning I thought this was not the case since <code>Sigma.desc π</code> is an iso, but if we have <code>a ≠ b</code> such that <code>Z a = Z b = ∅</code>, then <code>a</code> and <code>b</code> are sent to the same element in <code>T</code>.</p>\n<p>So the point is the following: we have <code>y</code> with type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∏</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">F.obj</span> <span class=\"n\">f.fst.op</span>\n</code></pre></div>\n<p>and we need to construct a term of type <code>F.obj X.op</code>. We can use the isos above (or their variations for <code>T</code> instead of <code>α</code>), but at some point we need to produce a function <code>v : T → α</code> (for example the right inverse of <code>v</code> above).  Being the right inverse will prove that our element is sent to <code>y</code> or that it is the only one that can be sent to <code>y</code> (it's too late to understand this), but not the other condition. What do you think?</p>\n<p>Sorry for the very long message, it is mainly useful to myself I guess.</p>",
        "id": 372428455,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688513258
    },
    {
        "content": "<p>Mathematically, it's fine because the only way this happens is in the case you mention where <code>a ≠ b</code> with <code>Z a = Z b = ∅</code>. And you seem to be on the right track, you just need to show that the function <code>v : α → T</code> induces an isomorphism on the products?</p>",
        "id": 372504052,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688545717
    },
    {
        "content": "<p>I really mean <code>v : α → T</code>, no need to produce a function in the other direction. The isomorphism on the products is the only thing you need, right?</p>",
        "id": 372504262,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688545767
    },
    {
        "content": "<p>I'll start working on <code>Profinite/ExplicitSheaves</code> and <code>CompHaus/ExplicitSheaves</code></p>",
        "id": 372504387,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688545798
    },
    {
        "content": "<p>Sure, I am not saying there is a mathematical problem , only a Lean one</p>",
        "id": 372505840,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688546091
    },
    {
        "content": "<p>I know. But you agree about the direction of the map <code>v</code>?</p>",
        "id": 372505950,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688546114
    },
    {
        "content": "<p>Oh, I didn't read your message carefully, but I was to prove exactly that. To be precise we need that it is an iso and its inverse is the morphism already in the diagram</p>",
        "id": 372507004,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688546355
    },
    {
        "content": "<p>I mean, not its inverse</p>",
        "id": 372507082,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688546374
    },
    {
        "content": "<p>But that it is compatible with the given morphism</p>",
        "id": 372507151,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688546392
    },
    {
        "content": "<p>To do <code>Profinite/ExplicitSheaves</code> etc. I'm defining a <code>dagurCoverage' [HasFiniteCoproducts C] [HasPullbacks C] (h_ext : Extensivity C)</code>. We don't have that anywhere yet, right?</p>",
        "id": 372507958,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688546561
    },
    {
        "content": "<p>Not exactly, but most of the proof should be the same</p>",
        "id": 372508641,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688546705
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> should know</p>",
        "id": 372508725,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688546722
    },
    {
        "content": "<p>Yeah the first half is identical, but in the second half I use the pullback instead of projectivity</p>",
        "id": 372508774,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688546736
    },
    {
        "content": "<p>The coverage is the same, so maybe it's convenient to write a lemma that says the set of sieves form a coverage</p>",
        "id": 372508963,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688546771
    },
    {
        "content": "<p>I am in a meeting now, I will read the thread in the afternoon (if it is not too late....)</p>",
        "id": 372509299,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688546858
    },
    {
        "content": "<p>Pushing <code>dagurCoverage'</code> for categories with pullback now. I define it in <code>dagur.lean</code> just below <code>dagurCoverage</code></p>",
        "id": 372513980,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688547880
    },
    {
        "content": "<p>The proofs of <code>one</code> and <code>one'</code> worked perfectly well for <code>Profinite</code> and <code>CompHaus</code>, so if <code>dagurCoverage'</code> is the same as <code>dagurCoverage</code> (except for the proof the <code>Prop</code> valued part) they should work too.</p>",
        "id": 372538138,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688552748
    },
    {
        "content": "<p>Yes those are done. \"Sorried\" in the commit messages meant that extensivity and <code>epi_pullback_of_epi</code> are sorried. I'm working on that now</p>",
        "id": 372546044,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688554484
    },
    {
        "content": "<p>It seems like it should be enough to prove extensivity for <code>CompHaus</code> and then deduce it for <code>Profinite</code> and <code>ExtrDisc</code> by proving that the property is preserved by pullback-and-finite-coproduct-preserving functors</p>",
        "id": 372546568,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688554599
    },
    {
        "content": "<p>We should also come up with a good way to state the equalizer condition for a single surjection for the explicit properties a presheaf on <code>Profinite/CompHaus</code> has to satisfy to be a condensed set</p>",
        "id": 372547362,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688554772
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 372554205,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688556233
    },
    {
        "content": "<p>Forget my last message</p>",
        "id": 372554369,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688556264
    },
    {
        "content": "<p>Parentheses are messed up <span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span></p>",
        "id": 372558661,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688557131
    },
    {
        "content": "<p>I just pushed some progress on extensivity of CompHaus</p>",
        "id": 372569920,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688559568
    },
    {
        "content": "<p>There is one annoying sorry in <code>extensivity_injective</code></p>",
        "id": 372570008,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688559583
    },
    {
        "content": "<p><code>exact Sigma.subtype_ext Hfst hR</code> works in the analogue for <code>ExtrDisc</code>, but for some reason it doesn't work in <code>CompHaus</code>...</p>",
        "id": 372570415,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688559646
    },
    {
        "content": "<p>Maybe someone wants to take a look</p>",
        "id": 372570437,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688559652
    },
    {
        "content": "<p>Where exactly is this pushed?</p>",
        "id": 372577044,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1688560955
    },
    {
        "content": "<p>On branch  <code>dagur_ExtrDiscExplicitSheaves</code> of the <a href=\"https://github.com/adamtopaz/CopenhagenMasterclass2023\">Copenhagen repo</a></p>",
        "id": 372579927,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688561468
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/372508641\">said</a>:</p>\n<blockquote>\n<p>Not exactly, but most of the proof should be the same</p>\n</blockquote>\n<p>Yes, I confirm that we did not have them. But it seems they are on their way....</p>",
        "id": 372629374,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688570446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"519559\">Dagur Ásgeirsson</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/372570008\">said</a>:</p>\n<blockquote>\n<p>There is one annoying sorry in <code>extensivity_injective</code></p>\n</blockquote>\n<p>I've been fighting with Lean about this sorry for the last few hours... I'm stopping now and I'll push my progress if someone wants to take a look. Also, <code>extensivity_explicit</code> is kind of slow, I don't know why</p>",
        "id": 372635231,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688571421
    },
    {
        "content": "<p>I am also fighting a little with Lean :)</p>\n<p>I've pushed the iso between products and coprodut in the opposite category, and there is a sorry <a href=\"https://github.com/adamtopaz/CopenhagenMasterclass2023/blob/c0c0b83b7bd0743e964d28c3e57c1a6ae02c688f/Sieves/ProdCoprod.lean#L73\">here</a> that we need.</p>",
        "id": 372636391,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688571629
    },
    {
        "content": "<p>It's the fact that the iso sends the inclusion to the projection, or the other way around and it is hopefully true...</p>",
        "id": 372636534,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688571659
    },
    {
        "content": "<p>This small lemma is done.</p>",
        "id": 372647210,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688573659
    },
    {
        "content": "<p>I've pushed some progress towards the last sorry in <code>Dagur.lean</code>. The file is a mess ATM, hopefully I will be able to finish it tomorrow. In any case I will clean it up.</p>",
        "id": 372662866,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688576943
    },
    {
        "content": "<p>Boom!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">final</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ExtrDisc.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">A</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"n\">PreservesFiniteProducts</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Presheaf.IsSheaf</span> <span class=\"o\">(</span><span class=\"n\">coherentTopology</span> <span class=\"n\">ExtrDisc</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">one'</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">E</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Presieve.isSheaf_coverage</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">fun</span> <span class=\"n\">S</span> <span class=\"n\">hS</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isSheafFor_of_Dagur</span> <span class=\"n\">hS</span>\n    <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">J</span> <span class=\"n\">inst</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">hF.1</span><span class=\"bp\">;</span> <span class=\"n\">compPreservesLimitsOfShape</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">final</span> <span class=\"c1\">--'final' depends on axioms: [Quot.sound, propext, Classical.choice]</span>\n</code></pre></div>",
        "id": 372720130,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688593774
    },
    {
        "content": "<p>I will clean up the proof tomorrow. There is room for quite a lot of PR to mathlib :)</p>",
        "id": 372720311,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688593844
    },
    {
        "content": "<p>That's a great milestone! It was one of the \"key results\" which Adam and I wanted to get done. The other one is AB5 for Condensed Ab :-)</p>",
        "id": 372720328,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1688593851
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"519559\">@Dagur Ásgeirsson</span> In my opinion we should define two coverages, not only two types of presieves. Indeed, they mix in exactly only proof (the fact that together they generate the coherent topology)</p>\n<ul>\n<li>for the first one to be a coverage we used <code>HasPullbackOfIsIsodesc</code> and <code>Extensivity</code>. The first one is obviously true if there are pullbacks and the second one follows by the explicit description of the pullback in <code>ExtrDisc</code> (the same strategy works in <code>Profinte</code> and <code>CompHaus</code>). If we want to go deep in the categorical rabbit hole then extensive categories are the way (we need  \"inclusions in the coproduct are disjoint \" and \"something like that). In any case the interesting thing is that we have proved the following</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">CategoryTheory.isSheafForDagurSieveIso.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"bp\">✝¹</span> <span class=\"o\">:</span> <span class=\"n\">HasFiniteCoproducts</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"bp\">✝²</span> <span class=\"o\">:</span> <span class=\"n\">HasPullbackOfIsIsodesc</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Presieve</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">∈</span> <span class=\"n\">DagurSieveIso</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)}</span>\n  <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"n\">PreservesFiniteProducts</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Presieve.IsSheafFor</span> <span class=\"n\">F</span> <span class=\"n\">S</span>\n</code></pre></div>\n<p>in particular we don't need to know anything like extensivity (this is about one particular presieve, so no coverage is involved), and <code>HasPullbackOfIsIsodesc</code> is very reasonable, since it is implied by <code>HasPullbacks</code>. This was quite hard to prove, but it is the \"trivial\" statement that a presheaf that sends finite disjoint unions to products satisfies the sheaf condition for a covering given by a disjoint union.</p>\n<ul>\n<li>the second coverage is a coverage if <code>EverythingIsProjective</code>, and in this case the sheaf condition is automatic. This is a very specific condition that miraculously holds for <code>ExtrDisc</code> but we can forget about it. You are working on the fact that <code>HasPullback</code> implies that this is a coverage, right? I think we also need something like <code>effectiveEpiFamily_tfae</code>, but I don't see exactly a good generalization (it should be something related to regular epi). For the condition of being a sheaf wrt to this presieve I don't think there is anything very interesting, we be more explicit using <code>Equalizer.Presieve.sheaf_condition'</code> (or the mathlib version without <code>'</code> if the category has pullbacks) and <code>Limits.Types.type_equalizer_iff_unique</code> but that's it in my opinion.</li>\n</ul>",
        "id": 372723726,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688595431
    },
    {
        "content": "<p>Split epis automatically form a coverage for an even sillier reason, though it's not enough to get a pretopology: Given a split epi p:A -&gt; B, with section s:B-&gt;A, and a map f:C-&gt;B, then the required cover of C is the identity map (which is a split epi), and then the map sf:C-&gt;B-&gt;A completes the commutative square.</p>",
        "id": 372736917,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1688603113
    },
    {
        "content": "<p>You don't need pullbacks, but perhaps you need those for a different reason, eg that the superextensive pretopology is actually a pretopology, not just a coverage.</p>",
        "id": 372737074,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1688603180
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/372723726\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"519559\">Dagur Ásgeirsson</span> In my opinion we should define two coverages, not only two types of presieves. Indeed, they mix in exactly only proof (the fact that together they generate the coherent topology)</p>\n<ul>\n<li>for the first one to be a coverage we used <code>HasPullbackOfIsIsodesc</code> and <code>Extensivity</code>. The first one is obviously true if there are pullbacks and the second one follows by the explicit description of the pullback in <code>ExtrDisc</code> (the same strategy works in <code>Profinte</code> and <code>CompHaus</code>). If we want to go deep in the categorical rabbit hole then extensive categories are the way (we need  \"inclusions in the coproduct are disjoint \" and \"something like that). In any case the interesting thing is that we have proved the following</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">CategoryTheory.isSheafForDagurSieveIso.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"bp\">✝¹</span> <span class=\"o\">:</span> <span class=\"n\">HasFiniteCoproducts</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"bp\">✝²</span> <span class=\"o\">:</span> <span class=\"n\">HasPullbackOfIsIsodesc</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Presieve</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">∈</span> <span class=\"n\">DagurSieveIso</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)}</span>\n  <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"n\">PreservesFiniteProducts</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Presieve.IsSheafFor</span> <span class=\"n\">F</span> <span class=\"n\">S</span>\n</code></pre></div>\n<p>in particular we don't need to know anything like extensivity (this is about one particular presieve, so no coverage is involved), and <code>HasPullbackOfIsIsodesc</code> is very reasonable, since it is implied by <code>HasPullbacks</code>. This was quite hard to prove, but it is the \"trivial\" statement that a presheaf that sends finite disjoint unions to products satisfies the sheaf condition for a covering given by a disjoint union.</p>\n<ul>\n<li>the second coverage is a coverage if <code>EverythingIsProjective</code>, and in this case the sheaf condition is automatic. This is a very specific condition that miraculously holds for <code>ExtrDisc</code> but we can forget about it. You are working on the fact that <code>HasPullback</code> implies that this is a coverage, right? I think we also need something like <code>effectiveEpiFamily_tfae</code>, but I don't see exactly a good generalization (it should be something related to regular epi). For the condition of being a sheaf wrt to this presieve I don't think there is anything very interesting, we be more explicit using <code>Equalizer.Presieve.sheaf_condition'</code> (or the mathlib version without <code>'</code> if the category has pullbacks) and <code>Limits.Types.type_equalizer_iff_unique</code> but that's it in my opinion.</li>\n</ul>\n</blockquote>\n<p>But how would you concretely use them? So you would construct these two \"collections\" of sieves, and adding some adapted hypotheses each of them becomes a coverage?</p>",
        "id": 372793502,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688628270
    },
    {
        "content": "<p>What do you mean? My point is just about not duplicating all the proofs.</p>",
        "id": 372796687,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688629124
    },
    {
        "content": "<p>Sure, but I do not understand how you would do this concretely.</p>",
        "id": 372797663,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688629377
    },
    {
        "content": "<p>Perhaps my problem is to understand what are the two coverages you are speaking about.</p>",
        "id": 372798104,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688629485
    },
    {
        "content": "<p>Sieves given disjoint union and sieves given by a single coverage</p>",
        "id": 372799078,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688629726
    },
    {
        "content": "<p>We can have a typeclass \"type one is a coverage\", and define the coverage on any category with this instance (tautologically)</p>",
        "id": 372799336,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688629787
    },
    {
        "content": "<p>And then provide various instances</p>",
        "id": 372799367,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688629797
    },
    {
        "content": "<p>But for \"disjoint unions\" do you require epi or iso (for single epi, I guess, no?)</p>",
        "id": 372799484,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688629818
    },
    {
        "content": "<p><code>Sigma.desc</code> is an iso</p>",
        "id": 372799586,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688629853
    },
    {
        "content": "<p>I have the impression that when they form a coverage, for any reason, they have good properties</p>",
        "id": 372799817,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688629916
    },
    {
        "content": "<p>But then you need something like the coverage generated by two coverages, right?  I mean, for <code>ExtrDisc</code>, neither coverage generates the top alone, you need both.</p>",
        "id": 372800069,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688629977
    },
    {
        "content": "<p>A union of two coverages is a coverage, right?</p>",
        "id": 372812676,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688632874
    },
    {
        "content": "<p>Yes, that's the point</p>",
        "id": 372812712,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688632883
    },
    {
        "content": "<p>Set-theoretic union</p>",
        "id": 372812736,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688632891
    },
    {
        "content": "<p>But anyway, the thing I'm struggling with is extensivity of CompHaus, the rest is basically done (except finding a good statement for the sheaf condition for a single epi, right now it's not ideal, you can look in <code>CompHaus/ExplicitSheaves</code>)</p>",
        "id": 372813508,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688633043
    },
    {
        "content": "<p>I can have a look, but the same proof should work, right?</p>",
        "id": 372814211,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688633196
    },
    {
        "content": "<p>The coproduct is still the disjoint union</p>",
        "id": 372814261,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688633207
    },
    {
        "content": "<p>Well, for ExtrDisc the pullback was defined as a subtype, so you could use <code>Sigma.subtype_ext</code>. Now that doesn't work and if I use <code>Sigma.ext</code> I have to prove a <code>HEq</code></p>",
        "id": 372817899,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688633916
    },
    {
        "content": "<p>Oh no, an <code>Heq</code> seems bad! I can also have a look, unless <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> is already on it.</p>",
        "id": 372818529,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688634034
    },
    {
        "content": "<p>I didn't start, so go aheaed</p>",
        "id": 372818589,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688634048
    },
    {
        "content": "<p>but <code>Heq</code> is almost surely a bad idea</p>",
        "id": 372818650,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688634060
    },
    {
        "content": "<p>Yeah I know, I'm trying to add some API for <code>CompHaus.finiteCoproduct</code> to prove when a map out of a finite coproduct is injective. Right now the old proof is commented below</p>",
        "id": 372818936,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688634112
    },
    {
        "content": "<p>I think I have something now that will work</p>",
        "id": 372819136,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688634141
    },
    {
        "content": "<p>It's strange that the subtype thing does not work here</p>",
        "id": 372819160,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688634146
    },
    {
        "content": "<p>I think I can write my map out of the coproduct as a <code>Sigma.map</code>, and there are some lemmas about injectivity of those</p>",
        "id": 372819529,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688634223
    },
    {
        "content": "<p>No nevermind</p>",
        "id": 372819807,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688634276
    },
    {
        "content": "<p>I misunderstood</p>",
        "id": 372819879,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688634296
    },
    {
        "content": "<p>Either of you go ahead and take a look!</p>",
        "id": 372819977,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688634317
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/372819160\">said</a>:</p>\n<blockquote>\n<p>It's strange that the subtype thing does not work here</p>\n</blockquote>\n<p>It's not strange that <code>Sigma.subtype_ext</code> doesn't work, because the components of the sigma aren't subtypes</p>",
        "id": 372821252,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688634591
    },
    {
        "content": "<p>I mean, it's strange it works for <code>ExtrDisc</code> and not in the other cases</p>",
        "id": 372822069,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688634746
    },
    {
        "content": "<p>No because in <code>ExtrDisc</code> we defined the pullback not as usual, but as a subtype</p>",
        "id": 372822370,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688634807
    },
    {
        "content": "<p>But actually in this case it's a subtype of the product, so maybe one could make <code>Sigma.subtype_ext</code> work by tweaking the first part of the proof</p>",
        "id": 372822524,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688634840
    },
    {
        "content": "<p>Ah sure. We can do exactly the same though, using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CompHaus.pullback#doc\">docs#CompHaus.pullback</a></p>",
        "id": 372824446,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688635217
    },
    {
        "content": "<p>That is what we're using</p>",
        "id": 372824587,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688635252
    },
    {
        "content": "<p>I should probably stop saying nonsense and looking at the code</p>",
        "id": 372825043,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688635336
    },
    {
        "content": "<p>Btw, my <code>finiteCoproduct.injective_of</code> is of course not true. But when trying to prove it, I think I found a way to prove <code>extensivity_injective</code></p>",
        "id": 372839250,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688638352
    },
    {
        "content": "<p>I still don't understand exactly why the proof doesn't work for <code>CompHaus</code>. In both cases we uses explicit limits, so the pullback is a subtype of the product. The difference seems that Lean, for <code>CompHaus</code>, goes via <code>Top</code> or something like that.</p>",
        "id": 372839911,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688638487
    },
    {
        "content": "<p>Ah, the explicit definition of the pullback is not the same</p>",
        "id": 372840511,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688638614
    },
    {
        "content": "<p>OK, I have a proof of <code>extensivity_injective</code></p>",
        "id": 372841163,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688638775
    },
    {
        "content": "<p>Pretty ugly, but it works</p>",
        "id": 372841254,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688638796
    },
    {
        "content": "<p>It's pushed</p>",
        "id": 372841762,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688638917
    },
    {
        "content": "<p>great!</p>",
        "id": 372843117,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688639210
    },
    {
        "content": "<p>So <code>CompHaus/ExplicitSheaves</code> is now sorry-free, but we don't have the analogous statement to <code>final</code> in <code>ExtrDisc/ExplicitSheaves</code>.</p>",
        "id": 372843921,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688639373
    },
    {
        "content": "<p>I'll work on <code>Profinite/ExplicitSheaves</code> now, trying to deduce <code>extensivity</code> and <code>epi_pullback_of_epi</code> from <code>CompHaus</code></p>",
        "id": 372844374,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688639464
    },
    {
        "content": "<p>What do you think of a typeclass <code>hasDagurCoverage</code> saying that <code>DagurCoverage</code> is a coverage? Having that and <code>HasPullbackOfIsIsodesc</code> all the proofs about <code>DagurSieveIso</code> should work</p>",
        "id": 372847679,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688640221
    },
    {
        "content": "<p>and we avoid duplicating the code</p>",
        "id": 372847723,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688640229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"519559\">Dagur Ásgeirsson</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/372844374\">said</a>:</p>\n<blockquote>\n<p>I'll work on <code>Profinite/ExplicitSheaves</code> now, trying to deduce <code>extensivity</code> and <code>epi_pullback_of_epi</code> from <code>CompHaus</code></p>\n</blockquote>\n<p>Actually maybe I'll just duplicate everything. We already have <code>Profinite.finiteCoproduct</code> and <code>Profinite.pullback</code></p>",
        "id": 372848107,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688640289
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/372847679\">said</a>:</p>\n<blockquote>\n<p>What do you think of a typeclass <code>hasDagurCoverage</code> saying that <code>DagurCoverage</code> is a coverage? Having that and <code>HasPullbackOfIsIsodesc</code> all the proofs about <code>DagurSieveIso</code> should work</p>\n</blockquote>\n<p>We will still have to duplicate some code to prove <code>hasDagurCoverage</code> for all three sites</p>",
        "id": 372848288,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688640317
    },
    {
        "content": "<p>Sure, that part has to be done</p>",
        "id": 372848363,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688640329
    },
    {
        "content": "<p>But I would be fine with it, it would at least reduce the three identical proofs of <code>one'</code> to one proof</p>",
        "id": 372848475,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688640360
    },
    {
        "content": "<p>Does <code>[HasDagurCoverage C] [Precoherent C]</code> imply that the Dagur coverage generates the coherent topology?</p>",
        "id": 372848839,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688640441
    },
    {
        "content": "<p>Our proof uses <code>epi_iff_surjective</code></p>",
        "id": 372848937,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688640465
    },
    {
        "content": "<p>I mean, the explicit description of <code>EffectiveEpiFamily</code></p>",
        "id": 372849133,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688640495
    },
    {
        "content": "<p>yeah, that's what I figured.</p>",
        "id": 372849136,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688640496
    },
    {
        "content": "<p>I <em>think</em> the statement is true for the category of projectives in any coherent category.</p>",
        "id": 372849274,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688640519
    },
    {
        "content": "<p>And certainly in a coherent category the statement is true</p>",
        "id": 372849381,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688640545
    },
    {
        "content": "<p>But I still don't know of a natural categorical criterion which ensures that this holds.</p>",
        "id": 372849489,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688640567
    },
    {
        "content": "<p>Does every coherent category satisfy extensivity?</p>",
        "id": 372849736,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688640614
    },
    {
        "content": "<p>Tne <a href=\"https://ncatlab.org/nlab/show/coherent+coverage\">nlab</a> says \"If C is extensive, then its coherent topology is generated by the regular topology together with the extensive topology. \"</p>",
        "id": 372849779,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688640623
    },
    {
        "content": "<p>The extensive topology is generated by what we call <code>DagurSieveIso</code></p>",
        "id": 372849931,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688640658
    },
    {
        "content": "<p>Where <br>\nregular topology = the one generated by <code>DagurSieveSingle</code><br>\nextensive topology = generated by <code>DagurSieveIso</code>?</p>",
        "id": 372850032,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688640678
    },
    {
        "content": "<p>and the regular topology in our cases coincides with the one generated by <code>DagurSieveSingle</code></p>",
        "id": 372850057,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688640682
    },
    {
        "content": "<p>But the definitions are different, as the name suggest the regular topology uses regular epi (just one, as in <code>DagurSieveSingle</code>)</p>",
        "id": 372850173,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688640714
    },
    {
        "content": "<p>To be honest I am not even sure that in our cases \"regular epi iff epi\", but I think so</p>",
        "id": 372850416,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688640753
    },
    {
        "content": "<p>yes, that's true for comphaus / profinite / extrdic</p>",
        "id": 372850536,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688640782
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"519559\">Dagur Ásgeirsson</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/372849736\">said</a>:</p>\n<blockquote>\n<p>Does every coherent category satisfy extensivity?</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"519559\">Dagur Ásgeirsson</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/372849736\">said</a>:</p>\n<blockquote>\n<p>Does every coherent category satisfy extensivity?</p>\n</blockquote>\n<p><a href=\"https://ncatlab.org/nlab/show/coherent+category#extensivity\">almost</a></p>",
        "id": 372851052,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688640894
    },
    {
        "content": "<p>OK, just pushed <code>Profinite/ExplicitSheaves</code>. Duplicated a lot of the explicit limit API from CompHaus</p>",
        "id": 372855905,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688641838
    },
    {
        "content": "<p>Now in <code>isSheafFor_of_Dagur</code> in <code>CompHaus/ExplicitSheaves</code> and <code>Profinite/ExplicitSheaves</code>, the additional hypothesis on the presheaf is just  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">hFecs</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Presieve</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">∈</span> <span class=\"n\">DagurSieveSingle</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">IsSheafFor</span> <span class=\"n\">F</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but we want it to be something like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">hFecs</span> <span class=\"o\">:</span> <span class=\"n\">EqualizerCondition</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>where <code>EqualizerCondition</code> is the explicit sheaf condition for a single surjection in a way that's nice to work with. In LTE, this was </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">equalizer_condition</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span>\n<span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Profinite.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">surj</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">π</span><span class=\"o\">),</span>\n<span class=\"n\">function.bijective</span> <span class=\"o\">(</span><span class=\"n\">map_to_equalizer</span> <span class=\"n\">P</span> <span class=\"n\">π</span> <span class=\"o\">(</span><span class=\"n\">Profinite.pullback.fst</span> <span class=\"n\">π</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Profinite.pullback.snd</span> <span class=\"n\">π</span> <span class=\"n\">π</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">Profinite.pullback.condition</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 372857442,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688642143
    },
    {
        "content": "<p>Any opinions on this?</p>",
        "id": 372857839,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688642220
    },
    {
        "content": "<p>Yes, that's better</p>",
        "id": 372861064,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688642875
    },
    {
        "content": "<p>It should be easy, right?</p>",
        "id": 372861105,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688642881
    },
    {
        "content": "<p>Yeah I think so</p>",
        "id": 372861189,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688642890
    },
    {
        "content": "<p>Just use <code>Equalizer.Presieve.sheaf_condition</code> and <code>Limits.Types.type_equalizer_iff_unique</code></p>",
        "id": 372861283,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688642908
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 372861662,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688642991
    },
    {
        "content": "<p>nonsense, sorry</p>",
        "id": 372861803,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688643012
    },
    {
        "content": "<p>Just pushed some progress, I've reduced it to two stupid sorries about commutativity of some diagrams with isomorphisms between objects and products over a singleton. We might need some more more API for the explicit limits in CompHaus</p>",
        "id": 372940954,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688657427
    },
    {
        "content": "<p>I am not sure I will time tomorrow, and I am going to Leiden on Sunday (also Filippo), so we will probably be a little slow.</p>",
        "id": 372951363,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688659446
    },
    {
        "content": "<p>I am also finishing preparing my talk for there, so I <em>am already</em> very slow <span aria-label=\"snail\" class=\"emoji emoji-1f40c\" role=\"img\" title=\"snail\">:snail:</span></p>",
        "id": 372958357,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1688660865
    },
    {
        "content": "<p>No worries. Have fun in Leiden!</p>",
        "id": 372967841,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688662969
    },
    {
        "content": "<p>Ok the stupid sorries are done</p>",
        "id": 372980125,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688666062
    },
    {
        "content": "<p>We now also have: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">final</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">CompHaus.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">A</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"n\">PreservesFiniteProducts</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hF'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">EqualizerCondition</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">⋙</span> <span class=\"n\">coyoneda.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">E</span><span class=\"o\">)))</span> <span class=\"o\">:</span>\n  <span class=\"n\">Presheaf.IsSheaf</span> <span class=\"o\">(</span><span class=\"n\">coherentTopology</span> <span class=\"n\">CompHaus</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">one'</span><span class=\"o\">]</span>\n  <span class=\"n\">refine'</span> <span class=\"k\">fun</span> <span class=\"n\">E</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Presieve.isSheaf_coverage</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">_</span>\n  <span class=\"n\">intro</span> <span class=\"n\">B</span> <span class=\"n\">S</span> <span class=\"n\">hS</span>\n  <span class=\"n\">apply</span> <span class=\"n\">isSheafFor_of_Dagur</span> <span class=\"n\">hS</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">J</span> <span class=\"n\">inst</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">hF.1</span><span class=\"bp\">;</span> <span class=\"n\">compPreservesLimitsOfShape</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">hF'</span> <span class=\"n\">E</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">final'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)}</span>\n    <span class=\"o\">[</span><span class=\"n\">HasLimits</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">PreservesLimits</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ReflectsIsomorphisms</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">CompHaus.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">A</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"n\">PreservesFiniteProducts</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">⋙</span> <span class=\"n\">G</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hF'</span> <span class=\"o\">:</span> <span class=\"n\">EqualizerCondition</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">⋙</span> <span class=\"n\">G</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">Presheaf.IsSheaf</span> <span class=\"o\">(</span><span class=\"n\">coherentTopology</span> <span class=\"n\">CompHaus</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Presheaf.isSheaf_iff_isSheaf_forget</span> <span class=\"o\">(</span><span class=\"n\">coherentTopology</span> <span class=\"n\">CompHaus</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n    <span class=\"n\">isSheaf_iff_isSheaf_of_type</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">one'</span><span class=\"o\">,</span> <span class=\"n\">Presieve.isSheaf_coverage</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">B</span> <span class=\"n\">S'</span> <span class=\"n\">hS</span>\n  <span class=\"n\">exact</span> <span class=\"n\">isSheafFor_of_Dagur</span> <span class=\"n\">hS</span> <span class=\"n\">hF</span> <span class=\"n\">hF'</span>\n\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">final</span>\n<span class=\"c1\">-- 'CompHaus.final' depends on axioms: [Quot.sound, propext, Classical.choice]</span>\n\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">final'</span>\n<span class=\"c1\">-- 'CompHaus.final'' depends on axioms: [propext, Quot.sound, Classical.choice]</span>\n</code></pre></div>\n<p>and its analogue for <code>Profinite</code></p>",
        "id": 372994210,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688669715
    },
    {
        "content": "<p>Here, <code>final</code> is not very helpful, and in all cases of interest I think <code>final'</code> is more useful</p>",
        "id": 372994414,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688669771
    },
    {
        "content": "<p>I'm planning on cleaning up our code now (in particular rename everything that's called <code>dagur</code>-something), and then merge it into master</p>",
        "id": 372998063,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688670717
    },
    {
        "content": "<p>I've opened a PR and it passes CI, but I'll keep pushing to the branch until the code is a bit nicer</p>",
        "id": 372998284,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688670773
    },
    {
        "content": "<p>Our code is now merged into master</p>",
        "id": 373007751,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688673542
    },
    {
        "content": "<p>Here is a dictionary:</p>\n<ul>\n<li><code>DagurOpenEmbedding</code> = <code>openEmbedding_ι</code></li>\n<li><code>DagurSieveIso </code> = <code>ExtensiveSieve</code></li>\n<li><code>DagurSieveSingle</code> = <code>RegularSieve</code></li>\n<li><code>dagurCoverage</code>/ <code>dagurCoverage'</code> = <code>ExtensiveRegularCoverage</code>/<code>ExtensiveRegularCoverage'</code></li>\n<li><code>isSheafFor_of_Dagur</code> = <code>isSheafFor_of_extensiveRegular</code></li>\n<li><code>one'</code> = <code>extensiveRegular_generates_coherent</code></li>\n</ul>",
        "id": 373008417,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688673682
    },
    {
        "content": "<p>Wow, thanks!</p>",
        "id": 373012202,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688674845
    },
    {
        "content": "<p>A bit sad for our beloved dagur coverage, but that's life</p>",
        "id": 373012276,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688674882
    },
    {
        "content": "<p>I can guess your answer but... Are we really sure we don't need a <code>for_mathlib</code> folder?</p>",
        "id": 373013852,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688675411
    },
    {
        "content": "<p>Everything is going in mathlib!</p>",
        "id": 373013926,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688675445
    },
    {
        "content": "<p>I agree, but I mean a folder with stuff that is ready to be PRed</p>",
        "id": 373017687,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688676583
    },
    {
        "content": "<p>Yes that would be nice</p>",
        "id": 373017783,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688676610
    },
    {
        "content": "<p>For example <code>ExtrDisc/Gleason</code> is ready to be PRed to mathlib. I'm just gonna add everything in that file to the file <code>Mathlib/Topology/ExtremallyDisconnected</code> and open a PR</p>",
        "id": 373018601,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688676901
    },
    {
        "content": "<p>Then we can create a <code>Mathlib/Topology/Category/ExtrDisc/Basic</code> which imports that file</p>",
        "id": 373018721,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688676938
    },
    {
        "content": "<p>Oh I see <span class=\"user-mention\" data-user-id=\"464700\">@David Ang</span>  already has a branch <code>gleason</code> on mathlib</p>",
        "id": 373018973,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688677021
    },
    {
        "content": "<p>But there the file has some sorries. Is it an older version of our <code>ExtrDisc/Gleason</code>?</p>",
        "id": 373019378,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688677163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"519559\">Dagur Ásgeirsson</span> <a href=\"#narrow/stream/384459-Copenhagen-Masterclass-2023/topic/Characterization.20of.20sheaves.20on.20ExtDisc/near/373018973\">said</a>:</p>\n<blockquote>\n<p>Oh I see <span class=\"user-mention silent\" data-user-id=\"464700\">David Ang</span>  already has a branch <code>gleason</code> on mathlib</p>\n</blockquote>\n<p>I'm almost done with this and it should be ready for review by the weekend. The old code had a lot of definitions that's only used once in the proof so I was trying to refactor everything to make the argument more readable.</p>",
        "id": 373019826,
        "sender_full_name": "David Ang",
        "timestamp": 1688677301
    },
    {
        "content": "<p>Is the one remaining <code>sorry</code> hard? Is it not something we already have in the Copenhagen repo?</p>",
        "id": 373020631,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688677541
    },
    {
        "content": "<p>The statement in the Copenhagen repo is surely sorry free (since we use it, and our result is sorry free)</p>",
        "id": 373022012,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688678014
    },
    {
        "content": "<p>The proof is basically <span class=\"user-mention\" data-user-id=\"496319\">@Nikolas Kuhn</span>'s proof in the Copenhagen repo, so the main idea is already <code>sorry</code>-free. However the current code was a statement about a very specific compact space <code>D'</code> that we defined for the proof, and I was trying to refactor it to be a general statement about compact spaces for the PR to mathlib. I encountered some technical set-type issues and I've solved all of them yesterday, but the code might involve stupid hacks like these:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">B</span><span class=\"o\">}</span>\n<span class=\"kn\">private</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_coe_of_mem</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha'</span> <span class=\"o\">:</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">ha'</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩⟩</span>\n<span class=\"kn\">private</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_subset</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨⟨⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩⟩</span><span class=\"bp\">;</span> <span class=\"n\">convert</span> <span class=\"n\">ha</span>\n<span class=\"kn\">private</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_of_mem_coe</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">coe_subset</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rcases</span> <span class=\"n\">ha</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span><span class=\"bp\">;</span> <span class=\"n\">convert</span> <span class=\"n\">ha</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">lemma</span> <span class=\"n\">isClosed_trans</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hC</span> <span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hB</span> <span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsClosed</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">isClosed_induced_iff.mp</span> <span class=\"n\">hC</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">D</span><span class=\"o\">,</span> <span class=\"n\">hD</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n  <span class=\"n\">convert</span> <span class=\"n\">IsClosed.inter</span> <span class=\"n\">hB</span> <span class=\"n\">hD</span>\n  <span class=\"n\">ext</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">coe_subset</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">mem_of_mem_coe</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">hB</span><span class=\"o\">,</span> <span class=\"n\">hD</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mem_coe_of_mem</span> <span class=\"n\">hB</span> <span class=\"n\">hD</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>The issue was about converting between <code>C</code> as a subset of <code>B</code>, which is a subset of a type <code>A</code>, and <code>C</code> as a subset of <code>A</code>.</p>",
        "id": 373023943,
        "sender_full_name": "David Ang",
        "timestamp": 1688678666
    },
    {
        "content": "<p>I think \"stupid hacks like these\" belong in mathlib. These are very useful statements when doing topology</p>",
        "id": 373024563,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688678934
    },
    {
        "content": "<p>I wasn't 100% sure about that - if you try to investigate the types of the lemmas you see a lot of <code>Lean.Internal.coeM</code> which is not used much (if at all) in the rest of mathlib from what I can tell.</p>",
        "id": 373024842,
        "sender_full_name": "David Ang",
        "timestamp": 1688679037
    },
    {
        "content": "<p>Ah ok I see</p>",
        "id": 373025404,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1688679255
    },
    {
        "content": "<p>From when I spoke about these lemmas with Kevin I felt that there should exist some coercion doing what is needed for these lemmas, perhaps it's just that we need to make a nice looking coercion with higher priority rather than using the one that comes from Set being a monad or whatever the weird one is</p>",
        "id": 373236733,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1688741360
    }
]