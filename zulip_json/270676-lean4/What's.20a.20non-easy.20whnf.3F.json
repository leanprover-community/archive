[
    {
        "content": "<p>I'm looking at before/after traces after a change in mathlib's typeclass system and I see that I have made some <code>Non-easy whnf</code>s disappear. FWIW the diff looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code>5426,5432c5426,5427\n<span class=\"gd\">&lt;                 [Meta.whnf] [21.000000] Non-easy whnf: SMulZeroClass M A</span>\n<span class=\"gd\">&lt;                 [Meta.whnf] [21.000000] Non-easy whnf: AddZeroClass A</span>\n<span class=\"gd\">&lt;                 [Meta.whnf] [21.000000] Non-easy whnf: DistribSMul M A</span>\n<span class=\"gd\">&lt;                 [Meta.whnf] [21.000000] Non-easy whnf: SMul M A</span>\n<span class=\"gd\">&lt;                 [Meta.whnf] [21.000000] Non-easy whnf: Zero A</span>\n<span class=\"gd\">&lt;                 [Meta.whnf] [21.000000] Non-easy whnf: SMulZeroClass M A</span>\n<span class=\"gd\">&lt;                 [Meta.isDefEq] [11491.000000] ✅️ (Algebra.id (MvPolynomial σ R)).toSMul =?= instDistribSMul.toSMul</span>\n<span class=\"gs\">---</span>\n<span class=\"gi\">&gt;                 [Meta.isDefEq] [10411.000000] ✅️ (Algebra.id</span>\n<span class=\"gi\">&gt;                         (MvPolynomial σ R)).toSMul =?= Mul.toSMul' (MvPolynomial σ R)</span>\n</code></pre></div>\n<p>(the change is that the RHS of the <code>=?=</code> is now different). I doubt this is much to fuss about, 21.000000 mheartbeats is nothing, but I was wondering what I'd done. I know I'm just supposed to read the source code but it's meaningless to me. I found <a href=\"https://github.com/leanprover/lean4/pull/3774\">lean4#3774</a> which will presumably tell some people what the answer is, but the PR has no description.</p>",
        "id": 568611915,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1768679574
    },
    {
        "content": "<p>i think (from reading the PR) that a non-easy whnf is one which hasn't been cached before?</p>",
        "id": 568612110,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1768679780
    },
    {
        "content": "<p>The easy whnfs are:</p>\n<ul>\n<li>those that are already in the whnf cache, so don't need to be recomputed</li>\n<li>expressions that are obviously already in WHNF (foralls, unapplied lambdas, universes, and literals)</li>\n<li>expressions that are let-defined free variables or assigned metavariables and after unfolding them they're easy whnfs</li>\n</ul>",
        "id": 568612216,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1768679898
    },
    {
        "content": "<p>For example, <code>SMulZeroClass M A</code> is not an easy whnf since it's a constant application. Deciding if it's in WHNF requires details about the definition <code>SMulZeroClass</code>.</p>",
        "id": 568612337,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1768680046
    },
    {
        "content": "<p>Easy/non-easy doesn't seem particularly relevant here; my understanding is that the new isDefEq problem after the typeclass changes is easier(*) for isDefEq to resolve: it's asking for fewer things to be put in WHNF.</p>\n<p>(*) At least in terms of number of WHNF calculations.</p>",
        "id": 568612480,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1768680201
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/What's.20a.20non-easy.20whnf.3F/near/568612337\">said</a>:</p>\n<blockquote>\n<p>For example, <code>SMulZeroClass M A</code> is not an easy whnf since it's a constant application. Deciding if it's in WHNF requires details about the definition <code>SMulZeroClass</code>.</p>\n</blockquote>\n<p>reading your explanation, maybe it'd be more relevant to say \"deciding <em>what the WHNF is</em> requires details\"? because although it is true, it could still be an easy whnf if it's been cached?</p>",
        "id": 568612555,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1768680304
    },
    {
        "content": "<p>I was imprecise saying that cached results are \"easy\". It's an explanation for what skips the \"Non-easy whnf\" trace message.</p>\n<p>For my comment about requiring details, that's more an explanation of my understanding of the design of this part of the WHNF reducer. In the end, an \"easy case\" is what <code>whnfEasyCases</code> is implemented to handle. I don't think there's any technical definition beyond the practical implementation.</p>",
        "id": 568612807,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1768680622
    }
]