[
    {
        "content": "<p>This is an MWE (well, sort of minimal) extracted from an Aesop failure at <a href=\"https://github.com/leanprover-community/mathlib4/pull/7909\">#7909</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Category.TopCat.Basic</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">TopCat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">TopCat.of</span> <span class=\"n\">PUnit.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exists</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PUnit.unit</span>\n  <span class=\"n\">with_reducible</span> <span class=\"n\">apply</span> <span class=\"n\">continuous_const</span> <span class=\"c1\">-- tactic 'apply' failed, failed to assign synthesized instance</span>\n</code></pre></div>\n<p>The <code>with_reducible apply</code> fails even though the target unifies with the conclusion of <code>continuous_const</code> at <code>reducible</code> transparency. The issue seems to be that <code>apply</code> checks <a href=\"https://github.com/leanprover/lean4/blob/dcb40f67c1ef635caf87423d5a4b1c4786f9d9ac/src/Lean/Meta/Tactic/Apply.lean#L64\">here</a> whether some synthesised instances are defeq to inferred instances. In the above example, this check succeeds at <code>default</code> or <code>instances</code> transparency, but fails at <code>reducible</code>.</p>\n<p>What would be a good solution to this in the context of Aesop rules that should be applied with <code>reducible</code> transparency? Change <code>apply</code> such that it performs this defeq check with at least <code>default</code> transparency (or maybe <code>instances</code>)? Turn off the check for Aesop's version of <code>apply</code>?</p>",
        "id": 401174140,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1699542129
    },
    {
        "content": "<p>I think this suggests that there is some API missing to translate between raw functions and morphisms</p>",
        "id": 401183455,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699544803
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Category.TopCat.Basic</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"sd\">/-- type-cast between the underlying map and the categorical spelling -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">TopCat.mkHom</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">TopCat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousMap</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">TopCat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">TopCat.of</span> <span class=\"n\">PUnit.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">TopCat.mkHom</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">exists</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PUnit.unit</span>\n  <span class=\"n\">with_reducible</span> <span class=\"n\">apply</span> <span class=\"n\">continuous_const</span> <span class=\"c1\">--success</span>\n</code></pre></div>",
        "id": 401184359,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699545084
    },
    {
        "content": "<p>I don't mind this solution because it means less work for me. ;)</p>\n<p>Still, the user experience is very suboptimal: a lemma reducibly matches the target yet <code>with_reducible apply</code> fails to apply it. Does anyone have an intuition as to what would break if the check were performed at <code>instances</code> or <code>default</code> transparency? I'm guessing not much since the check should succeed in the vast majority of cases, but maybe I'm wrong.</p>",
        "id": 401222078,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1699557997
    }
]