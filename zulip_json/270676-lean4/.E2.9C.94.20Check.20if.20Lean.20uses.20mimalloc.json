[
    {
        "content": "<p>I'm updating Lean from 4.18 to 4.19 as a package of a Linux distribution, and that involves adding mimalloc as a dependency.  Things don't work out-of-the-box because CMake tries to use git to fetch it as a dependency, which is not compatible with the way packages are built in the distribution.  To solve this issue, I've tried to patch the CMakeLists.txt file, and fetch mimalloc using the packaging primitives.  Lean appears to be building without complaining it can't find mimalloc, so I am somewhat confident that it worked, but I'd like to double check that it didn't just resort to simply not using it.  Is there a way to check that the blob I get out of the build step indeed uses mimalloc?</p>",
        "id": 516018405,
        "sender_full_name": "jthulhu",
        "timestamp": 1746356937
    },
    {
        "content": "<p>I guess the easiest way would be to just run lean with gdb on some random lean file and set a breakpoint at <code>mi_free</code>, if that's hit you should be good.</p>\n<p>Note that we do not generally recommend packaging Lean for distributions right now.</p>",
        "id": 516019195,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1746357607
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"674423\">jthulhu</span> <a href=\"#narrow/channel/270676-lean4/topic/Check.20if.20Lean.20uses.20mimalloc/near/516018405\">said</a>:</p>\n<blockquote>\n<p>I'm updating Lean from 4.18 to 4.19 as a package of a Linux distribution</p>\n</blockquote>\n<p>Please, <em>please</em> don’t do that. You will only bring pain to your users, and then to us all when they’ll come here and ask for help.</p>",
        "id": 516023366,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1746361356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/270676-lean4/topic/Check.20if.20Lean.20uses.20mimalloc/near/516023366\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"674423\">jthulhu</span> <a href=\"#narrow/channel/270676-lean4/topic/Check.20if.20Lean.20uses.20mimalloc/near/516018405\">said</a>:</p>\n<blockquote>\n<p>I'm updating Lean from 4.18 to 4.19 as a package of a Linux distribution</p>\n</blockquote>\n<p>Please, <em>please</em> don’t do that. You will only bring pain to your users, and then to us all when they’ll come here and ask for help.</p>\n</blockquote>\n<p>Even though I've never tried that because I've always exclusively used Lean through my package manager, prebuilt binaries usually do not work out of the box in the distribution I use, so there is a thin chance installing Lean with elan would work.</p>\n<p>Besides, I don't see the point in <em>not</em> packaging Lean for my distribution.  I want to handle the software installed on my computer the way I see it, and I fail to understand why, if I take the time to make it work on my machine in a certain way, I couldn't share this work I've done so that other people that would prefer to handle the Lean package in the same way I do could do the same.</p>\n<p>I've contributed to packaging Lean for my distribution for approximately one year and, so far, I have received exactly 0 reports of the packaging introducing issues for the end users.</p>",
        "id": 516024956,
        "sender_full_name": "jthulhu",
        "timestamp": 1746362669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"674423\">jthulhu</span> has marked this topic as resolved.</p>",
        "id": 516024982,
        "sender_full_name": "Notification Bot",
        "timestamp": 1746362700
    },
    {
        "content": "<p>I would guess that either the end users are not also trying to use Mathlib, or if they are then they are not aware of how to report the issue.</p>",
        "id": 516077642,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746400371
    },
    {
        "content": "<p>I'm not part of Lean's core team, but I just have a comment. Lean is open source, so of course you're allowed to do whatever you would like with it, but I think the worry is that people will come to this Zulip and ask for help, not realizing that their issues were caused by the way in which they installed Lean. As an example of an issue that might occur, <code>elan</code> is used to make sure that the <code>lean-toolchain</code> file in a project is respected, which guarantees that everyone working on the same repository is using the same Lean version. Lean does not have strong backward compatibility guarantees right now, so not respecting <code>lean-toolchain</code> will mean that working on a sufficiently complicated library like Mathlib will almost never work with your installation method.</p>\n<p>I think if you are to going to be packaging Lean this way, you might want to consider clearly labeling your versions as unofficial (you haven't linked to it yet, so I don't know whether you've already done this). You are of course welcome to share your work, as long as its clear that it is not the recommended way to install Lean.</p>\n<p>What distribution are you using? <code>elan</code> is a fork of <code>rustup</code>, so maybe your distribution could handle <code>elan</code> the same way that it handles <code>rustup</code>? How does it handle other programs which need to update frequently and control their own updates, e.g. web browsers?</p>",
        "id": 516127752,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746430793
    },
    {
        "content": "<p>For \"Lean does not have strong backward compatibility guarantees\", read  \"Lean does not have any backward compatibility guarantees\"</p>",
        "id": 516129893,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1746431442
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"674423\">@jthulhu</span> Reiterating the above, please please do not publish packaged versions of Lean that do not respect <code>lean-toolchain</code> in user projects. If you <em>must</em>, please make sure you call it <code>lean-broken</code> or <code>lean-do-not-use</code> etc, and emphasise in the README that this is not intended for end users, carefully explaining why it is not usable.</p>",
        "id": 516136140,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1746433377
    },
    {
        "content": "<p>The lean package in question is most likely the <a href=\"https://github.com/NixOS/nixpkgs/blob/nixos-unstable/pkgs/by-name/le/lean4/package.nix\">nixpkgs lean4 package</a>.<br>\nElan is already very well packaged in nixpkgs.</p>",
        "id": 516137238,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1746433740
    },
    {
        "content": "<p>We are indeed speaking of nixpkgs.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Check.20if.20Lean.20uses.20mimalloc/near/516077642\">said</a>:</p>\n<blockquote>\n<p>I would guess that either the end users are not also trying to use Mathlib, or if they are then they are not aware of how to report the issue.</p>\n</blockquote>\n<p>Unfortunately, mathlib is not packaged for Lean yet (although this is planned).  IIRC, Mathlib requires elan to be installed, even if Lean is otherwise installed, so there is no way around it so far.  However, the plan is, of course, to have mathlib packaged alongside Lean, to ensure no compatibility issues.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Check.20if.20Lean.20uses.20mimalloc/near/516127752\">said</a>:</p>\n<blockquote>\n<p>As an example of an issue that might occur, <code>elan</code> is used to make sure that the <code>lean-toolchain</code> file in a project is respected, which guarantees that everyone working on the same repository is using the same Lean version. Lean does not have strong backward compatibility guarantees right now, so not respecting <code>lean-toolchain</code> will mean that working on a sufficiently complicated library like Mathlib will almost never work with your installation method.</p>\n</blockquote>\n<p>Only the latest version of Lean is packaged in nixpkgs, so you cannot use it to pin a specific version you need.  However, the nix ecosystem does package every version of Lean (since 4.11), including a mechanism that detects the version from the <code>lean-toolchain</code> file to ensure compatibility.  It is the recommended way to use Lean with Nix in a project, and note that Nix is purposefully made to be capable of precisely pinning dependencies.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Check.20if.20Lean.20uses.20mimalloc/near/516136140\">said</a>:</p>\n<blockquote>\n<p>please make sure you call it <code>lean-broken</code> or <code>lean-do-not-use</code> etc</p>\n</blockquote>\n<p>Lol, no.  This is ridiculous. </p>\n<p>What we aim at is a situation similar to that of Rust, for which there are three installation methods available:</p>\n<ul>\n<li>the latest version of rust/cargo is directly available in nixpkgs;</li>\n<li>(patched) rustup is available in nixpkgs;</li>\n<li>a Rust overlay is available out-of-tree that packages every version of Rust, alongside tools that parse rust/cargo manifest files to make exactly the right tools/dependencies available without resorting to rustup/cargo.</li>\n</ul>\n<p>Additionally, a wiki page explains the tradeoff of each option.</p>\n<p>Currently, for Lean with Nix, the three installation methods are available, but the tools to parse the manifest files are not yet complete.  They understand lean-toolchain and lake-manifest.json, but not yet the lakefile (to extract the targets of a project).</p>\n<p>If you are worried about having too many issues related to a different installation method, which is a common source of tension between software developers/software packagers:</p>\n<ul>\n<li>include a message, that people have to read before posting an issue or creating a thread on Zulip, stating that the only official installation method is with elan, and that if issues occur the user should first try to see if they are solved by installing Lean through elan, and if so, that they should contact whomever provided the alternative installation method;</li>\n<li>add a flag at build time that states who is vendoring Lean, so that if Lean is installed via nix, say, <code>lean --version</code> states something like <code>Lean (version X.Y.Z, installed via Nix, ...)</code>, which makes it straightforward to isolate those cases.</li>\n</ul>\n<p>Finally, I must say that I find the responses to the work of packagers disrespectful.  We are all trying to make the world better for users, including those that prefer (to various degrees) installing software through their package manager rather than resorting to yet another ecosystem-specific package manager.  There is little point in blaming packagers because the packaging itself might create issues that would have otherwise not existed.  After all, all software is fallible, and elan itself certainly has issues that would have not been encountered by a user would they have used a packaged manager instead.  The point being that something can both create problems and yet be worth doing because it has more positive aspects than problems.</p>",
        "id": 516852184,
        "sender_full_name": "jthulhu",
        "timestamp": 1746697029
    },
    {
        "content": "<p>The usual issue is this - packagers make the decision to include a non-standard package of software someone else developed, without alerting users to the fact that it is a non-standard package, and then users come ask the original maintainers when they have issues</p>",
        "id": 516852615,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1746697180
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Check.20if.20Lean.20uses.20mimalloc/near/516852615\">said</a>:</p>\n<blockquote>\n<p>The usual issue is this - packagers make the decision to include a non-standard package of software someone else developed, without alerting users to the fact that it is a non-standard package, and then users come ask the original maintainers when they have issues</p>\n</blockquote>\n<p>I mean... this is precisely the role of packagers.  Nobody expects software developers to maintain packaging for every operating system in existence.  There is a triage issue, in that it's not always clear for users who is responsible for handling an installation issue, but the solution to that is having smarter error detection mechanisms, not hoping that every platform will uniformly accept to use the same tool to distribute their software.</p>",
        "id": 516853416,
        "sender_full_name": "jthulhu",
        "timestamp": 1746697436
    },
    {
        "content": "<p>An other solution would be to have the package maintainers of every distribution available on the forum where users usually report their issues.</p>",
        "id": 516853977,
        "sender_full_name": "jthulhu",
        "timestamp": 1746697597
    },
    {
        "content": "<p>Would it be possible to make elan configurable to access system installed (likely via a package manager) lean toolkits, and notify when the system doesn't have it? I think this is similar to how uv is configurable to use system pythons if the user doesn't want to use uv's python managing.</p>",
        "id": 516862456,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1746700494
    },
    {
        "content": "<p>Having read all this I agree that there could and probably should be better solutions to just discouraging people from packaging. But in my experience (downloading lean projects which my students have written all of which use different versions of lean and mathlib) a packaged version of lean needs to be able to switch between versions of lean at will, for me this feels like a deal breaker. How can a packaged version of lean do this?</p>",
        "id": 516886967,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746708311
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Check.20if.20Lean.20uses.20mimalloc/near/516886967\">发言道</a>：</p>\n<blockquote>\n<p>Having read all this I agree that there could and probably should be better solutions to just discouraging people from packaging. But in my experience (downloading lean projects which my students have written all of which use different versions of lean and mathlib) a packaged version of lean needs to be able to switch between versions of lean at will, for me this feels like a deal breaker. How can a packaged version of lean do this?</p>\n</blockquote>\n<p>I'm not trying to recommend anything to anyone, nor am I trying to promote anything. The reason I’m sharing this is that my team frequently needs to modify the source code of the Lean compiler and toolchain, and we run experiments or programs using these modified versions. Our solution is to package everything using Nix and use a Nix develop shell to specify the Lean version for the workspace. This way, after each modification to the Lean compiler, we only need to update the corresponding commit SHA in the Nix develop shell definition file. With this setup, we get precise version control, out-of-the-box caching (since compiling the Lean compiler and toolchain takes quite a bit of time), and a CI environment that matches the local setup—all with minimal extra effort.</p>\n<p>If anyone has ever truly benefited from using the Lean version packaged by a distro, I think I might be one of them. But generally speaking, whether it's Haskell, Rust, Java, Erlang, or Lean, using the version provided by a Linux distribution is not recommended. Personally, I think probably only C compiler users tend to prefer the distro-provided compiler.</p>",
        "id": 516927727,
        "sender_full_name": "Alissa Tung",
        "timestamp": 1746719129
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Check.20if.20Lean.20uses.20mimalloc/near/516886967\">said</a>:</p>\n<blockquote>\n<p>Having read all this I agree that there could and probably should be better solutions to just discouraging people from packaging. But in my experience (downloading lean projects which my students have written all of which use different versions of lean and mathlib) a packaged version of lean needs to be able to switch between versions of lean at will, for me this feels like a deal breaker. How can a packaged version of lean do this?</p>\n</blockquote>\n<p>The Nix world has techniques like <a href=\"https://github.com/oxalica/rust-overlay\">https://github.com/oxalica/rust-overlay</a> which analyze all released versions and select the right Rust version at evaluation time of the recipes. There's nothing preventing the very similar thing to exist for Lean (and there were various variants of this idea floating across the past years, none caught up particularly AFAIK because the appetite for Lean vs. Rust is slightly different.)</p>\n<p>So, yes, you can have switching to a specific revision of Lean, no problem, while honoring the \"I need this to live in Nix\" world. Put in another way, to switch to any version of Lean, it suffices to automate the packaging of all Lean versions.</p>",
        "id": 516936406,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1746721648
    },
    {
        "content": "<p>And in my application when I need to switch to any version of mathlib too, you have to package all tens of thousands of mathlib versions too?</p>",
        "id": 516942692,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746723747
    },
    {
        "content": "<p>Just to give a concrete example: I met a PhD student today, and they told me they'd proved a theorem and pointed me to a repo on github. I cloned it, used elan to download the appropriate version of Lean, used the appropriate version of lake to download the appropriate version of mathlib, and then everything worked fine and I could inspect the student's proof. Can this workflow work in Nix?</p>",
        "id": 516943019,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746723856
    },
    {
        "content": "<p>One problem with packaging individual versions of Lean is that the Lean community frequently uses release candidate versions. For example, Mathlib is now on Lean v4.20.0-rc5. I think if this approach were to work, you would have to build every single version of Lean, include the release candidate versions.</p>\n<p>Also, I don't know why you would need to package mathlib with the lean version. Shouldn't the version of <code>lake</code> that ships with <code>lean</code> handle that?</p>",
        "id": 516946963,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746725293
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"638718\">Alissa Tung</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Check.20if.20Lean.20uses.20mimalloc/near/516927727\">said</a>:</p>\n<blockquote>\n<p>I'm not trying to recommend anything to anyone, nor am I trying to promote anything. The reason I’m sharing this is that my team frequently needs to modify the source code of the Lean compiler and toolchain, and we run experiments or programs using these modified versions. Our solution is to package everything using Nix and use a Nix develop shell to specify the Lean version for the workspace. This way, after each modification to the Lean compiler, we only need to update the corresponding commit SHA in the Nix develop shell definition file. With this setup, we get precise version control, out-of-the-box caching (since compiling the Lean compiler and toolchain takes quite a bit of time), and a CI environment that matches the local setup—all with minimal extra effort.</p>\n</blockquote>\n<p>I don't think anyone's saying that users shouldn't be allowed to use nix if they want to. If will definitely be beneficial to some people. It's not like the Lean maintainers are against Nix either; they have a development-only nix flake in the official lean4 repo and an official elan package for Nix. If users decide they understand the tradeoffs involved and decide that jthulhu's Lean package is the best for them, that's their decision to make. The worry is that many users won't understand the tradeoffs involved.</p>",
        "id": 516948085,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746725720
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Check.20if.20Lean.20uses.20mimalloc/near/516943019\">发言道</a>：</p>\n<blockquote>\n<p>Just to give a concrete example: I met a PhD student today, and they told me they'd proved a theorem and pointed me to a repo on github. I cloned it, used elan to download the appropriate version of Lean, used the appropriate version of lake to download the appropriate version of mathlib, and then everything worked fine and I could inspect the student's proof. Can this workflow work in Nix?</p>\n</blockquote>\n<p>I think yes, and if a coworker switches to Nix for project management, one can drop Elan altogether. The command <code>nix develop --command code .</code> will prepare everything about working with a proof repo well.</p>\n<p>Here is some explantation on this: (while my English writing is not good <span aria-label=\"crying cat\" class=\"emoji emoji-1f63f\" role=\"img\" title=\"crying cat\">:crying_cat:</span> )</p>\n<p>In a Nix-managed Lean 4 project, one include a single <code>.nix</code> file that pins each dependency: the Lean 4 git rev, the Mathlib4 git rev, and any other Lean-based libraries. When one runs <code>nix develop</code>, Nix automatically builds an isolated development environment where VS Code sees exactly the right compiler and library versions. No manual installs or version change is needed.</p>\n<p>I think people worry that pinning many different Lean or Mathlib versions leads to packaging the same code over and over. In reality, one simply change the git rev strings in the definition file, library provides functions handle the rest. It’s no more work than GitHub automatically publishing each Lean nightly release, which is all scripted and repeatable.</p>\n<p>The Nix functions about Lake-based packages isn’t 100 % finished yet. As now, Nix’s automated caches cover different Lean compiler versions; they haven’t fully integrated Lake package fetching. But one can still use one command to config the environment well, <code>nix develop</code>, no other installation and config is needed. Just the admin of that repo needs to specify which versions to use, and end user of that repo does not need to learn or adjust things.</p>\n<p>Since Nix treats each package definition as a pure function of its inputs (the git revs), the resulting build outputs are bit-identical across machines. So every packages and tools have the chance to get cache service without writing code and infra. For now we only have this for Mathlib, Lean compiler, ProofWidgets, and the cloud infra or fetch scripts is not unified yet.</p>",
        "id": 516974958,
        "sender_full_name": "Alissa Tung",
        "timestamp": 1746735924
    },
    {
        "content": "<p>A concrete example is that for each commit of Lean 4, Mathlib 4, FLT, ProofWidgets 4 and other Lake package repo, the CI would fire for each commit, which already done <code>lake build</code>.</p>\n<p>If we have Nix functions for fetching Lake packages, after <code>lake build</code> CI can upload to a global Nix store (for example, garnix or cachix).  So every commit of every package would have cache, once on CI is done.</p>\n<p>As for now, many packages from other language (Haskell, Rust, Python, JavaScript) have many cache, on different version, on different machine arch too. Most of them are hosted by Nix official cache and Garnix.</p>",
        "id": 516976106,
        "sender_full_name": "Alissa Tung",
        "timestamp": 1746736406
    },
    {
        "content": "<p>So with this system nix has to pay to store gigabytes of mathlib cache which are already being stored elsewhere?</p>",
        "id": 516977119,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746736842
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Check.20if.20Lean.20uses.20mimalloc/near/516977119\">发言道</a>：</p>\n<blockquote>\n<p>So with this system nix has to pay to store gigabytes of mathlib cache which are already being stored elsewhere?</p>\n</blockquote>\n<p>With system Nix, for the same Lean compiler version and Mathlib version, the Mathlib cache on one's computer disk will only save once, shared between multiple projects.</p>",
        "id": 516978354,
        "sender_full_name": "Alissa Tung",
        "timestamp": 1746737452
    },
    {
        "content": "<p>I could potentially see how nix could replace elan but I don't understand how it could replace lake. Is the idea that lake somehow hooks into nix?</p>",
        "id": 517007274,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746753920
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Check.20if.20Lean.20uses.20mimalloc/near/516977119\">said</a>:</p>\n<blockquote>\n<p>So with this system nix has to pay to store gigabytes of mathlib cache which are already being stored elsewhere?</p>\n</blockquote>\n<p>mathlib is not built in <a href=\"https://cache.nixos.org\">https://cache.nixos.org</a> for the time being, but do know that it already stores 800TB of almost all software universe for the past 2 decades almost ;-). There's also room for improvements.</p>\n<p>But on the system, the cache (the store) is a fixed output content, i.e. addressed by its hash, so it's only stored once over all Lean projects. (it could even be further compressed by doing content defined chunking but that's for tomorrow!)</p>",
        "id": 517057150,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1746779387
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Check.20if.20Lean.20uses.20mimalloc/near/517007274\">said</a>:</p>\n<blockquote>\n<p>I could potentially see how nix could replace elan but I don't understand how it could replace lake. Is the idea that lake somehow hooks into nix?</p>\n</blockquote>\n<p>This is the same question as whether Nix replaces Make, Ninja, CMake, Meson, etc. Nix only drives them for now, there's people looking into how to make Nix replaces those or drive them with a better granularity (it's interesting for various reasons because Nix gives free lunch on certain features, e.g. caching, distribution, etc.). In the past, Lean 4 had a Nix native setup where it effectively required no Lake, this setup was deprecated because used by an invisible and probably small audience.</p>",
        "id": 517057580,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1746779510
    }
]