[
    {
        "content": "<p>I'm encountering some problems where <code>simp</code> is definitionally rewriting data inside a dependent type in a way that breaks confluence when combined with <code>FunLike</code>. </p>\n<p>It is fixed by changing a <code>rfl</code> proof to <code>by exact rfl</code>. As well as seeming hacky, this is not a feasible fix for my use case, because the relevant <code>rfl</code> proof is already in mathlib.</p>\n<p>It is also fixed by not using <code>FunLike</code> and just going with <code>toFun</code> explicitly, which is undesirable.  </p>\n<p>Does anyone know another way to stop <code>simp</code> from screwing around inside the <code>DFunLike.coe</code> term? </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"sd\">/-- A wrapper for a set -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span>\n\n<span class=\"sd\">/-- The union of two wrapped sets -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"bp\">.</span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">âˆª</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">âŸ©</span>\n\n<span class=\"sd\">/-- A reasonable simp lemma with `rfl` as the proof. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"bp\">.</span><span class=\"n\">union_val</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">âˆª</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- A sequence of subsets of a set `s` -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span>\n<span class=\"w\">  </span><span class=\"n\">subset</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">âŠ†</span><span class=\"w\"> </span><span class=\"n\">s</span>\n\n<span class=\"sd\">/-- `SubsetSeq` is `FunLike` -/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"bp\">.</span><span class=\"n\">toFun</span>\n<span class=\"w\">  </span><span class=\"n\">coe_injective'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"bp\">âŸ©</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">f'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"bp\">âŸ©;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n\n<span class=\"sd\">/-- If `f` is a subset sequence arising from a `SetWrap`, then its terms are empty. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- an easy lemma that follows directly from `foo` and should be proved by `simp`. -/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span><span class=\"cm\"> The following `simp` succeeds with no visible change;</span>\n<span class=\"cm\">  it uses `SetWrap.union_val` to change the term `f i` from</span>\n<span class=\"cm\">  `@DFunLike.coe (SubsetSeq ((a.union b).val)) â„• (fun x â†¦ Set â„•) instFunLikeSubsetSeqNatSet f i`</span>\n<span class=\"cm\">  to</span>\n<span class=\"cm\">  `@DFunLike.coe (SubsetSeq (a.val âˆª b.val)) â„• (fun x â†¦ Set â„•) instFunLikeSubsetSeqNatSet f i`.</span>\n<span class=\"cm\">  This is not visible in the infoview without mouseover. -/</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c1\">-- succeeds with no visible change</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Now the next `simp` fails to resolve the goal using `foo`,</span>\n<span class=\"w\">  </span><span class=\"c1\">-- because `f` does not match its argument.</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\">  </span><span class=\"c1\">-- fails</span>\n</code></pre></div>\n<p>If the proof of <code>SetWrap.union_val</code> is changed from <code>rfl</code> to <code>by exact rfl</code>, then <code>simp</code> will resolve the above example using <code>foo</code>, because <code>simp</code> doesn't change the type of <code>f</code>.</p>",
        "id": 563949891,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765846840
    },
    {
        "content": "<p>so is the problem that <code>foo</code> isn't in simp-nf</p>",
        "id": 563951576,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765848338
    },
    {
        "content": "<p>In what way could <code>foo</code> by itself be more normalized? Using <code>simp</code> as the first line of the proof of <code>foo</code> fails.</p>",
        "id": 563951663,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765848424
    },
    {
        "content": "<p>(Of course <code>foo</code> is equivalent to a more normalized lemma with <code>SubsetSeq s</code> for arbitrary <code>s</code>, but that is an artefact of the MWE)</p>",
        "id": 563951803,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765848567
    },
    {
        "content": "<p>oh no nvm</p>",
        "id": 563951904,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765848663
    },
    {
        "content": "<p>it's definitely in simpNF</p>",
        "id": 563951934,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765848685
    },
    {
        "content": "<p>I think I need more context</p>",
        "id": 563951969,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765848723
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 563952510,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765849216
    },
    {
        "content": "<p>The context is partitions of the ground sets of matroids. <br>\nFirst, independently of anything matroidy, for each <code>s : Set a</code>, I have a function-like type <code>s.Bipartition</code> that coerces to a function from <code>Bool</code> to <code>Set a</code>. (It encodes a partition of <code>s</code> into two parts.)</p>\n<p>Then I have a structure <code>Matroid a</code>, which has a structure field <code>E : Set a</code>; this it the 'ground set' of a matroid. </p>\n<p>One operation on matroids is the following : <code>Matroid.delete (M : Matroid a) (D : Set a) : Matroid a</code>. This satisfies <code>(M.delete D).E = M.E \\ D</code>; this is a simp lemma whose proof is <code>rfl</code>. </p>\n<p>Then I have a bunch of @[simp] lemmas <code>foo1, foo2, ...</code> about matroidal properties of bipartitions of the ground set of a matroid. They each take <code>(P : M.E.Bipartition)</code> as an argument. </p>\n<p>The problem now is that if I have <code>P : (M.delete D).E.Bipartition</code>, then these simp lemmas will never work, because <code>simp</code> will first change <code>(M.delete D).E</code> to <code>(M.E \\ D)</code> inside the <code>FunLike</code> coercion term.</p>",
        "id": 563953006,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765849684
    },
    {
        "content": "<p>uhhhhh</p>",
        "id": 563953166,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765849910
    },
    {
        "content": "<p>maybe make it not a dsimp lemma</p>",
        "id": 563953191,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765849936
    },
    {
        "content": "<p>or maybe noindex that part</p>",
        "id": 563953198,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765849946
    },
    {
        "content": "<p>It should really be a dsimp lemma in almost every other context, though. How does <code>noindex</code> work?</p>",
        "id": 563953261,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765850015
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span> See <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20What.20does.20.60no_index.60.20mean.3F/near/473204047\">#new members &gt; âœ” What does &#96;no_index&#96; mean? @ ðŸ’¬</a> for some explanation about <code>no_index</code>.</p>",
        "id": 563978777,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1765870465
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/270676-lean4/topic/Annoying.20simp.20.2B.20FunLike.20interaction/near/563953006\">said</a>:</p>\n<blockquote>\n<p>The context is partitions of the ground sets of matroids. <br>\nFirst, independently of anything matroidy, for each <code>s : Set a</code>, I have a function-like type <code>s.Bipartition</code> that coerces to a function from <code>Bool</code> to <code>Set a</code>. (It encodes a partition of <code>s</code> into two parts.)</p>\n<p>Then I have a structure <code>Matroid a</code>, which has a structure field <code>E : Set a</code>; this it the 'ground set' of a matroid. </p>\n<p>One operation on matroids is the following : <code>Matroid.delete (M : Matroid a) (D : Set a) : Matroid a</code>. This satisfies <code>(M.delete D).E = M.E \\ D</code>; this is a simp lemma whose proof is <code>rfl</code>. </p>\n<p>Then I have a bunch of @[simp] lemmas <code>foo1, foo2, ...</code> about matroidal properties of bipartitions of the ground set of a matroid. They each take <code>(P : M.E.Bipartition)</code> as an argument. </p>\n<p>The problem now is that if I have <code>P : (M.delete D).E.Bipartition</code>, then these simp lemmas will never work, because <code>simp</code> will first change <code>(M.delete D).E</code> to <code>(M.E \\ D)</code> inside the <code>FunLike</code> coercion term.</p>\n</blockquote>\n<p>Does it matter that <code>Set.Bipartition</code> is FunLike? Wouldn't the same problem still occur even if it was just structure?</p>",
        "id": 563990125,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765875156
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/270676-lean4/topic/Annoying.20simp.20.2B.20FunLike.20interaction/near/563990125\">said</a>:</p>\n<blockquote>\n<p>Does it matter that <code>Set.Bipartition</code> is FunLike? Wouldn't the same problem still occur even if it was just structure?</p>\n</blockquote>\n<p>If I understand you correctly, then no. The following works after the code above : </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 563993384,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765876185
    },
    {
        "content": "<p>Ah, I see. It's because simp is changing the type of <code>f</code> inside the term. Hmm, it's kinda defeq abuse. Maybe it's bug that <code>simp</code> does it in the first place?</p>",
        "id": 563993887,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765876348
    },
    {
        "content": "<p>Yes, the fact that <code>FunLike</code> and <code>by exact rfl</code> vs <code>rfl</code> change things suggests that some part of this behaviour is actually undesirable.</p>",
        "id": 563994111,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765876413
    },
    {
        "content": "<p>The suggested <code>no_index</code> approach fixes the issue.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">no_index</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Though, it has a drawback of slowing down <code>simp</code>.</p>",
        "id": 563996526,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765877151
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/270676-lean4/topic/Annoying.20simp.20.2B.20FunLike.20interaction/near/563993887\">said</a>:</p>\n<blockquote>\n<p>Ah, I see. It's because simp is changing the type of <code>f</code> inside the term.</p>\n</blockquote>\n<p>I don't think that's possible</p>",
        "id": 564016040,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765883436
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/270676-lean4/topic/Annoying.20simp.20.2B.20FunLike.20interaction/near/563996526\">said</a>:</p>\n<blockquote>\n<p>The suggested <code>no_index</code> approach fixes the issue.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">no_index</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Though, it has a drawback of slowing down <code>simp</code>.</p>\n</blockquote>\n<p>I meant you should <code>no_index</code> the parts in the expression that are being changed hopefully retaining enough information to not slow down <code>simp</code> too much</p>",
        "id": 564016235,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765883492
    },
    {
        "content": "<p>Is this actually a bug?</p>",
        "id": 564105267,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765908643
    },
    {
        "content": "<p>I think it is just sub-optimal design. </p>\n<p>Does anyone want to argue against </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">reducible</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">DFunLike</span><span class=\"bp\">.</span><span class=\"n\">coe</span>\n</code></pre></div>",
        "id": 564109693,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1765910267
    },
    {
        "content": "<p>Design on my part, or of the interactions Iâ€™m fighting with? I donâ€™t understand why FunLike should behave differently to a plain function.</p>",
        "id": 564110174,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765910422
    },
    {
        "content": "<p>I think the totality of the design. Because <code>DFunLike.coe</code> is a projection to a field from a class it just doesn't \"fade away\" with <code>simp</code>. I could imagine that <code>dsimp</code> reduces it to the application of the underlying function it in this situation whether that is via some global setting or some particular local simp lemma.</p>",
        "id": 564112164,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1765911171
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/270676-lean4/topic/Annoying.20simp.20.2B.20FunLike.20interaction/near/564016040\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/270676-lean4/topic/Annoying.20simp.20.2B.20FunLike.20interaction/near/563993887\">said</a>:</p>\n<blockquote>\n<p>Ah, I see. It's because simp is changing the type of <code>f</code> inside the term.</p>\n</blockquote>\n<p>I don't think that's possible</p>\n</blockquote>\n<p>I think it does, but using defeq of types.</p>",
        "id": 564129597,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765917875
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/270676-lean4/topic/Annoying.20simp.20.2B.20FunLike.20interaction/near/564016235\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/270676-lean4/topic/Annoying.20simp.20.2B.20FunLike.20interaction/near/563996526\">said</a>:</p>\n<blockquote>\n<p>The suggested <code>no_index</code> approach fixes the issue.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">no_index</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Though, it has a drawback of slowing down <code>simp</code>.</p>\n</blockquote>\n<p>I meant you should <code>no_index</code> the parts in the expression that are being changed hopefully retaining enough information to not slow down <code>simp</code> too much</p>\n</blockquote>\n<p>That's what I tried to do, what else could you do here? <code>SetWrap.val (no_index a)</code> won't work.</p>",
        "id": 564129907,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765918016
    },
    {
        "content": "<p>And I has potential of slowing down simp quite a lot, because now it will try this lemma for every SubsetSeq, not just the ones using SetWrap. <del>(It still needs some SetWrap in the context though).</del></p>",
        "id": 564130811,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765918388
    },
    {
        "content": "<p>I mean like doing <code>@DFunLike.coe (SubsetSeq (no_index _)) (Nat â†’ Set) _ f i</code></p>",
        "id": 564131010,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765918474
    },
    {
        "content": "<p>I've tried, but this doesn't work.</p>",
        "id": 564131144,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765918537
    },
    {
        "content": "<p>oh no</p>",
        "id": 564131213,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765918565
    },
    {
        "content": "<p><code>simp</code> doesn't try <code>foo</code>, because the type of <code>f</code> doesn't match.</p>",
        "id": 564131308,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765918607
    },
    {
        "content": "<p>And I don't think <code>no_index</code> in <code>DFunLike</code> instance, can stop <code>simp</code> from modifying the type.</p>",
        "id": 564131457,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765918664
    },
    {
        "content": "<p>I still don't exactly understand why <code>simp</code> doesn't try <code>foo</code> without <code>no_index</code>. The type of <code>f</code> in the context didn't change. It only changed the type inside the goal term.</p>",
        "id": 564131687,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765918765
    },
    {
        "content": "<p>I think <code>simp</code> shouldn't do this. If I wanted to change the type of <code>f</code>, I would do <code>dsimp at f</code>.</p>",
        "id": 564132098,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765918941
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/270676-lean4/topic/Annoying.20simp.20.2B.20FunLike.20interaction/near/564130811\">said</a>:</p>\n<blockquote>\n<p>And I has potential of slowing down simp quite a lot, because now it will try this lemma for every SubsetSeq, not just the ones using SetWrap. <del>(It still needs some SetWrap in the context though).</del></p>\n</blockquote>\n<p>Oh, wow, it's even worse. It will not only try, but can even succeed in using this lemma for a different type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"sd\">/-- A wrapper for a set -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span>\n\n<span class=\"sd\">/-- A sequence of subsets of a set `s` -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span>\n<span class=\"w\">  </span><span class=\"n\">subset</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">âŠ†</span><span class=\"w\"> </span><span class=\"n\">s</span>\n\n<span class=\"sd\">/-- `SubsetSeq` is `FunLike` -/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"bp\">.</span><span class=\"n\">toFun</span>\n<span class=\"w\">  </span><span class=\"n\">coe_injective'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"bp\">âŸ©</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">f'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"bp\">âŸ©;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n\n<span class=\"sd\">/-- If `f` is a subset sequence arising from a `SetWrap`, then its terms are empty. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"n\">no_index</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">discr_tree_simp_key</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">simp</span><span class=\"bp\">.</span><span class=\"n\">rewrite</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">âˆª</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- succeeds</span>\n</code></pre></div>",
        "id": 564140287,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765922454
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span> This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"sd\">/-- A wrapper for a set -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span>\n\n<span class=\"sd\">/-- The union of two wrapped sets -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"bp\">.</span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">âˆª</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">âŸ©</span>\n\n<span class=\"sd\">/-- A reasonable simp lemma with `rfl` as the proof. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"bp\">.</span><span class=\"n\">union_val</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">âˆª</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- A sequence of subsets of a set `s` -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span>\n<span class=\"w\">  </span><span class=\"n\">subset</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">âŠ†</span><span class=\"w\"> </span><span class=\"n\">s</span>\n\n<span class=\"sd\">/-- `SubsetSeq` is `FunLike` -/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"bp\">.</span><span class=\"n\">toFun</span>\n<span class=\"w\">  </span><span class=\"n\">coe_injective'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"bp\">âŸ©</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">f'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"bp\">âŸ©;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n\n<span class=\"sd\">/-- If `f` is a subset sequence arising from a `SetWrap`, then its terms are empty. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"bp\">â†“</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- an easy lemma that follows directly from `foo` and should be proved by `simp`. -/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c1\">-- succeeds</span>\n</code></pre></div>",
        "id": 564147424,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765926346
    },
    {
        "content": "<p>Although, using <code>@[simpâ†“]</code> might cause failure in some other cases that one would expect to work. Maybe you could try <code>@[simpâ†“, simp]</code>?</p>",
        "id": 564147739,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765926540
    },
    {
        "content": "<p>But it's a bit wacky solution. Ideally, we would want to apply simp to some argument subexpressions, but not all of them.</p>",
        "id": 564147905,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765926661
    },
    {
        "content": "<p>You could also try <code>simp -dsimp</code>?</p>",
        "id": 564148685,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1765927200
    },
    {
        "content": "<p>Isn't that a bug?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"sd\">/-- A wrapper for a set -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span>\n\n<span class=\"sd\">/-- A sequence of subsets of a set `s` -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span>\n<span class=\"w\">  </span><span class=\"n\">subset</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">âŠ†</span><span class=\"w\"> </span><span class=\"n\">s</span>\n\n<span class=\"sd\">/-- `SubsetSeq` is `FunLike` -/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"bp\">.</span><span class=\"n\">toFun</span>\n<span class=\"w\">  </span><span class=\"n\">coe_injective'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"bp\">âŸ©</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">f'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"bp\">âŸ©;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n\n<span class=\"sd\">/-- If `f` is a subset sequence arising from a `SetWrap`, then its terms are empty. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"n\">no_index</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">âˆª</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c1\">-- succeeds</span>\n</code></pre></div>\n<p>I've made an <code>axiom</code> for <code>SetWrap</code>. Yet, simp happily used it to prove <code>example</code> where there's no SetWrap.</p>",
        "id": 564150050,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765928064
    },
    {
        "content": "<p>Ah, okay, somehow <code>simp</code> automatically used the one-argument constructor for SetWrap I think? This doesn't work, so I don't think there's soundness issue:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"sd\">/-- A wrapper for a set -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span>\n<span class=\"w\">  </span><span class=\"n\">impossible</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span>\n\n<span class=\"sd\">/-- A sequence of subsets of a set `s` -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span>\n<span class=\"w\">  </span><span class=\"n\">subset</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">âŠ†</span><span class=\"w\"> </span><span class=\"n\">s</span>\n\n<span class=\"sd\">/-- `SubsetSeq` is `FunLike` -/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"bp\">.</span><span class=\"n\">toFun</span>\n<span class=\"w\">  </span><span class=\"n\">coe_injective'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"bp\">âŸ©</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">f'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"bp\">âŸ©;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n\n<span class=\"sd\">/-- If `f` is a subset sequence arising from a `SetWrap`, then its terms are empty. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetWrap</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"n\">no_index</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SubsetSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">âˆª</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 564150336,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765928226
    },
    {
        "content": "<p>still, <code>simp</code> is being quite a loose cannon...</p>",
        "id": 564222191,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765968870
    }
]