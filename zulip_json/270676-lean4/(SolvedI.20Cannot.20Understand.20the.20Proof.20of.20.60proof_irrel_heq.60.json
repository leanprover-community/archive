[
    {
        "content": "<p>This is the prefix tree of the proof of proof_irrel_heq in Lean 4:<br>\ntheorem proof_irrel_heq : (a : Prop) -&gt; (b : Prop) -&gt; (c : a) -&gt; (d : b) -&gt; HEq a c b d<br>\n  (a : Prop) =&gt; (b : Prop) =&gt; (c : a) =&gt; (d : b) =&gt;<br>\n    Eq.casesOn Prop a<br>\n      ((e : Prop) =&gt; <br>\n        (f : Eq Prop a e) =&gt; <br>\n          (Eq Prop b e -&gt; HEq (Eq Prop a b) (propext a b (iff_of_true a b c d)) (Eq Prop a e) f -&gt; HEq a c b d))<br>\n      b<br>\n      (propext a b (iff_of_true a b c d))<br>\n      ((g : Eq Prop b a) =&gt; <br>\n        Eq.ndrec Prop a <br>\n          ((h : Prop) =&gt; <br>\n            ((i : h) -&gt; (j : Eq Prop a h) -&gt; HEq (Eq Prop a h) j (Eq Prop a a) (Eq.refl Prop a) -&gt; HEq a c h i))<br>\n          (a =&gt; (k : Eq Prop a a) =&gt; HEq (Eq Prop a a) k (Eq Prop a a) (Eq.refl Prop a) =&gt; HEq.rfl a c)<br>\n          b<br>\n          (Eq.symm Prop b a g)<br>\n          d<br>\n          (propext a b (iff_of_true a b c d)))<br>\n      (Eq.refl Prop b)<br>\n      (HEq.refl (Eq Prop a b) (propext a b (iff_of_true a b c d)))</p>\n<p>The proof is quite complex, and I am struggling to understand the application after Eq.ndrec.<br>\nHere’s the issue I encountered:<br>\nThe function expects an argument of type:<br>\n  (i : h) -&gt; (j : Eq Prop a h) -&gt; HEq (Eq Prop a h) j (Eq Prop a a) (Eq.refl Prop a) -&gt; HEq a c h i<br>\nIf we replace h with a, the expected type simplifies to:<br>\n  (i : a) -&gt; (j : Eq Prop a a) -&gt; HEq (Eq Prop a a) j (Eq Prop a a) (Eq.refl Prop a) -&gt; HEq a c a i<br>\nHowever, the provided argument is:<br>\n  (a =&gt; (k : Eq Prop a a) =&gt; HEq (Eq Prop a a) k (Eq Prop a a) (Eq.refl Prop a) =&gt; HEq.rfl a c)<br>\nIts type appears to be:<br>\n  (a -&gt; (k : Eq Prop a a) -&gt; HEq (Eq Prop a a) k (Eq Prop a a) (Eq.refl Prop a) -&gt; HEq a c h c)<br>\nThis doesn’t match, because HEq a c a i is not equivalent to HEq a c h c.</p>\n<p>Why is this application considered valid?<br>\nAny clarification would be greatly appreciated. Thank you!</p>",
        "id": 492853356,
        "sender_full_name": "Lingwei Peng (彭灵伟)",
        "timestamp": 1736472005
    },
    {
        "content": "<p>here's a version of <code>proof_irrel_heq</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">proof_irrel_heq'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HEq</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">propext</span><span class=\"w\"> </span><span class=\"o\">⟨(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)⟩</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">HEq.refl</span><span class=\"w\"> </span><span class=\"n\">_</span>\n</code></pre></div>\n<p>First, show that <code>P=Q</code>, which is possible since we have instances of both <code>P</code> and <code>Q</code>.  Then use definitional proof irrelevance to show that <code>p=q</code> (since now both <code>p</code> and <code>q</code> have the same type). </p>\n<p>Here's the actual proof in <code>Init</code> which is very similar <a href=\"https://github.com/leanprover/lean4/blob/d3699764749a456beecc250ddf17df57ebace155/src/Init/PropLemmas.lean#L26-L27\">https://github.com/leanprover/lean4/blob/d3699764749a456beecc250ddf17df57ebace155/src/Init/PropLemmas.lean#L26-L27</a> </p>\n<p>I have found that the printed output of a proof isn't very enlightening on how the proof actually works. It's usually better to just look at the proof directly, which is almost always significantly simpler.</p>",
        "id": 492857637,
        "sender_full_name": "RustyYato",
        "timestamp": 1736474148
    },
    {
        "content": "<p>Thanks.</p>\n<p>I am trying to understand what the kernel does, so I expanded the proof into its prefix format. After consulting ChatGPT, I learned that the logic of <strong>Proof Irrelevance</strong> is implemented directly in the kernel. This is why <code>HEq a c a i</code> and <code>HEq a c h c</code> are considered the same in the kernel.</p>\n<p>Here is a similar example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">proof_irrel</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>The actual type of <code>(a:Prop) =&gt; (x:a) =&gt; (y:a) =&gt; Eq.refl a x</code> is <code>(a:Prop) =&gt; (x:a) =&gt; (y:a) =&gt; Eq a x x</code>, not <code>(a:Prop) -&gt; (x:a) -&gt; (y:a) -&gt; Eq a x y</code>. However, the kernel treats them as equivalent implicitly.</p>\n<p>Personally, I would prefer to explicitly define the axiom instead of relying on the theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">proof_irrel</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>\n<p>I think explicitness is better than implicitness.</p>",
        "id": 492876091,
        "sender_full_name": "Lingwei Peng (彭灵伟)",
        "timestamp": 1736484368
    },
    {
        "content": "<p>That <code>proof_irrel</code> would be a propositional proof irrelevance, but the axiom is supposed to be that proofs of the same proposition are definitionally equal, which is more primitive and can't be represented as an <code>axiom</code>.</p>",
        "id": 492989750,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1736528437
    }
]