[
    {
        "content": "<p>There's been very consistent work on <code>BitVec</code> in Lean. This is fantastic but I'm afraid I haven't been able to keep up!</p>\n<p>I'm needing to work with <code>BitVec</code> as coefficients of polynomials over the two element field. Is there  existing/planned work in that direction? It is not hard to give a reference implementation for the few things I need, but I don't want to reinvent the wheel. It's tough to go straight with two wheels of different size!</p>",
        "id": 476951113,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1728986301
    },
    {
        "content": "<p>I don't think there's any work in progress with the interpretation as coefficients of polynomials. What exactly are you doing?</p>",
        "id": 476960526,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1728989532
    },
    {
        "content": "<p>For the Mersenne Twister (<a href=\"https://github.com/leanprover-community/batteries/pull/984\">batteries#984</a>) the trick to jump ahead 2^128 steps is to calculate the minimal polynomial p(x) of the twist transform, calculate x^(2^128) mod p(x) using quick exponentiation, and then evaluate the resulting polynomial using Horner's method, substituting the twist transformation for x. </p>\n<p>PS: The polynomial p(x) has degree 19968 for the most common practical use case. So this is not something where it's easier to do with ad hoc code.</p>",
        "id": 476963511,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1728990630
    },
    {
        "content": "<p>Are you sure that you want to implement your Mersenne twister on top of BitVec instead of UIntX btw? If you are doing all of these bitwise ops on BitVec's that always carries a performance penalty while it doesn't for UInt.</p>",
        "id": 476964445,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1728990940
    },
    {
        "content": "<p>This is a reference implementation that allows for all possible variations of parameters. The MT19937 and MT19937-64 special cases are part of the C++11 standard, so I think we just need to link those in for efficiency.</p>\n<p>The reason for the reference implementation is that it is not opaque and we can verify its statistical properties, eventually...</p>",
        "id": 476966455,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1728991622
    },
    {
        "content": "<p>PS:The Philox PRNG is coming up soon. Maybe some more after that...</p>",
        "id": 476966825,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1728991757
    },
    {
        "content": "<p>PS2: I already had UIntX versions, this is the BitVec upgrade!!!</p>",
        "id": 476967045,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1728991833
    }
]