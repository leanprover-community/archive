[
    {
        "content": "<p>Hello. I'm a newbie in Lean, and was trying to prove this equality:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">inits</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">scanl</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">e</span>\n</code></pre></div>\n<p>Where the functions are:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">scanl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">scanl</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">inits</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[[]]</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inits</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I'm using Lean 4 in VS Code, and have no idea on how to import libraries. Also, I've already tried to do induction and to expand the definitions, but always ended up on a dead end. Can you give some ideas in how to prove this example?</p>",
        "id": 468645817,
        "sender_full_name": "Sílvio Zacomelli",
        "timestamp": 1725842216
    },
    {
        "content": "<p>You don't need any libraries to do this, you can prove this with your bare hands. :-)</p>",
        "id": 468646898,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1725843060
    },
    {
        "content": "<p>Have you done previous exercises using <code>induction ... generalizing ... with</code>, or the <code>generalize</code> tactic? Both are useful here.</p>",
        "id": 468646945,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1725843091
    },
    {
        "content": "<p>(If you can say a bit more about the context of where this came from, I'm happy to post a spoiler, but it has the look of a homework exercise without further context. :-)</p>",
        "id": 468647049,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1725843157
    },
    {
        "content": "<p>(Faced with something like this, I would immediately write the eight lemmas <code>map_nil</code>, <code>map_cons</code>, etc. Copilot or Cursor Tab's AI models can probably just autocomplete these. Having these lemmas lets you do exactly the rewriting you want to do.)</p>",
        "id": 468647102,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1725843218
    },
    {
        "content": "<p>Yes, it's indeed from an assignment of my college, and it's the first the teacher gave us to do. I haven't done any type of exercises before, and all the tactics I know are the ones I learned by myself while trying to prove this kind of things. Don't know how to use induction with generalizing, or even what generalizes means. I also don't know about those eight lemmas. I tried to do some research on my own, but all the textbooks and tutorials are very heavy to read and, in many of them, there isn't something useful. Any help here is appreciated.</p>",
        "id": 468648446,
        "sender_full_name": "Sílvio Zacomelli",
        "timestamp": 1725844205
    },
    {
        "content": "<p>I haven't copilot either (forgot to mention).</p>",
        "id": 468648532,
        "sender_full_name": "Sílvio Zacomelli",
        "timestamp": 1725844274
    },
    {
        "content": "<p>Try the natural number game. This will show you the basics of induction. But I think people will be reluctant to do your homework for you. I would imagine that you've been given some kind of teaching material, which you should probably stick to rather than asking here (where people might use techniques which haven't been/won't be taught)</p>",
        "id": 468649428,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725844940
    },
    {
        "content": "<p>The only material I have is the \"Functional Programming in Lean\" available in the official site and \"Algorithm Design with Haskell\" (in which the course is based upon). The thing is, I can't read 10 chapters in 4 days to do this, so I blindly tried to learn everything I could by practicing and searching. If you have any material which is focused in what I need, it would be useful too. No need in doing the homework for me, I just need hints to get unstuck from this.</p>",
        "id": 468650117,
        "sender_full_name": "Sílvio Zacomelli",
        "timestamp": 1725845480
    },
    {
        "content": "<p>Do you know how to prove this informally?</p>",
        "id": 468660613,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725852025
    },
    {
        "content": "<p>(This is not easy as a first exercise. It's also teaching the wrong things, in some sense, because one should never try to prove such a result straight from definitions without setting up some intermediate lemmas first.)</p>",
        "id": 468699497,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1725865950
    },
    {
        "content": "<p>This is kinda tricky to prove (on paper too!) because you can't fix <code>f</code> and <code>e</code> and then try to do induction on the list that these functions would be applied to. That is, this naive approach won't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">inits</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">scanl</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">funext</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inits</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">foldl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">scanl</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>You can notice this by the fact that the goal will require you to prove something involving <code>scanl f (f e y) ys</code>, while your assumption will only involve <code>scanl f e ys</code>. This should tell you that you can't fix a specific accumulator <code>e</code> and then do induction, instead you should prove by induction that this holds for all <code>e</code>s. In other words, you should try to prove <code>∀ l e, (map (foldl f e) ∘ inits) l = scanl f e l</code>, where doing induction on <code>l</code> will lead you to prove <code>∀ e, (map (foldl f e) ∘ inits) l = scanl f e l</code>. This will still not be so trivial to prove though, as you'll need to do induction twice or use a separate lemma. I would suggest trying to separately prove <code>map (foldl f e') (map (y :: ·) xs) = map (foldl f (f e' y)) xs</code> for that lemma.</p>",
        "id": 468720415,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1725871232
    },
    {
        "content": "<p><code>induction l generalizing e</code> is exactly the magic incantation required to \"prove by induction that this holds for all <code>e</code>s\"!</p>",
        "id": 468758708,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1725880474
    },
    {
        "content": "<p>Yes, that's exactly part of the problem: in the right side I don't get passed of <code>scanl f (f e y) ys</code>, so your suggestion is really good. But the major problem (to me) is the lambda that appears in the left-hand side, after rewriting inits, and I can't get rid of, what makes the lhs very different from the lhs of the inductive hypotheses. Kim mentioned lemmas about the map function, but I didn't get how to use them (maybe I need to try more).</p>",
        "id": 468759270,
        "sender_full_name": "Sílvio Zacomelli",
        "timestamp": 1725880624
    },
    {
        "content": "<p>I have read about it. It's like inducting over one variable and, after proving it, changing the goal to another? I'll try that too.</p>",
        "id": 468759641,
        "sender_full_name": "Sílvio Zacomelli",
        "timestamp": 1725880728
    },
    {
        "content": "<p>I thought of using something like <code>map f ∘ g = map f :: map g </code>, but I need to get better in rewriting the goal using lemmas.</p>",
        "id": 468760591,
        "sender_full_name": "Sílvio Zacomelli",
        "timestamp": 1725880970
    },
    {
        "content": "<p>Currently trying yo show <code>foldl f e ∘ fun x =&gt; y :: x = fold f (f e y)</code></p>",
        "id": 468764548,
        "sender_full_name": "Sílvio Zacomelli",
        "timestamp": 1725881984
    },
    {
        "content": "<p>I did it guys! Thank you for the huge help! One last question: after generalizing e, why there is no goal for proving that the equality holds for all e's or something like that? What is indeed generalizing and how it works (or where can I read about it)?</p>",
        "id": 468769292,
        "sender_full_name": "Sílvio Zacomelli",
        "timestamp": 1725883041
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/270676-lean4/topic/Trying.20to.20prove.20an.20equality.20with.20functions.20of.20lists/near/468758708\">said</a>:</p>\n<blockquote>\n<p><code>induction l generalizing e</code> is exactly the magic incantation required to \"prove by induction that this holds for all <code>e</code>s\"!</p>\n</blockquote>\n<p>TIL, though for learning I generally prefer taking the longer way and only use the basics, otherwise you can easily get overwhelmed by all the different notations and rules.</p>",
        "id": 468770546,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1725883242
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"753433\">Sílvio Zacomelli</span> <a href=\"#narrow/stream/270676-lean4/topic/Trying.20to.20prove.20an.20equality.20with.20functions.20of.20lists/near/468769292\">said</a>:</p>\n<blockquote>\n<p>I did it guys! Thank you for the huge help! One last question: after generalizing e, why there is no goal for proving that the equality holds for all e's or something like that? What is indeed generalizing and how it works (or where can I read about it)?</p>\n</blockquote>\n<p>If I understand <code>induction l generalizing e</code> correctly, the <code>generalizing e</code> part means that instead of proving the statement for the current specific <code>e</code>, you have to prove it for any <code>e</code>. So it's not that there's no goal for this, it's the only goal you have to prove. The initial goal is instead trivially handled by the tactic because if you proved that the statement holds for all <code>e</code>s then of course it also holds for the original one.</p>",
        "id": 468771381,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1725883398
    },
    {
        "content": "<p>In other words, I still need to prove that it hold for any <code>e</code>. So now, I have <code>example : map (foldl f e) ∘ inits = scanl f e</code> but with induction in <code>e</code>?</p>",
        "id": 468777440,
        "sender_full_name": "Sílvio Zacomelli",
        "timestamp": 1725884614
    },
    {
        "content": "<p>There's no induction over <code>e</code> going on, only over <code>l</code>. However <code>e</code> is not \"fixed\" before doing the induction, so the inductive hypothesis holds for all <code>e</code> instead of just the initial one.</p>",
        "id": 468812070,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1725891210
    },
    {
        "content": "<p>I see. Thanks for the help!</p>",
        "id": 468826880,
        "sender_full_name": "Sílvio Zacomelli",
        "timestamp": 1725894059
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"753433\">Sílvio Zacomelli</span> has marked this topic as resolved.</p>",
        "id": 468827910,
        "sender_full_name": "Notification Bot",
        "timestamp": 1725894273
    }
]