[
    {
        "content": "<p>What is the relationship between <code>DecidableEq</code> and <code>LawfulBEq</code> please?</p>",
        "id": 448391716,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1719854248
    },
    {
        "content": "<p>Seems like every instance of one should be an instance of the other, which begs the question, it is really for the best that these be separate typeclasses?</p>",
        "id": 448404254,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1719858000
    },
    {
        "content": "<p>I suppose you could have DecidableEq and then an unlawful BEq, but then it would feel like the BEq was defined wrong.</p>",
        "id": 448405368,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1719858310
    },
    {
        "content": "<p>It's perfectly fine to have a non-lawful <code>BEq</code> even if equality is decidable. <code>BEq</code> is a programming concept and you can use it to define whatever notion of equality is convenient for your program. For example, you might have a structure that contains a field which is transient in some sense, and you do not want it to be considered when using the structure as a key in a hash map. Then you would define a <code>BEq</code> that is not lawful, even if equality may be decidable.</p>\n<p>Another example would be IEEE 754 floating point numbers (like the Lean <code>Float</code> type). <code>Float</code> has decidable equality (though I don't know if this can be shown given the way <code>Float</code> is defined in Lean), but the <code>BEq</code> instance, which implements comparison as defined in IEEE 754, is famously not reflexive and hence certainly not lawful.</p>",
        "id": 448409941,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1719859277
    },
    {
        "content": "<p>It sounds like <code>LawfulBEq</code> should imply <code>DecidableEq</code>.<br>\nI didn't find such a conversion.<br>\nOn the contrary, I found this:<br>\n<a href=\"https://github.com/leanprover/lean4/blob/3b58e0649156610ce3aeed4f7b5c652340c668d4/src/Init/Prelude.lean#L927\">https://github.com/leanprover/lean4/blob/3b58e0649156610ce3aeed4f7b5c652340c668d4/src/Init/Prelude.lean#L927</a><br>\nI am still confused.</p>",
        "id": 448538381,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1719909300
    },
    {
        "content": "<p>Here is the conversion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">decidableEq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulBEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">isTrue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eq_of_beq</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">isFalse</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ne_of_beq_false</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">eq_false_iff</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 448540763,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1719909809
    },
    {
        "content": "<p>The logical relationship between the two could be summed up as \"<code>DecidableEq</code> holds if and only if it is possible to define a <code>BEq</code> instance such that <code>LawfulBEq</code> holds\".</p>",
        "id": 448541127,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1719909884
    },
    {
        "content": "<p>But that doesn't and shouldn't stop you from defining a <code>BEq</code> instance that does something completely different.</p>",
        "id": 448541265,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1719909912
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/2038\">lean4#2038</a> is perhaps relevant here</p>",
        "id": 448547407,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1719911499
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260921\">Markus Himmel</span> <a href=\"#narrow/stream/270676-lean4/topic/DecidableEq.20vs.20LawfulBEq/near/448540763\">said</a>:</p>\n<blockquote>\n<p>Here is the conversion:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">decidableEq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulBEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">isTrue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eq_of_beq</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">isFalse</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ne_of_beq_false</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">eq_false_iff</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">))</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Afaik this conversion isn't in any of our libraries. Why?</p>",
        "id": 448550932,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1719912328
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/270676-lean4/topic/DecidableEq.20vs.20LawfulBEq/near/448550932\">said</a>:</p>\n<blockquote>\n<p>Afaik this conversion isn't in any of our libraries. Why?</p>\n</blockquote>\n<p>It can't be an instance because it would create a loop with the much more useful other direction you already discovered. Probably no one has bothered to put it in as a <code>def</code> so far simply because it's a pretty strange way to derive <code>DecidableEq</code> and no one has needed it yet.</p>",
        "id": 448555696,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1719913240
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> has marked this topic as resolved.</p>",
        "id": 448568307,
        "sender_full_name": "Notification Bot",
        "timestamp": 1719916197
    },
    {
        "content": "<p>Is <code>BEq</code> just an arbitrary binary relation equipped with the infix <code>==</code> operator?</p>",
        "id": 448642443,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1719935758
    },
    {
        "content": "<p>Yes</p>",
        "id": 448643241,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1719935908
    },
    {
        "content": "<p>But <code>Bool</code>-valued instead of <code>Prop</code>-valued, unlike relations such as <code>&lt;</code></p>",
        "id": 448643413,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1719935943
    }
]