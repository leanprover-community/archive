[
    {
        "content": "<p>More specifically, I want to be able to load dynamic libraries in Lean code on multiple platforms.</p>\n<p>My understanding so far:</p>\n<ul>\n<li>Runtime source code is located in <code>lean4/src/include</code> and <code>lean4/src/runtime</code>.</li>\n<li>Compiled code only needs to <code>#import &lt;lean/lean.h&gt;</code> (I did not find any code in Lean4 sources using <code>lean/lean_gmp.h</code>).</li>\n<li><code>leanc</code> will link the <code>libLeanc.a</code> library when building an executable (this is not shown by <code>lake build -v</code>).</li>\n</ul>\n<p>In the runtime code, I see two platform-specific macros:</p>\n<ul>\n<li>Windows: <code>LEAN_WINDOWS</code></li>\n<li>Emscripten (WASM): <code>LEAN_EMSCRIPTEN</code></li>\n<li>*nix: <code>not(LEAN_WINDOWS)</code></li>\n</ul>\n<p>There are two places in the compiler sources that already provide this functionality for Windows and non-Windows, but these are not available at runtime, so they are not useful for me at this point.</p>\n<p>What are the plans going forward?</p>\n<p>I see two options from here:</p>\n<p>A) (Tactical) Add this functionality to the runtime. We could argue that specifically loading shared libraries is core enough that it should live in the runtime (I am happy to add that if desired), but this solution obviously does not scale since the runtime will end up being a garbage can for everything that needs a cross-platform API.</p>\n<p>B) (Likely long-term plan) Another option is to expose platform-specific flags to the Lean code so that anyone could add cross-platform code as Lake packages outside of core Lean.</p>\n<p>My workaround for now is to add a C shim that relies on <code>LEAN_WINDOWS</code> and <code>not(LEAN_WINDOWS)</code> to load libraries and expose that to my Lean code using standard Lean FFI.</p>\n<p>I could just use the workaround above and go about my business, but I am curious about the longer-term direction here and, if possible, align efforts.</p>\n<p>At this point, I am going ahead with creating something like the <a href=\"https://docs.rs/libloading/latest/libloading/\">libloading</a> crate from Rust. At least, this could be useful to the broader community. First, using the FFI workaround and then migrate to the long term solution once in place.</p>\n<p>Thanks,</p>",
        "id": 441770287,
        "sender_full_name": "Yuri",
        "timestamp": 1717178346
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.loadDynlib#doc\">docs#Lean.loadDynlib</a></p>",
        "id": 442061223,
        "sender_full_name": "Mac Malone",
        "timestamp": 1717340289
    },
    {
        "content": "<p>(Is that what you are looking for?)</p>",
        "id": 442061242,
        "sender_full_name": "Mac Malone",
        "timestamp": 1717340322
    },
    {
        "content": "<p>Hi, <span class=\"user-mention\" data-user-id=\"315577\">@Mac Malone</span>, thanks for the nudge.</p>\n<p>I did see <code>loadDynlib</code>, but I wrongly assumed it was not available at runtime. I should have double checked. Let me see if that is enough for my needs.</p>\n<p>thanks,</p>",
        "id": 442111723,
        "sender_full_name": "Yuri",
        "timestamp": 1717366341
    }
]