[
    {
        "content": "<p>I've recently been working (with a few others) on a Lean formalization of some basic combinatorial objects (perfect matchings of a finite set; the eventual goal is Pfaffians). Today I've at last tried out aristotle, which suggested a short but rather strange <code>obtain</code> command. I wonder if someone can explain it to me.</p>\n<p>This is in the proof of <code>PerfectMatching.partner_block</code> in <a href=\"https://github.com/ghseeli/lean-club/blob/4743c35b97573a2305458bec30fd9822564f75a1/LeanClub/Pfaffian.lean\">https://github.com/ghseeli/lean-club/blob/4743c35b97573a2305458bec30fd9822564f75a1/LeanClub/Pfaffian.lean</a> (second-to-last theorem; note that only the last two proofs are aristotle's handiwork). A <code>PerfectMatching \\alpha</code> is defined as a Finset of ordered pairs that are furthermore disjoint and contain each element of <code>\\alpha</code> among them (thus a structure with four fields: <code>edges</code>, <code>ordered</code>, <code>disjoint</code>, <code>union</code>; we'll probably refactor this eventually, but this is very much a babby's first implementation). The function <code>set</code> transforms a pair <code>(a, b)</code> into the finset <code>{a, b}</code>. The function <code>M.block</code> sends an element of <code>\\alpha</code> to the unique edge of <code>M</code> that contains this element. The theorem <code>partner_block</code> says:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">PerfectMatching</span><span class=\"bp\">.</span><span class=\"n\">partner_block</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PerfectMatching</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">block</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">partner</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Aristotle (after a first strange but completely unnecessary restatement via <code>ext</code> and <code>intro</code>) does the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"bp\">âŸ©</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆƒ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">âˆ§</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">âˆ§</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">block</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">block_spec</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">;</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">ordered</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"bp\">âŸ©;</span>\n</code></pre></div>\n<p>Note that <code>M.block_spec i</code> results in <code>(M.block i âˆˆ M.edges) âˆ§ (i âˆˆ _root_.set (M.block i))</code>. But what happens on the <code>exact</code> line? Why does the existence quantifier appear out of thin air?</p>\n<p>And is this a style I should imitate? It's significantly shorter than my code...</p>",
        "id": 558853958,
        "sender_full_name": "Darij Grinberg",
        "timestamp": 1763859440
    },
    {
        "content": "<p>This works due to the anonymous constructor syntax:<br>\n<a href=\"https://lean-lang.org/theorem_proving_in_lean4/Quantifiers-and-Equality/?terms=anonymous%C2%A0#the-existential-quantifier\">https://lean-lang.org/theorem_proving_in_lean4/Quantifiers-and-Equality/?terms=anonymous%C2%A0#the-existential-quantifier</a></p>\n<p>It works for more than existential, roughly if there is enough info to guess the type of a term that's a structure, you can use that syntax as shorthand for every field the structure has.</p>\n<p><a href=\"https://lean-lang.org/doc/reference/latest/The-Type-System/Inductive-Types/?terms=anonymous#anonymous-constructor-syntax\">https://lean-lang.org/doc/reference/latest/The-Type-System/Inductive-Types/?terms=anonymous#anonymous-constructor-syntax</a></p>",
        "id": 558854771,
        "sender_full_name": "Yan Yablonovskiy ðŸ‡ºðŸ‡¦",
        "timestamp": 1763860195
    },
    {
        "content": "<p>Wow, so the typechecker can solve this kind of sudoku!</p>",
        "id": 558855258,
        "sender_full_name": "Darij Grinberg",
        "timestamp": 1763860919
    },
    {
        "content": "<p>I guess <code>rfl</code> being the last field, it knows what <code>a</code> and <code>b</code> are...</p>",
        "id": 558855421,
        "sender_full_name": "Darij Grinberg",
        "timestamp": 1763861134
    },
    {
        "content": "<p>Oh, so this works just as well:<br>\n<code>Â  Â  exact âŸ¨ (M.block i).1, (M.block i).2, M.ordered (M.block i) this.1, this.2, rfl âŸ©;</code><br>\nmeaning that it understands that <code>M.block i = ((M.block i).1, (M.block i).2)</code> by <code>rfl</code>. So the sudoku is not as hard as I thought...</p>",
        "id": 558855471,
        "sender_full_name": "Darij Grinberg",
        "timestamp": 1763861202
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"773147\">@Yan Yablonovskiy ðŸ‡ºðŸ‡¦</span> !</p>",
        "id": 558855484,
        "sender_full_name": "Darij Grinberg",
        "timestamp": 1763861220
    }
]