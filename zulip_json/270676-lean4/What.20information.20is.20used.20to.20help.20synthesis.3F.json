[
    {
        "content": "<p>And: when do you need to instantiate mvars to help synthesis along?</p>\n<p>Here's the situation: I'm given a target type <code>t</code> and a theorem <code>thm</code> of type <code>a → b → ... → t'</code>, where <code>t'</code> matched <code>t</code> via a discrtree. I want to apply <code>thm</code> to <code>t</code>, and try to synthesize as much as I can using heuristics for the unsolved goals.</p>\n<p>It seems like the first step is computing <code>(hs, bs, t') ← forallMetaTelescopeReducing &lt;thm's type&gt;</code>, then unifying <code>t'</code> with <code>t</code>. I expect this will assign some metavariables now present in <code>t'</code> (unless <a href=\"https://github.com/leanprover/lean4/pull/2054\">lean4#2054</a> presents an issue here).</p>\n<p>The issue is then what the best way to step through <code>hs</code> is to deal with implicits and heuristic solving together. Here are a couple examples of slightly different approaches:</p>\n<ol>\n<li><strong>sequential</strong>: step through the arguments one by one; insert a natural metavariable for implicit (unification-solved) arguments; insert a metavariable to solve via TC for instance arguments, and try to solve them immediately; apply heuristics to each other <code>hs</code> as soon as it's encountered.</li>\n<li><strong>implicits first</strong>: Attempt to synthesize all implicit/instance arguments first, then apply heuristics to each other argument that remains.</li>\n<li><strong>implicits second</strong>: Create mvars for each implicit argument, and try to solve each other metavariable with heuristics. Then go back and try to synthesize any instance arguments that were encountered.</li>\n</ol>\n<p>The crux of the question here is: which order provides the most information to each solving process? For example, can attempting to solve later arguments by heuristics influence TC search in earlier instance arguments? (Do instance/implicit arguments <em>always</em> come first, and thus two of these options are equivalent?)</p>",
        "id": 339463840,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1677886379
    },
    {
        "content": "<p>Metavariables for instance subgoals are added to a pending list, and you can solve them using something like <code>trySynthPendingMVars</code> which takes no arguments</p>",
        "id": 339464368,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677886703
    },
    {
        "content": "<p>But when should you try to solve them? Before you've solved the other goals, or after, or both? (Or each step of the way?)</p>",
        "id": 339464617,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1677886887
    },
    {
        "content": "<p>I don't think there is a good answer to that. Everything can potentially help or be helped by something else</p>",
        "id": 339464896,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677887053
    },
    {
        "content": "<p>Hmm. Is calling something like <code>trySynthPendingMVars</code> relatively expensive to do over and over?</p>",
        "id": 339464933,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1677887089
    },
    {
        "content": "<p>no idea</p>",
        "id": 339464939,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677887095
    },
    {
        "content": "<p>I would just follow the lead of something like the app elaborator</p>",
        "id": 339464992,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677887117
    },
    {
        "content": "<p>sounds reasonable, I'll poke around in Lean.Elab.App</p>",
        "id": 339465396,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1677887386
    }
]