[
    {
        "content": "<p>is there any discussion of an hadd instance between fin and nat? just doing the usual Z/n behavior. </p>\n<p>it is one of those things that makes sense on a type for Z/n but not a type for [n], so I'm not sure if it is there.</p>",
        "id": 362616893,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1685589493
    },
    {
        "content": "<p>I think it would be preferable to just use coercions here, same as how we don't have a <code>HAdd Int Nat Int</code> instance</p>",
        "id": 362618188,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685590354
    },
    {
        "content": "<p>But having a coercion <code>Nat -&gt; Fin n</code> is admittedly deeply confusing (you could get inadvertent % where you don't want them).</p>",
        "id": 362620807,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1685592158
    },
    {
        "content": "<p>I thought there was a discussion at one point about separating the type with wrapping ring arithmetic from the type with non-wrapping arithmetic where overflow must be accounted for.</p>",
        "id": 362620926,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1685592246
    },
    {
        "content": "<p>keep in mind that <code>4 : Fin 2</code> already typechecks</p>",
        "id": 362621323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685592493
    },
    {
        "content": "<p>which always peeved me, since <code>4 : Fin n</code> with a hypothesis in context like <code>n = 2</code> or <code>n &gt; 0</code> or anything along those lines does not typecheck <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 362621741,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1685592734
    },
    {
        "content": "<p>how is the hypothesis supposed to be used?</p>",
        "id": 362621791,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685592781
    },
    {
        "content": "<p>do you want it to <code>by assumption</code> or something?</p>",
        "id": 362621819,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685592793
    },
    {
        "content": "<p><code>4 : Fin (n+1)</code> does typecheck</p>",
        "id": 362621920,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685592851
    },
    {
        "content": "<p>and mathlib also has a version where <code>4 : Fin n</code> typechecks given <code>Fact (0 &lt; n)</code></p>",
        "id": 362621967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685592889
    },
    {
        "content": "<p>I think for a type like <code>Mod n</code> the current mathlib behavior for Fin makes sense, trying to do whatever it can do show <code>n &gt; 0</code> so that the ring operations just work (in fact, it might even make sense for <code>Mod n</code> to require <code>n &gt; 0</code> for simplicity's sake, since Z/0 is degenerate...)</p>",
        "id": 362622134,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1685592985
    },
    {
        "content": "<p>you mean <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZMod#doc\">docs4#ZMod</a> ?</p>",
        "id": 362622367,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685593124
    },
    {
        "content": "<p>yes, that is exactly what i'm looking for :)</p>",
        "id": 362622551,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1685593242
    },
    {
        "content": "<p>now the question is why the wrapping <code>Fin.add</code> exists!</p>",
        "id": 362622642,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1685593294
    },
    {
        "content": "<p>what do you expect it to be?</p>",
        "id": 362622802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685593377
    },
    {
        "content": "<p>whatever you are thinking, it is much worse to work with</p>",
        "id": 362622830,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685593391
    },
    {
        "content": "<p>one pragmatic reason for <code>Fin.add</code> is that it is used to define <code>UInt32.add</code> and <code>UInt64.add</code></p>",
        "id": 362622924,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685593442
    },
    {
        "content": "<p>yeah. but you could see <code>ZMod</code> being moved to core and used as the backing for <code>UIntX</code></p>",
        "id": 362623051,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1685593488
    },
    {
        "content": "<p>Idk. I don't really ever <em>want</em> to add <code>Fin</code>s (?). Speaking as someone who only interacts with <code>Fin</code> in <code>Array</code> contexts.</p>",
        "id": 362623108,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1685593527
    },
    {
        "content": "<p>then maybe don't</p>",
        "id": 362623219,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685593570
    },
    {
        "content": "<p><code>ZMod</code> is a conditional type, it is defined as <code>Fin n</code> for <code>n &gt; 0</code> and <code>Int</code> for <code>n = 0</code></p>",
        "id": 362623486,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685593729
    },
    {
        "content": "<p>array indices don't even really want <code>Fin n</code>, they would be better off with <code>{ i : UInt64 // i &lt; n }</code></p>",
        "id": 362623641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685593805
    },
    {
        "content": "<p>Your original question sounds more like <code>vadd</code>. I still believe we should <em>never</em> use <code>HAdd</code> because the only heterogeneous cases that matter are covered by <code>vadd</code>.</p>",
        "id": 362632698,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1685598377
    },
    {
        "content": "<p>I'd make the stronger claim that  it's not just that <code>vadd</code> and <code>smul</code> are the only cases that matter, but<code>HAdd</code> and <code>HMul</code> are massive footguns as there is no sane composition strategy to avoid non-propeq diamonds</p>",
        "id": 362714567,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685617827
    },
    {
        "content": "<p>Arguably we could add a <code>nvadd</code> field to <code>AddMonoidWithOne</code>  which would give the behavior that <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> suggests</p>",
        "id": 362714810,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685617902
    },
    {
        "content": "<p>i think HAdd is more useful for programmers</p>",
        "id": 362727466,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1685620578
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"221921\">Marc Huisinga</span> has marked this topic as resolved.</p>",
        "id": 362786305,
        "sender_full_name": "Notification Bot",
        "timestamp": 1685631666
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"221921\">Marc Huisinga</span> has marked this topic as unresolved.</p>",
        "id": 362786380,
        "sender_full_name": "Notification Bot",
        "timestamp": 1685631680
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/HAdd.20.28Fin.20n.29.20Nat.20.28Fin.20n.29.3F/near/362623641\">said</a>:</p>\n<blockquote>\n<p>array indices don't even really want <code>Fin n</code>, they would be better off with <code>{ i : UInt64 // i &lt; n }</code></p>\n</blockquote>\n<p>Or, more precisely, <code>USize</code>.</p>",
        "id": 362913434,
        "sender_full_name": "Mac Malone",
        "timestamp": 1685669541
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/HAdd.20.28Fin.20n.29.20Nat.20.28Fin.20n.29.3F/near/362714567\">said</a>:</p>\n<blockquote>\n<p>I'd make the stronger claim that [...]<code>HAdd</code> and <code>HMul</code> are massive footguns as there is no sane composition strategy to avoid non-propeq diamonds</p>\n</blockquote>\n<p>Just to give a concrete example of this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Logic.Nontrivial.Defs</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Pi.Algebra</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- HMul generalizes to families on the right</span>\n<span class=\"kd\">instance</span> <span class=\"n\">hmulRight</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">HMul</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">HMul</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">hMul</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"n\">i</span>\n\n<span class=\"c1\">-- HMul generalizes to families on the left</span>\n<span class=\"kd\">instance</span> <span class=\"n\">hmulLeft</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">HMul</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">HMul</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">hMul</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">b</span>\n\n<span class=\"c1\">-- both of these are valid instance searches, lets give them short names</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">ι</span><span class=\"o\">)</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">lr</span> <span class=\"o\">:</span> <span class=\"n\">HMul</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">hmulLeft</span> <span class=\"o\">(</span><span class=\"n\">inst</span> <span class=\"o\">:=</span> <span class=\"n\">hmulRight</span><span class=\"o\">)</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">rl</span> <span class=\"o\">:</span> <span class=\"n\">HMul</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">hmulRight</span> <span class=\"o\">(</span><span class=\"n\">inst</span> <span class=\"o\">:=</span> <span class=\"n\">hmulLeft</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- holy diamonds batman</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">lr</span> <span class=\"n\">ι</span><span class=\"bp\">;</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">rl</span> <span class=\"n\">ι</span><span class=\"bp\">;</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"n\">j</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- propositional diamonds!</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">Nontrivial</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">lr</span> <span class=\"n\">ι</span> <span class=\"bp\">≠</span> <span class=\"n\">rl</span> <span class=\"n\">ι</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">classical</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">hij</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">exists_pair_ne</span> <span class=\"n\">ι</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">lr</span><span class=\"o\">,</span> <span class=\"n\">rl</span><span class=\"o\">,</span> <span class=\"n\">hmulLeft</span><span class=\"o\">,</span> <span class=\"n\">hmulRight</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">injection</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">h</span>\n  <span class=\"n\">replace</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">congr_fun₂</span> <span class=\"o\">(</span><span class=\"n\">congr_fun₂</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">mulSingle</span> <span class=\"n\">i</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">mulSingle</span> <span class=\"n\">i</span> <span class=\"mi\">3</span><span class=\"o\">))</span> <span class=\"n\">i</span> <span class=\"n\">j</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">mulSingle_eq_same</span><span class=\"o\">,</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">mulSingle_eq_same</span><span class=\"o\">,</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">mulSingle_eq_of_ne'</span> <span class=\"n\">hij</span><span class=\"o\">,</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">mulSingle_eq_of_ne'</span> <span class=\"n\">hij</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 403811115,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700753565
    }
]