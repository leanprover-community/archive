[
    {
        "content": "<p>I'm trying to experiment with metaprogramming a bit; why does this MWE work with <code>congrFunMonoUniverse</code> but not with <code>congrFun</code>? (it gives \"AppBuilder for 'mkAppM', result contains metavariables\")<br>\nIs there any way to \"close\" the term and quantify universally over the universe levels?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Lean.Meta</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span>\n\n<span class=\"c1\">-- use the same universe level</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">congFunMonoUniverse.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- use two different levels</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">congFun.</span><span class=\"o\">{</span><span class=\"n\">u₁</span><span class=\"o\">,</span><span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">congrFunExpr</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">mapForallTelescope</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">congFun</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">])</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">congrFunMonoUniverseExpr</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">mapForallTelescope</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">congFunMonoUniverse</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">])</span> <span class=\"n\">e</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"congrFun_of% \"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">congrFunExpr</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Term.elabTerm</span> <span class=\"n\">t</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"congrFunMonoUniverse_of% \"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">congrFunMonoUniverseExpr</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Term.elabTerm</span> <span class=\"n\">t</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">equation</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">},</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"mi\">3</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">congrFunMonoUniverse_of</span><span class=\"bp\">%</span> <span class=\"n\">Example.equation</span>\n<span class=\"k\">#check</span> <span class=\"n\">congrFun_of</span><span class=\"bp\">%</span> <span class=\"n\">Example.equation</span>\n</code></pre></div>",
        "id": 406930957,
        "sender_full_name": "Andrea Laretto",
        "timestamp": 1702125634
    },
    {
        "content": "<p>Can you please include your imports?</p>",
        "id": 406933310,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1702127485
    },
    {
        "content": "<p>Yes, fixed, sorry!</p>",
        "id": 406943232,
        "sender_full_name": "Andrea Laretto",
        "timestamp": 1702132269
    },
    {
        "content": "<p>I'm not exactly sure what is going on here, but there are some relevant parts of the metaprogramming book that might be helpful: <a href=\"https://github.com/leanprover-community/lean4-metaprogramming-book/blob/master/md/main/03_expressions.md#universe-levels\">univ levels in exprs</a>, <a href=\"https://github.com/leanprover-community/lean4-metaprogramming-book/blob/master/md/main/04_metam.md#applications\"><code>mkAppM</code></a></p>\n<p>I <em>think</em> universe variables can only be bound at constant declarations. I think <code>#check</code> declares the given expression as a constant before printing its type, which might be how it allows univ polymorphism. But I'm not sure if it generalizes all universe metavariables in the expression.</p>",
        "id": 407025719,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1702196269
    },
    {
        "content": "<p>I've been following the metaprogramming book but it doesn't touch upon this topic of managing universe levels. In <code>let</code> expressions you can write <code>congFun rfl</code> and it generalizes universe variables correctly, but in the following code</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"kd\">example</span> <span class=\"o\">:=</span> <span class=\"n\">congFun</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I get the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">occurrence</span> <span class=\"n\">of</span> <span class=\"kd\">universe</span> <span class=\"n\">level</span> <span class=\"bp\">'</span><span class=\"n\">u_2'</span> <span class=\"n\">at</span> <span class=\"bp\">'</span><span class=\"kd\">example</span><span class=\"bp\">'</span><span class=\"o\">,</span> <span class=\"n\">it</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"n\">occur</span> <span class=\"n\">at</span> <span class=\"n\">the</span> <span class=\"n\">declaration</span> <span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">nor</span> <span class=\"n\">it</span> <span class=\"n\">is</span> <span class=\"n\">explicit</span> <span class=\"kd\">universe</span> <span class=\"n\">level</span> <span class=\"n\">provided</span> <span class=\"kd\">by</span> <span class=\"n\">the</span> <span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">occurring</span> <span class=\"n\">at</span> <span class=\"n\">expression</span>\n  <span class=\"n\">congFun.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">,</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">rfl.</span><span class=\"o\">{</span><span class=\"n\">u_2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n<span class=\"n\">at</span> <span class=\"n\">declaration</span> <span class=\"n\">body</span>\n  <span class=\"n\">congFun</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>which I think is more or less the same of the original problem. </p>\n<p>So, is there any way to create a new declaration/constant which generalizes the universe levels of an expression?</p>",
        "id": 407215879,
        "sender_full_name": "Andrea Laretto",
        "timestamp": 1702292329
    },
    {
        "content": "<p>The <code>def</code> command generalizes the universe variables that appear in a type, but if the universe level metavariable only appears in the body then it's an error. The problem is that in Lean's type theory you can only quantify over universe levels at the very top level of a declaration so to speak.</p>\n<p>The problem with <code>congrFun_of%</code> is different though. It's just that <code>mkAppM</code> is meant to solve for every metavariable it introduces. If you need metavariables, you're expected to handle creating the application by other means.</p>",
        "id": 407275162,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702311831
    },
    {
        "content": "<p>Here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Lean.Meta</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">congFun.</span><span class=\"o\">{</span><span class=\"n\">u₁</span><span class=\"o\">,</span><span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">congrFunExpr</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">forallTelescope</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">args</span> <span class=\"n\">_ty</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">e.beta</span> <span class=\"n\">args</span>\n    <span class=\"k\">let</span> <span class=\"n\">e'</span> <span class=\"bp\">←</span> <span class=\"n\">Term.elabAppArgs</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Term.mkConst</span> <span class=\"bp\">``</span><span class=\"n\">congFun</span><span class=\"o\">)</span> <span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">expr</span> <span class=\"n\">e</span><span class=\"o\">]</span> <span class=\"n\">none</span> <span class=\"n\">false</span> <span class=\"n\">false</span>\n    <span class=\"n\">mkLambdaFVars</span> <span class=\"n\">args</span> <span class=\"n\">e'</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"congrFun_of% \"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">congrFunExpr</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Term.elabTerm</span> <span class=\"n\">t</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">equation</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">},</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"mi\">3</span>\n\n\n<span class=\"k\">#check</span> <span class=\"n\">congrFun_of</span><span class=\"bp\">%</span> <span class=\"n\">Example.equation</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">fun self {x y} ↦ congFun (Example.equation self) :</span>\n<span class=\"cm\">  ∀ (self : Example ?m.2424) {x y : Nat} (f : Nat → ?m.2441 self), f (x + 1) = f (y - 3)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 407276522,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702312240
    },
    {
        "content": "<p>I had to do forallTelescope/mkLambdaFVars myself because mapForallTelescope is specialized to just MetaM for some reason</p>",
        "id": 407276609,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702312266
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/.60mkAppM.60.20fails.20with.20multiple.20universe.20metavariables/near/407025719\">said</a>:</p>\n<blockquote>\n<p>I think <code>#check</code> declares the given expression as a constant before printing its type</p>\n</blockquote>\n<p>It doesn't need to do that -- it just elaborates the expression and runs <code>Term.levelMVarToParam</code> on it to make universe level metavariables print instead as fresh universe level variables, which it doesn't really need to do but it makes the output look nicer. (It also has a special case for <code>#check</code>ing a constant, where it pretty prints in a declaration heading style.)</p>",
        "id": 407277675,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702312584
    },
    {
        "content": "<p>I see,  that makes sense! Thank you for the very clear explanation <span aria-label=\"blush\" class=\"emoji emoji-1f60a\" role=\"img\" title=\"blush\">:blush:</span></p>",
        "id": 407480099,
        "sender_full_name": "Andrea Laretto",
        "timestamp": 1702389100
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"568205\">Andrea Laretto</span> has marked this topic as resolved.</p>",
        "id": 407482228,
        "sender_full_name": "Notification Bot",
        "timestamp": 1702389679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"568205\">Andrea Laretto</span> has marked this topic as unresolved.</p>",
        "id": 407524394,
        "sender_full_name": "Notification Bot",
        "timestamp": 1702401226
    },
    {
        "content": "<p>One last issue, I'll write it here to avoid opening a new topic: I've been trying to capture the previous example within a new declaration, but <code>addRelatedDecl</code> from mathlib4 apparently does not introduce universe levels as parameters: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Lean.Meta</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Util.AddRelatedDecl</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">congFun.</span><span class=\"o\">{</span><span class=\"n\">u₁</span><span class=\"o\">,</span><span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">congrFunExpr</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">forallTelescope</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">args</span> <span class=\"n\">_ty</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">e.beta</span> <span class=\"n\">args</span>\n    <span class=\"k\">let</span> <span class=\"n\">e'</span> <span class=\"bp\">←</span> <span class=\"n\">Term.elabAppArgs</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Term.mkConst</span> <span class=\"bp\">``</span><span class=\"n\">congFun</span><span class=\"o\">)</span> <span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">expr</span> <span class=\"n\">e</span><span class=\"o\">]</span> <span class=\"n\">none</span> <span class=\"n\">false</span> <span class=\"n\">false</span>\n    <span class=\"n\">mkLambdaFVars</span> <span class=\"n\">args</span> <span class=\"n\">e'</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"congrFun_of% \"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">congrFunExpr</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Term.elabTerm</span> <span class=\"n\">t</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">congrFunA</span><span class=\"o\">)</span> <span class=\"s2\">\"congrFunA\"</span> <span class=\"o\">(</span><span class=\"s2\">\" (\"</span> <span class=\"bp\">&amp;</span><span class=\"s2\">\"attr\"</span> <span class=\"s2\">\":=\"</span> <span class=\"n\">Parser.Term.attrInstance</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"s2\">\")\"</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">attr</span>\n\n<span class=\"n\">initialize</span> <span class=\"n\">registerBuiltinAttribute</span> <span class=\"o\">{</span>\n  <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">congrFunA</span>\n  <span class=\"n\">descr</span> <span class=\"o\">:=</span> <span class=\"s2\">\"\"</span>\n  <span class=\"n\">applicationTime</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">afterCompilation</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">src</span> <span class=\"n\">ref</span> <span class=\"n\">kind</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">ref</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"bp\">|</span> <span class=\"n\">congrFunA</span> <span class=\"bp\">$</span><span class=\"o\">[(</span><span class=\"n\">attr</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">stx</span><span class=\"bp\">?</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"o\">)]</span><span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MetaM.run'</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">kind</span> <span class=\"bp\">!=</span> <span class=\"n\">AttributeKind.global</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n      <span class=\"n\">throwError</span> <span class=\"s2\">\"`congrFunA` can only be used as a global attribute\"</span>\n    <span class=\"n\">Mathlib.Tactic.addRelatedDecl</span> <span class=\"n\">src</span> <span class=\"s2\">\"_congrFun\"</span> <span class=\"n\">ref</span> <span class=\"n\">stx</span><span class=\"bp\">?</span> <span class=\"k\">fun</span> <span class=\"n\">type</span> <span class=\"n\">value</span> <span class=\"n\">levels</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">congrFunExpr</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkExpectedTypeHint</span> <span class=\"n\">value</span> <span class=\"n\">type</span><span class=\"o\">)</span>\n      <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"bp\">←</span> <span class=\"n\">p.run'</span>\n      <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">levels</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Then, in a new file, </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Test</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">equation</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">},</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"mi\">3</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">congrFunA</span><span class=\"o\">]</span> <span class=\"n\">Example.equation</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">congrFun_of</span><span class=\"bp\">%</span> <span class=\"n\">Example.equation</span>\n</code></pre></div>\n<p>I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">kernel</span><span class=\"o\">)</span> <span class=\"n\">declaration</span> <span class=\"n\">has</span> <span class=\"n\">metavariables</span> <span class=\"bp\">'</span><span class=\"n\">Example.equation_congrFun'</span>\n</code></pre></div>\n<p>Is there a way to solve this? (i.e. to \"abstract\" all the metavariables in a new declaration?)</p>",
        "id": 407524494,
        "sender_full_name": "Andrea Laretto",
        "timestamp": 1702401258
    },
    {
        "content": "<p>Yes, there are functions to replace level metavariables with fresh level parameters. You could take a look at <a href=\"https://github.com/leanprover/lean4/blob/b0fe9d6cdca82723134d61f8fe23a8c674f308b7/src/Lean/Elab/Term.lean#L586-L591\">https://github.com/leanprover/lean4/blob/b0fe9d6cdca82723134d61f8fe23a8c674f308b7/src/Lean/Elab/Term.lean#L586-L591</a> which also adds those levels to the current TermElab state. Rather than updating the state though, <code>addRelatedDecl</code> is expecting that you return the new <code>level</code>s list.</p>",
        "id": 407529330,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702402873
    },
    {
        "content": "<p>The <code>elementwise</code> attribute in Mathlib/Tactic/CategoryTheory/Elementwise is one that needs to introduce a new universe level</p>",
        "id": 407529332,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702402874
    },
    {
        "content": "<p>In fact, you seem to know that you only need a single extra universe level, right? You could take a look how it's done there. Rather than using an elaborator instead it constructs the transformed theorem statement using a freshly generated level parameter.</p>",
        "id": 407529671,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702402971
    }
]