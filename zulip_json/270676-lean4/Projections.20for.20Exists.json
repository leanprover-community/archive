[
    {
        "content": "<p>I came across the following which I don't understand:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"ss\">`foo</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">c.value</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n<span class=\"w\">  </span><span class=\"n\">Meta.lambdaLetTelescope</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">_fvars</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">proj</span><span class=\"w\"> </span><span class=\"n\">nm</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"n\">_struct</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">println</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"n\">nm</span><span class=\"w\"> </span><span class=\"c1\">-- Exists</span>\n<span class=\"w\">      </span><span class=\"n\">println</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"c1\">-- 0</span>\n<span class=\"w\">      </span><span class=\"n\">println</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"n\">getStructureFields</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">nm</span><span class=\"w\"> </span><span class=\"c1\">-- PANIC</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n</code></pre></div>\n<p>What I really want to do is convert the projection to a function application, but I don't know how to do that in this case!</p>",
        "id": 471773959,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726849388
    },
    {
        "content": "<p>The thing is, in my mental model of how things work in <code>MetaM</code> world, if I have an expression of the form <code>.proj nm idx struct</code> then I should be able to call <code>getStructureFields env nm</code>, but clearly this is not the case.</p>",
        "id": 471775592,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726849818
    },
    {
        "content": "<p>As far as I can tell, in this case the projection <code>h.1</code> actually <em>cannot</em> be converted to a function application without using <code>Exists.choose</code>. Note that using <code>Exists.choose</code> adds that as a used axiom, but <code>foo</code> as written above does not depend on any axioms.</p>",
        "id": 471779687,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726851067
    },
    {
        "content": "<p>actually, because this is subsingleton elimination, there might be a way to do this without choice?</p>",
        "id": 471780172,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726851207
    },
    {
        "content": "<p>I don't really care about whether or not choice is used TBH. I really just want to convert this <code>Expr.proj</code> to an <code>Expr.app</code>.</p>",
        "id": 471780372,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726851260
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">nonempty_of_exists</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nonempty_prop</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">this</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n</code></pre></div>\n<p>indeed it exists</p>",
        "id": 471783263,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726851952
    },
    {
        "content": "<p>I mean... there is also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Exists.fst#doc\">docs#Exists.fst</a> but that's not the point. The point is that I want some <code>MetaM</code> program that is able to convert <code>Expr.proj</code> to <code>Expr.app</code>. I could write such a program which checks for special cases like <code>Exists</code>, but I hope that's not necessary.</p>",
        "id": 471784977,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726852332
    },
    {
        "content": "<p>it's not always  possible in general, unless someone made a definition with a compatible type and you happen to know what it is</p>",
        "id": 471814310,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726860220
    },
    {
        "content": "<p><code>Exists.fst</code> is not a special function, unlike structure projection functions</p>",
        "id": 471814451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726860261
    },
    {
        "content": "<p>It seems that the docstring on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr.proj#doc\">docs#Lean.Expr.proj</a> is slightly misleading then</p>",
        "id": 471814544,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726860300
    },
    {
        "content": "<p>in what way is it misleading?</p>",
        "id": 471814622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726860321
    },
    {
        "content": "<p>I interpret the word \"redundant\" as indicating that they can always be interpreted in terms of the other constructors.</p>",
        "id": 471814806,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726860380
    },
    {
        "content": "<p>oh, that is true, but it's not always a direct application of an existing function</p>",
        "id": 471814854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726860403
    },
    {
        "content": "<p>yeah, I understand.</p>",
        "id": 471814880,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726860413
    },
    {
        "content": "<p>the formal expression equivalent to <code>proj T e i</code> is <code>T.casesOn e (fun x1 ... xn =&gt; xi)</code></p>",
        "id": 471814944,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726860438
    },
    {
        "content": "<p>Oh yeah, good point.</p>",
        "id": 471815072,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726860485
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> do you know off the top of your head where the code is for the elaboration of projections like <code>h.1</code>?</p>",
        "id": 471815186,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726860547
    },
    {
        "content": "<p><code>inferProjType</code> in <code>Lean.Meta.InferType</code> is one place</p>",
        "id": 471815401,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726860627
    },
    {
        "content": "<p>next to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.throwTypeExcepted#src\">src#Lean.Meta.throwTypeExcepted</a></p>",
        "id": 471815478,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726860664
    },
    {
        "content": "<p>Thanks! That's helpful</p>",
        "id": 471815515,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726860680
    },
    {
        "content": "<p>I think there is also code for expanding <code>.proj</code> expressions but this is less common since lean really doesn't want to expand it</p>",
        "id": 471815658,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726860726
    },
    {
        "content": "<p>That would be very helpful indeed!</p>",
        "id": 471815712,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726860750
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/2747\">lean4#2747</a> involved touching every single location that interacts with <code>.proj</code>, so it might be useful to you</p>",
        "id": 471816636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726861103
    },
    {
        "content": "<p>actually, maybe it doesn't exist after all. The code for generating the type of the projection has to do something pretty similar, but it looks like lean will not recognize the defeq of a projection to its definition in terms of <code>casesOn</code></p>",
        "id": 471818321,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726861561
    }
]