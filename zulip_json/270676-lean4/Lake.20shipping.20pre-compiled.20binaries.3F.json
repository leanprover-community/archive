[
    {
        "content": "<p>A question that popped up in <a class=\"message-link\" href=\"/#narrow/channel/474713-Lean-Together-2025/topic/Marcus.20Rossel.3A.20Egg.3A.20An.20Equality.20Saturation.20Tactic.20in.20Lean/near/494214870\">#Lean Together 2025 &gt; Marcus Rossel: Egg: An Equality Saturation Tactic in Lean @ üí¨</a>: </p>\n<p>AFAIK Lake currently doesn't allow to ship pre-compiled binaries to avoid dependencies right now, right? Is that something that is potentially in the horizon? (<span class=\"user-mention\" data-user-id=\"315577\">@Mac Malone</span> )</p>",
        "id": 494318008,
        "sender_full_name": "Andr√©s Goens",
        "timestamp": 1737106295
    },
    {
        "content": "<p>I guess that's potentially a lake + reservoir question rather, in some sense</p>",
        "id": 494318179,
        "sender_full_name": "Andr√©s Goens",
        "timestamp": 1737106329
    },
    {
        "content": "<p>I don't  know anything about lake, but I would wonder how this works for different (combinations of) operating systems and CPU architectures. Would packages then include binaries for each? Or can a package say \"I only exist/work on amd64\"?</p>",
        "id": 494366547,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1737122212
    },
    {
        "content": "<p>yep, in other package managers (e.g. pip in python, etc), bundled binaries often just come separately for each architecture (triple)</p>",
        "id": 494367249,
        "sender_full_name": "Andr√©s Goens",
        "timestamp": 1737122412
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315434\">@Andr√©s Goens</span>  You can run <code>lake upload &lt;tag&gt;</code> to pack everything in the <code>.lake/build</code> directory (including binaries) into an artifact and upload it to a GitHub release with the same tag. If your package is a dependency of another package and has the <code>preferReleaseBuild</code> option set to true, lake will download the artifact instead of rebuilding your package (assuming the versions match). I did this for the <a href=\"https://github.com/abdoo8080/lean-cvc5/tree/main\">lean-cvc5</a> FFI and can confirm that it works for Linux and macOS (I haven't tried it on Windows yet). And yes! You need a seperate artifact for each target triple.</p>",
        "id": 494463039,
        "sender_full_name": "Abdalrhman M Mohamed",
        "timestamp": 1737160589
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"417967\">@Abdalrhman M Mohamed</span> Thanks! I've managed to build a release based on your steps :) A problem I'm running into now is that when I create a project with lean-egg as a dependency, it still tries to build lean-egg from source. Have you run into issues like that with lean-cvc5?</p>\n<p>I think I'm setting the required properties correctly in the <a href=\"https://github.com/marcusrossel/lean-egg/blob/6b9a0feafc14e5dc47cc4451930e7f56d50042f0/lakefile.lean#L11\">lakefile</a>. And I'm referring to the tag of the <a href=\"https://github.com/marcusrossel/lean-egg/releases/tag/nightly-2025-01-22\">release</a> when importing lean-egg in another project:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">[[</span><span class=\"n\">require</span><span class=\"o\">]]</span>\n<span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"s2\">\"egg\"</span>\n<span class=\"n\">git</span><span class=\"w\">  </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"s2\">\"https://github.com/marcusrossel/lean-egg\"</span>\n<span class=\"n\">rev</span><span class=\"w\">  </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"s2\">\"nightly-2025-01-22\"</span>\n</code></pre></div>\n<p>So I don't understand why it's trying to build from source anyway.</p>",
        "id": 496979882,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1738320805
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"372804\">@Marcus Rossel</span>, apologies for the delayed response. I have encountered this issue as well. It appears that Lake downloads the artifact and builds it in parallel, likely treating them as independent jobs. Adding <code>pkg.afterBuildCacheAsync</code> to the external library <a href=\"https://github.com/abdoo8080/lean-cvc5/blob/main/lakefile.lean#L102\">target</a> should resolve this problem.</p>",
        "id": 498804398,
        "sender_full_name": "Abdalrhman M Mohamed",
        "timestamp": 1739204179
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/7032\">lean4#7032</a></p>",
        "id": 498958620,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1739264427
    },
    {
        "content": "<p>Ahh, it seems <code>afterBuildCacheAsync</code> isn't exactly what we need for lean-egg. The given function still <em>always</em> runs the subsequent <code>build</code> job, even if it was able to fetch the cached files:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">Perform a build job after first checking for an (optional) cached build</span>\n<span class=\"sd\">for the package (e.g., from Reservoir or GitHub).</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Package</span><span class=\"bp\">.</span><span class=\"n\">afterBuildCacheAsync</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Package</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">build</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">JobM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Job</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FetchM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Job</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"bp\">.</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">getRootPackage</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"bp\">.</span><span class=\"n\">maybeFetchBuildCache</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">bindM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"n\">setTrace</span><span class=\"w\"> </span><span class=\"n\">nilTrace</span><span class=\"w\"> </span><span class=\"c1\">-- ensure both branches start with the same trace</span>\n<span class=\"w\">      </span><span class=\"n\">build</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">build</span>\n</code></pre></div>\n<p>(Our goal is to only run <code>cargo</code> if we were unable to retrieve the cached files.)</p>\n<p>Is there some way to run the <code>build</code> only if the cached files could not be retrieved? Or does there exist a notion of an \"empty job\" which could be returned in that case?</p>",
        "id": 500151024,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1739789972
    },
    {
        "content": "<p>Mathlib depends on ProofWidgets, which has a compilation step (with <code>npm</code> instead of <code>cargo</code>) that's usually skipped. Maybe you can imitate <a href=\"https://github.com/leanprover-community/ProofWidgets4/blob/main/lakefile.lean#L46-L48\">the relevant part</a> of the lakefile?</p>",
        "id": 500184762,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1739798408
    }
]