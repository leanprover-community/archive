[
    {
        "content": "<p>I'm trying to understand what the mutual blocks sent to the compiler can look like after elaboration. For context, I'm aiming towards later converting the Lean definitions into a Rocq-style lambda-calculus with explicit mutual fixpoints. I'm working with the <code>_unsafe_rec</code> version of functions when available, and mostly not concerning myself with the specifics of elaborating mutual recursion to primitive recursors.</p>\n<p>I know how to handle two classes of mutual blocks:</p>\n<ul>\n<li>There is exactly one definition in the block, and it is non-recursive</li>\n<li>There are one or more definitions in the block, all of which have a function type with at least one argument, and which are irreducibly mutually recursive (ie the dependency graph is strongly connected)</li>\n</ul>\n<p>These two classes are not exhaustive, and I'm wary about there being examples which are in neither one; for example, if the following code was accepted by Lean, it would be such an example.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">mutual</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>Are there situations in which Lean will send the compiler a mutual block containing &gt; 1 definitions and in which at least one of the definitions does not have a function type? How artificial are these, is this an edge case or something which could plausibly come up in natural code?</p>",
        "id": 519101271,
        "sender_full_name": "Simon Dima",
        "timestamp": 1747659158
    },
    {
        "content": "<p>An easy example which does not fall into your categorization is one where the dependency graph is nontrivial but not an SCC:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">mutual</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">37</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 519106757,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747660279
    },
    {
        "content": "<p>This is compiled exactly as if the <code>mutual</code> was not there. Perhaps you would like to say \"without loss of generality\" you don't have to worry about this case</p>",
        "id": 519107060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747660347
    },
    {
        "content": "<p>From what I can see this sends two mutual blocks to the compiler, one defining <code>a</code> and one defining <code>b</code>, both singletons<br>\nPerhaps what I mean by \"mutual block\" is nonstandard terminology?</p>",
        "id": 519107306,
        "sender_full_name": "Simon Dima",
        "timestamp": 1747660406
    },
    {
        "content": "<p>I'm referring to what <a href=\"https://github.com/leanprover/lean4/blob/68b4951d9e165d1b2c9378b88e1ab4952b238476/src/Lean/Compiler/LCNF/Basic.lean#L535\">this comment</a> calls a \"block of functions to be compiled\", not the syntactic <code>mutual &lt;decls&gt; end</code> construct (which is not visible after elaboration, as far as I can tell)</p>",
        "id": 519108126,
        "sender_full_name": "Simon Dima",
        "timestamp": 1747660570
    },
    {
        "content": "<p>That seems to be what the <code>.all</code> field of <code>ConstantVal</code> stores, and <a href=\"https://github.com/leanprover/lean4/blob/68b4951d9e165d1b2c9378b88e1ab4952b238476/src/Lean/Declaration.lean#L113\">this comment</a> calls that a mutual block</p>",
        "id": 519109140,
        "sender_full_name": "Simon Dima",
        "timestamp": 1747660795
    },
    {
        "content": "<p>I think all of those might be slightly different things</p>",
        "id": 519124266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747663787
    },
    {
        "content": "<p>are you interested in what the compiler sees or what is stored in the environment?</p>",
        "id": 519124412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747663810
    },
    {
        "content": "<p>I am very interested in whatever the differences between those two may be, but here I'm working with what is stored in the environment</p>",
        "id": 519124664,
        "sender_full_name": "Simon Dima",
        "timestamp": 1747663861
    },
    {
        "content": "<p>one reason they can be different is that anything <code>noncomputable</code> will not be sent to the compiler but will be in the environment</p>",
        "id": 519125083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747663943
    },
    {
        "content": "<p>Do you not care about <code>unsafe</code> mutual blocks?</p>",
        "id": 519127473,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747664431
    },
    {
        "content": "<p>it seems easy enough to create non-function mutuals using <code>unsafe</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">mutual</span>\n<span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 519127701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747664485
    },
    {
        "content": "<p>Thanks! I do care about <code>unsafe</code>, I think, especially if there are practically relevant situations where we need it to use recursion to define non-functions.<br>\nIs absence of <code>unsafe</code> sufficient to guarantee that mutual definitions will be functions?</p>",
        "id": 519136505,
        "sender_full_name": "Simon Dima",
        "timestamp": 1747666241
    },
    {
        "content": "<p>Not with well-founded recursion but certainly with <code>partial_fixpoint</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">mutual</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">partial_fixpoint</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">partial_fixpoint</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>And also, <code>partial</code> would be similar to <code>unsafe</code> although it creates opaque safe functions (with an unsafe implementation).</p>",
        "id": 519482004,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1747778732
    }
]