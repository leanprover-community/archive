[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.RCases</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Init.Set</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Mem</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">elem</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">type</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Mem</span> <span class=\"n\">elem</span> <span class=\"n\">type</span>\n\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\" ∈ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Mem</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">isElem</span> <span class=\"o\">(</span><span class=\"n\">elem</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Mem.intro</span> <span class=\"n\">elem</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">∈</span> <span class=\"n\">Nat</span>             <span class=\"o\">:=</span> <span class=\"n\">isElem</span> <span class=\"mi\">1</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">∈</span> <span class=\"n\">Bool</span>         <span class=\"o\">:=</span> <span class=\"n\">isElem</span> <span class=\"n\">true</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"s2\">\"Min Suha\"</span> <span class=\"bp\">∈</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"n\">isElem</span> <span class=\"s2\">\"Min Suha\"</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">∈</span> <span class=\"kt\">Type</span>          <span class=\"o\">:=</span> <span class=\"n\">isElem</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"k\">let</span> <span class=\"n\">subtype</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">//</span> <span class=\"n\">s.length</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">5</span><span class=\"o\">}</span>\n          <span class=\"o\">(⟨</span><span class=\"s2\">\"Na Sera\"</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">subtype</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">subtype</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">isElem</span>\n\n<span class=\"c1\">-- type membership</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"s2\">\"Ha Yun\"</span><span class=\"o\">,</span> <span class=\"s2\">\"Ryu Hari\"</span><span class=\"o\">]</span> <span class=\"bp\">∈</span> <span class=\"n\">List</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"n\">isElem</span> <span class=\"o\">[</span><span class=\"s2\">\"Ha Yun\"</span><span class=\"o\">,</span> <span class=\"s2\">\"Ryu Hari\"</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- set membership</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"s2\">\"Ha Yun\"</span><span class=\"o\">,</span> <span class=\"s2\">\"Ryu Hari\"</span><span class=\"o\">]</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span> <span class=\"bp\">|</span> <span class=\"n\">xs.length</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">}</span> <span class=\"o\">:=</span>\n  <span class=\"k\">show</span> <span class=\"o\">[</span><span class=\"s2\">\"Ha Yun\"</span><span class=\"o\">,</span> <span class=\"s2\">\"Ryu Hari\"</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span>\n  <span class=\"k\">from</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Mem</span>\n\n<span class=\"c1\">-- every element is in exactly one type</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">type_unique</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">_h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">eq</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">eq</span>\n\n<span class=\"c1\">-- you can't prove this</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"s2\">\"So Nagi\"</span> <span class=\"bp\">∈</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"k\">have</span> <span class=\"n\">is_string</span> <span class=\"o\">:</span> <span class=\"s2\">\"So Nagi\"</span> <span class=\"bp\">∈</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"n\">isElem</span> <span class=\"s2\">\"So Nagi\"</span>\n  <span class=\"k\">have</span> <span class=\"n\">String_eq_Nat</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span>   <span class=\"o\">:=</span> <span class=\"n\">type_unique</span> <span class=\"n\">is_string</span> <span class=\"n\">h</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- corollary of `Mem.type_unique`</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">mem_iff</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">α'</span> <span class=\"bp\">↔</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">α'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">eq</span><span class=\"o\">⟩</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">eq</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩</span>\n    <span class=\"n\">apply</span> <span class=\"n\">isElem</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Mem</span>\n</code></pre></div>",
        "id": 324373655,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1674959954
    },
    {
        "content": "<p>I know there's no such thing as \"type membership relation\" in standard materials on type theory, but I tried defining it for fun and experimentation.</p>",
        "id": 324373676,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1674959968
    },
    {
        "content": "<p>You will not be able to prove the last sorry because <code>Nat</code> and <code>String</code> cannot be proven distinct</p>",
        "id": 324439175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1675000899
    },
    {
        "content": "<p>Right. That's my complaint about Lean's type theory.</p>",
        "id": 324440318,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1675001352
    },
    {
        "content": "<p>The usual way to fix this in concrete applications is to use an inductive indexing set and a map to types, and then use equality of indexes instead of equality of types</p>",
        "id": 324441047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1675001627
    },
    {
        "content": "<p>Actually, for every definable property in Lean, Nat and String never disagree. So I don't see any reason why they should be unequal. Do we want to prove two types are unequal for the sake of being unequal?</p>",
        "id": 324462079,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1675010993
    },
    {
        "content": "<p>yes, I can count strings, so why not implement them like that :-)</p>",
        "id": 324467596,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1675013630
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"404479\">Trebor Huang</span> <a href=\"#narrow/stream/270676-lean4/topic/defining.20.22type.20membership.20relation.22/near/324462079\">said</a>:</p>\n<blockquote>\n<p>Actually, for every definable property in Lean, Nat and String never disagree. So I don't see any reason why they should be unequal. Do we want to prove two types are unequal for the sake of being unequal?</p>\n</blockquote>\n<p>I'd say they're just isomorphic.</p>",
        "id": 324504636,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1675038964
    },
    {
        "content": "<p>The problem is that internally they could actually be equal. Because you can't rule that out, you can't prove they're not equal.</p>",
        "id": 324545206,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1675065959
    },
    {
        "content": "<p>The <code>type_unique</code> theorem can be strengthened in a way.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">Mem_iff</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">α'</span> <span class=\"bp\">↔</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">α'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨⟩⟩</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩</span>\n    <span class=\"n\">apply</span> <span class=\"n\">isElem</span>\n</code></pre></div>\n<p>Here's another characterization of it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">typeof</span> <span class=\"o\">(</span><span class=\"n\">_a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Mem_iff'</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">α'</span> <span class=\"bp\">↔</span> <span class=\"n\">typeof</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">α'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">typeof</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Mem_iff</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 324567283,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675073322
    }
]