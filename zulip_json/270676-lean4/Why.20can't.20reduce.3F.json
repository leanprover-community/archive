[
    {
        "content": "<p>Hi! Why can't Lean reduce <code>f 5</code> in the example below? At the same time <code>#reduce</code> works well.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">11</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"c1\">-- 0</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"c1\">-- the goal is still f 5 = 0</span>\n</code></pre></div>",
        "id": 450709303,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1720704130
    },
    {
        "content": "<p><code>rfl</code> can close this goal but I want to understand why <code>reduce</code> doesn't work.</p>",
        "id": 450710047,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1720704329
    },
    {
        "content": "<p>I know nothing about the <code>reduce</code> tactic (indeed I didn't even know of its existence until now) but is this something to do with the fact that definitions are by default semireducible, which might mean that they won't reduce unless you <code>unfold</code> them first? Apologies if I'm barking up the wrong tree.</p>",
        "id": 450712731,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1720705042
    },
    {
        "content": "<p>Here's the fix:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">11</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"c1\">-- 0</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">reduce</span>\n</code></pre></div>",
        "id": 450713033,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1720705132
    },
    {
        "content": "<p>Also, please add all the relevant imports when you post your code.</p>",
        "id": 450713078,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1720705146
    },
    {
        "content": "<p>Kevin's diagnosis is correct. All I have done is change <code>def</code> to <code>abbrev</code> which is a neat way of saying \"make this definition reducible\".</p>",
        "id": 450713214,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1720705192
    },
    {
        "content": "<p>That being said, for larger proof developments, unless you are defining type synonyms, using reducible defs can be a performance issue. If you just want to forcibly normalise the term anyway you can use <code>unfold f</code> as Kevin says, or even <code>simp [f]</code> which will simplify the result of the unfolding.</p>",
        "id": 450713812,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1720705346
    },
    {
        "content": "<p>Thanks! But why it works with factorial then?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">factorial</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">factorial</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">factorial</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"c1\">-- the goal is 6 = 6</span>\n</code></pre></div>",
        "id": 450714351,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1720705491
    },
    {
        "content": "<p>my guess would be that it has to do with the fact that <code>factorial</code> uses the inductive structure on <code>Nat</code>...</p>",
        "id": 450715140,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1720705682
    },
    {
        "content": "<p>according to <code>#print</code>, <code>factorial</code> isn't marked as <code>irreducible</code>?</p>",
        "id": 450715526,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1720705766
    },
    {
        "content": "<p>It is marked as <code>reducible</code>.</p>",
        "id": 450716402,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1720705976
    },
    {
        "content": "<p>Definitions by well-founded recursion, such as <code>f</code>, are marked as <code>irreducible</code> by default. Shreyas' <code>abbrev</code> overrides this and makes <code>f</code> <code>reducible</code>. This is a questionable fix, though, since some parts of Lean assume that <code>reducible</code> definitions are always non-recursive. If you want to go this route, <code>@[semireducible] def f</code> would be better. However, note that definitions by well-founded recursion sometimes have very bad reduction performance; that's why they're marked as <code>irreducible</code> by default.</p>\n<p><code>factorial</code> does not use well-founded recursion and therefore doesn't have this issue.</p>\n<p><code>#reduce</code> uses kernel reduction, which ignores the <code>irreducible</code> annotation. <code>reduce</code> apparently uses a different reduction algorithm that respects the <code>irreducible</code> annotation(?).</p>",
        "id": 450716975,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1720706155
    },
    {
        "content": "<p>Thank you all for your answers!</p>",
        "id": 450719555,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1720706827
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> <code>#reduce</code> uses the elaborator's whnf (see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.reduce#doc\">docs#Lean.Meta.reduce</a>). Mathlib's <code>reduce</code> tactic uses the same <code>reduce</code> function. It looks like the major difference is that <code>#reduce</code> turns off smart unfolding.</p>",
        "id": 450764018,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720718030
    },
    {
        "content": "<p>Oh, that's a minor difference. The major difference is that <code>#reduce</code> sets transparency to <code>.all</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">with_unfolding_all</span><span class=\"w\"> </span><span class=\"n\">reduce</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ 0 = 0</span>\n</code></pre></div>",
        "id": 450764755,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720718245
    },
    {
        "content": "<p>In a recent Lean you can use the <code>unseal</code> command:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">unseal</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">reduce</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ 0 = 0</span>\n</code></pre></div>\n<p>I would suggest not using <code>abbrev</code>.</p>",
        "id": 450764997,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720718311
    },
    {
        "content": "<p>Not sure of the verbiage here, but is there a piece of documentation that describes the various \"levels\" of reducibility and transparency?</p>",
        "id": 450795051,
        "sender_full_name": "Chris Henson",
        "timestamp": 1720726929
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.TransparencyMode#doc\">docs#Lean.Meta.TransparencyMode</a> is one source</p>",
        "id": 450795398,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720727047
    },
    {
        "content": "<p>That's for configuring isDefEq/whnf. On the other side, there's annotating definitions with transparency levels.</p>",
        "id": 450795624,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720727099
    },
    {
        "content": "<p>I think <code>instances</code> is slightly incorrect in the docs. It's that it will unfold projections of instances, not instances themselves (so for example functions from a <code>class</code> will be unfolded)</p>",
        "id": 450795877,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720727171
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Why.20can't.20reduce.3F/near/450764018\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <code>#reduce</code> uses the elaborator's whnf (see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.reduce#doc\">docs#Lean.Meta.reduce</a>). Mathlib's <code>reduce</code> tactic uses the same <code>reduce</code> function. It looks like the major difference is that <code>#reduce</code> turns off smart unfolding.</p>\n</blockquote>\n<p>Ah! Thanks, and sorry for spreading misinformation.</p>",
        "id": 450802611,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1720728899
    }
]