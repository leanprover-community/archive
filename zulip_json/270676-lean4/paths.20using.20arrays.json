[
    {
        "content": "<p>What is the easiest way to require something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"o\">(</span><span class=\"n\">L.get</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">L.get</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">fst</span>\n</code></pre></div>\n<p>for each i in the appropriate index, and where L is a list of \"pairs\".</p>\n<p>I'm trying to define paths in a graph. It's specifically important that these paths <br>\nbe stored as arrays with extra information. I also want a path of length 0 to be stored as an empty array. All this is because I want Lean to be able to run an equality check on two different paths without much effort later on.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- a graph consists of:</span>\n<span class=\"kd\">structure</span> <span class=\"n\">graph</span> <span class=\"n\">where</span>\n    <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>    <span class=\"c1\">-- a type of vertices</span>\n    <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>    <span class=\"c1\">-- a type of edges, such that</span>\n    <span class=\"n\">d₀</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">V</span>  <span class=\"c1\">-- each edge has a head</span>\n    <span class=\"n\">d₁</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">V</span>  <span class=\"c1\">-- each edge has a tail</span>\n\n\n\n<span class=\"kd\">structure</span> <span class=\"n\">edge</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">graph</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n    <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">G.E</span>\n    <span class=\"n\">v₀</span> <span class=\"o\">:</span> <span class=\"n\">G.V</span>\n    <span class=\"n\">v₁</span> <span class=\"o\">:</span> <span class=\"n\">G.V</span>\n    <span class=\"n\">p₀</span> <span class=\"o\">:</span> <span class=\"n\">G.d₀</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">v₀</span>\n    <span class=\"n\">p₁</span> <span class=\"o\">:</span> <span class=\"n\">G.d₁</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">v₁</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">List</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">matches</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">graph</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">edge</span> <span class=\"n\">G</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">edges.length</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">edges.length</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">I need n &lt; m ↔ succ n &lt; succ m</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">path</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">graph</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n    <span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">edge</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n    <span class=\"n\">beginning</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">edges.length</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">G.V</span> <span class=\"c1\">-- marks the starting vertex for paths of length 0</span>\n<span class=\"c1\">--  sequential : ??? some condition must ensure that the path is sequential</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">here, some condition must ensure that the path is</span>\n<span class=\"cm\">in fact a path, but I'd like some help figuring out the</span>\n<span class=\"cm\">best way to index the list (I'm completely new to them)</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pointpath</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">graph</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">G.V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">path</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">edges</span> <span class=\"o\">:=</span> <span class=\"o\">[],</span> <span class=\"n\">beginning</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">:</span> <span class=\"o\">[]</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">domain</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">graph</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">path</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">p.edges.length</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G.V</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">codomain</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">graph</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">path</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">p.edges.length</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G.V</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">concatenate</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">graph</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p₀</span> <span class=\"o\">:</span> <span class=\"n\">path</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p₁</span> <span class=\"o\">:</span> <span class=\"n\">path</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">path</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 355793185,
        "sender_full_name": "Dean Young",
        "timestamp": 1683210630
    },
    {
        "content": "<p>Not an expert, but my understanding would be that there would be many different ways to represent the condition, each of which might be appropriate if you use that style of proposition in your proofs.</p>\n<p>For example, you could encode it using indices to say [i] and  [i+1] are connected:  forall i, edges[i].v1 = edges[i+1].v0<br>\nYou could also use isInfix with a list of size two: forall e1 e2, [e1, e2] &lt;:+: edges -&gt; e1.v1 = e2.v0<br>\nYou could also do a recursive definition:  sequential := l.head.v1 = l.tail.head.v1 ∧ sequential l.tail</p>\n<p>etc, etc</p>\n<p>You could also represent a path as a list of vertices, with the attached proof showing that it only passes through valid edges.</p>\n<p>I think the key thing is that you can prove the equivalence of these different statements, and transform it to the form you need for a specific proof.  So a good starting point is thinking about which form would be easiest to use as a hypothesis to use in your proofs, and start there.</p>",
        "id": 355844048,
        "sender_full_name": "Jeremy Salwen",
        "timestamp": 1683221718
    },
    {
        "content": "<p>Are you aware of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.walk\">docs#simple_graph.walk</a>?</p>",
        "id": 355895267,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683238782
    },
    {
        "content": "<p>oh thanks, that's great</p>",
        "id": 357119652,
        "sender_full_name": "Dean Young",
        "timestamp": 1683675118
    }
]