[
    {
        "content": "<p>I've been playing around with building Lean with some compiler optimization settings. With the most aggressive settings I could get to work, I was able to reduce the build time of Mathlib on my computer by 13-14% (from about 59 minutes to about 51 minutes).</p>\n<ol>\n<li>Is there any particular reason why I shouldn't be using such a build? I know that aggressive compiler optimization can change program behavior and make crashes harder to debug, but is that much of an issue here?</li>\n<li>How would I go about building Lean for profiling and profile-guided optimization with LLVM? I've tried to set this up a couple times now and haven't been able to get it to work.</li>\n</ol>",
        "id": 568312704,
        "sender_full_name": "James E Hanson",
        "timestamp": 1768511567
    },
    {
        "content": "<p>I'd say the answer to the first question depends on what kind of optimizations you are building it with (care to share maybe?). It might of course also make it more difficult to help you with whatever issues you might experience.</p>\n<p>We don't have a PGO setup at the moment. It would quite likely also be very annoying to maintain the long term future. The kind of C code that we generate does fluctuate quite a bit due to changes we make to the compiler and we would have to keep mathlib and potentially other repositories profiled etc. with these builds which would be quite a lot of effort for us to maintain for, often, not too much benefit. Check out for exampe what the rust people have done <a href=\"https://blog.rust-lang.org/inside-rust/2020/11/11/exploring-pgo-for-the-rust-compiler/#final-numbers-and-a-benchmarking-plot-twist\">https://blog.rust-lang.org/inside-rust/2020/11/11/exploring-pgo-for-the-rust-compiler/#final-numbers-and-a-benchmarking-plot-twist</a></p>",
        "id": 568317078,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1768513708
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/270676-lean4/topic/Two.20questions.20about.20building.20Lean.20with.20compiler.20optimization/near/568317078\">said</a>:</p>\n<blockquote>\n<p>(care to share maybe?)</p>\n</blockquote>\n<p>Sure, although it might be a bit embarrassing because I really don't know what I'm doing. This was the product of talking to free-tier ChatGPT about what compiler flags can increase runtime performance if you literally don't care about anything else (e.g., compile time, binary size, runtime safety, ease of debugging).</p>\n<div class=\"codehilite\" data-code-language=\"JSON\"><pre><span></span><code><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"nt\">\"name\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"optimized\"</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"nt\">\"displayName\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"Increase runtime speed\"</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"nt\">\"cacheVariables\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"nt\">\"CMAKE_BUILD_TYPE\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"Release\"</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"nt\">\"CMAKE_C_COMPILER\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"clang-20\"</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"nt\">\"CMAKE_CXX_COMPILER\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"clang++-20\"</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"nt\">\"CMAKE_INTERPROCEDURAL_OPTIMIZATION\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"ON\"</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"nt\">\"LEAN_USE_MIMALLOC\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"ON\"</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"nt\">\"CMAKE_C_FLAGS\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"-O3 -ffast-math -funroll-loops -falign-functions=32 -falign-loops=32 -march=native -flto -fno-plt -fno-stack-protector -D_FORTIFY_SOURCE=0 -DMI_SECURE=0 -DMI_PADDING=0 -DNDEBUG\"</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"nt\">\"CMAKE_CXX_FLAGS\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"-O3 -ffast-math -funroll-loops -falign-functions=32 -falign-loops=32 -march=native -flto -fno-plt -fno-stack-protector -D_FORTIFY_SOURCE=0 -DMI_SECURE=0 -DMI_PADDING=0 -DNDEBUG\"</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"nt\">\"CMAKE_EXE_LINKER_FLAGS\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"-fuse-ld=lld -Wl,-O3,--as-needed,--gc-sections\"</span>\n<span class=\"w\">    </span><span class=\"p\">},</span>\n<span class=\"w\">    </span><span class=\"nt\">\"generator\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"Unix Makefiles\"</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"nt\">\"binaryDir\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"${sourceDir}/build/optimized\"</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>If I'm understanding correctly though, <code>\"LEAN_USE_MIMALLOC\": \"ON\",</code> at least is redundant, and I'm not even sure if <code>-ffast-math</code> does anything from the point of view of Mathlib as a benchmark (because why would there be any floating-point calculations there?). I'm sure some or most of this is stupid from a cost/benefit perspective.</p>",
        "id": 568321212,
        "sender_full_name": "James E Hanson",
        "timestamp": 1768515575
    },
    {
        "content": "<p>You will probably be able to reap most benefits from just</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">-</span><span class=\"n\">march</span><span class=\"bp\">=</span><span class=\"n\">native</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"n\">flto</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"n\">fno</span><span class=\"bp\">-</span><span class=\"n\">plt</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"n\">fno</span><span class=\"bp\">-</span><span class=\"n\">stack</span><span class=\"bp\">-</span><span class=\"n\">protector</span>\n</code></pre></div>\n<p>the remainder is mostly relevant for numeric work loads. We can't (or don't want to) use a few of these but they are certainly on the list at some point.</p>",
        "id": 568322312,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1768516048
    },
    {
        "content": "<p>Does that mean that the generic compiler optimization flags like <code>-O2</code> and <code>-O3</code> aren't doing much or anything?</p>",
        "id": 568323263,
        "sender_full_name": "James E Hanson",
        "timestamp": 1768516491
    },
    {
        "content": "<p>Not at all, they are doing a ton of heavy lifting and I would expect -O0 to -O3 is a much larger change than what you are observing here but these flags are different:</p>\n<ul>\n<li>march=native tells the compiler to emit a binary specifically tuned for your CPU, we can't do that on a build that we release to the general public. We could play with weaker versions of this though.</li>\n<li>LTO is link time optimization and allows the compiler to do a more global optimization approach after (or rather while) linking the binary from all the object files but this comes at a significant compile time cost</li>\n<li>disabling the stack protector is giving up on a security feature that is pretty standard to have</li>\n<li>no PLT might actually be something we can just do</li>\n</ul>",
        "id": 568324225,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1768516977
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/270676-lean4/topic/Two.20questions.20about.20building.20Lean.20with.20compiler.20optimization/near/568317078\">said</a>:</p>\n<blockquote>\n<p>We don't have a PGO setup at the moment.</p>\n</blockquote>\n<p>Would it be possible for me to do this by hand, rather than by just modifying the make configuration?</p>",
        "id": 568324968,
        "sender_full_name": "James E Hanson",
        "timestamp": 1768517339
    },
    {
        "content": "<p>I guess what I should ask is how feasible would it be to do it by hand?</p>",
        "id": 568325521,
        "sender_full_name": "James E Hanson",
        "timestamp": 1768517605
    },
    {
        "content": "<p>I don't understand what you mean with doing it by hand</p>",
        "id": 568326140,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1768517929
    },
    {
        "content": "<p>I guess what I'm envisioning is something like compiling the stage1 Lean build to C and then using Clang's PGO from there.</p>",
        "id": 568327069,
        "sender_full_name": "James E Hanson",
        "timestamp": 1768518294
    },
    {
        "content": "<p>Well yes but why would that not involve touching the makefile? :D Everythign else seems horrible</p>",
        "id": 568327138,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1768518334
    },
    {
        "content": "<p>I guess what I meant by 'modifying the makefile' there was modifying it so that it just produces the Lean/Lake binaries with profiling directly.</p>",
        "id": 568327268,
        "sender_full_name": "James E Hanson",
        "timestamp": 1768518399
    },
    {
        "content": "<p>When you say you don't have PGO set up at the moment, do you mean that the Lean compiler is not able to do PGO, or do you mean that the compilation of Lean itself isn't configured for PGO?</p>",
        "id": 568327332,
        "sender_full_name": "James E Hanson",
        "timestamp": 1768518435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/270676-lean4/topic/Two.20questions.20about.20building.20Lean.20with.20compiler.20optimization/near/568327069\">said</a>:</p>\n<blockquote>\n<p>I guess what I'm envisioning is something like compiling the stage1 Lean build to C and then using Clang's PGO from there.</p>\n</blockquote>\n<p>Also, how difficult would this be exactly?</p>",
        "id": 568327507,
        "sender_full_name": "James E Hanson",
        "timestamp": 1768518522
    },
    {
        "content": "<p>The component of Lean that produce the C has absolutely no means to do PGO and won't have for a very long time. But you can just do PGO on the C code and with what clang is doing of course. That would require touching the makefile to give clang the profile information at the appropriate spots (and of course collecting and aggregating relevant profile data to begin with which probably takes hours).</p>",
        "id": 568327744,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1768518638
    },
    {
        "content": "<p>Maybe I should have picked this up by now, but does compiling Lean code always go through a C compilation?</p>",
        "id": 568328379,
        "sender_full_name": "James E Hanson",
        "timestamp": 1768518979
    },
    {
        "content": "<p>It can go through just LLVM without C in theory but yes Lean compiles to C.</p>",
        "id": 568328505,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1768519056
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/270676-lean4/topic/Two.20questions.20about.20building.20Lean.20with.20compiler.20optimization/near/568321212\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/270676-lean4/topic/Two.20questions.20about.20building.20Lean.20with.20compiler.20optimization/near/568317078\">said</a>:</p>\n<blockquote>\n<p>(care to share maybe?)</p>\n</blockquote>\n<p>Sure, although it might be a bit embarrassing because I really don't know what I'm doing. This was the product of talking to free-tier ChatGPT about what compiler flags can increase runtime performance if you literally don't care about anything else (e.g., compile time, binary size, runtime safety, ease of debugging).</p>\n<div class=\"codehilite\" data-code-language=\"JSON\"><pre><span></span><code><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"nt\">\"name\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"optimized\"</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"nt\">\"displayName\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"Increase runtime speed\"</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"nt\">\"cacheVariables\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"nt\">\"CMAKE_BUILD_TYPE\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"Release\"</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"nt\">\"CMAKE_C_COMPILER\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"clang-20\"</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"nt\">\"CMAKE_CXX_COMPILER\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"clang++-20\"</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"nt\">\"CMAKE_INTERPROCEDURAL_OPTIMIZATION\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"ON\"</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"nt\">\"LEAN_USE_MIMALLOC\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"ON\"</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"nt\">\"CMAKE_C_FLAGS\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"-O3 -ffast-math -funroll-loops -falign-functions=32 -falign-loops=32 -march=native -flto -fno-plt -fno-stack-protector -D_FORTIFY_SOURCE=0 -DMI_SECURE=0 -DMI_PADDING=0 -DNDEBUG\"</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"nt\">\"CMAKE_CXX_FLAGS\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"-O3 -ffast-math -funroll-loops -falign-functions=32 -falign-loops=32 -march=native -flto -fno-plt -fno-stack-protector -D_FORTIFY_SOURCE=0 -DMI_SECURE=0 -DMI_PADDING=0 -DNDEBUG\"</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"nt\">\"CMAKE_EXE_LINKER_FLAGS\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"-fuse-ld=lld -Wl,-O3,--as-needed,--gc-sections\"</span>\n<span class=\"w\">    </span><span class=\"p\">},</span>\n<span class=\"w\">    </span><span class=\"nt\">\"generator\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"Unix Makefiles\"</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"nt\">\"binaryDir\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"${sourceDir}/build/optimized\"</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>If I'm understanding correctly though, <code>\"LEAN_USE_MIMALLOC\": \"ON\",</code> at least is redundant, and I'm not even sure if <code>-ffast-math</code> does anything from the point of view of Mathlib as a benchmark (because why would there be any floating-point calculations there?). I'm sure some or most of this is stupid from a cost/benefit perspective.</p>\n</blockquote>\n<p>All of the arguments you're playing with up here poke the flags used for the compilation of the C/C++</p>",
        "id": 568328560,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1768519090
    }
]