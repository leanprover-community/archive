[
    {
        "content": "<p>The behaviour of <code>cases</code> tactic depends on the order of the type constructor's arguments, even if the two types are isomorphic:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ctor</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">match_Foo</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"mi\">2</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"c1\">-- Fails</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Bar</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ctor</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">false</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">match_Bar</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">true</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>Here <code>Foo</code> and <code>Bar</code> are essentially the same, but <code>cases hwf</code> fails on <code>match_Foo</code> which succeeds on <code>match_Bar</code>.</p>\n<p>Context: Here is a minimized example where the above issue becomes somewhat annoying. Switching arg order does not work because no matter what the order of argument, at least one constructor causes trouble.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Ctx</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ctor1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ctx</span> <span class=\"n\">false</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ctor2</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ctx</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">match_Ctx</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Ctx</span> <span class=\"n\">true</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"c1\">-- Fails</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">match_Ctx'</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Ctx</span> <span class=\"n\">true</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">revert</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">generalize</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"bp\">;</span> <span class=\"n\">generalize</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">h</span>\n  <span class=\"n\">case</span> <span class=\"n\">ctor1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cases</span> <span class=\"n\">h₂</span>\n  <span class=\"n\">case</span> <span class=\"n\">ctor2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cases</span> <span class=\"n\">h₁</span>\n</code></pre></div>",
        "id": 400730928,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1699360704
    },
    {
        "content": "<p>I'm not sure if there's some tactic in lean/mathlib that can succeed in the case of <code>match_Foo</code>.</p>",
        "id": 400731755,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1699361035
    },
    {
        "content": "<p>Coq's inversion can succeed in both cases:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">bool</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ctorF</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">false.</span>\n\n<span class=\"n\">Theorem</span> <span class=\"n\">match_Foo</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"mi\">2</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False.</span>\n<span class=\"n\">Proof.</span>\n  <span class=\"n\">inversion</span> <span class=\"n\">h.</span>\n<span class=\"n\">Qed.</span>\n\n<span class=\"n\">Inductive</span> <span class=\"n\">Bar</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ctorB</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">false</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span>\n\n<span class=\"n\">Theorem</span> <span class=\"n\">match_Bar</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">true</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False.</span>\n<span class=\"n\">Proof.</span>\n  <span class=\"n\">inversion</span> <span class=\"n\">h.</span>\n<span class=\"n\">Qed.</span>\n</code></pre></div>\n<p>Version: <code>Coq-Platform~8.15~2022.04</code>.</p>",
        "id": 400731875,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1699361072
    },
    {
        "content": "<p>For <code>cases</code> to work seamlessly, you must avoid arbitrary functions in the indices of constructors. If you write your type like this, everything should work (untested):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ctor</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">x</span> <span class=\"n\">false</span>\n</code></pre></div>\n<p>More generally, constructor indices may contain variables and constructors of other data types, but nothing else. For such indices, the unification algorithm used by <code>cases</code> is complete.</p>\n<p>(This rule should really be documented somewhere, and maybe linted for.)</p>",
        "id": 400733695,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1699361703
    },
    {
        "content": "<p>Actually, <code>f</code> is also a variable. Let me actually test my solution, lest I spout nonsense...</p>",
        "id": 400734002,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1699361814
    },
    {
        "content": "<p>Okay, it does work. <span aria-label=\"relieved\" class=\"emoji emoji-1f60c\" role=\"img\" title=\"relieved\">:relieved:</span> I guess the rule is that indices may contain first-order variables, constructors and nothing else.</p>",
        "id": 400734289,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1699361911
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo'</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ctor</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo'</span> <span class=\"n\">x</span> <span class=\"n\">false</span>\n</code></pre></div>\n<p>Yes, this indeed works, but it brings out another issue: If I write a function <code>f</code> that matches on <code>Foo'</code>, and tries to prove properties of <code>f</code>, then the <code>cases</code> or <code>match</code> on arguments of <code>f</code> will fail with <code>motive not type correct</code>, while if I use</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Bar</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ctor</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">false</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p><code>cases</code> and <code>match</code> will succeed.</p>",
        "id": 400735144,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1699362176
    },
    {
        "content": "<p>I'm not sure whether the above description is accurate, because I barely remember having this issue. I'll try to get a mwe.</p>",
        "id": 400735274,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1699362218
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"524339\">Yicheng Qian</span> <a href=\"#narrow/stream/270676-lean4/topic/Behaviour.20of.20.60cases.60.20depends.20on.20type.20constructor.20args'.20order/near/400731755\">said</a>:</p>\n<blockquote>\n<p>I'm not sure if there's some tactic in lean/mathlib that can succeed in the case of <code>match_Foo</code>.</p>\n</blockquote>\n<p>I can confirm that <code>induction h</code> and <code>induction' h</code> does not work.</p>",
        "id": 400736120,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1699362493
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"524339\">Yicheng Qian</span> <a href=\"#narrow/stream/270676-lean4/topic/Behaviour.20of.20.60cases.60.20depends.20on.20type.20constructor.20args'.20order/near/400736120\">said</a>:</p>\n<blockquote>\n<p>I can confirm that <code>induction h</code> and <code>induction' h</code> does not work.</p>\n</blockquote>\n<p>This is expected: <code>cases</code>, <code>induction</code> and the <code>match</code> compiler all use the same algorithm (I think).</p>",
        "id": 400736364,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1699362587
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"524339\">Yicheng Qian</span> <a href=\"#narrow/stream/270676-lean4/topic/Behaviour.20of.20.60cases.60.20depends.20on.20type.20constructor.20args'.20order/near/400735274\">said</a>:</p>\n<blockquote>\n<p>I'm not sure whether the above description is accurate, because I barely remember having this issue. I'll try to get a mwe.</p>\n</blockquote>\n<p>I failed to get a mwe, and remembered that the issue I had wasn't related to this one ... I'll probably start a new topic for that issue.</p>",
        "id": 400761373,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1699370315
    },
    {
        "content": "<p>Anyway, the unification algorithm of <code>cases</code> could have done better, since in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ctor</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">match_Foo</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"mi\">2</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"c1\">-- Fails</span>\n</code></pre></div>\n<p>It should have delayed the unification of <code>2 =? f n</code>, and then it would spot that <code>false =? true</code> can't be unified.</p>\n<p>Doing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ctor</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">x</span> <span class=\"n\">false</span>\n</code></pre></div>\n<p>is essentially telling <code>cases</code> that <code>2 =? f n</code> should be ignored.</p>",
        "id": 400761836,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1699370443
    },
    {
        "content": "<p>Could be implemented, but I doubt it would be worth it. The current algorithm is quite nice: simple, linear in the number of indices and complete for a well-defined fragment. Introducing postponement would increase the complexity quite a bit, for not that much gain. In particular, you would likely still run into trouble with the data type as you initially defined it; postponement would only address this specific class of examples.</p>",
        "id": 400784804,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1699377568
    },
    {
        "content": "<p>Here's a standard sort of workaround for the very first example. You use <code>generalize</code> to turn indices into variables.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ctor</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">match_Foo</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"mi\">2</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">generalize</span> <span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"c1\">-- succeeds</span>\n</code></pre></div>",
        "id": 400789411,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1699379533
    },
    {
        "content": "<p>It'd be neat if <code>cases</code>/<code>induction</code> had an extra clause for generalizing indices (maybe you give the names of the new variables and the names of their equalities?)</p>",
        "id": 400789535,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1699379589
    },
    {
        "content": "<p>Oh, I missed that you already mentioned <code>generalize</code> in that message, sorry.</p>",
        "id": 400789598,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1699379621
    },
    {
        "content": "<p>It seems like the behavior of <code>cases</code> could be improved here without regressing from linear time. Why couldn't it detect that <code>ctor</code> has one of these ill-behaved function application indices and then automatically call <code>generalize</code> on the term being supplied for that index?</p>",
        "id": 400817319,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1699391802
    },
    {
        "content": "<p>Doesn't sound unreasonable. I would still prefer a linter that discourages the problematic inductive type definitions, since that's the rule that Conor McBride, the inventor of the <code>cases</code> algorithm, has been advocating for since forever. (\"No green goo\" is the slogan.)</p>",
        "id": 401349497,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1699615070
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"500038\">Timo Carlin-Burns</span> <a href=\"#narrow/stream/270676-lean4/topic/Behaviour.20of.20.60cases.60.20depends.20on.20type.20constructor.20args'.20order/near/400817319\">said</a>:</p>\n<blockquote>\n<p>It seems like the behavior of <code>cases</code> could be improved here without regressing from linear time. Why couldn't it detect that <code>ctor</code> has one of these ill-behaved function application indices and then automatically call <code>generalize</code> on the term being supplied for that index?</p>\n</blockquote>\n<p>This would be equivalent to \"ignore\" instead of \"postpone\" the unsolvable unification problems, I think.</p>",
        "id": 401375068,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1699621369
    },
    {
        "content": "<p>It would also be equivalent to translating the \"problematic\" inductive types into \"non-problematic\" ones, because turning</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ctor</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">false</span>\n</code></pre></div>\n<p>into</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ctor</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">x</span> <span class=\"n\">false</span>\n</code></pre></div>\n<p>is essentially telling <code>cases</code> to \"ignore\" the unification problem <code>x =? f n</code></p>",
        "id": 401376052,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1699621613
    }
]