[
    {
        "content": "<p>How can I easily modify a value of a <code>HashMap</code> and ensure linearity of the value? </p>\n<p>Is this doing what I want?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">modify</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">HashMap</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HashMap</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">m.find</span><span class=\"bp\">?</span> <span class=\"n\">key</span> <span class=\"k\">then</span>\n    <span class=\"k\">let</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">m.insert</span> <span class=\"n\">key</span> <span class=\"o\">(</span><span class=\"n\">unsafeCast</span> <span class=\"o\">())</span> <span class=\"c1\">-- ensures linearity?</span>\n    <span class=\"n\">m.insert</span> <span class=\"n\">key</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">val</span><span class=\"o\">)</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">m</span>\n</code></pre></div>\n<p>However this is effectively doing three look-ups in the hash table which is a waste. Is there a better way?</p>",
        "id": 347259169,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1680731277
    },
    {
        "content": "<p>(<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.HashMap#doc\">docs4#Std.HashMap</a>)</p>",
        "id": 347265804,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680734776
    },
    {
        "content": "<p>I don't think any of those functions do what I'm asking for. Maybe you can put it together with functions from <code>HashMap.Impl</code> but I do not really understand the inner workings of the implementation.</p>",
        "id": 347268418,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1680736357
    },
    {
        "content": "<p>It's not currently supported. Here's a quick implementation, the real thing requires doing some proofs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.HashMap</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">`O(n)`. Replace the first entry `a', b` in the list</span>\n<span class=\"sd\">with key equal to `a` to have key `a` and value `f a' b`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">Std.AssocList.modify</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AssocList</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">AssocList</span> <span class=\"n\">α</span> <span class=\"n\">β</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span>         <span class=\"bp\">=&gt;</span> <span class=\"n\">nil</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">k</span> <span class=\"n\">v</span> <span class=\"n\">es</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">k</span> <span class=\"bp\">==</span> <span class=\"n\">a</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">true</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">k</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">es</span>\n    <span class=\"bp\">|</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cons</span> <span class=\"n\">k</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">modify</span> <span class=\"n\">a</span> <span class=\"n\">f</span> <span class=\"n\">es</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Std.HashMap</span>\n\n<span class=\"sd\">/-- Performs an in-place edit of the value, ensuring that the value is used linearly. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Imp.modify</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Imp</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Imp</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">size</span><span class=\"o\">,</span> <span class=\"n\">buckets</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">m</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdx</span> <span class=\"n\">buckets.2</span> <span class=\"o\">(</span><span class=\"n\">hash</span> <span class=\"n\">a</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">toUSize</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">bkt</span> <span class=\"o\">:=</span> <span class=\"n\">buckets.1</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">buckets</span> <span class=\"o\">:=</span> <span class=\"n\">buckets.update</span> <span class=\"n\">i</span> <span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"n\">h</span> <span class=\"c1\">-- for linearity</span>\n  <span class=\"o\">⟨</span><span class=\"n\">size</span><span class=\"o\">,</span> <span class=\"n\">buckets.update</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">bkt.modify</span> <span class=\"n\">a</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">Bucket.update_size</span> <span class=\"bp\">..</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">▸</span> <span class=\"n\">h</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Hashable</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- Performs an in-place edit of the value, ensuring that the value is used linearly. -/</span>\n<span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">modifyImpl</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">HashMap</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HashMap</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">self.1.modify</span> <span class=\"n\">a</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">lcProof</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/-- Performs an in-place edit of the value, ensuring that the value is used linearly. -/</span>\n<span class=\"kd\">@[implemented_by modifyImpl]</span>\n<span class=\"n\">opaque</span> <span class=\"n\">modify</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">HashMap</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HashMap</span> <span class=\"n\">α</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Std.HashMap</span>\n</code></pre></div>",
        "id": 347272073,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1680738499
    },
    {
        "content": "<p>Would <code>α → Option β → Option β</code> be a more sensible signature? That way you can handle removing or inserting during the update too (without computing the hash twice)</p>",
        "id": 347275155,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680740447
    },
    {
        "content": "<p>that's <code>alter</code>, it is a lot more complicated to prove</p>",
        "id": 347275217,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1680740497
    },
    {
        "content": "<p>Nice, thanks! I'm happy to use an unproven version now. Having <code>alter</code> would be also very useful.</p>",
        "id": 347277944,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1680742054
    },
    {
        "content": "<p>done in <a href=\"https://github.com/leanprover/std4/commit/ed1f8fe\">https://github.com/leanprover/std4/commit/ed1f8fe</a></p>",
        "id": 347279218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1680742709
    }
]