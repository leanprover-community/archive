[
    {
        "content": "<p>What is known about typeclass refactoring in Lean? </p>\n<p>My impression is that refactoring can be done so that users (but not makers) of a typeclass are unaffected as long as the typeclass has the same fields and implements the same preexisting superclasses. Is this a known fact about the system, or known cases where it does not hold?</p>\n<p>However, it seems that refactoring changes typeclass constructors .mk, and that this means refactoring will break code that makes a refactored class. Is this the case? Are there any workarounds (like providing custom constructors)?</p>\n<p>It looks like if <code>class C (α) extends A α</code>, one can add a new typeclass <code>class B (α) extends A α</code> and <code>instance B_of_C {α} : C α → B α</code> works to inject a class between two others; does this do the trick?</p>\n<p>Without non-breaking refactoring / additions, I would be concerned about the library becoming brittle (<a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/571066429\">ossification</a>), with early decisions being locked-in; is this happening in practice?</p>",
        "id": 571692314,
        "sender_full_name": "Pieter Collins",
        "timestamp": 1770132621
    },
    {
        "content": "<p>Haskell typeclass refactoring is breaking, which makes any refactoring of the standard library problematic. Around 2014 they were refactoring their Functor hierarchy to make Applicative a superclass of Monad. However, since users must explicitly declare instances of all superclasses, this meant a breaking change for all Monad users, and it was a big effort to phase the changes so that users could adapt code gradually; maybe they even had to change the compilers. See <a href=\"https://wiki.haskell.org/Functor-Applicative-Monad_Proposal\">https://wiki.haskell.org/Functor-Applicative-Monad_Proposal</a> for details. There were proposals for default superclass instances <a href=\"http://repetae.net/recent/out/classalias.html\">http://repetae.net/recent/out/classalias.html</a>, with an implementation in the Strathclyde Haskell Enhancement preprocessor <a href=\"https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/superclass.html\">https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/superclass.html</a>.</p>",
        "id": 571693752,
        "sender_full_name": "Pieter Collins",
        "timestamp": 1770132921
    },
    {
        "content": "<p>What is your question exactly?</p>\n<p>In the particular case of <code>Applicative</code> and <code>Monad</code>, the current design in Lean has <code>Monad</code> extend <code>Applicative</code>, but users can still declare <code>Monad</code> instances in a way that doesn't mention <code>Applicative</code>. So Lean is a lot more convenient than Haskell in that regard.</p>",
        "id": 571713803,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1770137638
    },
    {
        "content": "<p>I understand your specific question as: can we turn a <code>class C extends A</code> into <code>class C extends B</code> without breaking all <code>instance : C where ...</code> declarations? And the answer is yes (and the same holds for <code>structure</code> declarations in general), as long as the non-implicit non-autoparam fields remain the same.</p>\n<p>For implicit fields: instance synthesis and unification can be used to fill in the fields, and in particular instances often fill in the new fields in such an <code>extends</code>-based refactor.</p>\n<p>A good example of adding fields using autoparams is exponentiation in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Monoid#doc\">docs#Monoid</a>. <a href=\"https://github.com/leanprover-community/mathlib4/blob/9687699f0e8199c06fb088bac1e8a1086400082e/Mathlib/Algebra/Group/Defs.lean#L616-L624\">In the source code</a> we can see the fields are defined to have default values, but they can be overridden explicitly in specific instances, either for defeq or for optimizing the implementation.</p>",
        "id": 571862709,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1770198506
    },
    {
        "content": "<p><a href=\"https://arxiv.org/abs/2202.05360\">https://arxiv.org/abs/2202.05360</a> \"Formalized functional analysis with semilinear maps\" is a good example of a highly nontrivial factor that was performed \"in flight\" without disrupting the ecosystem significantly.</p>",
        "id": 576250645,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1772196073
    }
]