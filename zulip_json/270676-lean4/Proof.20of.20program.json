[
    {
        "content": "<p>Very locally I'm interested in proving programs. But I have no idea how to get started. Say I want to complete:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n    <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">i</span>\n  <span class=\"n\">return</span> <span class=\"n\">r</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">sum_eq</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>How do I even get started? I can guess <code>induction n</code>, but then what?</p>",
        "id": 359324593,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1684396007
    },
    {
        "content": "<p>That's false, right? <code>sum n = n</code> there.</p>",
        "id": 359324808,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684396097
    },
    {
        "content": "<p>Fixed. I changed my mind half-way through and ended up in an inconsistent state, sorry.</p>",
        "id": 359325437,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1684396319
    },
    {
        "content": "<p>I would get rid of the division, by multiplying both sides by 2 before you state anything but I can't say anything else coherent about this question</p>",
        "id": 359325693,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684396392
    },
    {
        "content": "<p>I think the crux of the question is maybe \"how do I prove things about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Range.forIn#doc\">docs4#Std.Range.forIn</a>\", which I think I've seen threads about before</p>",
        "id": 359326096,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684396526
    },
    {
        "content": "<p>See for instance <a href=\"#narrow/stream/348111-std4/topic/Proving.20theorems.20about.20monads/near/338398617\">this message by Mario</a></p>",
        "id": 359326182,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684396559
    },
    {
        "content": "<p>Yes, that's one crux. The other one is <code>let mut</code></p>",
        "id": 359326186,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1684396560
    },
    {
        "content": "<p>Your real question is how to relate sum(n+1) to sum(n) (unless there's another way?) but yeah this suddenly looks terrifying :-)</p>",
        "id": 359326247,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684396570
    },
    {
        "content": "<p>I don't think the <code>let mut</code> is a crux; if you <code>rw [sum]</code> to start the proof you see that it desugars immediately</p>",
        "id": 359326593,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684396693
    },
    {
        "content": "<p>Running <code>simp</code> then gets you to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Id.run</span> <span class=\"o\">(</span><span class=\"n\">forIn</span> <span class=\"o\">{</span> <span class=\"n\">start</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">stop</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">step</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span> <span class=\"o\">}</span> <span class=\"mi\">0</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ForInStep.yield</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>which looks in the realm of \"basic missing API for <code>forIn</code>\"</p>",
        "id": 359326766,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684396776
    },
    {
        "content": "<p>What I would do is define the function differently, as a recursive definition. Then a proof should be easier.</p>",
        "id": 359352420,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1684404736
    },
    {
        "content": "<p>I specifically don't want to write in an openly functional way.</p>",
        "id": 359354071,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1684405241
    },
    {
        "content": "<p>The question is: can you write a program normally and still prove it is correct?</p>",
        "id": 359354175,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1684405266
    },
    {
        "content": "<p>There is a paper of <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> and <span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> about proving things in Monads. One of them can probably explain (to me using mutable variables is not the <em>normal</em> way <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> ).</p>",
        "id": 359356588,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1684405942
    },
    {
        "content": "<p>mutable variables (and likely even monads) are irrelevant here, consider</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sum</span> <span class=\"o\">:=</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span>\n  <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span>\n  <span class=\"n\">return</span> <span class=\"n\">r</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">sum_eq</span> <span class=\"o\">:</span> <span class=\"n\">sum</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- no problem</span>\n</code></pre></div>\n<p>The problem here is <code>Std.Range.forIn</code> not having API</p>",
        "id": 359357054,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684406090
    },
    {
        "content": "<p>Siddhartha, are sure this paper exists? I know about the great <a href=\"https://leanprover.github.io/papers/do.pdf\">https://leanprover.github.io/papers/do.pdf</a> which is mostly about writing normal programs in a functional programming language. It has a short section about proofs, but only devoted to translating between do notation and openly functional style, not directly about proving programs. Is there another paper?</p>",
        "id": 359358989,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1684406628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/Proof.20of.20program/near/359358989\">said</a>:</p>\n<blockquote>\n<p>Siddhartha, are sure this paper exists? I know about the great <a href=\"https://leanprover.github.io/papers/do.pdf\">https://leanprover.github.io/papers/do.pdf</a> which is mostly about writing normal programs in a functional programming language. It has a short section about proofs, but only devoted to translating between do notation and openly functional style, not directly about proving programs. Is there another paper?</p>\n</blockquote>\n<p>I meant that paper. I had wrongly assumed that it had such proofs.</p>",
        "id": 359360451,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1684407013
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I proved a few <code>forIn</code> lemmas to make some progress here.</p>\n<p>All that's left is this theorem about natural numbers, and it's sort of gross because the loop is summing upwards rather than downwards:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">main</span> <span class=\"o\">:</span>\n    <span class=\"n\">acc</span> <span class=\"bp\">+</span> <span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">start</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span>\n    <span class=\"n\">acc</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">start</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n    <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">i</span>\n  <span class=\"n\">return</span> <span class=\"n\">r</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">forIn_thms</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">forIn_range_done1</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">ForInStep</span> <span class=\"n\">β</span><span class=\"o\">)}</span>\n    <span class=\"o\">{</span><span class=\"n\">fuel</span> <span class=\"n\">start</span> <span class=\"n\">stop</span> <span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">stop</span> <span class=\"bp\">≤</span> <span class=\"n\">start</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Std.Range.forIn.loop</span> <span class=\"n\">f</span> <span class=\"n\">fuel</span> <span class=\"n\">start</span> <span class=\"n\">stop</span> <span class=\"n\">step</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">pure</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">fuel</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Std.Range.forIn.loop</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">forIn_range_fuel_boost1</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">ForInStep</span> <span class=\"n\">β</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">fuel</span> <span class=\"n\">start</span> <span class=\"n\">stop</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">stop</span> <span class=\"bp\">≤</span> <span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"n\">fuel</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Std.Range.forIn.loop</span> <span class=\"n\">f</span> <span class=\"n\">fuel</span> <span class=\"n\">start</span> <span class=\"n\">stop</span> <span class=\"mi\">1</span> <span class=\"n\">b</span> <span class=\"bp\">=</span>\n      <span class=\"n\">Std.Range.forIn.loop</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">fuel</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">start</span> <span class=\"n\">stop</span> <span class=\"mi\">1</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">fuel</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hf</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">forIn_range_done1</span> <span class=\"n\">hf</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">fuel</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_assoc</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_comm</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Nat.add_assoc</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Std.Range.forIn.loop</span><span class=\"o\">]</span>\n    <span class=\"n\">congr</span><span class=\"bp\">!</span> <span class=\"mi\">5</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"n\">h'</span> <span class=\"n\">s</span> <span class=\"n\">b'</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h'</span>\n    <span class=\"k\">have</span> <span class=\"n\">hf'</span> <span class=\"o\">:</span> <span class=\"n\">stop</span> <span class=\"bp\">≤</span> <span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">fuel</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_assoc</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_comm</span> <span class=\"mi\">1</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">forIn_range_fuel_boost1</span> <span class=\"n\">f</span> <span class=\"n\">fuel</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">stop</span> <span class=\"n\">n</span> <span class=\"n\">b'</span> <span class=\"n\">hf'</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">forIn_range_1_aux</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">ForInStep</span> <span class=\"n\">β</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">fuel</span> <span class=\"n\">start</span> <span class=\"n\">stop</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">stop</span> <span class=\"bp\">≤</span> <span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"n\">fuel</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">Std.Range.forIn.loop</span> <span class=\"n\">f</span> <span class=\"n\">fuel</span> <span class=\"n\">start</span> <span class=\"n\">stop</span> <span class=\"mi\">1</span> <span class=\"n\">b</span> <span class=\"bp\">=</span>\n    <span class=\"k\">if</span> <span class=\"n\">start</span> <span class=\"bp\">&lt;</span> <span class=\"n\">stop</span> <span class=\"k\">then</span>\n      <span class=\"n\">f</span> <span class=\"n\">start</span> <span class=\"n\">b</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"k\">fun</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">match</span> <span class=\"n\">r</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">ForInStep.done</span> <span class=\"n\">b</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">b</span>\n      <span class=\"bp\">|</span> <span class=\"n\">ForInStep.yield</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Std.Range.forIn.loop</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">fuel</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">stop</span> <span class=\"mi\">1</span> <span class=\"n\">b</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">pure</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">split</span>\n  <span class=\"n\">next</span> <span class=\"n\">h'</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">cases</span> <span class=\"n\">fuel</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n      <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">trans</span> <span class=\"n\">h</span> <span class=\"n\">h'</span>\n      <span class=\"n\">exact</span> <span class=\"n\">False.elim</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Nat.lt_le_antisymm</span> <span class=\"n\">h'</span> <span class=\"n\">h</span>\n    <span class=\"n\">next</span> <span class=\"n\">fuel</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Std.Range.forIn.loop</span><span class=\"o\">]</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">start</span> <span class=\"bp\">≥</span> <span class=\"n\">stop</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h'</span><span class=\"o\">]</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n      <span class=\"n\">rfl</span>\n  <span class=\"n\">next</span> <span class=\"n\">h'</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h'</span>\n    <span class=\"n\">cases</span> <span class=\"n\">fuel</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Std.Range.forIn.loop</span><span class=\"o\">]</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h'</span><span class=\"o\">]</span>\n    <span class=\"n\">next</span> <span class=\"n\">fuel</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Std.Range.forIn.loop</span><span class=\"o\">]</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h'</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">forIn_range_1</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">ForInStep</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">forIn</span> <span class=\"o\">[</span><span class=\"n\">start</span><span class=\"o\">:</span><span class=\"n\">stop</span><span class=\"o\">]</span> <span class=\"n\">b</span> <span class=\"n\">f</span> <span class=\"bp\">=</span>\n      <span class=\"k\">if</span> <span class=\"n\">start</span> <span class=\"bp\">&lt;</span> <span class=\"n\">stop</span> <span class=\"k\">then</span>\n        <span class=\"n\">f</span> <span class=\"n\">start</span> <span class=\"n\">b</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"k\">fun</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">match</span> <span class=\"n\">r</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"n\">ForInStep.done</span> <span class=\"n\">b</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">b</span>\n        <span class=\"bp\">|</span> <span class=\"n\">ForInStep.yield</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">forIn</span> <span class=\"o\">[</span><span class=\"n\">start</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">stop</span><span class=\"o\">]</span> <span class=\"n\">b</span> <span class=\"n\">f</span>\n      <span class=\"k\">else</span>\n        <span class=\"n\">pure</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">forIn</span><span class=\"o\">,</span> <span class=\"n\">Std.Range.forIn</span><span class=\"o\">]</span>\n  <span class=\"n\">split</span>\n  <span class=\"n\">next</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">forIn_range_1_aux</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">stop</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">stop</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">stop</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n    <span class=\"n\">congr</span><span class=\"bp\">!</span> <span class=\"mi\">4</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">forIn_range_fuel_boost1</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">stop</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">stop</span> <span class=\"mi\">1</span><span class=\"o\">]</span>\n      <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n      <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_assoc</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_comm</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">this</span><span class=\"o\">]</span>\n        <span class=\"n\">simp</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n  <span class=\"n\">next</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">forIn_range_done1</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">forIn_range'</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">ForInStep</span> <span class=\"n\">β</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">start</span> <span class=\"bp\">&lt;</span> <span class=\"n\">stop</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">forIn</span> <span class=\"o\">[</span><span class=\"n\">start</span><span class=\"o\">:</span><span class=\"n\">stop</span><span class=\"o\">]</span> <span class=\"n\">b</span> <span class=\"n\">f</span> <span class=\"bp\">=</span>\n      <span class=\"n\">f</span> <span class=\"n\">start</span> <span class=\"n\">b</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"k\">fun</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">match</span> <span class=\"n\">r</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">ForInStep.done</span> <span class=\"n\">b</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">b</span>\n      <span class=\"bp\">|</span> <span class=\"n\">ForInStep.yield</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">forIn</span> <span class=\"o\">[</span><span class=\"n\">start</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">stop</span><span class=\"o\">]</span> <span class=\"n\">b</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">forIn_range_1</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">forIn_thms</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">main</span> <span class=\"o\">:</span>\n    <span class=\"n\">acc</span> <span class=\"bp\">+</span> <span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">start</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span>\n    <span class=\"n\">acc</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">start</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">sum_eq_aux</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">start</span> <span class=\"n\">acc</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Id.run</span> <span class=\"o\">(</span><span class=\"n\">forIn</span> <span class=\"o\">[</span><span class=\"n\">start</span> <span class=\"o\">:</span> <span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">acc</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">r</span> <span class=\"bp\">↦</span> <span class=\"n\">ForInStep.yield</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n      <span class=\"n\">acc</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">start</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">forIn_range_1</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">forIn_range'</span><span class=\"o\">]</span>\n    <span class=\"n\">case</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n    <span class=\"n\">simp</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">add_assoc</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sum_eq_aux</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ge_iff_le</span><span class=\"o\">,</span> <span class=\"n\">Nat.succ_add_sub_one</span><span class=\"o\">,</span> <span class=\"n\">add_le_iff_nonpos_left</span><span class=\"o\">,</span> <span class=\"n\">nonpos_iff_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">add_tsub_cancel_right</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"n\">main</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">sum_eq</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sum</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">sum_eq_aux</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">Nat.mul_comm</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 359369327,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684409471
    },
    {
        "content": "<p>The mathlib <code>congr!</code> tactic is pretty good at descending into equalities between monad expressions, ifs, and lambdas, and this is used a couple of times here.</p>",
        "id": 359369610,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684409568
    },
    {
        "content": "<p>Thanks a lot Kyle!</p>",
        "id": 359375172,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1684411131
    },
    {
        "content": "<p>I think generally speaking a theorem of the form</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n  <span class=\"n\">action</span>\n</code></pre></div>\n<p>is eqiuvalent to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">action</span>\n<span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">n</span><span class=\"o\">]</span>\n  <span class=\"n\">action</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n  <span class=\"n\">action</span>\n</code></pre></div>\n<p>is equivalent to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">for</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">n</span><span class=\"o\">]</span>\n   <span class=\"n\">action</span>\n<span class=\"n\">action</span>\n</code></pre></div>\n<p>unfolded to the <code>forIn</code> definition of Std.Range could ease these proofs a lot.</p>",
        "id": 359376354,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1684411432
    },
    {
        "content": "<p>Hm, actually that theorem doesnt hold if action as a break  /o\\</p>",
        "id": 359376627,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1684411483
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> Are you suggesting something that's different from, for example, <code>forIn_range'</code>?</p>",
        "id": 359381266,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684412672
    },
    {
        "content": "<p>Most of the complexity is from reasoning about the <code>fuel</code> after you unfold the <code>forIn</code> definition.</p>",
        "id": 359381344,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684412699
    },
    {
        "content": "<p>Regarding inducting on the <code>stop</code>, I was thinking about how to formulate that, but you need a version of <code>forIn</code> that catches when there's a break to make it easy to state (I guess like Python's <code>for ... else ...</code> loops)</p>",
        "id": 359381549,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684412759
    },
    {
        "content": "<p>Wow so this is crazy complicated compared to the inductive def of sum. Even the statements are kinda awful. If you multiply both sides by 2 then <code>main</code> is just <code>ring</code>, you've moved the division difficulties elsewhere (but they're not hard to solve here I guess).</p>",
        "id": 359383642,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684413298
    },
    {
        "content": "<p>Kevin, this really isn't about Nat division this time. I simply tried to get a program that does something small but non-zero. In my real example there is no Nat division.</p>",
        "id": 359385623,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1684413840
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> If Lean has the ability to write imperative programs like this, then I think we should be able to prove things about them. This is a pretty standard program to compute triangle numbers, and you shouldn't have to change the program just because it's not mathematically the most convenient.</p>\n<p>That goal isn't hard to prove, though it's not the most fun. Here's something without thinking too hard:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">key'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">∣</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Int.dvd_iff_emod_eq_zero</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Int.even_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Int.even_mul_succ_self</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">key</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">qify</span> <span class=\"o\">[</span><span class=\"n\">key'</span> <span class=\"n\">n</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Int.cast_div</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">ring</span>\n  <span class=\"n\">apply</span> <span class=\"n\">key'</span>\n  <span class=\"n\">norm_num</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">key''</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">c</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_succ</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">main</span> <span class=\"o\">:</span>\n    <span class=\"n\">acc</span> <span class=\"bp\">+</span> <span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">start</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span>\n    <span class=\"n\">acc</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">start</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">start</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n  <span class=\"n\">next</span> <span class=\"n\">start</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.succ_eq_add_one</span><span class=\"o\">]</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">key</span> <span class=\"n\">start</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_assoc</span> <span class=\"n\">_</span> <span class=\"n\">start</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_assoc</span> <span class=\"n\">acc</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)]</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">key''</span><span class=\"o\">]</span>\n    <span class=\"n\">ring_nf</span>\n    <span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 359392047,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684415385
    },
    {
        "content": "<p>I'm sure the proofs of <code>sum_eq</code>, <code>sum_eq_aux</code>, and <code>main</code> could be improved, but they're not so long that it suggests that it's practically impossible to prove things about <code>for</code></p>",
        "id": 359392690,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684415552
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Proof.20of.20program/near/359326182\">said</a>:</p>\n<blockquote>\n<p>See for instance <a href=\"#narrow/stream/348111-std4/topic/Proving.20theorems.20about.20monads/near/338398617\">this message by Mario</a></p>\n</blockquote>\n<p>One suggestion in this thread was to redefine <code>forIn</code> to avoid a <code>fuel</code> argument, because then we get useful equation lemmas</p>",
        "id": 359403905,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684418141
    },
    {
        "content": "<p>(with the speculation being that it only exists in the first place because <code>termination_by</code> didn't exist yet)</p>",
        "id": 359404121,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684418175
    },
    {
        "content": "<p>I did write some API for dealing with these loops, including a bind-like operator <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ForInStep.bind#doc\">docs4#ForInStep.bind</a> like Kyle suggested, but I was mainly aiming for for loops over lists, not <code>Range</code>.</p>",
        "id": 359422026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684422400
    },
    {
        "content": "<p>see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.forIn_eq_bindList#doc\">docs4#List.forIn_eq_bindList</a></p>",
        "id": 359422713,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684422545
    },
    {
        "content": "<p>It looks like this is again relating <code>forIn</code> with functional stuff, but surely this isn't how we hope that proofs of programs in Lean 4 will look like, right? I guess we want tactics generating goals where the local context is the same as what you see inside the loop while programming, without seeing any <code>forIn</code> or monadic stuff, right? I'm aware this is a very vague specification, but does it make some sense?</p>",
        "id": 359423488,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1684422737
    },
    {
        "content": "<p>Sure, that is definitely on the agenda (we have been holding some meetings at CMU on this topic). It's a major endeavor though, and not likely to seamlessly interact with do notation as it currently exists (which was quite clearly not written with proving in mind). The approach Std is taking is much more pragmatic and similar to where other such goals pop up in mathlib: break everything down into functional stuff and have lemmas for everything</p>",
        "id": 359428564,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684423974
    },
    {
        "content": "<p>The proofs in the do paper were based on <code>forM</code> plus exception monads, not <code>forIn</code> (because they use a different implementation of do notation) <a href=\"https://kha.github.io/do-supplement/For.lean.html\">https://kha.github.io/do-supplement/For.lean.html</a></p>",
        "id": 359442144,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1684427188
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Proof.20of.20program/near/359428564\">said</a>:</p>\n<blockquote>\n<p>Sure, that is definitely on the agenda (we have been holding some meetings at CMU on this topic). It's a major endeavor though, and not likely to seamlessly interact with do notation as it currently exists (which was quite clearly not written with proving in mind). The approach Std is taking is much more pragmatic and similar to where other such goals pop up in mathlib: break everything down into functional stuff and have lemmas for everything</p>\n</blockquote>\n<p>How do we get this for our programs?</p>",
        "id": 359448085,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1684428842
    },
    {
        "content": "<p>what do you mean?</p>",
        "id": 359448430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684428936
    },
    {
        "content": "<p>How do we automatically convert our imperative programs to functional versions?</p>",
        "id": 359450733,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1684429456
    },
    {
        "content": "<p>I think Std's approach is that there is a team of volunteers that do it (unless you're asking what they're talking about at the meetings)</p>",
        "id": 359451693,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684429708
    },
    {
        "content": "<p><del>delete previous message</del> okay so it is done by hand. I am curious to know what the solutions are, as discussed in these meetings of course.</p>",
        "id": 359452729,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1684429980
    },
    {
        "content": "<p>the meetings are about the kind of thing Patrick was talking about: having a fancy proof context which works with the imperative program, in a style similar to dafny. One thing I can say is that it would almost certainly be an alternative to the do notation, not a proof about it</p>",
        "id": 359458601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684431549
    },
    {
        "content": "<p>It is still very much in the design stage though, if you want to prove things about do notation programs you have to do it the old fashioned way</p>",
        "id": 359458982,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684431660
    },
    {
        "content": "<p>The idea is to modify the \"do unchained\" approach and devise syntax so that there are places to write loop invariants and proofs. Ideally, the proofs can be filled in automatically, making Lean look more like Dafny or Why3 or F* in that sense. But users will also be able to write interactive proofs by hand. </p>\n<p>There is a toy proof-of-concept example here: <a href=\"https://github.com/avigad/verification_demo/blob/main/Demo/Demo.lean#L94-L103\">https://github.com/avigad/verification_demo/blob/main/Demo/Demo.lean#L94-L103</a>.</p>",
        "id": 359459569,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1684431813
    },
    {
        "content": "<p>With some new theorems in Std, the proof is now down to this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.Range.Lemmas</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Data.List.Lemmas</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n    <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">i</span>\n  <span class=\"n\">return</span> <span class=\"n\">r</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">sum_eq</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">suffices</span> <span class=\"bp\">∀</span> <span class=\"n\">l</span> <span class=\"n\">i</span> <span class=\"n\">acc</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">l</span> <span class=\"bp\">+</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">acc</span> <span class=\"bp\">→</span>\n      <span class=\"n\">Id.run</span> <span class=\"o\">(</span><span class=\"n\">forIn</span> <span class=\"o\">(</span><span class=\"n\">List.range'</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"n\">acc</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">yield</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">→</span>\n      <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">r</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sum</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Std.Range.forIn_eq_forIn_range'</span><span class=\"o\">,</span> <span class=\"n\">Std.Range.numElems_step_1</span><span class=\"o\">]</span>\n    <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">Nat.div_eq_of_eq_mul_right</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">intro</span> <span class=\"n\">l</span> <span class=\"n\">i</span> <span class=\"n\">acc</span> <span class=\"n\">r</span> <span class=\"n\">e</span> <span class=\"n\">ih</span> <span class=\"n\">hr</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"n\">generalizing</span> <span class=\"n\">i</span> <span class=\"n\">acc</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hr</span><span class=\"o\">,</span> <span class=\"n\">Id.run</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">next</span> <span class=\"n\">l</span> <span class=\"n\">IH</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.succ_add</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">e</span>\n    <span class=\"n\">refine</span> <span class=\"n\">IH</span> <span class=\"n\">i.succ</span> <span class=\"n\">_</span> <span class=\"n\">e</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"n\">hr</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.mul_add</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Nat.add_mul</span><span class=\"o\">,</span> <span class=\"n\">Nat.mul_comm</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>You can probably golf it some more using mathlib stuff</p>",
        "id": 359503122,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684446134
    },
    {
        "content": "<p>Great! Could you also do the <code>forIn'</code> versions?</p>",
        "id": 359570625,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1684483089
    },
    {
        "content": "<p>I am interested in working towards a solution to this problem because this will make algorithmic verification so much less painful than it is (even in the isabelle world).</p>",
        "id": 359650939,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1684500812
    },
    {
        "content": "<p>my initial idea was to replace all the loops with folds, because they seem like a general way to represent what loops seem to be doing (fold on a list that carries the relevant program state).</p>",
        "id": 359654508,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1684501493
    },
    {
        "content": "<p>I don't have a proof that it works in all cases.  The idea is based on how <code>forM_</code> and <code>mapM_</code> work in haskell</p>",
        "id": 359655802,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1684501739
    },
    {
        "content": "<p><code>forIn</code>, which the <code>for</code> syntax sugar boils down to, is just a monadic fold. It's a slight generalisation of <code>foldlM</code> that also allows early exit.</p>",
        "id": 359658275,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1684502215
    },
    {
        "content": "<p>The lean version is. But foldl doesn't need to be defined monadically</p>",
        "id": 359661115,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1684502789
    },
    {
        "content": "<p>In that case I don't understand the idea. Do you intend to convert the monadic folds to non-monadic ones?</p>",
        "id": 359674793,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1684505667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/270676-lean4/topic/Proof.20of.20program/near/359674793\">said</a>:</p>\n<blockquote>\n<p>In that case I don't understand the idea. Do you intend to convert the monadic folds to non-monadic ones?</p>\n</blockquote>\n<p>It was an initial idea. I essentially rewrote my own list so that Lean doesn't use some <code>Lean.Internal.coeM</code>  and I wrote my fold operation on it. Now I am trying to write an induction rule on this version of fold</p>",
        "id": 359676451,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1684505982
    },
    {
        "content": "<blockquote>\n<p>I essentially rewrote my own list</p>\n</blockquote>\n<p>Don't reinvent <code>List</code>, it will multiply your work 10x. There is a reason String and Array both use <code>List</code> for the model instead of reimplementing it, it has a huge API, convenient recursion principles and a lot of lemmas.</p>",
        "id": 359719741,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684515602
    }
]