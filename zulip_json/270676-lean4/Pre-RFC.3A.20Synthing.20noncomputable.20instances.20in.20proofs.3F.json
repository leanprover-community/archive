[
    {
        "content": "<p>Some instances, like <code>Classical.propDecidable</code> or <code>Fintype.ofFinite</code>, noncomputably create data: this makes them unacceptable in defs and type signatures, but they <em>are</em> acceptable within proofs.</p>\n<p>We seem to work around this in an ad-hoc way, by e.g. using the scoping tactic <code>classical</code>, term-mode <code>open scoped Classical in</code>, or asking the user to <code>have</code> the instance in manually (<code>Fintype.ofFinite</code> is not an <code>instance</code>, just a <code>def</code> you can <code>have</code> into the local context).</p>\n<p>In principle, though: we <em>could</em> try to keep track of whether we are in a proof/noncomputable context in the <code>TermElabM</code> or <code>MetaM</code> context. We could then tag \"proof-only\" instances, and have typeclass synthesis only use them when the flag is passed or set.</p>\n<p>This would mean we'd no longer need things like <code>classical</code> or <code>have := Fintype.ofFinite</code> to make the instances available; the instances would be usable within proofs automatically (and, by default, <em>not</em> available in type signatures or outside of proofs).</p>\n<p>One challenge would be that we'd need to pin down when exactly we want to consider ourselves \"within a proof\". My first thought is simply when inside of something like a <code>theorem</code> declaration body, so that it's predictable (or by manually setting it). (This lets us avoid worrying about metavariable assignment times and such if we were to take a <code>Prop</code>-expected-type approach.)</p>\n<p>So, one approach would be setting up this flag in three places:</p>\n<ul>\n<li>add a flag to the appropriate monad's context which signals being in a \"noncomputable elaboration context\" (like a theorem body), and turn it on in appropriate places</li>\n<li>record a flag for instances saying whether they're \"proof-only\"</li>\n<li>handle the (ambient) flag in typeclass synthesis to make it include or exclude such instances from the search</li>\n</ul>\n<p>Some questions:</p>\n<p>Are there other cases where \"knowing whether we're elaborating something noncomputable\" is useful? Instance synthesis is the motivation, but it seems plausible that this information could be useful in other situations.</p>\n<p>Would there be any major drawbacks or hurdles, e.g. cases where this would systematically be \"the wrong thing to do\", and we'd have to manually set the flag?</p>\n<p>Just wondering if this is worth exploring. :)</p>",
        "id": 558711982,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763745044
    },
    {
        "content": "<p>Let me ask the dreaded question first: is this change a good idea?</p>\n<p>I'm not sure. I also like that opting into classical logic is explicit (though this is not a strong opinion).<br>\nAt the same time, I agree that starting a proof, realising you want to add <code>classical</code> and manually doing so breaks the loop. (And leads to not-as-experience users writing <code>have := Classical.propDecidable</code> and somesuch manually; I've cleaned up several such instances in the Carleson project.)</p>\n<p>What do you think about a try this suggestion instead: if we're inside a proof, we need a classical instance and don't have one, have the error message contain a suggestion to use <code>classical</code>. This hopefully keeps friction relatively low, but keeps the current property \"you can see where it is used\".</p>",
        "id": 558753001,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1763760057
    },
    {
        "content": "<p>Hmm, so to be clear, this would be more or less the same change under the hood--i.e. we would have proof-only instances, typeclass synthesis would try them in proofs--but if typeclass synthesis failed, it would retry with proof-only instances activated, and if successful, make a try-this suggestion?</p>",
        "id": 558754378,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763760746
    },
    {
        "content": "<p>(Perhaps only retrying if the right kind of instances were not found.)</p>",
        "id": 558754490,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1763760802
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/channel/270676-lean4/topic/Pre-RFC.3A.20Synthing.20noncomputable.20instances.20in.20proofs.3F/near/558753001\">said</a>:</p>\n<blockquote>\n<p>I also like that opting into classical logic is explicit</p>\n</blockquote>\n<p>Minor point: <em>is</em> it explicit, though? <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> <code>by_cases</code> introduces classicality silently, for example. I wonder if anything else does.</p>",
        "id": 558754577,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763760841
    },
    {
        "content": "<p>My impression along those lines has been that Lean is intended to be a classical language when it comes to proofs, and that maybe we should embrace this and instead mark opting <em>out</em> explicitly, since it's not clear (to me!) how one could actually <em>use</em> constructivity of proofs in Lean's proofs, given proof irrelevance.</p>",
        "id": 558754957,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763761017
    },
    {
        "content": "<p>(I'm imagining that with the original \"it just works\" approach, one could use an elaborator like <code>constructive%</code> to unset the flag and opt out.)</p>",
        "id": 558755080,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763761084
    },
    {
        "content": "<p>But, in any case, since the infrastructure largely overlaps, maybe we can walk this question back to simply \"is at least one of these options worth exploring?\" :)</p>",
        "id": 558755382,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763761251
    }
]