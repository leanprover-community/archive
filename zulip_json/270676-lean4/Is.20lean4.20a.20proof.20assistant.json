[
    {
        "content": "<p>Hello.</p>\n<p>I made a theorem demontration for the purpose of my blog at: <a href=\"https://gogo2464.github.io/gogo-s-blog-cpe/from-0-to-crypto-by-projects/episode-2-proof-demonstration/\">https://gogo2464.github.io/gogo-s-blog-cpe/from-0-to-crypto-by-projects/episode-2-proof-demonstration/</a></p>\n<p>I want to ensure my theorem is correct Nobody wants to read it. Does lean4 answers to my needs please? I never ever used any proof assistant. I do not know if a proof assistant solves my issue actually.</p>",
        "id": 505716504,
        "sender_full_name": "Damien Carré",
        "timestamp": 1741969410
    },
    {
        "content": "<blockquote>\n<p>Is lean4 a proof assistant</p>\n</blockquote>\n<p>Yes, famously so.</p>\n<blockquote>\n<p>I want to ensure my theorem is correct Nobody wants to read it. Does lean4 answers to my needs please?</p>\n</blockquote>\n<p>Now that depends on your needs. Formalizing a proof in Lean is a good way to check if it's correct, but that does not immediately mean that people would like to read your work. The later also requires your work to be readable and interesting.</p>",
        "id": 505740133,
        "sender_full_name": "suhr",
        "timestamp": 1741976034
    },
    {
        "content": "<p>Maybe I should use coq or Isabelle</p>",
        "id": 505754772,
        "sender_full_name": "Damien Carré",
        "timestamp": 1741981382
    },
    {
        "content": "<p>You can, but the situation will be the same. Except in Lean you have Mathlib, which is a very good library of formalized mathematics.</p>\n<p>Lean is also easier to learn: it has better tooling, better tutorials and more active community.</p>",
        "id": 505757643,
        "sender_full_name": "suhr",
        "timestamp": 1741982594
    },
    {
        "content": "<p>Glancing at your blog post - If your central claim is \"I have an efficient algorithm to break a cryptographic hash\", then there are three main things to be aware of:</p>\n<ul>\n<li>(1) You should implement your algorithm. If you have a program (say, in Python or C) that can reverse the hash, that's already an excellent \"proof\". Find a string that gives the hash 0x123456789: this would be hard in general, so if you find such a string (like, \"look! the string '29uojvinsdjkfgn1ar' gives that hash of 0x12356789\") then that's good evidence you do in fact have such an algorithm.</li>\n<li>(2) Breaking cryptographic hashes is, in general, very hard. Or at least, it should be. Some hashes are <em>not</em> designed to be cryptographically secure (they're just fast and pseudorandom).</li>\n<li>(3) If the hash is supposed to be hard to break, then people will be skeptical of your claim; but because of (1), you can very easily given a simple proof; so if you <em>don't</em> do (1) and give people a clear example, they just won't believe you.</li>\n</ul>\n<p>I don't now what the Cisco Vigenere hash is. If it's supposed to be cryptographically secure, you should start by trying to write an actual cracking program of your idea. If it's not supposed to be cryptographically secure, it might simply be that people aren't surprised or interested to hear that you broke it.</p>\n<p>Anyway, the point: start by writing an implementation and getting a proof of concept! That's the best proof you'll get for sure!</p>",
        "id": 505804056,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742009736
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span> </p>\n<p>I have already reversed the hash in C++. cisco hash is a PROPRIETARY algorithm.</p>\n<p>It has already broken. The break has been tested over 5 times on my github unit testing: <a href=\"https://gogo2464.github.io/gogo-s-blog-cpe/from-0-to-buffer-overflow-by-projects/episode-2-guessing-source-code-reverse-engineering-program/\">https://gogo2464.github.io/gogo-s-blog-cpe/from-0-to-buffer-overflow-by-projects/episode-2-guessing-source-code-reverse-engineering-program/</a></p>",
        "id": 505823968,
        "sender_full_name": "Damien Carré",
        "timestamp": 1742026667
    },
    {
        "content": "<p>I see, ok! Well, it sounds like you reverse engineered it, found it was a fairly simple hash to invert, and broke it. Not knowing anything about Packet Tracer, it's hard to quickly see what the impact of this is. What is this hash used for? What are the security consequences of inverting it?</p>",
        "id": 505988079,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742153244
    },
    {
        "content": "<p>You call it \"Vigenere Cisco\", but that doesn't seem to be a standard name. If you think this was an <em>interesting fun project</em> in reverse engineering, then I would call it a day and be satisfied. If you think this is a <em>meaningful flaw in some Cisco software</em>, then you should alert people; filing a report on some bug tracker would be appropriate.</p>\n<p>I don't think anyone will reasonably question the fact that the hash is broken - it sounds clear - a mathematical proof won't get you anything extra. I would write something like this in a CVE report:</p>\n<blockquote>\n<p>The hashing algorithm used in Cisco's Packet Tracer software for xxxxx seems to be a weak, handrolled hashing function that's trivial to invert. This means that xxxxxx is less secure. It is possible that the same hashing algorithm would be used in related Cisco products like xxxxxxxx. I think Cisco should switch to a secure hasing algorithm such as SHA256 and update this in the next version of Packet Tracker.</p>\n</blockquote>",
        "id": 505988404,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742153485
    },
    {
        "content": "<p>Yes i did :). the impact is low. If i have remote access to a router i coild read passwords hashed in type7. It is all.</p>",
        "id": 506577067,
        "sender_full_name": "Damien Carré",
        "timestamp": 1742330713
    },
    {
        "content": "<p>It is the name according to cisco doc.</p>\n<p>The hash is disrecommended since 50 yo then it sounds ok.</p>\n<p>If you want to find 0days, you can search for proprietary algos. Sounds impossible as nobodu redo custom algos but actually some do it in cryptocurrencies!!</p>",
        "id": 506577690,
        "sender_full_name": "Damien Carré",
        "timestamp": 1742330952
    },
    {
        "content": "<p>for your information, custom crypto come back more often than I thank <a href=\"https://github.com/mit-dci/tangled-curl/blob/master/vuln-iota.md#2-disclosure-timeline\">https://github.com/mit-dci/tangled-curl/blob/master/vuln-iota.md#2-disclosure-timeline</a></p>",
        "id": 506578631,
        "sender_full_name": "Damien Carré",
        "timestamp": 1742331308
    },
    {
        "content": "<p>do you want to look for custom crypto?</p>",
        "id": 506579216,
        "sender_full_name": "Damien Carré",
        "timestamp": 1742331454
    }
]