[
    {
        "content": "<p>Consider </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">ToString</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ToString</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Action</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">reject</span><span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Action</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">accepted</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Action</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">replaced</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\">  </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Action</span>\n<span class=\"w\"> </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n</code></pre></div>\n<p>when I tried</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToString</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Action</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\"> </span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">|&gt;</span><span class=\"w\"> </span><span class=\"n\">toString</span>\n</code></pre></div>\n<p>and I got</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">synthesize</span>\n<span class=\"w\">  </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Action</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I didn't get any info about the missing instances of <code>Repr</code> for <code>α</code> and <code>β</code></p>",
        "id": 526108571,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1751038158
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToString</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Action</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\"> </span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">|&gt;</span><span class=\"w\"> </span><span class=\"n\">toString</span>\n</code></pre></div>\n<p>Lean can only generate a <code>Repr (Action α β)</code> instance based on <code>Repr α</code> and <code>Repr β</code> instances.</p>",
        "id": 526154274,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1751059817
    },
    {
        "content": "<p>I think the problem here is rather that you aren't being told that you might've needed <code>Repr α</code> or <code>Repr β</code>. This information can be seen indirectly through <code>set_option trace.Meta.synthInstance true</code> though</p>",
        "id": 526155103,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1751060421
    },
    {
        "content": "<p>The question is whether this is expected or not. I would expect Lean to complain about the missing [Repr α] and [Repr β] additional necessary restrictions.</p>",
        "id": 526699010,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1751414662
    },
    {
        "content": "<p>It would be nice to attribute reasons to typeclass failures, but I don't think there's any obvious algorithm for how to do it. Certainly if there's just a single instance that applies Lean could commit to it, which would help in this particular example, but in general it seems like a problem that requires designing heuristics.</p>\n<p>I remember at ICERM this year in a group with <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span>, <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>, and others trying to brainstorm possible heuristics, but I'm forgetting what we came up with.</p>",
        "id": 526699659,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751415235
    },
    {
        "content": "<p>A problem here is that typeclasses aren't <em>restrictions</em>. Typeclass synthesis is like running a Prolog program. When a Prolog program outputs no solutions, what should it say to explain why there were none?</p>",
        "id": 526699878,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751415407
    },
    {
        "content": "<p>The proposal I made was to be able to tag instances as \"structural\", with semantics:</p>\n<ul>\n<li>Perform the search the same way as we do now</li>\n<li>If no match is found, follow the largest subree of \"structural\" edges in the graph of explored instances (from the root), and then report the remaining nodes as an error to the user</li>\n</ul>",
        "id": 526702806,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1751417848
    },
    {
        "content": "<p>The instance above would be tagged in this way, as would things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod.instGroup#doc\">docs#Prod.instGroup</a></p>",
        "id": 526702880,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1751417900
    },
    {
        "content": "<p>Things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CommGroup.toGroup#doc\">docs#CommGroup.toGroup</a> would not be</p>",
        "id": 526702897,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1751417913
    },
    {
        "content": "<p>Probably you could do the majority of the tagging automatically with a heuristic of \"conclusion matches <code>Class _ _ _ (Head _ _)</code> where <code>Head</code> is a constant and not a free variable\", but I think manual tagging could go a long way</p>",
        "id": 526703068,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1751418038
    },
    {
        "content": "<p>Thanks for reminding me of the details! Now I recall there was also an idea we discussed of adding cuts that are activated during error attribution (cuts in the sense of <a href=\"https://en.wikipedia.org/wiki/Cut_(logic_programming)\">the Prolog cut operator</a>), though I don't remember if we thought that was something that would be usable, or that was a basis for implementing your idea.</p>\n<p>Maybe the heuristic for \"structural\" has something to do with instances that reflect the intuition of typeclasses-as-constraints.</p>",
        "id": 526829023,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751470092
    },
    {
        "content": "<p>In my head that cut idea is the same as the one I just described, just phrased in a different way.</p>",
        "id": 526832526,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1751471163
    }
]