[
    {
        "content": "<p>I'm starting an implementation of Edward Zalta's abstract object theory. </p>\n<p>The issue in the definition below is an error: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">kernel</span><span class=\"o\">)</span> <span class=\"n\">arg</span> <span class=\"bp\">#</span><span class=\"mi\">3</span> <span class=\"n\">of</span> <span class=\"bp\">'</span><span class=\"n\">Formula.applied'</span> <span class=\"n\">contains</span> <span class=\"n\">a</span> <span class=\"n\">non</span> <span class=\"n\">valid</span> <span class=\"n\">occurrence</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">datatypes</span> <span class=\"n\">being</span> <span class=\"n\">declared</span>\n</code></pre></div>\n<p>I guess I can't use Term as an argument to relsToTerms inside of the type definition. I don't know how to express that the terms applied to the term of an nary-relation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>:</mo><mo stretchy=\"false\">[</mo><msub><mi>r</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><msub><mi>r</mi><mi>n</mi></msub><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R: [r_1, ... r_n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">...</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> must be of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>T</mi><mi>e</mi><mi>r</mi><mi>m</mi><mtext>  </mtext><msub><mi>r</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mtext>  </mtext><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mtext>  </mtext><mo separator=\"true\">,</mo><mtext>  </mtext><mi>T</mi><mi>e</mi><mi>r</mi><mi>m</mi><mtext>  </mtext><msub><mi>r</mi><mi>n</mi></msub><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[Term \\; r_1, \\; ... \\;, \\; Term \\; r_n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">...</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span>. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Rel</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>  <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Ind</span> <span class=\"o\">:</span> <span class=\"n\">Rel</span>\n  <span class=\"bp\">|</span> <span class=\"n\">NAry</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Rel</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Rel</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n<span class=\"kn\">open</span> <span class=\"n\">Rel</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">relsToTerms</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Rel</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">rels</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Rel</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n   <span class=\"k\">match</span> <span class=\"n\">rels</span> <span class=\"k\">with</span>\n   <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PUnit</span>\n   <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">::</span> <span class=\"n\">rs</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">relsToTerms</span> <span class=\"n\">T</span> <span class=\"n\">rs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">mutual</span>\n  <span class=\"kd\">inductive</span> <span class=\"n\">Formula</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">atom</span> <span class=\"o\">:</span> <span class=\"n\">Term</span> <span class=\"o\">(</span><span class=\"n\">Rel.NAry</span> <span class=\"o\">[])</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Formula</span>\n    <span class=\"bp\">|</span> <span class=\"n\">applied</span> <span class=\"o\">:</span>\n    <span class=\"n\">Term</span> <span class=\"o\">(</span><span class=\"n\">Rel.NAry</span> <span class=\"o\">(</span><span class=\"n\">rels</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Rel</span><span class=\"o\">))</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"o\">(</span><span class=\"n\">relsToTerms</span> <span class=\"n\">Term</span> <span class=\"n\">rels</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"n\">Formula</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ifThen</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Formula</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Formula</span>\n    <span class=\"bp\">|</span> <span class=\"n\">not</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Formula</span>\n\n  <span class=\"kd\">inductive</span> <span class=\"n\">Term</span> <span class=\"o\">:</span> <span class=\"n\">Rel</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Name</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">:</span><span class=\"n\">Rel</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">String</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Term</span> <span class=\"n\">R</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Variable</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">:</span><span class=\"n\">Rel</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">String</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Term</span> <span class=\"n\">R</span>\n    <span class=\"bp\">|</span> <span class=\"n\">formulaTerm</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Term</span> <span class=\"o\">(</span><span class=\"n\">Rel.NAry</span> <span class=\"o\">[])</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 397014734,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1697511742
    },
    {
        "content": "<p>You can write it like this, assuming you intend <code>rels</code> to be an argument to <code>applied</code> (not sure what happens when you write it like you did). I just replaced your<code>relsToTerms</code> with another mutual inductive definition</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Rel</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>  <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Ind</span> <span class=\"o\">:</span> <span class=\"n\">Rel</span>\n  <span class=\"bp\">|</span> <span class=\"n\">NAry</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Rel</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Rel</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n<span class=\"kn\">open</span> <span class=\"n\">Rel</span>\n\n<span class=\"kd\">mutual</span>\n  <span class=\"kd\">inductive</span> <span class=\"n\">Formula</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">atom</span> <span class=\"o\">:</span> <span class=\"n\">Term</span> <span class=\"o\">(</span><span class=\"n\">Rel.NAry</span> <span class=\"o\">[])</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Formula</span>\n    <span class=\"bp\">|</span> <span class=\"n\">applied</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">rels</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Rel</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"n\">Term</span> <span class=\"o\">(</span><span class=\"n\">Rel.NAry</span> <span class=\"n\">rels</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"o\">(</span><span class=\"n\">TermList</span> <span class=\"n\">rels</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"n\">Formula</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ifThen</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Formula</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Formula</span>\n    <span class=\"bp\">|</span> <span class=\"n\">not</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Formula</span>\n\n  <span class=\"kd\">inductive</span> <span class=\"n\">Term</span> <span class=\"o\">:</span> <span class=\"n\">Rel</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Name</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">:</span><span class=\"n\">Rel</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">String</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Term</span> <span class=\"n\">R</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Variable</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">:</span><span class=\"n\">Rel</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">String</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Term</span> <span class=\"n\">R</span>\n    <span class=\"bp\">|</span> <span class=\"n\">formulaTerm</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Term</span> <span class=\"o\">(</span><span class=\"n\">Rel.NAry</span> <span class=\"o\">[])</span>\n\n  <span class=\"kd\">inductive</span> <span class=\"n\">TermList</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Rel</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">TermList</span> <span class=\"o\">[]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Rel</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Rel</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Term</span> <span class=\"n\">r</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">TermList</span> <span class=\"n\">rs</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">TermList</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">::</span> <span class=\"n\">rs</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I don't know what kind of mutual inductive definitions are allowed by Lean, but basically what you wrote only makes sense because <code>relsToTerms</code> is in some sense positive in its <code>T</code> argument (more terms of <code>T r</code> means more terms of <code>relstoTerms T rs</code>)</p>",
        "id": 397039749,
        "sender_full_name": "David Wärn",
        "timestamp": 1697525387
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"130377\">@David Wärn</span>  This gave me exactly the direction I needed to make it work!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Rel</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>  <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Ind</span> <span class=\"o\">:</span> <span class=\"n\">Rel</span>\n  <span class=\"bp\">|</span> <span class=\"n\">NAry</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Rel</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Rel</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n<span class=\"kn\">open</span> <span class=\"n\">Rel</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">TermSyntax</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">var</span>\n<span class=\"bp\">|</span> <span class=\"n\">name</span>\n<span class=\"bp\">|</span> <span class=\"n\">abstraction</span>\n<span class=\"kn\">open</span> <span class=\"n\">TermSyntax</span>\n\n<span class=\"kd\">mutual</span>\n  <span class=\"kd\">inductive</span> <span class=\"n\">Term</span> <span class=\"o\">:</span> <span class=\"n\">Rel</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">TermSyntax</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Name</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"n\">Rel</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">String</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Term</span> <span class=\"n\">r</span> <span class=\"n\">name</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Variable</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"n\">Rel</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">String</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Term</span> <span class=\"n\">r</span> <span class=\"n\">var</span>\n    <span class=\"bp\">|</span> <span class=\"n\">abstraction</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Term</span> <span class=\"n\">relType</span> <span class=\"n\">var</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Term</span> <span class=\"n\">relType</span> <span class=\"n\">abstraction</span>\n\n\n  <span class=\"kd\">inductive</span> <span class=\"n\">Formula</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">atom</span> <span class=\"o\">:</span>   <span class=\"o\">(</span><span class=\"n\">Term</span> <span class=\"o\">(</span><span class=\"n\">NAry</span> <span class=\"o\">[])</span> <span class=\"n\">tSyn</span><span class=\"o\">)</span>  <span class=\"bp\">-&gt;</span> <span class=\"n\">Formula</span>\n    <span class=\"bp\">|</span> <span class=\"n\">applied</span> <span class=\"o\">:</span>  <span class=\"o\">(</span><span class=\"n\">rels</span><span class=\"o\">:</span> <span class=\"n\">FullList</span> <span class=\"n\">Rel</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">initialTerm</span><span class=\"o\">:</span>  <span class=\"n\">Term</span> <span class=\"o\">(</span><span class=\"n\">NAry</span> <span class=\"o\">(</span><span class=\"n\">rels.toList</span><span class=\"o\">))</span> <span class=\"n\">tSyn</span><span class=\"o\">)</span>  <span class=\"bp\">-&gt;</span>\n      <span class=\"o\">(</span><span class=\"n\">TermList</span> <span class=\"n\">rels</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Formula</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ifThen</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Formula</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Formula</span>\n    <span class=\"bp\">|</span> <span class=\"n\">not</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Formula</span>\n    <span class=\"bp\">|</span> <span class=\"n\">forAll</span> <span class=\"o\">:</span> <span class=\"n\">Formual</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Term</span> <span class=\"n\">relType</span> <span class=\"n\">var</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Formula</span>\n    <span class=\"bp\">|</span> <span class=\"n\">necessary</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Formula</span>\n\n  <span class=\"kd\">inductive</span> <span class=\"n\">TermList</span><span class=\"o\">:</span> <span class=\"n\">FullList</span> <span class=\"n\">Rel</span> <span class=\"bp\">-&gt;</span>  <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">single</span> <span class=\"o\">:</span>  <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"n\">Term</span> <span class=\"n\">r</span> <span class=\"n\">tSyn</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">TermList</span> <span class=\"o\">(</span><span class=\"n\">FullList.single</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">multi</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">rels</span><span class=\"o\">:</span> <span class=\"n\">FullList</span> <span class=\"n\">Rel</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span>  <span class=\"n\">Term</span> <span class=\"o\">(</span><span class=\"n\">rels.head</span><span class=\"o\">)</span> <span class=\"n\">tSyn</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">TermList</span> <span class=\"n\">rels.tail</span> <span class=\"bp\">-&gt;</span>  <span class=\"n\">TermList</span> <span class=\"n\">rels</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I didn't include the definition of FullList, but it's an inductive type like List except it always has at least one value. </p>\n<p>So now I've finished the easy part of describing how terms and formulas are formed. The hard part is enforcing the extra constraints on the formation and introduction. </p>\n<p>Universal quantification and abstraction both have the constraint that the variable being bound by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span></span></span></span> cannot be an \"initial\" variable. That is it cannot be a variable that binds the second argument of the <code>applied</code> term constructor.</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">R(x,y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span> can be made into <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi>R</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\lambda x. R(x,y) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">λ</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span> but not <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi><mi>R</mi><mi mathvariant=\"normal\">.</mi><mi>R</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\lambda R . R(x,y) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">λ</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span> however, if R is not initial it can be bound, e.g., where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Φ</mi></mrow><annotation encoding=\"application/x-tex\">\\Phi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Φ</span></span></span></span> is a relation from properties of individuals to individuals, the formula <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Φ</mi><mo stretchy=\"false\">(</mo><mi>R</mi><mo separator=\"true\">,</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\Phi(R, x) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Φ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> can be abstracted to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi><mi>R</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">Φ</mi><mo stretchy=\"false\">(</mo><mi>R</mi><mo separator=\"true\">,</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\lambda R . \\Phi(R,x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">λ</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">.Φ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span></p>\n<p>Ideally, I'd like to make it impossible to construct invalid abstraction terms or forall formulas. But it might be a bit heavy to include this level of logic in the type definitions (and I'm not sure how I'd even do it). Another option is to have a set of designated term factory functions which apply these extra checks. </p>\n<p>Does anybody have any ideas how to implement such constraints? Maybe there have been similar things done elsewhere.</p>\n<hr>\n<p>Update: I realized that the easiest way to implement this is just to allow the use of initial variables as parameters but not to allow substitution for initial variables when doing beta-reduction.</p>",
        "id": 397390097,
        "sender_full_name": "Avi Craimer",
        "timestamp": 1697667276
    }
]