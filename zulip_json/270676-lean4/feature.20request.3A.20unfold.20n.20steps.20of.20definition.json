[
    {
        "content": "<p>From <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/channel/113489-new-members/topic/How.20to.20determine.20the.20intended.20API.20of.20an.20object/with/536312297\">#new members &gt; How to determine the intended API of an object</a> we ran into the problem that it can be hard for a beginner to find out the underlying definition of <code>(· ≤ · : Subgroup _ → Subgroup _ → Prop)</code> (sorry for using mathlib), and I proposed a command/tactic to repeatedly unfold definition for n steps (n is numeral input)...</p>\n<p>and right in the middle of typing this I realised that maybe I can try to write the code as well</p>",
        "id": 536312276,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1756242320
    },
    {
        "content": "<p>What does \"unfold for n steps\" mean if the head symbol of the definition is not a constant?</p>",
        "id": 536313423,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1756242833
    },
    {
        "content": "<p>nothing</p>",
        "id": 536313457,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1756242852
    },
    {
        "content": "<p>Aren't you going to run into issues pretty quickly then because <code>LE.le</code> is just a projection and as such not unfoldable</p>",
        "id": 536313504,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1756242880
    },
    {
        "content": "<p>well <code>unfold LE.le</code> works</p>",
        "id": 536313523,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1756242893
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ (fun x1 x2 =&gt; CompleteLattice.toCompletePartialOrder.toLE.1 x1 x2) = sorry</span>\n</code></pre></div>",
        "id": 536313642,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1756242934
    },
    {
        "content": "<p>Yeah and now youa re left in another state where the head symbol is not a constant, so what do you want to unfold next, my point is that it's not trivial to figure out what the symbol you actually want to unfold is when you go recursively without human assistance</p>",
        "id": 536313704,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1756242964
    },
    {
        "content": "<p>the head is <code>Preorder.toLE</code> which is a constant</p>",
        "id": 536313753,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1756242991
    },
    {
        "content": "<p>oh wait, it's the .1</p>",
        "id": 536313818,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1756243021
    },
    {
        "content": "<p>Exactly^^</p>",
        "id": 536313834,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1756243029
    },
    {
        "content": "<p>but after the .1 the head is Preorder.toLE</p>",
        "id": 536313840,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1756243031
    },
    {
        "content": "<p>But Preorder.toLE is also just an abbrevation for a projection</p>",
        "id": 536313924,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1756243069
    },
    {
        "content": "<p>how would you solve this problem then?</p>",
        "id": 536313959,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1756243088
    },
    {
        "content": "<p>I don't know, that's why I asked :)</p>",
        "id": 536313975,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1756243099
    },
    {
        "content": "<p>well you can go one step deeper if you see <code>.n</code></p>",
        "id": 536314023,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1756243125
    },
    {
        "content": "<p>Sure you can try many tricks, there is also the question of what you do once there is more than one potential constant that you could unfold in your term around, do you go for all of them? just one? which one?. My point is that it is probably not easy to figure out something that will present a beginner with an output that is generally helpful, especially when there are large towers of definitions like in Mathlib that, when just naively unfolded, don't look helpful at all.</p>",
        "id": 536314589,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1756243452
    },
    {
        "content": "<p>Hmm, maybe mathlib's <code>whnf</code> tactic could take a numeric argument for how many head definition unfoldings to do. In the given example, it could be used along with <code>conv</code> mode to get into a particular position.</p>\n<p>It'll probably unfold too much still, since the projection will force unfolding, even of definitions. Plus, it won't use equation lemmas, so the results might not be good.</p>",
        "id": 536336331,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756259930
    },
    {
        "content": "<p>Something that might work as a heuristic for Kenny's idea is \"to find the next definition to unfold, take all the constants appearing in explicit arguments, and unfold the one with the largest definitional height\".</p>\n<p>\"Definitional height\" is already a heuristic used in the system. The definitional height is one more than the maximum of definitional heights of constants appearing in a declaration. (Abbreviations don't have a definitional height though. They sort of have infinite height and could be unfolded first.)</p>",
        "id": 536336968,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756260511
    }
]