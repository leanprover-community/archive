[
    {
        "content": "<p>I have a couple of teaching exercises (in a NNG-like game) about concretely defined functions and currenctly I use the following syntax for the locally defined function <code>f</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- import Mathlib  -- optional</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">f</span> <span class=\"mi\">4</span> <span class=\"bp\">=</span> <span class=\"mi\">8</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">f</span>\n  <span class=\"c1\">-- the actual exercise starts:</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I prefer this over <code>def f :=</code> because</p>\n<p>a) it's visible in the context (a player does only see the context, not the code before the exercise) and<br>\nb) it does not pollute any namespace with random defs.</p>\n<p>What I dislike is that they are forced to always enter <code>intro f</code> as a first step and until then the goal looks rather taunting.</p>\n<p>Does anybody have a better idea how I could write a statement such that the start of the proof is in a similar state to what it looks like after <code>intro f</code> currently?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">f</span> <span class=\"mi\">4</span> <span class=\"bp\">=</span> <span class=\"mi\">8</span>\n</code></pre></div>\n<p>Or maybe more concretely, what does <code>intro f</code> exactly do at this stage?</p>\n<p>Could I achieve this in meta-code since I already replaced <code>example</code> by a custom <code>elab \"Statement\" sig:declSig val:declVal : command =&gt; do _</code> which then calls <code>elabCommand</code> eventually (see <a href=\"https://github.com/leanprover-community/lean4game/blob/e07570181ce883571f5136cd0b688951a7313714/server/GameServer/Commands.lean#L380-L381\">here</a>)</p>",
        "id": 426641562,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1710455963
    },
    {
        "content": "<p>Sure, you could put your <code>intro</code> in your custom command.</p>",
        "id": 426643026,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1710456754
    },
    {
        "content": "<p>It would be nice if <code>theorem foo (x : Nat) (let f := _) (h : f x &lt; 2)</code> or similar were legal</p>",
        "id": 426643389,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710456934
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/let.20in.20statement/near/426643026\">said</a>:</p>\n<blockquote>\n<p>Sure, you could put your <code>intro</code> in your custom command.</p>\n</blockquote>\n<p>But if I dont know how many <code>let</code>s there are (0 or more) and I dont want to <code>intro</code> anything else (like a <code>\\forall</code> following the <code>let</code>), it's not quite as simple, is it?</p>",
        "id": 426644858,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1710457684
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/let.20in.20statement/near/426643389\">said</a>:</p>\n<blockquote>\n<p>It would be nice if <code>theorem foo (x : Nat) (let f := _) (h : f x &lt; 2)</code> or similar were legal</p>\n</blockquote>\n<p>Would you estimate that's something one could make legal with the required meta-coding skills?<span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 426644981,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1710457764
    },
    {
        "content": "<p>You would need a <code>intro_lets</code> tactic.</p>",
        "id": 426645304,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1710457937
    },
    {
        "content": "<p>This should be pretty easy.</p>",
        "id": 426645357,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1710457964
    },
    {
        "content": "<p>You do have a point</p>",
        "id": 426645419,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1710458009
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"385895\">Jon Eugster</span> <a href=\"#narrow/stream/270676-lean4/topic/let.20in.20statement/near/426644981\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/let.20in.20statement/near/426643389\">said</a>:</p>\n<blockquote>\n<p>It would be nice if <code>theorem foo (x : Nat) (let f := _) (h : f x &lt; 2)</code> or similar were legal</p>\n</blockquote>\n<p>Would you estimate that's something one could make legal with the required meta-coding skills?<span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>\n</blockquote>\n<p>I think this probably would be much easier as a core change; I think extending existing syntax externally is quite awkward.</p>",
        "id": 426647210,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710459058
    },
    {
        "content": "<p>It might at least be worth writing an rfc</p>",
        "id": 426647843,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710459469
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/let.20in.20statement/near/426645304\">said</a>:</p>\n<blockquote>\n<p>You would need a <code>intro_lets</code> tactic.</p>\n</blockquote>\n<p>Indeed, after realising what I need to do it wasn't that complicated:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>let_intros</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Elab.Binders</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean.Elab.Tactic.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean.Meta.Tactic.Intro</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># `let_intros` Tactic</span>\n\n<span class=\"cm\">`let_intros` is a weaker form of `intros` aimed to only introduce `let` statements,</span>\n<span class=\"cm\">but not for example `∀`-binders.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">GameServer</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Parser</span> <span class=\"n\">Tactic</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Copied from `Lean.Meta.getIntrosSize`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">private</span> <span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">getLetIntrosSize</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"c1\">-- | .forallE _ _ b _ =&gt; getLetIntrosSize b + 1</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">letE</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">b</span> <span class=\"n\">_</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">getLetIntrosSize</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">mdata</span> <span class=\"n\">_</span> <span class=\"n\">b</span>       <span class=\"bp\">=&gt;</span> <span class=\"n\">getLetIntrosSize</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">e</span>                <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">e.letFun</span><span class=\"bp\">?</span> <span class=\"k\">then</span>\n      <span class=\"n\">getLetIntrosSize</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n    <span class=\"k\">else</span>\n      <span class=\"mi\">0</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Copied and from `Lean.MVarId.intros`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">_root_.Lean.MVarId.letIntros</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">FVarId</span> <span class=\"bp\">×</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">type</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.getType</span>\n  <span class=\"k\">let</span> <span class=\"n\">type</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">type</span>\n  <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">getLetIntrosSize</span> <span class=\"n\">type</span>\n  <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">==</span> <span class=\"mi\">0</span> <span class=\"k\">then</span>\n    <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">#</span><span class=\"o\">[],</span> <span class=\"n\">mvarId</span><span class=\"o\">)</span>\n  <span class=\"k\">else</span>\n    <span class=\"c1\">-- `introNP` preserves the binder names</span>\n    <span class=\"n\">mvarId.introNP</span> <span class=\"n\">n</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">`let_intros` introduces all `let` statements that are preceeding the proof. Concretely</span>\n<span class=\"sd\">it does a subset of what `intros` does.</span>\n\n<span class=\"sd\">If names are provided, it will introduce as many `let` statements as there are names.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">letIntros</span><span class=\"o\">)</span> <span class=\"s2\">\"let_intros\"</span> <span class=\"o\">(</span><span class=\"n\">ppSpace</span> <span class=\"n\">colGt</span> <span class=\"o\">(</span><span class=\"n\">ident</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">hole</span><span class=\"o\">))</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">tactic</span> <span class=\"n\">letIntros</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">evalLetIntros</span> <span class=\"o\">:</span> <span class=\"n\">Tactic</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">let_intros</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">liftMetaTactic</span> <span class=\"k\">fun</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">mvarId</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.letIntros</span>\n    <span class=\"n\">return</span> <span class=\"o\">[</span><span class=\"n\">mvarId</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">let_intros</span> <span class=\"bp\">$</span><span class=\"n\">ids</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">fvars</span> <span class=\"bp\">←</span> <span class=\"n\">liftMetaTacticAux</span> <span class=\"k\">fun</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">fvars</span><span class=\"o\">,</span> <span class=\"n\">mvarId</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.introN</span> <span class=\"n\">ids.size</span> <span class=\"o\">(</span><span class=\"n\">ids.map</span> <span class=\"n\">getNameOfIdent'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n      <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">fvars</span><span class=\"o\">,</span> <span class=\"o\">[</span><span class=\"n\">mvarId</span><span class=\"o\">])</span>\n    <span class=\"n\">withMainContext</span> <span class=\"k\">do</span>\n      <span class=\"n\">for</span> <span class=\"n\">stx</span> <span class=\"k\">in</span> <span class=\"n\">ids</span><span class=\"o\">,</span> <span class=\"n\">fvar</span> <span class=\"k\">in</span> <span class=\"n\">fvars</span> <span class=\"k\">do</span>\n        <span class=\"n\">Term.addLocalVarInfo</span> <span class=\"n\">stx</span> <span class=\"o\">(</span><span class=\"n\">mkFVar</span> <span class=\"n\">fvar</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n</code></pre></div>\n</div></div>\n<p>This introduces all <code>let</code> statements:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n    <span class=\"k\">let</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">↦</span> <span class=\"n\">y</span>\n    <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">let_intros</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  f✝ : Nat</span>\n<span class=\"cm\">  f : Nat → Nat := fun x =&gt; x + 1</span>\n<span class=\"cm\">  g : Nat → Nat := fun y =&gt; y</span>\n<span class=\"cm\">  ⊢ ∀ (x : Nat), x ≤ f x</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Nat.le_succ</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>Thanks for the hint!</p>",
        "id": 426716220,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1710499328
    },
    {
        "content": "<p>The <code>extract_lets</code> tactic theoretically supports this, but apparently <code>extract_lets at ⊢</code> is a parse error because there are zero hypotheses. You can still use it, if you create syntax with zero hypotheses:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elab</span> <span class=\"s2\">\"let_intros\"</span> <span class=\"o\">(</span><span class=\"n\">ppSpace</span> <span class=\"n\">colGt</span> <span class=\"o\">(</span><span class=\"n\">ident</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">hole</span><span class=\"o\">))</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">Lean.Elab.Tactic.evalTactic</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">extract_lets</span> <span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">#</span><span class=\"o\">[])</span><span class=\"bp\">*</span> <span class=\"bp\">⊢</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>If you wanted to make a PR to make the <code>location</code> clause optional for <code>extract_lets</code>, then you could have <code>extract_lets</code> act just on the goal.</p>\n<p>Or maybe you could add <code>let_intros</code> to that file for acting on just the goal? The <code>extract_lets</code> command is meant to be for hypotheses anyway, and it's not a good name for acting on the goal.</p>\n<p>This is the meta implementation for acting on the goal: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.extractLets#doc\">docs#Lean.MVarId.extractLets</a> And this is the tactic driver: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.evalExtractLet#doc\">docs#Mathlib.evalExtractLet</a></p>",
        "id": 426760967,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710514703
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/11400\">#11400</a> cleans up <code>extract_lets</code>.</p>\n<p>(I don't have any opinion on the tactic naming, so I just left it as is.)</p>",
        "id": 426785544,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1710521976
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/270676-lean4/topic/let.20in.20statement/near/426643389\">said</a>:</p>\n<blockquote>\n<p>It would be nice if <code>theorem foo (x : Nat) (let f := _) (h : f x &lt; 2)</code> or similar were legal</p>\n</blockquote>\n<p>I made an RFC for this at <a href=\"https://github.com/leanprover/lean4/pull/6091\">lean4#6091</a></p>",
        "id": 482623915,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731680543
    }
]