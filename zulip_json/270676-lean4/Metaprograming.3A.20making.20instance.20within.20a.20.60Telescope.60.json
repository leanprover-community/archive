[
    {
        "content": "<p>Another minor metaprograming question (please tell me if I should be creating threads with larger scope).</p>\n<p>I'm trying to declare a command that takes in a lambda and creates an instance parametrized by those same vars. E.g. one could imagine a method</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">derive_with_params</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>that generates a command like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">myInstance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>I've been trying to do this with one big <code>lambdaTelescope</code>, but <code>CommandElabM</code> does not implement the required interface, namely <code>MonadControlT MetaM</code>. <code>Term.TermElabM</code> does, but AFAIKT this does not allow me to define a new instance in an easy way (though it is easy to lift a <code>TermElabM</code> to a <code>CommandElabM</code>).</p>\n<p>Any suggestions to get around this? Is there some way to</p>\n<p>A) Define a <code>MonadControlT MetaM</code> for <code>CommandElabM</code> or<br>\nB) Do things in a different way to avoid this issue?</p>\n<p>Thanks!</p>",
        "id": 546016325,
        "sender_full_name": "Cody Roux",
        "timestamp": 1760975000
    },
    {
        "content": "<p>Is it important for you to generate the <strong>syntax</strong> for the <code>instance</code> command? It's probably easier to directly call <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.addAndCompile#doc\">docs#Lean.addAndCompile</a>, which adds a declaration to the environment (after that you will have to add the <code>@[instance]</code> attribute with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.addInstance#doc\">docs#Lean.Meta.addInstance</a>).</p>",
        "id": 546019527,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1760975686
    },
    {
        "content": "<p>Are those the only 2 things that happen on an <code>instance</code> declaration?</p>",
        "id": 546019852,
        "sender_full_name": "Cody Roux",
        "timestamp": 1760975757
    },
    {
        "content": "<p>I am a bit nervous about having to come up with all the fields here: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Declaration.html#Lean.DefinitionVal\">https://leanprover-community.github.io/mathlib4_docs/Lean/Declaration.html#Lean.DefinitionVal</a></p>",
        "id": 546020273,
        "sender_full_name": "Cody Roux",
        "timestamp": 1760975847
    },
    {
        "content": "<p>And it's worth noting that the body will be a fixpoint, so someone will need to elaborate this term</p>",
        "id": 546020591,
        "sender_full_name": "Cody Roux",
        "timestamp": 1760975916
    },
    {
        "content": "<p>Well, there is more, like configuring jump-to-definition. But you have to do something differently there anyway, as the syntax doesn't literally exist anywhere in the file.</p>",
        "id": 546020690,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1760975936
    },
    {
        "content": "<p>You can take a look at what <code>@[to_additive]</code> or <code>@[simps]</code> do, which both add declarations. Search for <code>addDecl</code> and surrounding code. <code>@[to_additive]</code> does quite a bit more, like copying attributes and generating equational lemmas eagerly (and applying <code>to_additive</code> to them), but that shouldn't be necessary for you.</p>",
        "id": 546020832,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1760975965
    },
    {
        "content": "<p>If you want to stick with the syntax-based approach, you should be able to construct the command syntax (<code>Lean.Command</code>) in <code>TermElabM</code>, pass it up to <code>CommandElabM</code> via <code>liftTermElabM</code>, and <code>elabCommand</code> there.</p>",
        "id": 546022178,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1760976248
    },
    {
        "content": "<p>That does seem a bit easier in the short term</p>",
        "id": 546022320,
        "sender_full_name": "Cody Roux",
        "timestamp": 1760976278
    },
    {
        "content": "<p>Btw, I thought there was a convention that commands prefixed with a hash are not supposed to change the environment. But not sure whether people are still sticking to that.</p>",
        "id": 546022556,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1760976332
    },
    {
        "content": "<p>oh, that's good to know!</p>",
        "id": 546022760,
        "sender_full_name": "Cody Roux",
        "timestamp": 1760976376
    },
    {
        "content": "<p>(originally I think <span class=\"user-mention\" data-user-id=\"920434\">@Ernest Ng</span> designed this as a \"you can declare this instance\" message)</p>",
        "id": 546023090,
        "sender_full_name": "Cody Roux",
        "timestamp": 1760976451
    },
    {
        "content": "<p>I should mention that the syntactic approach is unreliable if you delaborate <code>Expr</code> to <code>Syntax</code> anywhere. The delaborator is known not to be round-tripping in certain cases, so the generated command may fail to elaborate even though your <code>Expr</code> is correct. There are some pretty-printing options that partly fix the issue, most prominently <code>pp.analyze</code> and its sub-options. But the 'correct' way to do it is to stay in <code>Expr</code> land, like Floris says.</p>",
        "id": 546024734,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1760976884
    },
    {
        "content": "<p>Several disadvantages to that, unfortunately:</p>\n<ol>\n<li>It'd be a big rewrite at this point</li>\n<li>It's hard to write big pattern matches directly in <code>Expr</code> (<code>deriving BEq</code> doesn't do it!)</li>\n<li>You can't generate code from recursors AFAIK (has that changed?)</li>\n</ol>",
        "id": 546025926,
        "sender_full_name": "Cody Roux",
        "timestamp": 1760977211
    }
]