[
    {
        "content": "<p>Hi, I'm reading \"functional programming in lean\", I'm up to the exercise that has you implement <code>zip</code>.</p>\n<p>I have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">zip</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">([],</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">[])</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">moreXs</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">moreYs</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">zip</span> <span class=\"n\">moreXs</span> <span class=\"n\">moreYs</span>\n</code></pre></div>\n<p>I'm getting</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">fail</span> <span class=\"n\">to</span> <span class=\"k\">show</span> <span class=\"n\">termination</span> <span class=\"n\">for</span>\n  <span class=\"n\">zip</span>\n<span class=\"k\">with</span> <span class=\"n\">errors</span>\n<span class=\"n\">argument</span> <span class=\"bp\">#</span><span class=\"mi\">3</span> <span class=\"n\">was</span> <span class=\"n\">not</span> <span class=\"n\">used</span> <span class=\"n\">for</span> <span class=\"n\">structural</span> <span class=\"n\">recursion</span>\n  <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">eliminate</span> <span class=\"n\">recursive</span> <span class=\"n\">application</span>\n    <span class=\"n\">zip</span> <span class=\"n\">moreXs</span> <span class=\"n\">moreYs</span>\n\n<span class=\"n\">argument</span> <span class=\"bp\">#</span><span class=\"mi\">4</span> <span class=\"n\">was</span> <span class=\"n\">not</span> <span class=\"n\">used</span> <span class=\"n\">for</span> <span class=\"n\">structural</span> <span class=\"n\">recursion</span>\n  <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">eliminate</span> <span class=\"n\">recursive</span> <span class=\"n\">application</span>\n    <span class=\"n\">zip</span> <span class=\"n\">moreXs</span> <span class=\"n\">moreYs</span>\n\n<span class=\"n\">structural</span> <span class=\"n\">recursion</span> <span class=\"n\">cannot</span> <span class=\"n\">be</span> <span class=\"n\">used</span>\n</code></pre></div>\n<p>How do I show lean that this terminates?</p>",
        "id": 362409480,
        "sender_full_name": "James Sully",
        "timestamp": 1685528432
    },
    {
        "content": "<p>I managed it with a nested match, is there a nicer way? and why isn't lean smart enough to figure out the first one?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">zip</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">xs</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">moreXs</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">ys</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">moreYs</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">zip</span> <span class=\"n\">moreXs</span> <span class=\"n\">moreYs</span>\n</code></pre></div>",
        "id": 362411506,
        "sender_full_name": "James Sully",
        "timestamp": 1685528862
    },
    {
        "content": "<p>I would guess the overlapping cases give Lean some trouble. Try making the second case <code>(_ :: _), []</code>?</p>",
        "id": 362412743,
        "sender_full_name": "Reid Barton",
        "timestamp": 1685529122
    },
    {
        "content": "<p>didn't work unfortunately. Not even this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">zip</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">([],</span> <span class=\"o\">[])</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"o\">([],</span> <span class=\"n\">_</span> <span class=\"o\">::</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">::</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">[])</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">moreXs</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">moreYs</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">zip</span> <span class=\"n\">moreXs</span> <span class=\"n\">moreYs</span>\n</code></pre></div>",
        "id": 362414017,
        "sender_full_name": "James Sully",
        "timestamp": 1685529456
    },
    {
        "content": "<p>maybe it's something to do with it being inside  a newly cooked up pair?</p>",
        "id": 362414091,
        "sender_full_name": "James Sully",
        "timestamp": 1685529475
    },
    {
        "content": "<p>is it possible to match on multiple arguments at once without a pair?</p>",
        "id": 362414272,
        "sender_full_name": "James Sully",
        "timestamp": 1685529509
    },
    {
        "content": "<p>Don't match on a tuple, match on both arguments directly</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">zip</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">ys</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">moreXs</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">moreYs</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">zip</span> <span class=\"n\">moreXs</span> <span class=\"n\">moreYs</span>\n</code></pre></div>\n<p>this was recently discussed on the issue tracker as well. maybe it should be clarified in the book?</p>",
        "id": 362414409,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1685529546
    },
    {
        "content": "<p>nice, thanks. That's handy</p>",
        "id": 362414711,
        "sender_full_name": "James Sully",
        "timestamp": 1685529626
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/issues/2242\">https://github.com/leanprover/lean4/issues/2242</a></p>",
        "id": 362414729,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1685529630
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/showing.20termination/near/362414409\">said</a>:</p>\n<blockquote>\n<p>Don't match on a tuple, match on both arguments directly</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">zip</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">ys</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">moreXs</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">moreYs</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">zip</span> <span class=\"n\">moreXs</span> <span class=\"n\">moreYs</span>\n</code></pre></div>\n<p>this was recently discussed on the issue tracker as well. maybe it should be clarified in the book?</p>\n</blockquote>\n<p>Perhaps it would be best to \"desugar\" matching on tuples to the usual matching on multiple terms ? I've seen quite a lot of people get termination issues because they'd parenthesize on the match where they'd only mean to match on two terms.</p>",
        "id": 362435916,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1685534704
    },
    {
        "content": "<p>This is also only tangential, but Lean allows you to start with the more \"meaty\" match first and then handles the rest on its own:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">zip</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">ys</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">moreXs</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">moreYs</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">zip</span> <span class=\"n\">moreXs</span> <span class=\"n\">moreYs</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n</code></pre></div>",
        "id": 362466417,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685541632
    },
    {
        "content": "<p>Can't we add a linter or warning that detects whether a newly constructed tuple is directly matched away?</p>",
        "id": 366357664,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1686802790
    },
    {
        "content": "<p>Thanks for the feedback on the book - I've added it to the <a href=\"https://github.com/leanprover/fp-lean/issues/118\">issue tracker</a> for next time I get to fixing problems. I'm sorry to have led you astray and caused frustration.</p>",
        "id": 366834293,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1686922607
    }
]