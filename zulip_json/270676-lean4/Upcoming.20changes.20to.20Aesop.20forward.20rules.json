[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"557459\">@Xavier Généreux</span> and I have been working for some time on a new, much faster implementation of forward reasoning (<code>forward</code> and <code>destruct</code> rules) in Aesop. This is now close to ready for prime-time. The new implementation should be backward-compatible (modulo new bugs), except for three changes. I'd like to hear from users of Aesop's forward reasoning (e.g. <span class=\"user-mention\" data-user-id=\"371938\">@Son Ho</span>) whether you expect these changes to adversely affect your use cases.</p>\n<p><strong>1) <code>forward</code>  and <code>destruct</code> rules will always use <code>reducible</code> transparency.</strong></p>\n<p>This means that the premises of a forward rule will be matched against hypotheses with <code>reducible</code> transparency.</p>\n<p>Currently, the transparency is customisable, but by default, hypotheses are matched with <code>default</code> (semireducible) transparency. However, the last premise of each forward rule is indexed in a discrimination tree, so hypotheses are effectively matched against that premise with a weird mixture of <code>reducible</code> and <code>default</code> transparency.</p>\n<p>It would be possible to reimplement the old behaviour, but only with substantial effort. Transparency choices other than <code>reducible</code> would also come with a  performance hit. (They already do now, but the new implementation relies more on indexing and would therefore suffer comparatively more.) </p>\n<p><strong>2) <code>destruct</code> rules will no longer clear non-propositional hypotheses.</strong></p>\n<p>Currently, when a <code>destruct</code> rule <code>(n : Nat) -&gt; P n -&gt; Q n</code> is applied to hypotheses <code>m : Nat</code> and <code>h : P m</code>, it clears <code>m</code> and <code>h</code> unless there are other hypotheses in the goal that depend on them.</p>\n<p>With the proposed change, the rule only clears matched hypotheses if their types are propositions. So <code>m</code> will remain in the goal, but if <code>P</code> is a proposition, then <code>h</code> will still be cleared.</p>\n<p>This change is not really necessary, but I think this behaviour makes more sense, so I'm sneaking it in anyway. <span aria-label=\"smiling devil\" class=\"emoji emoji-1f608\" role=\"img\" title=\"smiling devil\">:smiling_devil:</span> </p>\n<p><strong>3) <code>forward</code> and <code>destruct</code> rules will no longer support custom indexing modes</strong></p>\n<p>Currently, custom indexing modes can be specified for <code>forward</code> and <code>destruct</code> rules, using the <code>(imode := ...)</code> builder option. The new implementation uses a different indexing scheme, so this builder option will no longer be available.</p>",
        "id": 480776570,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1730830483
    },
    {
        "content": "<p>This makes sense to me. The use of <code>reducible</code> transparency shouldn't be an issue for me, though I will need to test them on my use cases - I'm looking forward to the new version of the forward reasoning.</p>",
        "id": 480877304,
        "sender_full_name": "Son Ho",
        "timestamp": 1730885261
    },
    {
        "content": "<p>Great, thanks! I'll give you a branch with these changes soon.</p>",
        "id": 480885741,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1730887965
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/channel/270676-lean4/topic/Upcoming.20changes.20to.20Aesop.20forward.20rules/near/480776570\">said</a>:</p>\n<blockquote>\n<p>This change is not really necessary, but I think this behaviour makes more sense, so I'm sneaking it in anyway. <span aria-label=\"smiling devil\" class=\"emoji emoji-1f608\" role=\"img\" title=\"smiling devil\">:smiling_devil:</span></p>\n</blockquote>\n<p>Just curious why it makes more sense to leave a type like <code>m : Nat</code> in the context when it’s not mentioned anywhere anymore?</p>",
        "id": 480890757,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1730889687
    },
    {
        "content": "<p>Throwing away propositions is more easily reversible. For example, if <code>Q n</code> generalises <code>P n</code> and we have the <code>destruct</code> rule <code>forall n, P n -&gt; Q n</code>, then applying this rule loses no information with the new approach. With the old approach, the rule is also reversible if <code>n : Nat</code> (or, generally, if  the type of <code>n</code> is inhabited), but it's more cumbersome. Admittedly, I expect this to have about zero impact in practice.</p>",
        "id": 480920340,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1730899768
    },
    {
        "content": "<p><del>There's actually one more change I forgot:</del></p>\n<p><del><strong>4) Forward rules can now add the same proposition multiple times.</strong></del></p>\n<p>Currently, Aesop tracks which propositions have already been added by forward rules. If a forward rule then attempts to add a prop that was already added by another forward rule, the rule fails and the prop is not added again.</p>\n<p>The new system ensures a weaker property: each forward rule is run once for each distinct list of valid inputs. So if we have, for example, the rule <code>r : forall a : α, P a -&gt; Q a</code>and hypotheses <code>x : α</code>, <code>hx : P x</code>, <code>y : α</code>, <code>hy : P y</code> then the rule will be applied once to <code>x</code> and <code>hx</code> and once to <code>y</code> and <code>hy</code>. However, if we additionally have <code>hy' : P y</code> and <code>P</code> is not a <code>Prop</code>, then <code>r</code> will be applied again, resulting in an additional hypothesis of type <code>Q y</code>. And if there is another rule that derives <code>Q x</code> or <code>Q y</code>, this will also result in duplicates.</p>\n<p>If this turns out to be troublesome, it wouldn't be too much work to restore the old behaviour, but it would cost a bit of performance.</p>",
        "id": 480923437,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1730900771
    },
    {
        "content": "<p>I've backtracked on the last change, so new forward reasoning should now act exactly like old forward reasoning with respect to duplicate hypotheses. We'll see whether this creates performance issues in practice.</p>",
        "id": 481314258,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1731072365
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"371938\">@Son Ho</span> Aesop's <code>forward-code</code> branch is now ready for testing the new forward reasoning. You should be able to use this instead of <code>master</code> in your <code>lakefile.{lean,toml}</code>. The Aesop version on this branch is intended to be functionally equivalent to Aesop <code>master</code>, except for the changes mentioned above.</p>",
        "id": 481787373,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1731351136
    }
]