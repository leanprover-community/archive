[
    {
        "content": "<p>I have written a function that returns prop, and I want to use it to filter a list. To do that, I trying to write an instance of Decidable for it. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">vecLE</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v1</span> <span class=\"n\">v2</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">ℕ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Vector.map₂</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">≤</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"n\">v1</span> <span class=\"n\">v2</span>\n  <span class=\"bp\">|&gt;.</span><span class=\"n\">toList</span>\n  <span class=\"bp\">|&gt;.</span><span class=\"n\">foldl</span> <span class=\"n\">And</span> <span class=\"n\">True</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">decideableVecLE</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v1</span> <span class=\"n\">v2</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">ℕ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">vecLE</span> <span class=\"n\">v1</span> <span class=\"n\">v2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">getValid</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">ℕ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Vector</span> <span class=\"n\">ℕ</span> <span class=\"n\">n</span><span class=\"o\">)):</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Vector</span> <span class=\"n\">ℕ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">l.filter</span> <span class=\"o\">(</span><span class=\"n\">vecLE</span> <span class=\"n\">v</span> <span class=\"bp\">·</span> <span class=\"bp\">|&gt;</span> <span class=\"n\">Decidable.decide</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I have been having trouble figuring out how to prove that it is decidable. </p>\n<p>Is this the right way to be doing this? I know that I could rewrite vecLE to return bool and then I would not have to do this, but I was looking at <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Boolean.20.60.3C.60/near/328443002\">this</a>, and decided to try to do it with Prop. </p>\n<p>If this is the best approach, how can I prove decidableVecLE? If it isn't, what other approach should I use? <br>\nThis is a MWE so in reality vecLE is slightly more complicated, and getValid is part of a larger function.</p>\n<p>Also, any code criticism would be much appreciated. I am self taught, so I always just use the first solution I find in the docs, and never know if I am missing a better solution.</p>",
        "id": 350334823,
        "sender_full_name": "Jesse Slater",
        "timestamp": 1681660325
    },
    {
        "content": "<p>Presumably you can prove decidability of that relation by induction</p>",
        "id": 350337949,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681661901
    },
    {
        "content": "<p>Some comments:</p>\n<ul>\n<li>Definitions of type <code>Prop</code> are generally written in UpperCamelCase, so it should be <code>VecLE</code>,</li>\n<li>Nothing in this construction depends on <code>Nat</code>, consider generalizing to any type with a (decidable) <code>LE</code> instance</li>\n<li>it's probably easier to define a version in terms of <code>List</code> first, and then define <code>VecLE</code> in terms of <code>ListLE</code></li>\n</ul>\n<p>You could use the following as a starting point, just fill in the <code>sorry</code>s:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Aesop</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ListLE</span> <span class=\"o\">(</span><span class=\"n\">v1</span> <span class=\"n\">v2</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">List.zipWith</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">≤</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"n\">v1</span> <span class=\"n\">v2</span>\n  <span class=\"bp\">|&gt;.</span><span class=\"n\">foldl</span> <span class=\"n\">And</span> <span class=\"n\">True</span>\n\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ListLE</span>\n  <span class=\"kd\">theorem</span> <span class=\"n\">listLE_nil_left</span> <span class=\"o\">{</span><span class=\"n\">bs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ListLE</span> <span class=\"o\">([])</span> <span class=\"n\">bs</span> <span class=\"o\">:=</span>\n    <span class=\"kd\">by</span> <span class=\"n\">trivial</span>\n\n  <span class=\"kd\">theorem</span> <span class=\"n\">listLE_nil_right</span> <span class=\"o\">{</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ListLE</span> <span class=\"n\">as</span> <span class=\"o\">([])</span> <span class=\"o\">:=</span>\n    <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">as</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">trivial</span>\n\n\n\n  <span class=\"kd\">theorem</span> <span class=\"n\">not_listLE_succ_of_not_listLE</span> <span class=\"o\">{</span><span class=\"n\">x1</span> <span class=\"n\">x2</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v1</span> <span class=\"n\">v2</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n      <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">ListLE</span> <span class=\"n\">v1</span> <span class=\"n\">v2</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">ListLE</span> <span class=\"o\">(</span><span class=\"n\">x1</span> <span class=\"o\">::</span> <span class=\"n\">v1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x2</span> <span class=\"o\">::</span> <span class=\"n\">v2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n\n  <span class=\"kd\">theorem</span> <span class=\"n\">not_listLE_succ_of_not_le</span> <span class=\"o\">{</span><span class=\"n\">x1</span> <span class=\"n\">x2</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v1</span> <span class=\"n\">v2</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n      <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">x1</span> <span class=\"bp\">≤</span> <span class=\"n\">x2</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">ListLE</span> <span class=\"o\">(</span><span class=\"n\">x1</span> <span class=\"o\">::</span> <span class=\"n\">v1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x2</span> <span class=\"o\">::</span> <span class=\"n\">v2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">h₁</span><span class=\"bp\">;</span> <span class=\"n\">clear</span> <span class=\"n\">h₁</span>\n    <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">ListLE</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₂</span>\n\n    <span class=\"n\">induction</span> <span class=\"n\">v1</span> <span class=\"n\">generalizing</span> <span class=\"n\">v2</span>\n    <span class=\"n\">case</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">apply</span> <span class=\"n\">h₂</span>\n    <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">hd1</span> <span class=\"n\">tl1</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">cases</span> <span class=\"n\">v2</span>\n      <span class=\"n\">case</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">h₂</span>\n      <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">hd2</span> <span class=\"n\">tl2</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">ih</span> <span class=\"n\">tl2</span>\n        <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">List.foldl</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₂</span>\n        <span class=\"k\">suffices</span> <span class=\"bp\">∀</span> <span class=\"n\">left</span> <span class=\"n\">right</span> <span class=\"n\">tl</span><span class=\"o\">,</span>\n          <span class=\"n\">List.foldl</span> <span class=\"n\">And</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"bp\">∧</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"n\">tl</span> <span class=\"bp\">→</span> <span class=\"n\">List.foldl</span> <span class=\"n\">And</span> <span class=\"n\">right</span> <span class=\"n\">tl</span>\n        <span class=\"k\">from</span> <span class=\"kd\">by</span>\n          <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">And.comm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₂</span>\n          <span class=\"n\">apply</span> <span class=\"n\">this</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h₂</span>\n\n        <span class=\"n\">intro</span> <span class=\"n\">left</span> <span class=\"n\">right</span> <span class=\"n\">tl</span><span class=\"bp\">;</span>\n        <span class=\"n\">induction</span> <span class=\"n\">tl</span> <span class=\"n\">generalizing</span> <span class=\"n\">left</span> <span class=\"n\">right</span>\n        <span class=\"n\">case</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">h</span>\n        <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"n\">intro</span> <span class=\"n\">h</span>\n          <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">List.foldl</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"bp\">|-</span>\n          <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">left</span> <span class=\"bp\">∧</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">hd</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"bp\">∧</span> <span class=\"n\">hd</span><span class=\"o\">))</span>\n            <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span>\n          <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">clear</span> <span class=\"n\">this</span><span class=\"bp\">;</span>\n          <span class=\"n\">apply</span> <span class=\"n\">ih</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span>\n\n\n\n\n\n  <span class=\"kd\">theorem</span> <span class=\"n\">listLE_succ</span> <span class=\"o\">{</span><span class=\"n\">x1</span> <span class=\"n\">x2</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v1</span> <span class=\"n\">v2</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n      <span class=\"n\">x1</span> <span class=\"bp\">≤</span> <span class=\"n\">x2</span> <span class=\"bp\">→</span> <span class=\"n\">ListLE</span> <span class=\"n\">v1</span> <span class=\"n\">v2</span> <span class=\"bp\">→</span> <span class=\"n\">ListLE</span> <span class=\"o\">(</span><span class=\"n\">x1</span> <span class=\"o\">::</span> <span class=\"n\">v1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x2</span> <span class=\"o\">::</span> <span class=\"n\">v2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span>\n    <span class=\"gr\">sorry</span>\n\n\n\n\n  <span class=\"kd\">instance</span> <span class=\"n\">decide</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"n\">bs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">rel</span> <span class=\"o\">:</span> <span class=\"n\">DecidableRel</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE.le</span> <span class=\"n\">α</span> <span class=\"n\">_</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">ListLE</span> <span class=\"n\">as</span> <span class=\"n\">bs</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"n\">bs</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"n\">_</span>           <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">isTrue</span> <span class=\"n\">listLE_nil_left</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">[]</span>           <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">isTrue</span> <span class=\"n\">listLE_nil_right</span>\n    <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">::</span><span class=\"n\">bs</span>    <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">rel</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">decide</span> <span class=\"n\">as</span> <span class=\"n\">bs</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">isFalse</span> <span class=\"n\">h</span>           <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">isFalse</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">not_listLE_succ_of_not_listLE</span> <span class=\"n\">h</span>\n        <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">isFalse</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span>           <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">isFalse</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">not_listLE_succ_of_not_le</span> <span class=\"n\">h</span>\n        <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">isTrue</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">isTrue</span> <span class=\"n\">h₂</span>  <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">isTrue</span>  <span class=\"bp\">&lt;|</span> <span class=\"n\">listLE_succ</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span>\n\n\n<span class=\"kd\">end</span> <span class=\"n\">ListLE</span>\n</code></pre></div>",
        "id": 350359525,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1681675047
    },
    {
        "content": "<p>If you change the definition to something that's more mathematical and less procedural, it turns out to be really easy to define this instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Vector.Basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">VectorLE</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v1</span> <span class=\"n\">v2</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">v1.get</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">v2.get</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">DecidableRel</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">≤</span> <span class=\"bp\">·</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">v1</span> <span class=\"n\">v2</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">VectorLE</span> <span class=\"n\">v1</span> <span class=\"n\">v2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">inferInstanceAs</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The key is that there is already a forall decidable instance when it's over <code>Fin n</code>.</p>\n<p>I also generalized this to be for an arbitrary type with a decidable LE relation, rather than just <code>Nat</code>.</p>",
        "id": 350377020,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681686327
    },
    {
        "content": "<p>Thank you, this is excellent! I guess I am too used to thinking procedurally.</p>",
        "id": 351769688,
        "sender_full_name": "Jesse Slater",
        "timestamp": 1682132490
    }
]