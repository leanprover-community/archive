[
    {
        "content": "<p>I hope that this is the right stream for my question, since it's not really a math question but, as far as I can tell, a problem with different decidability instances fighting it out.</p>\n<p>Context: I'm trying to prove that continuous multilinear maps are differentiable. So there is a type <code>ι</code> indexing the product on which the map is defined, with a <code>Fintype</code> instance on it. Some of my lemmas require a <code>DedicableEq</code> instance on <code>ι</code>, and some require a <code>LinearOrder</code> instance; when I tried to call the second kind of lemma in the first kind of lemma, the <code>DecidableEq</code> instance coming from the <code>LinearOrder</code> fights the already existing <code>DecidableEq</code> instance and it blocks everything with one of Lean's trademark confusing messages. Here is a MWE so you can see if I interpreted the situation correctly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.NormedSpace.Multilinear</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Extension.Well</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MultilinearMap</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uR</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>  <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uι</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span>\n<span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">AddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n<span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">apply_sub</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">MultilinearMap</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">Finset.card</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">s.piecewise</span> <span class=\"n\">a</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">s.piecewise</span> <span class=\"n\">b</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Finset.sum</span> <span class=\"n\">Finset.univ</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n<span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">s.orderIsoOfFin</span> <span class=\"n\">hs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"n\">a</span> <span class=\"n\">j</span>\n<span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">s.orderIsoOfFin</span> <span class=\"n\">hs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"n\">a</span> <span class=\"n\">j</span> <span class=\"bp\">-</span> <span class=\"n\">b</span> <span class=\"n\">j</span> <span class=\"k\">else</span> <span class=\"n\">b</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">v</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MultilinearMap</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ContinuousMultilinearMap</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">w₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w₂</span><span class=\"o\">}</span>\n<span class=\"o\">[(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">NormedAddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n<span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">deriv</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousMultilinearMap</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"n\">Finset.sum</span> <span class=\"n\">Finset.univ</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">f.toContinuousLinearMap</span> <span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">ContinuousLinearMap.proj</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sub_piecewise_bound</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousMultilinearMap</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(((</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">×</span> <span class=\"o\">((</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n<span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">s.card</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">‖</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">s.piecewise</span> <span class=\"n\">h.1</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">s.piecewise</span> <span class=\"n\">h.2</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">‖</span> <span class=\"bp\">≤</span> <span class=\"n\">s.card</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">f</span><span class=\"bp\">‖</span> <span class=\"bp\">*</span>\n<span class=\"bp\">‖</span><span class=\"n\">x</span><span class=\"bp\">‖</span> <span class=\"bp\">^</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ.</span><span class=\"n\">card</span> <span class=\"bp\">*</span> <span class=\"bp\">‖</span><span class=\"n\">h</span><span class=\"bp\">‖</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">s.card</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">‖</span><span class=\"n\">h.1</span> <span class=\"bp\">-</span> <span class=\"n\">h.2</span><span class=\"bp\">‖</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">ι</span> <span class=\"o\">:=</span> <span class=\"n\">WellFounded.wellOrderExtension</span> <span class=\"n\">emptyWf.wf</span>\n  <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">MultilinearMap.apply_sub</span> <span class=\"n\">f.toMultilinearMap</span> <span class=\"n\">h.1</span> <span class=\"n\">h.2</span> <span class=\"n\">x</span> <span class=\"n\">s</span> <span class=\"n\">rfl</span><span class=\"o\">]</span>\n    <span class=\"c1\">-- Error message: tactic 'rewrite' failed, did not find instance of the pattern in the target expression</span>\n     <span class=\"c1\">-- f.toMultilinearMap (Finset.piecewise s h.1 x) - f.toMultilinearMap (Finset.piecewise s h.2 x)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">ContinuousMultilinearMap</span>\n</code></pre></div>\n<p>My interpretation of the error message is that Lean doesn't think the <code>Finset.piecewise</code> do the same thing, since the <code>Finset.decidableMem</code> instances that they call come from different sources. But since I'm a mathematician and I don't care about these decidability things, of course the functions do the same thing !  </p>\n<p>I thought about just taking my <code>ι</code> to be <code>Fin n</code> throughout, but it's a bit unsatisfying to my mathematical mind (because it <em>shouldn't</em> be necessary), and also I'm not even sure it would solve the problem.</p>",
        "id": 408338111,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702728312
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">MultilinearMap.apply_sub</span> <span class=\"n\">f.toMultilinearMap</span> <span class=\"n\">h.1</span> <span class=\"n\">h.2</span> <span class=\"n\">x</span> <span class=\"n\">s</span> <span class=\"n\">rfl</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans_le</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 408338625,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1702728623
    },
    {
        "content": "<p>Thanks ! Though it made a strange seemingly unrelated error appear later in my real code, and I have no idea what's happening. (No MWE yet as I'm still trying to fix things myself, but I may be back soon.)</p>",
        "id": 408339745,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702729443
    },
    {
        "content": "<p>Okay, so I pawned myself by trying to streamline the MWE too much. <span aria-label=\"confounded\" class=\"emoji emoji-1f616\" role=\"img\" title=\"confounded\">:confounded:</span> My actual file had an <code>open Classical</code> at the beginning instead of a <code>DecidableEq</code> instance for my specific type <code>ι</code>,  and I don't even know why or how, but your solution has introduced a problem with the complement function on <code>Finset ι</code>. New MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.NormedSpace.Multilinear</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Extension.Well</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MultilinearMap</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uR</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>  <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uι</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span>\n<span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">AddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n<span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">apply_sub</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">MultilinearMap</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">Finset.card</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">s.piecewise</span> <span class=\"n\">a</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">s.piecewise</span> <span class=\"n\">b</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Finset.sum</span> <span class=\"n\">Finset.univ</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n<span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">s.orderIsoOfFin</span> <span class=\"n\">hs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"n\">a</span> <span class=\"n\">j</span>\n<span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">s.orderIsoOfFin</span> <span class=\"n\">hs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"n\">a</span> <span class=\"n\">j</span> <span class=\"bp\">-</span> <span class=\"n\">b</span> <span class=\"n\">j</span> <span class=\"k\">else</span> <span class=\"n\">b</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">v</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MultilinearMap</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ContinuousMultilinearMap</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Classical</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">w₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w₂</span><span class=\"o\">}</span>\n<span class=\"o\">[(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">NormedAddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n<span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">deriv</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousMultilinearMap</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"n\">Finset.sum</span> <span class=\"n\">Finset.univ</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">f.toContinuousLinearMap</span> <span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">ContinuousLinearMap.proj</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sub_piecewise_bound</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousMultilinearMap</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(((</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">×</span> <span class=\"o\">((</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n<span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">s.card</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">‖</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">s.piecewise</span> <span class=\"n\">h.1</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">s.piecewise</span> <span class=\"n\">h.2</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">‖</span> <span class=\"bp\">≤</span> <span class=\"n\">s.card</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">f</span><span class=\"bp\">‖</span> <span class=\"bp\">*</span>\n<span class=\"bp\">‖</span><span class=\"n\">x</span><span class=\"bp\">‖</span> <span class=\"bp\">^</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ.</span><span class=\"n\">card</span> <span class=\"bp\">*</span> <span class=\"bp\">‖</span><span class=\"n\">h</span><span class=\"bp\">‖</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">s.card</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">‖</span><span class=\"n\">h.1</span> <span class=\"bp\">-</span> <span class=\"n\">h.2</span><span class=\"bp\">‖</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">ι</span> <span class=\"o\">:=</span> <span class=\"n\">WellFounded.wellOrderExtension</span> <span class=\"n\">emptyWf.wf</span>\n  <span class=\"n\">set</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">s.card</span>\n  <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">MultilinearMap.apply_sub</span> <span class=\"n\">f.toMultilinearMap</span> <span class=\"n\">h.1</span> <span class=\"n\">h.2</span> <span class=\"n\">x</span> <span class=\"n\">s</span> <span class=\"n\">rfl</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans_le</span> <span class=\"n\">_</span>\n  <span class=\"n\">refine</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">norm_sum_le</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"k\">have</span> <span class=\"n\">heq</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Finset.univ</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Finset.card_fin</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">heq</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"o\">(</span><span class=\"n\">Finset.sum_const</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">))]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Finset.sum_le_sum</span>\n  <span class=\"n\">intro</span> <span class=\"n\">i</span> <span class=\"n\">_</span>\n  <span class=\"n\">refine</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">ContinuousMultilinearMap.le_op_norm</span> <span class=\"n\">f</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">mul_assoc</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"n\">mul_le_mul_of_nonneg_left</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">norm_nonneg</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"o\">(</span><span class=\"n\">Finset.prod_compl_mul_prod</span> <span class=\"n\">s</span><span class=\"o\">)]</span>\n  <span class=\"n\">set</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">s.orderIsoOfFin</span> <span class=\"n\">rfl</span> <span class=\"n\">i</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"o\">(</span><span class=\"n\">Finset.mul_prod_erase</span> <span class=\"n\">s</span> <span class=\"n\">_</span> <span class=\"n\">m.2</span><span class=\"o\">)]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">m.2</span><span class=\"o\">,</span> <span class=\"n\">dite_true</span><span class=\"o\">]</span>\n  <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lhs</span>\n          <span class=\"n\">congr</span>\n          <span class=\"n\">rfl</span>\n          <span class=\"n\">congr</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">OrderIso.symm_apply_apply</span><span class=\"o\">]</span>\n          <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">lt_irrefl</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">ite_false</span><span class=\"o\">,</span> <span class=\"n\">ite_true</span><span class=\"o\">]</span>\n          <span class=\"n\">rfl</span>\n  <span class=\"k\">have</span> <span class=\"n\">hle1aux</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">→</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">‖</span><span class=\"k\">if</span> <span class=\"n\">hk</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"k\">then</span>\n          <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">OrderIso.symm</span> <span class=\"o\">(</span><span class=\"n\">Finset.orderIsoOfFin</span> <span class=\"n\">s</span> <span class=\"n\">rfl</span><span class=\"o\">))</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">⟩</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"n\">h.1</span> <span class=\"n\">k</span>\n          <span class=\"k\">else</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">OrderIso.symm</span> <span class=\"o\">(</span><span class=\"n\">Finset.orderIsoOfFin</span> <span class=\"n\">s</span> <span class=\"n\">rfl</span><span class=\"o\">))</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"n\">h.1</span> <span class=\"n\">k</span> <span class=\"bp\">-</span> <span class=\"n\">h.2</span> <span class=\"n\">k</span>\n            <span class=\"k\">else</span> <span class=\"n\">h.2</span> <span class=\"n\">k</span>\n        <span class=\"k\">else</span> <span class=\"n\">x</span> <span class=\"n\">k</span><span class=\"bp\">‖</span><span class=\"o\">)</span> <span class=\"n\">j</span> <span class=\"bp\">≤</span> <span class=\"bp\">‖</span><span class=\"n\">x</span><span class=\"bp\">‖</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">j</span> <span class=\"n\">hj</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finset.mem_compl</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hj</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hj</span><span class=\"o\">,</span> <span class=\"n\">dite_false</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"n\">norm_le_pi_norm</span>\n  <span class=\"k\">have</span> <span class=\"n\">hle1</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.prod_le_prod</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">j</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">norm_nonneg</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">hle1aux</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finset.prod_const</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hle1</span>\n  <span class=\"k\">have</span> <span class=\"n\">hle2aux</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">Finset.erase</span> <span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"bp\">→</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span>  <span class=\"bp\">‖</span><span class=\"k\">if</span> <span class=\"n\">hk</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"k\">then</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">OrderIso.symm</span> <span class=\"o\">(</span><span class=\"n\">Finset.orderIsoOfFin</span> <span class=\"n\">s</span> <span class=\"n\">rfl</span><span class=\"o\">))</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">⟩</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"n\">h.1</span> <span class=\"n\">k</span>\n    <span class=\"k\">else</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">OrderIso.symm</span> <span class=\"o\">(</span><span class=\"n\">Finset.orderIsoOfFin</span> <span class=\"n\">s</span> <span class=\"n\">rfl</span><span class=\"o\">))</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"n\">h.1</span> <span class=\"n\">k</span> <span class=\"bp\">-</span> <span class=\"n\">h.2</span> <span class=\"n\">k</span>\n    <span class=\"k\">else</span> <span class=\"n\">h.2</span> <span class=\"n\">k</span>\n    <span class=\"k\">else</span> <span class=\"n\">x</span> <span class=\"n\">k</span><span class=\"bp\">‖</span><span class=\"o\">)</span> <span class=\"n\">j</span> <span class=\"bp\">≤</span> <span class=\"bp\">‖</span><span class=\"n\">h</span><span class=\"bp\">‖</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">j</span> <span class=\"n\">hj</span>\n    <span class=\"n\">set</span> <span class=\"n\">hj'</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.mem_of_mem_erase</span> <span class=\"n\">hj</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hj'</span><span class=\"o\">,</span> <span class=\"n\">dite_true</span><span class=\"o\">]</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">hj''</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s.orderIsoOfFin</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">hj'</span><span class=\"o\">⟩</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span>\n    <span class=\"bp\">.</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hj''</span><span class=\"o\">,</span> <span class=\"n\">ite_true</span><span class=\"o\">]</span>\n      <span class=\"n\">refine</span> <span class=\"n\">le_trans</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">norm_fst_le</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n      <span class=\"n\">apply</span> <span class=\"n\">norm_le_pi_norm</span>\n    <span class=\"bp\">.</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hj''</span><span class=\"o\">,</span> <span class=\"n\">ite_false</span><span class=\"o\">]</span>\n      <span class=\"k\">have</span> <span class=\"n\">hj'''</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s.orderIsoOfFin</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">hj'</span><span class=\"o\">⟩</span> <span class=\"bp\">≠</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">by_contra</span> <span class=\"n\">habs</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finset.mem_erase</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hj</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"n\">at</span> <span class=\"n\">hj</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">habs</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hj</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">OrderIso.apply_symm_apply</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">not_true_eq_false</span><span class=\"o\">,</span> <span class=\"n\">false_and</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hj</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hj'''</span><span class=\"o\">,</span> <span class=\"n\">ite_false</span><span class=\"o\">,</span> <span class=\"n\">ge_iff_le</span><span class=\"o\">]</span>\n      <span class=\"n\">refine</span> <span class=\"n\">le_trans</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">norm_snd_le</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n      <span class=\"n\">apply</span> <span class=\"n\">norm_le_pi_norm</span>\n  <span class=\"k\">have</span> <span class=\"n\">hle2</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.prod_le_prod</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">s.erase</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">j</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">norm_nonneg</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">hle2aux</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finset.prod_const</span><span class=\"o\">,</span> <span class=\"n\">Finset.card_erase_of_mem</span> <span class=\"n\">m.2</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hle2</span>\n  <span class=\"n\">refine</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">mul_le_mul_of_nonneg_right</span> <span class=\"n\">hle1</span> <span class=\"o\">(</span><span class=\"n\">mul_nonneg</span> <span class=\"o\">(</span><span class=\"n\">norm_nonneg</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">Finset.prod_nonneg</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">norm_nonneg</span> <span class=\"n\">_</span><span class=\"o\">))))</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">apply</span> <span class=\"n\">mul_le_mul</span>\n  <span class=\"bp\">.</span> <span class=\"n\">apply</span> <span class=\"n\">le_refl</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">x</span><span class=\"bp\">‖</span> <span class=\"bp\">^</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ.</span><span class=\"n\">card</span><span class=\"o\">)</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> Error message:</span>\n<span class=\"cm\">  tactic 'apply' failed, failed to unify</span>\n<span class=\"cm\">  ‖x‖ ^ Finset.card sᶜ ≤ ‖x‖ ^ Finset.card sᶜ</span>\n<span class=\"cm\">with</span>\n<span class=\"cm\">  ‖x‖ ^ Finset.card sᶜ ≤ ‖x‖ ^ Finset.card sᶜ-/</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">ContinuousMultilinearMap</span>\n</code></pre></div>\n<p>The error message is not so helpful, but if I unwrap it I find that the problem seems to come from  <code>Finset.booleanAlgebra</code>, which calls on two separate decidability instances on <code>ι</code>. So the problem has only been displaced further. <span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span></p>",
        "id": 408341305,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702730834
    },
    {
        "content": "<p>Yes, simply don't use <code>open Classical</code>. This is what's introducing the problematic <code>DecidableEq</code> instance.</p>",
        "id": 408341394,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702730908
    },
    {
        "content": "<p>If I don't use <code>open Classical</code>, every lemma before that that involved <code>Function.update</code> and <code>Finset.piecewise</code> starts having problems.</p>",
        "id": 408342248,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702731634
    },
    {
        "content": "<p>Look at this for example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.NormedSpace.Multilinear</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Calculus.ContDiff.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.SpecialFunctions.Pow.Real</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Extension.Well</span>\n<span class=\"kn\">import</span> <span class=\"n\">ExteriorPowers.MultilinearMap</span>\n\n\n<span class=\"kn\">open</span> <span class=\"n\">Filter</span> <span class=\"n\">Asymptotics</span> <span class=\"n\">ContinuousLinearMap</span> <span class=\"n\">Set</span> <span class=\"n\">Metric</span>\n<span class=\"kn\">open</span> <span class=\"n\">Topology</span> <span class=\"n\">NNReal</span> <span class=\"n\">Asymptotics</span> <span class=\"n\">ENNReal</span>\n<span class=\"kn\">open</span> <span class=\"n\">NormedField</span>\n\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ContinuousMultilinearMap</span>\n\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">w₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w₂</span><span class=\"o\">}</span>\n<span class=\"o\">[(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">NormedAddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n<span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">deriv</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousMultilinearMap</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"n\">Finset.sum</span> <span class=\"n\">Finset.univ</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">f.toContinuousLinearMap</span> <span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">ContinuousLinearMap.proj</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n\n\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">deriv_apply</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousMultilinearMap</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f.deriv</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">Finset.sum</span> <span class=\"n\">Finset.univ</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">Function.update</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"n\">i</span><span class=\"o\">)))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">deriv</span> <span class=\"n\">toContinuousLinearMap</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ContinuousLinearMap.coe_sum'</span><span class=\"o\">,</span> <span class=\"n\">ContinuousLinearMap.coe_comp'</span><span class=\"o\">,</span>\n    <span class=\"n\">ContinuousLinearMap.coe_mk'</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.coe_toAddHom</span><span class=\"o\">,</span> <span class=\"n\">Finset.sum_apply</span><span class=\"o\">,</span>\n    <span class=\"n\">Function.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">ContinuousLinearMap.proj_apply</span><span class=\"o\">,</span> <span class=\"n\">MultilinearMap.toLinearMap_apply</span><span class=\"o\">,</span> <span class=\"n\">coe_coe</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">deriv_coe_apply</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousMultilinearMap</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">i</span><span class=\"o\">)):</span>\n<span class=\"n\">f.deriv</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">f.toMultilinearMap.linearDeriv</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">deriv_apply</span><span class=\"o\">,</span> <span class=\"n\">MultilinearMap.linearDeriv_apply</span><span class=\"o\">,</span> <span class=\"n\">coe_coe</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- Goal: (Finset.sum Finset.univ fun x_1 ↦ f (Function.update x x_1 (y x_1))) =</span>\n  <span class=\"c1\">--        Finset.sum Finset.univ fun x_1 ↦ f (Function.update x x_1 (y x_1))</span>\n  <span class=\"n\">rfl</span> <span class=\"c\">/-</span><span class=\"cm\">Error nmessage: type mismatch</span>\n<span class=\"cm\">  HEq.rfl</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  HEq ?m.22983 ?m.22983 : Prop</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  (Finset.sum Finset.univ fun x_1 ↦ f (Function.update x x_1 (y x_1))) =</span>\n<span class=\"cm\">    Finset.sum Finset.univ fun x_1 ↦ f (Function.update x x_1 (y x_1)) : Prop-/</span>\n</code></pre></div>\n<p>If I sorry this lemma, the next one has a similar problem !</p>",
        "id": 408342561,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702731821
    },
    {
        "content": "<p>Oops, there's an import from a local file in my MWE.  The local file also had an <code>open Classical</code>, I changed it to a <code>DedicableEq</code> instance and that problem vanished.</p>",
        "id": 408342791,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702732012
    },
    {
        "content": "<p>But I'm a mathematician, I want to use <code>open Classical</code> so I don't have to worry about decidability all the time... <span aria-label=\"sob\" class=\"emoji emoji-1f62d\" role=\"img\" title=\"sob\">:sob:</span></p>",
        "id": 408342822,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702732047
    },
    {
        "content": "<p>Lesson learned the hard way: never ever <code>open Classical</code>, because it creates much more problems than it solves. Instead, whenever a lemma complains that the statement doesn't make sense because it lacks decidability assumptions, add them to the statement of the lemma.</p>",
        "id": 408342983,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1702732188
    },
    {
        "content": "<p>Sebastien, the first <code>open Classical</code> came because I copied the preamble of <code>Mathlib.Analysis.Calculus.FDeriv.Bilinear</code> and it was there. (Since that's the file I'm trying to generalize.)</p>",
        "id": 408343129,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702732296
    },
    {
        "content": "<p>Feel free to remove it from there too!</p>",
        "id": 408343206,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702732339
    },
    {
        "content": "<p>Uhhhh, I haven't dared PR my shiny new lemmas to mathlib yet, I'm not at the level where I'm going to fiddle with the assumptions of already-existing files.</p>",
        "id": 408343233,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702732378
    },
    {
        "content": "<p>(Also one day maybe I'll understand how to use <code>calc</code> and my life will become beautiful. Don't hold your breath.)</p>",
        "id": 408343282,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702732431
    },
    {
        "content": "<p>Both of those are things you should try. I'm still eagerly awaiting your shellability work <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 408343332,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702732447
    },
    {
        "content": "<p>There were other people who wanted to contribute abstract simplicial complex stuff to mathlib so I was waiting to hear from them. But it's been a few months and they seem to have vanished.</p>",
        "id": 408343383,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702732514
    },
    {
        "content": "<p>There is <a href=\"#narrow/stream/287929-mathlib4/topic/AbstractSimplicialComplex\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/AbstractSimplicialComplex</a> from two days ago.</p>",
        "id": 408343490,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702732577
    },
    {
        "content": "<p>Out of everyone here, you have the most advanced use of ASC so far. I have very detailed ideas about the basic theory, but I don't know much about the rest. You should PR your material, then I can polish the basic parts and review the harder parts in depth.</p>",
        "id": 408343540,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702732640
    },
    {
        "content": "<p>I hadn't seen that. (Every time I log on to Zulip, it tells me I have ten zillion unread messages, and I run away again.) I have to <del>ruin lives</del> give an exam early next week, then I should have a little time to PR this stuff.</p>",
        "id": 408343845,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702732902
    },
    {
        "content": "<p>It's an oral exam, so at least I won't spend my holiday grading. (I will, however, spend it reading postdoc applications...)</p>",
        "id": 408344010,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702733043
    },
    {
        "content": "<p>Well, continuous multilinear maps are now officially differentiable, thanks to Andrew Yang's fix ! Now I have to prove that they are infinitely differentiable by an \"obvious induction\". I look forward eagerly to the wrenches that Lean is going to throw into said obvious induction.</p>",
        "id": 408344231,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702733221
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> <a href=\"#narrow/stream/270676-lean4/topic/Decidability.20clash/near/408343845\">said</a>:</p>\n<blockquote>\n<p>Every time I log on to Zulip, it tells me I have ten zillion unread messages, and I run away again.</p>\n</blockquote>\n<p>Do you know you can use the stream menu to mark messages as read even if you didn't read them?</p>",
        "id": 408353111,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1702739997
    },
    {
        "content": "<p>Wew are sorry about the <code>open Classical</code> trap. It used to be a good idea a long time ago. This is no longer true but you may still find places recommending it, or old files using it. It is really a historical accident.</p>",
        "id": 408353226,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1702740071
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> <a href=\"#narrow/stream/270676-lean4/topic/Decidability.20clash/near/408344231\">said</a>:</p>\n<blockquote>\n<p>Well, continuous multilinear maps are now officially differentiable, thanks to Andrew Yang's fix ! Now I have to prove that they are infinitely differentiable by an \"obvious induction\". I look forward eagerly to the wrenches that Lean is going to throw into said obvious induction.</p>\n</blockquote>\n<p>Please read comments containing the word universe in <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Analysis/Calculus/ContDiff/Bounds.lean\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Analysis/Calculus/ContDiff/Bounds.lean</a> for instance.</p>",
        "id": 408353370,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1702740200
    },
    {
        "content": "<p><code>open scoped Classical in</code> is still occasionally a good idea, but only for <code>def</code>s and never for theorems</p>",
        "id": 408357145,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702743101
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/Decidability.20clash/near/408353370\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> <a href=\"#narrow/stream/270676-lean4/topic/Decidability.20clash/near/408344231\">said</a>:</p>\n<blockquote>\n<p>Well, continuous multilinear maps are now officially differentiable, thanks to Andrew Yang's fix ! Now I have to prove that they are infinitely differentiable by an \"obvious induction\". I look forward eagerly to the wrenches that Lean is going to throw into said obvious induction.</p>\n</blockquote>\n<p>Please read comments containing the word universe in <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Analysis/Calculus/ContDiff/Bounds.lean\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Analysis/Calculus/ContDiff/Bounds.lean</a> for instance.</p>\n</blockquote>\n<p>Hahaha, I ran into exactly that issue, you wizard. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> Thanks for the link !</p>",
        "id": 408375745,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702760928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/Decidability.20clash/near/408353111\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> <a href=\"#narrow/stream/270676-lean4/topic/Decidability.20clash/near/408343845\">said</a>:</p>\n<blockquote>\n<p>Every time I log on to Zulip, it tells me I have ten zillion unread messages, and I run away again.</p>\n</blockquote>\n<p>Do you know you can use the stream menu to mark messages as read even if you didn't read them?</p>\n</blockquote>\n<p>Yes, I know. It goes against my completionist instincts but I will have to use this feature if I want to continue frequenting Zulip.</p>",
        "id": 408375780,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702760984
    },
    {
        "content": "<p>Whew, the induction is done. I had extra fun with the change of universe because <code>ContinuousMultilinearMap.domDomCongr</code> only works if all the components of the product are the same space, so I had to reduce to that case first. (Well first I tried to generalize <code>domDomCongr</code> and quickly understood why the restriction was there. Ouch.)</p>",
        "id": 408382227,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702768072
    },
    {
        "content": "<p>Okayyy, I made my first PR  of the \"continuous multilinear maps are infinitely differentiable\" project, which is a definition and a couple lemmas in <code>Mathlib.LinearAlgebra.Multilinear.Basic</code>, and I labelled it with <code>awaiting-review</code>. Should I now go to PR reviews to discuss it ? I've been trying to follow the instructions of <a href=\"https://leanprover-community.github.io/contribute/index.html\">https://leanprover-community.github.io/contribute/index.html</a> so far, but I didn't see a mention of the <code>PR reviews</code> Zulip channel.</p>",
        "id": 408449338,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702826051
    },
    {
        "content": "<p>This review stream is used only for PRs that require too much discussion for GitHub, and sometimes also to point out PRs that seem neglected on GitHub.</p>",
        "id": 408449452,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1702826162
    },
    {
        "content": "<p>Ok, I'll wait then.</p>",
        "id": 408449570,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702826272
    },
    {
        "content": "<p>It is usually a good idea to mention the PR number when noting that you made a PR, so that interested but lazy people can click it and look at it! (Zulip autolinks things that look like #NNNN to github PRs)</p>",
        "id": 408449959,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702826599
    },
    {
        "content": "<p>Here, for interested but lazy people: <a href=\"https://github.com/leanprover-community/mathlib4/pull/9130\">#9130</a></p>",
        "id": 408450251,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702826867
    },
    {
        "content": "<p>Wow, magical autolink !</p>",
        "id": 408450265,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702826879
    },
    {
        "content": "<p>I left some initial comments; the obvious one is that you're writing <code>Finset.sum</code> instead of <code>∑</code>, and the latter is usually much easier to read!</p>",
        "id": 408450786,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702827339
    },
    {
        "content": "<p>You're right, I almost never use notation in my own files but I guess I should. I've committed all your changes.</p>",
        "id": 408458784,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1702833387
    }
]