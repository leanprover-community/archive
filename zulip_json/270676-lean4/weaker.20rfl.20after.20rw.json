[
    {
        "content": "<p>In Lean 3, the <code>rw</code> closed the goal. In Lean 4 it doesn't:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">g'</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">g'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g'</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- ⊢ Function.comp f g' x = f (g' x)</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I'm interested in understanding why this happens because it just came up in the mathlib port and I suspect we'll be seeing it again. Is there some rule of thumb here about the change?</p>",
        "id": 323579994,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674679027
    },
    {
        "content": "<p>Is this a change related to rfl or Function.comp? I feel like I've hit issues with comp before</p>",
        "id": 323582169,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1674679829
    },
    {
        "content": "<p>Oh I don't know! In mathlib3 <code>rw</code> tries a \"weak <code>rfl</code>\", not daring to unfold too much, because we don't want a performance hit when it fails.</p>",
        "id": 323582474,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674679946
    },
    {
        "content": "<p>There's another kind of difference in <code>rw</code> between Lean 3 and Lean 4:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.sub_sub_self</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- ⊢ x = x * Nat.succ 0</span>\n  <span class=\"n\">change</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_one</span><span class=\"o\">]</span>\n</code></pre></div>\n<ul>\n<li>In Lean 3, after the first rewrite the goal is <code>x = x * 1</code> which can be finished with either <code>simp</code> or <code>rw mul_one</code>.</li>\n<li>In Lean 4, the goal becomes <code>x = x * Nat.succ 0</code> instead. Then <code>simp</code> doesn't do anything and <code>rw [mul_one]</code> fails to match. My solution was to add the <code>change</code> call, after which either <code>simp</code> or <code>rw [mul_one]</code> will close the goal.</li>\n</ul>\n<p>This isn't the same as your example, because <code>rfl</code> (reducible or not) won't close the goal at that point, in Lean 3 or in Lean 4. It's not necessarily a bug, or even a big deal, but it's another difference that might affect porting.</p>",
        "id": 327455247,
        "sender_full_name": "Richard Copley",
        "timestamp": 1676253663
    },
    {
        "content": "<p>That's an interesting difference, thanks for pointing it out.</p>",
        "id": 327487529,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676275901
    },
    {
        "content": "<p>I think Kevin's original example is due to Function.comp no longer being reducible.</p>",
        "id": 327487564,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676275916
    },
    {
        "content": "<p>In Kevin's example, in Lean 3, the <code>rw</code> changes <code>(f ∘ g) x = f (g' x)</code> to <code>(f ∘ g') x = f (g' x)</code> — an exact match, nothing to reduce — but in Lean 4 the result has <code>Function.comp</code> instead of <code>∘</code>.</p>",
        "id": 327517437,
        "sender_full_name": "Richard Copley",
        "timestamp": 1676285483
    },
    {
        "content": "<p>Your issue is that you're abusing the le-lt defeq; <code>sub_sub_self</code> needs a <code>1 \\le a</code> argument</p>",
        "id": 327517874,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1676285623
    },
    {
        "content": "<p>Isn't <code>∘</code> notation for <code>Function.comp</code>? Though I don't know why it doesn't get pretty printed that way</p>",
        "id": 327518084,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676285695
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">replace</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.sub_sub_self</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_one</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 327518092,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1676285696
    },
    {
        "content": "<p>That replacement makes for a clearer argument than the one I came up with. Thanks.</p>",
        "id": 327520348,
        "sender_full_name": "Richard Copley",
        "timestamp": 1676286440
    },
    {
        "content": "<p>I agree this example with <code>le</code>/<code>lt</code> is marginally defeq abuse, but there are probably similar situations, which we wouldn't consider abuse, but where the result of <code>rw</code> is still spelled differently in Lean 3 and Lean 4.</p>",
        "id": 327521436,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676286774
    },
    {
        "content": "<p>It seems like Lean 3 takes the spelling from the goal, while Lean 4 takes the one from the lemma to rewrite with.</p>",
        "id": 327521504,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676286798
    },
    {
        "content": "<p>If you're keeping this code, I'd use one of these, fwiw:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">Nat.add_one_le_iff</span><span class=\"o\">,</span> <span class=\"n\">zero_add</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pos_iff_ne_zero</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">one_le_iff_ne_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>(and wonder if we should have a custom lemma for it)</p>",
        "id": 327521654,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1676286848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/270676-lean4/topic/weaker.20rfl.20after.20rw/near/327518084\">said</a>:</p>\n<blockquote>\n<p>Isn't <code>∘</code> notation for <code>Function.comp</code>? Though I don't know why it doesn't get pretty printed that way</p>\n</blockquote>\n<p>Right, I see. And I said \"an exact match, nothing to reduce\": that's not true at all. The goal is <code>(f ∘ g') x = f (g' x)</code>, which is <code>rfl</code> but not an exact equality and not <code>with_reducible rfl</code>.</p>",
        "id": 327523946,
        "sender_full_name": "Richard Copley",
        "timestamp": 1676287733
    }
]