[
    {
        "content": "<p>Hi everyone,</p>\n<p>I’m working on defining a syntax that looks like this:</p>\n<p><code>{x0 &gt; 0}</code>  <br>\nor<br>\n<code>{x1 = 2 /\\ 0 &lt;= x3 /\\ x0 = 0}</code></p>\n<p>The goal is for this syntax to evaluate to the following in the next step:</p>\n<p><code>fun n : Nat =&gt; {(n.add 0) &gt; 0}</code><br>\nor <br>\n<code>fun n : Nat =&gt; {(n.add 0) = 2 /\\ 0 &lt;= (n.add 3) /\\ (n.add 0) = 0}</code></p>\n<p>So every occurence of any <code>(xn)</code> with n being a numeral literal gets replaced. </p>\n<p>I’m trying to achieve this while adhering to the following constraints:</p>\n<ol>\n<li>Preserve existing term syntax: Avoid polluting or modifying the existing syntax category for terms.</li>\n<li>Reuse existing definitions: Ensure it’s not necessary to redefine all operations for natural numbers and propositions. However, if redefining them is unavoidable, I’d appreciate guidance on a simple, non-redundant approach to achieve this</li>\n</ol>\n<p>This is what I have so far: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span>\n\n<span class=\"n\">declare_syntax_cat</span><span class=\"w\"> </span><span class=\"n\">testSyntax</span>\n<span class=\"n\">declare_syntax_cat</span><span class=\"w\"> </span><span class=\"n\">toBeReplaced</span>\n\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">testSyntax</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"(x\"</span><span class=\"w\"> </span><span class=\"n\">num</span><span class=\"w\"> </span><span class=\"s2\">\")\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">toBeReplaced</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"n\">toBeReplaced</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">testSyntax</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"n\">toBeReplaced</span><span class=\"w\"> </span><span class=\"n\">testSyntax</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">testSyntax</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getNum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reg</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">`toBeReplaced</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">reg</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">toBeReplaced</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">num</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">getNat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">9999</span><span class=\"w\"> </span><span class=\"c1\">-- This is bad but I am lazy</span>\n\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">testFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">`testSyntax</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">TermElabM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">`term</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">testSyntax</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"n\">toBeReplaced</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">getNum</span><span class=\"w\"> </span><span class=\"n\">r</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">←`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{t}\"</span><span class=\"bp\">.</span><span class=\"n\">toName</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">testSyntax</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"n\">toBeReplaced</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">testSyntax</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">getNum</span><span class=\"w\"> </span><span class=\"n\">r</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">testFun</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">←`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{t1}\"</span><span class=\"bp\">.</span><span class=\"n\">toName</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">t2</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">testSyntax</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">←`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">t1</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">NOTHING</span><span class=\"o\">)</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"start\"</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">testSyntax</span><span class=\"w\"> </span><span class=\"s2\">\"end\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">processedTerm</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">testFun</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"w\">  </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">processedTerm</span>\n<span class=\"w\">  </span><span class=\"c1\">-- let result ← Lean.Elab.Term.elabTerm processedTerm (some (.const ``Nat []))</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">mkNatLit</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"c1\">-- return result</span>\n</code></pre></div>\n<p>However, this approach encounters the following issues:</p>\n<ul>\n<li>The <code>toBeReplaced</code> syntax is not replaced correctly when nested inside another term.</li>\n<li>Attempting to use individual components of the <code>toBeReplaced</code> syntax as operands in other expressions.</li>\n</ul>\n<p>I would really appreciate any input.</p>",
        "id": 485723220,
        "sender_full_name": "Marx",
        "timestamp": 1733180518
    },
    {
        "content": "<p>Likely you don't want a new syntax category but to parse a <code>term</code> and then recursively replace <code>ident</code>s inside of it. See <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Term.expandCDot%3F#doc\">docs#Lean.Elab.Term.expandCDot?</a> for a similar approach.</p>",
        "id": 485804218,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1733219669
    },
    {
        "content": "<p>Thank you for the suggestion, I'm gonna give it a try</p>",
        "id": 486349968,
        "sender_full_name": "Marx",
        "timestamp": 1733417170
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/channel/270676-lean4/topic/Replacing.20certain.20keywords.20during.20syntax.20evaluation/near/485804218\">said</a>:</p>\n<blockquote>\n<p>Likely you don't want a new syntax category but to parse a <code>term</code> and then recursively replace <code>ident</code>s inside of it. See <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Term.expandCDot%3F#doc\">docs#Lean.Elab.Term.expandCDot?</a> for a similar approach.</p>\n</blockquote>\n<p>So i've had a look at it and this look pretty much like what I could use. Unfortunately I find it very difficult to understand in detail. Could you provide me some further documentation or information about this. I would really appreciate that.</p>",
        "id": 486784398,
        "sender_full_name": "Marx",
        "timestamp": 1733676360
    }
]