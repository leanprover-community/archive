[
    {
        "content": "<p>I'm working through cleaning up and unifying the various <code>let</code>/<code>have</code> binding syntaxes in Lean, so that they have the same features (e.g. allowing <code>let := v</code>) and also adding things like <code>let (eq := h) x := v</code> to get an <code>h : x = v</code> in context, which also works with pattern matching by the way, as a synonym for doing <code>match h : v with | x =&gt; ...</code>.</p>\n<p>There are a couple things that are causing issues, to the point where it should get community feedback.</p>\n<p>I'll try to explain using some stream-of-conciousness bullet points:</p>\n<ul>\n<li>Design assumption: we want <code>let</code> and <code>have</code> to parse using the exact same rules. Rationale: differences make Lean more difficult to learn, and the only difference should be whether or not the value of the binding is visible in the local context.</li>\n<li>The \"anaphoric\" syntaxes <code>let := v</code> and <code>have := v</code> support binders, as in <code>have (x y) (h) := ...</code>, which creates a <code>this</code> function of three arguments.</li>\n<li>The syntaxes also support pattern matching, as in <code>let (x,y) := p</code></li>\n<li>However, there is an ambiguity with <code>let (rfl) := h</code>, which looks like a one-binder anaphoric <code>let</code>.</li>\n<li>I gave patterns in parentheses higher priority to compensate for this. So, <code>let (rfl) := h</code> parses as a pattern, rather than as a <code>this</code> function taking <code>rfl</code> as an argument.</li>\n<li>However, people legitimately are writing things like <code>have (x) := ...</code> in mathlib.</li>\n<li>That's easy to work around by writing <code>have (x : _) := ...</code> or <code>have this x := ...</code> or <code>have := fun x =&gt; ...</code>. (One-argument anaphoric <code>have</code> is kind of weird, right?)</li>\n<li>Anaphoric <code>have</code> with any number of binders is kind of weird, but it's well-used in mathlib, so it's staying.</li>\n<li>Another solution to the pattern problem could be to require more parentheses, like <code>let ((rfl)) := h</code>. Pattern matching seems more important than supporting anaphoric <code>let</code>/<code>have</code> with a single <code>(x)</code> binder. It's already confusing how <code>let ctor x y z := v</code> parses as a function definition rather than as <code>let (ctor x y z) := v</code>. Needing double parentheses seems rather obscure! How likely would someone guess to use double parentheses? (That all said, <code>rfl</code> is one of the few argument-free constructors — maybe <code>let rfl := ...</code> should be special syntax!)</li>\n</ul>",
        "id": 525168959,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750524294
    },
    {
        "content": "<p>I don't have any specific question here, other than perhaps <strong>\"Is breaking <code>have (x) := ...</code> OK given that there are many easy workarounds?\"</strong> (This breakage is for the case of a single typeless explicit binder in an anaphoric <code>let</code>/<code>have</code> only.)</p>",
        "id": 525168964,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750524298
    },
    {
        "content": "<p>I considered another solution where there could be special support looking for specifically the case <code>have (ctor) := ...</code> where <code>ctor</code> resolves to a constructor, then reinterpreting it as a pattern. However, I'm very uncomfortable with these sorts of reinterpretations, since it can make for brittle macros (in this case, a macro that thinks it's making an anaphoric <code>have</code>, and in fact the Syntax shows it thinks its making an anaphoric <code>have</code>, would sometimes result in a pattern match <code>have</code> if the user supplies the macro a length-one binder list with a binder of the form <code>(ctor)</code>. Not great!)</p>",
        "id": 525168965,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750524299
    },
    {
        "content": "<p>Hmm... I use <code>have (x) := ...</code> a huge lot, but maybe switching to <code>have this (x) := ...</code> is fine</p>",
        "id": 525169289,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750524779
    },
    {
        "content": "<p>Thanks for the feedback. Other alternatives include <code>have this x := ...</code> and <code>have (x : _) := ...</code>.</p>\n<p>(I might try to make a code action to propose one of these when <code>x</code> isn't a constructor.)</p>",
        "id": 525169378,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750524899
    },
    {
        "content": "<p>I think I've used it, but wouldn't mind losing it if I get rfl patterns instead</p>",
        "id": 525170408,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1750526376
    },
    {
        "content": "<p>I wasn't aware that anaphoric <code>have</code> could bind variables and find it looks super strange. So I guess we have all opinions covered <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 525171942,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1750528745
    },
    {
        "content": "<p>+1 for \"let and have should behave in the same way\" for sure, this has confused me several times in the past</p>",
        "id": 525176272,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750535735
    },
    {
        "content": "<p>I would rather have <code>let (x) :=</code> than <code>let rfl :=</code>, if I had to choose between them. You can write things like <code>let .rfl :=</code> if you want to make it clearly not a binder, vice versa is harder</p>",
        "id": 525189104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750558289
    },
    {
        "content": "<p>You can also have the syntax be ambiguous and just reinterpret it if you parsed it the wrong way. I recall there is some example of this already in lean where <code>have (x y) :=</code> ends up parsing <code>x y</code> as an application, and then it is destructured and turned back into a binder list</p>",
        "id": 525189148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750558392
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Cleanup.20of.20.60let.60.2F.60have.60.20syntaxes/near/525168965\">said</a>:</p>\n<blockquote>\n<p>(in this case, a macro that thinks it's making an anaphoric <code>have</code>, and in fact the Syntax shows it thinks its making an anaphoric <code>have</code>, would sometimes result in a pattern match <code>have</code> if the user supplies the macro a length-one binder list with a binder of the form <code>(ctor)</code>. Not great!)</p>\n</blockquote>\n<p>That would be a weird thing for a macro to do if it's not explicitly trying to break the system. You can always just put in <code>have this</code> in such cases.</p>",
        "id": 525189328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750558790
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/Cleanup.20of.20.60let.60.2F.60have.60.20syntaxes/near/525189328\">said</a>:</p>\n<blockquote>\n<p>You can always just put in <code>have this</code> in such cases.</p>\n</blockquote>\n<p>As a macro author you'd have to know that writing <code> `(have $bs* := $v; $b)</code> is dangerous, since when <code>bs.size = 1</code> then the <code>have</code> elaborator would be liable to reinterpret the binder as a pattern. I don't think it's fair to say that someone who writes this syntax quotation is \"explicitly trying to break the system\".</p>",
        "id": 525189958,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750559958
    },
    {
        "content": "<p>you can write <code>have this $bs*</code> in that example though</p>",
        "id": 525190146,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750560388
    },
    {
        "content": "<p>it's a hygienic <code>this</code> anyway, you would probably want the user to be able to name the binder</p>",
        "id": 525190171,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750560458
    }
]