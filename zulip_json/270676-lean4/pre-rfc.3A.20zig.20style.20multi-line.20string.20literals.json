[
    {
        "content": "<p>The Zig programming language has an interesting design with regards to its <a href=\"https://ziglang.org/documentation/master/#Multiline-String-Literals\">multi-line string literals</a>. Instead of the usual pair of triple-quotes <code>\"\"\"</code>, the <code>\\\\</code> operator (c.f. both twice a string escape backslash and the usual C-style <code>//</code> comment syntax) is used.</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">hello_world_in_c</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">    </span><span class=\"sh\">\\\\#include &lt;stdio.h&gt;</span>\n<span class=\"w\">    </span><span class=\"sh\">\\\\</span>\n<span class=\"w\">    </span><span class=\"sh\">\\\\int main(int argc, char **argv) {</span>\n<span class=\"w\">    </span><span class=\"sh\">\\\\    printf(\"hello world\\n\");</span>\n<span class=\"w\">    </span><span class=\"sh\">\\\\    return 0;</span>\n<span class=\"w\">    </span><span class=\"sh\">\\\\}</span>\n<span class=\"p\">;</span>\n</code></pre></div>\n<p>This <code>\\\\</code> operates similar to a <em>comment</em> -- it takes in as input any characters until the end of the line. It then <em>merges</em> with subsequent invocations of <code>\\\\</code>, so long as they immediately follow on the next line with only whitespace between (same as Lean's rules for <em>gaps</em>). These are then treated as one string literal: where the new <code>\\\\</code>s are treated as new newlines. The string literal is ended upon a line that does not start with <code>\\\\</code> as the first post-whitespace token.</p>\n<p>Zig is currently the only language that does this (<a href=\"https://github.com/ziglang/zig/issues/162\">because they came up with it</a>). I really like this syntax! It's not very well known and I wish it was. I'm of the opinion it's a much better approach than the usual style. In particular, there are some distinct advantages:</p>\n<ol>\n<li>Newlines are overt. Does the final <code>\"</code> of a multi-line string literal ending on its own line add a <code>\\n</code> or not? What about the starting <code>\"</code>? What about preceding or trailing whitespace on either of those? Many languages have many different behaviors with the <em>de facto</em> multiline string syntax. Lean's behavior here is very reasonable, but not evident without needing to read the manual.</li>\n<li>String blocks appear at the same indentation level of the rest of the code (really, an arbitrary indentation). This helps with readability. It also helps with clarity: I know of some languages that instead <em>implicitly</em> trim leading whitespace within their multi-line strings to support this (which has made me wary of the syntax ever since). Zig appears to use this especially wrt. inline assembly and C, but it's more generally useful.</li>\n<li>This syntax doubles as a raw string literal syntax in an elegant fashion. (See <a href=\"https://github.com/ziglang/zig/issues/8540\">https://github.com/ziglang/zig/issues/8540</a> for examples.) The <code>\\\\</code> character takes in input until a newline. It doesn't matter what follows, so long as it is not a newline -- escapes can be treated literally, a literal <code>\\\\</code> can be recognized, <em>any</em> number of literal <code>\\\\</code>s can be recognized.</li>\n</ol>\n<p>Would the Lean community be interested in such a feature? Is the double <code>\\\\</code> available? I think this is clearer than multiline <code>\"\"</code> and better than the existing <code>r\"\"</code>, though it could exist alongside or replace either or both. If so, I can write this up into a proper RFC and stick it somewhere (and maybe take a stab at implementing it to learn some about the compiler internals. i don't believe it's doable purely in terms of macros? you would have to recognize this regex pattern: <code>\\\\\\\\[^\\n]*(\\n *\\\\\\\\[^\\n]*)*</code>)</p>\n<p>I'm not a Zig aficionado (just watch it from afar) but my impression is they're all broadly happy with this syntax. (The language creator <a href=\"https://github.com/ziglang/zig/issues/162#issuecomment-407858363\">certainly is</a>.) Since Lean is in a stage where it's not afraid to make breaking changes, I thought I'd pitch this to see what people think.</p>",
        "id": 533394677,
        "sender_full_name": "JJ",
        "timestamp": 1754626942
    },
    {
        "content": "<p>We already have this, just using <code>\\</code> at the end of a line.</p>",
        "id": 533398251,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1754629875
    },
    {
        "content": "<p>It's very different!</p>\n<p>The Zig <code>\\\\</code> syntax eats whitespace following a newline up until the next <code>\\\\</code> character. The Lean string gaps syntax eats whitespace up until the next <em>non-whitespace</em> character. This means that the gaps syntax cannot support code blocks well (since the leading whitespace <em>must</em> be trimmed), and cannot support use as a raw string literal.</p>\n<p>The newlines preceding the whitespace-prefixed <code>\\\\</code> are also <em>kept</em> in the Zig string syntax, unlike with <code>\\</code>.</p>",
        "id": 533401069,
        "sender_full_name": "JJ",
        "timestamp": 1754632187
    },
    {
        "content": "<p>Here's an example that showcases how Zig's <code>\\\\</code> differs from Lean's  <code>\"</code> + <code>\\</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">str1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"String with </span><span class=\"se\">\\</span>\n<span class=\"s2\">             a gap\"</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">str2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"String with a gap\"</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">str1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">str2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">str3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">\\\\</span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">            </span><span class=\"bp\">\\\\</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">gap</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">str4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"String with</span><span class=\"se\">\\n</span><span class=\"s2\"> a gap\"</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">str3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">str4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 533401352,
        "sender_full_name": "JJ",
        "timestamp": 1754632427
    },
    {
        "content": "<p>Here is another example showing the utility of a <code>\\\\</code> syntax.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">prefix_strings</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">\\\\</span><span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">lctx</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">                      </span><span class=\"bp\">\\\\</span><span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">fvarIdToDecl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">decls</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">decls</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">                      </span><span class=\"bp\">\\\\</span><span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">lctx</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"n\">fvarId</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">                      </span><span class=\"bp\">\\\\</span><span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\">      </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"s2\">\"oops! string\"</span>\n<span class=\"w\">                      </span><span class=\"bp\">\\\\</span><span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">                      </span><span class=\"bp\">\\\\</span><span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">decl</span>\n<span class=\"w\">                      </span><span class=\"bp\">\\\\</span><span class=\"w\">      </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">fvarIdToDecl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"bp\">.</span><span class=\"n\">fvarId</span><span class=\"w\"> </span><span class=\"n\">decl</span>\n<span class=\"w\">                      </span><span class=\"bp\">\\\\</span><span class=\"w\">        </span><span class=\"n\">decls</span><span class=\"w\">        </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">decls</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"bp\">.</span><span class=\"n\">index</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">normal_strings</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"  match lctx with</span>\n<span class=\"s2\">  | { fvarIdToDecl := map, decls := decls } =&gt;</span>\n<span class=\"s2\">    match lctx.find? fvarId with</span>\n<span class=\"s2\">    | none      =&gt; </span><span class=\"se\">\\\"</span><span class=\"s2\">oops! string</span><span class=\"se\">\\\"</span>\n<span class=\"s2\">    | some decl =&gt;</span>\n<span class=\"s2\">      let decl := f decl</span>\n<span class=\"s2\">      { fvarIdToDecl := map.insert decl.fvarId decl</span>\n<span class=\"s2\">        decls        := decls.set decl.index decl }\"</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">gap_strings</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"  match lctx with</span><span class=\"se\">\\</span>\n<span class=\"s2\">                  </span><span class=\"se\">\\n</span><span class=\"s2\">  | { fvarIdToDecl := map, decls := decls } =&gt;</span><span class=\"se\">\\</span>\n<span class=\"s2\">                  </span><span class=\"se\">\\n</span><span class=\"s2\">    match lctx.find? fvarId with</span><span class=\"se\">\\</span>\n<span class=\"s2\">                  </span><span class=\"se\">\\n</span><span class=\"s2\">    | none      =&gt; </span><span class=\"se\">\\\"</span><span class=\"s2\">oops! string</span><span class=\"se\">\\\"\\</span>\n<span class=\"s2\">                  </span><span class=\"se\">\\n</span><span class=\"s2\">    | some decl =&gt;</span><span class=\"se\">\\</span>\n<span class=\"s2\">                  </span><span class=\"se\">\\n</span><span class=\"s2\">      let decl := f decl</span><span class=\"se\">\\</span>\n<span class=\"s2\">                  </span><span class=\"se\">\\n</span><span class=\"s2\">      { fvarIdToDecl := map.insert decl.fvarId decl</span><span class=\"se\">\\</span>\n<span class=\"s2\">                  </span><span class=\"se\">\\n</span><span class=\"s2\">        decls        := decls.set decl.index decl }</span><span class=\"se\">\\</span>\n<span class=\"s2\">                   \"</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">raw_strings</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">#</span><span class=\"s2\">\"  match lctx with</span>\n<span class=\"s2\">  | { fvarIdToDecl := map, decls := decls } =&gt;</span>\n<span class=\"s2\">    match lctx.find? fvarId with</span>\n<span class=\"s2\">    | none      =&gt; \"</span><span class=\"n\">oops!</span><span class=\"w\"> </span><span class=\"n\">string</span><span class=\"s2\">\"</span>\n<span class=\"s2\">    | some decl =&gt;</span>\n<span class=\"s2\">      let decl := f decl</span>\n<span class=\"s2\">      { fvarIdToDecl := map.insert decl.fvarId decl</span>\n<span class=\"s2\">        decls        := decls.set decl.index decl }\"</span><span class=\"bp\">#</span>\n\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">prefix_strings</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">normal_strings</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">normal_strings</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">gap_strings</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">normal_strings</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">raw_strings</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>The <code>\\\\</code> style is more amenable to large strings of verbatium text containing newlines. With <code>\\</code>, you lose newlines. Without <code>\\</code>, you give up having a consistent indentation level. In either case, you will have to fix escapes, and if you use <code>r\"\"</code> you both consign yourself to giving up <code>\\</code> and worrying about nested <code>\"</code>.</p>",
        "id": 533403599,
        "sender_full_name": "JJ",
        "timestamp": 1754633854
    },
    {
        "content": "<p>(Actually, maybe I should have opened this with discussing <code>r#\"\"#</code>. I didn't realize just how big an improvement this would be over it for multi-line strings until now.)</p>",
        "id": 533403867,
        "sender_full_name": "JJ",
        "timestamp": 1754634024
    },
    {
        "content": "<p>To get <code>str4</code> in Lean, I just write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">str1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"String with </span><span class=\"se\">\\n\\</span>\n<span class=\"s2\">             a gap\"</span>\n</code></pre></div>\n<p>It works very well.</p>",
        "id": 533415828,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1754640057
    },
    {
        "content": "<p>Right. That example was for explaining the difference between Zig <code>\\\\</code> and Lean <code>\\</code>, not for motivating it. See the next set of examples for motivation.</p>",
        "id": 533416747,
        "sender_full_name": "JJ",
        "timestamp": 1754640433
    },
    {
        "content": "<p>(by the way, if not already clear -- this syntax would complement <code>\"\"</code> and <code>\\</code>, could-possibly-replace <code>r#\"\"#</code>)</p>",
        "id": 533417235,
        "sender_full_name": "JJ",
        "timestamp": 1754640623
    },
    {
        "content": "<p><code>gap_strings</code> in <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/pre-rfc.3A.20zig.20style.20multi-line.20string.20literals/near/533403599\">#lean4 &gt; pre-rfc: zig style multi-line string literals @ ðŸ’¬</a> was one of the intended ways of getting multiline strings (it appears not to have been included in the RFC though, <a href=\"https://github.com/leanprover/lean4/pull/2838\">lean4#2838</a>)</p>\n<p>Something neat about Lean is that the different string syntaxes give you the tools you need to add your own multiline strings on top of it. In <a href=\"https://github.com/leanprover/lean4/blob/ad471b46b80fb4cc5576941bba7caa1b43fcaf5c/tests/lean/run/string_gaps.lean#L138-L166\">tests/lean/run/string_gaps.lean</a> there's an example with user-defined \"<code>d!</code>\" strings:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">d!</span><span class=\"s2\">\"this is </span><span class=\"se\">\\</span>\n<span class=\"s2\">            line 1</span>\n<span class=\"s2\">        |  line 2, indented</span>\n<span class=\"s2\">        |line 3\"</span>\n<span class=\"c1\">-- `\"this is line 1\\n  line 2, indented\\nline 3\"`</span>\n</code></pre></div>\n<p>This transformation is done at compile time too.</p>\n<p>It works with raw strings, though it needs a space between <code>d!</code> and <code>r</code> because <code>d!r</code> is a valid identifier:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">d!</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">#</span><span class=\"s2\">\"this is line 1</span>\n<span class=\"s2\">           |  line 2, indented</span>\n<span class=\"s2\">           |line 3\"</span><span class=\"bp\">#</span>\n</code></pre></div>",
        "id": 533473871,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754662984
    },
    {
        "content": "<p>For the zig style strings, if you had a function <code>f : String -&gt; String -&gt; Nat</code>, how would you call <code>f</code> with two multiline strings?</p>",
        "id": 533629300,
        "sender_full_name": "Niels Voss",
        "timestamp": 1754809960
    },
    {
        "content": "<p>It also seems less natural to wrap the strings in parentheses, since you'd need the closing parenthesis on its own line. Although maybe this isn't that big of a deal.</p>",
        "id": 533629396,
        "sender_full_name": "Niels Voss",
        "timestamp": 1754810083
    },
    {
        "content": "<p>In any case, I think the largest problem with trying to use zig strings in Lean is the lack of explicit delimiters, not the indentation markers (kotlin uses indentation markers plus a .trim function, for example) because that causes parsing ambiguity and makes things like dot notation more tedious</p>",
        "id": 533630065,
        "sender_full_name": "Niels Voss",
        "timestamp": 1754810850
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/270676-lean4/topic/pre-rfc.3A.20zig.20style.20multi-line.20string.20literals/near/533629300\">said</a>:</p>\n<blockquote>\n<p>For the zig style strings, if you had a function <code>f : String -&gt; String -&gt; Nat</code>, how would you call <code>f</code> with two multiline strings?</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- With Zig-style multiline strings:</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">\\\\</span><span class=\"w\"> </span><span class=\"n\">This</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">my</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">first</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">string</span><span class=\"bp\">.</span>\n<span class=\"w\">             </span><span class=\"bp\">\\\\</span><span class=\"w\"> </span><span class=\"n\">It</span><span class=\"w\"> </span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"n\">multiple</span><span class=\"w\"> </span><span class=\"n\">lines</span><span class=\"bp\">.</span>\n\n<span class=\"w\">             </span><span class=\"bp\">\\\\</span><span class=\"w\"> </span><span class=\"n\">This</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">my</span><span class=\"w\"> </span><span class=\"s2\">\"{second}\"</span><span class=\"w\"> </span><span class=\"bp\">\\\\</span><span class=\"w\"> </span><span class=\"n\">string</span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">It</span><span class=\"w\"> </span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"n\">line</span><span class=\"bp\">.</span>\n<span class=\"c1\">-- As stands, using d! strings and r#...# strings to avoid escapes and capture newlines:</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">d!</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">#</span><span class=\"s2\">\"This is my {first} string.</span>\n<span class=\"s2\">                   It contains multiple lines.\"</span><span class=\"bp\">#</span>\n<span class=\"w\">             </span><span class=\"n\">r</span><span class=\"bp\">#</span><span class=\"s2\">\"This is my \"</span><span class=\"o\">{</span><span class=\"n\">second</span><span class=\"o\">}</span><span class=\"s2\">\" </span><span class=\"se\">\\\\</span><span class=\"s2\"> string. It contains one line.\"</span><span class=\"bp\">#</span>\n</code></pre></div>\n<blockquote>\n<p>In any case, I think the largest problem with trying to use zig strings in Lean is the lack of explicit delimiters, not the indentation markers (kotlin uses indentation markers plus a .trim function, for example) because that causes parsing ambiguity and makes things like dot notation more tedious</p>\n</blockquote>\n<p>Yeah. I have not yet learned Lean's metaprogramming, so I do not know how feasible this is for the parser.</p>",
        "id": 534735219,
        "sender_full_name": "JJ",
        "timestamp": 1755315235
    }
]