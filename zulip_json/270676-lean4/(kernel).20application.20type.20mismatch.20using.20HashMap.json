[
    {
        "content": "<p>This is simplified from my actual use case, but I can't seem to put a hash map whose target type is the type being defined in an inductive type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">NodeThing</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">LeafThing</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span>\n</code></pre></div>\n<p>Error message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">kernel</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">DHashMap</span><span class=\"bp\">.</span><span class=\"n\">Raw</span><span class=\"bp\">.</span><span class=\"n\">WF</span><span class=\"w\"> </span><span class=\"n\">inner</span>\n<span class=\"n\">argument</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"bp\">@_</span><span class=\"n\">nested</span><span class=\"bp\">.</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">DHashMap</span><span class=\"bp\">.</span><span class=\"n\">Raw_3</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">✝</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">DHashMap</span><span class=\"bp\">.</span><span class=\"n\">Raw</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>Note that the simpler case where the hashmap target is just <code>V</code> works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">NodeThing</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">LeafThing</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span>\n</code></pre></div>\n<p>This is on Lean 4.22.0-rc3.</p>",
        "id": 529365223,
        "sender_full_name": "Valentin Robert",
        "timestamp": 1752791721
    },
    {
        "content": "<p>You have to use <code>Std.HashMap.Raw</code> in this case.</p>",
        "id": 529399134,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1752820434
    },
    {
        "content": "<p>If you read the documentation of <code>Std.HashMap</code>, at the end is says:</p>\n<blockquote>\n<p>These hash maps contain a bundled well-formedness invariant, which means that they cannot be used in nested inductive types. For these use cases, Std.Data.HashMap.Raw and Std.Data.HashMap.Raw.WF unbundle the invariant from the hash map. When in doubt, prefer HashMap over HashMap.Raw.</p>\n</blockquote>\n<p>In other words, because of limitations of Lean, <code>Std.HashMap</code> cannot be used for nested inductives; but <code>Std.HashMap.Raw</code> does.</p>",
        "id": 529403825,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1752822885
    },
    {
        "content": "<p>There is more information about this in the reference manual: <a href=\"https://lean-lang.org/doc/reference/latest//Basic-Types/Maps-and-Sets/#raw-data\">https://lean-lang.org/doc/reference/latest//Basic-Types/Maps-and-Sets/#raw-data</a> It also contains an example of how to use the <code>Raw</code> variant.</p>",
        "id": 529409989,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1752825610
    }
]