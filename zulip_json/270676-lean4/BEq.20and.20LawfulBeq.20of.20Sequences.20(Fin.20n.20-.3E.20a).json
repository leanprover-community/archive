[
    {
        "content": "<p>Hello everyone!<br>\nI am kinda stuck, maybe I am not seeing something trivial here.<br>\nLet me know if this channel is not the correct one.</p>\n<p>So, I want to define BEq and LawfulBEq for finite Sequences.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Sequence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>So, I would like to define a simple BEq as there are several ways to do it I<br>\nguess:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">beq_sequences</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Sequence</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">beq</span><span class=\"w\"> </span><span class=\"n\">sl</span><span class=\"w\"> </span><span class=\"n\">sr</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">   </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">   </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">pn</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">headSeq</span><span class=\"w\"> </span><span class=\"n\">sl</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">headSeq</span><span class=\"w\"> </span><span class=\"n\">sr</span>\n<span class=\"w\">                  </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">beq_sequences</span><span class=\"bp\">.</span><span class=\"n\">beq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"n\">sl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"n\">sr</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>And finally, I would like to show something on the lines of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">law_full_beq_seq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">][</span><span class=\"n\">LawfulBEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LawfulBEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Sequence</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">eq_of_beq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>The problem is that when proving 'eq_of_beq' I have no way of getting<br>\ninformation from the statement '(a == b) = true'. I gave one definition of<br>\n'(==)' before at 'beq_sequences', but here '==' may be something else.</p>\n<p>Does that make sense? What do you recomend?</p>\n<p>I am using these Sequences for something else and it should be rudimentary.<br>\nThe 'main' proof of this section is about a transformation from sequences to<br>\ntrees and back. Something on the lines of:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">split_seq_eq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}{</span><span class=\"w\"> </span><span class=\"n\">mLTn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">}(</span><span class=\"w\"> </span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Sequence</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">):</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">seql</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">seqr</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">splitSeq</span><span class=\"w\"> </span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">mLTn</span>\n<span class=\"w\">  </span><span class=\"n\">HEq</span><span class=\"w\"> </span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">concatSeq</span><span class=\"w\"> </span><span class=\"n\">seql</span><span class=\"w\"> </span><span class=\"n\">seqr</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">concat_perfect_split</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}(</span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Sequence</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">seql</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">seqr</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">seqPerfectSplit</span><span class=\"w\"> </span><span class=\"n\">seq</span>\n<span class=\"w\">  </span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">concatSeq</span><span class=\"w\"> </span><span class=\"n\">seql</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">seqr</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Thank you very much for your time!</p>",
        "id": 489758492,
        "sender_full_name": "Martin Ceresa",
        "timestamp": 1734528748
    },
    {
        "content": "<p>it seems that the <code>BEq</code> and <code>LawfulBEq</code> variants of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.decidablePiFintype#doc\">docs#Fintype.decidablePiFintype</a> are missing (and exactly what you need)</p>",
        "id": 489763066,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734530286
    },
    {
        "content": "<p>(although that will result in slightly different defeq for you)</p>",
        "id": 489763117,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734530310
    },
    {
        "content": "<p>True! Maybe I can take some inspiration from the ones already defined!<br>\nThanks!!</p>",
        "id": 489763543,
        "sender_full_name": "Martin Ceresa",
        "timestamp": 1734530435
    },
    {
        "content": "<p>Well, I ended up doing something not so very nice, just to be sure that I am in the good (?) path:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">split_seq_eq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}{</span><span class=\"w\"> </span><span class=\"n\">mLTn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">}(</span><span class=\"w\"> </span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Sequence</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">):</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">seql</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">seqr</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">splitSeq</span><span class=\"w\"> </span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">mLTn</span>\n<span class=\"w\">  </span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">sequence_coerce</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">concatSeq</span><span class=\"w\"> </span><span class=\"n\">seql</span><span class=\"w\"> </span><span class=\"n\">seqr</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The function sequencu_coerce simply enable me to match sequence lenghts:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">sequence_coerce</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}(</span><span class=\"w\"> </span><span class=\"n\">hEq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">)(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Sequence</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Sequence</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>With that and some funext, it is easy to prove.<br>\nI will take a look to see if I can define some more generic notions and maybe suggest something nice :D!<br>\nIt is a way of having a notion of hidden <code>HEq</code>, but it is working fine :D</p>\n<p>Cheers!!</p>",
        "id": 489767574,
        "sender_full_name": "Martin Ceresa",
        "timestamp": 1734531621
    },
    {
        "content": "<p>Just to check, are you defining <code>BEq</code> for programming purposes? Will you ever be wanting to use <code>Sequence</code> with an underlying type that doesn't satisfy <code>LawfulBEq</code>?</p>\n<p>If the answer to the first question is \"no\", then you may as well use plain old <code>=</code> instead. Otherwise, if the answer to the second question is \"no\", it might be better to define a <code>DecidableEq</code> instance instead of defining <code>BEq</code>.</p>",
        "id": 489818381,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734546678
    },
    {
        "content": "<p>Side note: you likely don't want the definition of <code>Sequence</code> to be <code>abbrev</code>, given that you are putting instances on it. The effect is actually that you're putting an instance on <code>Fin n -&gt; α</code> itself, since the typeclass system unfolds <code>abbrev</code>s.</p>",
        "id": 489818537,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734546738
    },
    {
        "content": "<p>Here's a DecidableEq instance in case it's helpful (I have mathlib imported, and I haven't checked that the simps are not making use of mathlib or batteries theorems). You might like the <code>Sequence.beq</code> definition. I found that rewriting with <code>Nat.all_eq_finRange_all</code> enables a reduction to a forall, and then simp handles the rest.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Sequence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Sequence</span><span class=\"bp\">.</span><span class=\"n\">beq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sl</span><span class=\"w\"> </span><span class=\"n\">sr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Sequence</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">sl</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">sr</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Sequence</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">sl</span><span class=\"w\"> </span><span class=\"n\">sr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">decidable_of_iff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Sequence</span><span class=\"bp\">.</span><span class=\"n\">beq</span><span class=\"w\"> </span><span class=\"n\">sl</span><span class=\"w\"> </span><span class=\"n\">sr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">constructor</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">        </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">funext</span>\n<span class=\"w\">        </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Sequence</span><span class=\"bp\">.</span><span class=\"n\">beq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">all_eq_finRange_all</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Sequence</span><span class=\"bp\">.</span><span class=\"n\">beq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">all_eq_finRange_all</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 489820171,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734547323
    },
    {
        "content": "<p>Hello! What I am implementing in Lean is not purely mathematical, but a mix between programming and proving. If that anwsers the your questions.<br>\nI thought the usual steps were to define <code>BEq</code> and then <code>LawfulBEq</code>, but it seems I am wrong.</p>\n<p>I developed almost everything without instances so far and <code>abbrev</code> was working just fine. Although defining <code>Sequences</code> as it's own \"type\" may be a good idea in a final version.</p>\n<p>The endgoal here is to have something close to <code>HEq</code> actually. \"Heterogeous\" in the length of the Sequence. When you start working with sequences, some operations may modify the length of the sequences, and thus, we need to have a notion that enable us to prove equivalence while computing at the length parameter.<br>\nI called that <code>sequence_coerce</code> and just used <code>=</code> as you suggested <span aria-label=\"muscle\" class=\"emoji emoji-1f4aa\" role=\"img\" title=\"muscle\">:muscle:</span> . The problem here is that I need to explictly use this coerce function when I am manipulating the length and make some extra annotations.</p>\n<p>I was worried because I was not understanding how to prove it. But I think I was wrong about instances, <code>DecidableEq</code> seems to be what I wanted.</p>",
        "id": 489894606,
        "sender_full_name": "Martin Ceresa",
        "timestamp": 1734589761
    },
    {
        "content": "<p>Also, funny thing. My <code>Nat.all</code> is different from yours.<br>\nThe documentation <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Nat/Fold.html\">here</a> says it has the type you have, but the use part <code>all f n = true</code> is wrong.<br>\nMaybe I need to update my system.</p>",
        "id": 489897208,
        "sender_full_name": "Martin Ceresa",
        "timestamp": 1734591447
    },
    {
        "content": "<p>Okay, last notes.</p>\n<ul>\n<li>Mathlib is required, in particular<code>List.mem_finRange</code> mapping elements from <code>Fin n</code> to <code>finRange</code> (basically).</li>\n<li>So, my original question was how to get something to work with, because when defining a definition of <code>BEq</code> I am just giving one but when proving <code>LawfulEq</code> I did no have it in my context. I think this is what <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> showed me how to do it properly through <code>decidable_of_iff</code> (plus some useful questions and insights). Thanks a lot!!</li>\n</ul>",
        "id": 489909639,
        "sender_full_name": "Martin Ceresa",
        "timestamp": 1734596939
    },
    {
        "content": "<p>If you want to work with finite sequences of varying lengths, it's hard to beat <code>List α</code>. You can restrict to particular lengths like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Sequence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>(In mathlib this is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Vector#doc\">docs#Mathlib.Vector</a>, though it's not particularly well developed.)</p>",
        "id": 490015497,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734629137
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"767337\">Martin Ceresa</span> <a href=\"#narrow/channel/270676-lean4/topic/BEq.20and.20LawfulBeq.20of.20Sequences.20.28Fin.20n.20-.3E.20a.29/near/489894606\">said</a>:</p>\n<blockquote>\n<p>I thought the usual steps were to define <code>BEq</code> and then <code>LawfulBEq</code></p>\n</blockquote>\n<p><code>=</code> is the true mathematical equality that every type comes with, and <code>BEq</code> is a user-implemented operation that happens to be equivalent to <code>=</code> if you prove <code>LawfulBEq</code>. Generally <code>=</code> is easier to work with, since to work with <code>==</code> in proofs you usually have to convert it to <code>=</code> first anyway.</p>\n<p>I think this tends to trip up people who come from languages like Haskell, where you need to implement a typeclass to get access to <code>=</code> at all. In programming there's usually not a concept of true mathematical equality, since it's not something you can necessarily compute with. But Lean does come with such an equality. Lean has this decidability system to synthesize decision procedures for mathematical concepts; the <code>DecidableEq</code> instance for example lets an <code>=</code> that appears in an <code>if</code> condition to be evaluated.</p>",
        "id": 490016694,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734629554
    },
    {
        "content": "<p>(<code>Mathlib.Vector</code> was just renamed to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Vector#doc\">docs#List.Vector</a>)</p>",
        "id": 490073407,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1734655325
    },
    {
        "content": "<p>I am checking <code>List.Vector</code> and it has kinda the same operations that I defined. That's cool, I am going to port it (one of these days).<br>\nThank you!!</p>",
        "id": 490100468,
        "sender_full_name": "Martin Ceresa",
        "timestamp": 1734675500
    }
]