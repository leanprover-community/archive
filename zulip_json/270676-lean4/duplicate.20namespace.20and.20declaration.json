[
    {
        "content": "<p>I have some function names that overlap, but are about different things. For example, I have <code>kleene_closure</code>, where in one case it refers to strings and in the other to languages. In a similar manner I have <code>derivative</code>, where in one case it refers to languages and in the other it refers to regular expressions. I was managing this by putting them into different namespaces, <code>Strings</code>, <code>Languages</code>, <code>RegExp</code>, but I also have types defined with those names. For example</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">RegExp</span>\n\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">RegExp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">char</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">RegExp</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">epsilon</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegExp</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegExp</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegExp</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">RegExp</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">RegExp</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">concat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegExp</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">RegExp</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">RegExp</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">kleene_closure</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegExp</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">RegExp</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"m\">3</span>\n<span class=\"n\">Messages</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">RegExp</span><span class=\"bp\">.</span><span class=\"n\">lean</span><span class=\"o\">:</span><span class=\"mi\">14</span><span class=\"o\">:</span><span class=\"mi\">10</span>\n<span class=\"n\">The</span><span class=\"w\"> </span><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">RegExp'</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">duplicated</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">declaration</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">RegExp</span><span class=\"bp\">.</span><span class=\"n\">RegExp'</span>\n<span class=\"n\">note</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"w\"> </span><span class=\"n\">can</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">disabled</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"ss\">`set_option</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">dupNamespace</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"bp\">`</span>\n</code></pre></div>\n<p>The linter does not appear to like this. I could turn off the linter, or slightly change one of the names, but I'm wondering if there is another way to address this, or something canonical.</p>",
        "id": 472118166,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727061985
    },
    {
        "content": "<p>You can move the type outside of the namespace - the constructors would still be e.g. <code>RegExp.kleene_closure</code></p>",
        "id": 472118253,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727062079
    },
    {
        "content": "<p>I think I tried that, and something went wrong, but I forget what. I'll try again.</p>",
        "id": 472118370,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727062184
    },
    {
        "content": "<p>Ok, this is what happened when I moved the inductive definition of <code>Language</code> outside of the namespace <code>Language</code>. In another file that transitively imports the file containing that definition, I have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Language</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"bp\">.</span><span class=\"n\">is_nullable</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">L</span>\n</code></pre></div>\n<p>because I want to do things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">is_nullable_iff_nullify_eq_eps_singleton</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">is_nullable</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">nullify</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{[]}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>\n<p>where I have <code>L.is_nullable</code> instead of <code>Language.is_nullable L</code>. But I didn't realize I could still do the same thing if I removed the <code>Language.</code> prefix from the definition.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Language</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">is_nullable</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">L</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">is_nullable_iff_nullify_eq_eps_singleton</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">is_nullable</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">nullify</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{[]}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>\n<p>So I think that works. Thank you.</p>",
        "id": 472119425,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727063017
    },
    {
        "content": "<p>I think moving the type outside the namespace like that is intended to be the canonical pattern here, as that lets you define <code>foo (a : RegExp A) : ...</code> within <code>namespace RegExp</code> later on and call it on any <code>x : RegExp A</code> with dot syntax (<code>x.foo</code>).</p>",
        "id": 472143399,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1727074478
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 472278007,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727109003
    }
]