[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">blah</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">iteInduction</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"n\">hy</span>\n</code></pre></div>\n<p>this (with no imports) works fine. But <code>exact?</code> does not close the goal, even though iteInduction is a ??totally normal?? theorem, and the only arguments are hx and hy, and everything is an exact expression equality afaict (no \"merely\" defeq fits going on). Can someone explain to me why?</p>",
        "id": 537198999,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756780539
    },
    {
        "content": "<p><code>iteInduction</code> doesn't seem to be used a lot</p>",
        "id": 537199733,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756780992
    },
    {
        "content": "<p>Yes, for good reason, it's kind of awkward (<code>split</code> or <code>split_ifs</code> is usually better). It's more a question of why exact? doesn't find it.</p>",
        "id": 537199770,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756781041
    },
    {
        "content": "<p>Probably the answer is that your conclusion is a free variable applied to stuff</p>",
        "id": 537199784,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756781064
    },
    {
        "content": "<p>so it's hard to unify</p>",
        "id": 537199795,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756781075
    },
    {
        "content": "<p>ah! Like there's no key for the discrimination tree? Did I say that right? That would make sense.</p>",
        "id": 537199808,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756781102
    },
    {
        "content": "<p>I guess it just finds <code>p</code> as the head, doesn't know what to do with that, and gives up. Hm.</p>",
        "id": 537199837,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756781133
    },
    {
        "content": "<p>That's too bad. I like to think of exact? as \"if there's one theorem in the library that will solve this, find it and use it!\". But no.</p>",
        "id": 537199878,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756781170
    },
    {
        "content": "<p>It also often won't find theorems whose conclusion is <code>A = B</code>.</p>",
        "id": 537327463,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756831663
    },
    {
        "content": "<p>Yep, theorems whose conclusion is a free variable, or an equality of free variables where the type is a free variable, are not indexed by <code>exact?</code> for efficiency reasons.</p>",
        "id": 537356801,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1756843729
    },
    {
        "content": "<p>This is really a huge trap for new users. It would be really nice if <code>exact?</code> could detect that the goal looks like this and print a warning message suggesting to try some new <code>slow_exact?</code> doing what the Lean 3 version was doing (simply try to apply all lemmas).</p>",
        "id": 537408121,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1756880727
    },
    {
        "content": "<p>Yes please, I would merge that PR! :-)</p>",
        "id": 537414065,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1756883649
    },
    {
        "content": "<p>Probably just a flag <code>exact? +all</code> would do. I like the warning idea, that hadn't occurred to me!</p>",
        "id": 537414138,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1756883683
    },
    {
        "content": "<p>There's actually a spot more than \"try to apply all lemmas\": you can do <code>exfalso</code> first and then trying applying all lemmas. :) (Or, <code>by_contra</code> first, which is slightly stronger.)</p>\n<p>Example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">NeBot</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Disjoint</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">solve_by_elim</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">NeBot</span><span class=\"bp\">.</span><span class=\"n\">not_disjoint</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Here <code>solve_by_elim</code> is able to (with the help of one extra library lemma) prove False and close the goal. <code>exact?</code> and <code>exfalso; exact?</code> both don't work. If there was a <code>slow_exact?</code>, I would hope it could catch things like this too!</p>",
        "id": 537521220,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756919358
    },
    {
        "content": "<p>Another example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">by_contra</span>\n<span class=\"w\">  </span><span class=\"n\">solve_by_elim</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">not_prime_of_dvd_of_ne</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 537521861,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756919590
    },
    {
        "content": "<p>This feels like mission creep really.</p>",
        "id": 537546901,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756930227
    },
    {
        "content": "<p>Fundamentally <code>apply?</code>, and hence <code>exact?</code>, are backwards reasoning tactics. This means that they infer what to apply directly from the shape of the goal. If the goal is <code>False</code>, or a free variable, then this strategy is simply too inefficient. Though feel free to try and implement a better strategy :).</p>",
        "id": 537549665,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1756931300
    },
    {
        "content": "<p>That's fair to call it mission creep! I just like automation that helps people find relevant stuff. So maybe this isn't \"exact?\" any more, but it's functionality I would enjoy seeing exist... Maybe under a different name, like <code>find_one_lemma</code> or something </p>\n<p>What is \"simply too inefficient\"? Like this would take five minutes, an hour?</p>",
        "id": 537549998,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756931427
    },
    {
        "content": "<p>Hmm, good question, I'm not sure how long such a thing would actually take. But another question is, even if the speed was there, how useful would it be to apply recursor-like theorems. Applying a recursor is hard, and will only work if the conclusion has exactly the right shape. This is the case in your original example, but if you replace <code>p</code> with a more complicated thing, it won't work at all.</p>",
        "id": 537551175,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1756931957
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span>, <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>, <a href=\"https://github.com/leanprover/lean4/pull/11494\">lean#11494</a> ensures that this lemma is found. In fact, hopefully we recover the old mathlib3 behaviour, as now all \"unindexable\" lemmas (i.e. DiscrTree keys <code>[*]</code> and <code>[Eq.eq, *, *, *]</code>) are tried in a second pass automatically. You can disable this with <code>exact? -start</code>.</p>",
        "id": 561988402,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1764888720
    },
    {
        "content": "<p>I'm particularly interested if anyone has reports of <code>exact?</code> timing out or being very slow, as I have a PR ready to install parallelism in <code>exact?</code> at <a href=\"https://github.com/leanprover/lean4/pull/11369\">lean#11369</a>, but I don't yet have convincing evidence it helps!</p>\n<p>(In particular, making this useful probably requires not parallelising every task, but chunking to limit the task overhead, and I need some good slow examples to tune this on.)</p>",
        "id": 561988557,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1764888798
    },
    {
        "content": "<p>Exciting! I'll be curious to try this out. :)</p>",
        "id": 562018440,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1764908742
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span>, I'm looking forward to you trying out the new <code>exact? +grind</code>. Sometimes it is too expensive (examples where it is slow very welcome!!) but it gives some lovely results. (It's the same first stage as <code>exact?</code>, but instead of solely relying on <code>solve_by_elim</code> to discharge the hypotheses, it can also use <code>grind</code>. So often slight mismatches get covered by <code>grind</code>, particularly small arithmetical differences.)</p>",
        "id": 562219801,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1765000674
    },
    {
        "content": "<p>Is the idea to evaluate possibly making grind the default discharger? Or just stay an alternate?</p>",
        "id": 562240038,
        "sender_full_name": "Julian Berman",
        "timestamp": 1765025149
    },
    {
        "content": "<p>What kind of terms does exact? +grind produce? Is it always <code>grind [one_extra_library_thm]</code>?</p>",
        "id": 562253974,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1765041646
    },
    {
        "content": "<p>I think <code>exact some_kind_of_theorem x y hxy (by grind) (by grind)</code></p>",
        "id": 562266198,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1765055777
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/channel/270676-lean4/topic/exact.3F.20can't.20find.20theorem/near/562240038\">said</a>:</p>\n<blockquote>\n<p>Is the idea to evaluate possibly making grind the default discharger? Or just stay an alternate?</p>\n</blockquote>\n<p>I would need many more user reports about its effectiveness / speed before considering this.</p>",
        "id": 562366483,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1765147028
    },
    {
        "content": "<p>If you're looking for suggestions like <code>grind [one_extra_library_thm]</code>, please try <code>grind +suggestions</code> (and, for those with in house AIs, please try out <code>set_library_suggestions</code>, and see if you can get your AI to make good suggestions!)</p>",
        "id": 562366522,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1765147097
    },
    {
        "content": "<p>I see, yeah it makes sense what Robin said, and I see why that falls much more naturally under exact? than what I was thinking. :)</p>",
        "id": 562366614,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1765147205
    }
]