[
    {
        "content": "<p>Is there a way to hide a given name when importing a module? <br>\nFor example in Mathlib 4 there exists the <code>Finmap</code> type, but I would like to use my own type with the same name. Is there a way to do something like?:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span> <span class=\"kn\">hiding</span> <span class=\"n\">Finmap</span>\n\n<span class=\"c1\">-- My own type:</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Finmap</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 338411840,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1677520913
    },
    {
        "content": "<p>The easy answer is \"don't import the file that defines <code>Finmap</code>\"</p>",
        "id": 338412233,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677520997
    },
    {
        "content": "<p>That is, use multiple <code>import Mathlib.TheFileYouActuallyNeed</code>s instead</p>",
        "id": 338412293,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677521014
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Hide.20from.20import/near/338412233\">said</a>:</p>\n<blockquote>\n<p>The easy answer is \"don't import the file that defines <code>Finmap</code>\"</p>\n</blockquote>\n<p>Oh right <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span><span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span></p>",
        "id": 338412495,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1677521058
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"372804\">Marcus Rossel</span> has marked this topic as resolved.</p>",
        "id": 338412521,
        "sender_full_name": "Notification Bot",
        "timestamp": 1677521065
    },
    {
        "content": "<p>The slightly more complex answer is either:</p>\n<ul>\n<li>Complain that <code>Mathlib</code> puts things in the global namespace. This has <a href=\"#narrow/stream/270676-lean4/topic/mathlib.3Aprelude/near/234611281\">come up</a> before, but I think is unlikely to change anytime soon.</li>\n<li>Put your own stuff in a <code>MyStuff</code> namespace so that it doesn't conflict.</li>\n</ul>",
        "id": 338412834,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677521145
    },
    {
        "content": "<p>Wait is <code>import Mathlib</code> a thing?</p>",
        "id": 338413837,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1677521386
    },
    {
        "content": "<p>Yes, Mathlib.lean is a file so you can import its .olean</p>",
        "id": 338414881,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1677521673
    },
    {
        "content": "<p>I basically do it all the time to figure out where stuff I need is coming from until we have a code action for automagic imports.</p>",
        "id": 338414958,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1677521699
    },
    {
        "content": "<p>Does it import every single file from Mathlib4?<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib.lean\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib.lean</a></p>",
        "id": 338415435,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1677521834
    },
    {
        "content": "<p>yes the file is generated by some script that stuffs all files from mathlib in there</p>",
        "id": 338415864,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1677521946
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4#build-instructions\">https://github.com/leanprover-community/mathlib4#build-instructions</a> last point of the listing here</p>",
        "id": 338415931,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1677521969
    },
    {
        "content": "<p>Sorry for necro posting, but I have the same problem when I import <a href=\"https://reservoir.lean-lang.org/@leanprover/LeanSAT\">LeanSAT</a> and Mathlib, as both of them have identical declaration <code>List.map_congr</code>.  I can't avoid importing both files declaring it because the declarations lies deep in import hierarchy and necessary and used in files I actually need. Is it possible to hide one of the declarations after importing?</p>",
        "id": 451154972,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1720867164
    },
    {
        "content": "<p>No this is not possible. However the latest version of LeanSAT does not have a map_congr theorem anymore. I'm also working on upstreaming the theory that is not SAT related such that LeanSAT doesn't carry its own pile of custom array/list theory around anymore.</p>",
        "id": 451163195,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1720871114
    },
    {
        "content": "<p>May I ask what you are doing with LeanSAT?</p>",
        "id": 451163279,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1720871154
    },
    {
        "content": "<p>I am working on the formalization of the <a href=\"https://en.wikipedia.org/wiki/Hadwiger%E2%80%93Nelson_problem\">Hadwiger-Nelson problem</a>, in particular on verifying that a certain unit distance graph on a plane is not four-colorable. This requires the use of a SAT solver.</p>",
        "id": 451167518,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1720874110
    },
    {
        "content": "<p>Oh interesting you are building your own CNFs and such? That's not quite what I engineered LeanSAT for but pretty cool none the less! Note that the majority of machinery in LeanSAT uses the AIG API because it allows for subterm sharing etc. which produces much smaller CNFs so if you end up running into issues because of that I would suggest to use AIGs instead of CNF.</p>",
        "id": 451168016,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1720874517
    },
    {
        "content": "<p>Yes, I build a CNF corresponding to given graph coloring problem and then use the LeanSAT API to prove that this CNF is unsat. SAT solving isn't the bottleneck in my problem so far, but I'll learn about AIGs. May I also ask you, is there a plan to  remove the <code>ofBoolReduce</code> axiom dependency in LeanSAT?</p>",
        "id": 451334045,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1720945691
    },
    {
        "content": "<p>Removing it is basically impossible in this architecture so no</p>",
        "id": 451338541,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1720949472
    },
    {
        "content": "<p>To clarify there: removing it is not that hard, but the scope of solvable problems without it is tiny -- perhaps down in the 10s of clauses range. (Henrik will have a much clearer idea than me where the cutoff is). It would be so small as to be practically unusable, and so it doesn't seem worth doing the relatively minor engineering work. Allowing people to turn off the dependence on <code>ofReduceBool</code> would just result in disappointment.</p>",
        "id": 451356630,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1720965448
    },
    {
        "content": "<p>Removing ofReduceBool would indeed push the whole thing down into the 10s of clauses. Moving from using native code to byte code (which would still require ofReduceBool) does already increase the time spent on some problems by a factor of 20x, removing byte code and relying on kernel evaluation entirely would make it close to unusable for any real world problem sizes.</p>",
        "id": 451357434,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1720966032
    },
    {
        "content": "<p>The reasoning for why it is acceptable to trust the Lean compiler here is basically the following: People that usually do BitVec proofs in the industry rely on SMT solvers. Currently SMT solvers do not emit a proof format at all. This means that as someone that is currently doing BitVec reasoning you are trusting an SMT solver <em>and</em> also your reduction of the problem to SMT BitVec theory.</p>\n<p>With LeanSAT the reduction to BitVec theory must be verified. LeanSAT then effectively implements a fully verified reduction from BitVec theory to SAT and a verified checker for proofs produces by SAT solvers. So you drop the reliance on the correctness of a SAT/SMT solver entirely and instead only have to trust the Lean compiler + Lean Kernel.</p>",
        "id": 451357763,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1720966380
    },
    {
        "content": "<p>That's cool for industry but sad for maths. Is it impossible in general to verify the unsatisfiability of large CNFs using the kernel?</p>",
        "id": 451486810,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1721046743
    },
    {
        "content": "<p>Yes, kernel evaluation is very slow on workloads like this. The verifier makes use of things like <code>Array</code> and <code>Std.HashMap</code> with the expected O(1) access times etc. All of this becomes O(n) (or worse) in the kernel + the additional overhead of symbolically evaluating this term in the kernel (the kernel constantly tries applying shortcuts that don't succeed because it's trimmed towards solving math defeq problems, not hard core computation).</p>\n<p>The only way I see to make this even remotely work without <code>ofReduceBool</code> is to have evaluation engines that are more trimmed to this type of computation which would increase the size of the kernel which is most likely not acceptable.</p>\n<p>Note that non industry people also seem to accept proofs by computation like this, e.g. the recent Busy Beaver number proof heavily relies on an <code>ofReduceBool</code> like mechanism in the Coq kernel.</p>",
        "id": 451489233,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1721047479
    },
    {
        "content": "<p>Would binary trees also take O(n) time in the kernel, or would they be efficient (O(log(n)))?</p>",
        "id": 451514345,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721053839
    },
    {
        "content": "<p>Binary Trees take log(n) time. The reduction in performance of Array and HashMap is because Array is only backed by a real array in the compiler, in the logic it is backed by a List. So if you are in the logic (aka in the kernel) and you do Array.get you do a List lookup</p>",
        "id": 451514745,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1721053953
    },
    {
        "content": "<p>I imagine even with that it would still be horribly slow?</p>",
        "id": 451514891,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721053999
    },
    {
        "content": "<p>Though that still does not change the fact that the constant overhead of just doing things symbolically in the kernel is ginormous. As I noted above simply going from natively compiled to bytecode <em>with</em> efficient aysmptotics is a 20x slowdown, doing symbolic evaluation in the kernel would be crippling.</p>",
        "id": 451514965,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1721054018
    },
    {
        "content": "<p>The computationally expensive step which uses <code>ofReduceBool</code> is</p>\n<blockquote>\n<p>Use an LRAT checker with a soundness proof in Lean to show that the LRAT proof is correct.</p>\n</blockquote>\n<p>right?</p>",
        "id": 451516151,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721054257
    },
    {
        "content": "<p>Not only that, LeanSAT also has to demonstrate to the kernel that its reduction from BitVec to CNF is correct. So it replays basically all of BitVec -&gt; AIG -&gt; CNF in the kernel using ofReduceBool as well.</p>",
        "id": 451516602,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1721054383
    },
    {
        "content": "<p>That's not quite right...we do of course have proof that this reduction is correct. However we need to present the LRAT checker with a CNF that is provably equal to the problem for the kernel to take the LRAT checker's result seriously. So what happens is that the kernel also needs to re-compute the CNF reduction because that is the only way it can be sure we actually computed that CNF using our verified reduction.</p>",
        "id": 451517011,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1721054476
    },
    {
        "content": "<p>That being said, the CNF reduction is <em>very</em> fast if evaluated using native code. It barely ever shows up in my profiles. The two components that dominante the profile are the SAT solver and the LRAT checker. However if you were to move to kernel evaluation the reduction would slow down <em>massively</em> because of its heavy reliance on verified caches etc. that are all based on Arrays and HashMaps. HashMaps in particular have (probably to the surprise of nobody) a horrible computational behavior in the kernel.</p>",
        "id": 451517346,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1721054567
    },
    {
        "content": "<p>The SAT solver itself doesn't need to be verified, right? Just the LRAT it outputs</p>",
        "id": 451517556,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721054634
    },
    {
        "content": "<p>Yes but I still need to run the SAT solver to get a proof. The SAT solver is not driving the BitVec to CNF reduction, the SAT solver is responsible for producing an LRAT proof given a CNF file.</p>\n<p>To give a perspective of the current runtimes on a hard-ish problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">bv</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">2.325685</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Preparing</span><span class=\"w\"> </span><span class=\"n\">LRAT</span><span class=\"w\"> </span><span class=\"n\">reflection</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Bitblasting</span><span class=\"w\"> </span><span class=\"n\">BVLogicalExpr</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">AIG</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">AIG</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"mi\">8354</span><span class=\"w\"> </span><span class=\"n\">nodes</span><span class=\"bp\">.</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">sat</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Converting</span><span class=\"w\"> </span><span class=\"n\">AIG</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">CNF</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">sat</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Converting</span><span class=\"w\"> </span><span class=\"n\">frontend</span><span class=\"w\"> </span><span class=\"n\">CNF</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">solver</span><span class=\"w\"> </span><span class=\"n\">specific</span><span class=\"w\"> </span><span class=\"n\">CNF</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">sat</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">CNF</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"mi\">23840</span><span class=\"w\"> </span><span class=\"n\">clauses</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">sat</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">2.284526</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Obtaining</span><span class=\"w\"> </span><span class=\"n\">external</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"n\">certificate</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Serializing</span><span class=\"w\"> </span><span class=\"n\">SAT</span><span class=\"w\"> </span><span class=\"n\">problem</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">DIMACS</span><span class=\"w\"> </span><span class=\"n\">file</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">2.158430</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Running</span><span class=\"w\"> </span><span class=\"n\">SAT</span><span class=\"w\"> </span><span class=\"n\">solver</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">0.105316</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Obtaining</span><span class=\"w\"> </span><span class=\"n\">LRAT</span><span class=\"w\"> </span><span class=\"n\">certificate</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">sat</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">0.014303</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Compiling</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">sat</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Compiling</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"n\">certificate</span><span class=\"w\"> </span><span class=\"n\">term</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">sat</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Compiling</span><span class=\"w\"> </span><span class=\"n\">reflection</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"n\">term</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Kernel</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">1.778691</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">typechecking</span><span class=\"w\"> </span><span class=\"n\">declaration</span>\n</code></pre></div>\n<p>This is with native code, The \"kernel\" part at the end is almost exclusively the LRAT checker.</p>\n<p>If I now disable native code in favor of bytecode evaluation (this is still not kernel evaluation, it is <em>much</em> faster on raw computation) it doesn't even terminate after a minute. Doing anything but native code is not feasible.</p>",
        "id": 451518458,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1721054881
    },
    {
        "content": "<p>Note that in the above profile the time spent bitblasting to AIG and converting to CNF etc. was so miniscule that Lean did not even record it. Moving away from native or bytecode evaluation would drive that part into the minutes already.</p>",
        "id": 451518926,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1721055011
    }
]