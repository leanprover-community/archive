[
    {
        "content": "<p>I've been struggling to build an instance for <code>ToTerm</code> for <code>FirstOrder.Language.Sentence</code> in mathlib which needs a bunch of other instances, notably <code>FirstOrder.Language.BoundedFormula</code> and <code>FirstOrder.Language.Term</code> which I'm finding difficult to write.</p>\n<p>The idea is to be able to reflect a <code>Lean.Expr</code> (when amenable) into a syntactic first order term, _including bound variables_ of course!</p>\n<p>To do this, I'm writing a <code>Lean.Expr -&gt; FirstOrder.Language.BoundedFormula</code> function, and then calling <code>toExpr</code> (and say, applying the \"models\" function to it).</p>\n<p>The trouble is that, <code>Term</code>, for instance (no pun intended) has a constructor of type <code>... -&gt; Fin n -&gt; Term</code>which is a bit awkward, (though there is an instance for such arrows) and the types are very dependent.</p>\n<p>The mathlib <code>ToExpr</code> instance generator fails for all of these, perhaps unsurprisingly.</p>\n<p>My questions are therefore:</p>\n<ul>\n<li>Is there an easier way to write these instances or just grit my teeth?</li>\n<li>Is this the right approach, or should I be doing this differently?</li>\n</ul>",
        "id": 430172084,
        "sender_full_name": "Cody Roux",
        "timestamp": 1711665352
    },
    {
        "content": "<p>how do you intend to define <code>toExpr</code> for a term?</p>",
        "id": 430173475,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711666213
    },
    {
        "content": "<p>In other words, do you really want <code>Term.var</code> to give a <code>bvar</code>, or do you want to also quantify over some type, and have <code>var</code> be a term of said type?</p>",
        "id": 430173731,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711666393
    },
    {
        "content": "<p>Also, as far as I know, Mathlib's model theory library currently only supports single-sorted theories. If one were to do the hard work to develop such reflections, then I think we should do it in the correct level of generality, which should include the multi-sorted case as well.</p>",
        "id": 430173869,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711666477
    },
    {
        "content": "<p>Maybe I should also mention that I did something like this not for all of first-order logic, but just a small fragment as part of a project on Lawvere theories (which I gave a <a href=\"#narrow/stream/224796-Geographic-locality/topic/Cambridge.2C.20UK/near/426489133\">talk</a> about a few weeks ago, and supposedly the recording of the talk will be posted soon).</p>",
        "id": 430174278,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711666702
    },
    {
        "content": "<p>(it was a very interesting talk!)</p>",
        "id": 430213742,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1711696657
    },
    {
        "content": "<p>Reading this again, it‚Äôs possible I misunderstood the original question. What is <code>ToTerm</code>?</p>",
        "id": 430264084,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711722486
    },
    {
        "content": "<p>Sorry, was distracted yesterda.</p>\n<p><code>ToTerm</code> was a typo, I meant <code>ToExpr</code>. I think you got my question perfectly right. The advantage of the existing mono-sorted logic is that</p>\n<ol>\n<li>It exists, and has some non-trivial lemmas</li>\n<li>It's roughly up to mathlib standards</li>\n<li>You can do plenty of things in mono-sorted logic, including (if you really want) encode multi-sorted theories.</li>\n</ol>\n<p>I also need it right now, to do this non-standard arithmetic stuff.</p>",
        "id": 430411022,
        "sender_full_name": "Cody Roux",
        "timestamp": 1711824046
    },
    {
        "content": "<p>I want <code>Term.var</code> to give the <code>Expr</code> it should stand for! In this case, I guess a <code>Expr.app (Expr.const ``Term.var []) (toExpr some_argument)</code> or something along those lines.</p>",
        "id": 430411132,
        "sender_full_name": "Cody Roux",
        "timestamp": 1711824158
    },
    {
        "content": "<p>Ah ok, so you don‚Äôt want to interpret first order logic in terms of lean‚Äôs type-theoretic logic. That‚Äôs much easier to accomplish :)</p>",
        "id": 430411886,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711824766
    },
    {
        "content": "<p>Well, I want that too, but that's easy :)</p>\n<p>Just use <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Sentence.Realize\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Sentence.Realize</a></p>",
        "id": 430412343,
        "sender_full_name": "Cody Roux",
        "timestamp": 1711825197
    },
    {
        "content": "<p>Yeah ok, but that takes a structure in the sense of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FirstOrder.Language.Structure#doc\">docs#FirstOrder.Language.Structure</a> not in the sense of lean‚Äôs structures</p>",
        "id": 430413256,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711825938
    },
    {
        "content": "<p>Ah I see, yes it'd be nice to generalize this, for sure. But for now, <code>toExpr</code> would be nice, so I can write a little tactic that reifies propositions into theories with \"known\" properties.</p>\n<p>In my specific case, I have \"spillover\": the non-standard model of <code>R</code> satisfies exactly the same first-order sentences as <code>R</code>.</p>",
        "id": 430414551,
        "sender_full_name": "Cody Roux",
        "timestamp": 1711827186
    },
    {
        "content": "<p><a href=\"https://github.com/codyroux/compact-php/blob/main/CompactPhp/NonstandardReal.lean#L330\">https://github.com/codyroux/compact-php/blob/main/CompactPhp/NonstandardReal.lean#L330</a></p>",
        "id": 430414593,
        "sender_full_name": "Cody Roux",
        "timestamp": 1711827230
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116028\">@Cody Roux</span> could you use a typeclass like this for your use case instead of a meta function from <code>Expr</code>? (I heard you explain your problem during office hours)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">ToRealSentence</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">arithSentence</span> <span class=\"o\">:</span> <span class=\"n\">Sentence</span> <span class=\"n\">Arith</span>\n  <span class=\"n\">isAboutReals</span> <span class=\"o\">:</span> <span class=\"n\">Sentence.Realize</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">arithSentence</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToRealSentence</span> <span class=\"n\">False</span> <span class=\"n\">where</span>\n  <span class=\"n\">arithSentence</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">falsum</span>\n  <span class=\"n\">isAboutReals</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ToRealSentence</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">arithSentence</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">equal</span> <span class=\"gr\">sorry</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">isAboutReals</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- and so on for every constructor of FirstOrder.Language.BoundedFormula</span>\n</code></pre></div>",
        "id": 433881354,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1713391174
    },
    {
        "content": "<p>Hmm after playing with it for a bit I think I see the problem. This is as far as I got</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">ToRealSentence</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">arithSentence</span> <span class=\"o\">:</span> <span class=\"n\">Sentence</span> <span class=\"n\">Arith</span>\n  <span class=\"n\">isAboutReals</span> <span class=\"o\">:</span> <span class=\"n\">Sentence.Realize</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">arithSentence</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ToRealTerm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">arithTerm</span> <span class=\"o\">[</span><span class=\"n\">IsEmpty</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Term</span> <span class=\"n\">Arith</span> <span class=\"n\">Œ±</span>\n  <span class=\"n\">isAboutReals</span> <span class=\"o\">:</span> <span class=\"n\">Term.realize</span> <span class=\"n\">nofun</span> <span class=\"o\">(</span><span class=\"n\">arithTerm</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"n\">Empty</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToRealSentence</span> <span class=\"n\">False</span> <span class=\"n\">where</span>\n  <span class=\"n\">arithSentence</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">falsum</span>\n  <span class=\"n\">isAboutReals</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ToRealTerm</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ToRealTerm</span> <span class=\"n\">y</span><span class=\"o\">]:</span> <span class=\"n\">ToRealSentence</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">arithSentence</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">equal</span> <span class=\"o\">(</span><span class=\"n\">ToRealTerm.arithTerm</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ToRealTerm.arithTerm</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"n\">isAboutReals</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"o\">[</span><span class=\"n\">ToRealTerm</span> <span class=\"n\">x</span><span class=\"o\">],</span> <span class=\"n\">ToRealSentence</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">ToRealSentence</span> <span class=\"o\">(</span><span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"c1\">-- we get stuck because we need to recursively synthesize an instance about the quantified formula,</span>\n  <span class=\"c1\">-- but `P x` can't have a `ToRealSentence` instance for all `x : ‚Ñù` because we don't necessarily know how to encode `x` as a term.</span>\n  <span class=\"c1\">-- if we try encoding `x` as `.var _`, we have another problem because we've been assuming all terms are ground.</span>\n  <span class=\"n\">arithSentence</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">all</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">f</span> <span class=\"gr\">sorry</span> <span class=\"o\">{</span><span class=\"n\">arithTerm</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">var</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"n\">isAboutReals</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">arithSentence</span>\n</code></pre></div>",
        "id": 433885609,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1713393526
    },
    {
        "content": "<p>Basically the problem with using typeclass synthesis for this is that typeclasses are always indexed by well-formed expressions, but we want to recurse on expressions with free variables.</p>",
        "id": 433885706,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1713393597
    },
    {
        "content": "<p>If there was a function that lifted functions from terms to terms into terms with free variables, I think that would solve the problem, but I don't think it's possible to write such a function.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">liftFun</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Term</span> <span class=\"n\">Arith</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Term</span> <span class=\"n\">Arith</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Term</span> <span class=\"n\">Arith</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 433886733,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1713394212
    },
    {
        "content": "<p><code>liftFun</code> could not work because not all Lean functions of that type are \"definable\" as FOL terms with a free variable. Logical frameworks can sometimes provide such a property (everything in a meta-level function space is definable), but general type theories don't.</p>",
        "id": 433887736,
        "sender_full_name": "ùö†ùöòùöìùöåùöíùöéùöåùöë ùöóùöäùö†ùöõùöòùöåùöîùöí",
        "timestamp": 1713394827
    },
    {
        "content": "<p>Right, I actually considered a less clever form of this idea but couldn't think of how to make it work. Let me think it through a bit.</p>\n<p>What's certainly not true is that there is a mapping from the non-standards <code>NS</code> to <code>R</code>, even less one that preserves all the properties. I don't think there is one in the other direction either, but that's less obvious (I think <code>NS</code> can be countable though).</p>\n<p>But I'm not sure that that's needed.</p>",
        "id": 433907670,
        "sender_full_name": "Cody Roux",
        "timestamp": 1713408960
    }
]