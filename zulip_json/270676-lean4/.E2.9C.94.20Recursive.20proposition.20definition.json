[
    {
        "content": "<p>This is part of practice for formulating and proving theorems in bare Lean 4, without Mathlib.</p>\n<p>Given <code>L : List Nat</code>, I want to define the proposition that all elements are greater than <code>1</code> recursively on <code>L</code>if L is not empty (call those <code>Nats</code> regular).  I would like to have something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">isRegs</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n   <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">→</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">isRegs</span> <span class=\"n\">xs</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>I have a recursive definition of product:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mult</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span>      <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">mult</span> <span class=\"n\">xs</span>\n</code></pre></div>\n<p>And I want to prove that the product of a \"regular list\" is regular:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">reg_of_mult_regs</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">isRegs</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">mult</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n      <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>When I try to destructure the hypothesis, I get an error saying that <code>isRegs L</code> is not an inductive type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">reg_of_mult_regs</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">isRegs</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">mult</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n    <span class=\"k\">fun</span> <span class=\"o\">⟨</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">reg_xs</span> <span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span>\n</code></pre></div>\n<blockquote>\n<p>invalid constructor ⟨...⟩, expected type must be an inductive type <br>\n  Acc.rec<br>\n    (fun x₁ h ih =&gt;<br>\n      (fun L a =&gt;<br>\n          ∃ x xs,<br>\n            ∀ (a_1 : L = x :: xs), 2 ≤ x ∧ a xs (_ : (invImage (fun a =&gt; sizeOf a) instWellFoundedRelation).1 xs L))<br>\n        x₁ ih)<br>\n    (_ : Acc (invImage (fun a =&gt; sizeOf a) instWellFoundedRelation).1 L)</p>\n</blockquote>\n<p>I understand that this is related to the recursive presence of <code>isRegs xs</code> in the definition.  What is the correct way to express my intent for a recursive proposition in Lean?  Or, is there another way to use this definition of <code>isRegs</code> in a proof?</p>",
        "id": 380996739,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1690974735
    },
    {
        "content": "<p>The following is probably more idiomatic:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">isRegs'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n<span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">isRegs'</span> <span class=\"n\">xs</span>\n</code></pre></div>\n<p>though it doesn't help with your error</p>",
        "id": 380999017,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1690975173
    },
    {
        "content": "<p>In fact, you can start your proof like that as well:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">reg_of_mult_regs</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">isRegs'</span> <span class=\"n\">L</span> <span class=\"bp\">→</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">mult</span> <span class=\"n\">L</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">isRegs'</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">isRegs'</span> <span class=\"n\">mult</span>\n</code></pre></div>",
        "id": 381001130,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1690975587
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/270676-lean4/topic/Recursive.20proposition.20definition/near/381001130\">said</a>:</p>\n<blockquote>\n<p>In fact, you can start your proof like that as well:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">reg_of_mult_regs</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">isRegs'</span> <span class=\"n\">L</span> <span class=\"bp\">→</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">mult</span> <span class=\"n\">L</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">isRegs'</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">isRegs'</span> <span class=\"n\">mult</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I see <code>unfold</code> is a tactic.  What is the term construction behind it?  I.e. if I wanted to proceed manually in your modified theorem, what would follow <code>x :: xs =&gt;</code> ?</p>",
        "id": 381006490,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1690976657
    },
    {
        "content": "<p>I'd recommend that you write the proof in tactic mode first, and then reconstruct the term from there. In the case of <code>unfold</code> - it just replaces the names by their definitions, so lean doesn't <em>need</em> it, but it helps to see what you're doing</p>",
        "id": 381009604,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1690977312
    },
    {
        "content": "<p>You can always use <code>show_term</code> to ask to see the term produced by a tactic. (Sometimes you won't like what you see!)</p>",
        "id": 381009925,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690977385
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/270676-lean4/topic/Recursive.20proposition.20definition/near/381009925\">said</a>:</p>\n<blockquote>\n<p>You can always use <code>show_term</code> to ask to see the term produced by a tactic. (Sometimes you won't like what you see!)</p>\n</blockquote>\n<p>How do you use <code>show_term</code>?  I searched all the documentation and did not find this string.</p>",
        "id": 381015769,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1690978565
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">reg_of_mult_regs</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">isRegs'</span> <span class=\"n\">L</span> <span class=\"bp\">→</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">mult</span> <span class=\"n\">L</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">isRegs'</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">show_term</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">isRegs'</span> <span class=\"n\">mult</span>\n</code></pre></div>",
        "id": 381017499,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690978906
    },
    {
        "content": "<p>etc</p>",
        "id": 381017525,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690978911
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/270676-lean4/topic/Recursive.20proposition.20definition/near/381017499\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">reg_of_mult_regs</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">isRegs'</span> <span class=\"n\">L</span> <span class=\"bp\">→</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">mult</span> <span class=\"n\">L</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">isRegs'</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">show_term</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">isRegs'</span> <span class=\"n\">mult</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I get an <code>unknown tactic</code> error when I try to use this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">one_gt_zero</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">show_term</span>\n    <span class=\"n\">simp</span>\n</code></pre></div>\n<blockquote>\n<p>Practice.lean:194:3<br>\nunknown tactic<br>\nPractice.lean:193:31<br>\nunsolved goals<br>\n⊢ 1 &gt; 0</p>\n</blockquote>",
        "id": 381019507,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1690979306
    },
    {
        "content": "<p>Do I need to import some library?</p>",
        "id": 381019608,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1690979329
    },
    {
        "content": "<p><code>import Std.Tactic.ShowTerm</code></p>",
        "id": 381020914,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690979568
    },
    {
        "content": "<p>This is frustrating.  I get</p>\n<blockquote>\n<p><code>/home/admin/.elan/toolchains/leanprover--lean4---nightly-2023-07-12/bin/lake print-paths Init Std.Tactic</code> failed:</p>\n<p>stderr:<br>\nerror: no such file or directory (error code: 2)<br>\n  file: ./lake-packages/std/././Std/Tactic.lean</p>\n</blockquote>\n<p>I initiated this repository with <code>lake new ... math</code> and did not touch the <code>lake_packages</code> folder.</p>",
        "id": 381024843,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1690980172
    },
    {
        "content": "<p>My path to <code>Tactic</code> is</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>/home/data/programming-data/practice/lake-packages/std/Std/Tactic\n</code></pre></div>",
        "id": 381025287,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1690980251
    },
    {
        "content": "<p>Try <code>lake exe cache get</code> in the root directory of the repo and then <code>lake build</code>?</p>",
        "id": 381028973,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690980920
    },
    {
        "content": "<p>You might end up downloading all of mathlib, but you don't have to import it :-)</p>",
        "id": 381029130,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690980951
    },
    {
        "content": "<p>I have already done that; all of Std, Mathlib, Qq, aesop etc are in the <code>lake_packages</code> folder, with cached binaries:</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>└─<span class=\"o\">[</span>$<span class=\"o\">]</span><span class=\"w\"> </span>&lt;git:<span class=\"o\">(</span>master*<span class=\"o\">)</span>&gt;<span class=\"w\"> </span>lake<span class=\"w\"> </span>exe<span class=\"w\"> </span>cache<span class=\"w\"> </span>get\nNo<span class=\"w\"> </span>files<span class=\"w\"> </span>to<span class=\"w\"> </span>download\nDecompressing<span class=\"w\"> </span><span class=\"m\">3598</span><span class=\"w\"> </span>file<span class=\"o\">(</span>s<span class=\"o\">)</span>\nunpacked<span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"m\">190</span><span class=\"w\"> </span>ms\n</code></pre></div>",
        "id": 381030032,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1690981108
    },
    {
        "content": "<p>The error message says that you tried to import <code>Std.Tactic</code>, not <code>Std.Tactic.ShowTerm</code></p>",
        "id": 381030953,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1690981266
    },
    {
        "content": "<p>I understand now; I initially miswrote <code>Std.Tactic.ShowTerm</code> as <code>Std.Tactic.showTerm</code>.</p>\n<p>I keep making these errors in capitalization in Lean due to my bad eyesight, sometimes leading to long and useless debugging.  :(</p>",
        "id": 381031748,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1690981401
    },
    {
        "content": "<p>With <span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> 's recommendation, I can now prove what I want:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mult</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span>      <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">mult</span> <span class=\"n\">xs</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">isRegs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">isRegs</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">reg_of_mult_regs</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">isRegs</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">mult</span> <span class=\"n\">L</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">isRegs</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">reg_x</span><span class=\"o\">,</span> <span class=\"n\">regs_xs</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">calc</span>\n      <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span>       <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n      <span class=\"n\">_</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span>       <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">reg_x</span><span class=\"o\">,</span> <span class=\"n\">Nat.mul_le_mul</span><span class=\"o\">]</span>\n      <span class=\"n\">_</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">mult</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">reg_of_mult_regs</span> <span class=\"n\">xs</span> <span class=\"n\">regs_xs</span><span class=\"o\">,</span> <span class=\"n\">Nat.mul_le_mul</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>However, I still do not understand the nature of the original error.  If anyone can elaborate, I will be grateful!</p>",
        "id": 381032490,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1690981531
    },
    {
        "content": "<p>Could you post a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> of the original error (imports included!) and we can take a look?</p>",
        "id": 381034140,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690981802
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/270676-lean4/topic/Recursive.20proposition.20definition/near/381034140\">said</a>:</p>\n<blockquote>\n<p>Could you post a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> of the original error (imports included!) and we can take a look?</p>\n</blockquote>\n<p>Here is a silly pattern that I distilled from the original problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">recProp</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n   <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">recProp</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mwe_rec</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">recProp</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n    <span class=\"k\">fun</span> <span class=\"o\">⟨</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hyp</span> <span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I define <code>recProp</code> depending on a <code>z : Nat</code> with an existential quantifier, and the second part references the <code>recProp</code> recursively.</p>\n<p>I then try to destructure the existential structure in <code>fun &lt; x, hyp &gt;</code> and this line fails with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">constructor</span> <span class=\"o\">⟨</span><span class=\"bp\">...</span><span class=\"o\">⟩,</span> <span class=\"n\">expected</span> <span class=\"n\">type</span> <span class=\"n\">must</span> <span class=\"n\">be</span> <span class=\"n\">an</span> <span class=\"kd\">inductive</span> <span class=\"n\">type</span>\n  <span class=\"n\">Acc.rec</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x₁</span> <span class=\"n\">h</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">z</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a_1</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">invImage</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">instWellFoundedRelation</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"n\">x₁</span>\n        <span class=\"n\">ih</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Acc</span> <span class=\"o\">(</span><span class=\"n\">invImage</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">instWellFoundedRelation</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 381037896,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1690982516
    },
    {
        "content": "<p>There are no imports, this is the entire file.</p>",
        "id": 381038017,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1690982535
    },
    {
        "content": "<p>The issue is that your definition of <code>recProp</code>is not structural over z here, and as such, your definition gets compiled to a well-founded definition, which doesn't end up looking like an inductive type. The solution in such a case would be to either define your predicate recursively via pattern-matching, as was done in your previous example, or as an inductive predicate, on which you'd then be allowed to pattern-match on like intended. If I translate your mwe, I get :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mult</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span>      <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">mult</span> <span class=\"n\">xs</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">isRegs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">isRegs</span> <span class=\"n\">xs</span> <span class=\"bp\">→</span> <span class=\"n\">isRegs</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">reg_of_mult_regs</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">isRegs</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">mult</span> <span class=\"n\">L</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">h</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"n\">reg_x</span><span class=\"o\">,</span> <span class=\"n\">regs_xs</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">calc</span>\n      <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span>       <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n      <span class=\"n\">_</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span>       <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">reg_x</span><span class=\"o\">,</span> <span class=\"n\">Nat.mul_le_mul</span><span class=\"o\">]</span>\n      <span class=\"n\">_</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">mult</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">reg_of_mult_regs</span> <span class=\"n\">xs</span> <span class=\"n\">regs_xs</span><span class=\"o\">,</span> <span class=\"n\">Nat.mul_le_mul</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Now, I'd like to point out that the predicate <code>isRegs</code> you've constructed until now is always false.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">empty_isRegs</span> <span class=\"o\">:</span><span class=\"bp\">∀</span> <span class=\"n\">L</span><span class=\"o\">,</span>  <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">isRegs</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">L</span>\n  <span class=\"n\">induction</span> <span class=\"n\">L</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">intro</span> <span class=\"n\">h</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">cases</span> <span class=\"n\">h</span>\n  <span class=\"bp\">·</span> <span class=\"n\">contradiction</span>\n</code></pre></div>\n<p>You should probably add a case to your definition if <code>isRegs</code> for when the list only has one element.</p>",
        "id": 381199330,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1690989727
    },
    {
        "content": "<p>Thank you very much!</p>",
        "id": 381263271,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1691001936
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"577163\">Ioannis Konstantoulas</span> has marked this topic as resolved.</p>",
        "id": 381263282,
        "sender_full_name": "Notification Bot",
        "timestamp": 1691001940
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"577163\">Ioannis Konstantoulas</span> has marked this topic as unresolved.</p>",
        "id": 381266962,
        "sender_full_name": "Notification Bot",
        "timestamp": 1691002762
    },
    {
        "content": "<p>One more thing: even if you do define <code>recProp</code> by well-founded recursion (i.e. not structural), while you cannot match on it directly, you can still match after unfolding:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">recProp</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n   <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">recProp</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mwe_rec</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">recProp</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">recProp</span>\n  <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hyp</span><span class=\"o\">⟩</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 381304632,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1691014587
    },
    {
        "content": "<p>In this case <code>unfold recProp</code> rewrites by the equation <code>recProp._unfold (z : ℕ) : recProp z = ∃ x, z = x + 1 → recProp x</code>.</p>",
        "id": 381304735,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1691014636
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Recursive.20proposition.20definition/near/381304632\">said</a>:</p>\n<blockquote>\n<p>One more thing: even if you do define <code>recProp</code> by well-founded recursion (i.e. not structural), while you cannot match on it directly, you can still match after unfolding:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">recProp</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n   <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">recProp</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mwe_rec</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">recProp</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">recProp</span>\n  <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hyp</span><span class=\"o\">⟩</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thank you, this remark is very useful!</p>",
        "id": 381385291,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1691048922
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"577163\">Ioannis Konstantoulas</span> has marked this topic as resolved.</p>",
        "id": 381385307,
        "sender_full_name": "Notification Bot",
        "timestamp": 1691048930
    }
]