[
    {
        "content": "<p>To prevent an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> issue, here's the full context: given an expression of the form <code>.app (.app (... (.app f a)...) y ) z</code>, I'm writing a function which (lambda-)abstracts the last <code>n</code> explicit arguments \"as much as possible\". \"As much as possible\" means that if there's e.g. an implicit argument <code>α</code> which is in the backwards dependencies of to-be-abstracted arguments—but <em>not</em> in the backwards dependencies of anything else—it gets abstracted as well.</p>\n<p>I have code that does this just fine typically, but it relies on the <code>backDeps</code> field of elements of <code>(← getFunInfo f).paramInfo</code> to figure out dependencies. This means that universe levels aren't accounted for.</p>\n<p>Is there some similar data to <code>backDeps</code> for figuring out universe level dependencies hidden somewhere, and for replacing existing levels with level mvars? I'm unfamiliar with the particulars of resolving levels, so I might be confused as to \"when\" this all needs to happen.</p>\n<p>If not, would it at least maybe be possible to take the \"nuclear option\" and erase universe levels everywhere in the expression, then re-infer them? If <code>f</code> happens to be a <code>.const</code>, this might be easy enough to do (untested), but this isn't fully general—plus, I'd hope there's a cleaner option! :)</p>",
        "id": 358825192,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1684263888
    }
]