[
    {
        "content": "<p>I ran into an issue where defining a function won't work with some implicit variables and quotients, because Lean can't figure out that two types are defeq because it won't unify the implicit parameters. (<span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> helped me figure out more or less what was happening there). Here's an attempt of mine to minimize it. I couldn't get this to work without Quotients, but I'm not sure if quotients are actually required or I just didn't find a minimal example without them:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.Polynomial.Quotient</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.Ideal.Quotient</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Polynomial</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">X</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ℤ</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"bp\">⧸</span> <span class=\"o\">(</span><span class=\"n\">Ideal.span</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">})</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">R.monomial</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">Ideal.Quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">Ideal.span</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">Polynomial.monomial</span> <span class=\"n\">k</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">addXk</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">n</span>\n   <span class=\"c1\">--| p, k =&gt; p + R.monomial k -- (deterministic) timeout at 'whnf', maximum number of heartbeats (200000) has been reached (use 'set_option maxHeartbeats &lt;num&gt;' to set the limit)</span>\n   <span class=\"bp\">|</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p</span> <span class=\"bp\">+</span> <span class=\"n\">R.monomial</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:=</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"c1\">-- works</span>\n</code></pre></div>\n<p>Is this a known problem? Is there a way to avoid doing that accidentally, or even better, help Lean figure out these things more easily? <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> conjectured it might actually be the reason behind a bunch of the mysterious timeouts we seem to get with quotient rings.</p>",
        "id": 386899258,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1692804515
    },
    {
        "content": "<p>I recall seeing some commands to enable/disable <code>*</code> as notation for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HMul#doc\">docs#HMul</a>, but forgot where. Maybe we should disable <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HAdd#doc\">docs#HAdd</a> here?</p>",
        "id": 386915327,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1692809227
    },
    {
        "content": "<p>yeah, disabling <code>HAdd</code> would fix that behavior but it feels like avoiding the issue rather than addressing it, doesn't it? It sounds like getting this to work would require changes in core (or even in the kernel), so maybe that's the best way to do from the user's point of view, but I was hoping people who know the internals better than I do might have some more insights about it</p>",
        "id": 386917481,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1692810007
    },
    {
        "content": "<p>Oh I think what I saw was <a href=\"https://github.com/leanprover/lean4/pull/2220\">lean4#2220</a> where Lean 4 assumes <code>x</code> and <code>y</code> are of the same type in <code>x ^ y</code> by default, which is undesirable. Here it's desirable to assume <code>x</code> and <code>y</code> are of the same type in <code>x + y</code>, and it's weird that Lean doesn't do so.</p>",
        "id": 391537068,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1694969042
    }
]