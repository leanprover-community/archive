[
    {
        "content": "<p>I'm not sure where the best place to raise this is, and I am sure this conversation has been had before, but I was reminded of it again today and I really felt I should mention it.</p>\n<p><code>List.concat</code> does not perform concatenation. In essentially every language I am aware of, and e.g. on Wikipedia etc. concatenation is defined as the joining of two strings: that is, what <code>List.append</code> does. And indeed, I would normally say that <code>append</code> is the operation of adding an element on to the end of a list - what <code>List.concat</code> does.</p>\n<p>Indeed, the description for <code>List.concat</code> is:<br>\n<code>/-- </code>l.concat a<code> appends </code>a<code> at the *end* of </code>l<code>, that is, </code>l ++ [a]<code>. -/</code></p>\n<p>And we then have things like this elsewhere:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The homogeneous version of `HAppend`: `a ++ b : α` where `a b : α`. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">Append</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- `a ++ b` is the result of concatenation of `a` and `b`. See `HAppend`. -/</span>\n  <span class=\"n\">append</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>How on earth did we get in a situation where we frequently confuse concatenation and appending, in ways that look,I'm sorry, kind of absurd? When you are saying <em>all the time</em> \"this is append, which concatenates\" and \"this is concat, which appends\", which we do, I can find lots of examples on a cursory check, that is to me the sign that something is deeply, weirdly wrong. I mean, from a formal perspective, fine! But why do we have to wear this confusion? Where did it come from? To me it just makes no sense at all.</p>",
        "id": 405811812,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701692231
    },
    {
        "content": "<p>I want to stress that I understand this can't be a mistake, it's happened so much. And the people who wrote the core libraries are very clever people - cleverer than me. I just am <strong>baffled</strong> as to why we make this choice: if we had called \"-\" \"Add\" and \"+\" \"Subtract\" it would make as much sense to me.</p>",
        "id": 405811993,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701692300
    },
    {
        "content": "<p>I'm sorry - I don't mean to make any trouble. This has just been really getting to me.</p>",
        "id": 405812132,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701692358
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/GhElN062fsbqWXiti6eYUp5l/image.png\">image.png</a><br>\n<span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/GhElN062fsbqWXiti6eYUp5l/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/GhElN062fsbqWXiti6eYUp5l/image.png\"></a></div>",
        "id": 405814152,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1701693129
    },
    {
        "content": "<p>The old thread is <a href=\"#narrow/stream/113488-general/topic/append.20and.20concat/near/299602232\">here</a></p>",
        "id": 405814179,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701693141
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"221921\">Marc Huisinga</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/405814152\">said</a>:</p>\n<blockquote>\n<p><a href=\"/user_uploads/3121/GhElN062fsbqWXiti6eYUp5l/image.png\">image.png</a><br>\n<span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>\n</blockquote>\n<p>To be fair I don't mind the idea that append and concat are synonyms. It isn't totally unambiguous! IIRC Haskell uses concat for [[a]] -&gt; [a].</p>",
        "id": 405814395,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701693236
    },
    {
        "content": "<p>But all our documentation describing it upside down is just ???</p>",
        "id": 405814458,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701693256
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> it looks like you reached a good solution there, but I assume there was never time for it to happen.</p>",
        "id": 405814666,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701693346
    },
    {
        "content": "<p>Like I am not sure that \"just switch append and concat\" is right at all. I do note that we often seem to do that in documentation! For me concat is the greater ??? - append is one of those tricksy things that does tend to mean more stuff.</p>",
        "id": 405814925,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701693440
    },
    {
        "content": "<p>But I think it is not true that every language makes totally different decisions - I think Lean might be unique (?) in having concat add an element to the end of a list (an operation which I struggle to describe as concatenation).</p>\n<p>For a recent example of somewhere where the confusion is quite overtly exposed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">SMT</span><span class=\"bp\">-</span><span class=\"n\">Lib</span> <span class=\"n\">name</span><span class=\"o\">:</span> <span class=\"bp\">`</span><span class=\"n\">concat</span><span class=\"bp\">`.</span>\n<span class=\"bp\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">append</span> <span class=\"o\">(</span><span class=\"n\">msbs</span> <span class=\"o\">:</span> <span class=\"n\">BitVec</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">lsbs</span> <span class=\"o\">:</span> <span class=\"n\">BitVec</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">BitVec</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">shiftLeftZeroExtend</span> <span class=\"n\">msbs</span> <span class=\"n\">m</span> <span class=\"bp\">|||</span> <span class=\"n\">zeroExtend'</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_add_left</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">lsbs</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Append a single bit to the end of a bitvector, using big endian order (see `append`).</span>\n<span class=\"sd\">    That is, the new bit is the least significant bit. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">concat</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">msbs</span> <span class=\"o\">:</span> <span class=\"n\">BitVec</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">lsb</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">BitVec</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">msbs</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">ofBool</span> <span class=\"n\">lsb</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Even if we simply must preserve this distinction - then we should not use confusing language in documentation. And I would like to understand from where the confusion arose. I think Lisp might use \"append\" for putting lists together?</p>",
        "id": 405815559,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701693711
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/405814666\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> it looks like you reached a good solution there, but I assume there was never time for it to happen.</p>\n</blockquote>\n<p>I assume you are referring to:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/append.20and.20concat/near/306832019\">said</a>:</p>\n<blockquote>\n<p>Personally I think the way forward here is:</p>\n<ul>\n<li>Put together a document (gist) indicating the terminology used by as many languages as possible, both for and against the change</li>\n<li>Make an offer to deal with making the change in Lean 4</li>\n<li>Put forth the above two items to Leo to be the final arbiter</li>\n<li>If the change is OK'd for lean4, backport to Lean 3</li>\n</ul>\n</blockquote>",
        "id": 405816280,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701694002
    },
    {
        "content": "<p>I would be happy to help with putting together a summary document. Essentially for each language you'd want to write down<br>\na) the name of the operation for adding an element to the start of a list<br>\nb) the name of the operation of adding an element to the end of a list<br>\nc) the name of the operation for taking two lists and outputting one list which contains the elements of both, first one then the other.</p>\n<p>(I think in some languages you need to be clearer about the difference between creating a new object which is the concatenation of both lists, versus mutating one list by adding on the elements of the other. I guess in Lean we are mostly doing the former?)</p>",
        "id": 405816336,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701694024
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/405816280\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/405814666\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> it looks like you reached a good solution there, but I assume there was never time for it to happen.</p>\n</blockquote>\n<p>I assume you are referring to:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/append.20and.20concat/near/306832019\">said</a>:</p>\n<blockquote>\n<p>Personally I think the way forward here is:</p>\n<ul>\n<li>Put together a document (gist) indicating the terminology used by as many languages as possible, both for and against the change</li>\n<li>Make an offer to deal with making the change in Lean 4</li>\n<li>Put forth the above two items to Leo to be the final arbiter</li>\n<li>If the change is OK'd for lean4, backport to Lean 3<br>\n</li>\n</ul>\n</blockquote>\n</blockquote>\n<p>Yep - I think you put it well.</p>",
        "id": 405816370,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701694035
    },
    {
        "content": "<p>Though we should skip the backporting to lean 3 bit ;)</p>",
        "id": 405816404,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701694046
    },
    {
        "content": "<p>Note that these three operations differ a lot in their importance, namely:<br>\na &gt; c &gt; b<br>\nI'm not claiming, however, that their importance should influence their names.</p>",
        "id": 405816843,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1701694200
    },
    {
        "content": "<p>Yeah, I agree with that. Generally speaking I find if you're using b, you shouldn't be ;)</p>",
        "id": 405816969,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701694234
    },
    {
        "content": "<p>(I suppose you also have exotic generalisations like \"insert an element at position i\". For us this is <code>List.insertNth</code> which is the most sane name I can think of. Unfortunately <code>List.insert</code> does not have a compatible meaning but oh well.)</p>",
        "id": 405817284,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701694337
    },
    {
        "content": "<p>(I mean, <code>List.insert</code> is a sensible definition given what <code>Finset.insert</code> etc. mean, don't get me wrong. It's just amusing that <code>List.insertNth</code>, which is also sensible, doesn't quite mean the same thing.)</p>",
        "id": 405817402,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701694383
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.insert#doc\">docs#List.insert</a></p>",
        "id": 405817464,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1701694402
    },
    {
        "content": "<p>I would not expect the \"without duplication\" part!</p>",
        "id": 405817554,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701694433
    },
    {
        "content": "<p>Incidentally, for <code>Fin n -&gt; \\alpha</code>, a) and c) are Fin.cons and Fin.snoc, and we also have <code>Fin.insertNth</code>. b) is <code>Fin.append</code>.</p>",
        "id": 405817898,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701694554
    },
    {
        "content": "<p>I've made a start on the list at <a href=\"https://github.com/leanprover-community/mathlib4/wiki/Alternate-names-for-%60List.concat%60-and-%60List.append%60\">https://github.com/leanprover-community/mathlib4/wiki/Alternate-names-for-%60List.concat%60-and-%60List.append%60</a></p>",
        "id": 405818016,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701694583
    },
    {
        "content": "<p>You may, for Lean at least, want to (as I just have there) note what we do for a few other datatypes - like <code>Fin.snoc</code> and <code>List.concat</code> are equivalent here, and we should probably note that.</p>",
        "id": 405818154,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701694642
    },
    {
        "content": "<p>Can others edit a gist?</p>",
        "id": 405818167,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701694648
    },
    {
        "content": "<p>Also apparantly in Python you can do mylist.append([\"a\", \"b\", \"c\"]) as well as mylist.append(\"a\"). Absolutely cursed language.</p>",
        "id": 405818759,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701694809
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/405818016\">said</a>:</p>\n<blockquote>\n<p>I've made a start on the list at <a href=\"https://github.com/leanprover-community/mathlib4/wiki/Alternate-names-for-%60List.concat%60-and-%60List.append%60\">https://github.com/leanprover-community/mathlib4/wiki/Alternate-names-for-%60List.concat%60-and-%60List.append%60</a></p>\n</blockquote>\n<p>Maybe you should also add whats <code>List.join</code> in Lean as a column since it also fights for the same name.</p>",
        "id": 405818804,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1701694825
    },
    {
        "content": "<p>Also you have<code> .extend</code> in Python which adds elements of an iterable to the end of a list.</p>",
        "id": 405818881,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701694848
    },
    {
        "content": "<p>I've added PHP because we may as well look at the cursed languages first. Though functional ones probably a better shout.</p>",
        "id": 405819926,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701695148
    },
    {
        "content": "<p>Scala has some very pleasing notation.</p>",
        "id": 405823548,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701696326
    },
    {
        "content": "<p><code>(:+)</code>, <code>(+:)</code>, and <code>(++)</code> for a), b) and c) respectively.</p>",
        "id": 405827866,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701697737
    },
    {
        "content": "<p>I don't think we currently have <code>join</code> for tuples but it would be easy enough to do, as we have all the parts. I've added a note in about this.</p>",
        "id": 405862985,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701707000
    },
    {
        "content": "<p>What this analysis is showing so far is that our use of <code>append</code> is not universal but not unknown. Our use of concat, however, I have seen nothing else like.</p>",
        "id": 405863141,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701707037
    },
    {
        "content": "<p>It does seem like renaming <code>concat</code> to <code>snoc</code> would be enough to avoid confusion</p>",
        "id": 405863890,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701707209
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/405862985\">said</a>:</p>\n<blockquote>\n<p>I don't think we currently have <code>join</code> for tuples but it would be easy enough to do, as we have all the parts. I've added a note in about this.</p>\n</blockquote>\n<p>Arguably that should work for mixed lengths of tuples</p>",
        "id": 405864134,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701707270
    },
    {
        "content": "<p>Ah, where the length is dependent on the index?</p>",
        "id": 405866986,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701708008
    },
    {
        "content": "<p>That's a more interesting challenge.</p>",
        "id": 405867017,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701708018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/405863890\">said</a>:</p>\n<blockquote>\n<p>It does seem like renaming <code>concat</code> to <code>snoc</code> would be enough to avoid confusion</p>\n</blockquote>\n<p>I think there are two, maybe three things.</p>\n<ul>\n<li>Rename <code>concat</code> to <code>snoc</code>. It is unequivocally the wrong name currently.</li>\n<li>Decide whether we want to use concat at all. (I actually think the answer here is <strong>we don't</strong>, but other options are \"use it where we use append\" and \"use it where we use join\".)</li>\n<li>Edit documentation so that we have no instances where we describe a function called \"append\" by saying that it concatenates. Either it should be called <code>concat</code>, or it should be described differently. Do similar for functions described as appending (though I think it's reasonably to say \"<code>snoc</code> appends an element to the end of the list, so I'm not so hardline on this).</li>\n</ul>",
        "id": 405867819,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701708241
    },
    {
        "content": "<p>Optionally, you could try and make a mutable/immutable distinction, but I think we probably won't.</p>",
        "id": 405868110,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701708315
    },
    {
        "content": "<p>Array uses <code>push</code> which I find quite natural in that context.  It's easier to pronounce that <code>snoc</code> and <code>List.push</code> would probably not confuse people.</p>",
        "id": 405872803,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1701709486
    },
    {
        "content": "<p>I don't disagree with that, but then in that case I would like to change all uses of <code>snoc</code> to the same thing...</p>",
        "id": 405877861,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701710777
    },
    {
        "content": "<p>I would probably find O(n) <code>push</code> to be somewhat confusing</p>",
        "id": 405877902,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1701710789
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/405864134\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/405862985\">said</a>:</p>\n<blockquote>\n<p>I don't think we currently have <code>join</code> for tuples but it would be easy enough to do, as we have all the parts. I've added a note in about this.</p>\n</blockquote>\n<p>Arguably that should work for mixed lengths of tuples</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sigmaCurry</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"o\">((</span><span class=\"bp\">Σ</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">g</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n  <span class=\"n\">invFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">⟩</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">ext</span> <span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">ext</span> <span class=\"bp\">;</span> <span class=\"n\">rfl</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n<span class=\"kd\">def</span> <span class=\"n\">finSigmaFinEquiv</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">≃</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">finDepJoin</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">sigmaCurry</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">Equiv.arrowCongr</span> <span class=\"o\">(</span><span class=\"n\">finSigmaFinEquiv</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Equiv.refl</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Something like this I think, but we need someone (<span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> ???) to fill in that sorry I think. I was also surprised we didn't have <code>sigmaCurry</code> but we don't as far as I can see!</p>",
        "id": 405878146,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701710864
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"221921\">Marc Huisinga</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/405877902\">said</a>:</p>\n<blockquote>\n<p>I would probably find O(n) <code>push</code> to be somewhat confusing</p>\n</blockquote>\n<p>Yes, this is fair. And a good distinguisher! <code>snoc for O(n), push otherwise</code>is a good rule.</p>",
        "id": 405878449,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701710942
    },
    {
        "content": "<p>I would have expected it to be <code>Equiv.sigmaCurry</code> to match <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.curry#doc\">docs#Equiv.curry</a>. Funnily enough, we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DFinsupp.sigmaCurryEquiv#doc\">docs#DFinsupp.sigmaCurryEquiv</a></p>",
        "id": 405878564,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701710973
    },
    {
        "content": "<p>That sorry doesn't seem very hard but I'm working on something else right now.</p>",
        "id": 405878784,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701711028
    },
    {
        "content": "<p>Aha, it's <code>Equiv.piCurry</code></p>",
        "id": 405878890,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701711058
    },
    {
        "content": "<p>A slightly unexpected name.</p>",
        "id": 405878921,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701711065
    },
    {
        "content": "<p>I don't think it is very hard but I wanted to see if you were going to tell me \"oh yes it's a trivial consequence of such and such\".</p>",
        "id": 405879046,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701711096
    },
    {
        "content": "<p>This has finally made me intuitively understand why Sigma types are called that. So that's nice.</p>",
        "id": 405879872,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701711350
    },
    {
        "content": "<p>I would find a O(1) <code>List.push</code> confusing, but I get the point that it may lead people to think it's more efficient than it is.  Interestingly, <code>List.concat</code> is defined much earlier than <code>List.append</code> and it looks like that's done so one can give a semantics to <code>Array.push</code>.  I think one could either rename the function or also move <code>List.append</code> up so <code>List.snoc</code> is definitionally equal to <code>x ++ [y]</code>.</p>",
        "id": 405880727,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1701711618
    },
    {
        "content": "<p>It certainly looks as though you could do that. I would imagine touching the actual structure of Init.Prelude would be controversial...</p>",
        "id": 405883909,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701712831
    },
    {
        "content": "<p>I believe mathlib (or possibly std?) has a simp lemma which unconditionally simplifies <code>List.concat a b</code> to <code>a ++ [b]</code>. It is definitely dispreferred in proofs</p>",
        "id": 405901222,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701719554
    },
    {
        "content": "<p>I'm not a fan of <code>snoc</code> because it's a made up word / jargon, which languages use this name?</p>",
        "id": 405901377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701719635
    },
    {
        "content": "<p>I'm not sure why in fact. I sometimes wanted to dualise proofs by replacing <code>cons</code> with <code>concat</code> everywhere and adding the missing lemmas on the way, but mathlib worked against me by replacing everything with <code>++ [a]</code>.</p>",
        "id": 405901479,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701719666
    },
    {
        "content": "<p>Haskell has a library for snoc. It implements Tsil</p>",
        "id": 405901911,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701719866
    },
    {
        "content": "<p>Which is of course List backwards</p>",
        "id": 405901925,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701719874
    },
    {
        "content": "<p>Would it be reasonable at this point to add a table which gives a rough \"human\" assessment of the frequency at which different proposed names are used for each respective operation (as well as simple reasons/details when appropriate)? (I feel using raw numbers for the frequencies is tricky since there are a bunch of languages we haven't surveyed—a gist might be more useful.)</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>append</th>\n<th>concat</th>\n<th>join</th>\n<th>flatten</th>\n<th>snoc</th>\n<th>push</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>++</code></td>\n<td><em>often</em></td>\n<td><em>often</em></td>\n<td><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span> never</td>\n<td><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span> never</td>\n<td><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span> never</td>\n<td><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span> never</td>\n</tr>\n<tr>\n<td><code>(· ++ [·])</code></td>\n<td><em>often</em></td>\n<td><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span> never</td>\n<td><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span> never</td>\n<td><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span> never</td>\n<td>rarely, but in nearby languages&lt;br&gt;– pure jargon</td>\n<td>sometimes&lt;br&gt;+ consistent with <code>Array.push</code>&lt;br&gt;– unintuitive $O(n)$ behavior</td>\n</tr>\n<tr>\n<td><code>⋯ ++ ⋯ ++ ⋯</code></td>\n<td><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span> never</td>\n<td><em>often</em></td>\n<td><em>often</em></td>\n<td><em>often</em></td>\n<td><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span> never</td>\n<td><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span> never</td>\n</tr>\n</tbody>\n</table>\n<p>But—do we agree with these assessments?</p>",
        "id": 405946722,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1701738864
    },
    {
        "content": "<p>Btw, thought I should note that we also confusingly have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.concatMap#doc\">docs#Array.concatMap</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">concatMap</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Array</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"n\">as.foldl</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"n\">empty</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">bs</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"n\">f</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>in core.</p>",
        "id": 405947938,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1701739358
    },
    {
        "content": "<p>This is despite having both <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.flatten#doc\">docs#Array.flatten</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.join#doc\">docs#Array.join</a> in std (which mean the same thing as each other and are implemented the same way, except <code>Array.join</code> is <code>@[inline]</code>) and <code>Array.concat</code> not existing—presumably the name ought to be <code>Array.</code>(<code>flatten</code>|<code>join</code>)<code>Map</code>, or we ought to have <code>Array.concat</code></p>",
        "id": 405948710,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1701739735
    },
    {
        "content": "<p>concatMap is a fairly standard name for this. I don't think flattenMap or joinMap are as much so?</p>\n<p>I seem to recall that join, map, and \"concatMap\" are all related monadically - specifically iirc concatMap is the bind operation for the List/Array monad.</p>",
        "id": 406050202,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701780901
    },
    {
        "content": "<p>Hmm, apparently Java uses flatMap</p>",
        "id": 406050836,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701781097
    },
    {
        "content": "<p>Rust also uses <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flat_map\"><code>flat_map</code></a></p>",
        "id": 406053123,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701781807
    },
    {
        "content": "<p>Good argument for using it in some ways. But I think consistency is the key.</p>",
        "id": 406053449,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701781936
    },
    {
        "content": "<p>Also, re: <code>snoc</code> being jargon, I'd say <code>cons</code> is also very high on the jargon scale, but it's not that bad since we tend to use the <code>::</code> notation anyway.<br>\nI personally like <code>snoc</code> because it's unambiguous, so what if we take a page from Scala's book and introduce <code>Cons</code> and <code>Snoc</code> typeclasses with <code>(+:)</code> and <code>(:+)</code> notations?</p>",
        "id": 406055886,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701782721
    },
    {
        "content": "<p>Do we have a <code>(++)</code> typeclass currently?</p>",
        "id": 406056100,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701782786
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HAppend#doc\">docs#HAppend</a></p>",
        "id": 406056116,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701782793
    },
    {
        "content": "<p>Yes, <code>HAppend</code></p>",
        "id": 406056117,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701782794
    },
    {
        "content": "<p>But a cons typeclass would be more annoying because then we end up with <code>List.cons</code> not <code>HCons.cons</code> when doing list induction</p>",
        "id": 406056170,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701782816
    },
    {
        "content": "<p>(We  already have this problem for Nat, but until we solve it we probably don't want to make it worse)</p>",
        "id": 406056242,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701782837
    },
    {
        "content": "<p>Hmm, can we not define a trivial induction principle in terms of <code>HCons.cons</code> and mark that as the default eliminator?</p>",
        "id": 406056418,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701782888
    },
    {
        "content": "<p>Yes, but that also replaces the induction principle for cases, they can't currently be overridden separately.</p>",
        "id": 406057052,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701783098
    },
    {
        "content": "<p>Kyle is working on this, but it's not ready yet</p>",
        "id": 406057091,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701783114
    },
    {
        "content": "<p>Which would be annoying because then you'd also have the induction hypothesis show up if you're using cases, gotcha</p>",
        "id": 406058514,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701783591
    },
    {
        "content": "<p>Anyways, my suggestion was to use a new notation <code>+:</code> for the generic <code>cons</code>, so we could just keep on using <code>::</code> as dedicated notation for <code>List.cons</code>.</p>",
        "id": 406058726,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701783646
    },
    {
        "content": "<p>But it would be nice to unify, so maybe we can just wait with this refactor until Kyle is done</p>",
        "id": 406058894,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701783699
    },
    {
        "content": "<p>I can't promise that custom induction principles except for the nice <code>Nat</code> one will be fully supported in the short term. There turns out to be more than just splitting <code>@[eliminator]</code> into two to get the experience to be nice, unfortunately. (Right now what I'm seeing is that when you unfold a recursive definition, you get <code>Nat.add n 0</code> rather than just <code>n</code>. I'd imagine a generic <code>cons</code> could be liable to unfold too.)</p>",
        "id": 406109722,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701796942
    },
    {
        "content": "<p>There's desire for custom induction principles for more than <code>Nat</code> (for example <a href=\"https://github.com/leanprover/lean4/pull/2716\">lean4#2716</a> where extending pattern matching is considered), but in the short term the focus is just on <code>Nat</code>, where it would be a clear improvement making sure induction uses <code>0</code> and <code>n + 1</code>.</p>",
        "id": 406110557,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701797248
    },
    {
        "content": "<p>It seems we shouldn't let that derail the discussion about concat etc.</p>",
        "id": 406111615,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701797653
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406050202\">said</a>:</p>\n<blockquote>\n<p>concatMap is a fairly standard name for this. I don't think flattenMap or joinMap are as much so?</p>\n<p>I seem to recall that join, map, and \"concatMap\" are all related monadically - specifically iirc concatMap is the bind operation for the List/Array monad.</p>\n</blockquote>\n<p>Wouldn't the better, more consistent name be \"whatever we use for <code>... ++ ... ++ ...</code>, then <code>Map</code>\"? So that e.g. <code>joinMap f</code> is the same as <code>join ∘ map f</code>, just more efficient.  Otherwise we're both wrongly suggesting <code>concat</code> is involved (if that winds up existing somewhere and is not <code>... ++ ... ++ ...</code>) and making people learn an extra name even though existing notions suffice.</p>\n<p>I feel like what we prioritize when answering this also bears on <code>snoc</code>: how do we rank and balance the importance of</p>\n<ol>\n<li>being consistent with the relatively niche group of nearby functional languages and type theory literature</li>\n<li>being consistent with broader programming-language usage</li>\n<li>being internally consistent with our naming</li>\n<li>using names which reflect their intuitive, english-language meaning in their semantics</li>\n</ol>\n<p>I'd personally deprioritize (1) the most due to Lean's relationship to math, and the need to make the naming accessible and discoverable to non-programming mathematicians and newcomers. As such, I'd rank these as: 4, 2, 3, 1. (For example, re: the above discussion about <code>snoc</code>, I'd vote for <code>Prepend</code> and <code>Append</code> typeclasses over <code>Cons</code> and <code>Snoc</code>. But I wouldn't push for having an \"internally consistent\" <code>List.push</code>/<code>Array.push</code> naming scheme if this were inconsistent with broader programming-language usage.) I'm curious to hear how other people would rank these (and if there are priorities that I'm missing)!</p>",
        "id": 406162351,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1701811663
    },
    {
        "content": "<p>I think I would put 4, 3, 2, 1.</p>",
        "id": 406162605,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701811778
    },
    {
        "content": "<p>Though I might split 1 up - I think it is more important to be consistent with \"other languages that somebody using Lean will have used before\", and that probably includes Rust and Haskell but also Python and Java and C.</p>",
        "id": 406162880,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701811888
    },
    {
        "content": "<p>As we've seen, it may also be useful to look at languages like Scala to see other solutions to the notational issue.</p>",
        "id": 406162925,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701811911
    },
    {
        "content": "<p>In some sense I think the important thing to me is that it feels \"ergonomic\", which is a combination really of the concerns of 4 and 3.</p>",
        "id": 406163337,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701812080
    },
    {
        "content": "<p>Yeah, that's what's important to me too!</p>\n<p>I suppose part of the question is \"ergonomic for who, in what context\": as a bit of a programming outsider personally, I felt I didn't want to dismiss the concerns of people who felt that consistency across languages was familiar, standard, and therefore ergonomic, and was trying to balance non-programmer interests with programmer interests (since I'm guessing both will form a large share of the community).</p>\n<p>But if it were just me, or we wanted to consider a \"Lean-only\" context (such as when strictly prioritizing newcomer experience), I'd move 3 above 2 as well. (Of course, if people (such as yourself?) who are <em>not</em> \"programming outsiders\" also like 4, 3, 2, 1, I'm happy to jump on board... <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span>)</p>",
        "id": 406164810,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1701812788
    },
    {
        "content": "<p>I don't know what I am really. I suppose I have many hats. I've been a mathematician in the past but nowadays I have a bit more of a programmer view of things.</p>\n<p>In a sense what we are thinking about is what they call \"user stories\", no? The different ways people come to Lean and the different things they'll bring.</p>\n<p>I think if someone is using the List/Array parts of Lean, they are probably more likely to be someone with prior exposure to other programming languages. They're likely to be an English-language user but not necessarily someone with English as a first language, so it's important we aren't using English words in ways counter to either their dictionary or colloquial meanings. I think they'll be comfortable with the idea that different languages have different conventions and names for things, but they will bring their prior experiences to bear. And they're probably more likely than not to have experience with other functional programming languages.</p>",
        "id": 406165473,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701813119
    },
    {
        "content": "<p>For my two cents, I think <code>List.concat</code> should be named <code>List.snoc</code>. Now it is most certainly weird jargon -- built on top of the already Lisp-inspired jargon name of <code>cons</code> for prepending. However, we do use <code>cons</code> already so the connection is a bit clear. Most important, though, the use of <code>List.snoc</code> is a code smell. Thus, the fact that is jargon alerts you that you may want to be doing something different (namely, using an <code>Array</code> and <code>Array.push</code>).</p>",
        "id": 406168233,
        "sender_full_name": "Mac Malone",
        "timestamp": 1701814336
    },
    {
        "content": "<p>Array.push gives you the last inserted element of the array, is that right? Whereas List.snoc gives you the first inserted element of the list? And for both data structures, they're LIFO, so Array.push is fast and List.snoc is slow?</p>",
        "id": 406169405,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701814932
    },
    {
        "content": "<p>Hmm! So,</p>\n<ol start=\"5\">\n<li>name \"bad\" operations \"badly\" (to discourage use)</li>\n</ol>",
        "id": 406170263,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1701815437
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330967\">@Wrenna Robson</span> Sort of. <code>List</code> is a singly linked list -- LIFO at head. Thus adding and deleting is fast (<code>O(1)</code>) for the first element and slow for the last. <code>Array</code> is a growable block of contiguous memory (also known as a vector in other languages like C++ and  Rust) that expands from the tail. Thus, adding and deleting elements is fast at the end and slow at the start.</p>",
        "id": 406170268,
        "sender_full_name": "Mac Malone",
        "timestamp": 1701815442
    },
    {
        "content": "<p>Hang on! We have unicode: <code>List.ƨnoↄ</code> :P</p>",
        "id": 406170360,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1701815512
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac Malone</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406170268\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> Sort of. <code>List</code> is a singly linked list -- LIFO at head. Thus adding and deleting is fast (<code>O(1)</code>) for the first element and slow for the last. <code>Array</code> is a growable block of contiguous memory (also known as a vector in other languages like C++ and  Rust) that expands from the tail. Thus, adding and deleting elements is fast at the end and slow at the start.</p>\n</blockquote>\n<p>But \"end\" is just a matter of where you index it, I suppose.</p>",
        "id": 406170667,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701815677
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406170263\">said</a>:</p>\n<blockquote>\n<p>Hmm! So,</p>\n<ol start=\"5\">\n<li>name \"bad\" operations \"badly\" (to discourage use)</li>\n</ol>\n</blockquote>\n<p>To a certain extent, yes. This is why, for example, Python has no built-in prepend operation for lists (which are Lean's <code>Array</code>), but rather forces you to use <code>.insert(0, a)</code>. It helps highlight the fact that the action the user is performing is not quite what it appears (i.e., does not actually parallel <code>append</code> in performance).</p>",
        "id": 406170743,
        "sender_full_name": "Mac Malone",
        "timestamp": 1701815723
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330967\">@Wrenna Robson</span> Correct! \"start\" and \"end\" in this case mean lowest and highest index respectively (i.e., according to the order <code>xs[n]</code> would return).</p>",
        "id": 406170846,
        "sender_full_name": "Mac Malone",
        "timestamp": 1701815781
    },
    {
        "content": "<p>Right, deliberately tagging inefficient/likely “wrong” operations with code smell seems sensible for UX! The less times you need to know “oh, yeah, just don’t do that”, the better. I noticed that we have the same pattern for Arrays: <code>xs.insertAt! 0 x</code> seems to be the only way to do “<code>Array.cons</code>” currently.</p>",
        "id": 406171232,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1701816007
    },
    {
        "content": "<p>In a way, 5 is counterintuitively consistent with 4 and general notions of ergonomicness (ergonomicity? ergonomy?): by making only the “nice” operations ergonomic, you prevent newcomers from making mistakes by using “bad” operations freely. Then ergonomic code ↔︎ “ergonomic” algorithms (as perceived by the computer), and the broader experience of coding becomes more ergonomic since pitfalls aren’t.</p>",
        "id": 406171790,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1701816306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406171232\">said</a>:</p>\n<blockquote>\n<p>Right, deliberately tagging inefficient/likely “wrong” operations with code smell seems sensible for UX! The less times you need to know “oh, yeah, just don’t do that”, the better. I noticed that we have the same pattern for Arrays: <code>xs.insertAt! 0 x</code> seems to be the only way to do “<code>Array.cons</code>” currently.</p>\n</blockquote>\n<p>Note that this would motivate the option of just not having <code>List.concat</code> at all and using <code>x ++ [y]</code> instead</p>",
        "id": 406176182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701818435
    },
    {
        "content": "<p>which IMO is better all around</p>",
        "id": 406176227,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701818466
    },
    {
        "content": "<p>Yes I was just thinking that. Is there really any reason <em>not</em> to do that?</p>",
        "id": 406176567,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701818652
    },
    {
        "content": "<p>It's useful to have a canonical name for the operation to use in lemma names, even if we spell it with <code>++</code></p>",
        "id": 406177052,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701818909
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406176182\">said</a>:</p>\n<blockquote>\n<p>Note that this would motivate the option of just not having <code>List.concat</code> at all and using <code>x ++ [y]</code> instead</p>\n</blockquote>\n<p>True. In fact, I suspect this being the canonical representation is what lead to <code>List.concat</code> being named <code>concat</code> in the first place.</p>",
        "id": 406180999,
        "sender_full_name": "Mac Malone",
        "timestamp": 1701821161
    },
    {
        "content": "<p>Maybe <code>append1</code> (or <code>&lt;whateverwecallit&gt;1</code>) would be a sufficiently unsightly but informative option. “You’re just appending a singleton list here, nothing special.”</p>",
        "id": 406182663,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1701822005
    },
    {
        "content": "<p>Or we could simply say <code>append_singleton</code> or something in lemma names, without a dedicated definition.</p>",
        "id": 406187676,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1701824161
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406177052\">said</a>:</p>\n<blockquote>\n<p>It's useful to have a canonical name for the operation to use in lemma names, even if we spell it with <code>++</code></p>\n</blockquote>\n<p>Agreed - this could probably be snoc.</p>",
        "id": 406192577,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701826171
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406187676\">said</a>:</p>\n<blockquote>\n<p>Or we could simply say <code>append_singleton</code> or something in lemma names, without a dedicated definition.</p>\n</blockquote>\n<p>Or this, yes.</p>",
        "id": 406192635,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701826203
    },
    {
        "content": "<p>That's quite annoying for proving purposes. You really want something which is pretty short so that you can write API about it matching <code>cons</code>.</p>",
        "id": 406246052,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701847534
    },
    {
        "content": "<p>On that basis <code>snoc</code> seems perfect.</p>",
        "id": 406246263,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701847586
    },
    {
        "content": "<p>Note the context of this discussion: <code>BitVec.concat</code> (which is an efficient / \"good\" operation) was named thus to be consistent with <code>List.concat</code>. I would very much not want to call this an ugly name, so there is a tradeoff between priority 5 and internal consistency</p>",
        "id": 406251841,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701849679
    },
    {
        "content": "<p>However, if people are working with bitvectors, it's safe to assume they are at least somewhat knowledgeable programming-wise and <code>snoc</code> should make some sense, so I think this name strikes the correct balance</p>",
        "id": 406252180,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701849790
    },
    {
        "content": "<p>It also matches <code>Fin.snoc</code>, and my gut feeling is that that is more important (<code>Fin.snoc</code> and <code>Fin.append</code> are what we use for tuples, which obviously BitVec isn't but it is imo the best model for them outside of the Fin(2^m) form, see discussions passim).</p>",
        "id": 406252488,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701849908
    },
    {
        "content": "<p>Also, it should be noted that not every use of <code>concat</code> is necessarily bad. For example, it might be easier to induct on a list in terms of <code>[]</code> and <code>concat</code> in a proof. I would thus strongly suggest we do keep a name for it!</p>",
        "id": 406253168,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701850240
    },
    {
        "content": "<p>Hmm. But is it currently possible to do that i.e. do we have an induction principle for it?</p>",
        "id": 406253264,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701850296
    },
    {
        "content": "<p>We have one for <code>Vector</code> at least (which incidentally also uses <code>snoc</code>)</p>",
        "id": 406253651,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701850452
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.list_reverse_induction#doc\">docs#List.list_reverse_induction</a></p>",
        "id": 406253714,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701850473
    },
    {
        "content": "<p>Presumably you could still have the principle even if we didn't have a name for xs ++ [x]</p>",
        "id": 406253975,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701850582
    },
    {
        "content": "<p>Indeed I see that we don't use the name List.concat there!!</p>",
        "id": 406254017,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701850608
    },
    {
        "content": "<p>Sure, but having the name reinforces that this is an operation we do care about, and want to have API for. Plus, having the name makes finding that API easier</p>",
        "id": 406254214,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701850686
    },
    {
        "content": "<p>I wonder how much that inductive principle is currently used (I'm on my phone, a little fiddly to check).</p>",
        "id": 406254297,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701850726
    },
    {
        "content": "<p>I used it quite a lot in the past, but I think my uses never made it to mathlib.</p>",
        "id": 406254391,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701850768
    },
    {
        "content": "<p>Although I've not used the List one, I have used the Vector principle (which by virtue of being a subtype of List benefits from having this API as well)</p>",
        "id": 406254577,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701850839
    },
    {
        "content": "<p>what were you proving?</p>",
        "id": 406254842,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701850945
    },
    {
        "content": "<p>Properties of Vector.mapAccumr (which is a foldr in disguise)</p>",
        "id": 406254989,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701851004
    },
    {
        "content": "<p>Yeah, it makes sense that you'd use it when proving stuff about foldrs</p>",
        "id": 406255297,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701851104
    },
    {
        "content": "<p>I think I'm increasingly of the opinion - I swear I am not a lobbyist for Big Tuple - that \"cons\" for \"insert on left\", \"append\" for \"join two lists\", and \"snoc\" for \"insert on right\" are good short forms for this. With probably \"flatten\" for the other thing that gets called concat sometimes. And then I'd just ban use of concat.</p>",
        "id": 406255873,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701851292
    },
    {
        "content": "<p>But as discussed in some contexts other spellings are going to be appropriate, e.g. I like Array.push</p>",
        "id": 406255938,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701851319
    },
    {
        "content": "<p>Array is slightly different, because of it's different usage parrern, but I would like List, Vector, Fin-tuples and BitVec to all have consistent naming. The ones you propose, though, would fit for all of these IMO</p>",
        "id": 406256276,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701851433
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406252180\">said</a>:</p>\n<blockquote>\n<p>However, if people are working with bitvectors, it's safe to assume they are at least somewhat knowledgeable programming-wise and <code>snoc</code> should make some sense, so I think this name strikes the correct balance</p>\n</blockquote>\n<p>I very much disagree with this reasoning. People working with bitvectors are probably quite knowledgeable programming-wise but maybe not the kind of programming that would use <code>snoc</code>, e.g. C, LLVM, Verilog.</p>",
        "id": 406267059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701855344
    },
    {
        "content": "<p>Indeed, a more pertinent question might be \"what does SMT-Lib use\" (for instance).</p>",
        "id": 406267227,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701855403
    },
    {
        "content": "<p>I don't think they have this operation</p>",
        "id": 406267284,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701855425
    },
    {
        "content": "<p>and it makes a bit of sense, they don't often treat bits via inductive principles because inductive reasoning is hard</p>",
        "id": 406267510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701855501
    },
    {
        "content": "<p>Yes - I know they have append/concat (because it's noted in BitVec.append that concat is the thing used in SMT-Lib) but I don't know that they have - well I mean effectively it's multiplication by 2 and add 1.</p>",
        "id": 406267572,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701855523
    },
    {
        "content": "<p>\"bitblasting\" is literally just introducing 64 variables for 64 bits</p>",
        "id": 406267582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701855526
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406267510\">said</a>:</p>\n<blockquote>\n<p>and it makes a bit of sense, they don't often treat bits via inductive principles because inductive reasoning is hard</p>\n</blockquote>\n<p>Tell me about it...</p>",
        "id": 406267597,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701855532
    },
    {
        "content": "<p>they have shift left</p>",
        "id": 406267684,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701855568
    },
    {
        "content": "<p>Indeed.</p>",
        "id": 406267723,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701855585
    },
    {
        "content": "<p>aka they do it the way you would do it in C</p>",
        "id": 406267852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701855625
    },
    {
        "content": "<p>As I have been discussing ad naseum, I've been working a lot with \"pull out the Nth bit\" as an operation but I can't pretend it's a thing people do that often normally.</p>",
        "id": 406267891,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701855646
    },
    {
        "content": "<p>Hmm, good point, but <code>cons</code> would be just as unfamiliar / jargon-like for people with a C, LLVM, Verilog background. I guess my argument was more, people with such experience might be more comfortable with learning jargon (even if they don't know this particular one)</p>",
        "id": 406267903,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701855650
    },
    {
        "content": "<p>I don't think they will be using <code>cons</code> either?</p>",
        "id": 406268179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701855747
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406267510\">said</a>:</p>\n<blockquote>\n<p>and it makes a bit of sense, they don't often treat bits via inductive principles because inductive reasoning is hard</p>\n</blockquote>\n<p>Presumably, if you're choosing to reason about bitvectors <strong>in Lean</strong>, you're doing that because you want to prove things about arbitrary widths, or other kinds of proofs for which bit-blasting is insufficient, right? Or because you're implementing an SMT-solver in Lean. Otherwise, would a regular SMT-solver not work better?</p>",
        "id": 406269785,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701856341
    },
    {
        "content": "<p>Or you're coming at it from a different angle.</p>",
        "id": 406269849,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701856378
    },
    {
        "content": "<p>Fair enough, it might be that my perspective is too coloured by our particular use-case and motivation</p>",
        "id": 406269929,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701856407
    },
    {
        "content": "<p>Well, same hat. But I suppose that's my point. Everyone will have different perspectives.</p>",
        "id": 406270066,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701856449
    },
    {
        "content": "<p>Anyway, we might want to refocus the discussion back to the original topic, what/if to name <code>List.concat</code>.</p>\n<p>The latest proposal is to rename <code>List.concat</code> to <code>List.snoc</code>.<br>\nMyself, <span class=\"user-mention\" data-user-id=\"330967\">@Wrenna Robson</span>, <span class=\"user-mention\" data-user-id=\"315577\">@Mac Malone</span>, (and <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>?) have expressed support for this</p>\n<p><span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> you've stated you don't like <code>snoc</code> because it's too much jargon. How do you feel about the response that, yes, it's jargon, but since it has some pitfalls it's a good thing that the name is not too accessible (paraphrased from <span class=\"user-mention\" data-user-id=\"315577\">@Mac Malone</span>'s)</p>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> would either like to remove <code>List.concat</code> or keep it as-is.</p>\n<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>, <span class=\"user-mention\" data-user-id=\"221921\">@Marc Huisinga</span>, <span class=\"user-mention\" data-user-id=\"110994\">@Joe Hendrix</span> you've participated in the discussion, but I couldn't see a clear opinion in favor or against, maybe you'd like to share your thoughts?</p>\n<p>EDIT: to reflect Mario's response</p>",
        "id": 406270690,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701856640
    },
    {
        "content": "<p>I would like to remove it</p>",
        "id": 406270777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701856669
    },
    {
        "content": "<p>or keep it as is</p>",
        "id": 406270801,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701856676
    },
    {
        "content": "<p>Would you support keeping a succinct canonical name for use in lemmas, even if we spell it <code>xs ++ [x]</code>?</p>",
        "id": 406271630,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701856903
    },
    {
        "content": "<p>sure, Thomas suggested <code>append1</code> or <code>append_singleton</code></p>",
        "id": 406271951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701856985
    },
    {
        "content": "<p><code>append_singleton</code> is not what I'd call \"succinct\".</p>",
        "id": 406272243,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701857061
    },
    {
        "content": "<p>true. I'm fine with using domain-specific naming methods here</p>",
        "id": 406272327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857102
    },
    {
        "content": "<p>which is to say, I would prefer to be asked the question \"what to name this particular lemma\" rather than \"what to name lemmas containing <code>x ++ [y]</code> in general\"</p>",
        "id": 406272524,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857171
    },
    {
        "content": "<p>Since this is (I think) already the third thread calling out the confusing names, leaving it as-is seems undesirable</p>",
        "id": 406272569,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701857187
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406272524\">said</a>:</p>\n<blockquote>\n<p>which is to say, I would prefer to be asked the question \"what to name this particular lemma\" rather than \"what to name lemmas containing <code>x ++ [y]</code> in general\"</p>\n</blockquote>\n<p>That's quite antithetic to the naming convention.</p>",
        "id": 406272721,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701857244
    },
    {
        "content": "<p>I mean, the usual naming convention would be to call it <code>append_singleton</code> but you don't like that so <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 406272899,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857314
    },
    {
        "content": "<p>I think in many cases I can think of it won't be necessary to call out this sequence of symbols in particular</p>",
        "id": 406272966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857347
    },
    {
        "content": "<p>so it might help to talk about a particular lemma as an example at least</p>",
        "id": 406272988,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857360
    },
    {
        "content": "<p>I quite like <code>append_singleton</code>. If you really wanted you could shorten <code>singleton</code> to <code>sngletn</code> but if you want to do that we should do it everywhere (and it seems bad to me).</p>",
        "id": 406273027,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701857385
    },
    {
        "content": "<p>I think it is abbreviated to <code>single</code> in some places, but most of the time it really is the full <code>singleton</code></p>",
        "id": 406273133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857414
    },
    {
        "content": "<p>it's a long name for a short operation</p>",
        "id": 406273162,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857423
    },
    {
        "content": "<p>I recently had a similar issue with a bunch of lemmas about commutators</p>",
        "id": 406273223,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701857451
    },
    {
        "content": "<p>Following the naming convention, if we're not going to have a named definition for <code>x ++ [y]</code>, we should at least consider it as such in lemma names by using a single atom to refer to it. Eg <code>appendSingleton</code>.</p>",
        "id": 406273256,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701857463
    },
    {
        "content": "<p>no, because it's two operations</p>",
        "id": 406273284,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857475
    },
    {
        "content": "<p>Yes, but the fact is that you really do want to consider it a single operation for proving purposes!</p>",
        "id": 406273335,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701857505
    },
    {
        "content": "<p>I disagree...</p>",
        "id": 406273352,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857512
    },
    {
        "content": "<p>Yeah, really what it is is <code>append_cons_nil</code>, right?</p>",
        "id": 406273362,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701857517
    },
    {
        "content": "<p>Try splitting <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.list_reverse_induction#doc\">docs#List.list_reverse_induction</a> into something about <code>append</code> and something about <code>singleton</code>.</p>",
        "id": 406273476,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701857549
    },
    {
        "content": "<p>That's why I suggested using a one word abbreviation for the combo but Yael says it's \"antithetic to the naming convention\"</p>",
        "id": 406273505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857562
    },
    {
        "content": "<p>even though they just gave an example which is clearly using that style of naming</p>",
        "id": 406273540,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857580
    },
    {
        "content": "<p>You know when I questioned the colour of this bike shed I hadn't anticipated arguments about whether or not it should have a roof.</p>",
        "id": 406273609,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701857620
    },
    {
        "content": "<p>But I see now I was a fool.</p>",
        "id": 406273628,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701857629
    },
    {
        "content": "<blockquote>\n<p>which is to say, I would prefer to be asked the question \"what to name this particular lemma\" rather than \"what to name lemmas containing x ++ [y] in general\"</p>\n</blockquote>\n<p>My objection to this statement was that it suggested naming the sequence <code>x ++ [y]</code> differently in different lemmas</p>",
        "id": 406273638,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701857634
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406272524\">said</a>:</p>\n<blockquote>\n<p>which is to say, I would prefer to be asked the question \"what to name this particular lemma\" rather than \"what to name lemmas containing <code>x ++ [y]</code> in general\"</p>\n</blockquote>\n<p>I read this as saying that we might want to call it <code>snoc</code> in one context and <code>append_singleton</code> in another, and <code>append1</code> in yet another one, depending on the current mood.</p>",
        "id": 406273642,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701857635
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406273638\">said</a>:</p>\n<blockquote>\n<p>My objection to this statement was that it suggested naming the sequence <code>x ++ [y]</code> differently in different lemmas</p>\n</blockquote>\n<p>More like, in some situations you will be naming things other than this operation in the lemma</p>",
        "id": 406273732,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857664
    },
    {
        "content": "<p>like <code>List.reverse_induction</code></p>",
        "id": 406273787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857688
    },
    {
        "content": "<p>(actually, it's <code>List.list_reverse_induction</code>? what's up with the duplication)</p>",
        "id": 406273879,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857725
    },
    {
        "content": "<p>Sure, but a lot of the relevant API is how this operation commutes with other things, like <code>List.foldr_concat</code> or <code>List.map_concat</code></p>",
        "id": 406273945,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701857755
    },
    {
        "content": "<p>and that's great, because such lemmas are unnecessary, being a simple composition of other things</p>",
        "id": 406274052,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857795
    },
    {
        "content": "<p>Not <code>foldr_concat</code>, no.</p>",
        "id": 406274147,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701857838
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.foldr_concat#doc\">docs#List.foldr_concat</a></p>",
        "id": 406274166,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857849
    },
    {
        "content": "<p>are you sure? It looks like I could just hit it with <code>simp</code></p>",
        "id": 406274207,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857870
    },
    {
        "content": "<p>I would very much like to call that induction principle <code>List.foo_induction</code>, where <code>foo</code> is <code>snoc</code> / <code>concat</code> / <code>append_singleton</code>,</p>",
        "id": 406274212,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701857872
    },
    {
        "content": "<p>why?</p>",
        "id": 406274280,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857887
    },
    {
        "content": "<p>we don't call the other one <code>List.cons_induction</code></p>",
        "id": 406274303,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857897
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406274207\">said</a>:</p>\n<blockquote>\n<p>are you sure? It looks like I could just hit it with <code>simp</code></p>\n</blockquote>\n<p>Pretty sure, yes. Can you hit <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.foldl_cons#doc\">docs#List.foldl_cons</a> with simp?</p>",
        "id": 406274305,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701857899
    },
    {
        "content": "<p>well yes, because it's a simp lemma</p>",
        "id": 406274345,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857916
    },
    {
        "content": "<p>Okay sure, but that's not my point. Can you remove the current <code>List.foldl_cons</code> and reprove it by simp?</p>",
        "id": 406274423,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701857960
    },
    {
        "content": "<p>No, but lists are not defined symmetrically so I'm not sure what that proves</p>",
        "id": 406274471,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701857986
    },
    {
        "content": "<p>I think the answer is \"Yes, because that's the definition of <code>foldl</code>\", but that answer specifically doesn't apply to <code>foldr</code>, which doesn't use structural recursion.</p>",
        "id": 406274504,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701858001
    },
    {
        "content": "<p>I can prove <code>List.foldr_concat</code> by simp because it's a composition of simpler operations with simp lemmas</p>",
        "id": 406274566,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701858014
    },
    {
        "content": "<p>I'm not really talking about how these lemmas themselves are proved though, I'm talking about whether in user code one could prove an instance of <code>List.foldr_concat</code> by simp</p>",
        "id": 406274667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701858062
    },
    {
        "content": "<p>I don't really care how the lemmas themselves are proved (well I do but that's another discussion)</p>",
        "id": 406274721,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701858086
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406274303\">said</a>:</p>\n<blockquote>\n<p>we don't call the other one <code>List.cons_induction</code></p>\n</blockquote>\n<p>We do have <code>Fin.consInduction</code>, <code>Finset.cons_induction</code>, <code>Fin.snocInduction</code> in this pattern</p>",
        "id": 406274763,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701858105
    },
    {
        "content": "<p>eh, we have <code>Fin.snoc</code>? <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 406274886,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701858147
    },
    {
        "content": "<p>We do</p>",
        "id": 406274906,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701858154
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406274886\">said</a>:</p>\n<blockquote>\n<p>eh, we have <code>Fin.snoc</code>? <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>\n</blockquote>\n<p>I think <code>Fin.snoc</code> makes more sense than <code>List.snoc</code>? I could be wrong though. But tuples are defined quite differently...</p>",
        "id": 406275008,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701858208
    },
    {
        "content": "<p>But we also have <code>Fin.induction</code> and <code>Fin.reverseInduction</code>, so possibly the <code>constructorInduction</code> are the ones that need changing. Let's put this side-track on hold, though</p>",
        "id": 406275028,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701858217
    },
    {
        "content": "<p>I think we should be using names inspired from languages like Java, JS, Rust, Ruby. I really want to combat the common perception of functional languages as elitist \"monads are just monoids in the category of endofunctors\" stuff</p>",
        "id": 406275287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701858311
    },
    {
        "content": "<p>I am strongly opposed to the use of <code>snoc</code> in library functions, it's second-order jargon</p>",
        "id": 406275356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701858341
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406275287\">said</a>:</p>\n<blockquote>\n<p>I think we should be using names inspired from languages like Java, JS, Rust, Ruby. I really want to combat the common perception of functional languages as elitist \"monads are just monoids in the category of endofunctors\" stuff</p>\n</blockquote>\n<p>I'm not quite sure that Rust is who we should be looking at for \"don't be elitist\" cues but I agree with the sentiment.</p>",
        "id": 406275407,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701858359
    },
    {
        "content": "<p>I stand by my statement. Rust is a very good model for this kind of thing, they do think quite hard about how to connect to users coming from different backgrounds like python, JS or C</p>",
        "id": 406275783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701858491
    },
    {
        "content": "<p>Although I agree with this sentiment, we should be careful about mirroring naming that people associate with O(1) mutating operations for functional constructors</p>",
        "id": 406275862,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701858516
    },
    {
        "content": "<p>Yes, that's fair. It just amused me because I do know people who find Rust very intimidating!</p>",
        "id": 406275885,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701858526
    },
    {
        "content": "<p>Oh sure, it's a hard language for irreducible reasons</p>",
        "id": 406275905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701858540
    },
    {
        "content": "<p>but I don't think the naming of functions is the problem</p>",
        "id": 406275951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701858555
    },
    {
        "content": "<p>Lean is also a hard language for irreducible reasons</p>",
        "id": 406276022,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701858586
    },
    {
        "content": "<p>Yes, and I think it's uncommonly approachable for languages in its class, but I agree that every step towards making that even more true is good.</p>",
        "id": 406276181,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701858635
    },
    {
        "content": "<p>The closes analogue of <code>List</code> in Rust is the <code>LinkedList</code>, which uses <code>push_front()</code> and <code>push_back()</code> for adding a single element at either end, but these don't seem appropriate for functional lists</p>",
        "id": 406276340,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701858706
    },
    {
        "content": "<p>Is that true? <code>LinkedList</code> is a doubly linked list (that's why they have both I think).</p>",
        "id": 406276534,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701858776
    },
    {
        "content": "<p>That is true, my objection was mostly about <code>push</code> feeling weird in a non-mutating setting, but then again, Rust's <code>LinkedList</code> is effectively non-mutating as well, so that might just be me being too entrenched in the FP style of naming things</p>",
        "id": 406278281,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701859453
    },
    {
        "content": "<p>yeah I was thinking <code>pushBack</code> might not be so bad</p>",
        "id": 406278330,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701859473
    },
    {
        "content": "<p>we use mutating terminology in lean all the time</p>",
        "id": 406278451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701859530
    },
    {
        "content": "<p>Then I would say: for <code>List.concat</code> we drop the name (to match the fact that it's an inefficient operation, I am hesitant to call an O(n) operation <code>push</code>), but in other context (e.g, <code>BitVec</code>) where it does make sense, use <code>pushBack</code></p>",
        "id": 406278604,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701859588
    },
    {
        "content": "<p>Presumably we should also use that where we currently use <code>Fin.snoc</code>.</p>",
        "id": 406279198,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701859827
    },
    {
        "content": "<p>(It is slightly irritating that that isn't about snoc on Fin but about tuples, i.e. pi-types from Fin - but it is what it is.)</p>",
        "id": 406279336,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701859876
    },
    {
        "content": "<p>(There has been previous discussion about, and support for, creating a separate name(space) for Fin-tuples, but this is another side-track that deserves it's own thread)</p>",
        "id": 406280267,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701860231
    },
    {
        "content": "<p>(I'd support it but indeed, stay on target.)</p>",
        "id": 406280328,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701860253
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406251841\">said</a>:</p>\n<blockquote>\n<p>Note the context of this discussion: <code>BitVec.concat</code> (which is an efficient / \"good\" operation) was named thus to be consistent with <code>List.concat</code>. I would very much not want to call this an ugly name, so there is a tradeoff between priority 5 and internal consistency</p>\n</blockquote>\n<p>In this case, it seems like it should  be called <code>BitVec.push</code> (or your suggestion of <code>pushBack</code>). Alternatively, it could be called some kind of a left shift, which as Mario <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406267684\">noted</a>,  is what operation would be in lower-level languages.</p>",
        "id": 406372504,
        "sender_full_name": "Mac Malone",
        "timestamp": 1701891181
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406276340\">said</a>:</p>\n<blockquote>\n<p>The closes analogue of <code>List</code> in Rust is the <code>LinkedList</code>, which uses <code>push_front()</code> and <code>push_back()</code> for adding a single element at either end, but these don't seem appropriate for functional lists</p>\n</blockquote>\n<p>Note that Rust's <code>LinkedList</code> is a doubly linked list so both those operations are \"good\" <code>O(1)</code> operations (like <code>Array.push</code>). To me, this further reinforces that a more obscure name like <code>List.snoc</code> is key to prevent people from thinking it is a \"good\" operation.</p>",
        "id": 406373020,
        "sender_full_name": "Mac Malone",
        "timestamp": 1701891383
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406275356\">said</a>:</p>\n<blockquote>\n<p>I am strongly opposed to the use of <code>snoc</code> in library functions, it's second-order jargon</p>\n</blockquote>\n<p>It is not math jargon, though, it is very CS jargon from Lisp. (Also, it is not very hard to unpack as it is just the name of the front operation backwards.)</p>",
        "id": 406373278,
        "sender_full_name": "Mac Malone",
        "timestamp": 1701891508
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406273133\">said</a>:</p>\n<blockquote>\n<p>I think it is abbreviated to <code>single</code> in some places, but most of the time it really is the full <code>singleton</code></p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/406273162\">said</a>:</p>\n<blockquote>\n<p>it's a long name for a short operation</p>\n</blockquote>\n<p>On this bike shed, I have long wanted to suggest the much more succinct name <code>solo</code> for <code>singleton</code>. My inspiration being the name of <a href=\"https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Tuple.html#t:Solo\"><code>Data.Tuple.Solo</code></a> for a 1-tuple in Haskell.</p>",
        "id": 406373905,
        "sender_full_name": "Mac Malone",
        "timestamp": 1701891763
    },
    {
        "content": "<p>It's more of a bike warehouse at this point.</p>",
        "id": 406373973,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701891788
    },
    {
        "content": "<p>On reflection, the fact that Lean is also used for theorem proving really muddies the waters around 5. It's <em>only</em> bad to use <code>List.snoc</code> in an actual algorithm—not in a proof about list behavior! We really do need another (hopefully last) priority:</p>\n<ol start=\"6\">\n<li>name things such that theorems about them are phrased nicely</li>\n</ol>\n<p>(This splits into the type of the theorem itself being phrased nicely, and the theorem being named nicely.)</p>",
        "id": 406405528,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1701904252
    },
    {
        "content": "<p>Ultimately—after reading the 116 messages that appeared in this thread since I last looked at it :P—I think there are three paths here. In all of them, I think we should have a canonical, internally consistent name for each abstract operation (e.g. <code>push</code> for \"adding to the end of something\", something for \"putting two things together in sequence\", etc.) Then, the three paths are</p>\n<ol>\n<li>Only use the canonical name when that operation is \"ok\"—and then in individual, specific exceptions, deliberately introduce code smell when it's not a \"good\" operation (e.g. <code>List.snoc</code> instead of a 'canonical' <code>List.push</code> or whatever).</li>\n<li>Only use the canonical name when that operation is \"ok\", and leave individual, specific exceptions unnamed <em>as definitions</em> when it's not ok (e.g. just use <code>(· ++ [·])</code>. (This has two subvariants for lemma naming: (2.a) use the canonical name <em>in lemma names about  the operation</em> E.g. <code>foo_push_bar</code> for a lemma involving <code>(· ++ [·])</code>; (2.b) describe the operation faithfully (e.g. <code>append_singleton</code>/<code>append_solo</code> etc.)</li>\n<li>Always use the canonical name, but signal loudly when they're \"bad\" in the docstring. (After all, new users, who as I understand it are the main group we'd be protecting via code smell, are probably looking at hovers to figure out what things are anyway.)</li>\n</ol>\n<p>(There's also a possibly-over-engineered 4th path which I'm only half-seriously suggesting: introduce a <code>@[discouraged]</code> or <code>@[formal]</code> attribute on definitions like e.g. <code>List.push</code> which are ok in theorems but shouldn't be in runnable code, and lint against it when inside <code>def</code>s (but not in <code>theorem</code>s). Code smell → code warning lights!)</p>\n<p>We can, of course, choose any of these paths as a guideline, then deviate when there are special circumstances (for example, some operation is really special and deserves its own name for other reasons, like <code>cons</code> itself). But it might be helpful if we at least chose one. (Are there any concerns not addressed by at least one of these paths?)</p>",
        "id": 406405850,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1701904407
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> That seems like a reasonable summary.  I am in favor of consistent naming across datatypes (i.e., 3) when feasible.  </p>\n<p>I think that reduces the cognitive load for learning new APIs, and makes it easier to migrate code from one type to another for performance or other reasons.   For example, maybe somebody starts with List because it is simpler and then migrates to Array for one of their types.  It's a lot easier to do that if you don't have to rename all your function calls.</p>",
        "id": 406423909,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1701913885
    },
    {
        "content": "<p>I'd also note that <code>Array.push</code> is also O(n) if the array is shared, and that's pretty easy to make that mistake if one needs to, for example, append to an array stored inside a larger data structure.</p>",
        "id": 406424041,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1701913971
    },
    {
        "content": "<p>Yep, I have discovered that any sufficiently large lean program contains a fair number of sharing bugs</p>",
        "id": 406424081,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701914016
    }
]