[
    {
        "content": "<p>In Lean version v4.15.0, the type of this symbol</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">List.getElem</span><span class=\"bp\">?</span><span class=\"n\">_mapFinIdx</span>\n</code></pre></div>\n<p>(which is very long so its not shown here) contains a <code>.proj</code> application of this kind</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">.</span><span class=\"n\">proj</span><span class=\"w\"> </span><span class=\"ss\">`Exists</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>but <code>Exists</code> is a inductive of one variant:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Existential introduction. If `a : α` and `h : p a`,</span>\n<span class=\"sd\">  then `⟨a, h⟩` is a proof that `∃ x : α, p x`. -/</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div>\n<p>so I can't query the fields of this variant's constructor with <code>getStructureFields</code>, because Lean will panic with the message \"Structure expected\".</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">getStructureFields</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"ss\">`Exists</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">PANIC</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">getStructureInfo</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Structure</span><span class=\"o\">:</span><span class=\"mi\">135</span><span class=\"o\">:</span><span class=\"mi\">4</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">expected</span>\n<span class=\"n\">backtrace</span><span class=\"o\">:</span>\n<span class=\"bp\">././.</span><span class=\"n\">lake</span><span class=\"bp\">/</span><span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">bin</span><span class=\"bp\">/</span><span class=\"n\">test</span><span class=\"o\">(</span><span class=\"n\">lean_panic_fn</span><span class=\"bp\">+</span><span class=\"mi\">0</span><span class=\"n\">x6d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"n\">x58870e5701fd</span><span class=\"o\">]</span>\n<span class=\"bp\">././.</span><span class=\"n\">lake</span><span class=\"bp\">/</span><span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">bin</span><span class=\"bp\">/</span><span class=\"n\">test</span><span class=\"o\">(</span><span class=\"n\">l_Lean_getStructureFields</span><span class=\"bp\">+</span><span class=\"mi\">0</span><span class=\"n\">xc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"n\">x588709b92b6c</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Is there a way to get around this? I need a programmatic way to query the fields of structures. If I can get access to the corresponding field accessor function from just the type name and index in <code>.proj</code>, that is fine for me too.</p>",
        "id": 494217280,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737054992
    },
    {
        "content": "<p>Could you paste in some more information? I'm not seeing any <code>Expr.proj</code>s in the type of that theorem.</p>\n<p>In general, <code>Expr.proj</code> works for any inductive type that has one constructor, for which it's valid to project. These are currently called \"structure-likes\". They do not have fields in the sense of <code>getStructureFields</code>. That queries an environment extension that is managed by the <code>structure</code> command.</p>\n<p>I'm confused about your example however, since <code>Expr.proj</code> should not be allowed for <code>Exists</code> due to the fact that the first constructor argument is not a proof. That's the requirement for <code>Prop</code>-valued structure-likes. You can see the requirements in <code>type_checker::infer_proj</code> in the kernel.</p>",
        "id": 494221012,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737056503
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Querying.20inductive.20of.20one.20variant/near/494221012\">said</a>:</p>\n<blockquote>\n<p>Could you paste in some more information? I'm not seeing any <code>Expr.proj</code>s in the type of that theorem.</p>\n<p>In general, <code>Expr.proj</code> works for any inductive type that has one constructor, for which it's valid to project. These are currently called \"structure-likes\". They do not have fields in the sense of <code>getStructureFields</code>. That queries an environment extension that is managed by the <code>structure</code> command.</p>\n<p>I'm confused about your example however, since <code>Expr.proj</code> should not be allowed for <code>Exists</code> due to the fact that the first constructor argument is not a proof. That's the requirement for <code>Prop</code>-valued structure-likes. You can see the requirements in <code>type_checker::infer_proj</code> in the kernel.</p>\n</blockquote>\n<p>MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">coreM</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoreM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"List.getElem?_mapFinIdx\"</span><span class=\"bp\">.</span><span class=\"n\">toName</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">info</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">MonadEnv.getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">panic</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"s2\">\"Not found\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Core.transform</span><span class=\"w\"> </span><span class=\"n\">info.type</span><span class=\"w\"> </span><span class=\"bp\">λ</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">proj</span><span class=\"w\"> </span><span class=\"n\">typeName</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"n\">IO.println</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\".proj {typeName}\"</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Environment</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">importModules</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">imports</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"ss\">`Init</span><span class=\"o\">])</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">opts</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{})</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">trustLevel</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">coreM.run'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">fileName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"Dummy\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fileMap</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">source</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">positions</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">toBaseIO</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"n\">exception</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">IO.println</span><span class=\"w\"> </span><span class=\"s2\">\"Error!\"</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\">            </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">()</span>\n</code></pre></div>\n<p>If you run this in Lean v4.15.0, it outputs <code>.proj Exists</code>, so <code>Exists</code> occurs in <code>.proj</code>. This behaviour did not exist in v4.12.0.</p>",
        "id": 494221592,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737056753
    },
    {
        "content": "<p>I see, it's a projection of something of type <code>∃ (h : i &lt; l.length), l[i] = x</code>, and so projection of argument 0 is ok.</p>",
        "id": 494222390,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737057063
    },
    {
        "content": "<p>I'm curious why a raw Expr.proj is appearing here.</p>",
        "id": 494222441,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737057082
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Querying.20inductive.20of.20one.20variant/near/494222390\">said</a>:</p>\n<blockquote>\n<p>I see, it's a projection of something of type <code>∃ (h : i &lt; l.length), l[i] = x</code>, and so projection of argument 0 is ok.</p>\n</blockquote>\n<p>so how can I extract the projection function corresponding to this operator? So something like <code>Prod.fst</code> but for <code>Exists</code></p>",
        "id": 494222456,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737057090
    },
    {
        "content": "<p>There isn't one</p>",
        "id": 494222482,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737057100
    },
    {
        "content": "<p>how is that allowed</p>",
        "id": 494222560,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737057123
    },
    {
        "content": "<p>ok I'll work around it</p>",
        "id": 494222649,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737057151
    },
    {
        "content": "<p>It's a proof, so proof irrelevance is the justification</p>",
        "id": 494222690,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737057173
    },
    {
        "content": "<p>but it occurs in the definition type of <code>List.getElem?_mapFinIdx</code>. If it occurs in the value it would be proof irrelevance, right?</p>",
        "id": 494222762,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737057206
    },
    {
        "content": "<p>(In particular, the value of the projection is in the type <code>i &lt; l.length</code>, so it's possible to write such a projection yourself. Elimination is OK into a proposition.)</p>",
        "id": 494222768,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737057209
    },
    {
        "content": "<p>This projection is allowed because you can write the projection:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">hp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">hp</span>\n</code></pre></div>",
        "id": 494222974,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737057292
    },
    {
        "content": "<p>If you are OK with unnecessary axiom of choice, for <code>Exists</code> you could make use of <code>Exists.choose</code> for this projection.</p>",
        "id": 494223050,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737057329
    },
    {
        "content": "<p>Ah, now that I'm looking at the definition of that theorem, I can see where the projection is coming in:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">getElem?_mapFinIdx</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">mapFinIdx</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">?.</span><span class=\"n\">pbind</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">getElem?_eq_some_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">getElem?_def</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">length_mapFinIdx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">getElem_mapFinIdx</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>The <code>m</code> argument is the existential. When you write <code>m.1</code>, the elaborator sees that <code>m</code> is \"structure-like\", and it generates an <code>Expr.proj</code> to do the projection.</p>",
        "id": 494223321,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737057452
    },
    {
        "content": "<p>I see. Is this (<code>Exists</code>) the only occurrence of this behaviour (<code>.proj</code> but no projector function), or could there be other occurrences?</p>",
        "id": 494223374,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737057476
    },
    {
        "content": "<p>This can happen with any structure-like in conjunction with numeric projection syntax.</p>",
        "id": 494223497,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737057521
    },
    {
        "content": "<p>Relevant elaborator code: <a href=\"https://github.com/leanprover/lean4/blob/17c0187252971a65f889d78726917307ea3c0304/src/Lean/Elab/App.lean#L1204-L1206\">https://github.com/leanprover/lean4/blob/17c0187252971a65f889d78726917307ea3c0304/src/Lean/Elab/App.lean#L1204-L1206</a></p>",
        "id": 494223519,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737057533
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Querying.20inductive.20of.20one.20variant/near/494223497\">said</a>:</p>\n<blockquote>\n<p>This can happen with any structure-like and numeric projection syntax.</p>\n</blockquote>\n<p>but if I define an ordinary structure, it would have the corresponding projection functions like <code>Prof.fst</code>. <code>Exists</code> is a special case that doesn't have it due to proof irrelevance</p>",
        "id": 494223610,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737057574
    },
    {
        "content": "<p>Note that <code>matchConstStructure</code> is for structure-likes, not just <code>structure</code>-defined types.</p>",
        "id": 494223615,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737057577
    },
    {
        "content": "<p>I'm not sure I understand your last comment</p>",
        "id": 494223834,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737057658
    },
    {
        "content": "<p>so if I define a structure like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>\n<p>it would automatically generate the projector functions <code>Point.x</code> and <code>Point.y</code>. However for <code>Exists</code>, the projector functions are not generated due to proof irrelevance. Does this only happen for <code>Exists</code>?</p>",
        "id": 494223968,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737057722
    },
    {
        "content": "<p>I was under the impression that every <code>.proj</code> expression has an equivalent <code>.app</code> form and I wanted to normalize <code>.proj</code> to <code>.app</code> so its easier to generate expressions with ML. Below is from <code>Expr.lean</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">Projection</span><span class=\"bp\">-</span><span class=\"n\">expressions</span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">They</span><span class=\"w\"> </span><span class=\"n\">are</span><span class=\"w\"> </span><span class=\"n\">redundant</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">are</span><span class=\"w\"> </span><span class=\"n\">used</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">create</span><span class=\"w\"> </span><span class=\"n\">more</span><span class=\"w\"> </span><span class=\"n\">compact</span>\n<span class=\"w\">  </span><span class=\"n\">terms</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">speedup</span><span class=\"w\"> </span><span class=\"n\">reduction</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">implement</span><span class=\"w\"> </span><span class=\"n\">eta</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">structures</span><span class=\"bp\">.</span>\n</code></pre></div>",
        "id": 494226177,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737058670
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/Querying.20inductive.20of.20one.20variant/near/494223968\">said</a>:</p>\n<blockquote>\n<p>However for <code>Exists</code>, the projector functions are not generated due to proof irrelevance.</p>\n</blockquote>\n<p>This is not a correct understanding of the situation.</p>\n<p>Facts:</p>\n<ul>\n<li><code>structure</code> defines an inductive type, generates projections, and registers them.</li>\n<li><code>inductive</code> only defines an inductive type</li>\n<li>It is not possible to define <code>Exists</code> with <code>structure</code> due to the fact that it's possible for the first argument to be in <code>Type _</code> but <code>Exists</code> is <code>Prop</code>-valued, and in that case it's impossible to write universe-polymorphic projection functions. (Try defining <code>Exists</code> as a <code>structure</code> to see for yourself.)</li>\n<li>It is possible to define a projection for <code>Exists</code> <em>if we specialize the universe to <code>Prop</code></em>, like I showed you earlier.</li>\n<li>The app elaborator is willing to elaborate <code>x.1</code> into <code>Expr.proj T 0 x</code> <em>exactly when the concrete universe levels allow it</em></li>\n</ul>",
        "id": 494226398,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737058761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/Querying.20inductive.20of.20one.20variant/near/494226177\">said</a>:</p>\n<blockquote>\n<p>I was under the impression that every <code>.proj</code> expression has an equivalent <code>.app</code> form</p>\n</blockquote>\n<p>This is not the case, without defining missing projection functions yourself.</p>",
        "id": 494226446,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737058782
    },
    {
        "content": "<p>Well, you could translate it to an application of the type's recursor of course.</p>",
        "id": 494226577,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737058825
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Querying.20inductive.20of.20one.20variant/near/494226577\">said</a>:</p>\n<blockquote>\n<p>Well, you could translate it to an application of the type's recursor of course.</p>\n</blockquote>\n<p>What is the recursor in this case?</p>",
        "id": 494226603,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737058839
    },
    {
        "content": "<p><code>Exists.recOn</code>?</p>",
        "id": 494226621,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737058847
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/Querying.20inductive.20of.20one.20variant/near/494226177\">said</a>:</p>\n<blockquote>\n<p><code>They are redundant</code></p>\n</blockquote>\n<p>To be very clear, the redundancy isn't that <code>structure</code> defines projection functions. It's that every valid projection can be encoded as a recursor application.</p>",
        "id": 494226905,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737058990
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Querying.20inductive.20of.20one.20variant/near/494226905\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/Querying.20inductive.20of.20one.20variant/near/494226177\">said</a>:</p>\n<blockquote>\n<p><code>They are redundant</code></p>\n</blockquote>\n<p>To be very clear, the redundancy isn't that <code>structure</code> defines projection functions. It's that every valid projection can be encoded as a recursor application.</p>\n</blockquote>\n<p>I see. Thank you!</p>",
        "id": 494226975,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737059036
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> has marked this topic as resolved.</p>",
        "id": 494227072,
        "sender_full_name": "Notification Bot",
        "timestamp": 1737059072
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494226905\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/Querying.20inductive.20of.20one.20variant/near/494226177\">said</a>:</p>\n<blockquote>\n<p><code>They are redundant</code></p>\n</blockquote>\n<p>To be very clear, the redundancy isn't that <code>structure</code> defines projection functions. It's that every valid projection can be encoded as a recursor application.</p>\n</blockquote>\n<p>Does it mean that when <code>getStructureField </code>succeeds, a <code>.proj</code> can be converted to an equivalent function application?</p>",
        "id": 494250749,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737069431
    },
    {
        "content": "<p>Yes, that's correct.</p>\n<p>(Furthermore, the definitions of projection functions use <code>Expr.proj</code> expressions, so that's something you can use to verify it if you want.)</p>",
        "id": 494274982,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737083675
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494274982\">said</a>:</p>\n<blockquote>\n<p>Yes, that's correct.</p>\n<p>(Furthermore, the definitions of projection functions use <code>Expr.proj</code> expressions, so that's something you can use to verify it if you want.)</p>\n</blockquote>\n<p>Just a followup question, is there a way to turn a <code>.proj</code> back into a recursor application? Is the equivalence between <code>.proj</code> and recursor specified somewhere?</p>\n<p>The comment  on <code>Expr</code> says</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">When</span><span class=\"w\"> </span><span class=\"n\">exporting</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">developments</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"n\">systems</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">`proj</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">can</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">replaced</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"ss\">`typeName</span><span class=\"bp\">`.</span><span class=\"ss\">`rec</span><span class=\"bp\">`</span>\n<span class=\"w\">  </span><span class=\"n\">applications</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>so does the process exist somewhere?</p>",
        "id": 494970317,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737435900
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494970317\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494274982\">said</a>:</p>\n<blockquote>\n<p>Yes, that's correct.</p>\n<p>(Furthermore, the definitions of projection functions use <code>Expr.proj</code> expressions, so that's something you can use to verify it if you want.)</p>\n</blockquote>\n<p>Just a followup question, is there a way to turn a <code>.proj</code> back into a recursor application? Is the equivalence between <code>.proj</code> and recursor specified somewhere?</p>\n<p>The comment  on <code>Expr</code> says</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">When</span><span class=\"w\"> </span><span class=\"n\">exporting</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">developments</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"n\">systems</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">`proj</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">can</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">replaced</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"ss\">`typeName</span><span class=\"bp\">`.</span><span class=\"ss\">`rec</span><span class=\"bp\">`</span>\n<span class=\"w\">  </span><span class=\"n\">applications</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>so does the process exist somewhere?</p>\n</blockquote>\n<p>As far as i understand, proj is just rec but keeping all other fields as irrelevant.<br>\nIf a proj was made with a structure, it has a rec, in fact every inductive type has a rec and essentially all types are inductive.</p>",
        "id": 494972771,
        "sender_full_name": "Abraham Solomon",
        "timestamp": 1737437763
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494970317\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494274982\">said</a>:</p>\n<blockquote>\n<p>Yes, that's correct.</p>\n<p>(Furthermore, the definitions of projection functions use <code>Expr.proj</code> expressions, so that's something you can use to verify it if you want.)</p>\n</blockquote>\n<p>Just a followup question, is there a way to turn a <code>.proj</code> back into a recursor application? Is the equivalence between <code>.proj</code> and recursor specified somewhere?</p>\n<p>The comment  on <code>Expr</code> says</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">When</span><span class=\"w\"> </span><span class=\"n\">exporting</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">developments</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"n\">systems</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">`proj</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">can</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">replaced</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"ss\">`typeName</span><span class=\"bp\">`.</span><span class=\"ss\">`rec</span><span class=\"bp\">`</span>\n<span class=\"w\">  </span><span class=\"n\">applications</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>so does the process exist somewhere?</p>\n</blockquote>\n<p>For example this does the same thing, where the second one uses rec via the eq compiler:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"bp\">.</span><span class=\"n\">x</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"bp\">.</span><span class=\"n\">x'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>",
        "id": 494972975,
        "sender_full_name": "Abraham Solomon",
        "timestamp": 1737437917
    },
    {
        "content": "<p>Yes but in this case <code>Point.x</code> has a concrete type. For something like <code>Exists</code>, what would be the types going into <code>Exists.rec</code>?</p>",
        "id": 494973017,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737437959
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494973017\">said</a>:</p>\n<blockquote>\n<p>Yes but in this case <code>Point.x</code> has a concrete type. For something like <code>Exists</code>, what would be the types going into <code>Exists.rec</code>?</p>\n</blockquote>\n<p>Exists is actually an inductive family, not simply one inductive type. For each (α → Prop)<br>\nit is then an inductive type that lives in the Prop universe.<br>\nSo you can't do recOn it the same way, if using inductive families.</p>\n<p>You would need to recOn on the (α → Prop) at the same time. But due to the way Prop works, this is also in Prop.</p>",
        "id": 494973371,
        "sender_full_name": "Abraham Solomon",
        "timestamp": 1737438188
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776452\">Abraham Solomon</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494973371\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494973017\">said</a>:</p>\n<blockquote>\n<p>Yes but in this case <code>Point.x</code> has a concrete type. For something like <code>Exists</code>, what would be the types going into <code>Exists.rec</code>?</p>\n</blockquote>\n<p>Exists is actually an inductive family, not simply one inductive type. For each (α → Prop)<br>\nit is then an inductive type that lives in the Prop universe.<br>\nSo you can't do recOn it the same way, if using inductive families.</p>\n<p>You would need to recOn on the (α → Prop) at the same time. But due to the way Prop works, this is also in Prop.</p>\n</blockquote>\n<p>The first field of <code>Exists</code> is the witness, what prevents me from extracting the witness using the projection? There has to be some mechanism that does it</p>",
        "id": 494973423,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737438236
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494973423\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"776452\">Abraham Solomon</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494973371\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494973017\">said</a>:</p>\n<blockquote>\n<p>Yes but in this case <code>Point.x</code> has a concrete type. For something like <code>Exists</code>, what would be the types going into <code>Exists.rec</code>?</p>\n</blockquote>\n<p>Exists is actually an inductive family, not simply one inductive type. For each (α → Prop)<br>\nit is then an inductive type that lives in the Prop universe.<br>\nSo you can't do recOn it the same way, if using inductive families.</p>\n<p>You would need to recOn on the (α → Prop) at the same time. But due to the way Prop works, this is also in Prop.</p>\n</blockquote>\n<p>The first field of <code>Exists</code> is the witness, what prevents me from extracting the witness using the projection? There has to be some mechanism that does it</p>\n</blockquote>\n<p>The part in Dependent Pattern matching <a href=\"https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\">https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html</a> might help.</p>\n<p>The first field in Exists is a type, you cant extract a term of the type Prop from that. That would be tantamount to producing a proof from phrasing a theorem.</p>\n<p>Once you provide a term of that type, it becomes an inductive type with that term attached to it.</p>",
        "id": 494973576,
        "sender_full_name": "Abraham Solomon",
        "timestamp": 1737438347
    },
    {
        "content": "<p>Are you thinking of something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Exists1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Exists</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Or are you trying to get the prop term ?</p>",
        "id": 494974575,
        "sender_full_name": "Abraham Solomon",
        "timestamp": 1737439093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776452\">Abraham Solomon</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494974575\">said</a>:</p>\n<blockquote>\n<p>Are you thinking of something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Exists1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Exists</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Or are you trying to get the prop term ?</p>\n</blockquote>\n<p>No I just want to get the witness like some form of Axiom of Choice but without Choice itself (<code>Exists.choose</code>). I'm just curious what is preventing me from extracting the witness. The use case is transpilation to another formal language</p>",
        "id": 494974998,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737439335
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494974998\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"776452\">Abraham Solomon</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494974575\">said</a>:</p>\n<blockquote>\n<p>Are you thinking of something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Exists1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Exists</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Or are you trying to get the prop term ?</p>\n</blockquote>\n<p>No I just want to get the witness like some form of Axiom of Choice but without Choice itself (<code>Exists.choose</code>). I'm just curious what is preventing me from extracting the witness. The use case is transpilation to another formal language</p>\n</blockquote>\n<p>Without choice, thats a very deep question. I think its something people have tried to get rid of for a long time, and wish they wouldn't need it.</p>\n<p>The real problem is Prop contains no 'data'  of computational value,  for the sake of proof irrelevance.  </p>\n<p>That is to say, a Prop that says there are infinitely many primes does not necessarily provide you an algorithm for extracting a prime larger than any n.</p>\n<p>So i guess by design something that exists living in Prop, can only ever rec to Prop -- no extra computational data is created. </p>\n<p>If an exists Prop can always be eliminated to the value in question, without choice -- so constructively and hence computationally -- this makes a lot of classical mathematics unmanageable.</p>",
        "id": 494975795,
        "sender_full_name": "Abraham Solomon",
        "timestamp": 1737439925
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494974998\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"776452\">Abraham Solomon</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494974575\">said</a>:</p>\n<blockquote>\n<p>Are you thinking of something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Exists1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Exists</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Or are you trying to get the prop term ?</p>\n</blockquote>\n<p>No I just want to get the witness like some form of Axiom of Choice but without Choice itself (<code>Exists.choose</code>). I'm just curious what is preventing me from extracting the witness. The use case is transpilation to another formal language</p>\n</blockquote>\n<p>There is the equivalent to Exists but without the Prop universe , i believe this is the Sum type in dependent type theory. Its just Exists is the version thats proof-irrelevant and lives in a universe that impredicative. That is Exists (...) is always a Prop, whereas Sum (...) will be of Sort n for some n; not in the sort of its inputs.</p>",
        "id": 494976209,
        "sender_full_name": "Abraham Solomon",
        "timestamp": 1737440236
    },
    {
        "content": "<p>back to the original question, how can I rewrite this theorem definition using <code>Exists.rec</code> and no <code>.proj</code>? At which level should <code>Exists.rec</code> occur?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">getElem</span><span class=\"bp\">?</span><span class=\"n\">_mapFinIdx</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">l.length</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">l.mapFinIdx</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">?.</span><span class=\"n\">pbind</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">getElem</span><span class=\"bp\">?</span><span class=\"n\">_eq_some_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">⟩</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">getElem</span><span class=\"bp\">?</span><span class=\"n\">_def</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">length_mapFinIdx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">getElem_mapFinIdx</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 494976223,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737440246
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494976223\">said</a>:</p>\n<blockquote>\n<p>back to the original question, how can I rewrite this theorem definition using <code>Exists.rec</code> and no <code>.proj</code>? At which level should <code>Exists.rec</code> occur?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">getElem</span><span class=\"bp\">?</span><span class=\"n\">_mapFinIdx</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">l.length</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">l.mapFinIdx</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">?.</span><span class=\"n\">pbind</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">getElem</span><span class=\"bp\">?</span><span class=\"n\">_eq_some_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">⟩</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">getElem</span><span class=\"bp\">?</span><span class=\"n\">_def</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">length_mapFinIdx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">getElem_mapFinIdx</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>it looks like .proj is doing a lot under the hood, i am just looking at it, it uses other data types</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">LValResolution</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">projFn</span><span class=\"w\">   </span><span class=\"o\">(</span><span class=\"n\">baseStructName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">structName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fieldName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">projIdx</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">structName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">const</span><span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">baseStructName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">structName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">constName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">localRec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">baseName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fullName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fvar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>in </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"c\">/-</span><span class=\"cm\"> `structName` was declared using `inductive` command.</span>\n<span class=\"cm\">            So, we don't projection functions for it. Thus, we use `Expr.proj` -/</span>\n<span class=\"w\">          </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">LValResolution</span><span class=\"bp\">.</span><span class=\"n\">projIdx</span><span class=\"w\"> </span><span class=\"n\">structName</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p><a href=\"https://github.com/leanprover/lean4/blob/17c0187252971a65f889d78726917307ea3c0304/src/Lean/Elab/App.lean#L1204-L1206\">https://github.com/leanprover/lean4/blob/17c0187252971a65f889d78726917307ea3c0304/src/Lean/Elab/App.lean#L1204-L1206</a></p>\n<p>Which would be the general case, when its an inductive type and not simply a structure.<br>\nSo it looks like it creates this 'structure-like' auxiliary type which contains your original type; but its still an inductive type not a structure.</p>\n<p>So maybe you'd have to recOn this type, then recOn its entries with this recOn depending on the index. I don't see a trivial way to do this in general (though with exists you can hard code it).</p>",
        "id": 494977634,
        "sender_full_name": "Abraham Solomon",
        "timestamp": 1737441188
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776452\">Abraham Solomon</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494977634\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494976223\">said</a>:</p>\n<blockquote>\n<p>back to the original question, how can I rewrite this theorem definition using <code>Exists.rec</code> and no <code>.proj</code>? At which level should <code>Exists.rec</code> occur?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">getElem</span><span class=\"bp\">?</span><span class=\"n\">_mapFinIdx</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">l.length</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">l.mapFinIdx</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">?.</span><span class=\"n\">pbind</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">getElem</span><span class=\"bp\">?</span><span class=\"n\">_eq_some_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">⟩</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">getElem</span><span class=\"bp\">?</span><span class=\"n\">_def</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">length_mapFinIdx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">getElem_mapFinIdx</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>it looks like .proj is doing a lot under the hood, i am just looking at it, it uses other data types</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">LValResolution</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">projFn</span><span class=\"w\">   </span><span class=\"o\">(</span><span class=\"n\">baseStructName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">structName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fieldName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">projIdx</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">structName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">const</span><span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">baseStructName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">structName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">constName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">localRec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">baseName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fullName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fvar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>in </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"c\">/-</span><span class=\"cm\"> `structName` was declared using `inductive` command.</span>\n<span class=\"cm\">            So, we don't projection functions for it. Thus, we use `Expr.proj` -/</span>\n<span class=\"w\">          </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">LValResolution</span><span class=\"bp\">.</span><span class=\"n\">projIdx</span><span class=\"w\"> </span><span class=\"n\">structName</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p><a href=\"https://github.com/leanprover/lean4/blob/17c0187252971a65f889d78726917307ea3c0304/src/Lean/Elab/App.lean#L1204-L1206\">https://github.com/leanprover/lean4/blob/17c0187252971a65f889d78726917307ea3c0304/src/Lean/Elab/App.lean#L1204-L1206</a></p>\n<p>Which would be the general case, when its an inductive type and not simply a structure.<br>\nSo it looks like it creates this 'structure-like' auxiliary type which contains your original type; but its still an inductive type not a structure.</p>\n<p>So maybe you'd have to recOn this type, then recOn its entries with this recOn depending on the index. I don't see a trivial way to do this in general (though with exists you can hard code it).</p>\n</blockquote>\n<p>Thanks! I'll just stick to <code>.proj</code> for now then</p>",
        "id": 494978760,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737441917
    },
    {
        "content": "<p>How come <code>exact m.1</code> can exist in <code>List.getElem?_mapFinIdx</code>, but if I write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Exists</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>it shows</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">invalid</span><span class=\"w\"> </span><span class=\"n\">projection</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">expression</span>\n<span class=\"w\">  </span><span class=\"n\">e</span>\n<span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">proposition</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Exists</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">projected</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Nat</span>\n</code></pre></div>",
        "id": 494982076,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737443796
    },
    {
        "content": "<p>ok I dug into <code>List.getElem?_mapFinIdx</code> a bit more and the <code>Exists</code> shows up as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>so the <code>.proj 1</code> of this is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">l.length</span>\n</code></pre></div>\n<p>and hence is not dependent on <code>h</code> itself. Therefore it does not leak the witness in anyway</p>",
        "id": 494983358,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737444434
    },
    {
        "content": "<p>All that stuff about LValResolution doesn't directly have to do with Expr.proj. The former is an elaborator structure, and the latter is a raw expression that's checkable by the kernel.</p>",
        "id": 495098491,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737477441
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776452\">Abraham Solomon</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494973576\">said</a>:</p>\n<blockquote>\n<p>The first field in Exists is a type, you cant extract a term of the type Prop from that. That would be tantamount to producing a proof from phrasing a theorem.</p>\n</blockquote>\n<p>While this is true for the general case, this is irrelevant for well-typed <code>Expr.proj</code> expressions. I already wrote the projection here: <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494222974\">#lean4 &gt; ✔ Querying inductive of one variant @ 💬</a> </p>\n<p>The key is that for a well-typed <code>Expr.proj</code>, you can be sure that the universes are correct, so there is nothing deep about it, and no need to worry about <code>Classical.choice</code>. In this case, we can project out the first field because the target is in <code>Prop</code>.</p>",
        "id": 495099132,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737477610
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/494983358\">said</a>:</p>\n<blockquote>\n<p>and hence is not dependent on <code>h</code> itself. Therefore it does not leak the witness in anyway</p>\n</blockquote>\n<p>Take a look at the full expression for <code>l[i]</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">getElem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">instGetElemNatLtLength</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>It definitely depends on <code>h</code>.</p>\n<p>Dependence has no bearing on why Lean accepts this projection. The reason it accepts it is because <code>h</code> is a proof, it's possible write a projection, like in that message I just linked to in my previous comment.</p>",
        "id": 495099732,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737477799
    },
    {
        "content": "<p>If you see how that projection is written with <code>match</code> notation, you could unfold everything until you see the recursors.</p>\n<p>Here it is explicitly for you:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">recOn</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 495100179,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737477926
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Querying.20inductive.20of.20one.20variant/near/495100179\">said</a>:</p>\n<blockquote>\n<p>If you see how that projection is written with <code>match</code> notation, you could unfold everything until you see the recursors.</p>\n<p>Here it is explicitly for you:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">recOn</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>is there a mechanical way to do this unfolding?</p>",
        "id": 495189482,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1737515764
    },
    {
        "content": "<p>Are you asking for <code>#reduce (proofs := true) Exists.fst</code>? Or something else?</p>",
        "id": 495500179,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737639485
    }
]