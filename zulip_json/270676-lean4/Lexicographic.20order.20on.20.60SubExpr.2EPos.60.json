[
    {
        "content": "<p>Does the order which sorts <code>SubExpr.Pos</code> from left to right exist? It would allow lookup in an <code>RBMap</code> for \"match or ancestor\", using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RBMap.lowerBound#doc\">docs#RBMap.lowerBound</a> and something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Determine if `a` is an ancestor of `b`. -/</span>\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">SubExpr</span><span class=\"bp\">.</span><span class=\"n\">Pos</span><span class=\"bp\">.</span><span class=\"n\">isAncestorOf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SubExpr</span><span class=\"bp\">.</span><span class=\"n\">Pos</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">asNat</span><span class=\"w\"> </span><span class=\"bp\">â‰¤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">asNat</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">isAncestorOf</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">tail</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">asNat</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">asNat</span>\n</code></pre></div>",
        "id": 451896691,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721174894
    },
    {
        "content": "<p>If this is for doing computations on positions that come from the delaborator, something to watch out for is that some positions are non-hierarchical, coming from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.PrettyPrinter.Delaborator.SubExpr.nextExtraPos#doc\">docs#Lean.PrettyPrinter.Delaborator.SubExpr.nextExtraPos</a>. These are characterized by the fact that in base-4 they start with 2 or 3, unlike the hierarchical positions, which start with 1.</p>\n<p>For hierarchical positions, I think using lex order on the result of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.SubExpr.Pos.toArray#doc\">docs#Lean.SubExpr.Pos.toArray</a> gives what you want.</p>\n<p>An algorithm that would involve less memory allocation would be to take positions <code>a</code> and <code>b</code> (represented as <code>Nat</code>), find <code>m</code> and <code>n</code> such that the log-base-4 of <code>a*4^m</code> and <code>b*4^n</code> have the same integer part (one of <code>m</code> or <code>n</code> can be zero), and then use the usual Nat order.</p>",
        "id": 452141792,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721237563
    },
    {
        "content": "<p>Maybe this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">log4</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">acc</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">SubExpr</span><span class=\"bp\">.</span><span class=\"n\">Pos</span><span class=\"bp\">.</span><span class=\"n\">compare</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Pos</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">log4</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">asNat</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">log4</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">asNat</span>\n<span class=\"w\">  </span><span class=\"n\">Ord</span><span class=\"bp\">.</span><span class=\"n\">compare</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">asNat</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"n\">m</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">asNat</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">-</span><span class=\"n\">n</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 452143006,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721237877
    },
    {
        "content": "<p><code>log4</code> is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.SubExpr.Pos.depth#doc\">docs#Lean.SubExpr.Pos.depth</a>, right?</p>",
        "id": 452146380,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721238910
    },
    {
        "content": "<p>Yes, looks like it</p>",
        "id": 452147197,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721239093
    },
    {
        "content": "<p>Is the non-heirarchical representation documented anywhere?</p>",
        "id": 452147306,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721239125
    },
    {
        "content": "<p>(Side note: it's pretty amazing that the termination checker works for definitions like log4 now)</p>",
        "id": 452147355,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721239133
    },
    {
        "content": "<p>(I guess <code>foldr</code> could be made non-<code>partial</code> then?)</p>",
        "id": 452147560,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721239173
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Lexicographic.20order.20on.20.60SubExpr.2EPos.60/near/452147306\">said</a>:</p>\n<blockquote>\n<p>Is the non-heirarchical representation documented anywhere?</p>\n</blockquote>\n<p>Only barely, near <code>nextExtraPos</code>, but it doesn't say what they're for.</p>",
        "id": 452147570,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721239175
    },
    {
        "content": "<p>The context of this question was working out how to expand the positions in the return value of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Widget.exprDiff#doc\">docs#Lean.Widget.exprDiff</a> to correspond to the actual subexpressions that exist in the tagged text</p>",
        "id": 452147949,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721239234
    },
    {
        "content": "<p>Since right now, the diff can compute a diff in a position which isn't hoverable in the infoview, and so no diff appears</p>",
        "id": 452148078,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721239263
    },
    {
        "content": "<p>I think something to keep in mind is that SubExpr.Pos is not meant to be an index into the expression</p>",
        "id": 452148154,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721239280
    },
    {
        "content": "<p>It's simply a scheme to get unique identifiers without needing to keep track of global state</p>",
        "id": 452148214,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721239295
    },
    {
        "content": "<p>Delaborators are allowed to synthesize new subexpr positions as needed, so long as it's done in a way that won't collide with others</p>",
        "id": 452148536,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721239342
    },
    {
        "content": "<p>The linkage of a Pos to an expr is in the collected <code>State.infos</code> map</p>",
        "id": 452148750,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721239394
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Lexicographic.20order.20on.20.60SubExpr.2EPos.60/near/452148078\">said</a>:</p>\n<blockquote>\n<p>Since right now, the diff can compute a diff in a position which isn't hoverable in the infoview, and so no diff appears</p>\n</blockquote>\n<p>Hmm, the diff code assumes that positions really do correspond to subexpressions...</p>",
        "id": 452149391,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721239516
    },
    {
        "content": "<p>Regarding non-hierarchical positions, they only really show up in a couple places: structure instance fields, so you can hover over <code>x</code> and <code>y</code> in <code>{x := 1, y := 2}</code>, and on binders.</p>",
        "id": 452150269,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721239692
    },
    {
        "content": "<p>Something that would be more robust would be if the diff code left mdata nodes in the expression with <code>pp</code> configuration</p>",
        "id": 452151024,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721239839
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Lexicographic.20order.20on.20.60SubExpr.2EPos.60/near/452148078\">said</a>:</p>\n<blockquote>\n<p>Since right now, the diff can compute a diff in a position which isn't hoverable in the infoview, and so no diff appears</p>\n</blockquote>\n<p>Did you run into cases that aren't literals? Arguably the diff routine should know about OfNat expressions.</p>",
        "id": 452152909,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721240227
    },
    {
        "content": "<p>The case I was trying to handle was display the diff between <code>a_very_long_name + another_long_name</code> and <code>a_very_long_name - another_long_name</code> as just on the <code>+</code> / <code>-</code> character, though obviously that's not the same example as the one I summarize above.</p>",
        "id": 452158758,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721241513
    },
    {
        "content": "<p>For that, if you add <code>pp.tagAppFns</code> at the position of <code>a + b</code>/<code>a - b</code>, it'll make <code>+</code> and <code>-</code> hoverable, though I think the Pos will be for <code>HAdd.hAdd</code> and <code>HSub.hSub</code></p>",
        "id": 452159651,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721241771
    },
    {
        "content": "<p>Do you think it would be reasonable for the diffing machinery to do this automatically?</p>",
        "id": 452159994,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721241858
    },
    {
        "content": "<p>You can at least do <code>set_option pp.tagAppFns true</code> to experiment to see if it works, without spending time trying to make the option be precisely set</p>",
        "id": 452160165,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721241895
    },
    {
        "content": "<p>Great, thanks!</p>",
        "id": 452161060,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721242194
    },
    {
        "content": "<p>In particular, I'm thinking about things like <code>fooHom x y</code> vs <code>foo x y</code>, where seeing only the function application changing would be helpful</p>",
        "id": 452161061,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721242194
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Lexicographic.20order.20on.20.60SubExpr.2EPos.60/near/452159994\">said</a>:</p>\n<blockquote>\n<p>Do you think it would be reasonable for the diffing machinery to do this automatically?</p>\n</blockquote>\n<p>I'm wondering if diffing should be \"inside\" the delaborator, like a variant of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.PrettyPrinter.delabCore#doc\">docs#Lean.PrettyPrinter.delabCore</a> that takes two expressions and annotates expressions in a delaborator-aware way. Note for example that delabCore can do transformations like beta reduction or metavariable instantiation (plus, some delaborators do eta reduction of certain terms).</p>\n<p>Or, there's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.addPPExplicitToExposeDiff#doc\">docs#Lean.Meta.addPPExplicitToExposeDiff</a>, which adds <code>pp.explicit</code> meta nodes to show differences. It's still trying to recapitulate the delaborator by making educated guesses of where <code>pp.explicit</code>s are needed, but at least it's not messing around with getting positions right.</p>",
        "id": 452161417,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721242321
    },
    {
        "content": "<p>I could see something like addPPExplicitToExposeDiff that inserts annotations (including tagAppFns if the differences is on the function), and then having a post-delaboration pass that works on Syntax directly, if you want to mark differences with colors.</p>",
        "id": 452161589,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721242380
    },
    {
        "content": "<p>It might take some fixes to core delaborators to make sure these annotations are respected in all cases, which I think we can allocate some resources doing.</p>",
        "id": 452161825,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721242485
    }
]