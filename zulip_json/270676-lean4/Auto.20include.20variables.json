[
    {
        "content": "<p>Is the following behavour expected?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.RootsOfUnity.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.FieldTheory.Minpoly.IsIntegrallyClosed</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">minpoly</span> <span class=\"n\">Polynomial</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">IsPrimitiveRoot</span> <span class=\"n\">μ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hpos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">IsIntegral</span> <span class=\"n\">ℤ</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">use</span> <span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">monic_X_pow_sub_C</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">ne_of_lt</span> <span class=\"n\">hpos</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[((</span><span class=\"n\">IsPrimitiveRoot.iff_def</span> <span class=\"n\">μ</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">eval₂_one</span><span class=\"o\">,</span> <span class=\"n\">eval₂_X_pow</span><span class=\"o\">,</span> <span class=\"n\">eval₂_sub</span><span class=\"o\">,</span>\n      <span class=\"n\">sub_self</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">IsDomain</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CharZero</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">minpoly</span> <span class=\"n\">ℤ</span> <span class=\"n\">μ</span> <span class=\"bp\">∣</span> <span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">n.eq_zero_or_pos</span> <span class=\"k\">with</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">h0</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n  <span class=\"n\">apply</span> <span class=\"n\">minpoly.isIntegrallyClosed_dvd</span> <span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"n\">h</span> <span class=\"n\">h0</span><span class=\"o\">)</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[((</span><span class=\"n\">IsPrimitiveRoot.iff_def</span> <span class=\"n\">μ</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">aeval_X_pow</span><span class=\"o\">,</span> <span class=\"n\">eq_intCast</span><span class=\"o\">,</span> <span class=\"n\">Int.cast_one</span><span class=\"o\">,</span>\n    <span class=\"n\">aeval_one</span><span class=\"o\">,</span> <span class=\"n\">AlgHom.map_sub</span><span class=\"o\">,</span> <span class=\"n\">sub_self</span><span class=\"o\">]</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">bar</span> <span class=\"c1\">--bar ... (h : IsPrimitiveRoot μ n) (hpos : 0 &lt; n) ...</span>\n</code></pre></div>\n<p>I am a little surprised that <code>bar</code> now has <code>hpos</code> as assumption, since it is never used, now in the statement nor in the proof in the proof.</p>",
        "id": 366740413,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686905038
    },
    {
        "content": "<p>Didn't you use <code>hpos</code> on the last <code>exact</code>?</p>",
        "id": 366740889,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686905133
    },
    {
        "content": "<p>Ops</p>",
        "id": 366740933,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686905147
    },
    {
        "content": "<p>Mmm, indeed if I use <code>h</code> it doesn't, good.</p>",
        "id": 366741087,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686905176
    },
    {
        "content": "<p>May I interst you in the <code>prune</code> tactic <a href=\"https://github.com/leanprover-community/mathlib/pull/5062\">#5062</a>?</p>",
        "id": 366741199,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686905203
    },
    {
        "content": "<p>This came up in <a href=\"https://github.com/leanprover-community/mathlib4/pull/5119\">!4#5119</a>, where <code>hpos</code> is really not used, but it shows up in the statement. Let me try to minimize.</p>",
        "id": 366741269,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686905221
    },
    {
        "content": "<p>OK, I just copied/pasted the PR. My question is not how to fix it (it is enough to write <code>hpos</code> in the statement of <code>foo</code> instead of the variable line), but this is weird, isn't it?</p>",
        "id": 366742630,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686905505
    },
    {
        "content": "<p>I still see that you used <code>foo</code> in <code>bar</code>, right?</p>",
        "id": 366742904,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686905567
    },
    {
        "content": "<p>Ah, you have fabricated your internal <code>hpos</code>!!</p>",
        "id": 366743032,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686905589
    },
    {
        "content": "<p>(Sorry, I am downloading the cache and will look at this in Lean soon!)</p>",
        "id": 366743135,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686905611
    },
    {
        "content": "<p>Exactly! In mathlib3 the thing was</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">include</span> <span class=\"n\">hpos</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"bp\">...</span> <span class=\"c1\">--uses hpos</span>\n\n<span class=\"kn\">omit</span> <span class=\"n\">hpos</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"bp\">...</span>\n<span class=\"c1\">--if `n=0` then blah blah, otherwise use `bar`, but no need to suppose `hpos` from the beginning</span>\n</code></pre></div>",
        "id": 366743522,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686905689
    },
    {
        "content": "<p>I would go as far as saying that it is not just weird, I would consider this wrong...</p>",
        "id": 366743593,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686905704
    },
    {
        "content": "<p>Yes, <code>omit/include</code> have to be replaced by <code>section</code>ing.  In fact, my motivation for <code>prune</code> was exactly from a similar issue when porting <code>RatFunc</code>.</p>",
        "id": 366743801,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686905750
    },
    {
        "content": "<p>If you begin the proof of <code>bar</code> with <code>clear hpos</code>, then <code>hpos</code> does not appear in the final expression.</p>",
        "id": 366744074,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686905807
    },
    {
        "content": "<p>Ah, my understand was that Lean is now smart enough to include/not include variables in the expected way.</p>",
        "id": 366744089,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686905810
    },
    {
        "content": "<p>No, Lean is smart enough to use a superset of what is needed.</p>",
        "id": 366744219,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686905833
    },
    {
        "content": "<p>OK, so we should just be extra careful when porting, since in my example above <code>bar</code> is not anymore the mathlib3 statement, and if it not used in the file being ported (but only in later files) the problem can show up later and being quite confusing.</p>",
        "id": 366744660,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686905928
    },
    {
        "content": "<p><a href=\"#narrow/stream/270676-lean4/topic/substitute.20for.20.60include.2Fomit.60.3F\">Here</a> is where something similar happened, though it was not the first time.</p>",
        "id": 366744804,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686905958
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/270676-lean4/topic/Auto.20include.20variables/near/366744660\">said</a>:</p>\n<blockquote>\n<p>OK, so we should just be extra careful when porting, since in my example above <code>bar</code> is not anymore the mathlib3 statement, and if it not used in the file being ported (but only in later files) the problem can show up later and being quite confusing.</p>\n</blockquote>\n<p>Indeed: the issue with <code>RatFunc</code> was reported by Yuri porting <code>Laurent</code>.</p>",
        "id": 366744952,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686905996
    },
    {
        "content": "<p>I am hoping that using <code>prune 0</code> at the beginning of proofs will mitigate this, but <code>prune</code> is not in <code>Mathlib</code>.</p>",
        "id": 366745174,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686906032
    },
    {
        "content": "<p>The issue that I am referring to is <a href=\"https://github.com/leanprover-community/mathlib4/issues/4513\">#4513</a>.</p>",
        "id": 366745858,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686906172
    },
    {
        "content": "<p>It looks like an issue with <code>rcases</code> and <code>rfl</code>: using <code>rfl</code> in the first branch modifies <code>hpos</code> to <code>0 &lt; 0</code>, so it is indeed involved in the proof then.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.RootsOfUnity.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hpos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">n.eq_zero_or_pos</span> <span class=\"k\">with</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">h0</span>\n  <span class=\"gr\">sorry</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">bar</span> <span class=\"c1\">--bar ... (hpos : 0 &lt; n) ...</span>\n</code></pre></div>",
        "id": 366746850,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1686906389
    },
    {
        "content": "<p>Ah, well spotted!</p>",
        "id": 366747052,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686906430
    },
    {
        "content": "<p>As a workaround, you can <code>clear hpos</code> before the <code>rcases</code>.</p>",
        "id": 366747194,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1686906464
    },
    {
        "content": "<p>The solution in this particular case was very simple (I just wrote <code>hpos</code> in the statement of <code>foo</code>), but in general this looks like a regression from Lean3, since it's difficult to realize that <code>hpos</code> is included, and using sections can be more annoying than <code>include/omit</code> (since we have to rewrite the <code>variable</code> line at the beginning of every section needing them).</p>",
        "id": 366747888,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686906609
    },
    {
        "content": "<p>The same issue exists in Lean, not just in mathlib:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hpos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">hpos</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">bar1</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"mi\">0</span>  <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span>\n  <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"n\">Or.inr</span> <span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ_pos</span> <span class=\"n\">_</span><span class=\"o\">))</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">bar2</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"mi\">0</span>  <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">clear</span> <span class=\"n\">hpos</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span>\n  <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"n\">Or.inr</span> <span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ_pos</span> <span class=\"n\">_</span><span class=\"o\">))</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">bar1</span> <span class=\"c1\">-- bar1 {n : ℕ} (hpos : 0 &lt; n) : n = 0 ∨ 0 &lt; n</span>\n<span class=\"k\">#check</span> <span class=\"n\">bar2</span> <span class=\"c1\">-- bar2 {n : ℕ} : n = 0 ∨ 0 &lt; n</span>\n</code></pre></div>",
        "id": 366748157,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686906673
    },
    {
        "content": "<p>I agree that the automatic inclusion of all the variables in scope (instead of the ones that show up in the statement) looks like a regression to me. It was a very nice idea to start with, but my impression is that the drawbacks are outweighing the gains.</p>",
        "id": 366748420,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1686906731
    },
    {
        "content": "<p>So, clearly, the proof where <code>hpos</code> is written is the one that does not contain it...</p>",
        "id": 366748425,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686906732
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/270676-lean4/topic/Auto.20include.20variables/near/366748425\">said</a>:</p>\n<blockquote>\n<p>So, clearly, the proof where <code>hpos</code> is written is the one that does not contain it...</p>\n</blockquote>\n<p>Yeah, the real problem here is that it's very difficult to realize there's a problem...</p>",
        "id": 366748680,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686906785
    },
    {
        "content": "<p>Yes, I have already asked about restoring the \"old\" behaviour of including assumptions, but my understanding is that this is not really possible and the solution is <code>section</code>s.</p>",
        "id": 366748836,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686906833
    },
    {
        "content": "<p>Another approach which is intermediate between the lean 3 and lean 4 methods but will mostly result in a variable set like lean 3 is to use the statement of the theorem only to determine the variable set. But we will definitely need something like <code>include</code> for the cases where this is the wrong answer</p>",
        "id": 366748957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686906853
    },
    {
        "content": "<p>May I again interest you in <code>prune</code> <a href=\"https://github.com/leanprover-community/mathlib/pull/5062\">#5062</a>? <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 366749288,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686906919
    },
    {
        "content": "<p>I'm talking about default behavior</p>",
        "id": 366749365,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686906936
    },
    {
        "content": "<p>Ah, default <code>prune</code>ing would be excellent!</p>",
        "id": 366749454,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686906952
    },
    {
        "content": "<p>also I think <code>prune</code> is too aggressive, it removes even actual variables in the definition itself</p>",
        "id": 366749610,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686906982
    },
    {
        "content": "<p>Somehow, in the previous discussions, I got the impression that this was not going to happen...</p>",
        "id": 366749631,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686906985
    },
    {
        "content": "<p>A related (but less important) issue is that I've seen files where the infoview is practically unusable, because at the beginning there are like 50 variables declared, and now all of them are shown, even if for each declaration only a couple are really used.</p>",
        "id": 366749847,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686907028
    },
    {
        "content": "<p><code>Mario</code> Isn't this what happened in Lean 3: if a variable does not appear in the type, then it does not appear in context?</p>",
        "id": 366749857,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686907031
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span>  to be fair that was a problem in lean 3 as well</p>",
        "id": 366749952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686907053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> no, the rule was that if it appeared outside of a <code>begin end</code> block then it was included automatically</p>",
        "id": 366750290,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686907119
    },
    {
        "content": "<p>which is a weird rule</p>",
        "id": 366750313,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686907123
    },
    {
        "content": "<p>The presence of lots of variables in context would be mitigated by not having the ones that do not appear in the type, at least...</p>",
        "id": 366750404,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686907139
    },
    {
        "content": "<p>lots of definitions have simple types though, so you can't rely on the type alone</p>",
        "id": 366750639,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686907185
    },
    {
        "content": "<p>just think of any plain programming function, the types are all very simple</p>",
        "id": 366750852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686907216
    },
    {
        "content": "<p>Anyway, if you have suggestions about improvements to <code>prune</code>, I am happy to hear and implement them!  Also, you are not <em>required</em> to use the tactic, but it might be useful to have the option to use it, in case you do want it!</p>",
        "id": 366750909,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686907229
    },
    {
        "content": "<p>those will be hit hardest by a rule like that</p>",
        "id": 366750949,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686907238
    },
    {
        "content": "<p>I'm interested in brainstorming what is actually the expected behavior here</p>",
        "id": 366751104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686907273
    },
    {
        "content": "<p>I was certainly not advocating to use <code>prune</code> by default, but that most of the issues that have been brought up with include/omit would be at least partially mitigated by something along the lines of <code>prune</code>.</p>",
        "id": 366751143,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686907284
    },
    {
        "content": "<p>keep in mind that there is no reason at all we can't just straight up have <code>include</code> and <code>omit</code></p>",
        "id": 366751276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686907317
    },
    {
        "content": "<p>it was just a gamble to see whether the new variable inclusion behavior would suffice for everything</p>",
        "id": 366751443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686907343
    },
    {
        "content": "<p>Honestly, I think that <code>include/omit</code> was better than the current system, but not ideal.</p>",
        "id": 366751459,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686907348
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Auto.20include.20variables/near/366749952\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span>  to be fair that was a problem in lean 3 as well</p>\n</blockquote>\n<p>In Lean3 only the variables used in the statement are displayed, right?</p>",
        "id": 366751487,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686907356
    },
    {
        "content": "<p>yes but you can still have a ton of things in the statement</p>",
        "id": 366751554,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686907372
    },
    {
        "content": "<p>Riccardo, there was also the fact that <em>named</em> instances were not included by default.</p>",
        "id": 366751655,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686907392
    },
    {
        "content": "<p>Sure, but then I am ready to see all of them in the infoview...</p>\n<p>Maybe it's just that I am used to it, but I find the Lean3 behavior very natural.</p>",
        "id": 366751782,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686907420
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/270676-lean4/topic/Auto.20include.20variables/near/366751655\">said</a>:</p>\n<blockquote>\n<p>Riccardo, there was also the fact that <em>named</em> instances were not included by default.</p>\n</blockquote>\n<p>Yes, that was strange.</p>",
        "id": 366751918,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686907443
    },
    {
        "content": "<p>also it is weird to me that you would have so many unnecessary variables, that sounds like bad sectioning and hard to read besides</p>",
        "id": 366752117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686907483
    },
    {
        "content": "<p>How about this:</p>\n<ul>\n<li>variables that appear between <code>theorem</code> and <code>:=</code> are kept, as well as implied dependencies;</li>\n<li>variables that are needed to make the theorem typecheck are included, as well as dependencies;</li>\n<li>a mechanism for including more than this, if desired.</li>\n</ul>",
        "id": 366752358,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686907541
    },
    {
        "content": "<p>so <code>variable (x : Nat) in example := x</code> fails?</p>",
        "id": 366752774,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686907619
    },
    {
        "content": "<p>Mario, I think that the bad sectioning is a consequence of porting files that exploited <code>omit/include</code> and not used <code>section</code>s.  For native Lean 4 files, I think that people would start <code>section</code>s when they got annoyed by the amount of available variables...</p>",
        "id": 366752819,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686907627
    },
    {
        "content": "<p>To give an example, the file I am thinking about is <code>Mathlib.Analysis.NormedSpace.LinearIsometry</code>, that starts with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">R₂</span> <span class=\"n\">R₃</span> <span class=\"n\">R₄</span> <span class=\"n\">E</span> <span class=\"n\">E₂</span> <span class=\"n\">E₃</span> <span class=\"n\">E₄</span> <span class=\"n\">F</span> <span class=\"bp\">𝓕</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R₃</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R₄</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">σ₁₂</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">R₂</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">σ₂₁</span> <span class=\"o\">:</span> <span class=\"n\">R₂</span> <span class=\"bp\">→+*</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">σ₁₃</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">R₃</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">σ₃₁</span> <span class=\"o\">:</span> <span class=\"n\">R₃</span> <span class=\"bp\">→+*</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">σ₁₄</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">R₄</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">σ₄₁</span> <span class=\"o\">:</span> <span class=\"n\">R₄</span> <span class=\"bp\">→+*</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">σ₂₃</span> <span class=\"o\">:</span> <span class=\"n\">R₂</span> <span class=\"bp\">→+*</span> <span class=\"n\">R₃</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">σ₃₂</span> <span class=\"o\">:</span> <span class=\"n\">R₃</span> <span class=\"bp\">→+*</span> <span class=\"n\">R₂</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">σ₂₄</span> <span class=\"o\">:</span> <span class=\"n\">R₂</span> <span class=\"bp\">→+*</span> <span class=\"n\">R₄</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">σ₄₂</span> <span class=\"o\">:</span> <span class=\"n\">R₄</span> <span class=\"bp\">→+*</span> <span class=\"n\">R₂</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">σ₃₄</span> <span class=\"o\">:</span> <span class=\"n\">R₃</span> <span class=\"bp\">→+*</span> <span class=\"n\">R₄</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">σ₄₃</span> <span class=\"o\">:</span> <span class=\"n\">R₄</span> <span class=\"bp\">→+*</span> <span class=\"n\">R₃</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">RingHomInvPair</span> <span class=\"n\">σ₁₂</span> <span class=\"n\">σ₂₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">RingHomInvPair</span> <span class=\"n\">σ₂₁</span> <span class=\"n\">σ₁₂</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">RingHomInvPair</span> <span class=\"n\">σ₁₃</span> <span class=\"n\">σ₃₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">RingHomInvPair</span> <span class=\"n\">σ₃₁</span> <span class=\"n\">σ₁₃</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">RingHomInvPair</span> <span class=\"n\">σ₂₃</span> <span class=\"n\">σ₃₂</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">RingHomInvPair</span> <span class=\"n\">σ₃₂</span> <span class=\"n\">σ₂₃</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">RingHomInvPair</span> <span class=\"n\">σ₁₄</span> <span class=\"n\">σ₄₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">RingHomInvPair</span> <span class=\"n\">σ₄₁</span> <span class=\"n\">σ₁₄</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">RingHomInvPair</span> <span class=\"n\">σ₂₄</span> <span class=\"n\">σ₄₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">RingHomInvPair</span> <span class=\"n\">σ₄₂</span> <span class=\"n\">σ₂₄</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">RingHomInvPair</span> <span class=\"n\">σ₃₄</span> <span class=\"n\">σ₄₃</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">RingHomInvPair</span> <span class=\"n\">σ₄₃</span> <span class=\"n\">σ₃₄</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">RingHomCompTriple</span> <span class=\"n\">σ₁₂</span> <span class=\"n\">σ₂₃</span> <span class=\"n\">σ₁₃</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">RingHomCompTriple</span> <span class=\"n\">σ₁₂</span> <span class=\"n\">σ₂₄</span> <span class=\"n\">σ₁₄</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">RingHomCompTriple</span> <span class=\"n\">σ₂₃</span> <span class=\"n\">σ₃₄</span> <span class=\"n\">σ₂₄</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">RingHomCompTriple</span> <span class=\"n\">σ₁₃</span> <span class=\"n\">σ₃₄</span> <span class=\"n\">σ₁₄</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">RingHomCompTriple</span> <span class=\"n\">σ₃₂</span> <span class=\"n\">σ₂₁</span> <span class=\"n\">σ₃₁</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">RingHomCompTriple</span> <span class=\"n\">σ₄₂</span> <span class=\"n\">σ₂₁</span> <span class=\"n\">σ₄₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">RingHomCompTriple</span> <span class=\"n\">σ₄₃</span> <span class=\"n\">σ₃₂</span> <span class=\"n\">σ₄₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">RingHomCompTriple</span> <span class=\"n\">σ₄₃</span> <span class=\"n\">σ₃₁</span> <span class=\"n\">σ₄₁</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">SeminormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SeminormedAddCommGroup</span> <span class=\"n\">E₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SeminormedAddCommGroup</span> <span class=\"n\">E₃</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">SeminormedAddCommGroup</span> <span class=\"n\">E₄</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R₂</span> <span class=\"n\">E₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R₃</span> <span class=\"n\">E₃</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R₄</span> <span class=\"n\">E₄</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 366752870,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686907638
    },
    {
        "content": "<p>are those all being used in a single theorem?</p>",
        "id": 366752986,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686907669
    },
    {
        "content": "<p>that's horrific</p>",
        "id": 366753025,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686907676
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Auto.20include.20variables/near/366752774\">said</a>:</p>\n<blockquote>\n<p>so <code>variable (x : Nat) in example := x</code> fails?</p>\n</blockquote>\n<p>Let me see how Lean 3 handled this.</p>",
        "id": 366753124,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686907689
    },
    {
        "content": "<p>it's not in a begin end block</p>",
        "id": 366753184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686907702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Auto.20include.20variables/near/366752986\">said</a>:</p>\n<blockquote>\n<p>are those all being used in a single theorem?</p>\n</blockquote>\n<p>I would be <em>very</em> surprised if they're all needed in a single declaration.</p>",
        "id": 366753217,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686907709
    },
    {
        "content": "<p><code>example := by exact x</code> will fail in lean 3</p>",
        "id": 366753247,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686907716
    },
    {
        "content": "<p>Ok, so I would be happy with failure also in Lean 4...  <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 366753485,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686907766
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> that's also terrible because now you have to remember what implications each of those definitions has</p>",
        "id": 366753507,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686907771
    },
    {
        "content": "<p>... unless there was a mechanism for detecting that a variables comes from an <code>in</code>, in which case you really intended it to be present.  I suspect this is not possible, though.</p>",
        "id": 366753722,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686907812
    },
    {
        "content": "<p>even if you could, <code>section variable (x : Nat) example := x end</code> isn't that unusual either</p>",
        "id": 366753966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686907868
    },
    {
        "content": "<p>Ultimately, I think that if you really want a variable to appear in the signature, it is your responsibility of making it appear...</p>",
        "id": 366754011,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686907877
    },
    {
        "content": "<p>Mario, sure, but we already lived with that not working in Lean 3, right?</p>",
        "id": 366754106,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686907898
    },
    {
        "content": "<p>We could do heuristic name resolution of the body to see whether any variables are being referred to</p>",
        "id": 366754433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686907948
    },
    {
        "content": "<p>Especially since with <code>section variable (x y : Nat) example := x end</code>, I would not want <code>y</code> to appear, but this requires processing the whole proof, before realizing that <code>y</code> was not needed...</p>",
        "id": 366754434,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686907948
    },
    {
        "content": "<p>So it is not really good for writing the proof, only as an afterthought (for which the unused_variables linter is pretty good).</p>",
        "id": 366754590,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686907980
    },
    {
        "content": "<p>Moreover, with regards to readability of source code, having a <code>variable</code> defined at the beginning of a file and then passed though hundreds of lines of code with no further explicit mention is not always the best...</p>",
        "id": 366754976,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686908050
    },
    {
        "content": "<p>My conclusion is that Lean should aim to err on including too little, rather than too much.  And the choice should be made at the beginning of the proof and not modified after the proof.</p>",
        "id": 366755391,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686908147
    },
    {
        "content": "<p>Right now, you only see which variables make it into the final type if you <code>#check</code> it after the fact.</p>",
        "id": 366755584,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686908175
    },
    {
        "content": "<p>TBH it seems like the current strategy has actually worked pretty well</p>",
        "id": 366755677,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686908196
    },
    {
        "content": "<p>For me, once I am inside the <code>:= by ...</code> block, I want to assume that everything that I see is going to show up in the declaration.</p>",
        "id": 366755760,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686908214
    },
    {
        "content": "<p>it has got us through most of mathlib which I don't think you can say the same for the lean 3 style, there are lots of include/omit</p>",
        "id": 366755820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686908227
    },
    {
        "content": "<p>how common is it to need to use <code>clear</code> or <code>prune</code>, as a percentage of all theorems?</p>",
        "id": 366756074,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686908279
    },
    {
        "content": "<p>vs <code>include/omit</code></p>",
        "id": 366756168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686908289
    },
    {
        "content": "<p>My experience with the porting of <code>include/omit</code> was that they had to be <code>section</code>ed.  Of course, this is probably due to the fact that the initial file was written leveraging an option that is no longer available.  However, excessive assumptions in a statement that do not eventually appear in the type is somewhat annoying.</p>",
        "id": 366756246,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686908309
    },
    {
        "content": "<p>I think <code>clear/prune</code> are much less used than <code>include/omit</code></p>",
        "id": 366756261,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686908313
    },
    {
        "content": "<p>Certainly <code>prune</code> is <em>never</em> used, since it does not exist in mathlib!  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 366756393,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686908342
    },
    {
        "content": "<p>It would be interesting to see how many proofs can begin with <code>clear ...</code> and still produce the same declaration.  My guess is that \"a huge number\" is the answer.</p>",
        "id": 366756670,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686908387
    },
    {
        "content": "<p>I assume that in the future people will want to write in mathlib 4 directly rather than using mathport. I think it is fair to say we have close to no experience with what works well for this.</p>",
        "id": 366756740,
        "sender_full_name": "Reid Barton",
        "timestamp": 1686908398
    },
    {
        "content": "<p>Reid, agreed.  You said better what I had meant!</p>",
        "id": 366756954,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686908425
    },
    {
        "content": "<p>I'm not sure which side that argument is defending <span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> , other than \"we don't know yet\"</p>",
        "id": 366757174,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686908476
    },
    {
        "content": "<p>Of course the goal here is to find a strategy that requires the fewest annotations on average, and it is hard to tell how biased our current data set is by its lean 3 -&gt; mathport provenance</p>",
        "id": 366757739,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686908583
    },
    {
        "content": "<p>Anyway, I think that I prefer to not have <code>x</code> in context here</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ex</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"c1\">-- would like no `x` here</span>\n</code></pre></div>",
        "id": 366757875,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686908607
    },
    {
        "content": "<p>Here is a suggestion that I haven't given too much thought, but tries to balance concision and explicitness, as well as predictability and familiarity.</p>\n<ul>\n<li>Variables are automatically included if they appear in the statement/type. Relevant instance arguments are also included according to whatever the Lean 3 rules were.</li>\n<li>There is a lightweight, <em>per-declaration</em> mechanism for including more variables. For instance, propositional hypotheses about variables will pretty much always need to be included in this way. I suggest the mechanism is to write simply <code>(x)</code> in the argument list to include the variable <code>x</code>. I would also suggest that this can be used to override the implicit/explicitness of a variable on a per-declaration basis.</li>\n</ul>",
        "id": 366757964,
        "sender_full_name": "Reid Barton",
        "timestamp": 1686908625
    },
    {
        "content": "<p>unfortunately this clashes with existing use of <code>(x)</code> in the argument use to mean the opposite thing</p>",
        "id": 366758268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686908681
    },
    {
        "content": "<p>what is the opposite thing?</p>",
        "id": 366758330,
        "sender_full_name": "Reid Barton",
        "timestamp": 1686908693
    },
    {
        "content": "<p>i.e. to declare a new <code>(x)</code> without any of the baggage (typeclass instances) of the <code>variable</code></p>",
        "id": 366758423,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686908713
    },
    {
        "content": "<p>With no type?</p>",
        "id": 366758442,
        "sender_full_name": "Reid Barton",
        "timestamp": 1686908720
    },
    {
        "content": "<p>sure, that's quite common</p>",
        "id": 366758481,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686908730
    },
    {
        "content": "<p>I write <code>{α}</code> binders all the time</p>",
        "id": 366758605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686908760
    },
    {
        "content": "<p>Really??</p>",
        "id": 366758617,
        "sender_full_name": "Reid Barton",
        "timestamp": 1686908762
    },
    {
        "content": "<p>you can just write <code>: _</code> if you want that</p>",
        "id": 366758683,
        "sender_full_name": "Reid Barton",
        "timestamp": 1686908768
    },
    {
        "content": "<p>24 hits for <code>{α}</code> in std4, 750 in mathlib4</p>",
        "id": 366758892,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686908809
    },
    {
        "content": "<p>127 of those 750 are <code>variable {α}</code></p>",
        "id": 366759034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686908840
    },
    {
        "content": "<p>it's harder to grep for occurrences of <code>{α}</code> where there is already a <code>variable {α : ...}</code> in scope</p>",
        "id": 366759295,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686908888
    },
    {
        "content": "<p>For me, what is most confusing is that the variables that appear in the infoview may not actually appear in the declaration.  Whatever aggressive/permissive convention on variable inclusion is used, I would like to be sure that if I see a variable, then it means that it is really there, not that it may disappear after closing the goal and Lean deciding that it was not used.</p>",
        "id": 366760692,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686909145
    },
    {
        "content": "<p>If this rule is enforced, then new Lean 4 files will have to find their way of dealing with not declaring lots of unused variables.</p>",
        "id": 366760894,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686909188
    },
    {
        "content": "<p>hm, I wasn't planning on changing that</p>",
        "id": 366760953,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909201
    },
    {
        "content": "<p>it's one of the cheaper things to do</p>",
        "id": 366761042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909218
    },
    {
        "content": "<p>For the mathport ones, well, not many are missing and they are slightly annoying but temporary.</p>",
        "id": 366761113,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686909231
    },
    {
        "content": "<p>Mario, changing this, will mean that a <em>lot</em> of the mathported files will no longer compile.</p>",
        "id": 366761231,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686909253
    },
    {
        "content": "<p>?</p>",
        "id": 366761289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909265
    },
    {
        "content": "<p>first of all, my concern is not primarily with mathported files</p>",
        "id": 366761351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909281
    },
    {
        "content": "<p>A lot of files begin with <code>variable {X Y : Type}</code> and then a bunch of lemmas using only <code>X</code>.</p>",
        "id": 366761425,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686909298
    },
    {
        "content": "<p>sure and that should work</p>",
        "id": 366761473,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909308
    },
    {
        "content": "<p>that's the point of the <code>variable</code> command</p>",
        "id": 366761530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909319
    },
    {
        "content": "<p>Ok, so you are thinking of changing also the convention of what variables get included by default, right?</p>",
        "id": 366761621,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686909342
    },
    {
        "content": "<p>yes</p>",
        "id": 366761682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909357
    },
    {
        "content": "<p>Sure, then I think that making this change and testing it with the mathported files will give a very good indication of what people expect!</p>",
        "id": 366761859,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686909383
    },
    {
        "content": "<p>but no matter what you do on entry, it's still possible to post process and remove the unused variables on exit</p>",
        "id": 366761870,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909387
    },
    {
        "content": "<p>I am perfectly happy (and look forward to) Lean giving me an error for having included an unnecessary hypothesis after the fact.  But I do not want it to exclude one silently.</p>",
        "id": 366762060,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686909430
    },
    {
        "content": "<p>you have better information on exit than on entry so one would expect you can make a better decision</p>",
        "id": 366762078,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909433
    },
    {
        "content": "<p>we're not talking about hypotheses you explicitly included</p>",
        "id": 366762225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909466
    },
    {
        "content": "<p>the question is about auto-included variables</p>",
        "id": 366762258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909476
    },
    {
        "content": "<p>Right now, in the infoview after <code>variable {X Y}</code>, both <code>X</code> and <code>Y</code> are available, but if one does not get used, then it disappears in the declaration and I do not know this, unless I <code>#check</code> it.</p>",
        "id": 366762401,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686909501
    },
    {
        "content": "<p>if you include a variable explicitly by whatever syntax, it's not going to be removed</p>",
        "id": 366762418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909505
    },
    {
        "content": "<p>Mario, maybe we mean different things by \"variable\"...</p>",
        "id": 366762519,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686909530
    },
    {
        "content": "<p>Let me write an example.</p>",
        "id": 366762573,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686909542
    },
    {
        "content": "<p>by the way, in case you hadn't noticed a simpler alternative to <code>#check</code> is to put the cursor on the declaration name</p>",
        "id": 366762653,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909561
    },
    {
        "content": "<p>the type of the declaration shows up in the \"expected type\" view</p>",
        "id": 366762727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909577
    },
    {
        "content": "<p>I understand what you are saying, maybe the variables should be shown in a different color or something</p>",
        "id": 366762959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909620
    },
    {
        "content": "<p>or hidden</p>",
        "id": 366762987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909625
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">silly</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  α β: Type</span>\n<span class=\"cm\">  a: α</span>\n<span class=\"cm\">  ⊢ α</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">exact</span> <span class=\"n\">a</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">silly</span>  <span class=\"c1\">-- silly {α : Type} {a : α} : α</span>\n</code></pre></div>",
        "id": 366763041,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686909636
    },
    {
        "content": "<p>My point is that I have <code>β</code> in the infoview, but not in the final declaration, nor do I get an error for it being there uselessly.</p>",
        "id": 366763313,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686909703
    },
    {
        "content": "<p>I know</p>",
        "id": 366763342,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909709
    },
    {
        "content": "<p>(The error would be at the conclusion of the proof).</p>",
        "id": 366763385,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686909720
    },
    {
        "content": "<p>it's not really there, it's available for use</p>",
        "id": 366763389,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909720
    },
    {
        "content": "<p>Sure, but removing it silently is annoying.</p>",
        "id": 366763513,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686909737
    },
    {
        "content": "<p>why?</p>",
        "id": 366763540,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909744
    },
    {
        "content": "<p>I think I like Reid's idea that <code>{x}</code> in a def or theorem means \"include the variable <code>x</code> which has previously been declared, possibly changing its binder type\" and <code>{x : Type_}</code> means \"declare a new variable <code>x</code>\". Together with automatic inclusion of variables that show up in the statement (and their typeclasses), but only those. And no <code>omit</code> or <code>include</code> as they lead to readability issues.</p>",
        "id": 366763546,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1686909747
    },
    {
        "content": "<p>I would amend the first point to <code>{x}</code> in a def or theorem <em>when a <code>variable {x : ...}</code> has been previously declared</em></p>",
        "id": 366763845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909818
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Auto.20include.20variables/near/366763540\">said</a>:</p>\n<blockquote>\n<p>why?</p>\n</blockquote>\n<p>Because it has been reported several times that Lean includes variables that can be <code>clear</code>ed and the proof keeps working.</p>",
        "id": 366763918,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686909835
    },
    {
        "content": "<p>and why is that a problem?</p>",
        "id": 366764087,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909859
    },
    {
        "content": "<p>it is quite common that you can stick a <code>clear</code> in the middle of a proof, delete half the variables and things still work</p>",
        "id": 366764215,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909883
    },
    {
        "content": "<p>It is a problem when you apply your theorem and now you have to provide a hypothesis that was not intended to be there...</p>",
        "id": 366764242,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686909889
    },
    {
        "content": "<p>that's a problem with the entry heuristic, not the exit heuristic</p>",
        "id": 366764412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909919
    },
    {
        "content": "<p>the entry heuristic being: given the set of variables, what to put in the initial context? and the exit heuristic being: given the finalized proof body, what to put in the environment?</p>",
        "id": 366764850,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686909999
    },
    {
        "content": "<p>I think that the exit heuristic should be \"everything that came in, plus error if something could have been removed\".</p>",
        "id": 366765013,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686910032
    },
    {
        "content": "<p>that sounds even worse</p>",
        "id": 366765139,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910061
    },
    {
        "content": "<p>Then, I do not care what enters: it will be removed by fixing the errors on exit.</p>",
        "id": 366765154,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686910062
    },
    {
        "content": "<p>how will you fix the errors?</p>",
        "id": 366765212,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910080
    },
    {
        "content": "<p>By removing unnecessary hypotheses.</p>",
        "id": 366765318,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686910098
    },
    {
        "content": "<p>Like how I remove the \"unused_variables\" issues.</p>",
        "id": 366765388,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686910115
    },
    {
        "content": "<p>but these are auto-included variables</p>",
        "id": 366765441,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910125
    },
    {
        "content": "<p>you didn't write syntax to include them in the first place, the entry heuristic decided to include them</p>",
        "id": 366765536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910145
    },
    {
        "content": "<p>If they had been sealed in a <code>section</code> they would not have entered, right?  So, the answer is to use a <code>section</code>.</p>",
        "id": 366765795,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686910187
    },
    {
        "content": "<p>This is what is happening now anyways, but there is no certainty about what comes out after the proof.  Sometimes the assumptions that lean chooses are correct (very often), sometimes, they are not (rare, but does happen).</p>",
        "id": 366766102,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686910243
    },
    {
        "content": "<p>This will have a very high failure rate on mathlib</p>",
        "id": 366766142,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910250
    },
    {
        "content": "<p>Can you give an example where the behavior is undesirable?</p>",
        "id": 366766408,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910297
    },
    {
        "content": "<p>I agree, so this should be disabled on mathlib, but I think that it would be an improvement for new files over the current system.</p>",
        "id": 366766445,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686910304
    },
    {
        "content": "<p>The one at the beginning of this thread.</p>",
        "id": 366766495,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686910315
    },
    {
        "content": "<p>The <code>hpos</code> assumption making it in the declaration, when it was not needed, nor wanted.</p>",
        "id": 366766616,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686910334
    },
    {
        "content": "<p>that's the entry heuristic failing</p>",
        "id": 366766655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910344
    },
    {
        "content": "<p>not the exit heuristic</p>",
        "id": 366766685,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910351
    },
    {
        "content": "<p>You can also say that it is the exit heuristic: the variable was not used, so why did it stay?</p>",
        "id": 366766761,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686910369
    },
    {
        "content": "<p>the variable was used</p>",
        "id": 366766804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910379
    },
    {
        "content": "<p>it was used by <code>cases</code> / <code>induction</code></p>",
        "id": 366766855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910394
    },
    {
        "content": "<p><code>rcases</code> in this case I guess</p>",
        "id": 366766918,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910410
    },
    {
        "content": "<p>because those tactics generalize everything in the context</p>",
        "id": 366766956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910422
    },
    {
        "content": "<p>so if the entry heuristic puts too many things in the context, these tactics pick it up and now the exit heuristic can't remove them</p>",
        "id": 366767132,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910452
    },
    {
        "content": "<p>by the time you run <code>cases</code> on the bigger context it's already too late</p>",
        "id": 366767258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910481
    },
    {
        "content": "<p>Sure, this is then an issue with the entry heuristic.  And I can measure this by looking at the context and being certain that everything that I see when starting a proof will be there at the end.  Otherwise, I might think that <code>hpos</code> has not been touched <em>explicitly</em>, so it will disappear and then be surprised when it doesn't.</p>",
        "id": 366767836,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686910601
    },
    {
        "content": "<p>I think that \"include everything\" and \"purge out as much as I can\" should not be used together.  I prefer \"conservative inclusion\" and \"warning on excludability\" as policies.</p>",
        "id": 366768292,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686910682
    },
    {
        "content": "<p>However, it is also true that the theorems that entering mathlib4 now have a lot of assumptions appearing in context, <em>because they came from mathported files</em>, where those assumptions were not in context.</p>",
        "id": 366768696,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686910763
    },
    {
        "content": "<p>I imagine that, for native Lean 4 files, this would have been mitigated beforehand by using <code>section</code>s more profusely.</p>",
        "id": 366768811,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686910791
    },
    {
        "content": "<p>The statement \"everything I see when starting a proof will be there at the end\" is saying \"the exit heuristic is a no-op\"</p>",
        "id": 366768834,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910797
    },
    {
        "content": "<p>which is not the current situation</p>",
        "id": 366768909,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910806
    },
    {
        "content": "<p>I know: right now, I do not know if what I see in context will survive the end of proof or not.  I am not very happy about this behaviour.</p>",
        "id": 366769060,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686910836
    },
    {
        "content": "<p>but let's say that the entry heuristic was smarter but the entry heuristic was still \"remove unused things\"</p>",
        "id": 366769082,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910839
    },
    {
        "content": "<p>so you see a smaller context at the beginning of the proof but some things might still be removed later</p>",
        "id": 366769231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910863
    },
    {
        "content": "<p>I would still prefer \"remove unused things <em>and tell me about it</em>!\".</p>",
        "id": 366769276,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686910867
    },
    {
        "content": "<p>and let's also say that the variables that the exit heuristic would remove are hidden from the context</p>",
        "id": 366769544,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910894
    },
    {
        "content": "<p>so now you can't see them at all, problem solved</p>",
        "id": 366769600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910904
    },
    {
        "content": "<p>So I can go back and remove them explicitly.  Otherwise, I do not know if something that I was expecting not to be used, like <code>hpos</code> above, really has been removed or not.</p>",
        "id": 366769649,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686910915
    },
    {
        "content": "<p>but if you refer to them then oops I guess they are used and now they appear in the context</p>",
        "id": 366769750,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686910925
    },
    {
        "content": "<p>Partially better, but \"touching\" in the case of <code>hpos</code> meant using a tactic that did it under the hood...</p>",
        "id": 366769937,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686910963
    },
    {
        "content": "<p>So, true, they appear in context after I use <code>cases</code>: better than never showing up, but still very sneaky...</p>",
        "id": 366770124,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686910998
    },
    {
        "content": "<p>I think these variables can be marked in such a way so as to tell tactics to ignore them</p>",
        "id": 366770247,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911023
    },
    {
        "content": "<p>this already exists</p>",
        "id": 366770296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911032
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Auto.20include.20variables/near/366769750\">said</a>:</p>\n<blockquote>\n<p>but if you refer to them then oops I guess they are used and now they appear in the context</p>\n</blockquote>\n<p>So if I use <code>induction</code> I will suddenly get a bunch of variables appearing in my context? That will be very surprising behavior.</p>",
        "id": 366770312,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1686911035
    },
    {
        "content": "<p>Oh I guess marking them as \"for manual consumption only\" fixes my concern.</p>",
        "id": 366770519,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1686911074
    },
    {
        "content": "<p>I agree with Yael: I think that taking the extra effort of making sure that what you see at the beginning of a proof is what comes out of it is part of the game.  Heuristics can help with what you get to begin with, but messing with it after/during the proof is very doubtful.</p>",
        "id": 366770761,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686911116
    },
    {
        "content": "<p>you aren't actually adding or removing variables here, that would be almost impossible. You are just hiding and unhiding variables that were always there, and/or telling tactics to ignore those variables</p>",
        "id": 366771042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911166
    },
    {
        "content": "<p>Including <code>variable</code>s in the type of the theorem statement or not based on the proof is just clearly the wrong thing to do. Imagine you have some theorem with an expensive proof and so for development purposes you temporarily replace the proof by <code>sorry</code>. Now the rest of the file cannot type check because the theorem type was changed to omit some arguments?</p>",
        "id": 366771219,
        "sender_full_name": "Reid Barton",
        "timestamp": 1686911192
    },
    {
        "content": "<p>Sure, I am happy to have every variable ever created in mathlib being imported invisibly and unusably by any proof and then not showing up in the declaration.  For me, this counts as not including.</p>",
        "id": 366771365,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686911222
    },
    {
        "content": "<p>I actually agree with that <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> , that's part of why I dislike variables to begin with</p>",
        "id": 366771582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911265
    },
    {
        "content": "<p>but it also seems likely to me that when you use <code>variable</code> in <code>def</code> it will almost always be in the body and not the type</p>",
        "id": 366771862,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911307
    },
    {
        "content": "<p>then again, maybe programming just doesn't use <code>variable</code></p>",
        "id": 366772241,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911349
    },
    {
        "content": "<p>Likewise if I am proving a theorem T and I decide to split off some of the work into a lemma L to be proved later, then I want to make the proof <code>sorry</code> for now (because maybe the lemma statement is not quite right for my purpose anyways). Then I will need to jump through some hoops anyways, to make sure that L takes the specific hypotheses needed for it to be provable, even though they are obviously not used yet.</p>",
        "id": 366772434,
        "sender_full_name": "Reid Barton",
        "timestamp": 1686911386
    },
    {
        "content": "<p>I am just going to state that in the immense majority of cases we only ever care about variables that are used in the type of a declaration, so I think completely ignoring what comes after <code>:=</code> is a good heuristic. That also means restoring <code>include</code>/<code>omit</code>.</p>",
        "id": 366772474,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1686911392
    },
    {
        "content": "<p>I can live with different conventions on what to include/exclude between <code>def</code> and <code>theorem</code>, but I think that variables in the infoview that disappear from the final declaration leads to issues.</p>",
        "id": 366772815,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686911426
    },
    {
        "content": "<p>here's a programming example from lake:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">Module</span>\n\n<span class=\"sd\">/-- Build info for the module's specified facet. -/</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">facet</span> <span class=\"o\">(</span><span class=\"n\">facet</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">Module</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">BuildInfo</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">.</span><span class=\"n\">moduleFacet</span> <span class=\"n\">self</span> <span class=\"n\">facet</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">Module</span><span class=\"o\">)</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">imports</span>            <span class=\"o\">:=</span> <span class=\"n\">self.facet</span> <span class=\"n\">importsFacet</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">transImports</span>       <span class=\"o\">:=</span> <span class=\"n\">self.facet</span> <span class=\"n\">transImportsFacet</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">precompileImports</span>  <span class=\"o\">:=</span> <span class=\"n\">self.facet</span> <span class=\"n\">precompileImportsFacet</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">leanBin</span>            <span class=\"o\">:=</span> <span class=\"n\">self.facet</span> <span class=\"n\">leanBinFacet</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">importBin</span>          <span class=\"o\">:=</span> <span class=\"n\">self.facet</span> <span class=\"n\">importBinFacet</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">olean</span>              <span class=\"o\">:=</span> <span class=\"n\">self.facet</span> <span class=\"n\">oleanFacet</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">ilean</span>              <span class=\"o\">:=</span> <span class=\"n\">self.facet</span> <span class=\"n\">ileanFacet</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">c</span>                  <span class=\"o\">:=</span> <span class=\"n\">self.facet</span> <span class=\"n\">cFacet</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">o</span>                  <span class=\"o\">:=</span> <span class=\"n\">self.facet</span> <span class=\"n\">oFacet</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">dynlib</span>             <span class=\"o\">:=</span> <span class=\"n\">self.facet</span> <span class=\"n\">dynlibFacet</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Module</span>\n</code></pre></div>",
        "id": 366772883,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911435
    },
    {
        "content": "<p>We don't need <code>include/omit</code> if we follow Reid's suggestion as in <a href=\"#narrow/stream/270676-lean4/topic/Auto.20include.20variables/near/366763546\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Auto.20include.20variables/near/366763546</a></p>",
        "id": 366773092,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1686911462
    },
    {
        "content": "<p>Or maybe it's desirable to have different elaboration procedures for <code>def</code>/<code>abbrev</code>/<code>structure</code>/<code>class</code>  vs <code>theorem</code>/<code>lemma</code>?</p>",
        "id": 366773125,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1686911467
    },
    {
        "content": "<p>most of the examples I am finding in lean core are in types or typeclasses</p>",
        "id": 366773199,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911476
    },
    {
        "content": "<p>oh also this trick</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ctx</span> <span class=\"o\">:</span> <span class=\"n\">Context</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">builtin</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">compileEmbeddedParsers</span> <span class=\"o\">:</span> <span class=\"n\">ParserDescr</span> <span class=\"bp\">→</span> <span class=\"n\">MetaM</span> <span class=\"n\">Unit</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ParserDescr.const</span> <span class=\"n\">_</span>                <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ParserDescr.unary</span> <span class=\"n\">_</span> <span class=\"n\">d</span>              <span class=\"bp\">=&gt;</span> <span class=\"n\">compileEmbeddedParsers</span> <span class=\"n\">d</span>\n</code></pre></div>",
        "id": 366773343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911497
    },
    {
        "content": "<p>Maybe we should have a <code>set_option math</code> and <code>set_option programming</code>...</p>",
        "id": 366773375,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686911502
    },
    {
        "content": "<p>using <code>variable</code> like this means you don't have to refer to them in recursive calls</p>",
        "id": 366773447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911516
    },
    {
        "content": "<p>I think that for math theorems, having to go the extra mile to include a variable that is not present in the type, means that almost always you will not need to do the extra work.</p>",
        "id": 366773812,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686911568
    },
    {
        "content": "<p>Wait why does that recursive example work?</p>",
        "id": 366774141,
        "sender_full_name": "Reid Barton",
        "timestamp": 1686911623
    },
    {
        "content": "<p>Is there such a thing as <code>variable [...] in section [...] end</code>?</p>",
        "id": 366774223,
        "sender_full_name": "Reid Barton",
        "timestamp": 1686911637
    },
    {
        "content": "<p>I don't think that works</p>",
        "id": 366774585,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911706
    },
    {
        "content": "<p><code>section</code> would be read as a single command so you get <code>section variable [...] section end [...] end</code> which... seems wrong?</p>",
        "id": 366774798,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911746
    },
    {
        "content": "<p>actually it kinda works <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 366774942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911766
    },
    {
        "content": "<p>Are there like... really big parentheses I can use?</p>",
        "id": 366774964,
        "sender_full_name": "Reid Barton",
        "timestamp": 1686911771
    },
    {
        "content": "<p>what's the application?</p>",
        "id": 366775032,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911786
    },
    {
        "content": "<p>mathlib defines big parentheses by the name <code>stop_at_first_error</code></p>",
        "id": 366775191,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911805
    },
    {
        "content": "<p>Basically <code>parameters</code>. But probably I am misunderstanding that recursive example.</p>",
        "id": 366775243,
        "sender_full_name": "Reid Barton",
        "timestamp": 1686911809
    },
    {
        "content": "<p>I think so</p>",
        "id": 366775420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911843
    },
    {
        "content": "<p>here we are using <code>variable [...] in</code> to scope just over the <code>def</code> which is recursive</p>",
        "id": 366775542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911865
    },
    {
        "content": "<p>the trick is that this is the new way to write variables \"left of the colon\"</p>",
        "id": 366775642,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911882
    },
    {
        "content": "<p>because the recursive call doesn't have to refer to the variables (in fact it cannot)</p>",
        "id": 366775778,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911903
    },
    {
        "content": "<p>so they are fixed parameters</p>",
        "id": 366775839,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911916
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">add</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>lean 3 style</p>",
        "id": 366776122,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911973
    },
    {
        "content": "<p>compare:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">add</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 366776234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686911999
    },
    {
        "content": "<p>Can I write say a sequence of ten (non-mutually recursive, just ordinary) definitions after <code>variable [...] in</code>?<br>\nThis is how Agda anonymous modules work.</p>",
        "id": 366776476,
        "sender_full_name": "Reid Barton",
        "timestamp": 1686912044
    },
    {
        "content": "<p>no, the <code>in</code> scopes after only one definition, that's the point</p>",
        "id": 366776625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686912069
    },
    {
        "content": "<p>if you want to scope over ten definitions just use <code>section</code> normally</p>",
        "id": 366776715,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686912084
    },
    {
        "content": "<p>But then I don't get <code>parameter</code>-like behavior.</p>",
        "id": 366776881,
        "sender_full_name": "Reid Barton",
        "timestamp": 1686912119
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">add</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">a</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 366777063,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686912151
    },
    {
        "content": "<p>no, the reason for this behavior is because the auxiliary local variable <code>add</code> in the definition of <code>add</code> has the type <code>Nat -&gt; Nat</code></p>",
        "id": 366777418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686912218
    },
    {
        "content": "<p>the actual constant still has the type <code>Nat -&gt; Nat -&gt; Nat</code> which is why in the next definition you refer to it with two args</p>",
        "id": 366777600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686912246
    },
    {
        "content": "<p>ok, I think I see. Because <code>add</code> in its own definition is not a real reference to a definition anyways, it is something that will be processed by the equation compiler.</p>",
        "id": 366777757,
        "sender_full_name": "Reid Barton",
        "timestamp": 1686912274
    },
    {
        "content": "<p>if you make them all part of a mutual block, possibly you will get the desired behavior</p>",
        "id": 366778020,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686912326
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kd\">mutual</span>\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">add</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>there's your big parentheses</p>",
        "id": 366778163,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686912355
    },
    {
        "content": "<p>note that this is a \"non-mutual mutual block\", the equation compiler will notice that the definitions are not an SCC and compile them in order</p>",
        "id": 366778611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686912441
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"false\" stretchy=\"true\" minsize=\"3em\" maxsize=\"3em\">(</mo><mtext>hello big parentheses</mtext><mo fence=\"false\" stretchy=\"true\" minsize=\"3em\" maxsize=\"3em\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\Bigg(\\text{hello big parentheses}\\Bigg)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:3em;vertical-align:-1.25em;\"></span><span class=\"mord\"><span class=\"delimsizing size4\">(</span></span><span class=\"mord text\"><span class=\"mord\">hello big parentheses</span></span><span class=\"mord\"><span class=\"delimsizing size4\">)</span></span></span></span></span></p>",
        "id": 366778678,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1686912455
    },
    {
        "content": "<p>But I guess other random stuff will not quite work, e.g., if <code>add</code> has <code>@[simp]</code> then maybe <code>simp</code> will not apply it by default in <code>mul</code> because the declaration is not actually added to to the environment yet</p>",
        "id": 366778942,
        "sender_full_name": "Reid Barton",
        "timestamp": 1686912496
    },
    {
        "content": "<p>On the topic of the \"entry heuristic\", I think that most math theorems would work if you begun their proof with <code>prune 0</code>.</p>",
        "id": 366779084,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686912526
    },
    {
        "content": "<p>most meaning 99%? Because that's still thousands of lines to fix</p>",
        "id": 366779257,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686912567
    },
    {
        "content": "<p>No, I think that for the mathported files there is no hope to get something good...</p>\n<p>This would be for the native Lean 4 files.</p>",
        "id": 366779536,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686912615
    },
    {
        "content": "<p>The point is that while porting, people worked around the different conventions in Lean 3/4 and did a great job at it!</p>",
        "id": 366779658,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686912647
    },
    {
        "content": "<p>I don't see why it would be any different for non-mathported files</p>",
        "id": 366779715,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686912662
    },
    {
        "content": "<p>But the juggling of variables that had to be done for porting, should not be done for new files, I think.</p>",
        "id": 366779781,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686912671
    },
    {
        "content": "<p>Well, as you pointed out, for the vast majority of files, there would be no difference.  But there will always be the odd lemma that uses an unusual hypothesis...</p>",
        "id": 366779993,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686912719
    },
    {
        "content": "<p>The way of dealing with these outliers will be different in mathported files and in native ones, I think.</p>",
        "id": 366780188,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686912751
    },
    {
        "content": "<p>I think the fact that they are mathported files matters less than the fact that they are pre-existing files</p>",
        "id": 366780530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686912811
    },
    {
        "content": "<p>you would have to fix any errors up-front</p>",
        "id": 366780577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686912822
    },
    {
        "content": "<p>Sure, I meant files that were written with a different convention in mind.</p>",
        "id": 366780655,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686912837
    },
    {
        "content": "<p>What convention change?</p>",
        "id": 366780835,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686912864
    },
    {
        "content": "<p>Also, I do not think that a new heuristic will result in less work than the current one.  Just that it would be more natural.</p>",
        "id": 366780899,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686912875
    },
    {
        "content": "<p>The convention between what you see in the infoview and what appears in the final declaration.</p>",
        "id": 366781010,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686912893
    },
    {
        "content": "<p>I would like a heuristic that results in less work</p>",
        "id": 366781025,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686912897
    },
    {
        "content": "<p>that's not a convention</p>",
        "id": 366781135,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686912912
    },
    {
        "content": "<p>I think that both conventions work well on the majority of files, so less work is really referring to very few situations.</p>",
        "id": 366781238,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686912937
    },
    {
        "content": "<p>changing what you see in the infoview without changing what makes a lean file valid is easy</p>",
        "id": 366781344,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686912960
    },
    {
        "content": "<p>Maybe convention is not the right word, but in Lean 3 I expect that everything that I see in the infoview makes it into the declaration, whereas what I see in the infoview in Lean 4 is subject to unknown pruning.</p>",
        "id": 366781526,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686912989
    },
    {
        "content": "<p>I think that is the least important problem to solve</p>",
        "id": 366781573,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686912999
    },
    {
        "content": "<p>Maybe it is not important, but I do like to have some certainty about what comes out as a hypothesis in a declaration.</p>",
        "id": 366781789,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686913037
    },
    {
        "content": "<p>That is to say, maybe it should be discussed separately</p>",
        "id": 366781943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686913072
    },
    {
        "content": "<p>And I prefer to know it beforehand, possibly of course including stuff that I can later omit, rather than having to wait until the end of the proof and then re-inspecting it after the fact.</p>",
        "id": 366782038,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686913085
    },
    {
        "content": "<p>How hard would it be to have various versions of <code>prune</code> being auto-inserted in a random selection of theorems and seeing how many still typecheck?</p>",
        "id": 366782431,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686913163
    },
    {
        "content": "<p>(I am saying <code>prune</code> simply because it is already there.  Any other heuristic for removing assumptions would be good.)</p>",
        "id": 366782609,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686913199
    },
    {
        "content": "<p>E.g., you said above \"99.9%\": this was probably a guess.  Can we maybe have a montecarlo approach for checking this proportion?</p>",
        "id": 366783021,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686913256
    },
    {
        "content": "<p>For instance, how hard it is to make <code>theorem ... := by</code> be parsed as <code>theorem ... := by prune; </code> and then seeing what percentage of proofs break?</p>",
        "id": 366783424,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686913326
    },
    {
        "content": "<p>(Note that <code>prune</code> is the most conservative.  I would argue that <code>prune 0</code>, the least conservative, would still work for a good proportion of theorems.  I would also expect the difference between <code>prune</code> and <code>prune 1</code> to be really small.)</p>",
        "id": 366783837,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686913410
    },
    {
        "content": "<p>actually if I were to hazard an actual guess I would say something closer to 95%, and heavily biased to certain kinds of files</p>",
        "id": 366785475,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686913740
    },
    {
        "content": "<p>a.k.a. \"tons of breakage\"</p>",
        "id": 366785652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686913782
    },
    {
        "content": "<p>it is fairly easy to do that test, just override <code>theorem</code></p>",
        "id": 366786184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686913901
    },
    {
        "content": "<p>This means adding a <code>macro</code> for <code>theorem</code>?</p>",
        "id": 366786636,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686913986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/270676-lean4/topic/Auto.20include.20variables/near/366741199\">said</a>:</p>\n<blockquote>\n<p>May I interst you in the <code>prune</code> tactic <a href=\"https://github.com/leanprover-community/mathlib/pull/5062\">#5062</a>?</p>\n</blockquote>\n<p>This has been a long topic so maybe I missed where it might be discussed, but I'm not sure how <code>prune</code> would help with this problem. I'd guess that most of the time the additional hypotheses involve variables that appear in the goal. For example, even with a simplification of the motivating example, <code>prune</code> will keep <code>h</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">thm</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">prune</span>\n  <span class=\"c1\">-- h is still a goal</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">n.eq_zero_or_pos</span> <span class=\"k\">with</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">h0</span><span class=\"o\">)</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n<span class=\"k\">#check</span> <span class=\"n\">thm</span>\n<span class=\"c1\">-- thm (n : ℕ) (h : 0 &lt; n) : n = n</span>\n</code></pre></div>\n<p>Dealing with <code>prune n</code> for varying <code>n</code> isn't a general solution either because it takes manual intervention, and also I don't think you can use this number to delete exactly the right things (or really be able to predict what will happen for varying <code>n</code>).</p>",
        "id": 366897509,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1686934990
    },
    {
        "content": "<p>Kyle, yes, I had intended <code>prune</code> with a different goal in mind, but I think that it can be adapted to a solution to the current problem.</p>",
        "id": 366903118,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686936382
    },
    {
        "content": "<p>(that is, when a solution is agreed upon!)</p>",
        "id": 366903322,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686936427
    },
    {
        "content": "<p>The reason I would be against banning <code>variable</code> completely is that sometimes you have parameters like a prime number <code>p</code> and <code>variable {p : Nat} [fact p.prime]</code> and there are files when you'd need this in every declaration if you didn't have variables. I would definitely be able to adapt to just writing <code>{p}</code> in every declaration but I wouldn't want to write much more.</p>",
        "id": 367011251,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1686953302
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Auto.20include.20variables/near/366772241\">said</a>:</p>\n<blockquote>\n<p>then again, maybe programming just doesn't use <code>variable</code></p>\n</blockquote>\n<p>In programming, one of the most common uses of <code>variable</code> in a section is to equipped a monad <code>m</code> with all the relevant operations (e.g., <code>[Alternative m]</code>, <code>[MonadLog m]</code>, <code>[MonadEnv m]</code>, etc.) for whatever set of monadic combinators is being written.</p>",
        "id": 367463655,
        "sender_full_name": "Mac Malone",
        "timestamp": 1687124675
    },
    {
        "content": "<p>To give an example of the fact that this can go wrong, look at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.card_Ioi#doc\">docs#Fin.card_Ioi</a> and its mathlib3 version <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin.card_Ioi\">docs3#fin.card_Ioi</a>. The mathlib4 version has a sporious <code>(b : Fin n)</code> that has auto included for some reason. Since the result is only used in a later file, nobody noticed it.</p>",
        "id": 368492444,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1687427704
    },
    {
        "content": "<p>Same problem in several lemmas in this file!</p>",
        "id": 368493870,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1687427999
    },
    {
        "content": "<p>e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.map_valEmbedding_Ici#doc\">docs#Fin.map_valEmbedding_Ici</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.map_valEmbedding_Ioi#doc\">docs#Fin.map_valEmbedding_Ioi</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.card_Ici#doc\">docs#Fin.card_Ici</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.card_fintypeIci#doc\">docs#Fin.card_fintypeIci</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.card_fintypeIoi#doc\">docs#Fin.card_fintypeIoi</a>.</p>",
        "id": 368494264,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1687428074
    },
    {
        "content": "<p>Yes, I am fixing those</p>",
        "id": 368494719,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1687428158
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/5382\">#5382</a></p>",
        "id": 368507586,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1687430824
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/Auto.20include.20variables/near/367011251\">said</a>:</p>\n<blockquote>\n<p>The reason I would be against banning <code>variable</code> completely is that sometimes you have parameters like a prime number <code>p</code> and <code>variable {p : Nat} [fact p.prime]</code> and there are files when you'd need this in every declaration if you didn't have variables. I would definitely be able to adapt to just writing <code>{p}</code> in every declaration but I wouldn't want to write much more.</p>\n</blockquote>\n<p>This seems like an interesting middle road, we keep <code>variable</code> to declare the type and possibly associated typeclasses, and the for each definition/theorem we explicitly opt in to which variables we want by writing <code>{p x y}</code>, but we then don't have to repeat the types nor typeclasses. This gets rid of a lot of the implicit magic (which isn't perfect, and hard to detect when the magic went wrong), but means we don't have to repeat too much.</p>",
        "id": 368511333,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1687431546
    },
    {
        "content": "<p>I'm currently having some issues with variables, because I have a lot of fairly trivial theorems over bitvectors, where some mention just two variable <code>xs ys : Bitvec n</code> and others also have a third variable <code>zs : Bitvec n</code>.</p>\n<p>I could section these by the number of variables used (and that is what I now have to do as a work-around), but it's much nicer to section them by actual semantic content, so that theorems about similar operations are grouped.</p>\n<p>However, if I have just <code>variable (xs ys zs : Bitvec n)</code> for the whole file, and then do an <code>induction xs</code>, suddenly the third variable gets included in theorems which don't need it.</p>",
        "id": 368512136,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1687431706
    },
    {
        "content": "<p>As a workaround, you can <code>clear zs</code> before the induction line.</p>",
        "id": 368513037,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1687431869
    },
    {
        "content": "<p>Should we open a Lean issue? At least about <code>rfl</code> in <code>rcases</code>, that I suppose changes the value of all the variables of the appropriate type and so include all of them.</p>",
        "id": 368633673,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1687452831
    },
    {
        "content": "<p>I think that Alex' example above is a perfectly reasonable issue, so sure open an issue (if there isn't one already)</p>",
        "id": 368635850,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1687453204
    },
    {
        "content": "<p>I really like Reid's (sorry, I got this wrong the first time) suggestion above as an entry heuristic. Lean could then still look at the body and omit unused type classes from the declaration upon exit, but omitting implicit or explicit hypotheses would result in an error. In this case, it would be nice if we could also have some sort of linter which made sure each declared <code>variable</code> is actually used somewhere in the file.</p>\n<p>To really flesh this out, this is a behavior I think might be reasonable, but I understand it is a pretty significant departure from what we have currently (although, as we have been discussing, what we have currently is suboptimal).</p>\n<p>The entry rule is something like this:</p>\n<ol>\n<li>Types explicitly referenced in the declaration (allowing for the <code>(α)</code> or <code>{α}</code> to be an update to an existing variable instead of shadowing) are obviously entered.</li>\n<li>Any type class in a <code>variable</code> declaration all of whose explicit arguments are already included get added to the context. (Maybe only explicit arguments which are not <code>outParam</code>s are necessary to get included; the effect of this change in the above is that <code>myF'</code> would behave like <code>myF</code>.) </li>\n<li>Type classes with an explicit argument not referenced are excluded.</li>\n</ol>\n<p>I'm not sure exactly what the Lean 3 entry rule was, but it seems like it was a lot like the above. The key distinction I think is the allowing for forced inclusion of predeclared variables with <code>(α) or </code>{α}`</p>\n<p>The exit rule is still looks at the body and deletes unused things.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">StarRing</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">RingHomClass</span> <span class=\"n\">F</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">myRingCopy</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"c1\">-- only using tactic mode to show local context at various positions</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  α: Type ?u.551797</span>\n<span class=\"cm\">  inst✝¹: Ring α</span>\n<span class=\"cm\">  inst✝: StarRing α</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">exact</span> <span class=\"o\">‹</span><span class=\"n\">Ring</span> <span class=\"n\">α</span><span class=\"o\">›</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">myRingCopy</span>\n<span class=\"c1\">-- Unitization.myRingCopy.{u_1} (α : Type u_1) [inst✝ : Ring α] : Ring α</span>\n<span class=\"c\">/-</span><span class=\"cm\">  The `StarRing α` instance is omitted per the exit strategy, and note that even though `α` was declared as</span>\n<span class=\"cm\">an implicit variable, because of the `(α)` it is changed to explicit for the declaration. -/</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">‹</span><span class=\"n\">Ring</span> <span class=\"n\">α</span><span class=\"o\">›</span> <span class=\"c1\">-- succeeds and has the same type signature as `myRingCopy` except `α` is implicit.</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> local context only contains `α`, no instances because here we are shadowing the original `α` with `: Type _`.</span>\n<span class=\"cm\">  α: Type ?u.551783</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">myF</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- *all* the declared `variable`s are in context, because `α β F` are all mentioned, and hence the type classes</span>\n  <span class=\"c1\">-- depending on them.</span>\n  <span class=\"n\">exact</span> <span class=\"n\">f</span>\n<span class=\"c\">/-</span><span class=\"cm\"> because most everything was unused, it all gets deleted (except for `α β f F` because they were all explicitly</span>\n<span class=\"cm\">declared, but now we get an unused variable warning as usual on `α β` -/</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">myF'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- only `F` and `f` are in context</span>\n  <span class=\"n\">exact</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">my_add_comm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n   <span class=\"c\">/-</span><span class=\"cm\"> context contains `CommRing β`, but crucially, not `Module β α` because `α` was never mentioned -/</span>\n  <span class=\"n\">exact</span> <span class=\"n\">add_comm</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n<span class=\"c1\">-- at some point (maybe only with `#lint`) there is a liner error because the declared `[StarRing α]` variable</span>\n<span class=\"c1\">-- wasn't used anywhere.</span>\n</code></pre></div>",
        "id": 368663636,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1687459576
    }
]