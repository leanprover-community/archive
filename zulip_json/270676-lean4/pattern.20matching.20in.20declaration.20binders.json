[
    {
        "content": "<p>I want to transpile to Lean from a language that allows for pattern matching in the argument binders of top level declarations, not only to destruct variables, but also to express partiality. So for example to define the predecessor function you'd be able to simply write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>and the function wouldn't evaluate on anything that doesn't match.</p>\n<p>Funnily there's a really neat way to mimic this behaviour in Lean, which is to use autoParams to resolve the match:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>As far as I can tell, there's exactly one place, where this pattern is used in Mathlib, namely <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.TFAE.out#doc\">docs#List.TFAE.out</a></p>\n<p>(Sidenote: An alternative would be to use the existing pattern matching machinery by changing <code>h</code> to <code>(h : m matches _ + 1 := by simp)</code>, but then we couldn't have <code>n</code> as a function body but we'd need to simplify <code>((match m with | n.succ =&gt; true | x =&gt; false) = true)</code> which is a bit nasty)</p>\n<p>This begs the question of how to best have some syntax sugar to emulate this feature in Lean? The syntax around <code>declSig</code> doesn't seem to be built with overloading or extension in mind? Best thing I have managed so far is to make my own version of the <code>def</code> and <code>theorem</code> parsers, but I'm not sure if that's the easiest way. /cc <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> <span class=\"user-mention\" data-user-id=\"221679\">@Leo Stefanesco</span> <span class=\"user-mention\" data-user-id=\"122318\">@Tobias Grosser</span></p>",
        "id": 473634123,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1727683484
    },
    {
        "content": "<p>What language are you transpiling from? I'm curious to learn more about how partiality works in it.</p>",
        "id": 473760460,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727708183
    },
    {
        "content": "<p><a href=\"https://github.com/rems-project/sail\">Sail</a>. It's not a total language in general, but in particular it uses the above pattern to spread multiple \"clauses\" of one function across different files in order to successively specify different instructions in an ISA.</p>",
        "id": 473764093,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1727708733
    },
    {
        "content": "<p>FWIW I wrote a little prototype for the feature:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>syntax extension</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Data.Set.Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean.Elab.Command</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Parser</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"n\">Term</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">smartBinder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">leading_parser</span><span class=\"w\"> </span><span class=\"n\">ppGroup</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"s2\">\"⟦\"</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">termParser</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"s2\">\":\"</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">termParser</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"s2\">\"⟧\"</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">smartDeclSig</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">leading_parser</span>\n<span class=\"w\">  </span><span class=\"n\">many</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ppSpace</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Term.binderIdent</span><span class=\"w\"> </span><span class=\"bp\">&lt;|&gt;</span><span class=\"w\"> </span><span class=\"n\">Term.bracketedBinder</span><span class=\"w\"> </span><span class=\"bp\">&lt;|&gt;</span><span class=\"w\"> </span><span class=\"n\">smartBinder</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">Term.optType</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">smartDefinition</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">leading_parser</span>\n<span class=\"w\">  </span><span class=\"s2\">\"sdef \"</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">declId</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">smartDeclSig</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">declVal</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">optDefDeriving</span>\n\n<span class=\"n\">syntax</span><span class=\"w\"> </span><span class=\"n\">smartDefinition</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span>\n\n<span class=\"n\">macro_rules</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">sdef</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">bis</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">bis'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`ident</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">`Lean.Parser.Term.hole</span><span class=\"o\">,</span>\n<span class=\"w\">        </span><span class=\"ss\">`Lean.Parser.Term.bracketedBinder</span><span class=\"o\">]))</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">bis.mapM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">hole</span><span class=\"bp\">|$</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">hole</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">))]</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">|</span><span class=\"o\">{</span><span class=\"bp\">$</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">|</span><span class=\"o\">{</span><span class=\"bp\">$</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">})]</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">smartBinder</span><span class=\"bp\">|⟦$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">_</span><span class=\"bp\">⟧</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">        </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">|</span><span class=\"o\">{</span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}),</span><span class=\"w\"> </span><span class=\"c1\">-- TODO hygiene</span>\n<span class=\"w\">          </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">))]</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">panic</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"unsupported binder type in sdef {stx}\"</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">bis</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Array.join</span><span class=\"w\"> </span><span class=\"n\">bis'</span>\n<span class=\"w\">    </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">bis</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n</div></div>\n<p>Generalizing it to arbitrary inductive types seems to require to do lots of work that <code>match</code> already does, not sure yet how to fuse the two things...</p>",
        "id": 473766150,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1727709028
    },
    {
        "content": "<p>Would it be bad to compile these as <code>match</code> with a <code>panic!</code> for the catch-all case?</p>",
        "id": 473766978,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727709220
    },
    {
        "content": "<p>Maybe you could also generate an \"in-domain\" function, and when you call a function and want to make sure it's in the domain, you check that <code>pred.inDomain n = true</code>, also transpiled to a <code>match</code>, but with <code>true</code>/<code>false</code> instead of body/<code>panic!</code></p>",
        "id": 473767393,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727709318
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/pattern.20matching.20in.20declaration.20binders/near/473766978\">said</a>:</p>\n<blockquote>\n<p>Would it be bad to compile these as <code>match</code> with a <code>panic!</code> for the catch-all case?</p>\n</blockquote>\n<p>Yes, that's the alternative solution. We just have set ourselves the goal that the generated code should look as nice and succinct as possible <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 473767729,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1727709380
    },
    {
        "content": "<p>Does Sail check that functions are called with values inside their domain at compile time? If not, then this would be sufficient, right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">panic!</span><span class=\"w\"> </span><span class=\"s2\">\"outside domain\"</span>\n</code></pre></div>",
        "id": 473768344,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727709536
    },
    {
        "content": "<p>Yes, semantically definitely. My goal would just be to not have the match in the translated function body.</p>",
        "id": 473779528,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1727711745
    },
    {
        "content": "<p>How does transpiling work when it can't prove side-goals like <code>(h : m = n + 1 := by rfl)</code>?</p>",
        "id": 473780313,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727711911
    },
    {
        "content": "<p>Yes, we'd have to figure that out at some point. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 473781827,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1727712284
    },
    {
        "content": "<p>I guess my actual question would be: Could you make the syntax for binders a bit more sugarable, <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> ?</p>",
        "id": 474067992,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1727797259
    },
    {
        "content": "<p>One issue I see here is that auto-parameters are still explicit arguments, so even if you had macro expansion capabilities for binders (using the obvious implementation that individual binders should be allowed to expand into binder lists), you'd be expanding</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pred_add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pred_add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span>\n</code></pre></div>\n<p>and then to pass two arguments you'd have to write <code>pred_add num1 rfl num2</code> anyway.</p>",
        "id": 474107015,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727809356
    },
    {
        "content": "<p>I'm still not clear that this use case satisfies your goal of having the generated code as nice and succinct as possible — I'm not seeing how you'd be able to fill in these proofs. The elaborator is going to be checking that the first argument to <code>pred_add</code> is defeq to <code>_ + 1</code>. The <code>rfl</code> proof won't work for the <code>_</code> in <code>fun (n : Nat) =&gt; pred_add (1 + n) _ 2</code> for example.</p>\n<p>It seems to me that the following sort of translation would need the least amount of pomp and circumstance, and it's relatively clean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pred_add</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">panic!</span><span class=\"w\"> </span><span class=\"s2\">\"outside domain\"</span>\n</code></pre></div>",
        "id": 474108027,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727809639
    },
    {
        "content": "<p>Ah you're right, we'd have to shift the autoParams to the end of the argument list <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 474116187,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1727812417
    },
    {
        "content": "<p>The autoParam with the tactic defers the resolution of the defeq from the point of the function definition to the point of the elab of the function call, but not to execution time, the match does the latter, that's right</p>",
        "id": 474116397,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1727812507
    }
]