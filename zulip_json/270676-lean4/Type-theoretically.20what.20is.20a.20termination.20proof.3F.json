[
    {
        "content": "<p>Intuitively a termination proof means a function eventually stops, but type-theoretically, what is it we're proving about a term of a function type? (Or is it at all correct to say that a termination proof is a proof about a property of a term of a function type?)</p>",
        "id": 475216091,
        "sender_full_name": "nrs",
        "timestamp": 1728283693
    },
    {
        "content": "<p>You're proving that it <em>is</em> a term of a function type. i.e. that term doesn't even exist until you've finished the termination proof.</p>",
        "id": 475235398,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728287681
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/Type-theoretically.20what.20is.20a.20termination.20proof.3F/near/475235398\">said</a>:</p>\n<blockquote>\n<p>You're proving that it <em>is</em> a term of a function type. i.e. that term doesn't even exist until you've finished the termination proof.</p>\n</blockquote>\n<p>Ah I see! So a termination proof means we're showing that a term does indeed follow from the introduction rules for the types of our type theory?</p>",
        "id": 475235794,
        "sender_full_name": "nrs",
        "timestamp": 1728287795
    },
    {
        "content": "<p>I guess you can write a computer program which contains a \"function\" which sometimes loops on an input, but mathematically this isn't a function, it's a \"partially-defined function\" or something. In mathematics if you say <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">f:X\\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> then this means that given an element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> you <em>must</em> get an element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> out at the end of it, and that's what Lean's function type represents. I don't know anything about introduction rules, apologies. You're proving that something is a well-defined term.</p>",
        "id": 475236158,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728287892
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/Type-theoretically.20what.20is.20a.20termination.20proof.3F/near/475236158\">said</a>:</p>\n<blockquote>\n<p>I guess you can write a computer program which contains a \"function\" which sometimes loops on an input, but mathematically this isn't a function, it's a \"partially-defined function\" or something. In mathematics if you say <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">f:X\\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> then this means that given an element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> you <em>must</em> get an element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> out at the end of it, and that's what Lean's function type represents. I don't know anything about introduction rules, apologies. You're proving that something is a well-defined term.</p>\n</blockquote>\n<p>Ty I will be thinking about this!</p>",
        "id": 475238529,
        "sender_full_name": "nrs",
        "timestamp": 1728288679
    },
    {
        "content": "<p>the way i look at it, is that you're proving that the description you're giving is sufficient to completely determine the behaviour and values of the function</p>",
        "id": 475251530,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1728292094
    },
    {
        "content": "<p>The way I look at it is that you are helping lean prove that there exists a function (a value in the given type) that satisfies the given equations, and then lean constructs that value for you, and proves that it satisfies the equations.</p>\n<p>This may not even completely determine the behavior, something like <a href=\"https://github.com/leanprover/lean4/issues/3119\">https://github.com/leanprover/lean4/issues/3119</a> with the value being not uniquely determines for some inputs is totally fine (and the aeneas people have implemented that).</p>\n<p>This extensional point of view mostly ignores questions about the reduction behavior of the function.</p>",
        "id": 475256699,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1728293725
    },
    {
        "content": "<p>The way I see it, in type theory you can't define recursive functions like you would do in functional programming, instead you define functions that use eliminators on some of their inputs, which kinda emulates recursion. These are however restricted to getting the result of the recursive call only for structurally smaller values. Often the compiler can fit your function definition with this limitation automatically, but sometimes it can't. Termination proofs add extra parameters to the function on which the compiler can trivially eliminate on while still being able to get the recursive results it needs and hence allows it to write a term for your function.</p>",
        "id": 475264309,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1728296236
    },
    {
        "content": "<p>One of the things I've always found fascinating about this community is that because it has such a diverse mix of people, there are sometimes lots of ways to look at it :-)</p>",
        "id": 475265633,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728296737
    },
    {
        "content": "<p>The general technique (Bove–Capretta) is to look at the recursion, construct another helper proposition that says \"this input can be reached recursively from the base case\". Now you trivially have a function <code>f</code> that takes an input, and a proof of the proposition at this input, and returns the output, by recursion on the proof (not the input!). The termination proof is simply proving that the proposition is true for all inputs, which you can feed into the second argument of <code>f</code>. This proposition is called <code>Acc</code> in Lean.</p>\n<p>Though <code>Acc</code> being a proposition in Lean does raise some type theoretic complications, so you can probably view it as an ordinary type first, which doesn't change anything except maybe computational efficiency.</p>",
        "id": 475828614,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1728471760
    },
    {
        "content": "<p><code>def someFunc (x : A) (y : B) : C := (body)</code> is type-theoretically the assertion: <code>(x : A), (y : B) |- someFunc x y : C</code>. Since a term is well-formed only if it has finitely many symbols, a termination proof consists of the proof that <code>someFunc x y</code> is a term with finitely many symbols (this is effectively what people were saying above but I couldn't properly understand it at the time)</p>",
        "id": 490759495,
        "sender_full_name": "nrs",
        "timestamp": 1735117039
    },
    {
        "content": "<p>I don't think that's right? <code>def loop (a : Unit) : Unit := loop a</code> has finitely many symbols, but doesn't terminate</p>",
        "id": 490769257,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1735124843
    },
    {
        "content": "<p>Or maybe I am misunderstanding what you mean by \"symbols\"?</p>",
        "id": 490769370,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1735124922
    },
    {
        "content": "<p>hm you're right. instead the right statement is: a termination proof consists of the proof that <code>someFunc x y</code> denotes at least one symbol and at most finitely many symbols, i.e. that <code>(x : A), (y : B) |- someFunc x y : C</code> is a syntactically well-formed judgment</p>",
        "id": 490769951,
        "sender_full_name": "nrs",
        "timestamp": 1735125441
    },
    {
        "content": "<p>Kevin and Giacomo's perspectives are two sides of the same coin in the following way: Consider a recursive function <em>trivially terminating</em> if its termination follows from structural induction on one of its arguments. Such a function, is, in particular, the result of applying the recursor of the type inducted on with a suitable motive (It's a good exercise to show this). This is how recursive functions are constructed internally (type theoretically speaking).</p>\n<p>Then, for a general recursive function, a termination proof is a part of the definition in the following way: for an arbitrary recursive definition <code>f : X₁ × ... × Xₙ</code> with a termination proof, there exists an inductive type <code>I</code> and <code>g : X₁ × ... × Xₙ → I</code> and <code>h : X₁ × ... × Xₙ × I</code> such that h is trivially terminating w.r.t. I and <code>h x₁ ...  xₙ (g x₁ ...  xₙ) = f x₁ ...  xₙ</code> in the natural way (made precise with operational semantics).</p>\n<p>You can think of the termination proof as an ergonomic way of specifying I and g. In particular Lean works in terms of an order relationship equivalent to the structural order on I.</p>\n<p>Coq somewhat infamously lacked a feature for general termination proofs for most of its life because, well, by this theorem, it didn't need it!</p>",
        "id": 490804147,
        "sender_full_name": "Soundwave",
        "timestamp": 1735155862
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/Type-theoretically.20what.20is.20a.20termination.20proof.3F/near/475265633\">said</a>:</p>\n<blockquote>\n<p>One of the things I've always found fascinating about this community is that because it has such a diverse mix of people, there are sometimes lots of ways to look at it :-)</p>\n</blockquote>\n<p>How I feel about math in general</p>",
        "id": 490806368,
        "sender_full_name": "Alok Singh",
        "timestamp": 1735158316
    }
]