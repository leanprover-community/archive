[
    {
        "content": "<p>I want to formalize some category theory.<br>\nThe thing is, I chose to let my categories have their objects in <code>Sort u</code>, which means they can be <code>Prop</code>s.<br>\nNow, to formalize the Grothendieck construction, I need a Sigma type. Unfortunately, <code>Sigma</code> and <code>PSigma</code> either don't accept the right universes or don't live in the right universe for my purpose.<br>\nSo I tried to write another variant of Sigma types, and after figuring out I need to <code>set_option bootstrap.inductiveCheckResultingUniverse false</code> I'm stuck here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">bootstrap</span><span class=\"bp\">.</span><span class=\"n\">inductiveCheckResultingUniverse</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MySigma</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"c1\">-- (kernel) invalid reference to undefined universe level parameter 'u'</span>\n</code></pre></div>\n<p>This can be reduced to a smaller example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">bootstrap</span><span class=\"bp\">.</span><span class=\"n\">inductiveCheckResultingUniverse</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyFooBar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyFooBar</span><span class=\"w\"> </span><span class=\"n\">Î±</span>\n<span class=\"c1\">-- (kernel) invalid reference to undefined universe level parameter 'u'</span>\n</code></pre></div>\n<p>However, the following works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">bootstrap</span><span class=\"bp\">.</span><span class=\"n\">inductiveCheckResultingUniverse</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyBazz</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyBazz</span><span class=\"w\"> </span><span class=\"n\">Î±</span>\n</code></pre></div>\n<p>Why does Lean do that?</p>",
        "id": 492696153,
        "sender_full_name": "Julien Marquet-Wagner",
        "timestamp": 1736421598
    },
    {
        "content": "<p>I might get asked so here is:</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>lean<span class=\"w\"> </span>--version\nLean<span class=\"w\"> </span><span class=\"o\">(</span>version<span class=\"w\"> </span><span class=\"m\">4</span>.16.0-pre,<span class=\"w\"> </span>x86_64-unknown-linux-gnu,<span class=\"w\"> </span>commit<span class=\"w\"> </span>9b2c8287b12a,<span class=\"w\"> </span>Release<span class=\"o\">)</span>\n</code></pre></div>",
        "id": 492696381,
        "sender_full_name": "Julien Marquet-Wagner",
        "timestamp": 1736421663
    },
    {
        "content": "<p>Why do you want <code>MySigma</code> to sometimes live in <code>Prop</code>? In previous versions of Lean such inductive sorts were allowed, but generate only a recursion principle eliminating to <code>Prop</code> (they wouldn't have so-called \"large elimination\"). Having large elimination for such inductive sorts would be inconsistent in general.<br>\nApparently we now just disallow this behavior, to avoid that footgun, and place such inductive types always in <code>Type _</code>, which is what <code>PSigma</code> does. Why isn't that sufficient for your purposes?</p>",
        "id": 492701317,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1736423177
    },
    {
        "content": "<p>for more info, you can read <a href=\"https://lean-lang.org/doc/reference/latest//The-Type-System/Inductive-Types/#prop-vs-type\">ref4#prop-vs-type</a></p>",
        "id": 492702562,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736423603
    },
    {
        "content": "<p>This is the closed <a href=\"https://github.com/leanprover/lean4/pull/3310\">lean4#3310</a>, where <span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span>  says:</p>\n<blockquote>\n<p><code>bootstrap</code> comes without warranty :)</p>\n</blockquote>",
        "id": 492703647,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736423957
    },
    {
        "content": "<p>Let's say I write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"c1\">-- [...]</span>\n</code></pre></div>\n<p>The beginning of the problem is that <code>obj</code> and <code>hom</code> may live in <code>Prop</code>. I initially did that because I wanted to be able to say that a poset is a category where <code>hom</code> is a <code>Prop</code>.</p>\n<p>And then I want to have a Grothendieck construction, so something that takes a functor <code>F : C â‡’ Cat</code> to a category <code>âˆ« F</code>.<br>\nIn practice, I use use <a href=\"https://arxiv.org/abs/1705.04296\">Displayed Categories</a> rather than a functor <code>C â‡’ Cat</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">Displayed</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">âŸ¶</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"c1\">-- [...]</span>\n</code></pre></div>\n<p>Then the Grothendieck construction should be</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">total_category</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Câ‚€</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">Displayed</span><span class=\"w\"> </span><span class=\"n\">Câ‚€</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Now, how do I define <code>(total_category C).obj</code>? I want it to be <code>(aâ‚€ : Câ‚€.obj) Ã— (C.obj aâ‚€)</code> which has to be <code>Type u</code>, from the signature of <code>total_category</code>.<br>\nThis would work right away if I had <code>obj</code> live in <code>Type</code>. But my initial choice was to have <code>obj : Sort u</code>, which means I need a variant of <code>Sigma</code>that is polymorphic across all of <code>Sort u</code>, for all <code>u</code>.</p>",
        "id": 492703658,
        "sender_full_name": "Julien Marquet-Wagner",
        "timestamp": 1736423962
    },
    {
        "content": "<p>Can you explain why <code>PSigma</code> doesn't work for you?</p>",
        "id": 492703815,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736424008
    },
    {
        "content": "<p>Because <code>PSigma : {Î± : Sort u} â†’ (Î² : Î± â†’ Sort v) â†’ Type (max 1 u v)</code><br>\nI would need <code>{Î± : Sort u} â†’ (Î² : Î± â†’ Sort v) â†’ Sort (max u v)</code>...</p>",
        "id": 492704325,
        "sender_full_name": "Julien Marquet-Wagner",
        "timestamp": 1736424153
    },
    {
        "content": "<p>I guess the morality of the story is that this kind of aggressively polymorphic functions was never an intended use case of Lean <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> and admittedly it's not a very important issue.</p>",
        "id": 492705008,
        "sender_full_name": "Julien Marquet-Wagner",
        "timestamp": 1736424365
    },
    {
        "content": "<p>Is there an issue if the type of <code>total_category</code> is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">total_category</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Câ‚€</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">Displayed</span><span class=\"w\"> </span><span class=\"n\">Câ‚€</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>? (perhaps with one fewer <code>max 1</code>?)</p>",
        "id": 492708514,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1736425453
    },
    {
        "content": "<p>Having objects and homs of a category live in <code>Sort u</code> is perhaps useful. Of course, even if you choose <code>Type u</code>, you can still use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PLift#doc\">docs#PLift</a> to lift <code>Sort u</code> to <code>Type u</code> (and in particular <code>Prop</code> to <code>Type</code>).</p>",
        "id": 492708807,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1736425553
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"385405\">@Julien Marquet-Wagner</span>,  <a class=\"message-link\" href=\"/#narrow/channel/113489-new-members/topic/.E2.9C.94.20Universe.20Restriction.20on.20CategoryTheory.2ECategory/near/479078691\">#new members &gt; âœ” Universe Restriction on CategoryTheory.Category @ ðŸ’¬</a> might be an interesting read for you.</p>",
        "id": 492710086,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1736425920
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/channel/270676-lean4/topic/Universe.20polymorphism.20across.20Type.20and.20Prop/near/492708514\">said</a>:</p>\n<blockquote>\n<p>Is there an issue if the type of <code>total_category</code> is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">total_category</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Câ‚€</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">Displayed</span><span class=\"w\"> </span><span class=\"n\">Câ‚€</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>? (perhaps with one fewer <code>max 1</code>?)</p>\n</blockquote>\n<p>I'd say yes, it would be an issue, because the <code>max 1 u</code> breaks the universe combinatorics of the definition: with the definitions I gave of <code>Category</code> and <code>Category.Displayed</code>, the total category <em>always</em> live in the same universes as the base category.</p>",
        "id": 492710168,
        "sender_full_name": "Julien Marquet-Wagner",
        "timestamp": 1736425934
    },
    {
        "content": "<p>The choice I made in my project is that I preferred nice combinatorics above Prop-genericity.</p>",
        "id": 492710420,
        "sender_full_name": "Julien Marquet-Wagner",
        "timestamp": 1736426015
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> Interesting read indeed, thanks for the link!</p>",
        "id": 492710819,
        "sender_full_name": "Julien Marquet-Wagner",
        "timestamp": 1736426128
    },
    {
        "content": "<p>I'm just thinking: is the <code>invalid reference to undefined universe level parameter 'u'</code> message a sign of a kernel bug?</p>",
        "id": 492711152,
        "sender_full_name": "Julien Marquet-Wagner",
        "timestamp": 1736426208
    },
    {
        "content": "<p>I guess not, since Sebastian Ullrich seemed not concerned at all about it in <a href=\"https://github.com/leanprover/lean4/pull/3310\">lean4#3310</a>, but I still find that message surprising</p>",
        "id": 492711457,
        "sender_full_name": "Julien Marquet-Wagner",
        "timestamp": 1736426284
    },
    {
        "content": "<p>I think it's fair to say that this option is not \"officially supported\".<br>\nPlease note that if this bug were to be fixed, the resulting type would be absolutely useless for you: you wouldn't be able to define the projections or do anything with it that is not proving a proposition. This type doesn't have large elimination, so it can only be used to prove propositions (enabling large elimination is inconsistent).</p>",
        "id": 492713441,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1736426875
    }
]