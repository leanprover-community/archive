[
    {
        "content": "<p>A common pattern in Coq to rewrite over custom relations is to prove congruence for certain functions with the <code>Proper</code> typeclass, and then use <code>rewrite</code> to rewrite their arguments.</p>\n<p>I've been digging around for a similar mechanism in Lean 4, but I couldn't come up with anything substantial. The notion of <code>Setoid</code> looks related but it only really works for equivalence relations. I saw that <code>simp</code> has a notion of \"congruence lemmas\" mentioned a few times in the code, but most of the info went back to Lean 3.</p>\n<p>Is this kind of rewriting possible? If so how would one go about it?</p>",
        "id": 302284881,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1664896739
    },
    {
        "content": "<p>No, \"generalised rewriting\" is not implemented in Lean. You can sometimes achieve a similar effect by quotienting with an equivalence relation and then rewriting with propositional equality, but this is far from a full replacement.</p>\n<p>Several people have expressed interest in this mechanism recently, but it's a significant amount of coding effort. More than one good master thesis, I would guesstimate.</p>",
        "id": 302289571,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1664897926
    },
    {
        "content": "<p>I see. The project I'm working on only uses a few such relations, so I'm wondering whether a proof-of-concept for it could work out.</p>\n<p>But I guess the hard part is handling all the context... and it can't be as simple as looking up a congruence proof for each function call on the way up.</p>",
        "id": 302299190,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1664900652
    },
    {
        "content": "<p>Conceptually, I don't think there's anything particularly difficult about it. If anyone wants to work on this, I'd be happy to help. A minimum viable version could be restricted to equivalence relations and respectful morphisms. Coq's design generalises in multiple directions, but these generalisations could be added later (and are more niche anyway).</p>",
        "id": 302301571,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1664901399
    },
    {
        "content": "<p>Alright, maybe I can give this a try in a limited setting. I've worked on extensions to Coq's <code>congruence</code> tactic at some point so I should be able to make some basic cases work t least... the harder part for me is doing the Lean metaprogramming side I think.</p>",
        "id": 302302306,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1664901627
    },
    {
        "content": "<p>That sounds pretty interesting, I'd be happy to help on the Lean metaprogramming side <span class=\"user-mention\" data-user-id=\"484617\">@Sébastien Michelland</span> (and I've been wanting to test some of the rewrite stuff on that particular project anyway)</p>",
        "id": 302323622,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1664908678
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/270676-lean4/topic/Rewriting.20congruent.20relations/near/302301571\">said</a>:</p>\n<blockquote>\n<p>A minimum viable version could be restricted to equivalence relations and respectful morphisms.</p>\n</blockquote>\n<p>Quick note: equivalence relations are not closed under the respectful morphism construction so we actually have to start at PERs. It's mostly the same, fortunately.</p>",
        "id": 302334813,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1664912770
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315434\">Andrés Goens</span> <a href=\"#narrow/stream/270676-lean4/topic/Rewriting.20congruent.20relations/near/302323622\">said</a>:</p>\n<blockquote>\n<p>That sounds pretty interesting, I'd be happy to help on the Lean metaprogramming side <span class=\"user-mention silent\" data-user-id=\"484617\">Sébastien Michelland</span> (and I've been wanting to test some of the rewrite stuff on that particular project anyway)</p>\n</blockquote>\n<p>Your help is more than welcome! Even on the theoretical side, where I have broad ideas about how to tackle the problem but no real expert knowledge to back it up.</p>",
        "id": 302335096,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1664912891
    },
    {
        "content": "<p>I <a href=\"https://github.com/lephe/lean4-rewriting/blob/main/Rewriting.lean\">pushed some basic definitions</a> along with a trivial example where the goal is only applications. This should at least show what general process I have in mind.</p>\n<p>There are already difficult questions in terms of finding <code>Proper</code> instances. I'm not sure if I can make the typeclass engine find <em>all</em> solutions for a query. I'm tempted to just ask <code>Proper ?R f</code> for some function <code>f</code> at hand, and then check what <code>?R</code>s are found by making it an <code>outParam</code>. I'm not anticipating to have a large number of instances for a specific function, so it could work out for a start.</p>",
        "id": 302348037,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1664918005
    },
    {
        "content": "<p>that's a cool start (makes it more concrete and easier to understand)! I'm a bit confused by the example though, you can't prove <code>Rβ (fαβ a) x</code> for that arbitrary <code>x</code>. Did you mean to prove <code>Rβ (fαβ a) x ↔ Rβ (fαβ a') x</code>, i.e. your <code>h₂</code>, where ideally the whole proof would go with a simple <code>by [h]</code>?</p>",
        "id": 302400014,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1664954576
    },
    {
        "content": "<p>or I don't really understand the example <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> what is the idea behind it  <span class=\"user-mention\" data-user-id=\"484617\">@Sébastien Michelland</span> ?</p>",
        "id": 302400211,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1664954654
    },
    {
        "content": "<p>Oh the goal is indeed not provable. I made it this way to avoid Lean proving it automatically with a hypothesis or something. The \"demo\" ends after the rewrite.</p>",
        "id": 302400496,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1664954784
    },
    {
        "content": "<p>I <a href=\"https://github.com/lephe/lean4-rewriting/commit/5affa315f10e9142b93425bfbb1dda53f30f51bd\">added some tests handling subrelations</a>, which is often necessary because non-rewritten arguments get an <code>Eq</code> in the respectful relation while in general <code>Proper</code> instances will be declared with more general types.</p>\n<p>Unsurprisingly, encoding the subrelation rules in this naive way already blows up TC resolution, even without the transitivity rule for <code>Subrel</code>. I'm guessing the proper way to do this would be to solve with a specialized algorithm or to write the typeclasses in a smart way to avoid the engine branching so much. Any insight here?</p>",
        "id": 302412632,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1664959582
    },
    {
        "content": "<p><a href=\"https://jfr.unibo.it/article/view/1574\">This</a> seems to be the relevant paper.</p>",
        "id": 302416403,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1664961053
    },
    {
        "content": "<p>Thanks for digging it up. I've started to look at it, and I'm hopeful I can grasp it well enough. Writing the Lean code is another matter, but I'm sure I can get plenty of help here. :) </p>\n<p>Anyway, just to answer my previous question: handling subrelations is done in the main algorithm which is not typeclass driven; they eliminate it early to avoid searching and keep recursing on syntax (§2.3.2); and they assume the set of instances is transitive to never chain such rules. So that all checks out. I shall try and imitate that.</p>",
        "id": 302727816,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665085430
    },
    {
        "content": "<p>Quick update: I've started <a href=\"https://github.com/lephe/lean4-rewriting/blob/main/Rewriting/Algorithm.lean\">implementing the first algorithm</a> which traverses the goal and generates a set of intermediate relations, Proper instances and subrelation instances as metavariables. This is going pretty well, although I'm not quite sure if and how the context gets updated during the monadic code compared to what the paper expects.</p>\n<p>After that, it's all typeclass inference in the paper, but I don't know whether we can just solve a <em>set</em> of typeclass queries that share metavariables.</p>",
        "id": 303025592,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665239056
    },
    {
        "content": "<p>Reading the Coq source code, it also turns out that a fair amount of typeclass resolution is customized by using the fact that the typeclass resolution engine is a variant of <code>eauto</code>. By using hints that call into custom tactics, a number of instances are applied selectively and not put into the instance database, to avoid combinatorial explosions.</p>",
        "id": 303041983,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665247980
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> I'm ending up with this kind of typeclass problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.grewrite</span><span class=\"o\">]</span> <span class=\"n\">Constraints</span> <span class=\"n\">to</span> <span class=\"n\">solve</span><span class=\"o\">:</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.455</span><span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"o\">(</span><span class=\"n\">relation</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.459</span><span class=\"o\">:</span> <span class=\"n\">Proper</span> <span class=\"bp\">?</span><span class=\"n\">m.455</span> <span class=\"n\">Rα</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.462</span><span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.478</span><span class=\"o\">:</span> <span class=\"n\">Subrel</span> <span class=\"bp\">?</span><span class=\"n\">m.455</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"bp\">?</span><span class=\"n\">m.462</span><span class=\"o\">)</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.480</span><span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">α</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.484</span><span class=\"o\">:</span> <span class=\"n\">Proper</span> <span class=\"bp\">?</span><span class=\"n\">m.480</span> <span class=\"n\">x</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.486</span><span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.496</span><span class=\"o\">:</span> <span class=\"n\">Subrel</span> <span class=\"bp\">?</span><span class=\"n\">m.462</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m.480</span> <span class=\"bp\">==&gt;</span> <span class=\"bp\">?</span><span class=\"n\">m.486</span><span class=\"o\">)</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.508</span><span class=\"o\">:</span> <span class=\"n\">Subrel</span> <span class=\"bp\">?</span><span class=\"n\">m.486</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">impl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>How can I solve/work towards solving this set of queries?</p>",
        "id": 303049143,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665252724
    },
    {
        "content": "<p>I've never looked into typeclass resolution much, but I'm not aware of any use of typeclasses in Lean 4 where we synthesise a set of interdependent instances all at once. So this may be difficult. We could try to solve each constraint in turn (in some sensible order) with backtracking, but (a) Lean's typeclass inference does not assign metavariables (except those it generates itself) and (b) I don't think we can get typeclass inference to give us multiple possible solutions. I don't really have another idea at the moment, short of implementing a custom search algorithm for this sort of problem. <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>, as our resident typeclass tsar, do you maybe have an idea? (This is Lean 4, but the fundamentals are hopefully similar enough.)</p>\n<p>We definitely don't have support for extending typeclass inference with custom tactics, which, as you say, seems to be necessary to constrain the search. I've seen comments in the Lean 4 source code indicating that this feature is on the roadmap, but probably not any time soon.</p>",
        "id": 303242935,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1665401920
    },
    {
        "content": "<p>So the part about extending typeclass search with tactics is probably fine - I can write custom tactics that call into the typeclass engine manually instead. For the instances that I've seen it almost feels straightforward.</p>\n<p>For the set of instances, one approach maybe is to see that all the dependencies are on <code>relation</code>s, so once these are chosen all of the instances can be solved for individually and in any order. I'm considering some kind of \"informed bruteforcing\" on that front, although I'm not quite sure how to discover the relations to use apart from enumerating <code>Proper</code>s and <code>Subrel</code>s - which, apparently, is not possible either. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 303247675,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665403686
    },
    {
        "content": "<p>Do you have an example where in-order, no-backtracking solving is not sufficient?</p>",
        "id": 303247907,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1665403801
    },
    {
        "content": "<p>Yes. Consider a rewrite of <code>Rα a a'</code> into the goal <code>Pα a : Prop</code>. This gives you the following constraints:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.grewrite</span><span class=\"o\">]</span> <span class=\"n\">Constraints</span> <span class=\"n\">to</span> <span class=\"n\">solve</span><span class=\"o\">:</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.449</span><span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.453</span><span class=\"o\">:</span> <span class=\"n\">Proper</span> <span class=\"bp\">?</span><span class=\"n\">m.449</span> <span class=\"n\">Pα</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.455</span><span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.465</span><span class=\"o\">:</span> <span class=\"n\">Subrel</span> <span class=\"bp\">?</span><span class=\"n\">m.449</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"bp\">?</span><span class=\"n\">m.455</span><span class=\"o\">)</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.477</span><span class=\"o\">:</span> <span class=\"n\">Subrel</span> <span class=\"bp\">?</span><span class=\"n\">m.455</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">impl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Commonly, you will do this when <code>Pα</code> is proper for <code>Rα ==&gt; iff</code>, and thus you're aiming for:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"bp\">?</span><span class=\"n\">m.449</span> <span class=\"o\">:=</span> <span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">iff</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.453</span><span class=\"o\">:</span> <span class=\"n\">Proper</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">iff</span><span class=\"o\">)</span> <span class=\"n\">Pα</span> <span class=\"c1\">-- the main instance at play</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.455</span> <span class=\"o\">:=</span> <span class=\"n\">iff</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.465</span><span class=\"o\">:</span> <span class=\"n\">Subrel</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">iff</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">iff</span><span class=\"o\">)</span> <span class=\"c1\">-- trivial</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.477</span><span class=\"o\">:</span> <span class=\"n\">Subrel</span> <span class=\"n\">iff</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">impl</span><span class=\"o\">)</span> <span class=\"c1\">-- standard</span>\n</code></pre></div>\n<p>Now assume you solve in the listing order. There is a valid instance of <code>?m.453</code> in <code>Proper Eq Pα</code>, which will cause <code>?m.465</code> to fail because the respectful relation is not reflexive. You need to guess the correct relation <code>?m.449</code> for that to succeed. Not only do you have to solve both queries that involve <code>?m.449</code>, but really the entire set because the first <code>Subrel</code> ties it to <code>?m.455</code>, the other relation that you have to guess.</p>\n<p>The core problem is that you need to guess a relation for every codomain of an application in the goal, so someone has to explore.</p>",
        "id": 303252354,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665405485
    },
    {
        "content": "<p>I suppose it might be possible to combine all contraints into a single instance problem by basically building a tree instead of a set, but I'm not sure if typeclasses are really the best solution here in Lean</p>",
        "id": 303254585,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1665406380
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"484617\">Sébastien Michelland</span> <a href=\"#narrow/stream/270676-lean4/topic/Rewriting.20congruent.20relations/near/303247675\">said</a>:</p>\n<blockquote>\n<p>So the part about extending typeclass search with tactics is probably fine - I can write custom tactics that call into the typeclass engine manually instead. For the instances that I've seen it almost feels straightforward.</p>\n</blockquote>\n<p>Only if the custom logic is at the top level. If you need custom logic every time an instance is considered during typeclass search, this is not currently possible afaik. (I haven't looked at the paper carefully enough to see whether we need this.)</p>\n<blockquote>\n<p>For the set of instances, one approach maybe is to see that all the dependencies are on <code>relation</code>s, so once these are chosen all of the instances can be solved for individually and in any order. I'm considering some kind of \"informed bruteforcing\" on that front, although I'm not quite sure how to discover the relations to use apart from enumerating <code>Proper</code>s and <code>Subrel</code>s - which, apparently, is not possible either. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>\n</blockquote>\n<p>I would frame it like this: discovering the relations by enumerating <code>Proper</code>s and <code>Subrel</code>s is exactly what Coq's typeclass inference does, using unification.</p>\n<p>Maybe the solution really is to implement an approximation of <code>typeclasses eauto</code>. In principle, this should be no problem; we have nice backtrackable data structures. But I suspect the devil is very much in the details.</p>",
        "id": 303271289,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1665412367
    },
    {
        "content": "<p>I agree with Jannis' assessment that this is going to be difficult with the standard synthesis algorithm. The only thing I can figure out right now is to bundle everything together into one huge class (with judicious use of <code>out_param</code>s?) and hope this is expressive enough to capture what you're looking for. But indeed a custom synthesis algorithm seems more practical at this point.</p>",
        "id": 303279171,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1665415126
    },
    {
        "content": "<p>Thanks for the input! After some consideration I shall try to write a custom algorithm. I'm afraid contorting the standard typeclass search for this would just result in a wild hack, and the generalized rewriting approach so far seems clean enough that I can imagine it being polished and merged in the future. I would like to keep it that way.</p>\n<p>I <a href=\"https://github.com/lephe/lean4-rewriting/blob/728491db5347b9f641a0d917128e8421eae0ecbc/GeneralizedRewriting/Eauto.lean\">pushed some outline</a>, but essentially my idea is to make a naive imitation of eauto, in the sense that:</p>\n<ul>\n<li>It would solve multiple goals by trying different hints (let's say theorems/instances for now), recursively, with backtracking.</li>\n<li>It would unify metavariables and, if needed, allow introducing new ones as temporaries.</li>\n</ul>\n<p>I believe I can make it work nicely by first focusing on getting instances from context (hypotheses) rather than typeclass search. This will both help me split debugging efforts, and act as a fallback to keep the tactic usable whenever the custom typeclass search inevitably fails to find relevant instances.</p>",
        "id": 303461043,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665501560
    },
    {
        "content": "<p>Some practical questions straight away:</p>\n<ul>\n<li>\n<p>How can I obtain a goal with a metavariable in an interactive proof? For instance <code>Proper ?R fαβ</code>. I tried <code>exists R, Proper R fαβ</code> then <code>refine ⟨?R, ?_⟩</code> but then the goal is just some <code>?m.806 ?R</code> and it doesn't unify with eg. <code>Proper (Rα ==&gt; Rβ) fαβ</code>. (Edit: the goal also no longer contains <code>Proper</code>. How does this work? Is <code>?m.806</code> delayed-assigned?)</p>\n</li>\n<li>\n<p>Attempting to unify instances with the goal will assign metavariables. How do I save/split the context so that I can roll back the assignment in case the current instance is not satisfactory?</p>\n</li>\n</ul>",
        "id": 303461987,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665501810
    },
    {
        "content": "<p>For the second question, look at <a href=\"https://github.com/arthurpaulino/lean4-metaprogramming-book/blob/master/md/main/metam.md#backtracking\">this chapter</a> of the metaprogramming book.</p>",
        "id": 303469348,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1665503971
    },
    {
        "content": "<p>Basically, you can use the <code>MonadBacktrack</code> interface to store the current <code>MetavarContext</code> and roll back to it.</p>",
        "id": 303469504,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1665504011
    },
    {
        "content": "<p>By the way, the current lack of generalized rewriting in Lean also was an issue for the Iris port, which Lars fixed via an ad-hoc implementation <a href=\"https://github.com/larsk21/iris-lean/blob/master/src/Iris/Std/Rewrite.lean\">https://github.com/larsk21/iris-lean/blob/master/src/Iris/Std/Rewrite.lean</a>. But crucially, there was no need for backtracking in this specific case.</p>",
        "id": 303471542,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1665504697
    },
    {
        "content": "<p>Progress on this is <a href=\"https://github.com/lephe/lean4-rewriting/commit/81dc3cfb2bf0f9864e48b5b9032afcb6489e4371\">coming along</a>. With some help for Jannis, I now have a basic imitation of eauto that can close <a href=\"https://github.com/lephe/lean4-rewriting/blob/81dc3cfb2bf0f9864e48b5b9032afcb6489e4371/GeneralizedRewriting/TestsEauto.lean\">goals with backtracking</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P₁</span> <span class=\"n\">P₂</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P₁</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">P₂</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha₁</span><span class=\"o\">:</span> <span class=\"n\">P₁</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">a'</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha'₁</span><span class=\"o\">:</span> <span class=\"n\">P₁</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha'₂</span><span class=\"o\">:</span> <span class=\"n\">P₂</span> <span class=\"n\">a'</span><span class=\"o\">):</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">eauto</span>\n</code></pre></div>\n<p>The search for this one looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.eauto</span><span class=\"o\">]</span> <span class=\"n\">goal</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]:</span> <span class=\"n\">β</span> <span class=\"bp\">▼</span>\n  <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">applying</span> <span class=\"n\">hypothesis</span><span class=\"o\">:</span> <span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P₁</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">P₂</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n  <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">subgoals</span><span class=\"o\">:</span> <span class=\"n\">P₁</span> <span class=\"bp\">?</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">P₂</span> <span class=\"bp\">?</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">α</span>\n  <span class=\"o\">[]</span> <span class=\"n\">goal</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]:</span> <span class=\"n\">P₁</span> <span class=\"bp\">?</span><span class=\"n\">a</span> <span class=\"bp\">▼</span>\n    <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">applying</span> <span class=\"n\">hypothesis</span><span class=\"o\">:</span> <span class=\"n\">ha₁</span><span class=\"o\">:</span> <span class=\"n\">P₁</span> <span class=\"n\">a</span>\n    <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">subgoals</span><span class=\"o\">:</span>\n    <span class=\"o\">[]</span> <span class=\"n\">goal</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]:</span> <span class=\"n\">P₂</span> <span class=\"n\">a</span> <span class=\"bp\">▼</span>\n      <span class=\"o\">[]</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">close</span> <span class=\"n\">the</span> <span class=\"n\">goal</span>\n    <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">applying</span> <span class=\"n\">hypothesis</span><span class=\"o\">:</span> <span class=\"n\">ha'₁</span><span class=\"o\">:</span> <span class=\"n\">P₁</span> <span class=\"n\">a'</span>\n    <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">subgoals</span><span class=\"o\">:</span>\n    <span class=\"o\">[]</span> <span class=\"n\">goal</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]:</span> <span class=\"n\">P₂</span> <span class=\"n\">a'</span> <span class=\"bp\">▼</span>\n      <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">applying</span> <span class=\"n\">hypothesis</span><span class=\"o\">:</span> <span class=\"n\">ha'₂</span><span class=\"o\">:</span> <span class=\"n\">P₂</span> <span class=\"n\">a'</span>\n      <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">subgoals</span><span class=\"o\">:</span>\n\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.eauto</span><span class=\"o\">]</span> <span class=\"n\">final</span> <span class=\"n\">proof</span><span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">a'</span> <span class=\"n\">ha'₁</span> <span class=\"n\">ha'₂</span>\n</code></pre></div>\n<p>The fact that several goals of depth 1 are nested might look counter-intuitive, but since the witness for <code>P₁ ?a</code> unifies away <code>?a</code> this also affects the other goal <code>P₂ ?a</code>, so the nesting is in fact correct.</p>\n<p>This is all very basic but that should be enough resolution power to get started on the typeclass problems for generalized rewriting. Next is trying these problems with local hypotheses, then wiring up lower-level routines of the typeclass synthesizer to query instances that unify with the goal.</p>",
        "id": 304239178,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665864037
    },
    {
        "content": "<p>That sort of example is handled by <code>solve_by_elim</code> in mathlib3. I'm a bit confused as to why the minimal <code>solve_by_elim</code> in mathlib4 is failing on it, actually!</p>",
        "id": 304270000,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1665897707
    },
    {
        "content": "<p>I haven't tried, because I didn't know about this tactic! Thanks for bringing it up. Considering it was not recommended to me before, I'm suspecting it would not be able to handle the other two aspects of Coq's <code>typeclasses eauto</code> that I want/need to approximate : (1) querying typeclasses without synthesizing instances, instead leaving them as subgoals (apply in Lean4 does not support it currently), and (2) external hints in the form of using custom tactics when certain types of goals appear.</p>",
        "id": 304275757,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665904152
    },
    {
        "content": "<p>It doesn't do (1), but the mathlib3 version does have a <code>discharger</code> option which will run a custom tactic on each subgoal.</p>",
        "id": 304276342,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1665904701
    },
    {
        "content": "<p>I've made some good progress on this.</p>\n<ul>\n<li>I added <a href=\"https://github.com/lephe/lean4-rewriting/blob/afd05d356b839f227613a5a0eb97ab2fb64871e8/GeneralizedRewriting/Eauto.lean#L79\">a variant of <code>apply</code></a> that does not synthesize implicit instance arguments. It seems to me that it could be an option of the original <code>apply</code>, let me know if that's worth discussing. <code>typeclasses_eauto</code> uses it.</li>\n<li>This allowed me to start using <a href=\"https://github.com/lephe/lean4-rewriting/blob/afd05d356b839f227613a5a0eb97ab2fb64871e8/GeneralizedRewriting/TestsEauto.lean#L61-L72\">normal instance declarations during the search</a> (provided they're in context), and thus solve some basic generalized-rewriting queries.</li>\n<li>I added <a href=\"https://github.com/lephe/lean4-rewriting/blob/afd05d356b839f227613a5a0eb97ab2fb64871e8/GeneralizedRewriting/Eauto.lean#L116-L126\">basic infrastructure to register hints</a>, which should work across different files. Hint databases can be specified in the command, which allows me do to things like:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">eauto_hint</span> <span class=\"n\">Subrel_respectful</span><span class=\"o\">:</span> <span class=\"n\">test_eauto</span>\n<span class=\"n\">eauto_hint</span> <span class=\"n\">Reflexive.refl</span><span class=\"o\">:</span> <span class=\"n\">test_eauto</span>\n<span class=\"n\">eauto_hint</span> <span class=\"n\">Reflexive_Subrel</span><span class=\"o\">:</span> <span class=\"n\">test_eauto</span>\n<span class=\"n\">eauto_hint</span> <span class=\"n\">Subrel_Iff_flip_impl</span><span class=\"o\">:</span> <span class=\"n\">test_eauto</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Rα</span><span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Pα</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"o\">:</span> <span class=\"n\">Proper</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">Iff</span><span class=\"o\">)</span> <span class=\"n\">Pα</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">goal</span><span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">R₁</span><span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">R₂</span><span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span>\n     <span class=\"n\">Proper</span> <span class=\"n\">R₁</span> <span class=\"n\">Pα</span> <span class=\"bp\">→</span>\n     <span class=\"n\">Subrel</span> <span class=\"n\">R₁</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">R₂</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n     <span class=\"n\">Subrel</span> <span class=\"n\">R₂</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">impl</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">):</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">typeclasses_eauto</span> <span class=\"k\">with</span> <span class=\"n\">test_eauto</span>\n</code></pre></div>\n<p>which is an actual typeclass query for the simplest generalized rewriting instance.</p>",
        "id": 304321447,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665934824
    },
    {
        "content": "<p>I imagine that hints could be better integrated with the rest of Lean by using attributes. But there's still the question of extern hints that apply \"tactic expressions\" based on some pattern match. They didn't seem to fit, so I did the basic Coq imitation for now. Suggestions are welcome.</p>",
        "id": 304321674,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665934956
    },
    {
        "content": "<p>I got the <a href=\"https://github.com/lephe/lean4-rewriting/blob/main/GeneralizedRewriting/TestsGrewrite.lean#L20-L24\">simplest generalized rewrite</a> to work! It looks underwhelming, but it was a long way in the making. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n<p>In the context, we have <code>Pα: α → Prop</code> which is <code>Proper (Rα ==&gt; Iff)</code>, allowing us to rewrite:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">Rα</span> <span class=\"n\">a</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Pα</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">grewrite</span> <span class=\"n\">h</span> <span class=\"c1\">-- turns into Pα a'</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The full log is as follows. First, the generalized rewriting algorithm traverses the term to find occurrences and generate <code>Proper</code> and <code>Subrel</code> instances to apply along the way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.grewrite</span><span class=\"o\">]</span> <span class=\"n\">skeleton</span><span class=\"o\">:</span> <span class=\"n\">Pα</span> <span class=\"n\">a</span> <span class=\"bp\">▼</span>\n  <span class=\"o\">[]</span> <span class=\"n\">type_f</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"o\">[]</span> <span class=\"n\">using</span> <span class=\"n\">rule</span><span class=\"o\">:</span> <span class=\"n\">APP</span>\n  <span class=\"o\">[]</span> <span class=\"n\">skeleton</span><span class=\"o\">:</span> <span class=\"n\">Pα</span> <span class=\"bp\">▼</span>\n    <span class=\"o\">[]</span> <span class=\"n\">using</span> <span class=\"n\">rule</span><span class=\"o\">:</span> <span class=\"n\">ATOM</span>\n  <span class=\"o\">[]</span> <span class=\"n\">skeleton</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">▼</span>\n    <span class=\"o\">[]</span> <span class=\"n\">using</span> <span class=\"n\">rule</span><span class=\"o\">:</span> <span class=\"n\">UNIFY</span>\n</code></pre></div>\n<p>This generates a set of constraints involving intermediate relations that needs to be guessed (here <code>?m.438: relation (α → Prop)</code> and <code>?m.457: relation Prop</code>). The <code>flip impl</code> comes from the top-level, it is the relation that we can apply on the goal to make progress. (We could similarly rewrite on hypotheses by targeting <code>impl</code>).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.grewrite</span><span class=\"o\">]</span> <span class=\"n\">constraints</span> <span class=\"n\">to</span> <span class=\"n\">solve</span><span class=\"o\">:</span>\n      <span class=\"n\">Proper</span> <span class=\"bp\">?</span><span class=\"n\">m.438</span> <span class=\"n\">Pα</span>\n      <span class=\"n\">Subrel</span> <span class=\"bp\">?</span><span class=\"n\">m.438</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"bp\">?</span><span class=\"n\">m.457</span><span class=\"o\">)</span>\n      <span class=\"n\">Subrel</span> <span class=\"bp\">?</span><span class=\"n\">m.457</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">impl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Then the problem gets solved using <code>typeclasses_eauto with grewrite</code>. This runs the basic <code>eauto</code> imitation, with hints from the <code>grewrite</code> theorems (for all applicable theorems that are not typeclass instances), and also uses instances that the typeclass engine says unifies with the goal.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.eauto</span><span class=\"o\">]</span> <span class=\"n\">goal</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]:</span> <span class=\"n\">Proper</span> <span class=\"bp\">?</span><span class=\"n\">m.438</span> <span class=\"n\">Pα</span> <span class=\"bp\">▼</span>\n  <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">applying</span> <span class=\"n\">hypothesis</span><span class=\"o\">:</span> <span class=\"n\">Proper_Rα</span><span class=\"o\">:</span> <span class=\"n\">Proper</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">Iff</span><span class=\"o\">)</span> <span class=\"n\">Pα</span>\n  <span class=\"o\">[]</span> <span class=\"n\">goal</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]:</span> <span class=\"n\">Subrel</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">Iff</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Rα</span> <span class=\"bp\">==&gt;</span> <span class=\"bp\">?</span><span class=\"n\">m.457</span><span class=\"o\">)</span> <span class=\"bp\">▼</span>\n    <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">grewrite</span><span class=\"o\">]</span> <span class=\"n\">applying</span> <span class=\"n\">hint</span><span class=\"o\">:</span> <span class=\"n\">Reflexive.refl</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">Reflexive</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">x</span>\n    <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">subgoals</span><span class=\"o\">:</span> <span class=\"n\">Reflexive</span> <span class=\"n\">Subrel</span>\n    <span class=\"o\">[]</span> <span class=\"n\">goal</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]:</span> <span class=\"n\">Reflexive</span> <span class=\"n\">Subrel</span> <span class=\"bp\">▼</span>\n      <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">applying</span> <span class=\"kd\">instance</span><span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">Equiv.toReflexive</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">relation</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">Equiv</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">Reflexive</span> <span class=\"n\">R</span>\n      <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">subgoals</span><span class=\"o\">:</span> <span class=\"n\">Equiv</span> <span class=\"n\">Subrel</span>\n      <span class=\"o\">[]</span> <span class=\"n\">goal</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]:</span> <span class=\"n\">Equiv</span> <span class=\"n\">Subrel</span> <span class=\"bp\">▼</span>\n        <span class=\"o\">[]</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">close</span> <span class=\"n\">the</span> <span class=\"n\">goal</span>\n      <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">applying</span> <span class=\"kd\">instance</span><span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">Reflexive_Subrel</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">Reflexive</span> <span class=\"n\">Subrel</span>\n      <span class=\"o\">[]</span> <span class=\"n\">goal</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]:</span> <span class=\"n\">Subrel</span> <span class=\"n\">Iff</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">impl</span><span class=\"o\">)</span> <span class=\"bp\">▼</span>\n        <span class=\"o\">[</span><span class=\"n\">hints</span><span class=\"o\">]</span> <span class=\"n\">applying</span> <span class=\"kd\">instance</span><span class=\"o\">:</span> <span class=\"n\">Subrel_Iff_flip_impl</span><span class=\"o\">:</span> <span class=\"n\">Subrel</span> <span class=\"n\">Iff</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">impl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Note how we apply hypotheses (<code>Proper_Rα</code>), database hints (<code>Reflexive.refl</code>), and instances from the typeclass engine (<code>@Reflexive_Subrel</code>) all for this problem. There is also a bit of backtracking because the first instance we get is a false lead.</p>\n<p>There's still a bunch of bugs and none of the other tests work yet, but I'm happy with this first result. <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 304358705,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1665961357
    },
    {
        "content": "<p>I fixed a couple of bugs this morning, then followed up with <a href=\"https://github.com/lephe/lean4-rewriting/commit/8302b922adfc81d81eafb80677018847f05f9eee\">performance tweaks</a> which mean that we have reasonable examples starting to work now!</p>\n<p>For instance, assuming we have <code>f: α → β</code> which is <code>Proper (Rα ==&gt; Rβ)</code> where <code>Rβ</code> is a PER, then we can rewrite this goal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">Rα</span> <span class=\"n\">a</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">finish</span><span class=\"o\">:</span> <span class=\"n\">Rβ</span> <span class=\"o\">(</span><span class=\"n\">fαβ</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">):</span> <span class=\"n\">Rβ</span> <span class=\"o\">(</span><span class=\"n\">fαβ</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">grewrite</span> <span class=\"n\">h</span>\n  <span class=\"n\">exact</span> <span class=\"n\">finish</span>\n</code></pre></div>\n<p>The set of instances and hints behind the constraint solving is still very unpolished, but the infrastructure is clearly getting there!</p>",
        "id": 304519448,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1666028474
    },
    {
        "content": "<p>As you scale up to bigger hint databases, probably the biggest performance improvement will be to put the hints in a <code>DiscrTree</code>. However, this also means that hints will be applied with <code>reducible</code> rather than <code>default</code> transparency (which is probably fine, but is an observable change).</p>",
        "id": 304523520,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1666029616
    },
    {
        "content": "<p>So far I've only been looking at the search tree, and for that I think the lowest-hanging fruit is avoiding super-general instances and prioritizing hints properly.</p>\n<p>But I do have some concerns about the pattern of <code>commitIfNoEx</code> followed by applying a hypothesis which doesn't unify, then a rollback. In my examples I have ~15 elements in my local context + hint databases, so that's basically 15 rollbacks for every goal and subgoal, which surely can't be ideal. I considered doing that only for hints that unify, but unification already has side effects so it doesn't work; I guess that's why Coq's version is also based on the root symbol.</p>\n<p>So maybe <code>DiscrTree</code> is gonna help with that! I had no idea where to go for such a structure but it seems to be mostly cooked already so that's cool.</p>",
        "id": 304539876,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1666034401
    },
    {
        "content": "<p>Yes, <code>DiscrTree</code> is precisely the data structure you need. It's essentially an expression trie which enables efficient lookup of expressions that may unify with the goal, up to reducible transparency. Afaict from the docs, Coq uses the same approach when you create your hint database with the <code>discriminated</code> option, which would be the default if not for compatibility concerns. Lean 4 also uses <code>DiscrTree</code>s for simp lemmas and typeclasses.</p>",
        "id": 304639665,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1666084658
    },
    {
        "content": "<p>Btw, I just came across <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.sanitizeName#doc\">docs4#Lean.sanitizeName</a>, which you could use to prettify the tracing of local hints.</p>",
        "id": 304643342,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1666086112
    },
    {
        "content": "<p>Ah never mind, this function is for making hygienic names, not for displaying them.</p>",
        "id": 304643550,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1666086209
    },
    {
        "content": "<p>Thanks, I can look at that in the future. For now, I'm trying to implement occurrence selection (which essentially already works) and scaling things up.</p>\n<p>One problem I'm having is that the backtracking code catches all exceptions, and I failed to realize that I was hitting the heartbeat limit on some uncontrolled instance searches. I already have an easily-catchable internal exception for eauto failures, but there are also exceptions in <code>apply</code> that I don't control. So far I \"fixed\" the problem by pre-testing unification to throw my internal exception instead of just a message, and thus every message exception is bubbled back to the top-level. Is there a better way of achieving that?</p>",
        "id": 304666932,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1666095865
    },
    {
        "content": "<p>I don't see a good solution. Maybe  the redundant <code>isDefEq</code> is least bad, though it's obviously not ideal.</p>\n<p>Does anyone else have opinions on this? (Tl;dr of the question: how do we distinguish whether an <code>apply</code> call failed because the types do not unify or because of a fatal error, e.g. hitting the heartbeat limit?) Now that I think about it, I'm sure I have similar problems in Aesop.</p>",
        "id": 304760529,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1666108005
    },
    {
        "content": "<p>I'll stick to that for now, as in the worst case I can always internalize <code>apply</code> - it would just be some 40 more lines of code since I already have a variation of it.</p>",
        "id": 304805176,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1666115175
    },
    {
        "content": "<p>Following deeper reflections on constraint ordering I realized the natural order was best if <a href=\"https://github.com/lephe/lean4-rewriting/commit/7b1f68a90a9e4891525b4016bb38eb78dbf5ae2e\">arguments are solved before functions</a>. This allowed me to scale my <a href=\"https://github.com/lephe/lean4-rewriting/commit/b4b1729089e880588bd280a3007fe76026f2c1ae\">occurrence selection</a>, and now under <code>Proper (Rα ==&gt; Prop) Pα</code> we have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">Rα</span> <span class=\"n\">a</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">finish</span><span class=\"o\">:</span> <span class=\"n\">Pα</span> <span class=\"n\">a'</span><span class=\"o\">):</span> <span class=\"n\">Pα</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">Pα</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">Pα</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">Pα</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">Pα</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">Pα</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₁</span><span class=\"o\">:</span> <span class=\"n\">Proper</span> <span class=\"o\">(</span><span class=\"n\">Iff</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">Iff</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">Iff</span><span class=\"o\">)</span> <span class=\"n\">And</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hx</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hy</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">]⟩</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₂</span><span class=\"o\">:</span> <span class=\"n\">Proper</span> <span class=\"o\">(</span><span class=\"n\">Eq</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">Eq</span><span class=\"o\">)</span> <span class=\"n\">Pα</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hx</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]⟩</span>\n  <span class=\"n\">grewrite</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"mi\">5</span> <span class=\"c1\">-- Pα a  ∧ Pα a  ∧ Pα a  ∧ Pα a  ∧ Pα a' ∧ Pα a</span>\n  <span class=\"n\">grewrite</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"mi\">5</span> <span class=\"c1\">-- Pα a  ∧ Pα a  ∧ Pα a  ∧ Pα a  ∧ Pα a' ∧ Pα a'</span>\n  <span class=\"n\">grewrite</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"mi\">1</span> <span class=\"c1\">-- Pα a' ∧ Pα a  ∧ Pα a  ∧ Pα a  ∧ Pα a' ∧ Pα a'</span>\n  <span class=\"n\">grewrite</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"mi\">3</span> <span class=\"c1\">-- Pα a' ∧ Pα a  ∧ Pα a  ∧ Pα a' ∧ Pα a' ∧ Pα a'</span>\n  <span class=\"n\">grewrite</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"mi\">1</span> <span class=\"c1\">-- Pα a' ∧ Pα a' ∧ Pα a  ∧ Pα a' ∧ Pα a' ∧ Pα a'</span>\n  <span class=\"n\">grewrite</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"mi\">1</span> <span class=\"c1\">-- Pα a' ∧ Pα a' ∧ Pα a' ∧ Pα a' ∧ Pα a' ∧ Pα a'</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"o\">)</span>\n  <span class=\"n\">assumption</span>\n</code></pre></div>\n<p>For the extra <code>have</code>: the instance of <code>And</code> is just not registered yet, and I'm lacking properties on extensional equality so I had to provide that <code>Proper (Eq ==&gt; Eq)</code> which is always true. Using <code>have</code> is always a safety as well as an option to guide the search since it tries local declarations early.</p>",
        "id": 304806012,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1666115456
    },
    {
        "content": "<p>I'm slowly running out of time to spend on this, so I'll be trying to wrap up and polish these basic use cases, with documentation and everything. Hopefully this can be expanded on in the future...</p>",
        "id": 304806144,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1666115493
    },
    {
        "content": "<p>Has anyone picked this back up, or is there a similar project that was trying to accomplish this?</p>",
        "id": 480815951,
        "sender_full_name": "Max Nowak 🐉",
        "timestamp": 1730849413
    },
    {
        "content": "<p>I have a master student starting soon who's going to try to port the Coq approach.</p>",
        "id": 480816372,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1730849719
    },
    {
        "content": "<p>Oh wow that is awesome!</p>",
        "id": 480816502,
        "sender_full_name": "Max Nowak 🐉",
        "timestamp": 1730849795
    },
    {
        "content": "<p>No promises, it's quite a big project. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 480816715,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1730849941
    },
    {
        "content": "<p>Understandably so. I'd still be interested in intermediate and partial results!</p>",
        "id": 480816762,
        "sender_full_name": "Max Nowak 🐉",
        "timestamp": 1730849978
    },
    {
        "content": "<p>Hi, I'm \"the\" master student :P and I wanted to update you all. It took me some time to understand the paper. I used both Sébastien Michellands <code>eauto</code>imitation and <code>aesop</code> with a custom reduced ruleset to solve the constraints. I've also been testing rewrites in Arrows and Lambda types and noticed that even instances of a very simple arrow rewrite can be quite difficult to solve.</p>\n<p>For instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">grewrite</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Expected updated goal: (Q → Q) ∧ (Q → Q)</span>\n</code></pre></div>\n<p>results in 11 MVars in my implementation with the following path of the algorithm:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Algorithm trace</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">grewrite</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">algorithm</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">rew</span><span class=\"w\"> </span><span class=\"n\">Ψ</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"n\">Unify</span><span class=\"bp\">⇑</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"n\">APPSUB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">And</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">   </span><span class=\"n\">rew</span><span class=\"w\"> </span><span class=\"n\">Ψ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">And</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"n\">Unify</span><span class=\"bp\">⇑</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"n\">APPSUB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">And</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">     </span><span class=\"n\">rew</span><span class=\"w\"> </span><span class=\"n\">Ψ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">And</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"n\">Unify</span><span class=\"bp\">⇑</span><span class=\"w\"> </span><span class=\"n\">And</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"n\">ATOM</span><span class=\"w\"> </span><span class=\"n\">And</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">     </span><span class=\"n\">rew</span><span class=\"w\"> </span><span class=\"n\">Ψ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"n\">Unify</span><span class=\"bp\">⇑</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"n\">Arrow</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">       </span><span class=\"n\">rew</span><span class=\"w\"> </span><span class=\"n\">Ψ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"n\">Unify</span><span class=\"bp\">⇑</span><span class=\"w\"> </span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">P</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"n\">APPSUB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">         </span><span class=\"n\">rew</span><span class=\"w\"> </span><span class=\"n\">Ψ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">          </span><span class=\"bp\">|</span><span class=\"n\">Unify</span><span class=\"bp\">⇑</span><span class=\"w\"> </span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">          </span><span class=\"bp\">|</span><span class=\"n\">APPSUB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">impl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">           </span><span class=\"n\">rew</span><span class=\"w\"> </span><span class=\"n\">Ψ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">impl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">            </span><span class=\"bp\">|</span><span class=\"n\">Unify</span><span class=\"bp\">⇑</span><span class=\"w\"> </span><span class=\"n\">impl</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">            </span><span class=\"bp\">|</span><span class=\"n\">ATOM</span><span class=\"w\"> </span><span class=\"n\">impl</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">           </span><span class=\"n\">rew</span><span class=\"w\"> </span><span class=\"n\">Ψ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">            </span><span class=\"bp\">|</span><span class=\"n\">Unify</span><span class=\"bp\">⇑</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">            </span><span class=\"bp\">|</span><span class=\"n\">ATOM</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">         </span><span class=\"n\">rew</span><span class=\"w\"> </span><span class=\"n\">Ψ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">          </span><span class=\"bp\">|</span><span class=\"n\">UNIFY</span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">↝</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">   </span><span class=\"n\">rew</span><span class=\"w\"> </span><span class=\"n\">Ψ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"n\">Unify</span><span class=\"bp\">⇑</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"n\">Arrow</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">     </span><span class=\"n\">rew</span><span class=\"w\"> </span><span class=\"n\">Ψ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"n\">Unify</span><span class=\"bp\">⇑</span><span class=\"w\"> </span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">P</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"n\">APPSUB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">       </span><span class=\"n\">rew</span><span class=\"w\"> </span><span class=\"n\">Ψ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"n\">Unify</span><span class=\"bp\">⇑</span><span class=\"w\"> </span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"n\">APPSUB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">impl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">         </span><span class=\"n\">rew</span><span class=\"w\"> </span><span class=\"n\">Ψ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">impl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">          </span><span class=\"bp\">|</span><span class=\"n\">Unify</span><span class=\"bp\">⇑</span><span class=\"w\"> </span><span class=\"n\">impl</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">          </span><span class=\"bp\">|</span><span class=\"n\">ATOM</span><span class=\"w\"> </span><span class=\"n\">impl</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">         </span><span class=\"n\">rew</span><span class=\"w\"> </span><span class=\"n\">Ψ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">          </span><span class=\"bp\">|</span><span class=\"n\">Unify</span><span class=\"bp\">⇑</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">          </span><span class=\"bp\">|</span><span class=\"n\">ATOM</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">       </span><span class=\"n\">rew</span><span class=\"w\"> </span><span class=\"n\">Ψ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"n\">UNIFY</span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">↝</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n</code></pre></div>\n</div></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>MVars (Lean)</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">Proper</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">29</span><span class=\"w\"> </span><span class=\"n\">And</span>\n<span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">Proper</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">48</span><span class=\"w\"> </span><span class=\"n\">impl</span>\n<span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">Proper</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">65</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">Subrel</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">48</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">65</span><span class=\"w\"> </span><span class=\"bp\">⟹</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">83</span><span class=\"o\">)</span>\n<span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">Subrel</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">83</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Iff</span><span class=\"w\"> </span><span class=\"bp\">⟹</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">110</span><span class=\"o\">)</span>\n<span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">Subrel</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">29</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">110</span><span class=\"w\"> </span><span class=\"bp\">⟹</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">139</span><span class=\"o\">)</span>\n<span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">Proper</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">170</span><span class=\"w\"> </span><span class=\"n\">impl</span>\n<span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">Proper</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">187</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">Subrel</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">170</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">187</span><span class=\"w\"> </span><span class=\"bp\">⟹</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">204</span><span class=\"o\">)</span>\n<span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">Subrel</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">204</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Iff</span><span class=\"w\"> </span><span class=\"bp\">⟹</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">231</span><span class=\"o\">)</span>\n<span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">Subrel</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">139</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">231</span><span class=\"w\"> </span><span class=\"bp\">⟹</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">259</span><span class=\"o\">)</span>\n</code></pre></div>\n</div></div>\n<p>This produces two Proper MVars exactly like Rocqs implementation does with the same example. However in my traces of the Rocq algorithm I see no Subrelation instances which blows up the problem in my Lean implementation. I may trace in the wrong place in Rocq but my current goal is to get the algorithm correct (replicate what Rocq does) for each rule before improving the performance on the proof search.</p>\n<p>I also extended Sébastiens set of working examples <a href=\"https://github.com/FWuermse/grw/blob/main/Grw/TestsGrewrite.lean\">by a bit</a>.</p>",
        "id": 492491958,
        "sender_full_name": "Florian Würmseer",
        "timestamp": 1736338560
    },
    {
        "content": "<p>That's great news! I wish you luck on this project :) <span aria-label=\"rocket\" class=\"emoji emoji-1f680\" role=\"img\" title=\"rocket\">:rocket:</span></p>\n<p>Would this approach be applicable to rewriting \"indexed equalities\" ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">IdxEq</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IdxEq</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span><span class=\"w\"> </span><span class=\"s2\">\" =* \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">IdxEq</span>\n</code></pre></div>\n<p>I guess this is equivalent to equality in <code>Σ (a : α), F a</code>, but it this formulation I'd expect the dependency to be problematic, as there are morally two levels, that of <code>α</code> and that of <code>F</code> which is \"over α\", whereas equivalence relations only appear \"on one level\".<br>\nMaybe in the space of possible generalizations of rewriting techniques, the direction of equivalence relations is orthogonal to the direction of indexed equalities? (If so, there should be an even more general problem for \"indexed relations\".)</p>\n<p>The context is that such types appear when working with <a href=\"https://arxiv.org/abs/1705.04296\">displayed categories</a> and more generally with so-called \"displayed algebras\" (I believe this term was coined by <a href=\"https://andraskovacs.github.io/\">András Kovács</a>, it's very useful when tacking questions of representation of type theory within type theory).</p>",
        "id": 492502326,
        "sender_full_name": "Julien Marquet-Wagner",
        "timestamp": 1736342081
    },
    {
        "content": "<p>Awesome! I'm glad someone is working on this :) </p>\n<p>To throw another example at you, the \"Proof\" section of the README for <a href=\"https://github.com/leanprover-community/iris-lean\">iris-lean</a> project describes some places where they want generalized rewriting. I could probably help come up with concrete examples, if you wanted to test your implementation.</p>",
        "id": 492510293,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1736344743
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"721721\">@Markus de Medeiros</span> that would be great! Having more examples will definitely help me assert the performance and see what's possible. I don't have a strong intuition yet which Proper and respectful instances are required for the more complex structures. So I really appreciate your offer to find/extract \"real world\" examples from the iris port and their respective instances as a strong foundation for the algorithm and proof search.</p>\n<p>This would also help me  answer <span class=\"user-mention\" data-user-id=\"385405\">@Julien Marquet-Wagner</span>  s question and whether the instances work with the different levels and how the algorithm would behave.</p>",
        "id": 492566467,
        "sender_full_name": "Florian Würmseer",
        "timestamp": 1736362769
    },
    {
        "content": "<p>Hi, another update on my journey. I consulted the author Mattieu about the differences from the paper <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> . He got back to me with some differences that are very crucial for the performance on nested cases:</p>\n<blockquote>\n<p>Ok, I see what's happening I think. Taking the declarative system literaly produces a lot of constraints indeed. The implementation is based on section 2.3.2 and has a few refinements that might not be apparent in the paper. We treat application as binary somehow, so that when you rewrite with <code>H : P &lt;-&gt; Q</code> in <code>Q -&gt; P</code> treated as <code>impl Q P</code>, the constraint is simply <code>(Proper (iff =&gt; ?ev) (impl Q))</code> . I.e. if a rewrite does not apply in <code>(impl Q)</code> we do not decompose it. This is done by keeping a Success | Identity status for recursive calls to rewriting. To still be complete w.r.t. the declarative system, we add the <code>partial</code> instance that allows to create a relation evar <code>?ev8</code> for the argument <code>Q</code> and your <code>Proper ?ev8 Q</code> constraint. So this is done lazily during resolution, only if needed. Another aspect is that by default we do not allow rewriting on morphisms (only <code>setoid_rewrite</code> activates that, not <code>rewrite</code> IIRC), so we do not generate the <code>Proper _ and</code> and <code>Proper _ impl</code> and associated <code>subrelation</code> constraints but rather directly a <code>Proper (?ev10 =&gt; ev0) (and Q)</code>. Finally for subrelation, we also apply it lazily: when going top-down in the term, we propagate the expected relation for the rewrite of a given subterm (generating evars when we can't know it). If a rewrite happens with a concrete relation (typically the atom case), and it's not equal to the constraint, we insert a subrelation coercion, otherwise we don't. Again to keep completeness we have a somewhat tricky typeclass instance proper_subrelation that allows to apply at the root of a Proper constraint the proper_subrelation instance, but only once to avoid loops. This is the purpose of the do_subrelation hypotheses: they are consumed by the tactic that applies proper_subrelation so that it applies only once per constraint. Hope this helps!</p>\n</blockquote>\n<p>Since the actual Coq implementation includes lot's of technicalities that would be different in Lean's meta programming I'll try to find the bridge between the actual Coq implementation and the above named changes to the algorithm in the paper. And importantly get a better intuition for the Proper and respectful definitions as core for arbitrary rewrites. Also Jannis and Henrik suggested that the setoid_rewrite approach in Coq may not be relevant for Lean due to the Quotient type utilities.</p>",
        "id": 494625703,
        "sender_full_name": "Florian Würmseer",
        "timestamp": 1737280140
    },
    {
        "content": "<p>I'm glad to see this being picked up again! I haven't looked at it since starting my PhD in a different sub-field but I had a lot of fun trying it at first. <span class=\"user-mention\" data-user-id=\"466861\">@Florian Würmseer</span> I hope it's the same for you too!</p>\n<p>The constraints you have in the basic arrow example seem \"correct\" with respect to my implementation which was very naive following the paper. Matthieu's explanations match my moral understanding of what the tactic wants to do, and I think the not decomposing apps where no rewrite happens is something I considered. The rest of the technical details are beyond what I knew at the time I made my attempt, so you're already headed beyond the basics I setup.</p>\n<p>Looking back, I would have thought that matching the constraint set of the Rocq implementation would be too optimistic due to implementation details, but now I'm not sure anymore. If you can match it at least on simple examples that'd be a fantastic way to validate.</p>",
        "id": 494626099,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1737280493
    },
    {
        "content": "<p>Thank you! You're right. Comparing the constraints in Coq may be feasible when starting with basic cases and progressing to nested cases following the ideas from the paper/implementation. And for the completeness of the above example here the constraints I log in Coq for that conjunction:</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">my_rewrite_debug</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">H</span> <span class=\"o\">(</span><span class=\"n\">do_subrelation</span><span class=\"o\">:=</span><span class=\"n\">Morphisms.do_subrelation</span><span class=\"o\">)</span> <span class=\"o\">|-</span>\n    <span class=\"n\">Morphisms.Proper</span> <span class=\"o\">(?</span><span class=\"n\">r</span> <span class=\"o\">==&gt;</span> <span class=\"o\">?</span><span class=\"n\">r0</span> <span class=\"o\">==&gt;</span> <span class=\"n\">Basics.flip</span> <span class=\"n\">Basics.impl</span><span class=\"o\">)</span> <span class=\"n\">and</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">internal</span> <span class=\"n\">placeholder</span><span class=\"o\">).[</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">H</span> <span class=\"o\">(</span><span class=\"n\">do_subrelation</span><span class=\"o\">:=</span><span class=\"n\">Morphisms.do_subrelation</span><span class=\"o\">)</span>\n                             <span class=\"o\">|-</span>\n                             <span class=\"n\">Morphisms.Proper</span> <span class=\"o\">(</span><span class=\"n\">iff</span> <span class=\"o\">==&gt;</span> <span class=\"o\">?</span><span class=\"n\">r0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Basics.impl</span> <span class=\"n\">Q</span><span class=\"o\">)]</span>\n                             <span class=\"o\">(</span><span class=\"n\">internal</span> <span class=\"n\">placeholder</span><span class=\"o\">).</span>\n  <span class=\"o\">[</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">H</span> <span class=\"o\">|-</span> <span class=\"n\">relation</span> <span class=\"kt\">Prop</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">internal</span> <span class=\"n\">placeholder</span><span class=\"o\">).</span>\n  <span class=\"o\">[</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">H</span> <span class=\"o\">(</span><span class=\"n\">do_subrelation</span><span class=\"o\">:=</span><span class=\"n\">Morphisms.do_subrelation</span><span class=\"o\">)</span> <span class=\"o\">|-</span>\n    <span class=\"n\">Morphisms.Proper</span> <span class=\"o\">(</span><span class=\"n\">iff</span> <span class=\"o\">==&gt;</span> <span class=\"o\">?</span><span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Basics.impl</span> <span class=\"n\">Q</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">internal</span> <span class=\"n\">placeholder</span><span class=\"o\">).</span>\n  <span class=\"o\">[</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">H</span> <span class=\"o\">|-</span> <span class=\"n\">relation</span> <span class=\"kt\">Prop</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">internal</span> <span class=\"n\">placeholder</span><span class=\"o\">).</span>\n</code></pre></div>",
        "id": 494626652,
        "sender_full_name": "Florian Würmseer",
        "timestamp": 1737280972
    },
    {
        "content": "<p>Hi, I was able to recreate a part of the constraint generation algorithm in Coq and wrote a bunch of tests to check whether Coqs constraints equal mine. However, there is one thing I still don't understand considering the second part of Matthieus message above. <span class=\"user-mention\" data-user-id=\"484617\">@Sébastien Michelland</span> or someone else on this thread may have an idea considering the constraints here. Let's say for a problem:</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"n\">example</span> <span class=\"o\">:</span> <span class=\"o\">∀</span> <span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">↔</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">→</span> <span class=\"n\">Q</span> <span class=\"o\">∧</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">→</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kp\">by</span>\n  <span class=\"k\">intros</span> <span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">H</span>\n  <span class=\"n\">grewrite</span> <span class=\"o\">[</span><span class=\"n\">H</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I get constraints like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">Proper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">41534</span><span class=\"w\"> </span><span class=\"bp\">⟹</span><span class=\"w\"> </span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"n\">impl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">And</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- ?m.41534 : relation Prop</span>\n<span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">ProperProxy</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">41536</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"c1\">-- ?m.41536 : relation Prop</span>\n<span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">Proper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Iff</span><span class=\"w\"> </span><span class=\"bp\">⟹</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">41536</span><span class=\"w\"> </span><span class=\"bp\">⟹</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">41534</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">impl</span>\n</code></pre></div>\n<p>Now eventually I want to end up with something Subrel ?x (flip impl)  or impl respectively to get an implication (Q /\\ (P -&gt; Q)) &lt;- (Q /\\ (Q -&gt; Q) assuming we want to rw in the goal. Looking at Matthieus answer I still don't understand where I would place Subrels here and what the Subrel args would be. For reference, Coqs constraints look like this:</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code>  <span class=\"o\">[</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">H</span> <span class=\"o\">(</span><span class=\"n\">do_subrelation</span><span class=\"o\">:=</span><span class=\"n\">Morphisms.do_subrelation</span><span class=\"o\">)</span> <span class=\"o\">|-</span>\n    <span class=\"n\">Morphisms.Proper</span> <span class=\"o\">(?</span><span class=\"n\">r</span> <span class=\"o\">==&gt;</span> <span class=\"n\">Basics.flip</span> <span class=\"n\">Basics.impl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">and</span> <span class=\"n\">Q</span><span class=\"o\">)]</span>\n    <span class=\"o\">(</span><span class=\"n\">internal</span> <span class=\"n\">placeholder</span><span class=\"o\">).[</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">H</span> <span class=\"o\">|-</span> <span class=\"n\">Morphisms.ProperProxy</span> <span class=\"o\">?</span><span class=\"n\">r0</span> <span class=\"n\">Q</span><span class=\"o\">]</span>\n                             <span class=\"o\">(</span><span class=\"n\">internal</span> <span class=\"n\">placeholder</span><span class=\"o\">).</span>\n  <span class=\"o\">[</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">H</span> <span class=\"o\">(</span><span class=\"n\">do_subrelation</span><span class=\"o\">:=</span><span class=\"n\">Morphisms.do_subrelation</span><span class=\"o\">)</span> <span class=\"o\">|-</span>\n    <span class=\"n\">Morphisms.Proper</span> <span class=\"o\">(</span><span class=\"n\">Basics.iff</span> <span class=\"o\">==&gt;</span> <span class=\"o\">?</span><span class=\"n\">r0</span> <span class=\"o\">==&gt;</span> <span class=\"o\">?</span><span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">Basics.impl</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">internal</span> <span class=\"n\">placeholder</span><span class=\"o\">).</span>\n  <span class=\"o\">[</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">H</span> <span class=\"o\">|-</span> <span class=\"n\">relation</span> <span class=\"kt\">Prop</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">internal</span> <span class=\"n\">placeholder</span><span class=\"o\">).</span>\n  <span class=\"o\">[</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">H</span> <span class=\"o\">|-</span> <span class=\"n\">relation</span> <span class=\"kt\">Prop</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">internal</span> <span class=\"n\">placeholder</span><span class=\"o\">).</span>\n</code></pre></div>\n<p>I'm still looking for an answer to what those <code>do_subrelation:=Morphism.do_relation</code> mean in Coq and what kind of Subrel chain I need in general for the modified algorithm.</p>",
        "id": 495663736,
        "sender_full_name": "Florian Würmseer",
        "timestamp": 1737709101
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466861\">@Florian Würmseer</span> As far as I can tell (not 100% sure!), the <code>(do_subrelation:=Morphism.do_subrelation)</code> in the context part of the goal just indicates a let-binding which then happens to be unused. I suspect there <em>is no</em> subrelation in the constraint set generated by Rocq in this case. If there were one it should almost certainly appear in the RHS of a judgment.</p>",
        "id": 495690772,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1737717503
    },
    {
        "content": "<p>Another update. I was able to implement the Coq algorithm for constraint generation in Lean and wrote a couple more tests where I compared the proofs, constraints, and types of a rewrite with Coq. My current focus for the thesis is to show that the two algorithms (the paper one and the one implemented in Coq) always lead to the same rewrite proofs. I'm also optimizing Sébastien's EAuto for the new constraints. <span class=\"user-mention\" data-user-id=\"484617\">@Sébastien Michelland</span> I'm a bit puzzled by how the ProperProxy TC in coq leads to a performance gain. I see that ProperProxy implements some different TC instances than Proper but I don't see how that speeds up the proof search. Do you recall what's so special about ProperProxy? I saw you left a TODO or comment about that in your code.<br>\nThe Coq algorithm examines apps not just by the topmost binary app but unrolls them for some optimized Proper - respectful constraints. A rewrite on <code>x</code> with <code>r x x'</code> in <code>f  x y z x</code> for instance will treat <code>y</code> and <code>z</code> as id (no unification) and generate something like <code>Proper (r ==&gt; ?y ==&gt; ?z ==&gt; r ==&gt; (&lt;-)) f</code> with two ProperProxy instances for <code>?y</code> and <code>?z</code>: <code>ProperProxy ?y y</code>, <code>ProxerProxy ?z z</code>. I don't see how that is better than using Proper in this case. Do you have an intuition for this?</p>",
        "id": 498324429,
        "sender_full_name": "Florian Würmseer",
        "timestamp": 1738929739
    },
    {
        "content": "<p>PS: the proof for this rw <code>(f x y z x) &lt;- (f x' y z x')</code> is: <code>Proper.proper x x' h y y ProperProxy.proxy z z ProperProxy.proxy x x' h</code> with <code>h : r x x'</code></p>",
        "id": 498329447,
        "sender_full_name": "Florian Würmseer",
        "timestamp": 1738931349
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466861\">@Florian Würmseer</span> For the proxy part, you can find some info in the code: <a href=\"https://coq.inria.fr/doc/V8.20.0/stdlib/Coq.Classes.Morphisms.html\">https://coq.inria.fr/doc/V8.20.0/stdlib/Coq.Classes.Morphisms.html</a></p>\n<p>From my understanding the idea is that <code>ProperProxy</code>has hints with well-chosen priorities, so that instance search for <code>ProperProxy</code> first attempts basic matches like equality and iff before it goes into <code>Proper</code>, and might not do so if the target is left as an evar. The point is that the \"other\" instances are defined outside the generalized rewriting code and would not behave well either priority-wise or by enumerating too many options for the evars, leading to long searches.</p>\n<p>As far as I'm aware the satisfiability of <code>ProperProxy</code> is equivalent to that of <code>Proper</code> (or at least when you have a non-evar relation)</p>",
        "id": 498490511,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1739011143
    }
]