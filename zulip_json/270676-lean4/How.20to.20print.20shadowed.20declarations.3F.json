[
    {
        "content": "<p>Take this code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Box</span> <span class=\"n\">where</span>\n  <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"n\">deriving</span> <span class=\"n\">BEq</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">instBEqBox</span> <span class=\"c1\">-- { beq := beqBox✝ }</span>\n</code></pre></div>\n<p>Turning on <code>pp.sanitizeNames</code> does let you access the underlying name of this, but this changes on the ngen and such like so we can't actually access it. It'd be really nice to print it so that I could modify the instance generated by <code>deriving</code> without having to rewrite the scaffolding.</p>",
        "id": 425999861,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1710187526
    },
    {
        "content": "<p>I was told about <code>open private</code> here but I just can't get it to work. I am told that there is private declarations, but can't seem to figure out the syntax to actually do the <code>open</code>ing.</p>",
        "id": 426032686,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1710203689
    },
    {
        "content": "<p>this is not a private declaration (well it is but that's not the problem because you are still in the same module as the declaration), it is a declaration with an inaccessible name. You can call <code>#print</code> if you construct the name manually:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Box</span> <span class=\"n\">where</span>\n  <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"n\">deriving</span> <span class=\"n\">BEq</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.sanitizeNames</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"k\">#print</span> <span class=\"n\">instBEqBox</span>\n<span class=\"c1\">-- def instBEqBox : BEq Box :=</span>\n<span class=\"c1\">-- { beq := beqBox.22 }</span>\n\n<span class=\"kd\">run_cmd</span> <span class=\"n\">Elab.Command.elabCommand</span> <span class=\"bp\">&lt;|←</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">#print</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"o\">(</span><span class=\"n\">addMacroScope</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getMainModule</span><span class=\"o\">)</span> <span class=\"bp\">`</span><span class=\"n\">beqBox</span> <span class=\"mi\">22</span><span class=\"o\">)))</span>\n<span class=\"c1\">-- private def beqBox._@.Mathlib.Test._hyg.22 : Box → Box → Bool :=</span>\n<span class=\"c1\">-- fun x x_1 ↦</span>\n<span class=\"c1\">--   match x, x_1 with</span>\n<span class=\"c1\">--   | { a := a, b := a_1 }, { a := b, b := b_1 } =&gt; true &amp;&amp; a == b &amp;&amp; a_1 == b_1</span>\n<span class=\"c1\">--   | x, x_2 =&gt; false</span>\n</code></pre></div>",
        "id": 426187413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710267536
    },
    {
        "content": "<p>(The fact that several deriving instances produce global declarations with inaccessible names is a recurring source of issues, and I've been planning to write a PR to make them accessible for some time. For example this causes an issue if you want to prove that an autogenerated <code>Ord</code> or <code>BEq</code> instance is lawful.)</p>",
        "id": 426187822,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710267707
    },
    {
        "content": "<p>Thanks! This really does seem quite annoying. One thing I've been meaning to figure out is macro scopes - what are they and how should I use them?</p>",
        "id": 426188443,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1710267934
    },
    {
        "content": "<p>They're the scope of a macro :p. That is, the 'jurisdiction' of a macro over names and definitions. When a new macro is begun (controlled I think primarily <code>withNewMacroScope</code>?), it gets to include its macro scope (which is apparently implemented as just a unique number, probably encoding nesting of macros?) into the name of all (parsing) variables it introduces; this enforces hygiene requirements.</p>",
        "id": 426221907,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710281895
    },
    {
        "content": "<p>ah, yeah, here: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MacroScope#doc\">docs#Lean.MacroScope</a></p>",
        "id": 426221923,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710281907
    },
    {
        "content": "<p>So, in theory, you should introduce a new macro scope whenever there might be danger of name collision of parse variables. In practice I think it's not much used/handled for you when writing <code>notation</code> or simple <code>macro_rules</code> and <code>elab_rules</code>, but more involved elaborators pretty much all start with <code>withNewMacroScope do</code>, and also if you might collide with <em>yourself</em> (through a recursive call, for example) that should get a <code>withNewMacroScope do</code> as well.</p>",
        "id": 426222356,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710282139
    },
    {
        "content": "<p>Ahh, so that number <code>22</code> is a macro-scope in this case. It does seem odd to me because I feel like no macros have been involved here, but I guess (a) most things are macros in some way or another and (b) it's probably the macro scope of the <code>deriving</code> stuff. [Not sure whether multiple derivings would have same or different macro scopes, I guess it depends on the implementation...].</p>",
        "id": 426224043,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1710283028
    },
    {
        "content": "<p>It's possible to make a command that prints the value after unfolding all inaccessible constants (i.e., the ones with macro scopes):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Box</span> <span class=\"n\">where</span>\n  <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"n\">deriving</span> <span class=\"n\">BEq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Command</span> <span class=\"k\">in</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"#print_val \"</span> <span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">addCompletionInfo</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">CompletionInfo.id</span> <span class=\"n\">id</span> <span class=\"n\">id.getId</span> <span class=\"o\">(</span><span class=\"n\">danglingDot</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">{}</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"n\">c</span> <span class=\"bp\">←</span> <span class=\"n\">resolveGlobalConstNoOverloadWithInfo</span> <span class=\"n\">id</span>\n  <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"bp\">?</span> <span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"unknown identifier '{mkConst c}'\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">d.value</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"no value for decl\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">val</span> <span class=\"bp\">←</span> <span class=\"n\">liftTermElabM</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Meta.transform</span> <span class=\"n\">val</span>\n    <span class=\"o\">(</span><span class=\"n\">pre</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"n\">n</span> <span class=\"bp\">..</span> <span class=\"o\">:=</span> <span class=\"n\">e.getAppFn'</span> <span class=\"k\">then</span>\n        <span class=\"k\">if</span> <span class=\"n\">n.hasMacroScopes</span> <span class=\"k\">then</span>\n          <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">e'</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.unfoldDefinition</span><span class=\"bp\">?</span> <span class=\"n\">e</span> <span class=\"k\">then</span>\n            <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">visit</span> <span class=\"n\">e'</span>\n      <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">continue</span><span class=\"o\">)</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{val}\"</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print_val</span> <span class=\"n\">instBEqBox</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">{</span>\n<span class=\"cm\">  beq := fun x x_1 ↦</span>\n<span class=\"cm\">    (fun motive x x_2 h_1 h_2 ↦ Box.casesOn x fun a b ↦ Box.casesOn x_2 fun a_1 b_1 ↦ h_1 a b a_1 b_1) (fun x x ↦ Bool)</span>\n<span class=\"cm\">      x x_1 (fun a a_1 b b_1 ↦ true &amp;&amp; a == b &amp;&amp; a_1 == b_1) fun x x ↦ false }</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 426226078,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710284208
    },
    {
        "content": "<p>Together with <span class=\"user-mention\" data-user-id=\"315434\">@Andrés Goens</span> we are trying to print the internals of a derived <code>DecdiableEq</code> instance using the code by <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> above. Somehow this works for a simple type, but not for something properly inductive.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"#print_val \"</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">addCompletionInfo</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">CompletionInfo</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"bp\">.</span><span class=\"n\">getId</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">danglingDot</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{}</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">liftCoreM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">realizeGlobalConstNoOverloadWithInfo</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"unknown identifier '{mkConst c}'\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">value?</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"no value for decl\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">transform</span><span class=\"w\"> </span><span class=\"n\">val</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">getAppFn'</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">hasMacroScopes</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">          </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">e'</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">unfoldDefinition?</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">            </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">visit</span><span class=\"w\"> </span><span class=\"n\">e'</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{val}\"</span>\n\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">ABox</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ABox</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ABox</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"c1\">-- no recursion</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">instDecidableEqABox</span><span class=\"w\"> </span><span class=\"c1\">-- ... fun {a} =&gt; decEqABox✝</span>\n<span class=\"bp\">#</span><span class=\"n\">print_val</span><span class=\"w\"> </span><span class=\"n\">instDecidableEqABox</span><span class=\"w\"> </span><span class=\"c1\">-- ... nice detailed output :-)</span>\n\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Box</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Box</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Box</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Box</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"c1\">-- recursion</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">bla</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Box</span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">Box</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">Box</span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"c1\">-- DecidableEq works.</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print_val</span><span class=\"w\"> </span><span class=\"n\">instDecidableEqBox</span><span class=\"w\"> </span><span class=\"c1\">-- ... fun {a} =&gt; decEqBox✝ -- Why is this not unfolded?</span>\n</code></pre></div>\n<p>What is happening here / preventing this? Thanks for any suggestions :)</p>",
        "id": 530763924,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1753446758
    },
    {
        "content": "<p>it's smart unfolding</p>",
        "id": 530765698,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753447291
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">smartUnfolding</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"sd\">/--</span>\n<span class=\"sd\">info: fun {a} x x_1 =&gt;</span>\n<span class=\"sd\">  Box.brecOn (motive := fun {a} x =&gt; (x_2 : Box a) → Decidable (x = x_2)) x</span>\n<span class=\"sd\">    (fun {a} x f x_2 =&gt;</span>\n<span class=\"sd\">      (fun x_3 =&gt;</span>\n<span class=\"sd\">          Box.casesOn (motive := fun a_1 x_4 =&gt;</span>\n<span class=\"sd\">            a = a_1 →</span>\n<span class=\"sd\">              x ≍ x_4 →</span>\n<span class=\"sd\">                (fun a x x_5 =&gt;</span>\n<span class=\"sd\">                    Box.below (motive := fun {a} x =&gt; (x_6 : Box a) → Decidable (x = x_6)) x → Decidable (x = x_5))</span>\n<span class=\"sd\">                  a x x_2)</span>\n<span class=\"sd\">            x_3</span>\n<span class=\"sd\">            (fun h =&gt;</span>\n<span class=\"sd\">              Eq.ndrec (motive := fun a =&gt;</span>\n<span class=\"sd\">                (x x_4 : Box a) →</span>\n<span class=\"sd\">                  x ≍ Box.b →</span>\n<span class=\"sd\">                    (fun a x x_5 =&gt;</span>\n<span class=\"sd\">                        Box.below (motive := fun {a} x =&gt; (x_6 : Box a) → Decidable (x = x_6)) x → Decidable (x = x_5))</span>\n<span class=\"sd\">                      a x x_4)</span>\n<span class=\"sd\">                (fun x x_4 h =&gt;</span>\n<span class=\"sd\">                  ⋯ ▸</span>\n<span class=\"sd\">                    Box.casesOn (motive := fun a x =&gt;</span>\n<span class=\"sd\">                      [] = a →</span>\n<span class=\"sd\">                        x_4 ≍ x →</span>\n<span class=\"sd\">                          (fun a x x_5 =&gt;</span>\n<span class=\"sd\">                              Box.below (motive := fun {a} x =&gt; (x_6 : Box a) → Decidable (x = x_6)) x →</span>\n<span class=\"sd\">                                Decidable (x = x_5))</span>\n<span class=\"sd\">                            [] Box.b x_4)</span>\n<span class=\"sd\">                      x_4 (fun h h =&gt; ⋯ ▸ (fun a x =&gt; isTrue ⋯) ())</span>\n<span class=\"sd\">                      (fun {l} a h =&gt;</span>\n<span class=\"sd\">                        Eq.ndrec (motive := fun {l} =&gt;</span>\n<span class=\"sd\">                          x_4 ≍ a.a →</span>\n<span class=\"sd\">                            (fun a x x_5 =&gt;</span>\n<span class=\"sd\">                                Box.below (motive := fun {a} x =&gt; (x_6 : Box a) → Decidable (x = x_6)) x →</span>\n<span class=\"sd\">                                  Decidable (x = x_5))</span>\n<span class=\"sd\">                              [] Box.b x_4)</span>\n<span class=\"sd\">                          (fun h =&gt; ⋯ ▸ (fun a x =&gt; isFalse ⋯) a) h)</span>\n<span class=\"sd\">                      ⋯ ⋯)</span>\n<span class=\"sd\">                ⋯ x x_2)</span>\n<span class=\"sd\">            fun {l} a_1 h =&gt;</span>\n<span class=\"sd\">            Eq.ndrec (motive := fun {l} =&gt;</span>\n<span class=\"sd\">              x ≍ a_1.a →</span>\n<span class=\"sd\">                (fun a x x_4 =&gt;</span>\n<span class=\"sd\">                    Box.below (motive := fun {a} x =&gt; (x_5 : Box a) → Decidable (x = x_5)) x → Decidable (x = x_4))</span>\n<span class=\"sd\">                  a x x_2)</span>\n<span class=\"sd\">              (fun h =&gt;</span>\n<span class=\"sd\">                ⋯ ▸</span>\n<span class=\"sd\">                  Box.casesOn (motive := fun a_2 x =&gt;</span>\n<span class=\"sd\">                    a = a_2 →</span>\n<span class=\"sd\">                      x_2 ≍ x →</span>\n<span class=\"sd\">                        (fun a x x_4 =&gt;</span>\n<span class=\"sd\">                            Box.below (motive := fun {a} x =&gt; (x_5 : Box a) → Decidable (x = x_5)) x →</span>\n<span class=\"sd\">                              Decidable (x = x_4))</span>\n<span class=\"sd\">                          a a_1.a x_2)</span>\n<span class=\"sd\">                    x_2</span>\n<span class=\"sd\">                    (fun h =&gt;</span>\n<span class=\"sd\">                      Eq.ndrec (motive := fun a =&gt;</span>\n<span class=\"sd\">                        (x : Box a) →</span>\n<span class=\"sd\">                          x ≍ Box.b →</span>\n<span class=\"sd\">                            (fun a x x_4 =&gt;</span>\n<span class=\"sd\">                                Box.below (motive := fun {a} x =&gt; (x_5 : Box a) → Decidable (x = x_5)) x →</span>\n<span class=\"sd\">                                  Decidable (x = x_4))</span>\n<span class=\"sd\">                              a a_1.a x)</span>\n<span class=\"sd\">                        (fun x h =&gt; ⋯ ▸ (fun a x =&gt; isFalse ⋯) a_1) ⋯ x_2)</span>\n<span class=\"sd\">                    (fun {l} a_2 h =&gt;</span>\n<span class=\"sd\">                      Eq.ndrec (motive := fun {l} =&gt;</span>\n<span class=\"sd\">                        x_2 ≍ a_2.a →</span>\n<span class=\"sd\">                          (fun a x x_4 =&gt;</span>\n<span class=\"sd\">                              Box.below (motive := fun {a} x =&gt; (x_5 : Box a) → Decidable (x = x_5)) x →</span>\n<span class=\"sd\">                                Decidable (x = x_4))</span>\n<span class=\"sd\">                            a a_1.a x_2)</span>\n<span class=\"sd\">                        (fun h =&gt;</span>\n<span class=\"sd\">                          ⋯ ▸</span>\n<span class=\"sd\">                            (fun x a b x_4 =&gt;</span>\n<span class=\"sd\">                                let inst := x_4.1 b;</span>\n<span class=\"sd\">                                if h : a = b then</span>\n<span class=\"sd\">                                  h ▸</span>\n<span class=\"sd\">                                    let inst := x_4.1 a;</span>\n<span class=\"sd\">                                    isTrue ⋯</span>\n<span class=\"sd\">                                else isFalse ⋯)</span>\n<span class=\"sd\">                              a a_1 a_2)</span>\n<span class=\"sd\">                        h)</span>\n<span class=\"sd\">                    ⋯ ⋯)</span>\n<span class=\"sd\">              h)</span>\n<span class=\"sd\">        x ⋯ ⋯ f)</span>\n<span class=\"sd\">    x_1</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">print_val</span><span class=\"w\"> </span><span class=\"n\">instDecidableEqBox</span>\n</code></pre></div>",
        "id": 530765915,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753447350
    },
    {
        "content": "<p>Cool, thank you!</p>",
        "id": 530766427,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1753447496
    },
    {
        "content": "<p>with smart unfolding you get to unfold with the equational lemmas<br>\n<code>@decEqBox✝ [] .b .b = isTrue decEqBox._proof_1✝</code><br>\n<code>@decEqBox✝ [] .b (.a b) = isFalse ⋯</code><br>\n<code>@decEqBox✝ [] (.a a) .b = isFalse ⋯</code><br>\n<code>@decEqBox✝ l (.a a) (.a b) = if h : a = b then h ▸ have inst := decEqBox✝ a a; isTrue ⋯ else isFalse ⋯</code></p>",
        "id": 530767626,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753447863
    },
    {
        "content": "<p>We are trying to get a self-contained proof term, so is there a way to also avoid/unfold the <code>... ._proof_</code> parts?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"#print_val \"</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">addCompletionInfo</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">CompletionInfo</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"bp\">.</span><span class=\"n\">getId</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">danglingDot</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{}</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">liftCoreM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">realizeGlobalConstNoOverloadWithInfo</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"unknown identifier '{mkConst c}'\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">value?</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"no value for decl\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">transform</span><span class=\"w\"> </span><span class=\"n\">val</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">getAppFn'</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">hasMacroScopes</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">          </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">e'</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">unfoldDefinition?</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">            </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">visit</span><span class=\"w\"> </span><span class=\"n\">e'</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{val}\"</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Box</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Box</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Box</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Box</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"c1\">-- recursion</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">bla</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Box</span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">Box</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">Box</span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"c1\">-- DecidableEq works.</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">proofs</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">deepTerms</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">maxSteps</span><span class=\"w\"> </span><span class=\"mi\">1000000000000</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">smartUnfolding</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"bp\">#</span><span class=\"n\">print_val</span><span class=\"w\"> </span><span class=\"n\">instDecidableEqBox</span><span class=\"w\"> </span><span class=\"c1\">-- still contains `(decEqBox._proof_4✝ x a)` etc.</span>\n</code></pre></div>",
        "id": 530768338,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1753448077
    },
    {
        "content": "<p>Mathlib has <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.unfoldAuxLemmas#doc\">docs#Lean.Meta.unfoldAuxLemmas</a> for unfolding these aux lemmas</p>",
        "id": 530962915,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1753544144
    },
    {
        "content": "<p>You don't need mathlib if you don't want for it; it's a tiny definition you can copy out of the library. </p>\n<p>I think you could even just copy the <code>Lean.Name.isAuxLemma</code> definition and then change the <code>#print_val</code> command to use the condition <code>n.hasMacroScopes || n.isAuxLemma</code>.</p>",
        "id": 530963162,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1753544249
    }
]