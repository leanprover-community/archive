[
    {
        "content": "<p>The following short example leads to an error in <code>#eval</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">two</span> <span class=\"o\">:</span> <span class=\"n\">Subtype</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">three</span> <span class=\"o\">:</span> <span class=\"n\">Subtype</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">two</span> <span class=\"bp\">*</span> <span class=\"n\">three</span>\n</code></pre></div>\n<p>I would have hoped that <code>two</code> and <code>three</code> would get coerced to <code>Nat</code> and the result would be (6 : Nat). I get that <code>HMul</code> cannot infer the return type and the default instance <code>instHMul</code> doesn't trigger since <code>two</code> and <code>three</code> have different type.</p>\n<p>Is there a way to fix this without explicit casting (or <code>.val</code>)? Or is this desired behavior?</p>",
        "id": 398879322,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1698405966
    },
    {
        "content": "<p>Yes, I think you have an unreasonable hope here. :-)</p>",
        "id": 398879472,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1698406037
    },
    {
        "content": "<p>What makes this hope unreasonable?</p>",
        "id": 398879803,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1698406192
    },
    {
        "content": "<p>You could also hope for an autogenerated</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">six</span> <span class=\"o\">:</span> <span class=\"n\">Subtype</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">6</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">6</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>as a result.  <span aria-label=\"six\" class=\"emoji emoji-0036-20e3\" role=\"img\" title=\"six\">:six:</span></p>",
        "id": 398880187,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1698406345
    },
    {
        "content": "<p>Btw, you may like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Pointwise.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Pointwise</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">({</span><span class=\"mi\">2</span><span class=\"o\">}</span> <span class=\"bp\">*</span> <span class=\"o\">{</span><span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">6</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 398881249,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1698406736
    },
    {
        "content": "<p>There's nothing you wrote in your code that indicates you want an answer in Nat.</p>\n<p>Note that <em>both</em> of the following work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">two</span> <span class=\"o\">:</span> <span class=\"n\">Subtype</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">three</span> <span class=\"o\">:</span> <span class=\"n\">Subtype</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">two</span> <span class=\"bp\">*</span> <span class=\"n\">three</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">two</span> <span class=\"bp\">*</span> <span class=\"n\">three</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 398881702,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1698406910
    },
    {
        "content": "<p>How should Lean know which one you were hoping for?</p>",
        "id": 398881795,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1698406935
    },
    {
        "content": "<p>The same is true for <code>2 * 3</code> and yet Lean makes the reasonable choice of returning <code>(6 : Nat)</code>. I think it would also be reasonable for Lean to eagerly fall back to to underlying type for any <code>Subtype</code>. I wonder if there is a way to make it do so.</p>",
        "id": 398884502,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1698408036
    },
    {
        "content": "<p>On the other hand, I'm sorta starting to wonder if <code>Nat</code> as the default <code>OfNat</code> might cause more confusion than clarity. For example here the reason it returns <code>Nat</code> in <code>2 * 3</code> is that the <code>OfNat</code> instance defaults to <code>Nat</code>, which has nothing to do with <code>*</code>.</p>",
        "id": 398916061,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1698419073
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/270676-lean4/topic/Subtype.20coercion.20leads.20to.20error.20with.20multiplication/near/398879472\">said</a>:</p>\n<blockquote>\n<p>Yes, I think you have an unreasonable hope here. :-)</p>\n</blockquote>\n<p>I'm not so sure it's unreasonable -- the <code>binop%</code> elaborator could know about Subtype. It could make the assumption that Subtypes never have HMul instances, and so a Subtype argument must be coerced to its underlying type.</p>",
        "id": 398955537,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698434166
    },
    {
        "content": "<p>If people do actually add arithmetic operator instances to Subtypes directly (rather than onto a semireducible type synonym), then this is a bad idea.</p>",
        "id": 398955626,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698434233
    },
    {
        "content": "<p>Is <code>NNReal</code> a subtype? I think it used to be at some point</p>",
        "id": 398955823,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1698434319
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/b65c6a35d726e7be81e7ab7daa2bcfacfe1e5fd9//Mathlib/Data/PNat/Defs.lean#L38-L38\"><code>PNat</code></a> is a subtype.</p>",
        "id": 398956128,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1698434450
    },
    {
        "content": "<p>Those are type synonyms though -- the instances are being put on NNReal and PNat, rather than on Subtype itself.</p>",
        "id": 398956182,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698434486
    },
    {
        "content": "<p>Ooh, ok... I probably misunderstood the reducibility constraints.</p>",
        "id": 398956504,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1698434640
    },
    {
        "content": "<p>Yeah, I meant to just distinguish a <code>def ... := Subtype ...</code> from an <code>abbrev ... := Subtype ...</code></p>",
        "id": 398956608,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698434685
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># The type of nonnegative elements</span>\n\n<span class=\"cm\">This file defines instances and prove some properties about the nonnegative elements</span>\n<span class=\"cm\">`{x : α // 0 ≤ x}` of an arbitrary type `α`.</span>\n\n<span class=\"cm\">Currently we only state instances and states some `simp`/`norm_cast` lemmas.</span>\n\n<span class=\"cm\">When `α` is `ℝ`, this will give us some properties about `ℝ≥0`.</span>\n\n<span class=\"cm\">## Main declarations</span>\n\n<span class=\"cm\">* `{x : α // 0 ≤ x}` is a `CanonicallyLinearOrderedAddCommMonoid` if `α` is a `LinearOrderedRing`.</span>\n</code></pre></div>",
        "id": 398956917,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1698434810
    },
    {
        "content": "<p>Output of <code>head -27 Mathlib/Algebra/Order/Nonneg/Ring.lean | tail -14</code></p>",
        "id": 398956958,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1698434828
    },
    {
        "content": "<p>Ah, thanks for finding that. Back to the drawing board.</p>",
        "id": 398957543,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698435102
    },
    {
        "content": "<p>We could decide that this should also be wrapped behind an honest definition</p>",
        "id": 398958465,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1698435540
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Subtype.20coercion.20leads.20to.20error.20with.20multiplication/near/398955626\">said</a>:</p>\n<blockquote>\n<p>If people do actually add arithmetic operator instances to Subtypes directly (rather than onto a semireducible type synonym), then this is a bad idea.</p>\n</blockquote>\n<p>This is literally the API for every subobject</p>",
        "id": 398977258,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698446563
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submonoid.toMonoid#doc\">docs#Submonoid.toMonoid</a></p>",
        "id": 398977280,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698446579
    },
    {
        "content": "<p>Oh, right -- that's new to Lean 4 though, right? I mean, before in Lean 3 a submonoid as a monoid had a type wrapped up in a coe function, but now the coercions are unfolded. I don't remember, was that coe function reducible for typeclass inference purposes? If not, could we go back to wrapping these subobject -&gt; object coercions in some function to prevent putting instances on Subtype directly?</p>",
        "id": 399054055,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698501790
    },
    {
        "content": "<blockquote>\n<p>I don't remember, was that coe function reducible for typeclass inference purposes? </p>\n</blockquote>\n<p>No, but what mattered is that the it was the same <code>coe_sort</code> function symbol everywhere. I think we could introduced a <code>SetLike.Elem</code> class to use for every subobject if we wanted (or reuse <code>Set.Elem</code>), but that feels like it's pushing back even further against Lean4 deciding to inline coercions</p>",
        "id": 399056135,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698503302
    },
    {
        "content": "<p>I discussed exactly this issue with <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> a few weeks ago, my diagnosis was that it was a mistake to use <code>{x // x \\in s}</code> directly in the <code>Coe</code> instance and it should instead be wrapped by a <code>@[coe] def toSort</code> function so that you still get the arrow shown by the delaborator</p>",
        "id": 399107343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698548011
    }
]