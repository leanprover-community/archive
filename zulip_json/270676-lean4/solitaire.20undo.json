[
    {
        "content": "<p>I have modeled a simple solitaire logic where you can put any cards anywhere.</p>\n<p>I want to prove that every valid action can be undone. It's trivial to understand, but is hard to prove in Lean.</p>\n<p>Code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Suit</span>\n<span class=\"bp\">|</span> <span class=\"n\">A</span>\n<span class=\"bp\">|</span> <span class=\"n\">B</span>\n<span class=\"bp\">|</span> <span class=\"n\">C</span>\n<span class=\"bp\">|</span> <span class=\"n\">D</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Card</span> <span class=\"n\">where</span>\n  <span class=\"n\">suit</span><span class=\"o\">:</span> <span class=\"n\">Suit</span>\n  <span class=\"n\">value</span><span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Track</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"n\">Card</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">List.splitAt</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">([],</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">splited</span><span class=\"o\">,</span> <span class=\"n\">xs'</span><span class=\"o\">)</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">splitAt</span><span class=\"bp\">?</span> <span class=\"n\">i</span> <span class=\"n\">xs</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">splited</span><span class=\"o\">,</span> <span class=\"n\">xs'</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Fin.ofNat</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">isLt</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"k\">then</span>\n    <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.mk</span> <span class=\"n\">x</span> <span class=\"n\">isLt</span>\n  <span class=\"k\">else</span>\n    <span class=\"bp\">.</span><span class=\"n\">none</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Deck</span> <span class=\"n\">where</span>\n  <span class=\"n\">tracks</span><span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Track</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Action</span>\n<span class=\"sd\">/-- Move `amount` cards from track to track -/</span>\n<span class=\"bp\">|</span> <span class=\"n\">move</span> <span class=\"o\">(</span><span class=\"n\">from_track</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">to_track</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">amount</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Action.reverse</span> <span class=\"o\">:</span> <span class=\"n\">Action</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Action</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">move</span> <span class=\"n\">from_</span> <span class=\"n\">to_</span> <span class=\"n\">amt</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">move</span> <span class=\"n\">to_</span> <span class=\"n\">from_</span> <span class=\"n\">amt</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Deck</span>\n\n<span class=\"kd\">def</span> <span class=\"k\">do</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">deck</span><span class=\"o\">:</span> <span class=\"n\">Deck</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">action</span><span class=\"o\">:</span> <span class=\"n\">Action</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Option</span> <span class=\"n\">Deck</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">move</span> <span class=\"n\">from_track</span> <span class=\"n\">to_track</span> <span class=\"n\">amount</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">from_track</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Fin.ofNat</span><span class=\"bp\">?</span> <span class=\"n\">from_track</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">tracks</span> <span class=\"o\">:=</span> <span class=\"n\">deck.tracks</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">taken</span><span class=\"o\">,</span> <span class=\"n\">modified_track</span><span class=\"o\">)</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">tracks</span><span class=\"o\">[</span><span class=\"n\">from_track</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">splitAt</span><span class=\"bp\">?</span> <span class=\"n\">amount</span>\n  <span class=\"k\">let</span> <span class=\"n\">tracks</span> <span class=\"o\">:=</span> <span class=\"n\">tracks.set</span> <span class=\"n\">from_track</span> <span class=\"n\">modified_track</span>\n  <span class=\"k\">let</span> <span class=\"n\">to_track</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Fin.ofNat</span><span class=\"bp\">?</span> <span class=\"n\">to_track</span>\n  <span class=\"k\">let</span> <span class=\"n\">tracks</span> <span class=\"o\">:=</span> <span class=\"n\">tracks.set</span> <span class=\"n\">to_track</span> <span class=\"o\">(</span><span class=\"n\">List.append</span> <span class=\"n\">taken</span> <span class=\"n\">tracks</span><span class=\"o\">[</span><span class=\"n\">to_track</span><span class=\"o\">])</span>\n  <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">{</span> <span class=\"n\">tracks</span> <span class=\"o\">:=</span> <span class=\"n\">tracks</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- valid Action are reversible -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">biject_valid</span> <span class=\"o\">:</span>\n  <span class=\"k\">do</span><span class=\"bp\">?</span> <span class=\"n\">deck</span> <span class=\"n\">action</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">deck'</span> <span class=\"bp\">-&gt;</span>\n  <span class=\"k\">do</span><span class=\"bp\">?</span> <span class=\"n\">deck'</span> <span class=\"o\">(</span><span class=\"n\">action.reverse</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">deck</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- no idea how to prove this</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">biject</span> <span class=\"o\">(</span><span class=\"n\">deck</span><span class=\"o\">:</span> <span class=\"n\">Deck</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">action</span><span class=\"o\">:</span> <span class=\"n\">Action</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"k\">match</span> <span class=\"k\">do</span><span class=\"bp\">?</span> <span class=\"n\">deck</span> <span class=\"n\">action</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">deck'</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span><span class=\"bp\">?</span> <span class=\"n\">deck'</span> <span class=\"n\">action.reverse</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">deck</span>\n<span class=\"o\">:=</span><span class=\"k\">match</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"k\">do</span><span class=\"bp\">?</span> <span class=\"n\">deck</span> <span class=\"n\">action</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True.intro</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">_deck'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">biject_valid</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Deck</span>\n</code></pre></div>",
        "id": 350610596,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1681763741
    },
    {
        "content": "<p>Also, is there a way to do property testing in Lean?</p>",
        "id": 350610618,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1681763750
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515610\">Locria Cyber</span> <a href=\"#narrow/stream/270676-lean4/topic/solitaire.20undo/near/350610618\">said</a>:</p>\n<blockquote>\n<p>Also, is there a way to do property testing in Lean?</p>\n</blockquote>\n<p>have you seen LSpec/SlimCheck? <a href=\"https://github.com/lurk-lab/LSpec\">https://github.com/lurk-lab/LSpec</a></p>",
        "id": 350611038,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1681763906
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315434\">Andrés Goens</span> <a href=\"#narrow/stream/270676-lean4/topic/solitaire.20undo/near/350611038\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"515610\">Locria Cyber</span> <a href=\"#narrow/stream/270676-lean4/topic/solitaire.20undo/near/350610618\">said</a>:</p>\n<blockquote>\n<p>Also, is there a way to do property testing in Lean?</p>\n</blockquote>\n<p>have you seen LSpec/SlimCheck? <a href=\"https://github.com/lurk-lab/LSpec\">https://github.com/lurk-lab/LSpec</a></p>\n</blockquote>\n<p>no. thanks! I'll try it out</p>",
        "id": 350612600,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1681764567
    },
    {
        "content": "<p>On <code>match</code> unification</p>\n<p>For some reason, this is not type checking</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">biject_T</span> <span class=\"o\">(</span><span class=\"n\">deck</span><span class=\"o\">:</span> <span class=\"n\">Deck</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">action</span><span class=\"o\">:</span> <span class=\"n\">Action</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"k\">do</span><span class=\"bp\">?</span> <span class=\"n\">deck</span> <span class=\"n\">action</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">deck'</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span><span class=\"bp\">?</span> <span class=\"n\">deck'</span> <span class=\"n\">action.reverse</span> <span class=\"bp\">=</span> <span class=\"n\">Option.some</span> <span class=\"n\">deck</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">biject</span> <span class=\"o\">(</span><span class=\"n\">deck</span><span class=\"o\">:</span> <span class=\"n\">Deck</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">action</span><span class=\"o\">:</span> <span class=\"n\">Action</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">biject_T</span> <span class=\"n\">deck</span> <span class=\"n\">action</span>\n<span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"k\">do</span><span class=\"bp\">?</span> <span class=\"n\">deck</span> <span class=\"n\">action</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True.intro</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">_deck'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">biject_valid</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>Isn't <code>abbrev</code> suppose to expand <code>biject_T deck action</code>?</p>\n<p>The if I manually expand the expression <code>biject_T deck action</code> it works (see first code sample of this thread).</p>",
        "id": 350617181,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1681766486
    },
    {
        "content": "<p>No, <code>abbrev</code> does not immediately expand to its definition, it merely makes the definition always reducible (especially under typeclass search, unlike <code>def</code>). But the discriminant generalization of <code>match</code> works basically syntactically, without reduction.</p>",
        "id": 350691388,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1681802183
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/solitaire.20undo/near/350691388\">said</a>:</p>\n<blockquote>\n<p>No, <code>abbrev</code> does not immediately expand to its definition, it merely makes the definition always reducible (especially under typeclass search, unlike <code>def</code>). But the discriminant generalization of <code>match</code> works basically syntactically, without reduction.</p>\n</blockquote>\n<p>How do I make it expand when used as type?</p>",
        "id": 350902122,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1681859470
    },
    {
        "content": "<p>(edit: forget what I said; I misunderstood what you wanted)</p>",
        "id": 350907415,
        "sender_full_name": "Mac Malone",
        "timestamp": 1681862641
    }
]