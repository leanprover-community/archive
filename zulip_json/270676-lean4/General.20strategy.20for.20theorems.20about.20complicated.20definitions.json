[
    {
        "content": "<p>Hi!<br>\nSo I'm writing some very basic graph theory proofs, but my definitions are getting a bit tangled to the point that I have relatively complicated definitions e.g. for <code>Path.append</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"bp\">.</span><span class=\"n\">append</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">p1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">graph</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">graph</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hp1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"bp\">.</span><span class=\"n\">IsBetween</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hp2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"bp\">.</span><span class=\"n\">IsBetween</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hvOnlyCommon</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OnlyCommon</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">graph</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">IsBetween</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>As you can see, I modeled some properties of the return value of <code>Path.append</code> through the use of a subtype.<br>\nI think modeling <code>Path.IsBetween u w</code> with the subtype is fine, but I am not happy with having to model the length properties in there too.</p>\n<p>This leads me to my first question: It's surely not idiomatic to just prove everything about a definition inside the definition itself and then have the proven theorems be properties of the subtype like I did, right?</p>\n<p>Let me now explain, why I even chose to put the length properties in the subtype.<br>\nThis is because my <code>Path.append</code> definition has to do a bit of work to actually append the paths (orient the given paths, which are basically lists of vertices).<br>\nI tried proving the length properties from an external theorem, but I couldn't get that to work, because unfolding <code>Path.append</code> (and <code>Path.length</code>) lead to something I couldn't really work with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">‚ä¢</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üë</span><span class=\"o\">(</span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">op1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hop1</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">          </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">op1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚ãØ‚ü©</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">            </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"bp\">.</span><span class=\"n\">orient</span><span class=\"w\"> </span><span class=\"n\">hp2</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">            </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">op2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚ãØ‚ü©</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">              </span><span class=\"bp\">‚ü®</span><span class=\"o\">{</span>\n<span class=\"w\">                  </span><span class=\"n\">walk</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">                    </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">vertices</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">op1</span><span class=\"bp\">.</span><span class=\"n\">walk</span><span class=\"bp\">.</span><span class=\"n\">vertices</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">op2</span><span class=\"bp\">.</span><span class=\"n\">walk</span><span class=\"bp\">.</span><span class=\"n\">vertices</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">isNonempty</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ãØ</span><span class=\"o\">,</span>\n<span class=\"w\">                      </span><span class=\"n\">hasAdjacentVertices</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ãØ</span><span class=\"w\"> </span><span class=\"o\">},</span>\n<span class=\"w\">                  </span><span class=\"n\">isNonRepeating</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ãØ</span><span class=\"w\"> </span><span class=\"o\">},</span>\n<span class=\"w\">                </span><span class=\"bp\">‚ãØ‚ü©</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">walk</span><span class=\"bp\">.</span><span class=\"n\">vertices</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">  </span><span class=\"n\">p1</span><span class=\"bp\">.</span><span class=\"n\">walk</span><span class=\"bp\">.</span><span class=\"n\">vertices</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"bp\">.</span><span class=\"n\">walk</span><span class=\"bp\">.</span><span class=\"n\">vertices</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>This leads me to my second question: Is there some way of simplifying this goal state? That would enable me to actually prove properties such as the length properties in external theorems, which I think would be more idiomatic as the properties of definitions like <code>Path.append</code> would then be extensible from the outside.</p>",
        "id": 574293735,
        "sender_full_name": "Jannis",
        "timestamp": 1771335955
    },
    {
        "content": "<p>So I actually managed to prove the length properties from an external theorem now:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">path_append_length</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">p1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">graph</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">graph</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hp1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"bp\">.</span><span class=\"n\">IsBetween</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hp2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"bp\">.</span><span class=\"n\">IsBetween</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hvOnlyCommon</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OnlyCommon</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p1</span><span class=\"bp\">.</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"w\"> </span><span class=\"n\">hp1</span><span class=\"w\"> </span><span class=\"n\">hp2</span><span class=\"w\"> </span><span class=\"n\">hvOnlyCommon</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n<span class=\"w\">    </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Path</span><span class=\"bp\">.</span><span class=\"n\">append</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">‚ü®_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"bp\">.</span><span class=\"n\">orient</span><span class=\"w\"> </span><span class=\"n\">hp1</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">‚ü®_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"bp\">.</span><span class=\"n\">orient</span><span class=\"w\"> </span><span class=\"n\">hp2</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"bp\">.</span><span class=\"n\">walk</span><span class=\"bp\">.</span><span class=\"n\">vertices</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">length_pos_of_ne_nil</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"bp\">.</span><span class=\"n\">walk</span><span class=\"bp\">.</span><span class=\"n\">isNonempty</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n</code></pre></div>\n<p>This now leaves only my first question to be answered.</p>",
        "id": 574298190,
        "sender_full_name": "Jannis",
        "timestamp": 1771337132
    },
    {
        "content": "<p>It generally makes more sense to first implement the function itself, and then prove properties about it. When you define addition on numbers, you don't have a type <code>add : Nat -&gt; Nat -&gt; { res : Nat // is commutative and all the other properties }</code> either.</p>",
        "id": 574333231,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1771345579
    },
    {
        "content": "<p>If you often handle objects like \"path from A to B\", then you can still define a helper after defining <code>append</code> and after proving properties about it. Something like <code>def PathBetween (a b : Vertex) : Type := { p : Path // ... }</code>, and then define some convenience combinators, like <code>def PathBetween.append (p1 : PathBetween A B) (p2 : PathBetween B C) : PathBetween A C := ...</code></p>",
        "id": 574336114,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1771346347
    }
]