[
    {
        "content": "<p>I have a problem when I want to wrap two different monads (<code>m</code> and <code>n</code>) in the same monad <code>o</code>.<br>\nHowever if <code>m</code> and <code>n</code> have different type levels, this doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n  <span class=\"n\">o</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">o</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Is there any solution to this? I would like to have <code>o</code> being generic over a type level, something like <code>{o : {w₂} → Type w₂ → Type _}</code>, but that code doesn't seem to work.</p>",
        "id": 350565730,
        "sender_full_name": "Tage Johansson",
        "timestamp": 1681749146
    },
    {
        "content": "<p>If you really care about this, you'll probably have to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ULift#doc\">docs4#ULift</a> to <code>max v w</code></p>",
        "id": 350567637,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1681749679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"544752\">Tage Johansson</span> <a href=\"#narrow/stream/270676-lean4/topic/Generic.20over.20universe.20levels.20in.20argument/near/350565730\">said</a>:</p>\n<blockquote>\n<p>I would like to have <code>o</code> being generic over a type level, something like <code>{o : {w₂} → Type w₂ → Type _}</code></p>\n</blockquote>\n<p>This is a limitation of Lean's type system: you can't have variables that are polymorphic over universe levels. Only top-level definitions can be universe polymorphic. (What would be the type of <code>{w₂} → Type w₂ → Type _</code>? There's not a big enough universe for it.)</p>\n<p>Technically, if you have a monad instantiated twice with different universe variables, then even though the monads are from the same definition, the resulting monads are different and have no relation to each other. (I think of universe levels as giving you a family of definitions rather than a single definition.)</p>\n<p>One thing you could do is have <code>foo</code> take two different <code>o</code> arguments. Another is to do something like what Eric is suggesting; one implementation is to make all the monads use the same universe levels and then use <code>ULift</code> when you need types from different universes.</p>",
        "id": 350573944,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681751330
    }
]