[
    {
        "content": "<p>Sometimes <code>simp at ...</code> creates a new hypothesis instead of simplifying the given one. I think this happens when <code>simp</code> applies non-definitionally equalties. However, by simply creating a new hypothesis which is unrelated to the old, it sometimes becomes difficult to prove something.  Here is a contrived example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)):</span><span class=\"w\"> </span><span class=\"n\">IsBool</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">rename_i</span><span class=\"w\"> </span><span class=\"n\">x'</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≍</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>After simp has created an equivalent but different hypothesis, is it possible to prove that these two are still the same? In short, how to prove: <code>x ≍ x'</code>, where <code>x'</code> has been created by <code>simp at x</code>.</p>",
        "id": 553600647,
        "sender_full_name": "David Richter",
        "timestamp": 1762259278
    },
    {
        "content": "<p>I don't think this is possible</p>",
        "id": 553601310,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762259489
    },
    {
        "content": "<p>if you look at the context there's nothing that connects <code>x</code> with <code>x'</code></p>",
        "id": 553601440,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762259528
    },
    {
        "content": "<p>I fear the best advice here is \"don't get yourself into this situation\"</p>",
        "id": 553602000,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1762259691
    },
    {
        "content": "<p>Can you make that a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 553603281,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1762260026
    },
    {
        "content": "<blockquote>\n<p>Aaron Liu: I don't think this is possible<br>\nAaron Liu: if you look at the context there's nothing that connects <code>x</code> with <code>x'</code></p>\n</blockquote>\n<p>Yes, after having performed <code>simp at x</code>, there is nothing that connects these two. Maybe there is a variant or configuration option to simp that retains a proof that connects the new and the old hypothesis?</p>",
        "id": 553604812,
        "sender_full_name": "David Richter",
        "timestamp": 1762260460
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsBool#doc\">docs#IsBool</a> (404)</p>",
        "id": 553605069,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1762260540
    },
    {
        "content": "<p>maybe you can <code>revert x</code> first before rewriting with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=if_pos#doc\">docs#if_pos</a></p>",
        "id": 553605339,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762260628
    },
    {
        "content": "<p>sorry, forgot the IsBool definition</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">IsBool</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsBool</span><span class=\"w\"> </span><span class=\"n\">o</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)):</span><span class=\"w\"> </span><span class=\"n\">IsBool</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">rename_i</span><span class=\"w\"> </span><span class=\"n\">x'</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≍</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but really, this is not about proving specifically this goal, as it can be solved much easier in another way. to come up with an example where i actually need x=x' i probably need quite a few more lines...</p>",
        "id": 553605356,
        "sender_full_name": "David Richter",
        "timestamp": 1762260633
    },
    {
        "content": "<p>Type equality in lean is in general undecidable, for example if X is any type with two terms which isn't defeq to Bool (for example <code>Fin 2</code> or <code>Option Unit</code>) then <code>X = Bool</code> is neither provable nor disprovable in Lean's type theory. Are you sure that this is what you want?</p>",
        "id": 553605606,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1762260712
    },
    {
        "content": "<p>you can also <code>have teq : Foo = Bar := by simp</code> and then <code>have hx : x ≍ x := .rfl</code> and then rewrite the right side of <code>hx</code> using <code>teq</code></p>",
        "id": 553605705,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762260744
    },
    {
        "content": "<p>It's probably worth stepping back and thinking if you can solve your original problem without conditional types</p>",
        "id": 553606268,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1762260910
    },
    {
        "content": "<p>Thanks, for the thoughts!</p>\n<blockquote>\n<p>Type equality in lean is in general undecidable, for example if X is any type with two terms which isn't defeq to Bool (for example <code>Fin 2</code> or <code>Option Unit</code>) then <code>X = Bool</code> is neither provable nor disprovable in Lean's type theory. Are you sure that this is what you want?</p>\n</blockquote>\n<p>I'm not trying to prove equality for arbitrary types. I'm specifically interested in retaining a proof that anything produced by simp is still equal to what was given to simp.</p>\n<p>Most often, when you apply <code>simp at x</code> to the hypothesis <code>x</code>, the hypothesis <code>x</code> only changes its type. For example given a hypothesis <code>x: Fin (1+2)</code> we can simp it to <code>x: Fin 3</code>. These definitional-equalities can also be performed by using <code>dsimp</code> instead of <code>simp</code>, limiting the applicable equalities to only definitional ones.</p>\n<p>But <code>simp</code> can also perform non-definitional equalities, like for example associativity of natural addition, or simplification of if-then-else here. When <code>simp</code> performs non-definitional equalities, it seems it produces <em>a new hypothesis</em> which takes the name <code>x</code> with the simplified type, while graying out the old hypothesis <code>x</code>(and renaming it to <code>x†</code>, which retains its old type). This is a problem, when the old hypothesis was used anywhere else in the goal, as these references continue to use the old <code>x†</code>.</p>\n<p>Consider the proof states before and after <code>simp</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">IsBool</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsBool</span><span class=\"w\"> </span><span class=\"n\">o</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)):</span><span class=\"w\"> </span><span class=\"n\">IsBool</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- at this point the proof state is:</span>\n<span class=\"w\">  </span><span class=\"c1\">--   n : ℕ</span>\n<span class=\"w\">  </span><span class=\"c1\">--   x : Option (if n + 1 &gt; n then Bool else String)</span>\n<span class=\"w\">  </span><span class=\"c1\">--   ⊢ IsBool x</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"c1\">-- now the proof state is</span>\n<span class=\"w\">  </span><span class=\"c1\">--   n : ℕ</span>\n<span class=\"w\">  </span><span class=\"c1\">--   x✝ : Option (if n + 1 &gt; n then Bool else String)   &lt;- the x gets renamed but retains its type</span>\n<span class=\"w\">  </span><span class=\"c1\">--   x : Option Bool -- &lt;- a new x appears with the simplified type</span>\n<span class=\"w\">  </span><span class=\"c1\">--   ⊢ IsBool x✝ -- &lt;- the problem is that the proof continues to use the old x, and that there is no relationship between the old and the new x</span>\n</code></pre></div>\n<p>Clearly, <code>simp</code>only uses equalities (whether definitional or not) to simplify the type, so it should be possible to retain that the newly produced hypothesis is the same as the old. But it seems that is not the case...</p>\n<blockquote>\n<p>maybe you can <code>revert x</code> first before rewriting with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=if_pos#doc\">docs#if_pos</a></p>\n</blockquote>\n<p>yes, in this case doing revert first, then simp, and then intro, etc. works. i tried that in my attempts, but if the code is sufficiently additionally complex, then <code>simp</code> doesnt apply the rule anymore, and using explicit rewriting leads to <code>motive is not type correct</code>.</p>\n<p>i guess i should produce a self-contained example, and return with that, but that will take some more time...</p>",
        "id": 553609648,
        "sender_full_name": "David Richter",
        "timestamp": 1762261834
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687543\">David Richter</span> <a href=\"#narrow/channel/270676-lean4/topic/How.20to.20prove.20.60x.20.E2.89.8D.20x'.60.20where.20.60x'.60.20was.20created.20via.20.60simp.20at.20x.60/near/553609648\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>maybe you can <code>revert x</code> first before rewriting with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=if_pos#doc\">docs#if_pos</a></p>\n</blockquote>\n<p>yes, in this case doing revert first, then simp, and then intro, etc. works. i tried that in my attempts, but if the code is sufficiently additionally complex, then <code>simp</code> apply the rule anymore, and using explicit rewriting leads to <code>motive is not type correct</code>.</p>\n</blockquote>\n<p>I will once again advertise <a href=\"https://tqft.net/mathlib4files/Tactic/DepRewrite\">file#Tactic/DepRewrite</a></p>",
        "id": 553610011,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762261938
    },
    {
        "content": "<p>The module doc of this file doesn't tell you what the syntax of the tactic is</p>",
        "id": 553610477,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1762262082
    },
    {
        "content": "<p>The file defines only two syntaxes, so I guess your proposing to use <code>rw!</code> instead of <code>rw</code>/<code>simp</code>?<br>\nHm... let's see.</p>",
        "id": 553611355,
        "sender_full_name": "David Richter",
        "timestamp": 1762262342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/270676-lean4/topic/How.20to.20prove.20.60x.20.E2.89.8D.20x'.60.20where.20.60x'.60.20was.20created.20via.20.60simp.20at.20x.60/near/553610477\">said</a>:</p>\n<blockquote>\n<p>The module doc of this file doesn't tell you what the syntax of the tactic is</p>\n</blockquote>\n<p>oh no, I'll add that to the list of things I have to fix</p>",
        "id": 553612977,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762262809
    }
]