[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">NumberTheory</span><span class=\"bp\">.</span><span class=\"n\">FLT</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">badNatUnsafe</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">4294967296</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">implemented_by</span><span class=\"w\"> </span><span class=\"n\">badNatUnsafe</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">badNatVal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n\n<span class=\"n\">run_elab</span>\n<span class=\"w\">  </span><span class=\"n\">addDecl</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">defnDecl</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">name</span><span class=\"w\">        </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">anonymous</span><span class=\"w\"> </span><span class=\"s2\">\"badNat\"</span>\n<span class=\"w\">    </span><span class=\"n\">levelParams</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">    </span><span class=\"n\">type</span><span class=\"w\">        </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Nat</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">    </span><span class=\"n\">value</span><span class=\"w\">       </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">lit</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">natVal</span><span class=\"w\"> </span><span class=\"n\">badNatVal</span>\n<span class=\"w\">    </span><span class=\"n\">hints</span><span class=\"w\">       </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"kn\">opaque</span>\n<span class=\"w\">    </span><span class=\"n\">safety</span><span class=\"w\">      </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">safe</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">FLT</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FermatLastTheorem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">truly_marvelous_0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">badNat</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">9223372036854775807</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">truly_marvelous_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"mi\">9223372036854775807</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">badNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n<span class=\"w\">  </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">not_le</span><span class=\"o\">]</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">FLT</span>\n<span class=\"c1\">-- 'FLT' depends on axioms: [propext]</span>\n</code></pre></div>\n<p><a href=\"https://live.lean-lang.org/#codez=JYWwDg9gTgLgBAWQIYwBYBtgCMB0ARFJHAORRwCEkBnYAYwChRJZEUNscAVJWmOx8NHjI0mXMQCuILAFMonVDOgBPHADEAMpwrV+TIXA0ykAO3r0IYGScPGb5iSapIAZjLgATGS7hYkH0hgAVSdXdwAuOEBUQjhwgF44R2c3AGFqeAAKAFoAFgAmAE4cgoA2AHZCkti4QBJCAEpzAAEAbSZ0GRBrGBkPAH0sZV9/QJDkmQBdOEskAEcJdz8AlAA1JHRqqPMoR16ZdCQsejg4fw88GVp1gB4AHzgcLxcTc8u4AG8j47gTJE6v/9iCRwVBgUHupggJmUIAgEiocAARItAgjPsd2gA3PYABSQUF+8PicGa4zRcBgyisAK+RJwtEhILgAAMmYFiaT/hi1vNqYD7ph4Ld7j8YKt1siVmsyahgCYYPDqbTpnMZGSxhTFUCxp8AL7mNBKKAdOCaTjVNRyEAoDTpBSG41EgafVBILHk7boZS9K1QLHoWFUXoABmqABqJfBACZEcAKeTyAGZ4xUg/GSgAOACsOTKZQzaaDZT5A08F2AXmdrvcoIknu9eL9Ad6AEYw7GE0m8in01mc3mC3ArkMlvBHYMvLQy6rjjRwL01utIZ7iSYIDBeu1SfQAMRgKCy+BIAAewAgIHhpvoWSycAA5KabyWrCYPPDISdj6eqJFmrvLDJDzApJAA\">Web version.</a></p>\n<p>I don't know whether this counts as a 'soundness bug' since it uses environment hacking to intentionally send a malformed declaration to the kernel, but it does fool lean4checker and SafeVerify. As far as I can tell, this could have in principle been used to claim the bounties on TheoremMarketplace (so <span class=\"user-mention\" data-user-id=\"776090\">@GasStationManager</span> and <span class=\"user-mention\" data-user-id=\"568200\">@Vadim Fomin</span> should know about it). Because of this, I'm guessing it wasn't a known issue.</p>\n<p>Interestingly it doesn't fool Comparator because Comparator exports the solution environment to a string first (using lean4export) and then parses that string. Since <code>BadNatVal</code> gets printed as <code>4294967296</code>, the resulting proof no longer typechecks. (By contrast, SafeVerify uses .olean files, which are able to represent the malformed expression 'correctly'.)</p>",
        "id": 566253027,
        "sender_full_name": "James E Hanson",
        "timestamp": 1767563943
    },
    {
        "content": "<p>For safe verify, what does the challenge file look like?</p>",
        "id": 566256279,
        "sender_full_name": "Jason Rute",
        "timestamp": 1767567966
    },
    {
        "content": "<p><del>So the exploit is changing the declaration, but in a way that SafeVerify can’t detect?</del></p>",
        "id": 566256421,
        "sender_full_name": "Jason Rute",
        "timestamp": 1767568128
    },
    {
        "content": "<p>Does lean4checker work because it is a valid proof, but just of a different declaration?  Or is the proof invalid?</p>",
        "id": 566256477,
        "sender_full_name": "Jason Rute",
        "timestamp": 1767568213
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"904624\">@James E Hanson</span> for finding this! It does appear to pass SafeVerify. I would like to understand this more, to see to what extent this could be fixed in SafeVerify or elsewhere. </p>\n<p>To me the surprising thing about the example is that <code>decide</code> worked. From what I understand, <code>decide</code> here is unfolding opaque defs that ultimately leads to an unsafe def. But the 'unsafe' is not propagated; the <code>run_elab</code> makes a declaration that is 'safe'...</p>\n<p>If the <code>run_elab</code> is replaced with a normal def, then <code>decide</code> doesn't work.</p>",
        "id": 566257146,
        "sender_full_name": "GasStationManager",
        "timestamp": 1767569101
    },
    {
        "content": "<p>What's happening is that the <code>unsafeCast</code> produces a Lean object at the C level that confuses the part of the kernel that is capable of handling natural numbers natively to the point where the logic implementing the <a href=\"http://Nat.lt\">Nat.lt</a> and Nat.le operations for <code>decide</code> returns true in both cases. It's not really surprising that this only works with <code>run_elab</code> because otherwise <code>decide</code> will never get to see this malformed object.</p>\n<p>This is precisely the kind of exploit that I was hoping to prevent in Comparator by being more paranoid about the input format. The key design principle of Comparator is that the <code>olean</code> (and even the <code>lean</code>) file are to be considered malicious input. Mapping malicious input into our memory and blindly dereferencing pointers without any validation mechanism can and will go wrong and that is exactly what importing an <code>olean</code> file does. (Though I had expected it to be some cool trick with pointers and not this easy to be honest <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>)</p>",
        "id": 566258040,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1767570360
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/channel/270676-lean4/topic/SafeVerify-passing.20kernel.20soundness.20exploit/near/566256279\">said</a>:</p>\n<blockquote>\n<p>For safe verify, what does the challenge file look like?</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">NumberTheory</span><span class=\"bp\">.</span><span class=\"n\">FLT</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">FLT</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FermatLastTheorem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 566259895,
        "sender_full_name": "James E Hanson",
        "timestamp": 1767572624
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/channel/270676-lean4/topic/SafeVerify-passing.20kernel.20soundness.20exploit/near/566256477\">said</a>:</p>\n<blockquote>\n<p>Does lean4checker work because it is a valid proof, but just of a different declaration?  Or is the proof invalid?</p>\n</blockquote>\n<p>It's a valid proof in the same sense that <a href=\"https://en.wikipedia.org/wiki/MissingNo.\">missingno</a> is a real pokemon.</p>",
        "id": 566260288,
        "sender_full_name": "James E Hanson",
        "timestamp": 1767573029
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> good points, and I agree that what Comparator does is safer. But at the same time this also feels like a bug. If the kernel wants to be able to handle natural numbers natively, then it is either worth making it robust or leave it to the compiler / native_decide.</p>",
        "id": 566261281,
        "sender_full_name": "GasStationManager",
        "timestamp": 1767574438
    },
    {
        "content": "<p>I'm not sure whether the devs are going to want to do something about this because it might be a performance issue to sanitize declarations that are passed to the kernel.</p>",
        "id": 566261339,
        "sender_full_name": "James E Hanson",
        "timestamp": 1767574520
    },
    {
        "content": "<p>I don't really know though, obviously.</p>",
        "id": 566261361,
        "sender_full_name": "James E Hanson",
        "timestamp": 1767574550
    },
    {
        "content": "<p>The natural numbers are a red herring here. Exploits of the same kind are almost certainly doable by crafting olean files where expressions point to memory regions they aren't supposed to. I suspect the only reason this hasn't happened yet is that we do not have enough people with the necessary skillset and willingness in our community to figure out how to do it (look into e.g. ROP exploit chains on browsers, people go to extreme lengths of sophistication when sufficiently motivated). You cannot expect the kernel to somehow guard every pointer dereference it ever makes. Allowing an attacker to inject arbitrary things into your memory that you start playing around with is half of the effort that goes into writing arbitrary code execution exploits against \"normal programs\" and any verifier that imports oleans is giving this away for free by design. The only mean to defend against this type of attack consistently is to not load olean files.</p>",
        "id": 566261791,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1767574989
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> I tend to agree with you there. The kernel is implicitly trusting that the environment does not contain malformed objects. (But how do you define well-formed vs malformed? If the official definition is whatever  remains valid after a round trip to lean4export?)</p>\n<p>At the same time, this natural number example is perhaps making it too easy. native_decide would not have gotten confused by this, just sayin.</p>",
        "id": 566263340,
        "sender_full_name": "GasStationManager",
        "timestamp": 1767576437
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776090\">GasStationManager</span> <a href=\"#narrow/channel/270676-lean4/topic/SafeVerify-passing.20kernel.20soundness.20exploit/near/566263340\">said</a>:</p>\n<blockquote>\n<p>native_decide would not have gotten confused by this, just sayin.</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">NumberTheory</span><span class=\"bp\">.</span><span class=\"n\">FLT</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">badNatUnsafe</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">4294967296</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">implemented_by</span><span class=\"w\"> </span><span class=\"n\">badNatUnsafe</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">badNatVal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n\n<span class=\"n\">run_elab</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">anonymous</span><span class=\"w\"> </span><span class=\"s2\">\"badNat\"</span>\n<span class=\"w\">  </span><span class=\"n\">addDecl</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">defnDecl</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">name</span><span class=\"w\">        </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">name</span>\n<span class=\"w\">    </span><span class=\"n\">levelParams</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">    </span><span class=\"n\">type</span><span class=\"w\">        </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Nat</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">    </span><span class=\"n\">value</span><span class=\"w\">       </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">lit</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">natVal</span><span class=\"w\"> </span><span class=\"n\">badNatVal</span>\n<span class=\"w\">    </span><span class=\"n\">hints</span><span class=\"w\">       </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"kn\">opaque</span>\n<span class=\"w\">    </span><span class=\"n\">safety</span><span class=\"w\">      </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">safe</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">setImplementedBy</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"ss\">``badNatUnsafe</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">FLT</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FermatLastTheorem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">truly_marvelous_0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">badNat</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">9223372036854775807</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">truly_marvelous_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">badNat</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">9223372036854775808</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">FLT</span>\n<span class=\"c1\">-- 'FLT' depends on axioms: [propext, Lean.ofReduceBool, Lean.trustCompiler]</span>\n</code></pre></div>\n<p><a href=\"https://live.lean-lang.org/#codez=JYWwDg9gTgLgBAWQIYwBYBtgCMB0ARFJHAORRwCEkBnYAYwChRJZEUNscAVJWmOx8NHjI0mXMQCuILAFMonVDOgBPHADEAMpwrV+TIXA0ykAO3r0IYGScPGz9CSapIAZjLgATGS7hYkH0hgAVSdXdwAuOEBUQjhwgF44R2c3AGFqeAAKAFoAFgAmAE4cgoA2AHZCkti4QBJCAEpzAAEAbSZ0GRBrGBkPAH0sZV9/QJDkmQBdOEskAEcJdz8AlAA1JHRqqPMoR16ZdCQsejg4dvgTJE7YhJwqGCg4HFMIE2UQCAkqOAAiRcCvo7g/g8eBktHWAB4AD4PLwuEwgsFwADeAOO50ux0xx3icHRMlRJxkADc9gAFJBQC6fHHNcYEmDKKxYrE4nC0Z63OAAAy5gTgtIJRLW82Z2OumHgUIe5xgq3WvxWawJqGAJhgn1FrOmc3xWLGDM11zGAIAvgCjKYbjIYABJcDtTpqnrkQZ47lchXBUJucxoJRQDpwTScapqOQgFAadIKf2BnEDAGoJAkuB3CToZS9CNQEnod5UXoABmqnrgAD44AU8nkAMw1iqFmslAAcAFYcmUyq3m4WyldfK6UMASb0vLRgF5E8n3GmM1mKbn870AIwl4YoODgyvVusNpttjtdnvNsUD3FDkdjie61NQYfAJX0ADEYDvasBAA9gBAQJ9g/QsiyOAAHJg2AzwZCsEwPE+Z5P2/X9ImaV9LBkD8YAAGlsS0IBcAAlHoJFoGRyAgCB0Cwi0TBwNNbhSH8wGAdooDpeggA\">Web version.</a></p>",
        "id": 566264319,
        "sender_full_name": "James E Hanson",
        "timestamp": 1767577266
    },
    {
        "content": "<p>I guess maybe this isn't the same 'this' because I'm adding in an <code>implemented_by</code> declaration.</p>",
        "id": 566264357,
        "sender_full_name": "James E Hanson",
        "timestamp": 1767577299
    },
    {
        "content": "<p>But really I worked out this example in part by thinking about easier examples of the same kind of thing with <code>native_decide</code>.</p>",
        "id": 566264444,
        "sender_full_name": "James E Hanson",
        "timestamp": 1767577387
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"904624\">@James E Hanson</span> Very nice, I stand corrected. I guess once we see native_decide and implemented_by in the same file we should expect anything can happen; but still, this is something I haven't seen before, very interesting.</p>",
        "id": 566265628,
        "sender_full_name": "GasStationManager",
        "timestamp": 1767578524
    },
    {
        "content": "<p>Yes, it's very easy with both of them:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">implemented_by</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">tralse</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tralse</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tralse</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>\n<p><a href=\"https://live.lean-lang.org/#codez=JYWwDg9gTgLgBAWQIYwBYBtgCMBQOACA2qGOgKYhkB2MZAJgPpYCecAZkugM5kC6OdMmzgwonHnABccAEIQI6KQF4RUAK5k8ZAB5Jw5KXABi4ssrgsccOKiQA3M9NGm4K0RvMs4UNuis37R1UXFQ5uRxUvKhRgBwZBAGNgQX9RWOBOIA\">Web version.</a></p>",
        "id": 566265933,
        "sender_full_name": "James E Hanson",
        "timestamp": 1767578802
    },
    {
        "content": "<p>And at least some of the SafeVerify-based proof checking backends do ban implemented_by, though at the source level. <a href=\"https://github.com/GasStationManager/CodeProofTheArena/blob/main/app/services/judge.py\">Example</a></p>",
        "id": 566266617,
        "sender_full_name": "GasStationManager",
        "timestamp": 1767579483
    },
    {
        "content": "<p>I have just pushed to <a href=\"https://github.com/GasStationManager/SafeVerify\">SafeVerify</a> a fix that covers this case. </p>\n<p>In more detail: it has always been designed / intended to ban the use of unsafe and partial definitions,  since they are known to cause soundness issues. But previously I wasn't checking them properly; the correct way is to check before passing to Environment.replay, but I was doing it after.  Since Environment.replay was in fact skipping unsafe/partial constants, they weren't in the environment after the replay. In this example, the unsafe def badNatUnsafe ends up sneaking into the proof via implemented_by. After the fix, SafeVerify is able to detect the unsafe def and throws an error.</p>",
        "id": 566270385,
        "sender_full_name": "GasStationManager",
        "timestamp": 1767583799
    },
    {
        "content": "<p>Besides this, what soundness issues do unsafe and partial cause?</p>",
        "id": 566270517,
        "sender_full_name": "Jason Rute",
        "timestamp": 1767583929
    },
    {
        "content": "<p>I ask because someone may want to use partial to write a function which is used in a custom tactic.</p>",
        "id": 566270603,
        "sender_full_name": "Jason Rute",
        "timestamp": 1767584015
    },
    {
        "content": "<p><code>partial</code> doesn't cause any soundness issues</p>",
        "id": 566271148,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767584463
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/channel/270676-lean4/topic/SafeVerify-passing.20kernel.20soundness.20exploit/near/566270603\">said</a>:</p>\n<blockquote>\n<p>I ask because someone may want to use partial to write a function which is used in a custom tactic.</p>\n</blockquote>\n<p>you can use whatever functions you want in the implementation of a tactic (even <code>unsafe</code> functions!), and it will not cause any problems as long as the proof terms outputted by the tactic don't contain the bad functions</p>",
        "id": 566271294,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767584575
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/270676-lean4/topic/SafeVerify-passing.20kernel.20soundness.20exploit/near/566265933\">said</a>:</p>\n<blockquote>\n<p>Web version.</p>\n</blockquote>\n<p>FYI you don't need to include this link. Hover over the top right of any code snippet to find it.</p>",
        "id": 566298845,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767602263
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/270676-lean4/topic/SafeVerify-passing.20kernel.20soundness.20exploit/near/566261791\">said</a>:</p>\n<blockquote>\n<p>I suspect the only reason this hasn't happened yet is that we do not have enough people with the necessary skillset and willingness in our community to figure out how to do it</p>\n</blockquote>\n<p>The threat model here is not very clear to me. The AI companies care about some lean proof being gamed, but is it the case for anyone else? Why should I care?</p>\n<p>My threat model w.r.t lean is more about the security of my own device so I am much more concerned about the fact that to really read a proof you need to run it in interactive mode where another person's code could backdoor you. The entire community is vulnerable to this, meaning that watering hole attacks against e.g. reviewers with commit access to mathlib whose code I do run means I am also vulnerable to this even if I don't run untrusted code. We could sandbox lean to disallow access to network system calls but this would probably break some functionality I haven't thought of. <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> (sandboxes are also not perfect, but for how small our community is I imagine this would be a sufficient step for quite a while.)</p>",
        "id": 566299171,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1767602383
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/channel/270676-lean4/topic/SafeVerify-passing.20kernel.20soundness.20exploit/near/566270603\">said</a>:</p>\n<blockquote>\n<p>I ask because someone may want to use partial to write a function which is used in a custom tactic.</p>\n</blockquote>\n<p>Looking back at earlier discussions, I think my issue with partial mainly stems from SafeVerify's original use case in checking <a href=\"https://github.com/GasStationManager/CodeProofTheArena\">executable code with correctness proofs</a>, where partial functions are problematic at least due to their obvious potential for non-termination. </p>\n<p>Since most subsequent use cases are for pure proofs, and partial does have legitimate use in writing tactics, I've pushed an update so that SafeVerify only disallows partial if an optional command-line flag (--disallow-partial) is set.</p>",
        "id": 566307084,
        "sender_full_name": "GasStationManager",
        "timestamp": 1767605061
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/270676-lean4/topic/SafeVerify-passing.20kernel.20soundness.20exploit/near/566271294\">said</a>:</p>\n<blockquote>\n<p>you can use whatever functions you want in the implementation of a tactic (even <code>unsafe</code> functions!), and it will not cause any problems as long as the proof terms outputted by the tactic don't contain the bad functions</p>\n</blockquote>\n<p>But if we allow unsafe, this allows exactly the kind of examples given by <span class=\"user-mention\" data-user-id=\"904624\">@James E Hanson</span>, which can easily be packaged into a tactic. Then how can we tell if the resulting proof terms are not corrupted? Either (a) the kernel accepting such a proof is a bug in Lean, and needs to be fixed; or (b) this is beyond the kernel's responsibility.</p>",
        "id": 566309645,
        "sender_full_name": "GasStationManager",
        "timestamp": 1767605866
    },
    {
        "content": "<blockquote>\n<p>But how do you define well-formed vs malformed?</p>\n</blockquote>\n<p>I think that's quite easy: Built from the constructors of the safe Lean language. Which is essentially the invariant that recovering lean4export output through a safe Lean program ensures. After all the kernel already assumes this anyway. For example it expects that the hash code stored in an <code>Expr</code> node is in fact the real hash code for this node. The equality check will do judgements based on this value <a href=\"https://github.com/leanprover/lean4/blob/master/src/kernel/expr_eq_fn.cpp#L57\">https://github.com/leanprover/lean4/blob/master/src/kernel/expr_eq_fn.cpp#L57</a>. I am almost willing to bet that someone here can build a handcrafted Expr with a custom hash code (or other computed field) that does something funny.</p>\n<blockquote>\n<p>The threat model here is not very clear to me. The AI companies care about some lean proof being gamed, but is it the case for anyone else? Why should I care?</p>\n</blockquote>\n<p>This particular threat model is for example intended for people that run automated competitions etc. on a blockchain. More generally speaking though it's of course also a bit of a marketing thing in the end. Comparator is supposed to be the ultimate official judge <span aria-label=\"tm\" class=\"emoji emoji-2122\" role=\"img\" title=\"tm\">:tm:</span> that you cannot trick unless you actually find a bug in the kernel when its invariants are upheld. On the larger scale it is not feasible for us to go and correct people on the internet that do cheap tricks every time. So we built a software to do that.</p>\n<blockquote>\n<p>My threat model w.r.t lean is more about the security of my own device so I am much more concerned about the fact that to really read a proof you need to run it in interactive mode where another person's code could backdoor you. The entire community is vulnerable to this, meaning that watering hole attacks against e.g. reviewers with commit access to mathlib whose code I do run means I am also vulnerable to this even if I don't run untrusted code. We could sandbox lean to disallow access to network system calls but this would probably break some functionality I haven't thought of. <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> (sandboxes are also not perfect, but for how small our community is I imagine this would be a sufficient step for quite a while.)</p>\n</blockquote>\n<p>Very fair! Fortunately Comparator also has got you covered here as it tries to limit the read and write access to the environment you have <a href=\"https://github.com/leanprover/comparator/blob/master/Main.lean#L44-L46\">https://github.com/leanprover/comparator/blob/master/Main.lean#L44-L46</a>. I will agree this is very rough granular and if people are willing to figure out a better set of permissions I'd be more than happy to merge that. However this current set of permissions does already block any kind of network access. So I guess the worst thing they can do is read from somewhere in your system and then write that somewhere? I'm a bit concerned about the fact that we currently allow read and write access to <code>/dev</code> given the  various kinds of things you can do in that file system by just writing. Might be of interest to figure out a smaller set of permissions here.</p>\n<p>This approach could of course also be adapted to your more general Lean processes if you are sufficiently scared and I think e.g. Joachim has done that or something like it on his machine?</p>\n<p>More generally speaking Comparator is designed in this style that you see in daemons done by the OpenBSD community where you try to separate out processes and privdrop as much as possible in order to gain some defense in depth. If you have more ideas for what we could separate or privdrop I'd be more than happy to hear that! One thing I had in mind is that I would actually like to fork the lean4replay in a separate process as well but unfortunately our way of ref counting makes this sort of thing kind of difficult. That said, e.g. the nanoda support that will eventually come in the future is going to run in a separate, even harsher privdropped process.</p>",
        "id": 566320412,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1767609136
    },
    {
        "content": "<blockquote>\n<p>But if we allow unsafe, this allows exactly the kind of examples given by @James E Hanson, which can easily be packaged into a tactic. Then how can we tell if the resulting proof terms are not corrupted? Either (a) the kernel accepting such a proof is a bug in Lean, and needs to be fixed; or (b) this is beyond the kernel's responsibility.</p>\n</blockquote>\n<p>You should view the Lean program as you use it on a daily basis as essentially a fast path for Lean that assumes its user is kind and well intended and can thus cut lots of corners to make your experience fast. Which is to say the kernel simply assumes its invariant of \"everything is built from constructors\" and as long as you uphold that invariant everything is nice and fast. Once you do not have that assumption anymore and you are dealing with an adversarial user we know that it has severe issues and we know these issues are systemic and likely unfixable or very hard to fix. This is precisely where checkers come into play.</p>\n<p>Note that this is almost certainly not unique to Lean, I for example suspect that with enough hackery on the object representation of things in the Rocq kernel you will be able to pull off similar exploits. Just like our kernel, the Rocq kernel does of course assume that its objects are built using the constructors (after all its an OCaml program, why would they not be!) and it can likely be tricked into doing interesting things by fiddling with that assumption.</p>",
        "id": 566322531,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1767609860
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/270676-lean4/topic/SafeVerify-passing.20kernel.20soundness.20exploit/near/566320412\">said</a>:</p>\n<blockquote>\n<p>On the larger scale it is not feasible for us to go and correct people on the internet that do cheap tricks every time.</p>\n</blockquote>\n<p>Yeah I think this model just doesn't speak to me (or I expect the average formalizer.) Blockchain-anything isn't happening and there are plenty of people having AI delusions that will not be convinced by anything anyway.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/270676-lean4/topic/SafeVerify-passing.20kernel.20soundness.20exploit/near/566320412\">said</a>:</p>\n<blockquote>\n<p>So I guess the worst thing they can do is read from somewhere in your system and then write that somewhere?</p>\n</blockquote>\n<p>I mean this can be bad (e.g. plenty of auto-scanning daemons exist like anti-virus software that are notoriously buggy that could be used to move laterally), but is generally fine. The actual worst thing is they have a kernel 0day in the limited system functionality exposed to them, but I am very happy to reduce the problem of compromising me to having to exploit real bugs. That is anyways the case with my browser and all of my other network-connected software.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/270676-lean4/topic/SafeVerify-passing.20kernel.20soundness.20exploit/near/566320412\">said</a>:</p>\n<blockquote>\n<p>This approach could of course also be adapted to your more general Lean processes if you are sufficiently scared and I think e.g. Joachim has done that or something like it on his machine?</p>\n</blockquote>\n<p>I could go out of my way to do this, but without security-by-default it's still problematic because I am vulnerable to watering hole attacks on any number of other people in the ecosystem that are just doing the default (e.g. nothing.)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/270676-lean4/topic/SafeVerify-passing.20kernel.20soundness.20exploit/near/566320412\">said</a>:</p>\n<blockquote>\n<p>If you have more ideas for what we could separate or privdrop I'd be more than happy to hear that!</p>\n</blockquote>\n<p>I'm not familiar with <code>landrun</code> but assuming it is using kernel-level system call filtering then that is the gold standard for sandboxing. Now I'd just like the equivalent functionality to be integrated into VSCode.</p>",
        "id": 566329868,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1767612101
    },
    {
        "content": "<blockquote>\n<p>Blockchain-anything isn't happening</p>\n</blockquote>\n<p>Well people have already done it with e.g. <a href=\"https://theorem-marketplace.com/\">https://theorem-marketplace.com/</a> though with miniscule amounts of money I agree.</p>\n<blockquote>\n<p>there are plenty of people having AI delusions that will not be convinced by anything anyway.</p>\n</blockquote>\n<p>That is true, still when people post things like the above on twitter and claim that Lean is deeply flawed or w/e it is helpful to have a judge like this around that cannot be fooled. The marketing here is not directed towards the crazy people but to ensure to the larger audience that indeed if you need to be sure you can be sure. It should be possible to verify with the highest amount of certainty that a non trivial result in Lean is indeed correct in the theoretical definition of correct.</p>\n<blockquote>\n<p>I'm not familiar with <code>landrun</code> but assuming it is using kernel-level system call filtering then that is the gold standard for sandboxing.</p>\n</blockquote>\n<p>yes</p>\n<blockquote>\n<p>Now I'd just like the equivalent functionality to be integrated into VSCode.</p>\n</blockquote>\n<p>I think this is something that might end up happening in the longer term future. Doing this for a full  VSCode setup in a way that works cross platform is of course quite a lot more engineering effort compared to \"we want to run these specific actions on a Linux machine\"</p>",
        "id": 566333880,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1767613451
    },
    {
        "content": "<blockquote>\n<p>though with miniscule amounts of money I agree.</p>\n</blockquote>\n<p>It's actually on playmoney right now (Sepolia ether) specifically because I wasn't confident it was robust, and thought the community might want to play around with it and see how that goes without touching actual finances that might be lost to vulnerabilities. (I considered moving it to actual money If I saw it was of use to anyone, but right now I think it was more of a toy.)</p>",
        "id": 566334622,
        "sender_full_name": "Vadim Fomin",
        "timestamp": 1767613722
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/270676-lean4/topic/SafeVerify-passing.20kernel.20soundness.20exploit/near/566260288\">said</a>:</p>\n<blockquote>\n<p>It's a valid proof in the same sense that <a href=\"https://en.wikipedia.org/wiki/MissingNo.\">missingno</a> is a real pokemon.</p>\n</blockquote>\n<p>At least, in case of Pokémon, a team containing MissingNo will be automatically rejected from an official tournament. Similarly, it would be nice to get all proofs containing the exploit automatically rejected by a software, so that people don't have to check proofs for the exploit manually.</p>",
        "id": 566336784,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1767614452
    },
    {
        "content": "<p>Martin, that software already exists. It is being discussed in this very thread.</p>",
        "id": 566348973,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1767618354
    }
]