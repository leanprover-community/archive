[
    {
        "content": "<p>Consider the following toy language, with a proof that the evaluation is deterministic.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Expr</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span>\n  <span class=\"bp\">|</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span>\n  <span class=\"bp\">|</span> <span class=\"n\">union</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span>\n\n<span class=\"kd\">mutual</span>\n  <span class=\"kd\">inductive</span> <span class=\"n\">EvalAdd</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">EvalAdd</span> <span class=\"o\">[]</span> <span class=\"n\">e</span> <span class=\"o\">[]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">xsc</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n           <span class=\"o\">(</span><span class=\"n\">h_eval</span> <span class=\"o\">:</span> <span class=\"n\">Eval</span> <span class=\"n\">e</span> <span class=\"n\">xsc</span><span class=\"o\">)</span>\n           <span class=\"o\">(</span><span class=\"n\">h_rest</span> <span class=\"o\">:</span> <span class=\"n\">EvalAdd</span> <span class=\"n\">xs</span> <span class=\"n\">e</span> <span class=\"n\">xsr</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n           <span class=\"n\">EvalAdd</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">xsc.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"n\">xsr</span><span class=\"o\">)</span>\n\n  <span class=\"kd\">inductive</span> <span class=\"n\">Eval</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">Eval</span> <span class=\"n\">Expr.one</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Eval</span> <span class=\"n\">e₁</span> <span class=\"n\">xs₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">EvalAdd</span> <span class=\"n\">xs₁</span> <span class=\"n\">e₂</span> <span class=\"n\">xr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eval</span> <span class=\"o\">(</span><span class=\"n\">Expr.add</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"n\">xr</span>\n    <span class=\"bp\">|</span> <span class=\"n\">union</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">Eval</span> <span class=\"n\">e₁</span> <span class=\"n\">xs₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">Eval</span> <span class=\"n\">e₂</span> <span class=\"n\">xs₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eval</span> <span class=\"o\">(</span><span class=\"n\">Expr.union</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs₁</span> <span class=\"bp\">++</span> <span class=\"n\">xs₂</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">mutual</span>\n  <span class=\"kd\">theorem</span> <span class=\"n\">EvalAdd_deterministic</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">EvalAdd</span> <span class=\"n\">xs</span> <span class=\"n\">e</span> <span class=\"n\">xsr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">EvalAdd</span> <span class=\"n\">xs</span> <span class=\"n\">e</span> <span class=\"n\">xsr'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">xsr</span> <span class=\"bp\">=</span> <span class=\"n\">xsr'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">induction</span> <span class=\"n\">xs</span> <span class=\"n\">generalizing</span> <span class=\"n\">xsr</span> <span class=\"n\">xsr'</span>\n    <span class=\"n\">case</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h'</span>\n      <span class=\"n\">simp</span>\n    <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h</span>\n      <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">h_eval₁</span> <span class=\"n\">h_rest₁</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">cases</span> <span class=\"n\">h'</span>\n        <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">h_eval₂</span> <span class=\"n\">h_rest₂</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"n\">cases</span> <span class=\"n\">ih</span> <span class=\"n\">h_rest₁</span> <span class=\"n\">h_rest₂</span>\n          <span class=\"n\">cases</span> <span class=\"n\">Eval_deterministic</span> <span class=\"n\">h_eval₁</span> <span class=\"n\">h_eval₂</span>\n          <span class=\"n\">simp</span>\n\n  <span class=\"kd\">theorem</span> <span class=\"n\">Eval_deterministic</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Eval</span> <span class=\"n\">e</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">Eval</span> <span class=\"n\">e</span> <span class=\"n\">xs'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">xs</span> <span class=\"bp\">=</span> <span class=\"n\">xs'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">induction</span> <span class=\"n\">e</span> <span class=\"n\">generalizing</span> <span class=\"n\">xs</span> <span class=\"n\">xs'</span>\n    <span class=\"n\">case</span> <span class=\"n\">one</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h'</span>\n      <span class=\"n\">simp</span>\n    <span class=\"n\">case</span> <span class=\"n\">union</span> <span class=\"n\">ih₁</span> <span class=\"n\">ih₂</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h</span>\n      <span class=\"n\">case</span> <span class=\"n\">union</span> <span class=\"n\">h_left₁</span> <span class=\"n\">h_right₁</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">cases</span> <span class=\"n\">h'</span>\n        <span class=\"n\">case</span> <span class=\"n\">union</span> <span class=\"n\">h_left₂</span> <span class=\"n\">h_right₂</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"n\">cases</span> <span class=\"n\">ih₁</span> <span class=\"n\">h_left₁</span> <span class=\"n\">h_left₂</span>\n          <span class=\"n\">cases</span> <span class=\"n\">ih₂</span> <span class=\"n\">h_right₁</span> <span class=\"n\">h_right₂</span>\n          <span class=\"n\">simp</span>\n    <span class=\"n\">case</span> <span class=\"n\">add</span> <span class=\"n\">e_left</span> <span class=\"n\">e_right</span> <span class=\"n\">ih₁</span> <span class=\"n\">ih₂</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h</span>\n      <span class=\"n\">case</span> <span class=\"n\">add</span> <span class=\"n\">h_left₁</span> <span class=\"n\">h_right₁</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">cases</span> <span class=\"n\">h'</span>\n        <span class=\"n\">case</span> <span class=\"n\">add</span> <span class=\"n\">h_left₂</span> <span class=\"n\">h_right₂</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">sizeOf</span> <span class=\"n\">e_right</span> <span class=\"bp\">&lt;</span> <span class=\"n\">sizeOf</span> <span class=\"o\">(</span><span class=\"n\">Expr.add</span> <span class=\"n\">e_left</span> <span class=\"n\">e_right</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp_arith</span>\n          <span class=\"n\">cases</span> <span class=\"n\">ih₁</span> <span class=\"n\">h_left₁</span> <span class=\"n\">h_left₂</span>\n          <span class=\"n\">cases</span> <span class=\"n\">EvalAdd_deterministic</span> <span class=\"n\">h_right₁</span> <span class=\"n\">h_right₂</span>\n          <span class=\"n\">simp</span>\n<span class=\"kd\">end</span>\n<span class=\"n\">termination_by</span>\n  <span class=\"n\">EvalAdd_deterministic</span> <span class=\"n\">xs</span> <span class=\"n\">e</span> <span class=\"n\">xsr</span> <span class=\"n\">xsr'</span> <span class=\"n\">h</span> <span class=\"n\">h'</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">sizeOf</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">sizeOf</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n  <span class=\"n\">Eval_deterministic</span> <span class=\"n\">e</span> <span class=\"n\">xs</span> <span class=\"n\">xs'</span> <span class=\"n\">h</span> <span class=\"n\">h'</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">sizeOf</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I believe that I specified a sensible <code>termination_by</code> clause, but Lean is unable to prove that the call <code>EvalAdd_deterministic h_right₁ h_right₂</code> is decreasing somehow, even with the hint that <code>sizeOf e_right &lt; sizeOf (Expr.add e_left e_right)</code>. From the proof context, it appears that Lean doesn't know that <code>e = Expr.add e_left e_right</code> after induction? How can I fix the issue?</p>",
        "id": 339739356,
        "sender_full_name": "Sorawee Porncharoenwase",
        "timestamp": 1678046173
    },
    {
        "content": "<p>I can fix the problem by switching from <code>induction</code> to an explicit recursion, though I really don't want to do that if possible.</p>\n<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Expr</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span>\n  <span class=\"bp\">|</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span>\n  <span class=\"bp\">|</span> <span class=\"n\">union</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span>\n\n<span class=\"kd\">mutual</span>\n  <span class=\"kd\">inductive</span> <span class=\"n\">EvalAdd</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">EvalAdd</span> <span class=\"o\">[]</span> <span class=\"n\">e</span> <span class=\"o\">[]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">xsc</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n           <span class=\"o\">(</span><span class=\"n\">h_eval</span> <span class=\"o\">:</span> <span class=\"n\">Eval</span> <span class=\"n\">e</span> <span class=\"n\">xsc</span><span class=\"o\">)</span>\n           <span class=\"o\">(</span><span class=\"n\">h_rest</span> <span class=\"o\">:</span> <span class=\"n\">EvalAdd</span> <span class=\"n\">xs</span> <span class=\"n\">e</span> <span class=\"n\">xsr</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n           <span class=\"n\">EvalAdd</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">xsc.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"n\">xsr</span><span class=\"o\">)</span>\n\n  <span class=\"kd\">inductive</span> <span class=\"n\">Eval</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">Eval</span> <span class=\"n\">Expr.one</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Eval</span> <span class=\"n\">e₁</span> <span class=\"n\">xs₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">EvalAdd</span> <span class=\"n\">xs₁</span> <span class=\"n\">e₂</span> <span class=\"n\">xr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eval</span> <span class=\"o\">(</span><span class=\"n\">Expr.add</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"n\">xr</span>\n    <span class=\"bp\">|</span> <span class=\"n\">union</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">Eval</span> <span class=\"n\">e₁</span> <span class=\"n\">xs₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">Eval</span> <span class=\"n\">e₂</span> <span class=\"n\">xs₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eval</span> <span class=\"o\">(</span><span class=\"n\">Expr.union</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs₁</span> <span class=\"bp\">++</span> <span class=\"n\">xs₂</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">mutual</span>\n  <span class=\"kd\">theorem</span> <span class=\"n\">EvalAdd_deterministic</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xsr</span> <span class=\"n\">xsr'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">EvalAdd</span> <span class=\"n\">xs</span> <span class=\"n\">e</span> <span class=\"n\">xsr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">EvalAdd</span> <span class=\"n\">xs</span> <span class=\"n\">e</span> <span class=\"n\">xsr'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">xsr</span> <span class=\"bp\">=</span> <span class=\"n\">xsr'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">match</span> <span class=\"n\">xs</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">List.nil</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h'</span>\n      <span class=\"n\">simp</span>\n    <span class=\"bp\">|</span> <span class=\"n\">List.cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h</span>\n      <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">xsr₁</span> <span class=\"n\">xsc₁</span> <span class=\"n\">h_eval₁</span> <span class=\"n\">h_rest₁</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">cases</span> <span class=\"n\">h'</span>\n        <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">xsr₂</span> <span class=\"n\">xsc₂</span> <span class=\"n\">h_eval₂</span> <span class=\"n\">h_rest₂</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"n\">cases</span> <span class=\"n\">EvalAdd_deterministic</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h_rest₁</span> <span class=\"n\">h_rest₂</span>\n          <span class=\"n\">cases</span> <span class=\"n\">Eval_deterministic</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h_eval₁</span> <span class=\"n\">h_eval₂</span>\n          <span class=\"n\">simp</span>\n\n  <span class=\"kd\">theorem</span> <span class=\"n\">Eval_deterministic</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"n\">xs'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Eval</span> <span class=\"n\">e</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">Eval</span> <span class=\"n\">e</span> <span class=\"n\">xs'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">xs</span> <span class=\"bp\">=</span> <span class=\"n\">xs'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Expr.one</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h'</span>\n      <span class=\"n\">simp</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Expr.union</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h</span>\n      <span class=\"n\">case</span> <span class=\"n\">union</span> <span class=\"n\">h_left₁</span> <span class=\"n\">h_right₁</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">cases</span> <span class=\"n\">h'</span>\n        <span class=\"n\">case</span> <span class=\"n\">union</span> <span class=\"n\">h_left₂</span> <span class=\"n\">h_right₂</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"n\">cases</span> <span class=\"n\">Eval_deterministic</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h_left₁</span> <span class=\"n\">h_left₂</span>\n          <span class=\"n\">cases</span> <span class=\"n\">Eval_deterministic</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h_right₁</span> <span class=\"n\">h_right₂</span>\n          <span class=\"n\">simp</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Expr.add</span> <span class=\"n\">e_left</span> <span class=\"n\">e_right</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h</span>\n      <span class=\"n\">case</span> <span class=\"n\">add</span> <span class=\"n\">h_left₁</span> <span class=\"n\">h_right₁</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">cases</span> <span class=\"n\">h'</span>\n        <span class=\"n\">case</span> <span class=\"n\">add</span> <span class=\"n\">h_left₂</span> <span class=\"n\">h_right₂</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"n\">cases</span> <span class=\"n\">Eval_deterministic</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h_left₁</span> <span class=\"n\">h_left₂</span>\n          <span class=\"n\">cases</span> <span class=\"n\">EvalAdd_deterministic</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h_right₁</span> <span class=\"n\">h_right₂</span>\n          <span class=\"n\">simp</span>\n<span class=\"kd\">end</span>\n<span class=\"n\">termination_by</span>\n  <span class=\"n\">EvalAdd_deterministic</span> <span class=\"n\">xs</span> <span class=\"n\">e</span> <span class=\"n\">xsr</span> <span class=\"n\">xsr'</span> <span class=\"n\">h</span> <span class=\"n\">h'</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n  <span class=\"n\">Eval_deterministic</span> <span class=\"n\">e</span> <span class=\"n\">xs</span> <span class=\"n\">xs'</span> <span class=\"n\">h</span> <span class=\"n\">h'</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"o\">[])</span>\n</code></pre></div>",
        "id": 339752314,
        "sender_full_name": "Sorawee Porncharoenwase",
        "timestamp": 1678056458
    },
    {
        "content": "<p>Hey Sorawee. The current support for mutual induction is lacking, but you can define your own mutual induction principle in order to prove both theorems inside a single tactic block without any syntactic recursion.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">EvalAdd_Eval.ind</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">m1</span> <span class=\"n\">m2</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">nil</span> <span class=\"n\">cons</span> <span class=\"n\">one</span> <span class=\"n\">add</span> <span class=\"n\">union</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">And.intro</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">@</span><span class=\"n\">EvalAdd.rec</span> <span class=\"n\">m1</span> <span class=\"n\">m2</span> <span class=\"n\">nil</span> <span class=\"n\">cons</span> <span class=\"n\">one</span> <span class=\"n\">add</span> <span class=\"n\">union</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">@</span><span class=\"n\">Eval.rec</span> <span class=\"n\">m1</span> <span class=\"n\">m2</span> <span class=\"n\">nil</span> <span class=\"n\">cons</span> <span class=\"n\">one</span> <span class=\"n\">add</span> <span class=\"n\">union</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">EvalAdd_Eval_deterministic</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"n\">e</span> <span class=\"n\">xsr</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">EvalAdd</span> <span class=\"n\">xs</span> <span class=\"n\">e</span> <span class=\"n\">xsr</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">xsr'</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">EvalAdd</span> <span class=\"n\">xs</span> <span class=\"n\">e</span> <span class=\"n\">xsr'</span><span class=\"o\">),</span> <span class=\"n\">xsr</span> <span class=\"bp\">=</span> <span class=\"n\">xsr'</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"n\">xs</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Eval</span> <span class=\"n\">e</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">xs'</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">Eval</span> <span class=\"n\">e</span> <span class=\"n\">xs'</span><span class=\"o\">),</span> <span class=\"n\">xs</span> <span class=\"bp\">=</span> <span class=\"n\">xs'</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">EvalAdd_Eval.ind</span>\n  <span class=\"n\">all_goals</span> <span class=\"n\">intros</span>\n  <span class=\"n\">case</span> <span class=\"n\">nil</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n</code></pre></div>",
        "id": 339814505,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1678094578
    },
    {
        "content": "<p>Ideally <code>induction</code> would do something like that internally</p>",
        "id": 339814677,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1678094634
    },
    {
        "content": "<p>Thank you, Sebastian!</p>",
        "id": 339930461,
        "sender_full_name": "Sorawee Porncharoenwase",
        "timestamp": 1678124560
    },
    {
        "content": "<p>To be honest, the ideal user interface is not clear to me here. Better <code>induction</code> support here would be nice, but it's a pity we lose the auto implicits. It would be more natural to state the two theorems as before but without bodies, and then have a <code>by</code> block for the <code>mutual</code> block itself that does the induction. Which is not something that currently exists.</p>",
        "id": 339933038,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1678125271
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"360581\">Sorawee Porncharoenwase</span> has marked this topic as resolved.</p>",
        "id": 339958966,
        "sender_full_name": "Notification Bot",
        "timestamp": 1678133432
    }
]