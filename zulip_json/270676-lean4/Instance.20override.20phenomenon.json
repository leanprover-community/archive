[
    {
        "content": "<p>So we played around with instances a bit and found:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">high</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sub</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">⟩</span>\n\n<span class=\"c1\">--local instance (priority := high) : HAdd Nat Nat Nat := ⟨fun x y =&gt; Nat.sub x y⟩</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">testit</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- let myAdd : Add Nat := ⟨fun x y =&gt; x - y⟩</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">dsimp</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n</code></pre></div>\n<p>The eval returns 0, but in the have below, dsimp reduces addition with actual <code>Nat.add</code> it seems, despite using the above instance for add, according to <code>pp.all</code>. The theorem raises a bizarre error message. This is reproducible on live.lean. Is this an issue ?</p>",
        "id": 512268620,
        "sender_full_name": "Yves Jäckle",
        "timestamp": 1744708705
    },
    {
        "content": "<p>This is arguably a bug in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.reduceAdd#doc\">docs#Nat.reduceAdd</a> (<code>dsimp only [Nat.reduceAdd]</code> reproduces it)</p>",
        "id": 512280850,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744712102
    },
    {
        "content": "<p>The argument would be that it should be performing defeq matching on the instances, rather than just assuming they are the builtin ones</p>",
        "id": 512280961,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744712143
    },
    {
        "content": "<p>This is <a href=\"https://github.com/leanprover/lean4/pull/7444\">lean4#7444</a> / <a href=\"https://github.com/leanprover/lean4/pull/7557\">lean4#7557</a>.</p>",
        "id": 512290932,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1744715388
    },
    {
        "content": "<p>I'd argue it's slightly different from those issues, which are specifically about a mismatch in the decidability proof. I'd go further and say that this is actually intended behaviour, see for instance the comment here <a href=\"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Lean/Meta/Tactic/Simp/BuiltinSimprocs/Nat.lean#L47\">https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Lean/Meta/Tactic/Simp/BuiltinSimprocs/Nat.lean#L47</a>, which says exactly that if overriding the instances for arithmetic operators as you've done will cause problems.<br>\n(Whether this intended behaviour is the correct one is a different question though; I agree it can be confusing behaviour!)</p>",
        "id": 512308861,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1744720720
    },
    {
        "content": "<p>Ok cool <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span>  Of course, the above has no real use case, it occurred when I tried to explain to someone how instances work.</p>",
        "id": 512484600,
        "sender_full_name": "Yves Jäckle",
        "timestamp": 1744789239
    },
    {
        "content": "<p>I think this intended behavior might be at odds with the intended behavior of \"tactics should fail rather than produce an illegal proof\"</p>",
        "id": 512506359,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744795806
    }
]