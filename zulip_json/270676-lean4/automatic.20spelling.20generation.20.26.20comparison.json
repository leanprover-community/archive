[
    {
        "content": "<p>I've made a tool that automatically can generate the expected spelling of a theorem (according to the naming convention) and compare it with the existing name. The program can find keywords (= name parts that are only contained in the existing names and not in the generated names), count the amount of exactly correct names, names that are a sublist (<code>List.isSublist</code>) of the generated name and names that are a sublist after disregarding keywords. Then it also collects a list of those that are a subset after disregarding keywords and finally a list of everything that didn't fit.<br>\nHere is the code for anyone wondering:<br>\n<a href=\"/user_uploads/3121/zcwrzK_sE3OaT8OIWsxDIKte/Spelling.lean\">Spelling.lean</a><br>\nAnd here is the (current) list of suggested spellings:<br>\n<a href=\"/user_uploads/3121/9ozEJ1iVOav2TcD3j4HeUHkn/suggested_spellings.txt\">suggested_spellings.txt</a><br>\nThe program doesn't completely capture some details of naming which is why there are actually many that don't actually match even with non-keyword subset match.<br>\nBut still it produced some interesting results:</p>\n<ul>\n<li>Of the 15367 total analyzed theorems, 898 match the generated spelling exactly</li>\n<li>Of the remaining, 9489 (the majority!) are a sublist of the generated spelling</li>\n<li>3072 of the remaining are a sublist if you ignore keywords</li>\n<li>446 of the remaining are a subset after ignoring keywords and</li>\n<li>1462 are left without matching the generated spelling</li>\n<li>The most common keywords are: <code>self</code> (693 theorems), <code>left</code> (483), <code>right</code> (471), <code>congr</code> (230), <code>pos</code> (208), <code>forall</code> (157, really a technicality), <code>inj</code> (132), <code>comm</code> (112), <code>def</code> (110), <code>cancel</code> (76), <code>assoc</code> (62), <code>trans</code> (61), <code>distrib</code> (60), <code>nonneg</code> (56), <code>ext</code> (47), <code>nonpos</code> (42), <code>refl</code> (40), <code>fallback</code> (30), <code>apply</code> (27), <code>antisymm</code> (27), <code>symm</code> (23), <code>coe</code> (23), <code>total</code> (18), <code>irrefl</code> (18), <code>asymm</code> (18), <code>fun</code> (17)</li>\n<li>Some keywords that probably shouldn't be: <code>toUISize</code>, <code>uSize8ToBitVec</code>, <code>equivWithCapacity</code>, <code>forin</code>, <code>isValidUInt32</code> (maybe), <code>ofBoolUsing</code>, <code>updateAtKey</code> (internal stuff), <code>bnot</code>, <code>plus</code> (maybe), <code>fixFEq</code>, <code>int8toBitVec</code> (maybe), <code>existsOfSubtype</code>, <code>negOne</code>, <code>mul2</code>, <code>bex</code>, <code>ball</code>, <code>boole</code>, <code>geq</code></li>\n<li>Some incorrect names: <code>Bool.and_not_iff_right_iff_imp</code>, <code>Bool.not_or_iff_left_iff_imp</code>, <code>Bool.or_not_iff_right_iff_imp</code>, <code>Bool.not_and_iff_left_iff_imp</code>, <code>Array.beq_empty_iff</code> + <code>List.nil_beq_iff</code> (<code>eq</code>), <code>Array.elem_cons_self</code> (<code>push</code>), <code>Array.filterMap_eq_nil_iff</code> + other stuff with <code>Array.&lt;...&gt;nil&lt;...&gt;</code> (<code>empty</code>), <code>Array.getD_get?_setIfInBounds</code> (<code>getElem?</code>), <code>BitVec.getLsbD_ge</code> + friends (<code>of_ge</code>), <code>BitVec.getLsbD_rotateLeftAux_of_le</code> (<code>lt</code>), <code>BitVec.lt_of_getLsb?_eq_some</code> + <code>BitVec.getLsb?_ge</code> (<code>getElem?</code>), <code>List.exists_mem_nil</code> (<code>not</code> ...), <code>Vector.toList_empty</code> + <code>Vector.toList_zipWith</code> (<code>toArray</code>), <code>Vector.toList_eq_empty_iff</code> (<code>nil</code>), <code>imp.swap</code> (namespace??), <code>Nat.ge_two_pow_implies_high_bit_true</code>, <code>Nat.ne_zero_implies_bit_true</code></li>\n<li>Names in wrong order: <code>Option.guard_isSome</code>, <code>Option.choice_isSome_iff_nonempty</code>, <code>Option.isSome_filter_of_isSome</code>, <code>Nat.one_isPowerOfTwo</code>, <code>Nat.and_pow_two_sub_one_eq_mod</code> + others (<code>two_pow</code>), <code>List.head?_isSome</code>, <code>Decidable.not_and_iff_or_not_not</code> (<code>not_or_not</code>), <code>List.filter_length_eq_length</code>, <code>String.Pos.zero_addString_byteIdx</code></li>\n</ul>\n<p>There are probably more examples but these are a few that I could find by looking through them for a while.</p>",
        "id": 505760384,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1741983740
    },
    {
        "content": "<p>Just yesterday, I was talking with <span class=\"user-mention\" data-user-id=\"761203\">@Vlad Tsyrklevich</span> at Leaning in's conference dinner that this would be a useful tool. Wow, I'm really excited that this tool exists! Thanks a lot for working on this!</p>",
        "id": 505770987,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1741988228
    },
    {
        "content": "<p>Great work! Ultimately, it would be great if this could become a syntax linter that provides feedback right as you write your declarations.</p>",
        "id": 506048938,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742191474
    },
    {
        "content": "<p>In the short term/in addition, I was thinking that it could be nice to</p>\n<ul>\n<li>extract the logic of \"check a single declaration\"</li>\n<li>add two commands, <code>#suggest_verbose_name</code> (which creates suggestions as it currently does, with the understanding that the naming convention may allow/prefer slightly different names) and <code>#check_declaration_name</code> which verifies that the current name is a subset of the verbose one</li>\n</ul>",
        "id": 506192531,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1742226600
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"873547\">@Robin Arnez</span> Is that something you'd like to work on?</p>",
        "id": 506192631,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1742226614
    },
    {
        "content": "<p>I was also wondering: to run this in mathlib, we presumably need to add lots of <code>recommended_spelling</code>: do we have a list of all notation which needs this? How difficult would it be to generate one?</p>",
        "id": 506193243,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1742226738
    },
    {
        "content": "<p>I might work on this more and yeah, suggesting names and checking them are probably the most important use cases. I'm not really sure if this makes as much sense in mathlib because I'm pretty sure the conventions are a bit different there (e.g. it's called <code>add_right_injective</code> instead of <code>injective_add_right</code>). Regarding <code>recommended_spelling</code>: For most operations it's probably fine to use the lower-case declaration name as a notation name (e.g. we have <code>HasSubset.Subset</code> =&gt; <code>subset</code>). The main problem is the question of how we order the parameters, e.g. take <code>HasSubset.Subset x y</code> which should be spelled <code>x_subset_y</code> instead of <code>subset_x_y</code>, so that's something that would need to be denoted somewhere when necessary. Additionally, a challenge is special spellings, e.g. <code>singleton</code> for <code>[a]</code>. Ultimately, we might also want a more complex algorithm for correctness than just subset or sublist to make sure we allow everything that is okay according to the naming convention (e.g. <code>bitVecToNat</code> instead of <code>toNat</code>).</p>",
        "id": 506213845,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1742231412
    },
    {
        "content": "<p>I would <em>love</em> to have a tool for helping with the mathlib naming convention: this would be great for authors and reviewers alike, and could help to gradually fix the (relatively few) inconsistencies mathlib names have.</p>",
        "id": 506230709,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1742236030
    },
    {
        "content": "<p>If your tool is that or could be tweaked to become such a tool, that's even nicer (no need to duplicate work). My understanding is that core/stdlib naming and mathlib are supposed to be compatible/augmenting each other.</p>",
        "id": 506230956,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1742236092
    },
    {
        "content": "<p>This also looks useful for tactics like <code>to_additive</code> that generate new declarations from old ones! Let's definitely try to get this into mathlib (or batteries maybe?).</p>",
        "id": 506233901,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1742236916
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/270676-lean4/topic/automatic.20spelling.20generation.20.26.20comparison/near/505760384\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Names in wrong order: <code>Option.guard_isSome</code>, <code>Option.choice_isSome_iff_nonempty</code>, <code>Option.isSome_filter_of_isSome</code>, <code>Nat.one_isPowerOfTwo</code>, <code>Nat.and_pow_two_sub_one_eq_mod</code> + others (<code>two_pow</code>), <code>List.head?_isSome</code>, <code>Decidable.not_and_iff_or_not_not</code> (<code>not_or_not</code>), <code>List.filter_length_eq_length</code>, <code>String.Pos.zero_addString_byteIdx</code></li>\n</ul>\n</blockquote>\n<p>These are fixed in <a href=\"https://github.com/leanprover/lean4/pull/7541\">lean#7541</a>.</p>",
        "id": 506313700,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1742268096
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/270676-lean4/topic/automatic.20spelling.20generation.20.26.20comparison/near/505760384\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Some incorrect names: <code>Bool.and_not_iff_right_iff_imp</code>, <code>Bool.not_or_iff_left_iff_imp</code>, <code>Bool.or_not_iff_right_iff_imp</code>, <code>Bool.not_and_iff_left_iff_imp</code>, <code>Array.beq_empty_iff</code> + <code>List.nil_beq_iff</code> (<code>eq</code>), <code>Array.elem_cons_self</code> (<code>push</code>), <code>Array.filterMap_eq_nil_iff</code> + other stuff with <code>Array.&lt;...&gt;nil&lt;...&gt;</code> (<code>empty</code>), <code>Array.getD_get?_setIfInBounds</code> (<code>getElem?</code>), <code>BitVec.getLsbD_ge</code> + friends (<code>of_ge</code>), <code>BitVec.getLsbD_rotateLeftAux_of_le</code> (<code>lt</code>), <code>BitVec.lt_of_getLsb?_eq_some</code> + <code>BitVec.getLsb?_ge</code> (<code>getElem?</code>), <code>List.exists_mem_nil</code> (<code>not</code> ...), <code>Vector.toList_empty</code> + <code>Vector.toList_zipWith</code> (<code>toArray</code>), <code>Vector.toList_eq_empty_iff</code> (<code>nil</code>), <code>imp.swap</code> (namespace??), <code>Nat.ge_two_pow_implies_high_bit_true</code>, <code>Nat.ne_zero_implies_bit_true</code></li>\n</ul>\n</blockquote>\n<p>and these are corrected in <a href=\"https://github.com/leanprover/lean4/pull/7542\">lean#7542</a>.</p>",
        "id": 506317117,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1742269606
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"873547\">@Robin Arnez</span>, I'd really encourage you to keep working on this tool! The list you provided was entirely correct (i.e. everything was incorrect) and I'd happily have either more manual iterations, or access to an automatic tool or linter.</p>",
        "id": 506317217,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1742269667
    },
    {
        "content": "<p>But we wouldn't want to replace <code>Std.DTreeMap.Internal.Impl.toListModel_updateCell</code> with the recommended <code>Std.DTreeMap.Internal.Impl.toListModel_impl_updateCell_eq_filter_compare_fst_beq_gt_toListModel_append_toList_inner_findCell_toListModel_compare_append_filter_compare_fst_beq_lt_toListModel_of_ordered_of_balanced</code>, right?</p>",
        "id": 506321410,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1742271950
    },
    {
        "content": "<p>(I know to use common sense here. I'm saying that the majority 9489 lemmas whose names are pure sublists of the autogenerated name, and perhaps others, don't really need renaming)</p>",
        "id": 506322121,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1742272346
    },
    {
        "content": "<p>It looks like the pattern for refl/symm/trans lemmas isn't in there, eg these from your suggestions list</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Setoid</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">equiv</span>\n<span class=\"n\">Setoid</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">equiv_of_equiv</span>\n<span class=\"n\">Setoid</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">equiv_of_equiv_of_equiv</span>\n</code></pre></div>\n<p>(there's a slight subtlety in that some of these are called comp rather than trans), but <code>trans</code> alone accounts for 20 non-matches</p>",
        "id": 506322363,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1742272558
    },
    {
        "content": "<p><code>trans</code> is treated as a keyword so it doesn't actually show up as an incorrect spelling (e.g. <code>eq_trans</code> is treated as <code>eq</code> which is a subset of <code>eq_of_eq_of_eq</code>, so that's okay). However, that means these are not checked which is an issue on its own.</p>",
        "id": 506515935,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1742312673
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"598052\">Jeremy Tan</span> <a href=\"#narrow/channel/270676-lean4/topic/automatic.20spelling.20generation.20.26.20comparison/near/506321410\">schrieb</a>:</p>\n<blockquote>\n<p>But we wouldn't want to replace <code>Std.DTreeMap.Internal.Impl.toListModel_updateCell</code> with the recommended <code>Std.DTreeMap.Internal.Impl.toListModel_impl_updateCell_eq_filter_compare_fst_beq_gt_toListModel_append_toList_inner_findCell_toListModel_compare_append_filter_compare_fst_beq_lt_toListModel_of_ordered_of_balanced</code>, right?</p>\n</blockquote>\n<p>Yeah, of course not. These should be more treated as suggestions as actual name candidates which is why we check for sublist/subset instead of exactly the same name.</p>",
        "id": 506516981,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1742312910
    },
    {
        "content": "<p>Also I actually made my own PR: <a href=\"https://github.com/leanprover/lean4/pull/7499\">lean4#7499</a></p>",
        "id": 506531228,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1742316549
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/stream/270676-lean4/topic/automatic.20spelling.20generation.20.26.20comparison/near/506531228\">said</a>:</p>\n<blockquote>\n<p>Also I actually made my own PR: <a href=\"https://github.com/leanprover/lean4/pull/7499\">lean4#7499</a></p>\n</blockquote>\n<p>Apologies that I'd missed that. So many PRs. :-)</p>",
        "id": 506591740,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1742336506
    }
]