[
    {
        "content": "<p>I have an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> for something that I find weird. I am trying to understand what<code>constructor</code> is doing here.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">N</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">//</span> <span class=\"n\">n</span> <span class=\"bp\">≥</span> <span class=\"n\">m</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">incr_m</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">constructor</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">incr_m</span>\n</code></pre></div>\n<p>Explanation : <code>N m</code> is the set of natural numbers greater than or equal to <code>m</code>. <code>incr_m</code> is supposed to be something like below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">incr_m</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">case</span> <span class=\"n\">val</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">n.val</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n  <span class=\"n\">case</span> <span class=\"n\">property</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">linarith</span> <span class=\"o\">[</span><span class=\"n\">n.property</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>printing this yields </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">incr_m</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">N</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">N</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">}</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"bp\">↑</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"bp\">↑</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>which is fine.</p>\n<p>But I have been playing around with <code>repeat'</code> in the last few days. In the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> just applying <code>repeat' constructor</code> closed all goals. Then I manually repeated it and in two applications it claimed that all goals were met. So I printed it out</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">incr_m</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">N</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">N</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">}</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Nat.le</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>How did constructor magically infer the function I wanted to compute (incorrectly of course)?</p>",
        "id": 347170390,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1680705991
    },
    {
        "content": "<p>I thought <code>constructor</code> was lean4's equivalent of lean 3's <code>split</code></p>",
        "id": 347170670,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1680706060
    },
    {
        "content": "<p>(your mwe is missing imports)<br>\n<code>constructor</code> is the lean 4 equivalent of the lean 3 tactic <code>constructor</code> which tries all constructors of an inductive type in turn, <code>split</code> on the other hand is a special case of this when the type has only one constructor (e.g. an and statement, where applying this constructor splits the goal into two).<br>\nI think whats happening here is that the definition of le on naturals is an inductive type <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.le#doc\">docs4#Nat.le</a> with two constructors, i.e. lean knows that there are only two ways (possibly chained) to prove a natural is le another.<br>\nThe constructor tactic simply to tries to apply each of these in turn, so it applies <code>apply Nat.le.refl</code> (every natural number is le itself) which unifies the metavariable (the value of the function) with the lower bound, then once that is assigned there is nothing else to prove.<br>\nThis is one reason why people don't use tactics to make defs!<br>\nso your code really does this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n<span class=\"kd\">def</span> <span class=\"n\">N</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">//</span> <span class=\"n\">n</span> <span class=\"bp\">≥</span> <span class=\"n\">m</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">incr_m</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Subtype.mk</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Nat.le.refl</span>\n</code></pre></div>\n<p>btw do you know the tactic <code>show_term</code> its very helpful for unpacking what tactics are doing under the hood (and often easier than reading the source code)</p>",
        "id": 347178875,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1680707645
    },
    {
        "content": "<p>Sorry about the imports. I wrote this inside a large file. About <code>show_term</code> thanks for recommending it. I tried to <a href=\"https://leanprover-community.github.io/mathlib4_docs/search.html?sitesearch=https%3A%2F%2Fleanprover-community.github.io%2Fmathlib4_docs&amp;q=show_terms\">search the docs</a> for it. It doesn't seem to be in the docs</p>",
        "id": 347186254,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1680709103
    },
    {
        "content": "<p>If I understand your explanation correctly, if the goal is a value (rather than a prop), then in tactic mode, there is a risk that it will be filled with the wrong hypothesis. In this case constructor found <code>le.refl</code> and an appropriate filler for the meta variable for the <code>val</code> goal.</p>",
        "id": 347186628,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1680709195
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Std/Tactic/ShowTerm.html\">https://leanprover-community.github.io/mathlib4_docs/Std/Tactic/ShowTerm.html</a></p>",
        "id": 347186937,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1680709261
    },
    {
        "content": "<p>oh right. lean4 naming conventions.</p>",
        "id": 347187357,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1680709342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/How.20does.20constructor.20interact.20with.20inequalities.2E/near/347186628\">said</a>:</p>\n<blockquote>\n<p>If I understand your explanation correctly, if the goal is a value (rather than a prop), then in tactic mode, there is a risk that it will be filled with the wrong hypothesis. In this case constructor found <code>le.refl</code> and an appropriate filler for the meta variable for the <code>val</code> goal.</p>\n</blockquote>\n<p>Yeah the real issue is that tactics are very smart (sometimes) and fill in whatever they can, a goal whose type is a type is no different to most tactics. When proving things it doesn't matter most of the time if a tactic solves a goal in a way you weren't anticipating as any proof is just as good. But with defs/data there may be multiple ways to fill a goal that are distinct</p>",
        "id": 347189053,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1680709700
    }
]