[
    {
        "content": "<p>Currently, typeclass inferences take the form <code>F x -&gt; G x</code>, and this practically means that whenever we want an instance of <code>G x</code>, Lean automatically searches for <code>F x</code>.</p>\n<p>As a result, inference rules need to be \"decreasing\" (i.e. G should be more complex than F), otherwise the performance will have an impact.</p>\n<p>Could we potentially make the typeclass system stronger by adding forward inferences to typeclass searching as well? i.e. in this proposal, we would be able to tag inferences <code>F x -&gt; G x</code> with <code>@[forward]</code>, and this would mean the whenever the current context contains <code>F x</code>, then Lean would automatically infer <code>G x</code>. Then, we can have increasing complexity as well,  and for example we could have the rule <code>[Module R M] -&gt; [AddCommMonoid M]</code>?</p>",
        "id": 524430131,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750159727
    },
    {
        "content": "<p>Note that to be able to meaningfully write down <code>Module R M</code>, there must already be an instance of <code>AddCommMonoid M</code> available.</p>",
        "id": 524430553,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750159870
    },
    {
        "content": "<p>Yes, so my proposal includes restructuring <code>Module R M</code> to include <code>AddCommMonoid M</code>, which we were not able to do because of this exact reason.</p>",
        "id": 524430672,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750159904
    },
    {
        "content": "<p>To be more precise, you are proposing:</p>\n<ul>\n<li>a <code>@[forward_instance]</code> attribute that applies to declarations of the form <code>[F x] -&gt; G x</code>.</li>\n<li>For each global instance of <code>F x</code>, we also add the corresponding global instance <code>G x</code></li>\n<li>For each local instance of <code>F x</code>, we also add the corresponding local instance <code>G x</code></li>\n<li>declarations tagged with <code>@[forward_instance]</code> are not tagged with <code>@[instance]</code>, because this search is now redundant.</li>\n</ul>",
        "id": 524432475,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750160414
    },
    {
        "content": "<p>I think this would be a good idea.</p>\n<p>I would also be <em>very</em> curious to see the performance impact of replacing the <code>@[instance]</code> tag with <code>@[forward_instance]</code> in all instance of the right form. The consequence would be that adding an instance becomes slower, but looking up an instance becomes faster. And of course looking up instances is done much more often than adding instances.</p>",
        "id": 524434469,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750161044
    },
    {
        "content": "<p>Some more points</p>\n<ul>\n<li>\n<p>For an instance of type <code>[F x] -&gt; G x</code> to be in the correct form, we need <code>F x</code> to be a constant applied to only variables. And these variables need to be exactly the arguments that the instance takes. In this way, the forward instances are always applicable without a need for a potentially expensive unification or type class search.<br>\nDoes that sound reasonable?</p>\n</li>\n<li>\n<p>The process of computing the forwards instances from a given instance can give the same result in different forms, e.g. <code>CommGroup -&gt; Group -&gt; Monoid</code> vs <code>CommGroup -&gt; CommMonoid -&gt; Monoid</code>. So we will need to use unification here to avoid an exponential blowup. (Note that this blowup also arises in backwards type class search, which is dealt with properly)<br>\nMaybe this algorithm could also give a warning if it thinks that it found a diamond <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>\n</li>\n</ul>",
        "id": 524445149,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750164472
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> why would you want to refactor the current backward instances CommGroup -&gt; etc. to using forward?</p>",
        "id": 524446023,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750164757
    },
    {
        "content": "<p>I don't want to blow up the forward instances, I think we should use them sparingly</p>",
        "id": 524446211,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750164809
    },
    {
        "content": "<p>I do want to blow up the forwards instances, for improving performance :). The reason why type class search is slow is that the backwards instances have to search through the whole algebra library every time when you ask for an instance of e.g. Add, Sub or Monoid. If we can stop this \"wild goose chase\" from happening, then that would be a big performance win.</p>\n<p>So what would happen is that if you declare that you favourite type is a NormedField, then it would automatically add all the weaker type class instances to the instances discrimination tree, meaning that they can be found much much quicker.</p>",
        "id": 524449264,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750165684
    },
    {
        "content": "<p>I suppose that's how mathematicians work too</p>",
        "id": 524449447,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750165733
    },
    {
        "content": "<p>After thinking a bit more, I think that the forward instance you suggest, <code>[Module R M] -&gt; AddCommMonoid M</code> may be problematic. It works fine if <code>Module R M</code> is directly available in the local context. But if things get more complicated I'm afraid we could get into trouble.</p>\n<p>Imagine that there is some funny global instance <code>[Prime p] -&gt; Module (R p) M</code> that is different for all <code>p</code>. Then if we want to search for <code>AddCommMonoid M</code>, there is no way of knowing which <code>p</code> prime to pick.</p>",
        "id": 524495961,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750180051
    },
    {
        "content": "<p>(This is not an obstacle for the performance improvement I described above. Though I think that would better be named \"shortcut instances\" than \"forward instances\")</p>",
        "id": 524496198,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750180142
    },
    {
        "content": "<p>well, <code>[Prime p] -&gt; Module (R p) M</code> would be a backward instance...</p>",
        "id": 524496564,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750180275
    },
    {
        "content": "<p>I'm not very well-versed in instances, so I'll trust what whatever you think is better is probably better</p>",
        "id": 524496605,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750180291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/270676-lean4/topic/forward.20inference.20in.20typeclass/near/524496564\">said</a>:</p>\n<blockquote>\n<p>well, <code>[Prime p] -&gt; Module (R p) M</code> would be a backward instance...</p>\n</blockquote>\n<p>Exactly, what I'm worried about is that we cannot compose this backwards instance with your forwards instance. Because to find your instance, you need to reason forwards from the <code>Module</code> instance. And to find my instance, you need to reason backwards from the <code>Module</code> instance. So there is to way to get to the point of even considering the <code>Module</code> instance.</p>",
        "id": 524497170,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750180575
    },
    {
        "content": "<p>Could someone provide more examples of \"non-decreasing inferences\" so that we can be more informed?</p>",
        "id": 524497665,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750180832
    },
    {
        "content": "<p>I'll be the first one,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">PrimeSpectrum</span><span class=\"bp\">.</span><span class=\"n\">nontrivial</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSpectrum</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"n\">R</span>\n</code></pre></div>\n<p>is not an instance currently.</p>",
        "id": 524497765,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750180883
    },
    {
        "content": "<p>This is not an instance because PrimeSpectrum isn't a class (I think). So there is no way to infer <code>p</code></p>",
        "id": 524498135,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750181070
    },
    {
        "content": "<p>This is an interesting discussion, but please keep in mind it is extremely unlikely to lead to any modification to Lean in the near future. The core team has already a <em>lot</em> of work, and what you are discussing is a huge modification of a critical core component of Lean.</p>",
        "id": 524585944,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1750190016
    },
    {
        "content": "<p>That makes sense. My hope is though that if this kind of change gives a 50% speedup of type class search in mathlib, they will have to care..</p>",
        "id": 524590498,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750191774
    },
    {
        "content": "<p>Unfortunately the last time we tried to minimise the JacobiZariski problem we were saying \"this is clearly a universe issue\" and Ullrich said \"well what about this issue, here is a speed-up, maybe that's your problem\" (and he was right, it was one of our problems). But since then I have decided that there are several problems with this file and universes is definitely still one of them. The problem is we didn't yet write the correct mathlib-free MWE. It's been on my job list forever but right now there is so much low-hanging fruit in FLT that it might take me forever to get there. But tl;dr I think we need a reliable mathlib-free repro of \"changing universe names makes a substantial difference\".</p>",
        "id": 524591015,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750191953
    },
    {
        "content": "<p>Yes, the universes are another problem. But here I'm talking about typeclass search in general being slower than necessary.</p>\n<p>And I think we can have a much stronger point towards core if we come with a: here is a fix that makes everything faster.</p>",
        "id": 524591358,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750192085
    },
    {
        "content": "<p>(sorry, I think I'm conflating two different threads here)</p>",
        "id": 524593737,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750193188
    },
    {
        "content": "<p>Backward chaining is fairly well understood and has a long history in logic programming. We know how to design our instances in ways that guarantee termination.</p>\n<p>Forward chaining is has been long studied as well, but I'm not sure what the literature is on doing this in the context of typeclass inference. It reminds me of some of the things that show up in SMT solvers, in congruence closure I think.</p>\n<p>I'm not speaking on behalf of the core developers here, but my feeling is that this has entered open-research-problem territory. Maybe with with some papers that prove the concept and develop the theory it might lead to a new typeclass inference system in Lean, but without that I would hesitate making fundamental changes to this system even if there is a proof of concept that shows better performance. Fundamental questions: \"how can forward and backward instances compose in a performant way\", \"how can we design instances that don't cause inference to diverge\", \"how do we design math libraries when we have this tool\", etc.</p>\n<p>Regarding the proposal to add shortcut instances, haven't people found that <em>removing</em> shortcut instances has had positive effects on performance? The issue is that these shortcut instances provide more paths for typeclass inference to consider and then fail on.</p>\n<p>One thing I know that does need to be addressed, and which isn't as big of an open research problem, is how to make sure typeclass inference respects the resolution order (i.e. how to make it prefer earlier parent projections, <a href=\"https://github.com/leanprover/lean4/pull/2325\">lean4#2325</a>), which is important for isDefEq efficiency with the way instances are encoded. I think we could learn something from SageMath here, using some priority system where priorities are put on the classes themselves, rather than just on instances, and then doing a lot of work to try to get mathlib to compile with <code>structure.strictResolutionOrder</code> enabled (if that's possible at all!)</p>",
        "id": 524600607,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750196178
    },
    {
        "content": "<p>Yes, adding more shortcut instances without removing anything from the type class search will in general slow things down. But if we (automatically) add enough shortcut instances that the general instances can be completely ignored, then that would be a win. Here I define a general instance as an instance saying that one class (applied to only free variables) implies another class (applied to the same free variables), e.g. <code>CommGroup α → Group α</code>. So basically when syntesizing <code>Add α</code>, I want to never even get to the goals <code>Ring α</code> and <code>Field α</code>; I want that all the instances for that have shortcut variants that have the conclusion <code>Add ..</code></p>",
        "id": 524604941,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750198715
    },
    {
        "content": "<p>Note that I have an RFC for type class abbrevs, which addresses the <code>Module</code> inconvenience in a different way: <a href=\"https://github.com/leanprover/lean4/pull/8279\">lean#8279</a></p>",
        "id": 524646246,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750232332
    },
    {
        "content": "<p>The idea of having automatic shorcut instances would also obviate the need for PRs such as <a href=\"https://github.com/leanprover-community/mathlib4/pull/25358\">#25358</a> by <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>. I'll try to implement and !bench this when I find the time.</p>",
        "id": 524747219,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750265240
    }
]