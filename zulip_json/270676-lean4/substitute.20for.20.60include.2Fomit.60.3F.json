[
    {
        "content": "<p>In the process of porting a file that used <code>include/omit</code>, I found that it would have been useful to have some form of <code>include/omit</code>.  I ended up creating <code>section</code>s with the appropriate assumptions, but it was a little tedious.</p>\n<p>Below is an example of why this might be wanted.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">one</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span>\n<span class=\"kd\">class</span> <span class=\"n\">two</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">one</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Neg</span> <span class=\"n\">A</span> <span class=\"n\">where</span> <span class=\"n\">neg</span> <span class=\"o\">:=</span> <span class=\"n\">one.h</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">two</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Neg</span> <span class=\"n\">A</span> <span class=\"n\">where</span> <span class=\"n\">neg</span> <span class=\"o\">:=</span> <span class=\"n\">two.h</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">one</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">two</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">one.h</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>  <span class=\"c1\">-- comment `variable [two X]` to toggle which one of these</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">two.h</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>  <span class=\"c1\">-- two examples works and which one fails</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">which_one</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"k\">#check</span> <span class=\"n\">which_one</span><span class=\"bp\">?</span>    <span class=\"c1\">--  Can I control which of `one A` or `two A` is used here?</span>\n                     <span class=\"c1\">--  Is it inevitably the last-defined instance?</span>\n</code></pre></div>\n<p>(For completeness, the PR is <a href=\"https://github.com/leanprover-community/mathlib4/pull/4293\">!4#4293</a>, but it is not easy to single out where the issue above arises.)</p>",
        "id": 361067601,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685022662
    },
    {
        "content": "<p>I think the party line is \"you are not supposed to be in a situation where you need to control that\". You want to control typeclass inference?</p>",
        "id": 361081080,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685025560
    },
    {
        "content": "<p>I would have preferred not to, but there were two different <code>div</code>s in the context and it was hard to get Lean to figure out which one was the correct one, until I <code>section</code>ed it.</p>",
        "id": 361081420,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685025629
    },
    {
        "content": "<p>(At least, I think that this was the issue: what I know is that it got solved by the <code>section</code>.)</p>",
        "id": 361081539,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685025661
    },
    {
        "content": "<p>Anyway, this is a file defining the field of rational functions in one variable: it is quite possible that once the definitions are in, the no-longer-needed <code>omit/include</code> will indeed not be needed!</p>",
        "id": 361081824,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685025729
    },
    {
        "content": "<p>A small update on this issue and a potential warning.</p>\n<p>While Yuri was porting <code>FieldTheory.Laurent</code>, he ran into issues that the typeclass assumptions of some of the lemmas in <code>FieldTheory.RatFunc</code> were not correct.</p>\n<p>I take full responsibility for the mistakes!  The reason that I did not realize this, while the PR was in progress, was that I blindly assumed that Lean would cherry-pick the correct typeclass assumptions that were available in context, just as they were intended to be selected.  Of course, this was overly naïve on my part!</p>\n<p>However, unlike <code>autoImplicit</code>, I do not know how to disable this self-selection of the relevant assumptions (maybe it is in fact impossible).  The warning is: if in mathlib3 you felt inclined to avoid introducing <code>section</code>s and preferred to use <code>include/omit</code>, reconsider using <code>section</code>s in Mathlib4!</p>",
        "id": 362460855,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685540416
    },
    {
        "content": "<p>I think the recommended way to deal with this in Lean 4 is to explicitly include the typeclass arguments in the lemmas in question. But, can you provide an example of one of the offending lemmas? More context is always helpful.</p>",
        "id": 362462474,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1685540779
    },
    {
        "content": "<p>There was another Zulip thread about thisl perhaps it should be linked here</p>",
        "id": 362463271,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685540960
    },
    {
        "content": "<p>Jireh, I tried (and failed) for quite a while to come up with a good example of a theorem with \"fuzzy\" assumptions and where Lean selects an unwanted subset.  Right now, I think that the most solid confirmation is that <a href=\"https://github.com/leanprover-community/mathlib4/pull/4512\">!4#4512</a> fails, since \"somewhere\" in <a href=\"https://github.com/leanprover-community/mathlib4/pull/4293\">!4#4293</a> the wrong typeclass was selected.  The relevant issue is  <a href=\"https://github.com/leanprover-community/mathlib4/issues/4513\">#4513</a>.<br>\n(And the first step towards a solution is, hopefully, <a href=\"https://github.com/leanprover-community/mathlib/pull/19133\">#19133</a>.)</p>",
        "id": 362465079,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685541353
    },
    {
        "content": "<p>Aha, in that case it seems the <code>section</code>ing really is the correct approach.</p>",
        "id": 362465791,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1685541503
    },
    {
        "content": "<p>I would advocate for never having \"fuzzy\" assumptions.</p>",
        "id": 362465943,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1685541536
    },
    {
        "content": "<p>Even from a source code readability standpoint that seems hard to parse.</p>",
        "id": 362466066,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1685541562
    },
    {
        "content": "<p>Jireh, I agree.  In this case, I got lazy and decided to port directly instead of section-in-mathlib3-and-then-port.  I was warning that the fast way might be the one that starts with sectioning!</p>",
        "id": 362466811,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685541709
    },
    {
        "content": "<p>In case people are interested, I decided to write the small tactic <code>prune</code>, similar to the <code>clear...</code> family.</p>\n<p><code>prune</code> clears, very conservatively, all hypotheses that are not \"connected\" to the goal.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.List.Basic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Lean.Elab.Tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Meta</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">revertVarsOnce</span> <span class=\"o\">:</span> <span class=\"n\">TacticM</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">FVarId</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">LocalDecl</span> <span class=\"bp\">×</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">focus</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">ctx</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getLCtx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">decls.toList.reduceOption</span>\n  <span class=\"k\">let</span> <span class=\"n\">gMVar</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span> <span class=\"n\">getMainGoal</span>\n  <span class=\"k\">let</span> <span class=\"n\">goal</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span> <span class=\"n\">getMainTarget</span>\n  <span class=\"k\">let</span> <span class=\"n\">foundDecls</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ctx.map</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">x.toExpr.occurs</span> <span class=\"n\">goal</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"n\">x</span> <span class=\"k\">else</span> <span class=\"n\">none</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">reduceOption</span>\n  <span class=\"k\">let</span> <span class=\"n\">fvarIdFound</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">foundDecls.map</span> <span class=\"n\">Lean.LocalDecl.fvarId</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toArray</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">fvs</span><span class=\"o\">,</span> <span class=\"n\">newGoal</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span> <span class=\"n\">gMVar.revert</span> <span class=\"n\">fvarIdFound</span>\n  <span class=\"n\">setGoals</span> <span class=\"o\">[</span><span class=\"n\">newGoal</span><span class=\"o\">]</span>\n  <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">fvs</span><span class=\"o\">,</span> <span class=\"n\">ctx</span><span class=\"o\">,</span> <span class=\"n\">newGoal</span><span class=\"o\">)</span>\n\n<span class=\"n\">partial</span>\n<span class=\"kd\">def</span> <span class=\"n\">revertLoop</span> <span class=\"o\">:</span> <span class=\"n\">TacticM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">LocalDecl</span> <span class=\"bp\">×</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">focus</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">fvars</span><span class=\"o\">,</span> <span class=\"n\">ctx</span><span class=\"o\">,</span> <span class=\"n\">newGoal</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span> <span class=\"n\">revertVarsOnce</span>\n  <span class=\"k\">if</span> <span class=\"n\">fvars.size</span> <span class=\"bp\">==</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">ctx</span><span class=\"o\">,</span> <span class=\"n\">newGoal</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">revertLoop</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pruneTac</span> <span class=\"o\">:</span> <span class=\"n\">TacticM</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">focus</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">dcls</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getLCtx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">decls.toList.reduceOption</span>\n  <span class=\"n\">dbg_trace</span> <span class=\"n\">dcls.length</span>\n  <span class=\"k\">let</span> <span class=\"n\">goal</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span> <span class=\"n\">getMainGoal</span>\n  <span class=\"k\">let</span> <span class=\"n\">newGoal</span> <span class=\"bp\">←</span> <span class=\"n\">goal.tryClearMany</span> <span class=\"o\">(</span><span class=\"n\">dcls.map</span> <span class=\"n\">LocalDecl.fvarId</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toArray</span>\n  <span class=\"n\">setGoals</span> <span class=\"o\">[</span><span class=\"n\">newGoal</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">nms</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getMainTarget</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getForallBinderNames</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_newfvs</span><span class=\"o\">,</span> <span class=\"n\">rGoal</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span> <span class=\"n\">introNCore</span> <span class=\"n\">newGoal</span> <span class=\"n\">nms.length</span> <span class=\"o\">[]</span> <span class=\"n\">True</span> <span class=\"n\">True</span>\n  <span class=\"n\">setGoals</span> <span class=\"o\">[</span><span class=\"n\">rGoal</span><span class=\"o\">]</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"prune\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span> <span class=\"n\">revertLoop</span>\n  <span class=\"n\">pruneTac</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Lean.Elab.Tactic</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">_d</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">_h</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">≠</span> <span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">5</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">∨</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">prune</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> goal state:</span>\n<span class=\"cm\">  b a: Nat</span>\n<span class=\"cm\">  h₁: a = b</span>\n<span class=\"cm\">  c: Int</span>\n<span class=\"cm\">  ⊢ Int.ofNat a + 5 = c ∨ True</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Or.inr</span> <span class=\"n\">trivial</span>\n\n<span class=\"sd\">/-- Lots of duplication of variables, since they are included *again*! -/</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">_d</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">_h</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">≠</span> <span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">_h₁</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">_c</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">e</span> <span class=\"bp\">∨</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> goal state:</span>\n<span class=\"cm\">  α✝: Type u</span>\n<span class=\"cm\">  inst✝³ inst✝²: Add α✝</span>\n<span class=\"cm\">  e✝ f✝: α✝</span>\n<span class=\"cm\">  a✝ b✝ _d✝: Nat</span>\n<span class=\"cm\">  _h✝: e✝ ≠ f✝</span>\n<span class=\"cm\">  h₁: a✝ = b✝</span>\n<span class=\"cm\">  c: Int</span>\n<span class=\"cm\">  α: Type u</span>\n<span class=\"cm\">  inst✝¹: Add α</span>\n<span class=\"cm\">  inst✝: OfNat α 0</span>\n<span class=\"cm\">  e f: α</span>\n<span class=\"cm\">  a b _d: Nat</span>\n<span class=\"cm\">  _h: e ≠ f</span>\n<span class=\"cm\">  _h₁: a = b</span>\n<span class=\"cm\">  _c: Int</span>\n<span class=\"cm\">  ⊢ e + f = e ∨ True</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">prune</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> goal state:</span>\n<span class=\"cm\">  α: Type u</span>\n<span class=\"cm\">  inst✝¹: Add α</span>\n<span class=\"cm\">  inst✝: OfNat α 0</span>\n<span class=\"cm\">  ef: α</span>\n<span class=\"cm\">  _h: e ≠ f</span>\n<span class=\"cm\">  ⊢ e + f = e ∨ True</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Or.inr</span> <span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 365999741,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686692907
    },
    {
        "content": "<p>I believe the check via <code>goal.find?</code> may miss dependencies when the target contains an mvar. In that case, any fvar in the context of the mvar is a possible dependency of the target. Also, I believe you could use <code>collectFVars</code> instead of looping over the expression multiple times.</p>",
        "id": 366001957,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1686693785
    },
    {
        "content": "<p>Jannis, thank you for the suggestions!  I did not know <code>collectFVars</code> -- I'll look into it!<br>\nWrt metavariables in the target, I had simply thought of applying this tactic in a situation where there were no meta-variables...</p>",
        "id": 366003427,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686694315
    },
    {
        "content": "<p>Still, this highlighted an issue, I think:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  2 goals</span>\n<span class=\"cm\">  case h</span>\n<span class=\"cm\">  a: ℕ</span>\n<span class=\"cm\">  ⊢ ?w = 0</span>\n<span class=\"cm\">  case w</span>\n<span class=\"cm\">  a: ℕ</span>\n<span class=\"cm\">  ⊢ ℕ</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">prune</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  1 goal</span>\n<span class=\"cm\">  case h</span>\n<span class=\"cm\">  a: ℕ</span>\n<span class=\"cm\">  ⊢ ?w = 0</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>\n<p>One goal disappears, since I forgot to get the goals before and then reassign them later, I think.</p>\n<p>However, <code>a</code> remains in context, so this should be fine, right?</p>",
        "id": 366003886,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686694474
    },
    {
        "content": "<p><code>focus</code>ing the two <code>def</code>s fixed the \"disappearing\" goal and is also something that I had intended anyway!</p>\n<p>I will look into <code>collectFVars</code>, but not today, since it is getting late!</p>\n<p>Thank you for your comments, though!</p>",
        "id": 366004288,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686694638
    },
    {
        "content": "<p>I opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/5062\">!4#5062</a>, containing a small modification of the tactic above.</p>\n<p>I ended up preferring to use the recursive approach anyway and gave the option to \"step in\" at any stage of the process.  This gives finer control of how many variables you want to keep: <code>prune 0</code> only keeps the strictly necessary ones, while <code>prune &lt;large&gt;</code> (which is the same as <code>prune</code>), keeps conservatively all hypotheses that are \"recursively visible\" from the main goal.</p>",
        "id": 366326368,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686786271
    }
]