[
    {
        "content": "<p>Hello! After a lengthy disappearance caused by my PhD catching up with me, I've recently updated <a href=\"https://crates.io/crates/lean-sys\"><code>lean-sys</code></a> to version <code>0.3.0</code> to track the latest changes to <code>lean.h</code>. The version bump from <code>0.2.0</code> is due to the breaking change of removing the <code>fixpoint</code> family of functions, as in Lean 4 commit <a href=\"https://github.com/leanprover/lean4/commit/f9f074dbf5a04b755d88f3f63397889c1e8d3677\"><code>f9f074d</code></a>. Hopefully I'll have times to continue my project by publishing some higher-level bindings to Lean, with the end goal of seamless integration between Lean 4 and Rust code, as I'll need for my planned thesis. If anyone has any ideas/feature requests/found bugs/etc, I'd be happy to hear!</p>",
        "id": 309595158,
        "sender_full_name": "Jad Ghalayini",
        "timestamp": 1668431676
    },
    {
        "content": "<p>Hello, is the <a href=\"https://docs.rs/lean-sys/latest/lean_sys/\">Rust crate</a> up to date with Lean v4.16.0?</p>\n<p>Also, is there an example for how to use this crate?</p>",
        "id": 498493016,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1739013345
    },
    {
        "content": "<p>No, I think it hasn't been bumped since around 4.8.0</p>",
        "id": 499952926,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739655880
    },
    {
        "content": "<p>I would really prefer if the FRO took over maintenance of it, no one ever pings me when lean.h changes so it's really difficult to keep it afloat without people using it and relying on it</p>",
        "id": 499952982,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739655939
    },
    {
        "content": "<p>I'm not at all sure how the crate works, but at least for Lean projects I would love if <code>lean-action</code> could produce reminders/automation in some form to bump to the next toolchain.</p>",
        "id": 499953342,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1739656298
    },
    {
        "content": "<p>lean-sys is basically a collection of rust bindings, the FFI partner to lean.h. It needs to be changed whenever anything in lean.h changes, usually to just write the rust version of the type signature, and possibly also the implementation if it's a <code>static inline</code> method</p>",
        "id": 499953422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739656369
    },
    {
        "content": "<p>Mac would be the person to speak to about this, then.</p>\n<p>But at your end, maybe you could add a CI step the periodically tries to build against the latest toolchain or nightly?</p>",
        "id": 499953461,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1739656432
    },
    {
        "content": "<p>I am not sure we have anything which would detect a mismatch</p>",
        "id": 499953510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739656454
    },
    {
        "content": "<p>it will build even if there are changes, it will just segfault if you use the bad functions</p>",
        "id": 499953529,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739656477
    },
    {
        "content": "<p>the only thing I can think of is to just ping a human whenever the text of lean.h changes</p>",
        "id": 499953560,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739656512
    },
    {
        "content": "<p>there do exist automatic tools for building the bindings (bindgen), but I think they don't work well enough to be usable in practice - in particular I think it won't know about the lean ownership encoding with borrowed and owned object pointers (which aren't actually pointers sometimes)</p>",
        "id": 499953671,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739656599
    },
    {
        "content": "<p>so lean-sys is much closer to a manual port</p>",
        "id": 499953682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739656618
    },
    {
        "content": "<p>Thanks, we've taken a different approach. We're mimicking the memory layout of the Lean objects \"manually\". That's pretty much reimplementing <code>lean.h</code> in Rust. But we only need a subset of it.</p>\n<p>As far as detecting changes in <code>lean.h</code> goes, I can provide an idea. Keep a <code>lean-toolchain</code> file in the project specifying the toolchain version <code>lean-sys</code> targets. And also keep a <code>lean.h.hash</code> file containing the hash of the <code>lean.h</code> file. Then, on CI, force that hash to match the hash of <code>lean.h</code> that gets downloaded (based on <code>lean-toolchain</code>). This is probably the way I'm gonna set it up on our end.</p>",
        "id": 499955424,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1739658214
    },
    {
        "content": "<p>I just pushed lean-sys v0.0.8, which is up to date with lean v4.16.0</p>",
        "id": 499960193,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739662977
    },
    {
        "content": "<p>Sharing in case it's useful to someone in the future.<br>\nThis check turns out to be much better as a Lake script (if your project is also a Lake project) because there's already <code>getLeanIncludeDir</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">script</span><span class=\"w\"> </span><span class=\"n\">check_lean_h_hash</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">cachedLeanHHash</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">FS</span><span class=\"bp\">.</span><span class=\"n\">readFile</span><span class=\"w\"> </span><span class=\"s2\">\"lean.h.hash\"</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">leanIncludeDir</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getLeanIncludeDir</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">includedLeanHPath</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">leanIncludeDir</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"s2\">\"lean\"</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"s2\">\"lean.h\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">includedLeanHBytes</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">FS</span><span class=\"bp\">.</span><span class=\"n\">readBinFile</span><span class=\"w\"> </span><span class=\"n\">includedLeanHPath</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">includedLeanHHash</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">includedLeanHBytes</span><span class=\"bp\">.</span><span class=\"n\">hash</span>\n\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">cachedLeanHHash</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">includedLeanHHash</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">eprintln</span><span class=\"w\">   </span><span class=\"s2\">\"Mismatching lean/lean.h hash\"</span>\n<span class=\"w\">    </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">eprintln</span><span class=\"w\">   </span><span class=\"s2\">\"  1. Double-check changes made to lean/lean.h\"</span>\n<span class=\"w\">    </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">eprintln</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"  2. Cache {includedLeanHHash} instead\"</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>Then run <code>check_lean_h_hash</code> on CI</p>",
        "id": 500168779,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1739794549
    }
]