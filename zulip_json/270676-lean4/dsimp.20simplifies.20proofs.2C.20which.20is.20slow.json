[
    {
        "content": "<p>I was investigating some slowness of <code>simp</code>, and I found out that <code>dsimp</code>, unlike <code>simp</code>, simplifies proof terms. <code>simp</code> is very smart about handling proof terms: in some situations it simplifies the type of the proof term, and wraps the proof term in a <code>cast</code>.</p>\n<p>On the other hand, <code>dsimp</code> does traverse proofs, which (particularly for Category Theory) causes significant slowdowns. It would be much better if <code>dsimp</code> did either of</p>\n<ul>\n<li>leave proofs as-is, without simplification</li>\n<li>simplify the type of the proof and wrap the proof in a <code>cast</code> so that it gets the new type.</li>\n</ul>\n<p>The performance issue is still present in <code>simp</code>, because  <code>simp</code> relies on <code>dsimp</code> for dependent arguments.</p>",
        "id": 497950830,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1738777848
    },
    {
        "content": "<p>I think that the 1.4% speedup of Mathlib in <a href=\"https://github.com/leanprover-community/mathlib4/pull/21330\">#21330</a> can be (maybe partially) explained by this problem.</p>",
        "id": 497951000,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1738777904
    },
    {
        "content": "<p>If we do leave proofs as is, I think there should be a config option that allows requesting proof simplification; as I understand it there are cases where it does matter.</p>",
        "id": 497953232,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738778614
    },
    {
        "content": "<p>Then the second option would be the best one I think.</p>",
        "id": 497953448,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1738778685
    },
    {
        "content": "<p>I'd <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> if this were an RFC (and someone linked to it)</p>",
        "id": 497954488,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1738779039
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/6960\">lean#6960</a></p>",
        "id": 497978364,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1738787731
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/6960\">lean4#6960</a></p>",
        "id": 497978505,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1738787794
    },
    {
        "content": "<p>My result is that with only a few modifications in Mathlib, disabling <code>dsimp</code> in proofs gives a speedup of 0.83% in Mathlib. (<a href=\"https://github.com/leanprover-community/mathlib4/pull/21519#issuecomment-2655534838\">https://github.com/leanprover-community/mathlib4/pull/21519#issuecomment-2655534838</a>)</p>\n<p>This is great, but there are also some slowdowns. Looking more closely into this, I found that the simp lemma <code>CategoryTheory.LiftRightAdjoint.constructRightAdjointEquiv_symm_apply</code>, which is generated by <code>simps!</code>, has a RHS that contains a big proof term. This proof term would have been smaller if <code>dsimp</code> (which is called by <code>simp!</code>) had simplified it. And <code>rw</code> has the same issue as <code>dsimp</code> of trying to rewrite proof terms, causing the slowdown.</p>\n<p>So this slowdown could be solved by either of</p>\n<ul>\n<li>Not allowing <code>rw</code> to rewrite proofs. Although <code>rw</code> doesn't instantiate bound variables, we can still check for most proofs using <code>Lean.Meta.isProofQuick</code>.</li>\n<li>Expand the function <code>Lean.Elab.abstractNestedProofs</code> so that it also abstracts nested proofs inside the type of a definition, not just inside the value.</li>\n</ul>\n<p>Of course these can come with <code>set_option</code>s to turn them off in the very rare case that you do want to rewrite a proof.</p>",
        "id": 501108762,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740145607
    },
    {
        "content": "<p>Interestingly, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RelSeries.ext#doc\">docs#RelSeries.ext</a> has a proof that genuinely needs to simplify a proof, because it eliminates some variable x from appearing on the RHS of <code>h : x = _</code>, followed by <code>subst h</code>.</p>",
        "id": 501109669,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740145872
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/270676-lean4/topic/dsimp.20simplifies.20proofs.2C.20which.20is.20slow/near/501109669\">said</a>:</p>\n<blockquote>\n<p>Interestingly, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RelSeries.ext#doc\">docs#RelSeries.ext</a> has a proof that genuinely needs to simplify a proof, because it eliminates some variable x from appearing on the RHS of <code>h : x = _</code>, followed by <code>subst h</code>.</p>\n</blockquote>\n<p>This sounds like simplification of the type of a proof, not of the proof itself. It would be great to distill an example of proof-rewrites-which-matter down to a mathlib-free example, but that's obviously a rather big ask.</p>",
        "id": 501145085,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740156323
    },
    {
        "content": "<p>Yes, but the simplification happens inside of a proof term</p>",
        "id": 501146064,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740156624
    },
    {
        "content": "<p>I'm wondering if <code>generalize_proofs</code> would help here, which is often the answer where there's a dependence in a proof.</p>",
        "id": 501146073,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740156626
    },
    {
        "content": "<p>Oh, interesting, in <code>RelSeries.ext</code>, the <code>dsimp</code> is causing the type of the proof to change.</p>",
        "id": 501146512,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740156783
    },
    {
        "content": "<p><code>dsimp</code> isn't necessary, and neither is a fancy tactic like <code>generalize_proofs</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">iff</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RelSeries</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">length_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">toFun_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">length_eq</span><span class=\"o\">]))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">nx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fx</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">length_eq</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">toFun_eq</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Somehow <code>cases</code> is working better than <code>subst</code> here.</p>",
        "id": 501147021,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740156958
    },
    {
        "content": "<p>with that, I get the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">dependent</span><span class=\"w\"> </span><span class=\"n\">elimination</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">solve</span><span class=\"w\"> </span><span class=\"n\">equation</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"bp\">⋯</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">fx</span>\n</code></pre></div>",
        "id": 501147787,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740157193
    },
    {
        "content": "<p>You're right. There's a bug where that error is now showing up on <code>by</code> and I didn't notice. Sorry.</p>",
        "id": 501149012,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740157593
    },
    {
        "content": "<p>This one works, and it looks like <code>dsimp</code> isn't simplifying proofs (unverified though).</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">iff</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RelSeries</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">length_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">toFun_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">length_eq</span><span class=\"o\">]))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">nx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fx</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">length_eq</span>\n<span class=\"w\">  </span><span class=\"n\">generalize_proofs</span><span class=\"w\"> </span><span class=\"n\">pf</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">toFun_eq</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">pf</span><span class=\"w\"> </span><span class=\"n\">toFun_eq</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">toFun_eq</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 501149837,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740157849
    },
    {
        "content": "<p>I verified this does indeed work on the testing branch</p>",
        "id": 501150528,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740158062
    },
    {
        "content": "<p>Regarding options, I have a feeling that we do want a <code>proof</code> option (default false), but in <code>Simp.Config</code>, not a <code>set_option</code>. I think it should be a boolean (rather than something tri-state) and control both dsimp and simp. Right now, simp won't enter proofs at all, but for proofs it could dsimp them if <code>proof</code> is true. There's an application for this I believe too (in a <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> project).</p>",
        "id": 501150712,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740158130
    },
    {
        "content": "<blockquote>\n<p>Not allowing <code>rw</code> to rewrite proofs.</p>\n</blockquote>\n<p>I think this shouldn't be problematic — this wouldn't cause \"motive not type correct\" errors, right?</p>\n<p>Similarly, we could allow rewriting in proofs with a <code>proof</code> option in the rewrite config.</p>\n<p>(I'm not saying that core Lean is accepting this change, but I'd like to think through the design for a start.)</p>",
        "id": 501151188,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740158298
    },
    {
        "content": "<blockquote>\n<p>Expand the function <code>Lean.Elab.abstractNestedProofs</code> so that it also abstracts nested proofs inside the type of a definition, not just inside the value.</p>\n</blockquote>\n<p>I think this makes sense; to make sure I understand, you're saying that when a term's proofs are abstracted, when we make the theorem, we should make sure that the type of that theorem has recursively been abstracted too, right?</p>",
        "id": 501151862,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740158529
    },
    {
        "content": "<p>No, what I meant is that for any theorem, <code>Lean.Elab.abstractNestedProofs</code> should be ran on the theorem statement. in <a href=\"https://github.com/leanprover-community/mathlib4/pull/22160\">#22160</a>, I did this manually for a few simp lemmas, and it gave a 55% speedup in <code>Mathlib.CategoryTheory.Adjunction.Lifting.Right</code></p>",
        "id": 501152260,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740158666
    },
    {
        "content": "<p>I'm not following, the bullet point is about definitions, and now you're saying theorems. Are you just saying that it should be run on theorem statements too and that it is not currently being run on theorem statements?</p>",
        "id": 501153040,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740158941
    },
    {
        "content": "<p>And can you confirm that you're not saying anything about the theorems that abstractNestedProofs itself produces?</p>",
        "id": 501153142,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740158966
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/dsimp.20simplifies.20proofs.2C.20which.20is.20slow/near/501153040\">said</a>:</p>\n<blockquote>\n<p>I'm not following, the bullet point is about definitions, and now you're saying theorems. Are you just saying that it should be run on theorem statements too and that it is not currently being run on theorem statements?</p>\n</blockquote>\n<p>Yes sorry, I meant to say theorem</p>",
        "id": 501153305,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740159003
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/22160\">#22160</a> I apply this manually to some simp lemmas, which speeds up <code>Mathlib.CategoryTheory.Adjunction.Lifting.Right</code> by 55%</p>",
        "id": 501153539,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740159087
    },
    {
        "content": "<p>I think it makes sense to abstract the proofs in theorem statements from first principles. The performance measurements though are helpful for making it a priority.</p>",
        "id": 501154048,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740159253
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> I made a draft PR at <a href=\"https://github.com/leanprover/lean4/pull/7181\">lean4#7181</a>. Would you be interested in doing the performance measurements to help justify the change?</p>\n<p>Independently of this, I'm not sure why <code>Lean.Meta.AbstractNestedProofs.visit</code> doesn't visit the functions in function applications.</p>",
        "id": 501162434,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740162303
    },
    {
        "content": "<p>Haha, I made a draft PR (<a href=\"https://github.com/leanprover/lean4/pull/7180\">lean4#7180</a>) with the exact same modifications at lean47181, but I'll close mine.</p>",
        "id": 501164216,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740162928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/dsimp.20simplifies.20proofs.2C.20which.20is.20slow/near/501162434\">said</a>:</p>\n<blockquote>\n<p>Independently of this, I'm not sure why <code>Lean.Meta.AbstractNestedProofs.visit</code> doesn't visit the functions in function applications.</p>\n</blockquote>\n<p>I think that is because <code>f a₁ .. aₙ</code> is a proof if and only if <code>f</code> is a proof. But I guess if <code>f</code> is a projection, then it could have subterms that are proofs, while <code>f</code> isn't a proof.</p>",
        "id": 501164821,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740163123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/dsimp.20simplifies.20proofs.2C.20which.20is.20slow/near/501162434\">said</a>:</p>\n<blockquote>\n<p>Would you be interested in doing the performance measurements to help justify the change?</p>\n</blockquote>\n<p>Yes I can bench it when the corresponding mathlib branch gets created</p>",
        "id": 501165386,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740163328
    },
    {
        "content": "<p>I tried to fix the Mathlib branch for the PR, but I ran into some problems with the function restrictScalars, and its Prop argument IsScalarTower. There were some rewrites that required rewriting inside the proof of IsScalarTower, but that wasn't possible because these proofs were now being abstracted.</p>\n<p>I might try to turn IsScalarTower into a Type instead of a Prop.</p>",
        "id": 501348233,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740296284
    },
    {
        "content": "<p>No, that sounds like a bad idea</p>",
        "id": 501351686,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1740299614
    },
    {
        "content": "<p>It's used all over commutative algebra which is essentially all classical and the moment you deprop it there will be diamonds everywhere</p>",
        "id": 501353687,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740301482
    },
    {
        "content": "<p>Ok, I managed to get the mathlib branch working, by using the <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/dependent.20rewrite.20tactic\">rw!</a> tactic for dependent rewriting, in this case for casting the type of the proof.</p>\n<p>However, benchmarking shows a global <a href=\"https://github.com/leanprover-community/mathlib4/pull/22177#issuecomment-2677049882\">slowdown</a> instead of a speedup. In particular we see that</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">process</span><span class=\"w\"> </span><span class=\"n\">pre</span><span class=\"bp\">-</span><span class=\"n\">definitions</span><span class=\"w\">    </span><span class=\"bp\">+</span><span class=\"mf\">26.5</span><span class=\"bp\">%</span>\n</code></pre></div>\n<p>Somehow this modification has managed to slow down kernel type checking.</p>",
        "id": 501412660,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740346849
    },
    {
        "content": "<p>For example, type checking <code>CategoryTheory.Abelian.Ext.covariant_sequence_exact₃'</code> now takes the kernel 10s instead of the previous 0.06s. I'm having a hard time understanding why. I manually abstracted the proof in the type of this lemma, but that didn't make a difference. So it must be that some other theorems type check less easily with abstracted proofs in their type. <code>set_option diagnostics true</code> shows that the kernel is doing some hard work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">kernel</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">unfolded</span><span class=\"w\"> </span><span class=\"n\">declarations</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">126497</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">num</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">66</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">HAdd</span><span class=\"bp\">.</span><span class=\"n\">hAdd</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">126497</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">126439</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">94890</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Discrete</span><span class=\"bp\">.</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">94766</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">brecOn</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">78981</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">78979</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"bp\">.</span><span class=\"n\">match_1</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">47435</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">47422</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">31705</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">HomologicalComplex</span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">31586</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Prefunctor</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">23346</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">15807</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">NatCast</span><span class=\"bp\">.</span><span class=\"n\">natCast</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">15807</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">9997</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">DFunLike</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">155</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">129</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">107</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">80</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Ab</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">78</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">ZeroHom</span><span class=\"bp\">.</span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">71</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">AddCommGrp</span><span class=\"bp\">.</span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">69</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">68</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">AddCommMonoid</span><span class=\"bp\">.</span><span class=\"n\">toAddMonoid</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">65</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">62</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">SubNegMonoid</span><span class=\"bp\">.</span><span class=\"n\">toAddMonoid</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">62</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">58</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">CategoryStruct</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">56</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">AddMonoidHom</span><span class=\"bp\">.</span><span class=\"n\">toZeroHom</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">54</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Injective</span><span class=\"bp\">.</span><span class=\"n\">addMonoid</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">48</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">47</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">AddMonoidHom</span><span class=\"bp\">.</span><span class=\"n\">instFunLike</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">46</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">toPrefunctor</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">41</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">AddMonoid</span><span class=\"bp\">.</span><span class=\"n\">toZero</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">38</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">HSub</span><span class=\"bp\">.</span><span class=\"n\">hSub</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">37</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">37</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Sub</span><span class=\"bp\">.</span><span class=\"n\">sub</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">37</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">AddMonoid</span><span class=\"bp\">.</span><span class=\"n\">toAddZeroClass</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">36</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Prefunctor</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">35</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">shiftFunctor</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">33</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">ShiftMkCore</span><span class=\"bp\">.</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">33</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">AddGroup</span><span class=\"bp\">.</span><span class=\"n\">toSubNegMonoid</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">32</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">30</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Quot</span><span class=\"bp\">.</span><span class=\"n\">liftOn</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">30</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">negOfNat</span><span class=\"bp\">.</span><span class=\"n\">match_1</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">30</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">AddMonoid</span><span class=\"bp\">.</span><span class=\"n\">toAddSemigroup</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">28</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">AddSemigroup</span><span class=\"bp\">.</span><span class=\"n\">toAdd</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">28</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">indefiniteDescription</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">28</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">27</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">27</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">27</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">27</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">27</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">objPreimage</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">26</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Localization</span><span class=\"bp\">.</span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">26</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">essImage</span><span class=\"bp\">.</span><span class=\"n\">witness</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">26</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">25</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">instFunLike</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">25</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">ShiftedHom</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">24</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">24</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">23</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">AddCommGrp</span><span class=\"bp\">.</span><span class=\"n\">Hom</span><span class=\"bp\">.</span><span class=\"n\">hom'</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">23</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">AddCommGroup</span><span class=\"bp\">.</span><span class=\"n\">toAddGroup</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">22</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">ConcreteCategory</span><span class=\"bp\">.</span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">22</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">neg</span><span class=\"bp\">.</span><span class=\"n\">match_1</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">22</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">21</span>\n<span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">21</span>\n</code></pre></div>",
        "id": 501412700,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740346901
    },
    {
        "content": "<p>I managed to somewhat minimize the slowness to this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Homology</span><span class=\"bp\">.</span><span class=\"n\">DerivedCategory</span><span class=\"bp\">.</span><span class=\"n\">Ext</span><span class=\"bp\">.</span><span class=\"n\">ExtClass</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Triangulated</span><span class=\"bp\">.</span><span class=\"n\">Yoneda</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">w'</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Abelian</span><span class=\"bp\">.</span><span class=\"n\">Ext</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Opposite</span><span class=\"w\"> </span><span class=\"n\">DerivedCategory</span><span class=\"w\"> </span><span class=\"n\">Pretriangulated</span><span class=\"w\"> </span><span class=\"n\">Pretriangulated</span><span class=\"bp\">.</span><span class=\"n\">Opposite</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Abelian</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasExt</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ShortComplex</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hS</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">ShortExact</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">little_proof</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">n₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n₀</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">n₀</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n₁</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">preadditiveCoyoneda_homologySequenceδ_singleTriangle_apply</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">HasDerivedCategory</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ext</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">X₃</span><span class=\"w\"> </span><span class=\"n\">n₀</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">n₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n₀</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">preadditiveCoyoneda</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">singleFunctor</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">homologySequenceδ</span>\n<span class=\"w\">      </span><span class=\"n\">hS</span><span class=\"bp\">.</span><span class=\"n\">singleTriangle</span><span class=\"w\"> </span><span class=\"n\">n₀</span><span class=\"w\"> </span><span class=\"n\">n₁</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">hS</span><span class=\"bp\">.</span><span class=\"n\">extClass</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>It takes the kernel about 1.5s to figure out that the type  of <code>sorry</code> and the type of the lemma are the same. This is because the <code>sorry</code> gets abstracted. And replacing the <code>sorry</code> in the lemma statement with <code>little_proof h</code> fixes the slowness, because <code>little_proof h</code> will not be abstracted.</p>",
        "id": 501429002,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740360721
    },
    {
        "content": "<p>So I think the solution is to do the abstraction of nested proofs before elaborating the value/proof of a def/theorem. I believe it's only for theorems that the type is completely elaborated before the value is elaborated. So at least for theorems, it should be possible to abstract nested proofs before elaborating the proof. (<span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>)</p>",
        "id": 501429054,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740360731
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"651332\">@Sven Manthe</span> and I defined a tactic <code>abstract</code> that does the abstraction of proof in the type of a lemma before the proof is elaborated. It is <a href=\"https://github.com/sven-manthe/A-formalization-of-Borel-determinacy-in-Lean/blob/master/BorelDet/Basic/meta.lean#L9\">here</a>. Sven is working a lot with partial functions that depend on proof terms, and he got massive slowdowns without abstracting proof terms (cf. <a href=\"https://github.com/leanprover/lean4/pull/5108\">lean#5108</a>). <br>\nIt would be nice to put the <code>abstract</code> tactic into Mathlib (unless Lean will do this automatically by default).</p>",
        "id": 501543020,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1740403573
    },
    {
        "content": "<p><code>abstract</code> is just a tactic, i.e. it doesn't change the theorem statement that gets added. What I'm looking for is to abstract nested proofs in the theorem statement. And my hypothesis is that it's more efficient to do this step before rather that after elaborating the proof, so that the statement and proof match up better.</p>",
        "id": 501548215,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740404818
    },
    {
        "content": "<p>(The infrastructure for abstracting nested proofs is already present, it's just a matter of applying it in the right place)</p>",
        "id": 501550742,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740405474
    },
    {
        "content": "<p>If you call <code>abstract</code> in the statement of a lemma, it will create an auxiliary declaration, and use that auxiliary declaration in the statement of the lemma.</p>",
        "id": 501561348,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1740408038
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"n\">Term</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"abstract\"</span><span class=\"w\"> </span><span class=\"n\">tacs</span><span class=\"o\">:</span><span class=\"n\">ppDedent</span><span class=\"o\">(</span><span class=\"n\">tacticSeq</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getGoals</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">return</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getGoals</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"more than one goal\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">target</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getMainTarget</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getMainGoal</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">newGoal</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVar</span><span class=\"w\"> </span><span class=\"n\">target</span>\n<span class=\"w\">  </span><span class=\"n\">setGoals</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">newGoal</span><span class=\"bp\">.</span><span class=\"n\">mvarId!</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">evalTactic</span><span class=\"w\"> </span><span class=\"n\">tacs</span>\n<span class=\"w\">  </span><span class=\"n\">setGoals</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">goal</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">goal</span><span class=\"bp\">.</span><span class=\"n\">assign</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAuxTheorem</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getDeclName?</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get!</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"ss\">`abstract</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshId</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">target</span><span class=\"w\"> </span><span class=\"n\">newGoal</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">abstract</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"c1\">-- theorem foo : ∀ (x : Fin 3), x = ⟨2, foo.abstract._uniq.2632⟩</span>\n<span class=\"c1\">-- `foo.abstract._uniq.2632` is some auxiliary lemma stating `2 &lt; 3`.</span>\n</code></pre></div>",
        "id": 501562008,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1740408199
    },
    {
        "content": "<p>But perhaps making Lean automatically do this is better. It would certainly have made life easier for Sven.</p>",
        "id": 501562246,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1740408251
    },
    {
        "content": "<p>Oh, I see now. Yes that is what I'd like to happen automatically. One difference between that and the abstractNestedProofs implementation is that with <code>by abstract</code>, the type of the abstracted proof becomes the <strong>expected</strong> type of the proof term, whereas using <code>abstractNestedProofs</code> makes it have the <strong>inferred</strong> type of the proof term.</p>",
        "id": 501564380,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740408754
    },
    {
        "content": "<p>I ran into an example once where a proof stopped working because of this difference between the expected type and actual type of a proof (the proof was <code>rfl</code>)</p>",
        "id": 501565259,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740408957
    },
    {
        "content": "<p>I am confused by the example. How am I supposed to see the slowness? The file compiles instantly for me (I'm reviewing an old PR so I'm on v4.16.0-rc2, don't know if this makes a difference)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Homology</span><span class=\"bp\">.</span><span class=\"n\">DerivedCategory</span><span class=\"bp\">.</span><span class=\"n\">Ext</span><span class=\"bp\">.</span><span class=\"n\">ExtClass</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Triangulated</span><span class=\"bp\">.</span><span class=\"n\">Yoneda</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">w'</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Abelian</span><span class=\"bp\">.</span><span class=\"n\">Ext</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Opposite</span><span class=\"w\"> </span><span class=\"n\">DerivedCategory</span><span class=\"w\"> </span><span class=\"n\">Pretriangulated</span><span class=\"w\"> </span><span class=\"n\">Pretriangulated</span><span class=\"bp\">.</span><span class=\"n\">Opposite</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Abelian</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasExt</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ShortComplex</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hS</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">ShortExact</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">little_proof</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">n₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n₀</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">n₀</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n₁</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">profiler</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"c1\">-- 0.06 seconds</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">preadditiveCoyoneda_homologySequenceδ_singleTriangle_apply</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">HasDerivedCategory</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ext</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">X₃</span><span class=\"w\"> </span><span class=\"n\">n₀</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">n₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n₀</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">preadditiveCoyoneda</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">singleFunctor</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">homologySequenceδ</span>\n<span class=\"w\">      </span><span class=\"n\">hS</span><span class=\"bp\">.</span><span class=\"n\">singleTriangle</span><span class=\"w\"> </span><span class=\"n\">n₀</span><span class=\"w\"> </span><span class=\"n\">n₁</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">hS</span><span class=\"bp\">.</span><span class=\"n\">extClass</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Abelian</span><span class=\"bp\">.</span><span class=\"n\">Ext</span>\n</code></pre></div>",
        "id": 501624100,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740423188
    },
    {
        "content": "<p>Ah sorry, the slowness is only there on the testing branch of <a href=\"https://github.com/leanprover/lean4/pull/7181\">lean4#7181</a>, it's not in normal Lean</p>",
        "id": 501662261,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740436332
    },
    {
        "content": "<p>Should <code>abstract</code> be added to mathlib? It would be very handy for <a href=\"https://github.com/leanprover-community/mathlib4/pull/22160\">#22160</a>, where I did what <code>abstract</code> does, but manually, to get a performance improvement.</p>",
        "id": 501861732,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740503458
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Monad</span><span class=\"bp\">.</span><span class=\"n\">Monadicity</span><span class=\"w\">              </span><span class=\"bp\">-</span><span class=\"mf\">1.290</span><span class=\"bp\">⬝</span><span class=\"mi\">10</span><span class=\"bp\">⁹</span><span class=\"w\">     </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mf\">5.90</span><span class=\"bp\">%</span><span class=\"o\">)</span>\n<span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Adjunction</span><span class=\"bp\">.</span><span class=\"n\">Lifting</span><span class=\"bp\">.</span><span class=\"n\">Right</span><span class=\"w\">     </span><span class=\"bp\">-</span><span class=\"mf\">21.384</span><span class=\"bp\">⬝</span><span class=\"mi\">10</span><span class=\"bp\">⁹</span><span class=\"w\">     </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mf\">55.59</span><span class=\"bp\">%</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 501862042,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740503539
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/22296\">#22296</a></p>",
        "id": 501876777,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1740506059
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/270676-lean4/topic/dsimp.20simplifies.20proofs.2C.20which.20is.20slow/near/501662261\">said</a>:</p>\n<blockquote>\n<p>Ah sorry, the slowness is only there on the testing branch of <a href=\"https://github.com/leanprover/lean4/pull/7181\">lean4#7181</a>, it's not in normal Lean</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, actually, the slowness can be replicated in normal Lean. To trigger the slow unification, we can use the <code>change</code> tactic:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Homology</span><span class=\"bp\">.</span><span class=\"n\">DerivedCategory</span><span class=\"bp\">.</span><span class=\"n\">Ext</span><span class=\"bp\">.</span><span class=\"n\">ExtClass</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Triangulated</span><span class=\"bp\">.</span><span class=\"n\">Yoneda</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">w'</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Abelian</span><span class=\"bp\">.</span><span class=\"n\">Ext</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Opposite</span><span class=\"w\"> </span><span class=\"n\">DerivedCategory</span><span class=\"w\"> </span><span class=\"n\">Pretriangulated</span><span class=\"w\"> </span><span class=\"n\">Pretriangulated</span><span class=\"bp\">.</span><span class=\"n\">Opposite</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">profiler</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">preadditiveCoyoneda_homologySequenceδ_singleTriangle_apply</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Abelian</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasExt</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ShortComplex</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hS</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">ShortExact</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">HasDerivedCategory</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ext</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">X₃</span><span class=\"w\"> </span><span class=\"n\">n₀</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">n₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n₀</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">preadditiveCoyoneda</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">singleFunctor</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">homologySequenceδ</span>\n<span class=\"w\">    </span><span class=\"n\">hS</span><span class=\"bp\">.</span><span class=\"n\">singleTriangle</span><span class=\"w\"> </span><span class=\"n\">n₀</span><span class=\"w\"> </span><span class=\"n\">n₁</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">hS</span><span class=\"bp\">.</span><span class=\"n\">extClass</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">preadditiveCoyoneda</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">singleFunctor</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">homologySequenceδ</span>\n<span class=\"w\">      </span><span class=\"n\">hS</span><span class=\"bp\">.</span><span class=\"n\">singleTriangle</span><span class=\"w\"> </span><span class=\"n\">n₀</span><span class=\"w\"> </span><span class=\"n\">n₁</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">hS</span><span class=\"bp\">.</span><span class=\"n\">extClass</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 502080601,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740584917
    },
    {
        "content": "<p>The reason I asked was just to rule out the possibility that removing universes fixed the problem; this is another time I've seen the kernel take far too long to do something. I didn't expect universe-removal to fix the problem given your description and indeed it doesn't.</p>",
        "id": 502087328,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740586531
    },
    {
        "content": "<p>I've written a linter that complains if the RHS of a simp lemma contains a large proof term, which for example finds the lemma that slows down <code>Mathlib.CategoryTheory.Adjunction.Lifting.Right</code> (as seen in <a href=\"https://github.com/leanprover-community/mathlib4/pull/22160\">#22160</a>). So when <a href=\"https://github.com/leanprover-community/mathlib4/pull/22296\">#22296</a> is merged, I'd like to use the <code>abstract</code> tactic to improve some simp lemmas with proof terms on the RHS.</p>\n<p>Here's the code</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Batteries</span><span class=\"w\"> </span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"n\">Lint</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getRHS</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">eq?</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">rhs</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">iff?</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">rhs</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">none</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">env_linter</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">simpNF'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lint</span><span class=\"bp\">.</span><span class=\"n\">Linter</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">noErrorsFound</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"NOTHING\"</span>\n<span class=\"w\">  </span><span class=\"n\">errorsFound</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"FOUND SOME!\"</span>\n<span class=\"w\">  </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">declName</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isSimpTheorem</span><span class=\"w\"> </span><span class=\"n\">declName</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getConstInfo</span><span class=\"w\"> </span><span class=\"n\">declName</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">type</span>\n<span class=\"w\">    </span><span class=\"n\">forallTelescope</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">getRHS</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">    </span><span class=\"n\">try</span>\n<span class=\"w\">      </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">transform</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isProof</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">          </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">200000</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">            </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"too big proof term of {← inferType e}\"</span>\n<span class=\"w\">          </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">        </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">    </span><span class=\"n\">catch</span><span class=\"w\"> </span><span class=\"n\">er</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{e} might be a bad lemma; {er.toMessageData}\"</span>\n\n<span class=\"bp\">#</span><span class=\"n\">lint</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"n\">simpNF'</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">all</span>\n</code></pre></div>",
        "id": 502918009,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740963159
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/dsimp.20simplifies.20proofs.2C.20which.20is.20slow/near/501162434\">said</a>:</p>\n<blockquote>\n<p>Independently of this, I'm not sure why <code>Lean.Meta.AbstractNestedProofs.visit</code> doesn't visit the functions in function applications.</p>\n</blockquote>\n<p>I found out that for example <code>commaMapEquivalenceInverse</code> suffers from this, since it has a proof that sits inside a beta-unreduced function application. I'd guess this problem is quite common in functors, since the expected type of <code>map</code> usually contains the <code>obj</code> in beta-unreduced form.</p>",
        "id": 503630173,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741207608
    }
]