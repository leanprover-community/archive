[
    {
        "content": "<p>This has come up before (see e.g. <a href=\"https://github.com/leanprover/lean4/pull/2292\">lean4#2292</a>) but I figured I'd make this into a concrete proposal. The idea is the following:<br>\nIn some cases there is a definition of a type that's convenient for proofs but at the same time is very slow to use at runtime; but there is another definition of a type that's efficient at runtime but can't be used for proofs.<br>\nOne such example is an infinite list which can be defined as a function <code>f : Nat → α</code> where <code>f n</code> corresponds to the <code>n</code>th element of the list. However, using this definition often leads to inefficient code running in <code>O(n^2)</code> time where <code>O(n)</code> would be possible. A better definition would be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">InfiniteList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Thunk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">InfiniteList</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>but there's a problem: this type isn't formally inhabited so proof world can't do anything with it. So you need to choose: proofs or efficiency? The idea is to add an attribute similar to <code>@[implemented_by]</code> but for inductive types, which would allow you to solve this problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">InfiniteListImpl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Thunk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">InfiniteList</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">override_repr</span><span class=\"w\"> </span><span class=\"n\">InfiniteListImpl</span><span class=\"kd\">]</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">InfiniteList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>This attribute should make sure that <code>InfiniteList</code> doesn't use the representation provided by the structure but the representation of <code>InfiniteListImpl</code>; thus <code>InfiniteList.mk</code> and <code>InfiniteList.get</code> don't make any sense at this point and become noncomputable. However, you should be able to then use <code>@[implemented_by]</code>, <code>@[csimp]</code> and <code>@[extern]</code> on these as if they were regular noncomputable functions. At the same time <code>@[implemented_by]</code>, <code>@[csimp]</code> and <code>@[extern]</code> would then not be allowed on constructors and projections of inductives without <code>@[override_repr]</code>.</p>",
        "id": 529922835,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1753114203
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> and <span class=\"user-mention\" data-user-id=\"656225\">@Cameron Zwarich</span> you might be interested in this</p>",
        "id": 529923218,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1753114346
    },
    {
        "content": "<p>I definitely think we should do something like this. A few points:</p>\n<ul>\n<li>We need some specification of how <code>casesOn</code> should work. I assume that general recursors (which I've started working on a bit for \"ordinary\" inductive types) will just never work?</li>\n<li>Would we actually want to support <code>csimp</code> for these types?</li>\n<li>Whatever mechanism we pick should be able to subsume the builtin support for overridden runtime types; I don't want to support two very similar paths at once. I don't expect this to be a serious problem, maybe a few types (e.g. <code>Thunk</code>) will need their interface to be refactored.</li>\n<li>Similarly, I would like the implementation of this to share as much as possible with the implementation of computed fields (after some improvements, as it is currently deficient).</li>\n</ul>",
        "id": 529952335,
        "sender_full_name": "Cameron Zwarich",
        "timestamp": 1753125406
    },
    {
        "content": "<p>Maybe a reasonable restriction would be to only permit structures with one field? Most builtin runtime types already fulfill this requirement, except <code>Nat</code> and <code>Int</code> which we could hardcode in the worst case.</p>",
        "id": 530083330,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1753169043
    },
    {
        "content": "<p>Oh and another point is the syntax; should we allow <code>@[override_repr]</code> to only take in a single identifier or an entire term? In some cases it might be useful to be able to specify a full type term -- at the same time you could always write a <code>def</code> -- which is what has been done with <code>@[implemented_by]</code> for a long time already. One compromise I thought of was to allow the type you override from to have less parameters, so something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">override_repr</span><span class=\"w\"> </span><span class=\"n\">UInt8</span><span class=\"kd\">]</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">TestMe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"w\">  </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"w\">  </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>would work.</p>",
        "id": 530130884,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1753185858
    },
    {
        "content": "<p>Oh and</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">override_repr</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"kd\">]</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">MyErased</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>would also be cool</p>",
        "id": 530131350,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1753186023
    }
]