[
    {
        "content": "<p>Does something like this already exist?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Wrapper for a lazily-initializer reference. -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">LazilyInitialized</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">ref</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">Ref</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">mutex</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">BaseMutex</span>\n<span class=\"w\">  </span><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">LazilyInitialized</span><span class=\"bp\">.</span><span class=\"n\">new</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LazilyInitialized</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">ref</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">mkRef</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mutex</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">BaseMutex</span><span class=\"bp\">.</span><span class=\"n\">new</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Obtain the value, constructing it in a thread-safe way if necessary. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">LazilyInitialized</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LazilyInitialized</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">ref</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">try</span>\n<span class=\"w\">    </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">mutex</span><span class=\"bp\">.</span><span class=\"n\">lock</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">ref</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">init</span>\n<span class=\"w\">    </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">ref</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">finally</span>\n<span class=\"w\">    </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">mutex</span><span class=\"bp\">.</span><span class=\"n\">unlock</span>\n\n<span class=\"n\">initialize</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LazilyInitialized</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">LazilyInitialized</span><span class=\"bp\">.</span><span class=\"n\">new</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">someExpensiveIOCall</span>\n</code></pre></div>",
        "id": 499722793,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739534905
    },
    {
        "content": "<p>(context: <a href=\"https://github.com/nomeata/loogle/pull/26\">nomeata/loogle#26</a>)</p>",
        "id": 499728210,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739536267
    },
    {
        "content": "<p>Looks like an IO version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Thunk#doc\">docs#Thunk</a></p>",
        "id": 499737099,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739538662
    },
    {
        "content": "<p>(I’ll watch this discussion in case something new comes up before merging your PR)</p>",
        "id": 499737663,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739538797
    },
    {
        "content": "<p>Ah indeed, though <code>Thunk</code> <a href=\"https://github.com/leanprover/lean4/blob/dd1a4188a0cb6995d2519765fc20f461a0f546ff/src/runtime/object.cpp#L431\">uses atomics</a> behind the scenes rather than a mutex</p>",
        "id": 499756446,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739543126
    },
    {
        "content": "<p>Maybe this warrants a <code>ThunkT</code> monad transformer, with <code>Thunk := ThunkT Id</code>?</p>",
        "id": 499756483,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739543137
    },
    {
        "content": "<p>So something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"sd\">/-- A monadic thunk, that memorizes its result after the first execution.</span>\n\n<span class=\"sd\">Can also be thought of as a monadic lazy initializer-/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ThunkM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadLiftT</span><span class=\"w\"> </span><span class=\"n\">BaseIO</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadFinally</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">ctor</span><span class=\"w\"> </span><span class=\"bp\">::</span>\n<span class=\"w\">    </span><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">ref</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">Ref</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">mutex</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">BaseMutex</span>\n<span class=\"w\">    </span><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadLiftT</span><span class=\"w\"> </span><span class=\"n\">BaseIO</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadFinally</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ThunkM</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">ref</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">Ref</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">mutex</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">BaseMutex</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">init</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"o\">{</span><span class=\"n\">ref</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mutex</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"o\">}</span><span class=\"bp\">⟩</span>\n\n<span class=\"sd\">/-- Create a monadic thunk from an initializer.</span>\n\n<span class=\"sd\">When `.get` is called and the initializer succeeds, its result is cached. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ThunkM</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BaseIO</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ThunkM</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">ref</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">mkRef</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mutex</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">BaseMutex</span><span class=\"bp\">.</span><span class=\"n\">new</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Obtain the value, constructing it in a thread-safe way if necessary. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ThunkM</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ThunkM</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">ref</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BaseIO</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">try</span>\n<span class=\"w\">    </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">mutex</span><span class=\"bp\">.</span><span class=\"n\">lock</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">ref</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BaseIO</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">init</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">ref</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BaseIO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">finally</span>\n<span class=\"w\">    </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">mutex</span><span class=\"bp\">.</span><span class=\"n\">unlock</span>\n\n<span class=\"sd\">/-- info: ran initializer once -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"n\">run_meta</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">lazy1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ThunkM</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">ThunkM</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"s2\">\"ran initializer once\"</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"mi\">37</span>\n<span class=\"w\">  </span><span class=\"n\">lazy1</span><span class=\"bp\">.</span><span class=\"n\">get</span>\n<span class=\"w\">  </span><span class=\"n\">lazy1</span><span class=\"bp\">.</span><span class=\"n\">get</span>\n</code></pre></div>",
        "id": 500167840,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739794313
    },
    {
        "content": "<p>Remind me why do you want to lift it out of <code>IO</code>? I guess now <code>m</code> can do “things”, but since you don't really know when the first <code>get</code> it will be invoked, it seems like it can be somewhat confusing and dangerous to have the effects of <code>m</code> appear there.</p>",
        "id": 500180989,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739797483
    },
    {
        "content": "<p>I don't have a good motivation for that besides trying to generalize. Indeed, it's hard to think of a monad where this lift wouldn't be confusing and dangerous</p>",
        "id": 500181925,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739797701
    },
    {
        "content": "<p>Ok, that’s what I thought :-)</p>",
        "id": 500182021,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739797725
    },
    {
        "content": "<p>Maybe a version that cached the monad state and context at the time of initialization and used that in <code>.get</code> would be sane</p>",
        "id": 500182152,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739797764
    },
    {
        "content": "<p>Yes, possibly, using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MonadControlT#doc\">docs#MonadControlT</a> or so. But even then it may be confusing that any side-effects are dropped.</p>",
        "id": 500182469,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739797834
    },
    {
        "content": "<p>But it's more than I need, so maybe the original with name <code>IO.Thunk</code> is best?</p>",
        "id": 500182487,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739797840
    },
    {
        "content": "<p>If in doubt, don’t generalize. (It’s code, not math)</p>",
        "id": 500182570,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739797868
    },
    {
        "content": "<p>I guess <code>ExceptT BonusEx IO</code> would be a place where the generality is useful</p>",
        "id": 500182843,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739797934
    },
    {
        "content": "<p>Really? In that case the action would be thrown upon each <code>.get</code> and never cached (based on your code above)</p>",
        "id": 500183098,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739798007
    },
    {
        "content": "<p>That's already what it does with io errors</p>",
        "id": 500183165,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739798029
    },
    {
        "content": "<p>Hmm, fair point. Maybe it should live in <code>BaseIO</code> then :-)</p>",
        "id": 500183408,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739798088
    },
    {
        "content": "<p>Probably that’s why <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BaseIO.asTask#doc\">docs#BaseIO.asTask</a> is also in <code>BaseIO</code></p>",
        "id": 500183837,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739798209
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/270676-lean4/topic/Lazy.20initialization/near/500183408\">said</a>:</p>\n<blockquote>\n<p>Hmm, fair point. Maybe it should live in <code>BaseIO</code> then :-)</p>\n</blockquote>\n<p>Or there should be both <code>BaseIO.Thunk</code> and <code>IO.Thunk</code>?</p>",
        "id": 500184075,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739798268
    },
    {
        "content": "<p>For what it's worth, Python's <code>@functools.cache</code> has the behavior of not caching errors, like <code>IO.Thunk</code> would (<a href=\"https://github.com/python/cpython/issues/65736\">https://github.com/python/cpython/issues/65736</a>)</p>",
        "id": 500185442,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739798569
    },
    {
        "content": "<p>Maybe <code>BaseIO.Thunk</code> is enough. <code>IO.Thunk</code> sounds dangerous, unless it does store the exception (i.e. is a thin wrapper around <code>BaseIO.Thunk</code>)</p>",
        "id": 500200600,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739802009
    },
    {
        "content": "<p>Would you like me to make such a change to the loogle PR, or is it blocked until this discussion is resolved anyway?</p>",
        "id": 500220997,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739806571
    },
    {
        "content": "<p>I guess I can merge this change (with a <code>BaseIO</code>-typed-thunk)  to unblock your experiments using Loogle locally.</p>",
        "id": 500221853,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739806791
    }
]