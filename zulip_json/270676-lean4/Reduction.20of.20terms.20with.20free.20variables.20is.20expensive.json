[
    {
        "content": "<p>There seems to be a significant difference between the reduction strategies when using <code>rfl</code> on expressions with and without free variables, but I am a bit confused why that is.  I also can't come up with a completely standalone example of this (so I'm using a reduced example that uses <code>Batteries.RBMap</code>, because examples that are too small don't seem to exhibit the same issue.</p>\n<p>Below the proof of equality, which reduces the term, takes 500ms, and becomes exponentially longer the more elements are added to the first tree.  Here <code>T</code> is a fvar in the local context.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Batteries</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">profiler</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"c1\">-- takes 500ms (uncomment and it takes 7s)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"o\">(((</span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">RBMap</span><span class=\"bp\">.</span><span class=\"n\">ofList</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\">, (4, T), (5, T)-/</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"bp\">.</span><span class=\"n\">compare</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mergeWith</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">          </span><span class=\"o\">(</span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">RBMap</span><span class=\"bp\">.</span><span class=\"n\">ofList</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"bp\">.</span><span class=\"n\">compare</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>What I find strange is that just making <code>T</code> a declaration, so that it becomes a constant in the expression, makes the proof of equality nearly instant.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Batteries</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">profiler</span><span class=\"bp\">.</span><span class=\"n\">threshold</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"c1\">-- otherwise no time is shown</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">profiler</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"c1\">-- takes 8ms</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(((</span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">RBMap</span><span class=\"bp\">.</span><span class=\"n\">ofList</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"bp\">.</span><span class=\"n\">compare</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mergeWith</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">          </span><span class=\"o\">(</span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">RBMap</span><span class=\"bp\">.</span><span class=\"n\">ofList</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"bp\">.</span><span class=\"n\">compare</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>In our proofs we seem to be hitting this inefficiency quite often, because we are mainly referring to fvars in expressions.  I would also not expect the reduction to be this slow, and I am not sure which exact step is taking so long.  Does anyone have any insights on why this might be? Or if this is an expected behaviour of the reduction?</p>",
        "id": 469077847,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1725971729
    },
    {
        "content": "<p>Maybe you're seeing a feature in the <code>eq_refl</code> tactic (which is what <code>rfl</code> for equalities), where if there are no free variables or metavariables, it uses kernel defeq instead of the usual elaborator defeq when validating that <code>Eq.refl</code> can prove the goal. Kernel defeq is faster.</p>",
        "id": 469129805,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725982162
    },
    {
        "content": "<p>I'm not sure why <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.refl#doc\">docs#Lean.MVarId.refl</a> doesn't allow fvars at all, since <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Kernel.isDefEq#doc\">docs#Lean.Kernel.isDefEq</a> does accept a local context. Though, it would need to instantiate all mvars in the local context and check that no mvars are remaining.</p>",
        "id": 469130686,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725982399
    },
    {
        "content": "<p>Ah yes, that probably explains the difference between the free variable vs constant version.  But I still wasn't expecting there to be a difference of 7s vs 8ms!</p>\n<p>And thank you for the pointers, that's interesting that it could maybe be passed to the kernel defeq check.  Instantiating all mvars in the local context should be fine as well.</p>",
        "id": 469131196,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1725982524
    },
    {
        "content": "<p>If you can do some metaprogramming, it wouldn't be too difficult to make a <code>ker_rfl</code> tactic.</p>\n<p>One approach to make a local context would be to use <code>mkForallFVars</code> on the target with <code>usedOnly := true</code> to make a closed term, instantiate mvars at that point (and check that there are no mvars), then with an empty local context use <code>forallTelescope</code>. This is all a way to remove false dependencies on mvars while instantiating them.</p>",
        "id": 469132885,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725982933
    },
    {
        "content": "<p>Oh great thanks, yeah that shouldn't be too difficult, I'll try that out.  And thanks for the pointer on <code>usedOnly</code>, that should be useful!</p>\n<p>Is there any point in trying to reduce the example further to see what takes 7s in the non kernel reduction?  Or should one be avoiding the normal reduction in elaboration as much as possible?</p>",
        "id": 469134801,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1725983364
    },
    {
        "content": "<p>Just wanted to note that I've filed an issue about the <code>eq_refl</code> performance on this term with free variables, because I feel like the the exponential number of functions that are unfolded as the size of the list increases is unexpected <a href=\"https://github.com/leanprover/lean4/pull/5596\">lean#5596</a>.</p>",
        "id": 474299677,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1727876184
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Reduction.20of.20terms.20with.20free.20variables.20is.20expensive/near/469129805\">said</a>:</p>\n<blockquote>\n<p>it uses kernel defeq instead of the usual elaborator defeq when validating that <code>Eq.refl</code> can prove the goal.</p>\n</blockquote>\n<p>Is this still the case, or does it now use elaborator defeq?</p>",
        "id": 483966539,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732299602
    },
    {
        "content": "<p>Just checked, no it does not use the kernel anymore.</p>",
        "id": 483969694,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732300854
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/3772\">lean4#3772</a></p>",
        "id": 483969803,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732300899
    },
    {
        "content": "<p>Is there a version of <code>rfl</code> that does use the kernel?</p>",
        "id": 483971075,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732301448
    },
    {
        "content": "<p>I came up with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">run_tac</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">popMainGoal</span>\n<span class=\"w\">    </span><span class=\"n\">let_expr</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">getType'</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">failure</span>\n<span class=\"w\">    </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">assign</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">mkEqRefl</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but it wouldn't surprise me if something is wrong here</p>",
        "id": 483971143,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732301477
    },
    {
        "content": "<p>If it's applicable, you could use <code>decide</code>'s kernel mode (on nightly it's <code>decide +kernel</code>), which is a bit less efficient than just using Eq.refl</p>",
        "id": 483971404,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732301580
    },
    {
        "content": "<p>I think the only thing that's wrong with what you have is that it doesn't do any validation at tactic time that the tactic succeeds. The <code>decide +kernel</code> tactic will call out to the kernel at tactic time. It caches the result as a theorem too, so it doesn't need to be checked again.</p>",
        "id": 483971536,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732301635
    },
    {
        "content": "<p>That's <code>decide!</code> in non-nightly versions?</p>",
        "id": 483971629,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732301662
    },
    {
        "content": "<p>Yeah</p>",
        "id": 483971663,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732301684
    },
    {
        "content": "<p>Hmm, that doesn't exist in the stable version of Lean it seems</p>",
        "id": 483971940,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732301816
    },
    {
        "content": "<p>Only in the release candidates</p>",
        "id": 483971960,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732301825
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Reduction.20of.20terms.20with.20free.20variables.20is.20expensive/near/483971536\">said</a>:</p>\n<blockquote>\n<p>I think the only thing that's wrong with what you have is that it doesn't do any validation at tactic time that the tactic succeeds</p>\n</blockquote>\n<p>What would that validation look like?</p>",
        "id": 483972376,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732301907
    },
    {
        "content": "<p>You'd want to ask the kernel to check that <code>a</code> and <code>b</code> are defeq before assigning that metavariable, and if that fails then throw an error</p>",
        "id": 483972530,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732301973
    },
    {
        "content": "<p>(using the code that 3772 removed)</p>",
        "id": 483972568,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732301984
    },
    {
        "content": "<p>Or, you could look at how <code>decide +kernel</code> works. It uses the auxdecl interface to add a theorem to the environment.</p>\n<p>Though, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.mkAuxTheorem#doc\">docs#Lean.Meta.mkAuxTheorem</a> seems very convenient. It will auto-abstract the any fvars for you and create a theorem checked by the kernel, which you should be able to apply (though you'd have to be careful with transparency settings to make sure it doesn't trigger any expensive defeqs!)</p>",
        "id": 483973150,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732302175
    },
    {
        "content": "<p>I don't need anything sophisticated here, the purpose is to have a test that forces the kernel to crash</p>",
        "id": 483974278,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732302606
    },
    {
        "content": "<p>The test in question is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"sd\">/-- Check if the kernel would accept `rfl` -/</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"rfl!?\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">getMainGoal</span>\n<span class=\"w\">  </span><span class=\"n\">let_expr</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">getType'</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">failure</span>\n<span class=\"w\">  </span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">ofExceptKernelException</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Kernel</span><span class=\"bp\">.</span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{}</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">npowRec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">npowRec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">npowRec</span><span class=\"w\"> </span><span class=\"mi\">2000</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">npowRec</span><span class=\"w\"> </span><span class=\"mi\">2000</span><span class=\"w\"> </span><span class=\"mi\">2001</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">npowRec</span><span class=\"w\"> </span><span class=\"mi\">2000</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">npowRec</span><span class=\"w\"> </span><span class=\"mi\">20001</span><span class=\"w\"> </span><span class=\"mi\">2000</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rfl!?</span>\n</code></pre></div>\n<p>which indeed crashes / consumes all memory</p>",
        "id": 483974454,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732302704
    },
    {
        "content": "<p>(though arguably that's my fault for circumventing the elaborator)</p>",
        "id": 483974536,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732302732
    }
]