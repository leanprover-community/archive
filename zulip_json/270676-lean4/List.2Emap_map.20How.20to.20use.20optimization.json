[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">map_map</span>\n<span class=\"c1\">-- List.map_map.{u_1, u_2, u_3} {β : Type u_1} {γ : Type u_2} {α : Type u_3} {g : β → γ} {f : α → β} {l : List α} :</span>\n<span class=\"c1\">-- List.map g (List.map f l) = List.map (g ∘ f) l</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">compiler</span><span class=\"bp\">.</span><span class=\"n\">ir</span><span class=\"bp\">.</span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span>\n\n<span class=\"c1\">--[result]</span>\n<span class=\"c1\">--def test (x_1 : obj) (x_2 : obj) (x_3 : obj) : obj :=</span>\n<span class=\"c1\">--  let x_4 : obj := ctor_0[List.nil];</span>\n<span class=\"c1\">--  let x_5 : obj := List.mapTR.loop._rarg x_3 x_1 x_4;</span>\n<span class=\"c1\">--  let x_6 : obj := List.mapTR.loop._rarg x_2 x_5 x_4;</span>\n<span class=\"c1\">--  ret x_</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">test_optimized_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">map_map</span><span class=\"o\">]</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Compiler</span><span class=\"bp\">.</span><span class=\"n\">compile</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"ss\">``test</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Compiler</span><span class=\"bp\">.</span><span class=\"n\">LCNF</span><span class=\"bp\">.</span><span class=\"n\">showDecl</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">base</span><span class=\"w\"> </span><span class=\"ss\">``test</span>\n\n<span class=\"c1\">--def test l g f : List Nat :=</span>\n<span class=\"c1\">--  let _x.1 := @List.mapTR _ _ f l;</span>\n<span class=\"c1\">--  let _x.2 := @List.mapTR _ _ g _x.1;</span>\n<span class=\"c1\">--  return _x.2</span>\n</code></pre></div>",
        "id": 524166368,
        "sender_full_name": "lean_user",
        "timestamp": 1750036437
    },
    {
        "content": "<p>Can you provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 524166547,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750036628
    },
    {
        "content": "<p>This is currently not supported</p>",
        "id": 524207383,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750063699
    },
    {
        "content": "<p>If you use iterators on the latest nightly, the two <code>map</code>s are fused, though you get an additional loop turning the array that is used internally back into a list. If you use arrays instead of lists, there will only be a single loop.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Iterators</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">compiler</span><span class=\"bp\">.</span><span class=\"n\">ir</span><span class=\"bp\">.</span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">((</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">iter</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">def Std.Iterators.IterM.DefaultConsumers.toArrayMapped.go._at.test._spec_2 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) : obj :=</span>\n<span class=\"cm\">  case x_3 : obj of</span>\n<span class=\"cm\">  List.nil →</span>\n<span class=\"cm\">    dec x_2;</span>\n<span class=\"cm\">    dec x_1;</span>\n<span class=\"cm\">    ret x_4</span>\n<span class=\"cm\">  List.cons →</span>\n<span class=\"cm\">    let x_5 : obj := proj[0] x_3;</span>\n<span class=\"cm\">    inc x_5;</span>\n<span class=\"cm\">    let x_6 : obj := proj[1] x_3;</span>\n<span class=\"cm\">    inc x_6;</span>\n<span class=\"cm\">    dec x_3;</span>\n<span class=\"cm\">    inc x_2;</span>\n<span class=\"cm\">    let x_7 : obj := app x_2 x_5;</span>\n<span class=\"cm\">    inc x_1;</span>\n<span class=\"cm\">    let x_8 : obj := app x_1 x_7;</span>\n<span class=\"cm\">    let x_9 : obj := Array.push ◾ x_4 x_8;</span>\n<span class=\"cm\">    let x_10 : obj := Std.Iterators.IterM.DefaultConsumers.toArrayMapped.go._at.test._spec_2 x_1 x_2 x_6 x_9;</span>\n<span class=\"cm\">    ret x_10</span>\n<span class=\"cm\">def test._closed_1 : obj :=</span>\n<span class=\"cm\">  let x_1 : obj := ctor_0[List.nil];</span>\n<span class=\"cm\">  let x_2 : obj := Array.mk ◾ x_1;</span>\n<span class=\"cm\">  ret x_2</span>\n<span class=\"cm\">def test (x_1 : obj) (x_2 : obj) (x_3 : obj) : obj :=</span>\n<span class=\"cm\">  let x_4 : obj := test._closed_1;</span>\n<span class=\"cm\">  let x_5 : obj := Std.Iterators.IterM.DefaultConsumers.toArrayMapped.go._at.test._spec_2 x_2 x_3 x_1 x_4;</span>\n<span class=\"cm\">  let x_6 : obj := Array.toList ◾ x_5;</span>\n<span class=\"cm\">  ret x_6</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 524209022,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1750064251
    }
]