[
    {
        "content": "<p>I was wandering through <a href=\"https://leanprover-community.github.io/mathlib4_docs/Batteries/Data/UnionFind/Basic.html\">https://leanprover-community.github.io/mathlib4_docs/Batteries/Data/UnionFind/Basic.html</a>, and it seems like</p>\n<ol>\n<li>The implementation does both path compression and union-by-rank, so it should have complexity <code>O(n …ë(n))</code>.</li>\n<li>There's no proof of this.</li>\n<li>Of course (2) has to be true, as there's no way of expressing the complexity of an algorithm written in Lean in the same file.</li>\n</ol>\n<p>Is (3) right? I suppose the best one could do is write a lifting macro that extracts a representation of the algorithm in some other data structure, then prove the complexity of that lift. But this would require assuming complexities for all primitive operations, so it would be quite a heavyweight lifting algorithm.</p>\n<p>I've done a few (way easier) proofs of complexity <a href=\"https://github.com/girving/debate/blob/bf4beb9b2fdd160e734b70b402547f267cb39fd4/Debate/Cost.lean#L131\">for the debate formalization</a>, but that was a much simpler setting where (1) the Lean code computed a monad representating the computation and (2) I was only counting oracle query complexity, not some broader class of primitive operations.</p>",
        "id": 453274822,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1721680669
    },
    {
        "content": "<p>Yes, all three points are true</p>",
        "id": 453275299,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721680908
    },
    {
        "content": "<p>My dream system for doing this would be to reflect on the lean <code>Expr</code> itself and have some complexity theory of lambda calculus evaluation over that representation</p>",
        "id": 453275437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721680973
    },
    {
        "content": "<blockquote>\n<p>But this would require assuming complexities for all primitive operations, so it would be quite a heavyweight lifting algorithm.</p>\n</blockquote>\n<p>Note that due to sharing, in particular of <code>Array</code> you'd have to either:</p>\n<ol>\n<li>Overestimate things like setting an array element with <code>O(n)</code> because it needs to be copied in the worst case</li>\n<li>Write a perfect linearity analysis system, in which case you have solved one of the most annoying issues that we have right now.</li>\n</ol>",
        "id": 453275479,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1721681004
    },
    {
        "content": "<p>and/or to have a compiler into a simpler language with explicit runtime accounting</p>",
        "id": 453275511,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721681027
    },
    {
        "content": "<p>Ouch, the sharing aspect is rough.</p>",
        "id": 453275599,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1721681056
    },
    {
        "content": "<p>But hey, overestimating with <code>O(n)</code> would still get you a correct <code>O(f(x))</code> in the end :P</p>",
        "id": 453275691,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1721681113
    },
    {
        "content": "<p>well no, you would not want to introduce an extra linear function on a function of inverse ackermann bound</p>",
        "id": 453275751,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721681144
    },
    {
        "content": "<p>I assume <span class=\"user-mention\" data-user-id=\"395550\">@Henrik B√∂ving</span> is saying that if you add in O(n) once it's fine.</p>",
        "id": 453275815,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1721681164
    },
    {
        "content": "<p>Indeed you can safely add it in 4 times before you exceed …ë(n).</p>",
        "id": 453275854,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1721681190
    },
    {
        "content": "<p>but it's not once, it's once per operation, i.e. it would completely dominate the actual contribution of the algorithm</p>",
        "id": 453275858,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721681192
    },
    {
        "content": "<p>one O(n) is already enough to beat O(alpha(n))</p>",
        "id": 453275893,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721681214
    },
    {
        "content": "<p>Right but since <code>O</code> is only an upper bound  it's fine to exceed</p>",
        "id": 453275898,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1721681216
    },
    {
        "content": "<p>You just won't get the results that you want, but you'll get technically correct results!</p>",
        "id": 453275960,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1721681248
    },
    {
        "content": "<p>I'm very confused, that's like saying it's fine if your binary search algorithm is O(n), that's not the theorem we wanted to prove</p>",
        "id": 453276009,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721681272
    },
    {
        "content": "<p>Yes of course you would not want to practically do that, but it would yield a correct result. I'm just making a silly joke.</p>",
        "id": 453276145,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1721681329
    },
    {
        "content": "<p>There is certainly a correct result that if I'm handed a UnionFind of size n, and I do n consecutive operations on it, then the overall complexity is <code>O(n …ë(n))</code>. Since at most the first operation copies.</p>\n<p>Still not following the joke, unfortunately. Unless it's some sort of cojoke.</p>",
        "id": 453276183,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1721681352
    },
    {
        "content": "<p>Anyway it's very likely true that a solution to automating complexity theory will solve our sharing issues, although that's true in the same sense as \"proving the correctness of the program will solve the problem of having bugs in the code\"</p>",
        "id": 453276258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721681397
    },
    {
        "content": "<p>As an aside, there is some cool recent work on internally expressing complexity in type theory, e.g. <a href=\"https://dl.acm.org/doi/10.1145/3498670\">calf</a> (a logical framework).</p>",
        "id": 453277758,
        "sender_full_name": "ùö†ùöòùöìùöåùöíùöéùöåùöë ùöóùöäùö†ùöõùöòùöåùöîùöí",
        "timestamp": 1721682073
    },
    {
        "content": "<p>I await the day when one of these lambda calculus based complexity models actually doesn't have polynomial blow ups of complexity over normal RAM model computations</p>",
        "id": 453281405,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721683907
    },
    {
        "content": "<p>Currently all this work happens entirely outside algorithms groups and nobody seems to ask the algorithmists or complexity theorists about what would be useful for them (hint: ALGOL like lightweight DSL with CLRS style annotations)</p>",
        "id": 453281561,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721683992
    },
    {
        "content": "<p>What's CLRS annotations?</p>",
        "id": 453281750,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1721684119
    },
    {
        "content": "<p>That's not a technical term. See how the famous CLRS book annotates pseudocode with complexity</p>",
        "id": 453281801,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721684153
    },
    {
        "content": "<p>Another point: I don't see how a solution to complexity theory can be automatic in Lean's current expression language since by funext, all algorithms which compute the same function are equal to each other regardless of complexity.</p>",
        "id": 453282151,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721684369
    },
    {
        "content": "<p>Arthur pointed this out last year on discord.</p>",
        "id": 453282207,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721684402
    },
    {
        "content": "<p>It is an entirely symmetrical but different problem that modern algorithms research doesn't explore the complexity of algorithms in functional language models. These lines of research are more or less in separate silos</p>",
        "id": 453282383,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721684511
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/Expressing.20complexity.20of.20algorithms.20in.20Lean/near/453281561\">said</a>:</p>\n<blockquote>\n<p>I await the day when one of these lambda calculus based complexity models actually doesn't have polynomial blow ups of complexity over normal RAM model computations</p>\n<p>Currently all this work happens entirely outside algorithms groups and nobody seems to ask the algorithmists or complexity theorists about what would be useful for them (hint: ALGOL like lightweight DSL with CLRS style annotations)</p>\n</blockquote>\n<p>Especially for the <code>Expr</code> version I mentioned above, the complexity model I'm most interested in is the one the lean compiler actually uses</p>",
        "id": 453282526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721684598
    },
    {
        "content": "<p>apart from that funext issue, that's actually the most useful model for lean (I guess some quantitative type theory is involved)</p>",
        "id": 453282955,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721684832
    },
    {
        "content": "<p>But that also means that we don't have the same complexity model in lean as algorithmists do and the results from there may not apply</p>",
        "id": 453283051,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721684883
    },
    {
        "content": "<p>Which is more or less fine for lean users</p>",
        "id": 453283092,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721684910
    },
    {
        "content": "<p>I say \"may not\" because there are several niches in algorithms theory which are not concerned with the complexity of evaluation of a lean function, only the number of certain function calls. This includes several query models and communication models.</p>",
        "id": 453283190,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721684980
    },
    {
        "content": "<p>It seems like the question is how long it takes and reasonable approximations thereof, not niche theory.</p>",
        "id": 453283340,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1721685050
    },
    {
        "content": "<p>What I mean is, <code>union find</code> might not be as efficient as you read in your undergrad algorithms textbook</p>",
        "id": 453283416,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721685106
    },
    {
        "content": "<p>If we care about oracle complexity, <a href=\"https://github.com/google-deepmind/debate/blob/d9ca51ac43e06a8bab5937c47e7c0c68387efea5/Comp/Defs.lean#L23\">https://github.com/google-deepmind/debate/blob/d9ca51ac43e06a8bab5937c47e7c0c68387efea5/Comp/Defs.lean#L23</a> works.</p>",
        "id": 453283499,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1721685137
    },
    {
        "content": "<p>Yes. I am formalizing a different line of work where computational complexity is irrelevant</p>",
        "id": 453283604,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721685204
    },
    {
        "content": "<p>Then you should use custom monads to express algorithms, and not complain that a thread about time complexity <em>of Lean code</em> would involve Lean details.</p>",
        "id": 453283734,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1721685271
    },
    {
        "content": "<p>I am not complaining. On the contrary, I think</p>\n<ol>\n<li>Mario's solution makes the most sense for lean code.</li>\n<li>Calling it algorithmic complexity might be misleading, in that it won't match traditional algorithms analysis. It isn't esoteric theory. In fact functional programming models are very esoteric as far as mainstream algorithms research goes.</li>\n</ol>",
        "id": 453284268,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721685595
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Expressing.20complexity.20of.20algorithms.20in.20Lean/near/453276009\">said</a>:</p>\n<blockquote>\n<p>I'm very confused, that's like saying it's fine if your binary search algorithm is O(n), that's not the theorem we wanted to prove</p>\n</blockquote>\n<p>You will get results like this (not this exactly, but similar blow ups in complexity) unless you somehow manage to ensure in place mutation everywhere you need it. Textbook algorithmic results may not apply as is.</p>",
        "id": 453285317,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721686131
    },
    {
        "content": "<p>A difficulty with working on lean's complexity model (let's call it that for now) will be coming up with the correct complexity asymptotics for theorem statements, especially as the lean functions get more complicated, since it is unlikely that lean itself will produce the final simplified asymptotic form.</p>",
        "id": 453287783,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721687282
    },
    {
        "content": "<p>I don't think this is a major issue. Textbook algorithms assume mutable data structures, and this maps straightforwardly to linear usage of mutable variables</p>",
        "id": 453313009,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721703746
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/Expressing.20complexity.20of.20algorithms.20in.20Lean/near/453285317\">said</a>:</p>\n<blockquote>\n<p>unless you somehow manage to ensure in place mutation everywhere you need it.</p>\n</blockquote>\n<p>Yes that's the point</p>",
        "id": 453313061,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721703810
    },
    {
        "content": "<p>I'd like my proof to actually show the absence of bugs thank you very much</p>",
        "id": 453313091,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721703834
    },
    {
        "content": "<p>that applies just as much to complexity bounds as correctness</p>",
        "id": 453313146,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721703852
    },
    {
        "content": "<p>if my program has a (sharing) bug in it I shouldn't be able to prove the theorem</p>",
        "id": 453313179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721703876
    },
    {
        "content": "<p>otherwise what's the point of the theorem?</p>",
        "id": 453313209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721703896
    },
    {
        "content": "<p>I'd love to be able to prove something along the lines of <code>(f : (Œ± : Type) ‚Üí [LinearOrder Œ±] ‚Üí (l : List Œ±) ‚Üí {l‚ÇÇ : List Œ± // l‚ÇÇ.Perm l ‚àß List.Sorted (¬∑ ‚â§ ¬∑) l‚ÇÇ}) ‚Üí (complexity f = Œ©(n log(n)))</code>. Is there any approach which could, in theory, allow for something like this?</p>",
        "id": 453316607,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721706066
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Expressing.20complexity.20of.20algorithms.20in.20Lean/near/453313091\">said</a>:</p>\n<blockquote>\n<p>I'd like my proof to actually show the absence of bugs thank you very much</p>\n</blockquote>\n<p>How would you make an asymptotically tight prediction to put into a theorem statement when predicting linearity is hard? Would it be trial and error?  Otherwise when a bound doesn't get proved, especially for complex ones, how would you determine whether the proof is stuck because of tactics or a false statement?</p>",
        "id": 453359857,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721724149
    },
    {
        "content": "<p>I don‚Äôt think Marco is expecting to have a perfect decision rule for complexity.</p>",
        "id": 453360569,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1721724416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/270676-lean4/topic/Expressing.20complexity.20of.20algorithms.20in.20Lean/near/453316607\">said</a>:</p>\n<blockquote>\n<p>I'd love to be able to prove something along the lines of <code>(f : (Œ± : Type) ‚Üí [LinearOrder Œ±] ‚Üí (l : List Œ±) ‚Üí {l‚ÇÇ : List Œ± // l‚ÇÇ.Perm l ‚àß List.Sorted (¬∑ ‚â§ ¬∑) l‚ÇÇ}) ‚Üí (complexity f = Œ©(n log(n)))</code>. Is there any approach which could, in theory, allow for something like this?</p>\n</blockquote>\n<p>This statement is flawed as is. You are parametrizing over f (and not using it, but that's maybe just a typo). For an upper bound you need a specific f. For a lower bound this is only true for functions based on swapping operations</p>",
        "id": 453360868,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721724505
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"514145\">Geoffrey Irving</span> <a href=\"#narrow/stream/270676-lean4/topic/Expressing.20complexity.20of.20algorithms.20in.20Lean/near/453360569\">said</a>:</p>\n<blockquote>\n<p>I don‚Äôt think Marco is expecting to have a perfect decision rule for complexity.</p>\n</blockquote>\n<p>It isn't about perfection. These complexity recurrences can quickly get ugly and require some combinatorial theorems and clever application of inequalities and approximations to simplify into a reasonable shape</p>",
        "id": 453361253,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721724604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/Expressing.20complexity.20of.20algorithms.20in.20Lean/near/453360868\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/270676-lean4/topic/Expressing.20complexity.20of.20algorithms.20in.20Lean/near/453316607\">said</a>:</p>\n<blockquote>\n<p>I'd love to be able to prove something along the lines of <code>(f : (Œ± : Type) ‚Üí [LinearOrder Œ±] ‚Üí (l : List Œ±) ‚Üí {l‚ÇÇ : List Œ± // l‚ÇÇ.Perm l ‚àß List.Sorted (¬∑ ‚â§ ¬∑) l‚ÇÇ}) ‚Üí (complexity f = Œ©(n log(n)))</code>. Is there any approach which could, in theory, allow for something like this?</p>\n</blockquote>\n<p>This statement is flawed as is. You are parametrizing over f (and not using it, but that's maybe just a typo). For an upper bound you need a specific f. For a lower bound this is only true for functions based on swapping operations</p>\n</blockquote>\n<p>I am using it, in <code>complexity f = Œ©(n log(n))</code>. Why is this lower bound not true, for arbitrary <code>Œ±</code> whose only interface is the linear order instance? Can you do anything other than comparisons?</p>",
        "id": 453371599,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721727472
    },
    {
        "content": "<p>Radix sort</p>",
        "id": 453386881,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721732514
    },
    {
        "content": "<p>Your lower bound is only true for comparison sorts I.e. a model where you can access the array in the following two ways:</p>\n<ol>\n<li>Given two indices <code>i</code> and <code>j</code>, you make a compare(i,j) query  and  get the comparison of the corresponding elements.</li>\n<li>Given two indices, you call a swap query to swap(i,j) the elements in those indices.</li>\n</ol>",
        "id": 453387570,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721732750
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/Expressing.20complexity.20of.20algorithms.20in.20Lean/near/453386881\">said</a>:</p>\n<blockquote>\n<p>Radix sort</p>\n</blockquote>\n<p>or for an easier example, counting sort, but indeed any other sorting algorithm in that family. As <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> is saying you will need to either specify in a lot more detail what <code>f</code> does (in a way that I think is far from trivial in lean) or much more likely (and easily) prove your result for a specific implementation of a specific algorithm</p>",
        "id": 453388337,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1721733019
    },
    {
        "content": "<p>But <code>f</code> takes the type ‚Äî it can't depend on it being <code>Nat</code>, for instance</p>",
        "id": 453389623,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721733333
    },
    {
        "content": "<p>That's beside the point. You can generalize it to all hashable types by constructing a suitable hash function with low collision probability. Further, the specific theorem you are going for wouldn't apply as such. You need a way to restrict operations to a three-way comparison and swaps on indices. If any other operation were to be involved, for instance, even being able to access the array element, then you can do sorting in an external bucket array.</p>",
        "id": 453391292,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721733913
    },
    {
        "content": "<p>Also, currently in Lean, you can do something like the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Complexity</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- assume f and g both compute the same function with different complexities</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h_ext</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\">  </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ch</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Complexity</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Complexity</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"n\">h_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">h_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">ch</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ch</span>\n</code></pre></div>",
        "id": 453392509,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721734347
    },
    {
        "content": "<p>so you <code>f</code> could be radix sort, <code>g</code> could be merge sort. You could prove radix sort is linear time and then use the above trick to \"prove\" that merge sort is linear time.</p>",
        "id": 453392858,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721734490
    },
    {
        "content": "<p>your only way to prove this lower bound is to build a mini DSL that only lets you perform three way comparisons  and swaps on elements at a given pair of indices, interpret them on a given array, prove that a proper sorting algorithm in this DSL indeed sorts and that it needs <code>\\Omega(n log n)</code> swaps to do this.</p>",
        "id": 453393921,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721734878
    },
    {
        "content": "<p>A neat trick to generalise this DSL could be to parametrise a DSL with a type that represents all the basic operations allowed. Then you could do proofs in several kinds of query models and perhaps even some RAM models (at least as far as time complexity goes).</p>",
        "id": 453394151,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721734965
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/270676-lean4/topic/Expressing.20complexity.20of.20algorithms.20in.20Lean/near/453371599\">said</a>:</p>\n<blockquote>\n<p>I am using it, in <code>complexity f = Œ©(n log(n))</code>. Why is this lower bound not true, for arbitrary <code>Œ±</code> whose only interface is the linear order instance? Can you do anything other than comparisons?</p>\n</blockquote>\n<p>Yeah but where is the evidence that the sorting was done using <code>f</code>.</p>",
        "id": 453394461,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721735075
    },
    {
        "content": "<p>What do you mean? <code>f</code> by its type must be a sorting function, and I do not see how you can have a sensible complexity measure where the statement \"if you have a function which takes an arbitrarily typed list then its worst case time for a list of size n is Omega(n log(n))\". Do you have an example of such a function?</p>",
        "id": 453402554,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721737706
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/Expressing.20complexity.20of.20algorithms.20in.20Lean/near/453392509\">said</a>:</p>\n<blockquote>\n<p>Also, currently in Lean, you can do something like the following:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Complexity</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- assume f and g both compute the same function with different complexities</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h_ext</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\">  </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ch</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Complexity</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Complexity</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"n\">h_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">h_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">ch</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ch</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Yes, this is a problem, but my type was just an illustration ‚Äî the actual type can be <code>Algorithm `(a : Type) &lt;| Algorithm `([LinearOrder a]) &lt;| Algorithm `(List a) &lt;| ... </code> or something along those lines</p>",
        "id": 453403326,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721737837
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/Expressing.20complexity.20of.20algorithms.20in.20Lean/near/453391292\">said</a>:</p>\n<blockquote>\n<p>That's beside the point. You can generalize it to all hashable types by constructing a suitable hash function with low collision probability. Further, the specific theorem you are going for wouldn't apply as such. You need a way to restrict operations to a three-way comparison and swaps on indices. If any other operation were to be involved, for instance, even being able to access the array element, then you can do sorting in an external bucket array.</p>\n</blockquote>\n<p>Have you noticed that the type of <code>f</code> is <code>(Œ± : Type) ‚Üí [LinearOrder Œ±] ‚Üí (l : List Œ±) ‚Üí {l‚ÇÇ : List Œ± // l‚ÇÇ.Perm l ‚àß List.Sorted (¬∑ ‚â§ ¬∑) l‚ÇÇ}</code>? How could any other operation on <code>Œ±</code> be involved, when the only data <code>f</code> gets regarding it is the linear order instance?</p>",
        "id": 453404024,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721738022
    },
    {
        "content": "<p>In this case you have a <code>List a</code> so you can use every trick about <code>List</code> that we have available to us.</p>",
        "id": 453404295,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1721738102
    },
    {
        "content": "<p>Yes, you could call <code>List.mergeSort</code> for instance, but I'm assuming <code>complexity</code> also counts the runtime of functions you call</p>",
        "id": 453404825,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721738282
    },
    {
        "content": "<p>You are looking for an array lower bound. Not a list lower bound</p>",
        "id": 453420641,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721742524
    },
    {
        "content": "<p>What is the difference?</p>",
        "id": 453424767,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721743711
    },
    {
        "content": "<p>element access time given an index</p>",
        "id": 453424940,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721743762
    },
    {
        "content": "<p>To clarify the lower bound itself is independent of the underlying data structures, but in a lean proof using lists or arrays the differences could matter. You would use different lemmas. With my query model you could bundle both the proofs into one.</p>",
        "id": 453425766,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721744038
    },
    {
        "content": "<p>Further, to answer your question about model/complexity measure, pointer machines are supposed to be able to sort in linear time.</p>",
        "id": 453426228,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721744165
    },
    {
        "content": "<p><a href=\"https://dl.acm.org/doi/abs/10.1007/BF01936140\">https://dl.acm.org/doi/abs/10.1007/BF01936140</a></p>",
        "id": 453426254,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721744174
    },
    {
        "content": "<p>As for your proposal with an <code>Algorithm</code> typeclass, it will only work if you have a way of distinguishing between different algorithms, otherwise you will still find yourself running into the issue I illustrated. Whence the DSL. Btw, this was discussed last year in a thread in the <a class=\"stream\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general\">#general</a> channel.</p>",
        "id": 453426698,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721744315
    },
    {
        "content": "<p>I need to check out of this discussion now, but I'd be happy to hear about any developments on algorithms complexity formalisation in any reasonable model.</p>",
        "id": 453426890,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721744398
    },
    {
        "content": "<p>It is true that mergeSort is <code>O(n log n)</code> and this is optimal, BTW:</p>\n<ol>\n<li><a href=\"https://github.com/girving/debate/blob/f5a4cf1692c9d501c7a922081dc3cf3965e57802/Comp/Sort.lean#L447\">Lower bound</a></li>\n<li><a href=\"https://github.com/girving/debate/blob/f5a4cf1692c9d501c7a922081dc3cf3965e57802/Comp/Sort.lean#L174\">Upper bound</a></li>\n</ol>",
        "id": 462853941,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1723840962
    },
    {
        "content": "<p>Very nice</p>",
        "id": 462854008,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1723841011
    },
    {
        "content": "<p>I know this is an old thread and Geoffrey has a nice solution already; but does this approach work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! Step one: define the operations that you wish to count-/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MonadicLE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">leM</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! Step two: implement your abstract computation using only this monadic interface. -/</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadicLE</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">MonadicLE</span><span class=\"bp\">.</span><span class=\"n\">leM</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mergeSort</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">MergeSort</span><span class=\"bp\">.</span><span class=\"n\">Internal</span><span class=\"bp\">.</span><span class=\"n\">splitInTwo</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">‚ü©</span>\n<span class=\"w\">    </span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">mergeSort</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">mergeSort</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! Step three: implement the typeclass to compute your cost function. -/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">MonadicLE</span><span class=\"bp\">.</span><span class=\"n\">ofDecidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">MonadicLE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">StateM</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">leM</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">modify</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>",
        "id": 500968258,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740085203
    },
    {
        "content": "<p>FWIW, I discussed the query approach with someone who has done algorithms formalisation in Isabelle and he suggested that having a more systematic combinator language around queries would bring uniformity and clarity to the algorithm specifications.</p>",
        "id": 500968498,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1740085291
    },
    {
        "content": "<p>Clearly you can instantiate <code>MonadicLE (DComp ..)</code> using <span class=\"user-mention\" data-user-id=\"514145\">@Geoffrey Irving</span>'s construction, so this approach certianly works for writing down the algorithm; though maybe you still need <code>Comp</code>/<code>DComp</code> to state anything nicely</p>",
        "id": 500968502,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740085292
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/270676-lean4/topic/Expressing.20complexity.20of.20algorithms.20in.20Lean/near/500968498\">said</a>:</p>\n<blockquote>\n<p>and he suggested that having a more systematic combinator language around queries</p>\n</blockquote>\n<p>I guess my claim is that you can just write out all your possible queries as fields of a typeclass, and use a regular monad for the combinators.</p>",
        "id": 500968708,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740085359
    },
    {
        "content": "<p>This also handles things like <span class=\"user-mention\" data-user-id=\"514145\">@Geoffrey Irving</span>'s debate protocol, where some functions in your system only have access to subsets of the queries; you build a typeclass hierarchy, and instead of needing <code>allow</code> and <code>allowAll</code> to call a few-query-permitted algorithm in a many-query-permitted algorithm, you just let typeclass inference run.</p>",
        "id": 500968961,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740085451
    },
    {
        "content": "<p>My idea differs from Geoffrey in that it clearly syntactically separates calls to queries from other operations . </p>\n<p>I also discussed the combinator approach with people at ICFP (including Joachim) and one thing that struck us is that perhaps we could automate some of the parts related to deducing complexity recurrences and use external tools like sage to simplify them</p>",
        "id": 500969084,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1740085507
    },
    {
        "content": "<p>The weakness is that it would take some effort to achieve the same level of expressivity that Geoffrey‚Äôs approach gets for free from lean</p>",
        "id": 500969188,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1740085552
    },
    {
        "content": "<p>I don't understand either what the claimed idea of yours is, or why you want queries to be syntactically differentiated beyond the way that <code>‚Üê</code> already distinguishes monadic operations in Geoffrey's approach.</p>",
        "id": 500969444,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740085630
    },
    {
        "content": "<p>What stops me from non monadically calling the operations that the queries perform?</p>",
        "id": 500969752,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1740085753
    },
    {
        "content": "<p>And hide them deep in the algorithm</p>",
        "id": 500969791,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1740085770
    },
    {
        "content": "<p>So that someone has to carefully read everything to spot it</p>",
        "id": 500969813,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1740085783
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/Expressing.20complexity.20of.20algorithms.20in.20Lean/near/500969752\">said</a>:</p>\n<blockquote>\n<p>What stops me from non monadically calling the operations that the queries perform?</p>\n</blockquote>\n<p>The type of your function doesn't provide you access to those operations, as it's general over types and monads, without mentioning the relation or the counting monad.</p>",
        "id": 500970521,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740086058
    },
    {
        "content": "<p>But maybe that argument doesn't work with choice, since a function can use <code>if m = StateM Nat then ...</code></p>",
        "id": 500970645,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740086125
    },
    {
        "content": "<p>One can always lift pure functions into the monadic world.</p>",
        "id": 500973092,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1740087210
    }
]