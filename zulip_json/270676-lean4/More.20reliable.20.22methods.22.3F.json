[
    {
        "content": "<p>I really like the way that \"method call\" syntax works in Lean, with the type of the argument before the dot supplying a namespaces in which to find the function.</p>\n<p>However, there are three difficulties that arise from the fact that the user isn't saying that this is precisely what they're intending:</p>\n<ol>\n<li>Moving a type to a new namespace will break use sites, rather than definition sites, of these \"methods\"</li>\n<li>A typo in a definition's namespace will make it silently uncallable, again affecting use sites rather than definition sites</li>\n<li>To add a \"method\" while working in some other namespace, one must either write a fully-qualified name with <code>_root_</code> at the beginning or end the namespace and restart it. While this may be an advantage in that it reduces confusing file structures, it can get in the way of intense code binges :)</li>\n</ol>\n<p>I think the following metaprogram that I put together this morning addresses all of these:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.GuardMsgs</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Where.Does.This.Go</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Parser</span> <span class=\"n\">Elab</span> <span class=\"n\">Command</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">method</span> <span class=\"o\">:=</span> <span class=\"n\">leading_parser</span>\n  <span class=\"n\">declModifiers</span> <span class=\"n\">false</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"s2\">\"defmethod \"</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">declId</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">ppIndent</span> <span class=\"n\">optDeclSig</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">declVal</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">optDefDeriving</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">terminationSuffix</span>\n\n<span class=\"sd\">/-- Like 'def', except the namespace is resolved to an existing unique</span>\n<span class=\"sd\">name, and the resulting name is defined in that namespace.</span>\n\n<span class=\"sd\">In particular, `defmethod A.B.f ...` first resolves `A.B`. If there is</span>\n<span class=\"sd\">a unique resolution, say `Lib.More.A.B`, then it is equivalent to</span>\n<span class=\"sd\">`def Lib.More.A.B.f ...`. If there is no unique resolution, it is an</span>\n<span class=\"sd\">error.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">methodDecl</span><span class=\"o\">)</span> <span class=\"n\">method</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">_root_.Lean.Syntax.args</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">→</span> <span class=\"n\">Array</span> <span class=\"n\">Syntax</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">args</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">args</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">command_elab</span> <span class=\"n\">methodDecl</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabMethodDecl</span> <span class=\"o\">:</span> <span class=\"n\">CommandElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">ident</span> <span class=\"o\">:=</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">][</span><span class=\"mi\">2</span><span class=\"o\">][</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">ident</span> <span class=\"n\">origInfo</span> <span class=\"n\">origSubstr</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">ident</span>\n    <span class=\"bp\">|</span> <span class=\"n\">throwErrorAt</span> <span class=\"n\">ident</span> <span class=\"s2\">\"Expected identifier\"</span>\n  <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">str</span> <span class=\"n\">ns</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">str</span> <span class=\"bp\">..</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n    <span class=\"bp\">|</span> <span class=\"n\">throwErrorAt</span> <span class=\"n\">ident</span> <span class=\"s2\">\"Expected definable identifier with namespace\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">options</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">resolveGlobalName</span> <span class=\"n\">ns</span> <span class=\"o\">:</span> <span class=\"n\">CommandElabM</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"k\">match</span> <span class=\"n\">options</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwErrorAt</span> <span class=\"n\">ident</span> <span class=\"s2\">\"'{ns}' not found\"</span>\n  <span class=\"bp\">|</span> <span class=\"n\">found</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">::</span> <span class=\"n\">_</span> <span class=\"o\">::</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">exprs</span> <span class=\"bp\">←</span> <span class=\"n\">liftTermElabM</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">found.mapM</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">i'</span> <span class=\"o\">:=</span> <span class=\"n\">mkCIdent</span> <span class=\"n\">i</span>\n      <span class=\"n\">Term.elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">i'</span> <span class=\"o\">))</span> <span class=\"n\">none</span>\n    <span class=\"k\">let</span> <span class=\"n\">names</span> <span class=\"o\">:</span> <span class=\"n\">MessageData</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">group</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">.</span><span class=\"n\">joinSep</span> <span class=\"o\">(</span><span class=\"n\">exprs.map</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">ofFormat</span> <span class=\"bp\">.</span><span class=\"n\">line</span> <span class=\"bp\">++</span> <span class=\"n\">toMessageData</span> <span class=\"bp\">·</span><span class=\"o\">))</span> <span class=\"s2\">\",\"</span>\n    <span class=\"n\">throwErrorAt</span> <span class=\"n\">ident</span> <span class=\"s2\">\"'{ns}' is ambiguous - found:{names}</span><span class=\"se\">\\n\\n</span><span class=\"s2\">Please write a more specific namespace.\"</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[(</span><span class=\"n\">resolved</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)]</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">withNewName</span> <span class=\"o\">:=</span> <span class=\"n\">stx.modifyArg</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">modifyArg</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">modifyArg</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">ident</span> <span class=\"n\">origInfo</span> <span class=\"n\">origSubstr</span> <span class=\"o\">(</span><span class=\"n\">unambiguous</span> <span class=\"n\">resolved</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">[])))</span>\n    <span class=\"k\">let</span> <span class=\"n\">decl</span> <span class=\"bp\">←</span> <span class=\"n\">withNewName.replaceM</span> <span class=\"k\">fun</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">atom</span> <span class=\"n\">info</span> <span class=\"s2\">\"defmethod\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">atom</span> <span class=\"n\">info</span> <span class=\"s2\">\"def\"</span><span class=\"o\">))</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">info</span> <span class=\"bp\">``</span><span class=\"n\">method</span> <span class=\"n\">args</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">info</span> <span class=\"bp\">``</span><span class=\"n\">Parser.Command.declaration</span> <span class=\"n\">args</span><span class=\"o\">))</span>\n      <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">none</span>\n    <span class=\"k\">let</span> <span class=\"n\">decl'</span> <span class=\"o\">:=</span> <span class=\"kn\">open</span> <span class=\"n\">Parser.Command</span> <span class=\"k\">in</span>\n      <span class=\"n\">Syntax.node</span> <span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"bp\">``</span><span class=\"n\">declaration</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">decl</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">][</span><span class=\"mi\">0</span><span class=\"o\">],</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"bp\">``«</span><span class=\"kd\">def</span><span class=\"bp\">»</span> <span class=\"n\">decl</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">args</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"mi\">7</span><span class=\"o\">]]</span>\n    <span class=\"n\">elabCommand</span> <span class=\"n\">decl'</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">inRoot</span> <span class=\"o\">:</span> <span class=\"n\">Name</span> <span class=\"bp\">→</span> <span class=\"n\">Name</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">anonymous</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">str</span> <span class=\"bp\">.</span><span class=\"n\">anonymous</span> <span class=\"s2\">\"_root_\"</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">str</span> <span class=\"n\">ns</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">str</span> <span class=\"o\">(</span><span class=\"n\">inRoot</span> <span class=\"n\">ns</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">num</span> <span class=\"n\">ns</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">num</span> <span class=\"o\">(</span><span class=\"n\">inRoot</span> <span class=\"n\">ns</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n  <span class=\"n\">unambiguous</span> <span class=\"o\">(</span><span class=\"n\">ns</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Name</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">.</span><span class=\"n\">str</span> <span class=\"o\">(</span><span class=\"n\">inRoot</span> <span class=\"n\">ns</span><span class=\"o\">)</span> <span class=\"n\">y</span>\n  <span class=\"n\">replaceIdent</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">→</span> <span class=\"n\">CommandElabM</span> <span class=\"n\">Syntax</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ident</span> <span class=\"n\">info</span> <span class=\"n\">str</span> <span class=\"n\">_</span> <span class=\"n\">preres</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">.</span><span class=\"n\">ident</span> <span class=\"n\">info</span> <span class=\"n\">str</span> <span class=\"n\">n</span> <span class=\"n\">preres</span>\n    <span class=\"bp\">|</span> <span class=\"n\">other</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwErrorAt</span> <span class=\"n\">other</span> <span class=\"s2\">\"Not an identifier: {other}\"</span>\n\n\n<span class=\"kn\">namespace</span> <span class=\"n\">A.B.C</span>\n  <span class=\"kd\">structure</span> <span class=\"n\">D</span> <span class=\"n\">where</span>\n    <span class=\"n\">field</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n  <span class=\"kd\">structure</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n    <span class=\"n\">notReallyList</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"kd\">end</span> <span class=\"n\">A.B.C</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Other</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">A.B.C</span>\n\n\n<span class=\"n\">defmethod</span> <span class=\"n\">D.double</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"n\">D</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">*</span><span class=\"mi\">2</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">error: 'List' is ambiguous - found: A.B.C.List, _root_.List</span>\n\n<span class=\"sd\">Please write a more specific namespace.</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span> <span class=\"k\">in</span>\n<span class=\"n\">defmethod</span> <span class=\"n\">List.wat</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Other</span>\n\n<span class=\"sd\">/-- info: { field := 6 } -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span> <span class=\"k\">in</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">A.B.C.D.mk</span> <span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">double</span>\n</code></pre></div>\n<p>What do you think?</p>",
        "id": 398868324,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1698401694
    },
    {
        "content": "<p>I like it, although the keyword name could use some work. I might also more clearly separate the namespace from the method name to make it clear that they are being parsed separately</p>",
        "id": 398874723,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698404234
    },
    {
        "content": "<p>how about </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"o\">(</span><span class=\"k\">in</span> <span class=\"n\">List</span><span class=\"o\">)</span> <span class=\"n\">wat</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n</code></pre></div>",
        "id": 398874828,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698404283
    },
    {
        "content": "<p>that also makes it easier to generalize to <code>theorem</code>, <code>opaque</code> etc</p>",
        "id": 398874930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698404322
    },
    {
        "content": "<p>I think I like my bike shed color a bit better than this one, but I appreciate the point about generalizability. Perhaps another solution would be a modifier, rather than a new declaration form.</p>",
        "id": 398878661,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1698405701
    },
    {
        "content": "<p>I think keyword proliferation is worth avoiding. People already have trouble with <code>def</code>/<code>theorem</code> (and what on earth is <code>lemma</code>? :-), and we've coped flak for our cornucopia of brackets <code>() {} [] {{}} ‹› «»</code>.</p>",
        "id": 398879354,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1698405984
    },
    {
        "content": "<p>If the set of definition modifiers were extensible then this would fit in nicely, now that I think about it more</p>",
        "id": 398914415,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1698418588
    },
    {
        "content": "<p>Could this be implemented with a command? You'd have <code>in_namespace ident command</code> to evaluate <code>command</code> within the namespace specified by <code>ident</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">in_namespace</span> <span class=\"n\">List</span>\n<span class=\"kd\">def</span> <span class=\"n\">wat</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n</code></pre></div>",
        "id": 398947468,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698430498
    },
    {
        "content": "<p>That way you don't have to touch the <code>def</code> command, and it generalizes to all defining commands.</p>",
        "id": 398947703,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698430585
    },
    {
        "content": "<p>That could work too, I suppose :-)</p>",
        "id": 398989871,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1698455132
    },
    {
        "content": "<p>maybe something like <code>namespace for List</code> that checks that List is an inductive type, and then gets into its namespace?</p>",
        "id": 398990022,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1698455198
    },
    {
        "content": "<blockquote>\n<p>that checks that List is an inductive type</p>\n</blockquote>\n<p>Why would you check for this? You can use dot notation on any type.</p>",
        "id": 399009967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698468177
    },
    {
        "content": "<p>I think having <code>in_namespace Foo</code> do magic name resolution but <code>namespace Foo in</code> not do so will be very confusing</p>",
        "id": 399012636,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698470109
    },
    {
        "content": "<p>A more radical fix here would be \"<code>namespace Foo</code> must be predeclared before using <code>def Foo.bar</code>\", where predeclared means you used either <code>namespace Foo</code> or a declaration <code>Foo</code> is in the environment.</p>",
        "id": 399012771,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698470248
    },
    {
        "content": "<p>Or maybe even just the second condition, replacing the first with a <code>new_namespace</code> command to really avoid any accidents</p>",
        "id": 399012875,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698470324
    },
    {
        "content": "<p>Namespace declarations would be great, that would solve the problem of where to make go to def on <code>namespace</code>/<code>open</code> commands go, add hover docs, as well as avoiding misspelling problems</p>",
        "id": 399013339,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698470791
    },
    {
        "content": "<p>but it would be a somewhat disruptive breaking change to require</p>",
        "id": 399013511,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698470916
    },
    {
        "content": "<p>On the other hand, I'm not sure I would want <code>namespace Foo</code> to do regular name resolution for <code>Foo</code>, because this would make it more difficult to determine what namespace is being selected, which makes it harder to understand where definitions in the namespace went, which affects downstream <code>open</code> declarations, etc. That is, you would have to unravel quite a bit to do name resolution \"by hand\", which impacts readability of lean code outside the editor (and even in it, when using the sticky header feature for determining the current file namespace)</p>",
        "id": 399013972,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698471323
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"354934\">@David Thrane Christiansen</span> I hacked together an <code>in_namespace_for</code> command, and in your example <code>in_namespace_for D def double : D → D | ⟨n⟩ =&gt; ⟨n*2⟩</code> defines a function <code>A.B.C.D.double</code>. Your point number 1 in your first message I think is important (make it so moving <code>D</code> is likely to break definition sites).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.GuardMsgs</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Lean.Elab.Command</span>\n\n<span class=\"sd\">/-- Resolves the given name and runs the command within that resolved name's namespace. -/</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"in_namespace_for \"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"n\">cmd</span><span class=\"o\">:</span><span class=\"n\">command</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">ns</span> <span class=\"bp\">←</span> <span class=\"n\">resolveGlobalConstNoOverloadWithInfo</span> <span class=\"n\">n</span>\n  <span class=\"k\">let</span> <span class=\"n\">nscopes</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getScopes</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n  <span class=\"n\">modify</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span>\n    <span class=\"n\">env</span> <span class=\"o\">:=</span> <span class=\"n\">s.env.registerNamespace</span> <span class=\"n\">ns</span><span class=\"o\">,</span>\n    <span class=\"n\">scopes</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">s.scopes.head</span><span class=\"bp\">!</span> <span class=\"k\">with</span> <span class=\"n\">header</span> <span class=\"o\">:=</span> <span class=\"s2\">\"\"</span><span class=\"o\">,</span> <span class=\"n\">currNamespace</span> <span class=\"o\">:=</span> <span class=\"n\">ns</span><span class=\"o\">}</span> <span class=\"o\">::</span> <span class=\"n\">s.scopes</span>\n  <span class=\"o\">}</span>\n  <span class=\"n\">pushScope</span>\n  <span class=\"n\">activateScoped</span> <span class=\"n\">ns</span>\n  <span class=\"n\">try</span>\n    <span class=\"n\">elabCommand</span> <span class=\"n\">cmd</span>\n  <span class=\"n\">finally</span>\n    <span class=\"n\">unless</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getScopes</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">==</span> <span class=\"n\">nscopes</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"k\">do</span>\n      <span class=\"n\">throwError</span> <span class=\"s2\">\"Command should not alter scopes\"</span>\n    <span class=\"n\">modify</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">scopes</span> <span class=\"o\">:=</span> <span class=\"n\">s.scopes.drop</span> <span class=\"mi\">1</span> <span class=\"o\">}</span>\n    <span class=\"n\">popScope</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Lean.Elab.Command</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">A.B.C</span>\n  <span class=\"kd\">structure</span> <span class=\"n\">D</span> <span class=\"n\">where</span>\n    <span class=\"n\">field</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n  <span class=\"kd\">structure</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n    <span class=\"n\">notReallyList</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"kd\">end</span> <span class=\"n\">A.B.C</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Other</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">A.B.C</span>\n\n<span class=\"n\">in_namespace_for</span> <span class=\"n\">D</span> <span class=\"kd\">def</span> <span class=\"n\">double</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"n\">D</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">*</span><span class=\"mi\">2</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/-- error: ambiguous identifier '`List', possible interpretations: [A.B.C.List, List] -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span> <span class=\"k\">in</span>\n<span class=\"n\">in_namespace_for</span> <span class=\"n\">List</span> <span class=\"kd\">def</span> <span class=\"n\">wat</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Other</span>\n\n<span class=\"sd\">/-- info: { field := 6 } -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span> <span class=\"k\">in</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">A.B.C.D.mk</span> <span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">double</span>\n</code></pre></div>",
        "id": 399051833,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698500238
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"354934\">@David Thrane Christiansen</span> It turns out mathlib has a command for running another command within a namespace. With it, there's a quick implementation of this (with slightly different characteristics as my other one):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Util.WithWeakNamespace</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Lean.Elab.Command</span>\n\n<span class=\"sd\">/-- `in_namespace_for ident cmd` resolves the identifier and runs the command</span>\n<span class=\"sd\">within that resolved identifier's namespace. -/</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"in_namespace_for \"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"n\">cmd</span><span class=\"o\">:</span><span class=\"n\">command</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">ns</span> <span class=\"o\">:=</span> <span class=\"n\">rootNamespace</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">resolveGlobalConstNoOverloadWithInfo</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"n\">elabCommand</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span> <span class=\"n\">with_weak_namespace</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"n\">ns</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">cmd</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Lean.Elab.Command</span>\n</code></pre></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code with examples</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.GuardMsgs</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Util.WithWeakNamespace</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Lean.Elab.Command</span>\n\n<span class=\"sd\">/-- `in_namespace_for ident cmd` resolves the identifier and runs the command</span>\n<span class=\"sd\">within that resolved identifier's namespace. -/</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"in_namespace_for \"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"n\">cmd</span><span class=\"o\">:</span><span class=\"n\">command</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">ns</span> <span class=\"o\">:=</span> <span class=\"n\">rootNamespace</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">resolveGlobalConstNoOverloadWithInfo</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"n\">elabCommand</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span> <span class=\"n\">with_weak_namespace</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"n\">ns</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">cmd</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Lean.Elab.Command</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">A.B.C</span>\n  <span class=\"kd\">structure</span> <span class=\"n\">D</span> <span class=\"n\">where</span>\n    <span class=\"n\">field</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n  <span class=\"kd\">structure</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n    <span class=\"n\">notReallyList</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"kd\">end</span> <span class=\"n\">A.B.C</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Other</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">A.B.C</span>\n\n<span class=\"n\">in_namespace_for</span> <span class=\"n\">D</span> <span class=\"kd\">def</span> <span class=\"n\">double</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"n\">D</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">*</span><span class=\"mi\">2</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/-- error: ambiguous identifier '`List', possible interpretations: [A.B.C.List, List] -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span> <span class=\"k\">in</span>\n<span class=\"n\">in_namespace_for</span> <span class=\"n\">List</span> <span class=\"kd\">def</span> <span class=\"n\">wat</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Other</span>\n\n<span class=\"sd\">/-- info: { field := 6 } -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span> <span class=\"k\">in</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">A.B.C.D.mk</span> <span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">double</span>\n</code></pre></div>\n</div></div>",
        "id": 399819556,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698881981
    },
    {
        "content": "<p>This is indeed a nice way to do it!</p>",
        "id": 400415506,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1699210379
    }
]