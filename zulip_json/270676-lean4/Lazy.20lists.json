[
    {
        "content": "<p>What is the canonical way to get lazy lists?<br>\nHere's an example that I need: Suppose I have a <code>l : List Nat</code>, and some (decidable but slow) predicate <code>P : Nat -&gt; Nat -&gt; Bool</code>. I have a lean proof that <code>P a b</code> is satisfied for some <code>a b</code> in <code>l</code>, and a paper proof that <code>a</code> must be one of the first 10 elements of <code>l</code>. How can I find any such <code>a b</code>? If I had lazy list I could write <code>((l ×ˢ l).filter P).head sorry</code> which will only call <code>P</code> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>10</mn><mi mathvariant=\"normal\">∣</mi><mi>L</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">10|L|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">10∣</span><span class=\"mord mathnormal\">L</span><span class=\"mord\">∣</span></span></span></span> times at most, but I have the impression that this is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>L</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">|L|^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\">L</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> in lean.</p>",
        "id": 514894157,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1745870472
    },
    {
        "content": "<p>You could just call <code>List.find?</code> instead of filter</p>",
        "id": 514897266,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1745871769
    },
    {
        "content": "<p>Thanks! I see. But I guess this is my bad in simplifying my example too much. <br>\nIn my actual application I have such a function</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">differences</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">li</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">li</span><span class=\"w\"> </span><span class=\"bp\">×ˢ</span><span class=\"w\"> </span><span class=\"n\">li</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filterMap</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flatten</span>\n</code></pre></div>\n<p>And I want a performant implementation of <code>l.differences.dedup.length == 1</code> if I know that each element will appear at most 10 times and that each <code>(l[i]).Nodup</code>.</p>",
        "id": 514901491,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1745873415
    },
    {
        "content": "<p>But side question: how does <code>List.find?</code> avoid the problem? <br>\nDoes <code>(l ×ˢ l).find? P</code> not evaluate <code>l ×ˢ l</code> first?</p>",
        "id": 514902773,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1745873944
    },
    {
        "content": "<p>Sure but it won't evaluated <code>P</code> that many times, if you also want to avoid that you could use a double for loop instead.</p>",
        "id": 514903347,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1745874140
    },
    {
        "content": "<p>Using for loops for the application above, I now have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">differences</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">li</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">li</span><span class=\"w\"> </span><span class=\"bp\">×ˢ</span><span class=\"w\"> </span><span class=\"n\">li</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filterMap</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flatten</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">differencesDedupLengthLEOne?</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">thing</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">flag</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">li</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">li</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">li</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&gt;=</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">continue</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">flag</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">          </span><span class=\"n\">flag</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">          </span><span class=\"n\">thing</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">        </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">thing</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">          </span><span class=\"n\">continue</span>\n<span class=\"w\">        </span><span class=\"k\">else</span>\n<span class=\"w\">          </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">differences</span><span class=\"bp\">.</span><span class=\"n\">dedup</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">differencesDedupLengthLEOne?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Is this the intended way? I'll be sad if I am forced to do imperative programming in a FP language, and I have no idea how hard the last sorry will be.</p>",
        "id": 514905206,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1745874915
    },
    {
        "content": "<p>In principle you could also use hand rolled recursion if it's the imperative part that annoys you. I guess the upcoming work on iterators might also help.</p>",
        "id": 514906238,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1745875338
    },
    {
        "content": "<p>I guess I can tolerate the imperative part, but I've just tried to <code>induction l; simp [differencesDedupLengthLEOne?]</code> on the sorry and the goal state exploded into 400+ lines and I don't know where to start.</p>",
        "id": 514906704,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1745875533
    },
    {
        "content": "<p>I use MLList for this purpose, but I don't know how canonical it is</p>",
        "id": 514913104,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1745878662
    },
    {
        "content": "<p>Mathlib once had a <a href=\"https://github.com/leanprover-community/mathlib4/blob/8666bd82efec40b8b3a5abca02dc9b24bbdf2652/Mathlib/Data/LazyList.lean#L26\">lazy list definition</a></p>",
        "id": 514955355,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1745902791
    },
    {
        "content": "<p>And it is being replaced with MLList it seems? I'll look into that too. Thanks!<br>\nBut my first impression is that it is also not suited for proving things...</p>",
        "id": 515017940,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1745921226
    },
    {
        "content": "<p>MLList isn't intended for proof (at all).</p>",
        "id": 515292879,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1746016623
    },
    {
        "content": "<p>Strictly speaking I don't see the utility of laziness in proofs</p>",
        "id": 515294291,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1746016972
    },
    {
        "content": "<p>Lean's thunks come with special support to make them work as thunks should( as I learnt a few months ago), but beyond that lazy lists that use thunks are just lists with extra steps to unfold them.</p>",
        "id": 515294513,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1746017035
    },
    {
        "content": "<p>By “suited for proving” I mean to write an algorithm with lazy lists and verify in lean that it actually does the right thing.</p>",
        "id": 515307741,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1746020306
    },
    {
        "content": "<p>In that case, unless you are feeling adventurous, I suggest avoiding monadic code. It's not impossible to prove things inside the Id monad, it's just more tedious and less well documented.</p>",
        "id": 515307980,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1746020375
    },
    {
        "content": "<p>I started a speculative (potentially fruitless or even wildly wrong) discussion related to this on discord. Feel free to check it out and contribute</p>",
        "id": 515317978,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1746022862
    },
    {
        "content": "<p>I think it might actually be impossible to prove things about <code>MLList</code>, at least without <code>native_decide</code>. It's behavior is defined by an unsafe non positive inductive type</p>",
        "id": 515356004,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746032422
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/270676-lean4/topic/Lazy.20lists/near/514906238\">said</a>:</p>\n<blockquote>\n<p>upcoming work on iterators</p>\n</blockquote>\n<p>That sounds exciting!</p>",
        "id": 515447907,
        "sender_full_name": "James Sully",
        "timestamp": 1746075752
    }
]