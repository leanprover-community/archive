[
    {
        "content": "<p>I'm having a trouble figuring out why one simp theorem is not being applied. There is unification failure and I'm having hard time reading the trace.</p>\n<p>The main unification that fails is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">      </span><span class=\"o\">[</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">isDefEq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">❌</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">            </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">?</span><span class=\"n\">EI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span>\n<span class=\"w\">              </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">NonUnitalNormedRing</span><span class=\"bp\">.</span><span class=\"n\">toNormedAddCommGroup</span>\n</code></pre></div>\n<p>Here is the part of the trace corresponding to this failure</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>trace</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>      [Meta.isDefEq] ❌ fun (i : Fin 10 × Unit) =&gt;\n            (?inst : (i : (?I : Type)) → NormedAddCommGroup ((?EI : (?I : Type) → Type) i))\n              i.2 =?= fun (i : Fin 10 × Unit) =&gt; NonUnitalNormedRing.toNormedAddCommGroup\n        [Meta.isDefEq] ✅ Fin 10 × Unit =?= Fin 10 × Unit\n        [Meta.isDefEq] ❌ (?inst : (i : (?I : Type)) → NormedAddCommGroup ((?EI : (?I : Type) → Type) i))\n              i.2 =?= NonUnitalNormedRing.toNormedAddCommGroup\n          [Meta.isDefEq] (?inst : (i : (?I : Type)) → NormedAddCommGroup ((?EI : (?I : Type) → Type) i))\n                i.2 [assignable] =?= NonUnitalNormedRing.toNormedAddCommGroup [nonassignable]\n          [Meta.isDefEq.foApprox] (?inst :\n                (i : (?I : Type)) →\n                  NormedAddCommGroup ((?EI : (?I : Type) → Type) i)) [i.2] := NonUnitalNormedRing.toNormedAddCommGroup\n          [Meta.isDefEq] ❌ i.2 =?= NonUnitalNormedCommRing.toNonUnitalNormedRing\n            [Meta.isDefEq] ❌ i.2 =?= NonUnitalNormedCommRing.toNonUnitalNormedRing\n              [Meta.isDefEq] ❌ i.2 =?= NormedCommRing.toNonUnitalNormedCommRing.1\n                [Meta.isDefEq] ❌ i.2 =?= NonUnitalNormedRing.mk ⋯ ⋯\n                  [Meta.isDefEq] ❌ Unit =?= NonUnitalNormedRing R\n                    [Meta.isDefEq] ❌ Unit =?= NonUnitalNormedRing R\n                      [Meta.isDefEq] ❌ PUnit.{1} =?= NonUnitalNormedRing R\n                        [Meta.isDefEq.onFailure] ❌ PUnit.{1} =?= NonUnitalNormedRing R\n                  [Meta.isDefEq] ❌ PUnit.{1} =?= NonUnitalNormedRing R\n                  [Meta.isDefEq.onFailure] ❌ i.2 =?= NonUnitalNormedRing.mk ⋯ ⋯\n          [Meta.isDefEq.foApprox] (?inst :\n                (i : (?I : Type)) → NormedAddCommGroup ((?EI : (?I : Type) → Type) i)) [i.2] := NormedAddCommGroup.mk ⋯\n          [Meta.isDefEq] ❌ i.2 =?= NonUnitalNormedRing.dist_eq\n            [Meta.isDefEq] ❌ i.2 =?= NonUnitalNormedRing.dist_eq\n              [Meta.isDefEq] ❌ PUnit.{1} =?= ∀ (x y : R), dist x y = ‖x - y‖\n                [Meta.isDefEq.onFailure] ❌ PUnit.{1} =?= ∀ (x y : R), dist x y = ‖x - y‖\n              [Meta.isDefEq.onFailure] ❌ i.2 =?= NonUnitalNormedRing.dist_eq\n          [Meta.isDefEq.constApprox] (?inst :\n                (i : (?I : Type)) →\n                  NormedAddCommGroup ((?EI : (?I : Type) → Type) i)) [i.2] := NonUnitalNormedRing.toNormedAddCommGroup\n          [Meta.isDefEq.foApprox] (?inst :\n                (i : (?I : Type)) → NormedAddCommGroup ((?EI : (?I : Type) → Type) i)) [i.2] := NormedAddCommGroup.mk ⋯\n          [Meta.isDefEq] ❌ i.2 =?= NonUnitalNormedRing.dist_eq\n          [Meta.isDefEq.constApprox] (?inst :\n                (i : (?I : Type)) → NormedAddCommGroup ((?EI : (?I : Type) → Type) i)) [i.2] := NormedAddCommGroup.mk ⋯\n</code></pre></div>\n</div></div>\n<p>Here is a minimized version of the unification itself</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Qq</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"k\">do</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">I?</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVarQ</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">EI?</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVarQ</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">I?</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">inst?</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVarQ</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">((</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">I?</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NormedAddCommGroup</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">EI?</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">lam</span><span class=\"w\"> </span><span class=\"ss\">`i</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inst?</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">bvar</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">default</span>\n\n\n<span class=\"w\">  </span><span class=\"n\">withLocalDeclQ</span><span class=\"w\"> </span><span class=\"ss\">`R</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">withLocalDeclQ</span><span class=\"w\"> </span><span class=\"ss\">`R</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">instImplicit</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">RCLike</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">instR</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rhsBody</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">inferInstance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">rhsBody</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- I?.mvarId!.assignIfDefeq q(Unit)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- EI?.mvarId!.assignIfDefeq q(fun _ : Unit =&gt; $R)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- inst?.mvarId!.assignIfDefeq q(fun _ : Unit =&gt; $rhsBody)</span>\n\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">println</span><span class=\"w\"> </span><span class=\"s2\">\"unification succeeded\"</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"unification failed\"</span>\n</code></pre></div>\n<p>If you uncomment all the <code>assignIfDefeq</code> i.e. assign the metavariables manually then the final defeq test succeeds. </p>\n<p>I would like this unification to succeed. How can I achieve that? Can I write an unification hint?</p>\n<p>Ideally I would not run into this problem at all, but I'm unable to minimize the simp call :( I'm thinking that reordering the simp theorem arguments might cause different unification order. Any other tip would be welcome.</p>",
        "id": 463919341,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1724207481
    }
]