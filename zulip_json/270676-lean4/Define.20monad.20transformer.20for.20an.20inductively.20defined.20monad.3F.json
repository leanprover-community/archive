[
    {
        "content": "<p>I am trying to define <a href=\"https://harrisonwl.github.io/assets/papers/hosc-cheapthreads.pdf\">(reactive) resumption monad transformers</a> in Lean, with the goal toward formalizing cryptographic reasoning as in <a href=\"https://www.isa-afp.org/entries/CryptHOL.html\">this Isabelle library</a>. The reactive resumption monad can be defined inductively as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">ReacM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Input</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ReacM</span><span class=\"w\"> </span><span class=\"n\">Input</span><span class=\"w\"> </span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">pause</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Input</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ReacM</span><span class=\"w\"> </span><span class=\"n\">Input</span><span class=\"w\"> </span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ReacM</span><span class=\"w\"> </span><span class=\"n\">Input</span><span class=\"w\"> </span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>This is all well and good, but I cannot use the same strategy to define its transformer version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">ReacT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Input</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulMonad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ReacT</span><span class=\"w\"> </span><span class=\"n\">Input</span><span class=\"w\"> </span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">pause</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Input</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ReacT</span><span class=\"w\"> </span><span class=\"n\">Input</span><span class=\"w\"> </span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ReacT</span><span class=\"w\"> </span><span class=\"n\">Input</span><span class=\"w\"> </span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">(kernel) arg #7 of 'ReacT.pause' contains a non valid occurrence of the datatypes being declared</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>Is there a way to tell Lean that this inductive definition still works, despite the non-positivity?</p>",
        "id": 451249886,
        "sender_full_name": "Quang Dao",
        "timestamp": 1720923849
    },
    {
        "content": "<p>You can use the<code>unsafe</code> modifier, as in <code>unsafe inductive ReacT</code>. It may or may not prevent you from doing other things you wanted to do in terms of proof.</p>",
        "id": 451274183,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1720931121
    },
    {
        "content": "<p>I just glanced at the provided link so feel free to blow this off, but the <code>ReacT.pause</code> in the paper seems like <code>Input -&gt; Output -&gt; m (ReacT Input Output m a))</code> which naively looks  like <code>StateCpsT</code>, maybe you can use that?</p>",
        "id": 451306011,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1720932098
    },
    {
        "content": "<p>Does this form work for your application?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">ReacT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Input</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulMonad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ReacT</span><span class=\"w\"> </span><span class=\"n\">Input</span><span class=\"w\"> </span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">pause</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Output</span><span class=\"w\">  </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Input</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ReacT</span><span class=\"w\"> </span><span class=\"n\">Input</span><span class=\"w\"> </span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ReacT</span><span class=\"w\"> </span><span class=\"n\">Input</span><span class=\"w\"> </span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>I don't think you need to wrap <code>Input → ReacT Input Output m α</code> in the monad, but you might still need a <code>squash : m (ReacT Input Output m α) → ReacT Input Output m α</code> depending on what you are actually doing. That <code>squash</code> is illegal but there are some workarounds that might work if you really need them.</p>",
        "id": 451317960,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1720933191
    },
    {
        "content": "<p>(Of course, you can always do <code>unsafe inductive</code> to bypass the issue entirely, if that's what you need.)</p>",
        "id": 451318315,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1720933305
    },
    {
        "content": "<p>Thanks for your answers. I don't want to use <code>unsafe</code> since I want to prove properties of <code>ReacT</code>.</p>\n<p>I'll continue thinking about the proposed alternatives. One option I haven't tried is to define <code>ReacT m</code> directly for a specific monad <code>m</code> of interest (in my case it is a probability mass function).</p>",
        "id": 452562466,
        "sender_full_name": "Quang Dao",
        "timestamp": 1721393013
    }
]