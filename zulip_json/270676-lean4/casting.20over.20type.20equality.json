[
    {
        "content": "<p>In <code>Prelude.lean</code> above the definition of <code>cast</code> it says \"Cast across a type equality. If <code>h : α = β</code> is an equality of types, and <code>a : α</code>, then <code>a : β</code> will usually not typecheck directly ...\"</p>\n<p>What could go wrong if we instead tried to implement a type theory where <code>a : β</code> does typecheck?</p>",
        "id": 491946183,
        "sender_full_name": "Nick Mertes",
        "timestamp": 1736063327
    },
    {
        "content": "<p>In terms of logical consistency, that wouldn't be a problem, but it makes type checking undecidable. How is the type checker supposed to know that <code>α = β</code>? The proof of such an equality proof could be arbitrarily complicated. Nonetheless, as far as I know, the proof assistant PVS implements a logic that allows <code>a : β</code> to type check, at the cost of occasionally relying on the user to assist with type checking.</p>",
        "id": 491953730,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1736070863
    },
    {
        "content": "<p>I wonder, in the spirit of PVS, if a tool can be built on top of Lean (without destroying Lean's logic) to allow the user \"help\" the type checker to do something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">i_wish</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>I could <code>cast</code> in the above situation, but as is also explained in <code>Prelude.lean</code> \"It is best to avoid this function (cast) if you can, because it is more complicated to reason about terms containing casts\"</p>",
        "id": 492235179,
        "sender_full_name": "Nick Mertes",
        "timestamp": 1736220433
    },
    {
        "content": "<p>That note is only trying to tell you to use <code>Fin.cast</code> in favour of <code>_root_.cast</code>.</p>",
        "id": 492244057,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1736226098
    },
    {
        "content": "<p>So the right hand side should probably just be <code>x.cast (by omega)</code>.</p>",
        "id": 492244177,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1736226168
    }
]