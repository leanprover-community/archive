[
    {
        "content": "<p>Apologies if this has been hashed already, seems the issues it addresses have come up over the years with unclear resolution:</p>\n<p><strong>Proposal</strong>: Command causing another namespace to be considered in-scope for the purpose of \"scoped\" if the namespace in which it resides is in scope.</p>\n<p><strong>Example</strong> (syntax can be reworked, it's admittedly not super intuitive):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Foo</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"w\">  </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"kn\">infixr</span><span class=\"o\">:</span><span class=\"mi\">50</span><span class=\"w\"> </span><span class=\"s2\">\" ⊕ \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">add</span>\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Foo</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Bar</span>\n<span class=\"w\">  </span><span class=\"kn\">export</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">Foo</span>\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Bar</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Baz</span>\n<span class=\"w\">  </span><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Bar</span>\n\n<span class=\"w\">  </span><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"c1\">-- Okay!</span>\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Baz</span>\n</code></pre></div>\n<p><strong>Motivation</strong>: Currently the prelude and core need to flood namespaces, possibly including the root namespace, with notation for the core language without resorting to littering <code>open</code> everywhere. With current mechanisms, this is only possible by defining the notation in the root namespace, but this feature would permit the prelude to include an export to the root namespace, and modules within the prelude and core to use more conservative floods, such as only throughout <code>Lean</code> and <code>Init</code>. This would resolve long-standing issues with notation in self-contained developments and DSLs.</p>\n<p><strong>Impacts</strong>: No regressions. Minimizes complexity of increasing prelude flexibility. Presumably improves DX for library interoperability in other contexts, although I’m unsure how relevant that is to the current Lean ecosystem.</p>",
        "id": 490353429,
        "sender_full_name": "Soundwave",
        "timestamp": 1734837969
    },
    {
        "content": "<p>Could you say a bit more about the motivation? What pieces of the core language would not be exported to the root namespace? If that's not the intent, how would <code>export scoped</code> help?</p>\n<p>There's a related feature, a variation of <code>export</code> that only makes names available when you've <code>open</code>ed the namespace (or are in the namespace) that <span class=\"user-mention\" data-user-id=\"315577\">@Mac Malone</span> and I have talked about. While <code>export scoped</code> does make some sense, since it's as-if the activities that occur with <code>open</code> are exported into another namespace (although that's not how it would be implemented), I wonder if there's another syntax that would work for \"sticky\" <code>open</code>. All I can think of is <code>scoped open Foo</code> and <code>scoped open scoped Foo</code> right now, but these are bound to be confusing.</p>\n<p>There's also a related feature request for being able to locally disable syntaxes. Potentially syntaxes can be grouped and disabled together.</p>",
        "id": 490356150,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734840805
    },
    {
        "content": "<p>The prelude would export all of the core language to the root namespace, but crucially, via a module that is only included as part of the implicit import (Is it just <code>Init</code>? In this case <code>Init</code> would be the sole importer of a module that exports notation into <code>Init</code>. Similarly with <code>Lean</code>). That way you have the option of importing core modules, e.g. metaprogramming modules, without necessarily importing scoped commands. As it stands, a header like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">prelude</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Init</span><span class=\"bp\">.</span><span class=\"n\">Prelude</span>\n<span class=\"c1\">-- Lean.Elab.Tactic covers most of the bases but it....</span>\n</code></pre></div>\n<p>has a major limitation in flexibility because <code>Init.Notation</code> is downstream of everything.</p>\n<p>I hit on the <code>scoped open</code> syntax as well and chose <code>export scoped</code> to disambiguate from <code>open scoped</code>, but yes, it does feel like more of an <code>open</code> than an <code>export</code>. It also doesn't necessarily need to fit either of these schemes, I'm not fussed about it.</p>\n<p>I'm not opposed to syntax hiding but it does bring two issues to mind: lesser, a lack of symmetry with identifiers, which can only be shadowed or refactored out of scope; and greater, syntaxes are ~anonymous and so it'd be quite a namespace shakeup to normalize referring to them in order to disable them.</p>",
        "id": 490358028,
        "sender_full_name": "Soundwave",
        "timestamp": 1734842702
    },
    {
        "content": "<p>I see — I didn't expect this to be about supporting user <code>prelude</code>s. As far as I understand it, <code>prelude</code> is only meant for the implementation of Lean itself, and the system assumes that the supplied prelude is loaded. My feeling is that it's unlikely that we'll see any development in this direction, certainly not any time soon.</p>\n<p>Some sort of scoped open/export is plausible in the near future, but not specifically for the use case you're envisioning.</p>\n<blockquote>\n<p>This would resolve long-standing issues with notation in self-contained developments and DSLs.</p>\n</blockquote>\n<p>Is this something that has been affecting you for a long time? I saw your question today about doing logic from scratch, with the Sheffer stroke. Is this minimized from some larger ongoing project?</p>\n<p>From what I've seen, the solution to creating a DSL is to create a custom syntax category rather than try to reuse <code>term</code>. It's still work, but at least commands aren't broken because you don't have the full prelude loaded.</p>",
        "id": 490366285,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734851617
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/RFC.3A.20Export.20scoped.20commands/near/490366285\">said</a>:</p>\n<blockquote>\n<p>I see — I didn't expect this to be about supporting user <code>prelude</code>s.</p>\n</blockquote>\n<p>It's not, in the sense that I wouldn't have brought it up if I didn't think it was a sensible concern for other libraries. <em>I</em> am interested in writing preludes, but I understand that this isn't exactly sanctioned.</p>\n<blockquote>\n<p>Is this something that has been affecting you for a long time? I saw your question today about doing logic from scratch, with the Sheffer stroke. Is this minimized from some larger ongoing project?</p>\n</blockquote>\n<p>Yes re:minimization, although broadly this isn't a major pain point. I was more speaking to variations on \"Can you override core notation? Well yes, but no.\" that have been asked over the years.</p>\n<p>Yeah, there are solutions for DSLs, I just figure a step towards the Racket-esque with a DX improvement is a win-win, if low priority. Incidentally, in my tinkering I've found <code>Init.Prelude</code> + the coercions for TSyntax to be surprisingly functional for an unsupported mode. Really the main issue is not being able to lean on the core without yanking the rest of the prelude with it.</p>",
        "id": 490367062,
        "sender_full_name": "Soundwave",
        "timestamp": 1734852421
    },
    {
        "content": "<p>Having Racket-style <code>#lang</code>s is an idea we kick around, but the current focus is improving the Lean language itself and supporting embedded DSLs, for example David Thrane Christiansen has made a nice DSL (<a href=\"https://github.com/leanprover/verso\">Verso</a>) for writing documents such as the new Lean language reference.</p>\n<p>Making use of namespace activation is an interesting idea for trying to support <code>#lang</code>s, but my guess is we'll see real support for turning off existing notations, or maybe also third-party mini-Lean frontends that have a way to opt-in to language features in a composable way, for teaching or other research.</p>\n<p>By the way, there's an obstacle here with relying namespace activation, which makes using it as a step toward <code>#lang</code> not as good as you might want. There are plenty of notations that are \"builtin\" that use the <code>@[builtin_term_parser]</code> mechanism (see src/Lean/Parser/Term.lean), and these are not <code>syntax</code> that can be <code>scoped</code>.</p>\n<blockquote>\n<p>DX improvement</p>\n</blockquote>\n<p>I'm still not clear on the whole story here how it improves the developer experience for someone using the full Lean language  — <code>export scoped</code> doesn't help the \"can you override core notation\" problem, right? I do see it being useful for creating namespaces with a curated set of instances and notations from other namespaces, to be clear.</p>\n<p>Mathlib runs into issues with the core prefix <code>!</code> notation for boolean negation, since it has a postfix <code>!</code> for factorial that leads to ambiguities. It would be nice to have a way to turn off \"programming\" notations. The preference though is for these basic notations to be immediately available, so I imagine, if it becomes possible, it will be opt-out instead of opt-in.</p>\n<p>A design that comes to mind is that each syntax could have option name(s) associated to it, which would let <code>set_option</code> (or a syntax-specific command) control classes of syntax. Assuming these configurations could be <code>scoped</code>, that would enable you to have namespaces in which certain syntaxes are disabled, but even without that feature you can create command macros that set the desired configuration. That's more powerful than <code>export scoped</code>, which can only add syntaxes. Though, it's not so nice that different namespaces might have conflicting configurations; <code>scoped</code> is nice in that there are no conflicts, only unions.</p>\n<p>A wrinkle though is that the pretty printer needs to be similarly controlled (it's not nice seeing things pretty printed in a way you can't write yourself). These processes are not coupled, and it would take a little coordination, but it should be doable. At least all notations defined with <code>notation</code> could be handled at once.</p>",
        "id": 490370549,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734856175
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/RFC.3A.20Export.20scoped.20commands/near/490370549\">said</a>:</p>\n<blockquote>\n<p>By the way, there's an obstacle here with relying namespace activation, which makes using it as a step toward <code>#lang</code> not as good as you might want. There are plenty of notations that are \"builtin\" that use the <code>@[builtin_term_parser]</code> mechanism (see src/Lean/Parser/Term.lean), and these are not <code>syntax</code> that can be <code>scoped</code>.</p>\n</blockquote>\n<p>Known. Full <code>#lang</code>s seemed like a ways off (and honestly, even as someone who wants to pick apart the core, I'm not itching for them); this seemed like a more reasonable step</p>\n<blockquote>\n<p>I'm still not clear on the whole story here how it improves the developer experience for someone<br>\nusing the full Lean language  — <code>export scoped</code> doesn't help the \"can you override core notation\" problem, right? I do see it being useful for creating namespaces with a curated set of instances and notations from other namespaces, to be clear.</p>\n</blockquote>\n<p>This is a fair point. Without additional mechanisms it doesn't immediately, but without something to this effect the prelude has no mechanism by which to permit this. If we wanted to sanction specifically this use case of subverting the prelude, it'd then be as simple as a header command to suppress the one import.</p>\n<blockquote>\n<p>A design that comes to mind is that each syntax could have option name(s) associated to it, which would let <code>set_option</code> (or a syntax-specific command) control classes of syntax. Assuming these configurations could be <code>scoped</code>, that would enable you to have namespaces in which certain syntaxes are disabled, but even without that feature you can create command macros that set the desired configuration. That's more powerful than <code>export scoped</code>, which can only add syntaxes. Though, it's not so nice that different namespaces might have conflicting configurations; <code>scoped</code> is nice in that there are no conflicts, only unions.</p>\n</blockquote>\n<p>This seems fine to me from a UX standpoint.</p>\n<p>The reason why I'm inclined towards making this work with an additive mechanism with a default and opt-in baseline reductions is that my experience with reflection-heavy Java has been that normalizing subtractions is a Pandora's box of potential nightmare maintainability scenarios.</p>\n<p>Coming at it from an angle of \"Okay, in the idealistic model where <code>#lang</code>s etc. are built out, does this make sense?\" being able to export scopes seems somewhat natural, and moves closer to a model where <code>import</code> and <code>#lang</code> are one and the same, whereas syntax options is... fine, though see above, and they would seem to be less pressing in this scenario.</p>",
        "id": 490373699,
        "sender_full_name": "Soundwave",
        "timestamp": 1734859322
    },
    {
        "content": "<p>Re: The Mathlib use case, I will admit that syntax groups uniquely do address this, but my intuition there is to make syntaxes identifiable and shadowable, not add syntax options.</p>\n<p>Which come to think of it, does in and of itself cover most use cases for interop with the full language.</p>",
        "id": 490374822,
        "sender_full_name": "Soundwave",
        "timestamp": 1734860392
    }
]