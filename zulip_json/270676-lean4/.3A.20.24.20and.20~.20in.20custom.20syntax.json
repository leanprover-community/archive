[
    {
        "content": "<p>We're having a few issues when defining custom syntax</p>\n<ol>\n<li>syntax ident noWs \":\" noWs num : expr - works but makes $x:y macro syntax unusable</li>\n<li>syntax \"$\" noWs ident : expr - not able to input it in macro, $x macro syntax takes priority</li>\n<li>syntax \"~\" expr : expr - can't input it, \"expected token\"</li>\n</ol>\n<p>Is there any way to do this so I can achieve a usage like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"s2\">\"~\"</span> <span class=\"n\">expr</span><span class=\"o\">:</span> <span class=\"n\">expr</span>\n<span class=\"kn\">open</span> <span class=\"n\">Expression</span> <span class=\"k\">in</span> <span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Expression</span><span class=\"o\">[</span><span class=\"bp\">~$</span><span class=\"n\">x</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">int_negate</span> <span class=\"n\">Expression</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">])</span>\n</code></pre></div>",
        "id": 401807134,
        "sender_full_name": "Patrick Ford",
        "timestamp": 1699893927
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"664695\">@Patrick Ford</span> For (3), the problem is that <code>~</code> is not a token in Lean proper, thus  it does not parse as a token in the antiquote. The most direct way to fix this is to make your custom syntax somehow reachable from Lean syntax before the antiquota (e.g., via defining a custom term or command that uses <code>expr</code> in its syntax).</p>",
        "id": 401812831,
        "sender_full_name": "Mac Malone",
        "timestamp": 1699895964
    },
    {
        "content": "<p>For (1), the problem is that the default <code>withAntiquot</code> parser takes the longest match between <code>$x:y</code> syntaxes rather than just always parsing it as an antiquote. You can define <code>withAntiquot</code> that does not do this and use this for a custom parser like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Parser</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Parser</span> <span class=\"n\">PrettyPrinter</span> <span class=\"n\">Formatter</span> <span class=\"n\">Parenthesizer</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Like `Lean.Parser.withAntiquot`, but with an `acceptLhs` option.</span>\n<span class=\"sd\">Setting `acceptLhs` to true will always prefer parsing as an antiquote</span>\n<span class=\"sd\">in ambiguous cases.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">withAntiquot'</span> <span class=\"o\">(</span><span class=\"n\">antiquotP</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Parser</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">acceptLhs</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Parser</span> <span class=\"n\">where</span>\n  <span class=\"n\">fn</span> <span class=\"o\">:=</span> <span class=\"n\">withAntiquotFn</span> <span class=\"n\">antiquotP.fn</span> <span class=\"n\">p.fn</span> <span class=\"n\">acceptLhs</span>\n  <span class=\"n\">info</span> <span class=\"o\">:=</span> <span class=\"n\">orelseInfo</span> <span class=\"n\">antiquotP.info</span> <span class=\"n\">p.info</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">combinator_formatter</span> <span class=\"n\">withAntiquot'</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">withAntiquot'.formatter</span> <span class=\"o\">:=</span> <span class=\"n\">Formatter.withAntiquot.formatter</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">combinator_parenthesizer</span> <span class=\"n\">withAntiquot'</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">withAntiquot'.parenthesizer</span> <span class=\"o\">:=</span> <span class=\"n\">Parenthesizer.withAntiquot.parenthesizer</span>\n\n<span class=\"kd\">def</span> <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Parser</span> <span class=\"o\">:=</span>\n  <span class=\"n\">withAntiquot'</span> <span class=\"o\">(</span><span class=\"n\">mkAntiquot</span> <span class=\"bp\">...</span><span class=\"o\">)</span> <span class=\"n\">exampleNoAntiquot</span> <span class=\"n\">true</span>\n</code></pre></div>\n<p>(I, for example, do this in <a href=\"https://github.com/tydeu/lean4-alloy/blob/ff1967f9aa60b82505a979fc1c75b1a486f750d0/Alloy/Util/Parser.lean#L44-L53\">Alloy</a>.)</p>",
        "id": 401813895,
        "sender_full_name": "Mac Malone",
        "timestamp": 1699896365
    },
    {
        "content": "<p>Finally, for (2), to input a raw <code>$</code> in an antiquote, you can use <code>$$</code> as an escape (it will be treated as a raw <code>$</code> token).</p>",
        "id": 401814182,
        "sender_full_name": "Mac Malone",
        "timestamp": 1699896477
    },
    {
        "content": "<p>nice, thanks, for (2) there's still a problem</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">declare_syntax_cat</span> <span class=\"n\">expr2</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"$\"</span> <span class=\"n\">noWs</span> <span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">expr2</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"Expression[\"</span> <span class=\"n\">expr2</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Expression</span><span class=\"o\">[</span><span class=\"bp\">$$$</span><span class=\"n\">x</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Expression</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>you can't follow the escaped $ with a $x, as it doesn't actually capture the $x, instead we get <code>unknown identifier 'x'</code>. You can't follow $$ by an antiquote it seems.</p>",
        "id": 401815178,
        "sender_full_name": "Patrick Ford",
        "timestamp": 1699896826
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"664695\">@Patrick Ford</span> Yeah, I believe this is unfortunate by-product of the way antiquotes are currently parsed. However, it may be fixable, so I might be worth making an issue on the <a href=\"https://github.com/leanprover/lean4/\">lean4 repository</a> about this.</p>\n<p>As a workaround, while you cannot use the quotation to pattern match the specific <code>expr</code>, you can destruct the syntax manually. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Parser</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Parser</span> <span class=\"n\">PrettyPrinter</span> <span class=\"n\">Formatter</span> <span class=\"n\">Parenthesizer</span>\n\n<span class=\"n\">declare_syntax_cat</span> <span class=\"n\">expr</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"Expression[\"</span> <span class=\"n\">expr</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">withAntiquot'</span> <span class=\"o\">(</span><span class=\"n\">antiquotP</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Parser</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">acceptLhs</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Parser</span> <span class=\"n\">where</span>\n  <span class=\"n\">fn</span> <span class=\"o\">:=</span> <span class=\"n\">withAntiquotFn</span> <span class=\"n\">antiquotP.fn</span> <span class=\"n\">p.fn</span> <span class=\"n\">acceptLhs</span>\n  <span class=\"n\">info</span> <span class=\"o\">:=</span> <span class=\"n\">orelseInfo</span> <span class=\"n\">antiquotP.info</span> <span class=\"n\">p.info</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">combinator_formatter</span> <span class=\"n\">withAntiquot'</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">withAntiquot'.formatter</span> <span class=\"o\">:=</span> <span class=\"n\">Formatter.withAntiquot.formatter</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">combinator_parenthesizer</span> <span class=\"n\">withAntiquot'</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">withAntiquot'.parenthesizer</span> <span class=\"o\">:=</span> <span class=\"n\">Parenthesizer.withAntiquot.parenthesizer</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">expr_parser</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">dollarExpr</span> <span class=\"o\">:</span> <span class=\"n\">Parser</span> <span class=\"o\">:=</span>\n  <span class=\"n\">withAntiquot'</span> <span class=\"o\">(</span><span class=\"n\">mkAntiquot</span> <span class=\"s2\">\"dollarExpr\"</span> <span class=\"bp\">`</span><span class=\"n\">dollarExpr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"s2\">\"$\"</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">checkNoWsBefore</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">ident</span><span class=\"o\">)</span> <span class=\"n\">true</span>\n\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Expression</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">dollarExpr</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Expression</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"o\">(⟨</span><span class=\"n\">x.raw</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]⟩)])</span>\n</code></pre></div>",
        "id": 401817760,
        "sender_full_name": "Mac Malone",
        "timestamp": 1699897901
    },
    {
        "content": "<p>Theoretically, since this is already using a custom <code>withAntiquot</code> parser, one could also just write a custom <code>withAntiqutFn</code> itself to better support the escape.</p>",
        "id": 401818026,
        "sender_full_name": "Mac Malone",
        "timestamp": 1699898013
    },
    {
        "content": "<p>nice, that works, thanks for the information!</p>",
        "id": 401818502,
        "sender_full_name": "Patrick Ford",
        "timestamp": 1699898232
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"664695\">@Patrick Ford</span> Unfortunately, further investigation reveals that this doesn't quite do what you want. Literal expressions of the form <code>$id</code> will still be parsed as anitquotes in your custom syntax.</p>",
        "id": 401823124,
        "sender_full_name": "Mac Malone",
        "timestamp": 1699900116
    },
    {
        "content": "<p>I wrote the following expanded example that works for both literal and antiquot dollar expression. Unfortunately, it only works when the syntax is parsed directly, not as part of a category (because the category antiquot parser then takes precedence):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Parser</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Parser</span> <span class=\"n\">PrettyPrinter</span> <span class=\"n\">Formatter</span> <span class=\"n\">Parenthesizer</span>\n\n<span class=\"sd\">/-- Like `Lean.Parser.mkAntiquot`, but without embedded escapes. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">mkAntiquot'</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">kind</span> <span class=\"o\">:</span> <span class=\"n\">SyntaxNodeKind</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">anonymous</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">isPseudoKind</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Parser</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">kind</span> <span class=\"o\">:=</span> <span class=\"n\">kind</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">isPseudoKind</span> <span class=\"k\">then</span> <span class=\"bp\">`</span><span class=\"n\">pseudo</span> <span class=\"k\">else</span> <span class=\"bp\">.</span><span class=\"n\">anonymous</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"bp\">`</span><span class=\"n\">antiquot</span>\n  <span class=\"k\">let</span> <span class=\"n\">nameP</span> <span class=\"o\">:=</span> <span class=\"n\">node</span> <span class=\"bp\">`</span><span class=\"n\">antiquotName</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">checkNoWsBefore</span> <span class=\"o\">(</span><span class=\"s2\">\"no space before ':\"</span> <span class=\"bp\">++</span> <span class=\"n\">name</span> <span class=\"bp\">++</span> <span class=\"s2\">\"'\"</span><span class=\"o\">)</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">symbol</span> <span class=\"s2\">\":\"</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">nonReservedSymbol</span> <span class=\"n\">name</span>\n  <span class=\"c1\">-- if parsing the kind fails and `anonymous` is true, check that we're not ignoring a different</span>\n  <span class=\"c1\">-- antiquotation kind via `noImmediateColon`</span>\n  <span class=\"k\">let</span> <span class=\"n\">nameP</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">anonymous</span> <span class=\"k\">then</span> <span class=\"n\">nameP</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">checkNoImmediateColon</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">pushNone</span> <span class=\"k\">else</span> <span class=\"n\">nameP</span>\n  <span class=\"c1\">-- antiquotations are not part of the \"standard\" syntax, so hide \"expected '$'\" on error</span>\n  <span class=\"n\">leadingNode</span> <span class=\"n\">kind</span> <span class=\"n\">maxPrec</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">atomic</span> <span class=\"bp\">&lt;|</span>\n    <span class=\"n\">setExpected</span> <span class=\"o\">[]</span> <span class=\"s2\">\"$\"</span> <span class=\"bp\">&gt;&gt;</span>\n    <span class=\"n\">checkNoWsBefore</span> <span class=\"s2\">\"no space before spliced term\"</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">antiquotExpr</span> <span class=\"bp\">&gt;&gt;</span>\n    <span class=\"n\">nameP</span>\n\n<span class=\"sd\">/-- Like `Lean.Parser.withAntiquotFn`, but with multi-level `$` escapes. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">withAntiquotFn'</span> <span class=\"o\">(</span><span class=\"n\">antiquotP</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ParserFn</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">antiquotBehavior</span> <span class=\"o\">:</span> <span class=\"n\">OrElseOnAntiquotBehavior</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ParserFn</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">c</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">c.input.atEnd</span> <span class=\"n\">s.pos</span> <span class=\"k\">then</span>\n    <span class=\"n\">p</span> <span class=\"n\">c</span> <span class=\"n\">s</span>\n  <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">c.input.get'</span> <span class=\"n\">s.pos</span> <span class=\"n\">h</span> <span class=\"bp\">==</span> <span class=\"sc\">'$'</span> <span class=\"k\">then</span>\n    <span class=\"n\">go</span> <span class=\"n\">c</span> <span class=\"n\">s</span> <span class=\"n\">h</span> <span class=\"n\">c.quotDepth</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">p</span> <span class=\"n\">c</span> <span class=\"n\">s</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">go</span> <span class=\"n\">c</span> <span class=\"n\">s</span> <span class=\"n\">h</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p</span> <span class=\"n\">c</span> <span class=\"n\">s</span> <span class=\"c1\">-- parse `$` outside quotations as normal</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">quotDepth</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">pos'</span> <span class=\"o\">:=</span> <span class=\"n\">c.input.next'</span> <span class=\"n\">s.pos</span> <span class=\"n\">h</span>\n    <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">c.input.atEnd</span> <span class=\"n\">pos'</span> <span class=\"k\">then</span>\n      <span class=\"n\">p</span> <span class=\"n\">c</span> <span class=\"n\">s</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">c.input.get'</span> <span class=\"n\">pos'</span> <span class=\"n\">h</span> <span class=\"bp\">==</span> <span class=\"sc\">'$'</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">pos</span> <span class=\"o\">:=</span> <span class=\"n\">s.pos</span>\n      <span class=\"c1\">-- use an extra `$` to escape one level of quotation</span>\n      <span class=\"k\">match</span> <span class=\"n\">go</span> <span class=\"n\">c</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">pos</span> <span class=\"o\">:=</span> <span class=\"n\">pos'</span><span class=\"o\">}</span> <span class=\"n\">h</span> <span class=\"n\">quotDepth</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">stack</span><span class=\"o\">,</span> <span class=\"n\">lhsPrec</span><span class=\"o\">,</span> <span class=\"n\">errPos</span><span class=\"o\">,</span> <span class=\"n\">cache</span><span class=\"o\">,</span> <span class=\"n\">some</span> <span class=\"n\">msg</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">if</span> <span class=\"n\">errPos</span> <span class=\"bp\">=</span> <span class=\"n\">pos'</span> <span class=\"k\">then</span> <span class=\"c1\">-- backtrack on non-progressing error</span>\n          <span class=\"o\">⟨</span><span class=\"n\">stack</span><span class=\"o\">,</span> <span class=\"n\">lhsPrec</span><span class=\"o\">,</span> <span class=\"n\">pos</span><span class=\"o\">,</span> <span class=\"n\">cache</span><span class=\"o\">,</span> <span class=\"n\">some</span> <span class=\"n\">msg</span><span class=\"o\">⟩</span>\n        <span class=\"k\">else</span>\n          <span class=\"o\">⟨</span><span class=\"n\">stack</span><span class=\"o\">,</span> <span class=\"n\">lhsPrec</span><span class=\"o\">,</span> <span class=\"n\">errPos</span><span class=\"o\">,</span> <span class=\"n\">cache</span><span class=\"o\">,</span> <span class=\"n\">some</span> <span class=\"n\">msg</span><span class=\"o\">⟩</span>\n      <span class=\"bp\">|</span> <span class=\"n\">other</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">other</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">orelseFnCore</span> <span class=\"n\">antiquotP</span> <span class=\"n\">p</span> <span class=\"n\">antiquotBehavior</span> <span class=\"n\">c</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">withAntiquot'</span> <span class=\"o\">(</span><span class=\"n\">antiquotP</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Parser</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">antiquotBehavior</span> <span class=\"o\">:</span> <span class=\"n\">OrElseOnAntiquotBehavior</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Parser</span> <span class=\"n\">where</span>\n  <span class=\"n\">fn</span> <span class=\"o\">:=</span> <span class=\"n\">withAntiquotFn'</span> <span class=\"n\">antiquotP.fn</span> <span class=\"n\">p.fn</span> <span class=\"n\">antiquotBehavior</span>\n  <span class=\"n\">info</span> <span class=\"o\">:=</span> <span class=\"n\">orelseInfo</span> <span class=\"n\">antiquotP.info</span> <span class=\"n\">p.info</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">combinator_formatter</span> <span class=\"n\">withAntiquot'</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">withAntiquot'.formatter</span> <span class=\"o\">:=</span> <span class=\"n\">Formatter.withAntiquot.formatter</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">combinator_parenthesizer</span> <span class=\"n\">withAntiquot'</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">withAntiquot'.parenthesizer</span> <span class=\"o\">:=</span> <span class=\"n\">Parenthesizer.withAntiquot.parenthesizer</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dollarExprNoAntiquot</span> <span class=\"o\">:=</span>\n  <span class=\"n\">leadingNode</span> <span class=\"bp\">`</span><span class=\"n\">dollarExpr</span> <span class=\"mi\">1024</span> <span class=\"bp\">&lt;|</span> <span class=\"s2\">\"$\"</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">checkNoWsBefore</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">ident</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dollarExpr</span> <span class=\"o\">:</span> <span class=\"n\">Parser</span> <span class=\"o\">:=</span>\n  <span class=\"n\">withAntiquot'</span> <span class=\"o\">(</span><span class=\"n\">mkAntiquot</span> <span class=\"s2\">\"dollarExpr\"</span> <span class=\"bp\">`</span><span class=\"n\">dollarExpr</span><span class=\"o\">)</span> <span class=\"n\">dollarExprNoAntiquot</span> <span class=\"bp\">.</span><span class=\"n\">acceptLhs</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"expr% \"</span> <span class=\"n\">dollarExpr</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">%</span> <span class=\"bp\">$$$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">%</span> <span class=\"bp\">$</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">false</span><span class=\"o\">)</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"#print_term \"</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">#eval</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">quote</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">toString</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">x.raw</span><span class=\"o\">))</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">expr</span><span class=\"bp\">%</span> <span class=\"bp\">$</span><span class=\"n\">Json.null</span> <span class=\"c1\">-- null</span>\n</code></pre></div>",
        "id": 401825832,
        "sender_full_name": "Mac Malone",
        "timestamp": 1699901383
    },
    {
        "content": "<p>awesome, thanks again for the above and beyond response.</p>",
        "id": 401829092,
        "sender_full_name": "Patrick Ford",
        "timestamp": 1699902697
    }
]