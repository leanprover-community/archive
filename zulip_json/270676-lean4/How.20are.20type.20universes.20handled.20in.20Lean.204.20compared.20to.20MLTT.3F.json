[
    {
        "content": "<p>In Martin-LÃ¶f type theory, if we have A : Type u, then we also have A : Type (u+1) (by cumulativity).<br>\nHowever, in Lean 4, for example, Nat : Type (i.e. Nat : Type 0) does not seem to coerce naturally to Type 1, Type 2, or higher universes.<br>\nCould someone explain the formal aspects of Lean 4â€™s type universe system and how it differs from the usual presentation in classical type theory?</p>",
        "id": 540557832,
        "sender_full_name": "Junseong O",
        "timestamp": 1758341542
    },
    {
        "content": "<p>in practice you can do <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ULift#doc\">docs#ULift</a></p>",
        "id": 540558138,
        "sender_full_name": "Lawrence Wu (llllvvuu)",
        "timestamp": 1758341908
    },
    {
        "content": "<p>Oh I see!! Thank you so much <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 540558624,
        "sender_full_name": "Junseong O",
        "timestamp": 1758342506
    },
    {
        "content": "<p>But isnâ€™t this just introducing a new type inductively, rather than a judgment that the same type also belongs to a higher universe?</p>",
        "id": 540559021,
        "sender_full_name": "Junseong O",
        "timestamp": 1758342768
    },
    {
        "content": "<p>Yeah, Lean does not have cumulative universes. We can use <code>ULift</code>, but that is not the same as having cumulativity. Consider <code>A : Type 0</code> and <code>B : A -&gt; Type 1</code> so that <code>(a : A) -&gt; B a : Type 1</code>. Then <code>ULift.{2} A : Type 2</code> and <code>ULift.{2} B : Type 2</code> and <code>ULift.{2} ((a : A) -&gt; B a) : Type 2</code>. Now we can ask, is <code>ULift.{2} ((a : A) -&gt; B a) = (a : ULift.{2} A) -&gt; ULift.{2} (B a.down)</code>, i.e., are the two types provably equal? The answer is no. In a type theory with cumulativity there is no question to be asked because <code>ULift</code>s are silent/not recorded in the terms.</p>",
        "id": 540559789,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1758343721
    },
    {
        "content": "<p>Note also that inductive and Pi type formation in Lean <em>is</em> implicitly cumulative. In the example above we get <code>(a : A) -&gt; B a : Type 1</code> even though <code>A : Type 0</code>. This is basically what lets Lean get away without having general cumulativity, and is the reason why we don't have to use <code>ULift</code> all the time. It would be unusable without this feature.</p>",
        "id": 540559869,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1758343861
    },
    {
        "content": "<p>I see, thank you for the explanation. From which book (or resource) can I learn all the rules of Lean 4 as a formal language?</p>",
        "id": 540560656,
        "sender_full_name": "Junseong O",
        "timestamp": 1758344759
    },
    {
        "content": "<p><a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> is the most precise afaik.</p>",
        "id": 540561068,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1758345328
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 540561543,
        "sender_full_name": "Junseong O",
        "timestamp": 1758346039
    }
]