[
    {
        "content": "<p>I am new to Lean... I am working with LLM in generating Lean4 code. I am using datasets containing theorems but the imports are not provided.</p>\n<p>Is there an existing solution to automatically add the necessary imports?</p>",
        "id": 459521609,
        "sender_full_name": "Maxime Riché",
        "timestamp": 1723221974
    },
    {
        "content": "<p>You could try <code>import Mathlib</code> at the top.</p>",
        "id": 459521773,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1723222054
    },
    {
        "content": "<p>and end with <code>#min_imports</code> to minimise the required imports</p>",
        "id": 459521809,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1723222076
    },
    {
        "content": "<p>It would be pretty neat to have some autoimport mechanism, where \"unknown identifier\" could trigger reading all the oleans and reporting modules that might provide a relevant declaration. I don't know if this is practical, but it would be a nice UX improvement.</p>",
        "id": 459523685,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723222743
    },
    {
        "content": "<p>Haskell and rust do this already. So I have to ask why it wouldn't be feasible?</p>",
        "id": 459537712,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1723226111
    },
    {
        "content": "<p>I'm pretty sure it's feasible and just a matter of prioritization</p>",
        "id": 459539078,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1723226465
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/auto.20imports/near/459523685\">said</a>:</p>\n<blockquote>\n<p>It would be pretty neat to have some autoimport mechanism, where \"unknown identifier\" could trigger reading all the oleans and reporting modules that might provide a relevant declaration. I don't know if this is practical, but it would be a nice UX improvement.</p>\n</blockquote>\n<p>You don't actually have to read all the oleans. The ilean files should contain all of this information already and they should be loaded by the LSP I think? At least I don't know how the LSP would provide symbol search for stuff that you haven't yet imported otherwise. So the key component that is left here is integrating it with the autocompletion mechanism.</p>",
        "id": 459539481,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1723226541
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/270676-lean4/topic/auto.20imports/near/459539078\">said</a>:</p>\n<blockquote>\n<p>I'm pretty sure it's feasible and just a matter of prioritization</p>\n</blockquote>\n<p>Yes, there is lots of other things to be worked on the LSP and VSCode plugin as well.</p>",
        "id": 459540018,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1723226652
    },
    {
        "content": "<p>These are the questions that come to mind:</p>\n<ul>\n<li>How does an open Lean project know everything that could potentially be imported?</li>\n<li>Can you load the declaration names quickly enough that it wouldn't create unacceptable UI delay?</li>\n<li>Is having just declaration names sufficient? Do we need to worry about missing <code>open</code>s or unprocessed <code>export</code> commands? What about dot notation?</li>\n<li>Can this be done from within a lazy message, so that all this processing only happens when a user actually looks at it? Perhaps there are macro tactics out there that depend on name resolution failing fast?</li>\n</ul>",
        "id": 459540341,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723226723
    },
    {
        "content": "<p>Question 1 and 2 is already answered by the fact that you can do symbol search from a plain project that doesn't import <code>Lean</code> within the <code>Lean</code> namespace. The answer to number 1 in particular is most likely that you can just look up all ilean files that are available on the SEARCH_PATH and that should be everything you can ever import.</p>\n<p>The rest do get more interesting yes.</p>",
        "id": 459541761,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1723227011
    },
    {
        "content": "<p>The answer to 3 is to either use fully qualified names which are truncated upto the current namespace</p>",
        "id": 459544255,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1723227557
    },
    {
        "content": "<p>Or add more complex code to <code>open</code>  namespaces</p>",
        "id": 459544774,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1723227652
    },
    {
        "content": "<p>That's a possible answer, but it would take some work to validate it. Plus, it's likely that there needs to be some additional support (if it doesn't already exist for ileans) to be able to find <code>export</code>ed names.</p>",
        "id": 459545019,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723227707
    },
    {
        "content": "<p>You can always cache them as a symbol table with an index that is updated when a new dependency is added or there is an update</p>",
        "id": 459545425,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1723227786
    },
    {
        "content": "<p>Thanks a lot <span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span>  and <span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> ! I will try your solution</p>",
        "id": 459746560,
        "sender_full_name": "Maxime Riché",
        "timestamp": 1723317489
    }
]