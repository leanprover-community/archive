[
    {
        "content": "<p>I'm using Qq and I want to turn some <code>i : Foo</code> into a <code>i : Q(Foo)</code>, so that I can use it in subsequent <code>q</code>/<code>Q</code> macros. I noticed that for <code>n : Nat</code> this just works, but for other types I get an <code>unknown identifier</code> error.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n<span class=\"kn\">open</span> <span class=\"n\">Qq</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"c1\">--   ^------ unknown identifier '«$i»'</span>\n</code></pre></div>\n<p>Is <code>Nat</code> just hard-coded, or is there some typeclass I can implement to make this work?</p>",
        "id": 350187899,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1681575356
    },
    {
        "content": "<p>Does <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin#doc\">docs4#Fin</a> have a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.ToExpr#doc\">docs4#Lean.ToExpr</a> instance?</p>",
        "id": 350193029,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681577943
    },
    {
        "content": "<p>In lean 3 it was <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin.reflect\">docs#fin.reflect</a></p>",
        "id": 350193751,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681578272
    },
    {
        "content": "<p>I would guess we just dropped it when porting</p>",
        "id": 350193822,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681578316
    },
    {
        "content": "<p>Yeah, ToExpr is the typeclass I was looking for, after implementing it for <code>Fin</code> the error disappears</p>",
        "id": 350199305,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1681581106
    },
    {
        "content": "<p>Is there a reason <code>ToExpr</code> takes <code>Type u</code> rather than <code>Sort u</code>? I implemented <code>ToExpr (Fin n)</code> by translating proofs of <code>x &lt; y</code> to <code>Expr</code>, so I figured I could define <code>ToExpr (x &lt; y)</code> as well, but that of course doesn't work if <code>ToExpr</code> only takes types.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Qq</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"o\">(</span><span class=\"n\">ToExpr</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Nat.lt.toExpr</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">h</span>     <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">contradiction</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">_</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat.zero_lt_succ</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.lt_of_succ_lt_succ</span> <span class=\"n\">h</span>\n      <span class=\"k\">let</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">toExpr</span> <span class=\"n\">h</span>\n      <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat.succ_lt_succ</span> <span class=\"bp\">$</span><span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ToExpr</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toExpr</span>      <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Fin.mk</span> <span class=\"bp\">$</span><span class=\"n\">i</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">Nat.lt.toExpr</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n  <span class=\"n\">toTypeExpr</span>  <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 350199550,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1681581260
    },
    {
        "content": "<p>Looks like we created effectively the same implementation in parallel:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"k\">in</span>\n<span class=\"sd\">/-- Returns a proof of a &lt; b -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">ltToExpr</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Nat.not_lt_zero</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Nat.succ_pos</span> <span class=\"o\">[])</span> <span class=\"o\">(</span><span class=\"n\">toExpr</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">ltToExpr</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">Nat.lt_of_succ_lt_succ</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n    <span class=\"n\">mkApp3</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Nat.succ_lt_succ</span> <span class=\"o\">[])</span> <span class=\"o\">(</span><span class=\"n\">toExpr</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">toExpr</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">e</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"k\">in</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToExpr</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toExpr</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">mkApp3</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Fin.mk</span> <span class=\"o\">[])</span> <span class=\"o\">(</span><span class=\"n\">toExpr</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">toExpr</span> <span class=\"n\">x.1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ltToExpr</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">x.2</span><span class=\"o\">)</span>\n  <span class=\"n\">toTypeExpr</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Fin</span> <span class=\"o\">[])</span> <span class=\"o\">(</span><span class=\"n\">toExpr</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.proofs</span> <span class=\"n\">true</span>\n<span class=\"k\">#eval</span> <span class=\"n\">Lean.PrettyPrinter.ppExpr</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Lean.toExpr</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n<span class=\"c1\">-- { val := 3, isLt := Nat.succ_lt_succ (Nat.succ_lt_succ (Nat.succ_lt_succ (Nat.succ_pos 1))) }</span>\n</code></pre></div>",
        "id": 350199723,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681581380
    },
    {
        "content": "<p>Maybe <code>ToExpr</code> takes a <code>Type _</code> because there's no runtime values associated to proofs (they're erased)?</p>\n<p>We could use <code>PLift</code> here to create these sorts of instances anyway, at the cost of needing to insert some <code>PLift.up</code>s and <code>PLift.down</code>s:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Qq</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Nat.lt.toExpr</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">h</span>     <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Nat.not_lt_zero</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">_</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat.zero_lt_succ</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">toExpr</span> <span class=\"o\">(</span><span class=\"n\">Nat.lt_of_succ_lt_succ</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n      <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat.succ_lt_succ</span> <span class=\"bp\">$</span><span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ToExpr</span> <span class=\"o\">(</span><span class=\"n\">PLift</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">toExpr</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">PLift.up</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">Nat.lt.toExpr</span> <span class=\"n\">h.down</span><span class=\"o\">))</span>\n  <span class=\"n\">toTypeExpr</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">PLift</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">))</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ToExpr</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toExpr</span>      <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">PLift</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">toExpr</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">PLift.up</span> <span class=\"n\">h</span>\n    <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Fin.mk</span> <span class=\"bp\">$</span><span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">PLift.down</span> <span class=\"bp\">$</span><span class=\"n\">h'</span><span class=\"o\">))</span>\n  <span class=\"n\">toTypeExpr</span>  <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 350200810,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681582091
    },
    {
        "content": "<p>Another possible reason might be that most terms in <code>Prop</code> can’t be eliminated to <code>Type _</code>, making <code>ToExpr</code> only useful for subsingleton types, for which the rendered expressions would be trivial anyway</p>",
        "id": 350201369,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1681582460
    },
    {
        "content": "<p>I don't think that's explaining it -- all <code>ToExpr p</code> needs to do is synthesize a proof of <code>p</code> using the symbolic structure of <code>p</code> itself, given a proof of <code>p</code>. Look at how <code>Nat.lt.toExpr</code> is defined. It recurses on <code>x</code> and <code>y</code>, and then it only uses <code>h</code> when it's equivalent to <code>False</code> to be able to omit a case.</p>\n<p>The situation seems to be similar to <code>Decidable</code> instances. In fact, one could imagine a typeclass <code>DecideExpr p</code> that synthesizes an expression for either a proof of <code>p</code> or a proof of <code>not p</code>, depending on which is true. Then given one of these you can just use that proof directly for a <code>ToExpr</code> instance (since you know ahead of time the <code>DecideExpr</code> instance will never produce the negation proof).</p>\n<p><em>Edit:</em> I suppose this is all to say that you're right that it's important that propositions are subsingletons, with the caveat that since typeclass inference can look at the symbolic structure of the proposition there's still a lot you can do.</p>",
        "id": 350202096,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681582996
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Qq.20and.20reflecting.20meta-level.20values/near/350200810\">said</a>:</p>\n<blockquote>\n<p>Maybe <code>ToExpr</code> takes a <code>Type _</code> because there's no runtime values associated to proofs (they're erased)?</p>\n</blockquote>\n<p>That's true, but <code>Expr</code> isn't quite a runtime value yet. We do want to be able to construct expressions that correspond to proofs of <code>Prop</code>s (as witnessed by our implementations of <code>ToExpr (Fin n)</code>). The <code>PLift</code> trick is a cool workaround (thanks for showing it!), but for me it just reaffirms that it would be useful to have some built-in way to reflect a <code>Prop</code>.</p>\n<blockquote>\n<p>Another possible reason might be that most terms in Prop can’t be eliminated to Type _, making ToExpr only useful for subsingleton types, for which the rendered expressions would be trivial anyway</p>\n</blockquote>\n<p>That's fair, the translation cannot inspect the actual meta-level proof object, so maybe <code>ToExpr</code> is not the right class. Effectively, we just want to know that <code>Q(p)</code> is inhabited, for some <code>p : Prop</code>.</p>\n<p>Possibly a solution is to special case Qq so that <code>q($h)</code> where the type of <code>h</code>is a <code>P : Prop</code> instead tries to synthesize <code>Inhabited Q($P)</code></p>",
        "id": 350202190,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1681583047
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/270676-lean4/topic/Qq.20and.20reflecting.20meta-level.20values/near/350202190\">said</a>:</p>\n<blockquote>\n<p>That's true, but <code>Expr</code> isn't quite a runtime value yet.</p>\n</blockquote>\n<p>I agree (and the <code>PLift</code> trick shows these sorts of instances aren't useless). What I meant is that I believe the intended use was to be able to <code>#eval</code> an expression and then <code>toExpr</code> it. We're sort of misusing it here (not to say that we shouldn't be allowed to misuse it!) because we're using the fact that typeclass inference is symbolic, so from the elaboration-time type we can get <code>x</code> and <code>y</code>.</p>",
        "id": 350202595,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681583331
    },
    {
        "content": "<p>Shouldn't <code>Fin.toExpr</code> generate <code>ofNat</code> like it did in Lean 3?</p>",
        "id": 350202839,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681583512
    },
    {
        "content": "<p>I thought the idea was that it generate the canonical expression, as opposed to the most efficient one</p>",
        "id": 350202893,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681583530
    },
    {
        "content": "<p>I mean, I just learned about <code>ToExpr</code> yesterday, so I'm maybe not the most qualified person on that subject, but it seems that for <code>Qq</code>'s purposes it's beneficial to generate more efficient representations if we can. Compile-times are already not great, so if we can cut that down a bit, that seems good. (If there are other issues that I'm overlooking, please do tell me).</p>\n<p>Now, since Kyle mentioned that maybe we're misusing <code>ToExpr</code>, I figured I could try making a dedicated <code>QuoteExpr</code> typeclass that <em>does</em> allow for <code>Prop</code>s. It also uses the <code>QQ</code> type-family for some extra type-safety (at the cost of flexibility with the universe)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">  Gives a meta-level representation of the universe in which some type `α` lives</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">class</span> <span class=\"n\">QuoteUnivOf</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- Object representing the universe of `α` -/</span>\n  <span class=\"n\">quoteUniv</span> <span class=\"o\">:</span> <span class=\"n\">Level</span>\n\n\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  Converts a value of type `α` into an expression that represents this value in Lean.</span>\n\n<span class=\"sd\">  This class differs from the built-in `ToExpr` in two ways:</span>\n<span class=\"sd\">    * It allows implementation for `α : Prop`, whereas `ToExpr` is only for `Type _`s</span>\n<span class=\"sd\">    * We use the `QQ` type family to assert the type of the returned expressions.</span>\n<span class=\"sd\">      This ensures this type information is available when implementors use the `q(⋅)` macro</span>\n<span class=\"sd\">      to construct the expression.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">class</span> <span class=\"n\">QuoteExpr</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">QuoteUnivOf</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- Expression representing the type `α` -/</span>\n  <span class=\"n\">quoteTypeExpr</span> <span class=\"o\">:</span> <span class=\"n\">QQ</span> <span class=\"o\">(</span><span class=\"n\">Expr.sort</span> <span class=\"n\">quoteUniv</span><span class=\"o\">)</span>\n  <span class=\"sd\">/-- Convert a value `a : α` into an expression that denotes `a` -/</span>\n  <span class=\"n\">quoteExpr</span>     <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">QQ</span> <span class=\"n\">quoteTypeExpr</span>\n</code></pre></div>\n<p>With this class, we can write the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Qq.QuoteExpr</span>\n<span class=\"kn\">import</span> <span class=\"n\">Qq.Macro</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"o\">(</span><span class=\"n\">Level</span> <span class=\"n\">ToExpr</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Qq</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">QuoteUnivOf</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Level.ofNat</span> <span class=\"mi\">0</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">QuoteUnivOf</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Level.ofNat</span> <span class=\"mi\">1</span><span class=\"o\">⟩</span>\n\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  Define a fallback instance of `QuoteExpr` for implementors of `ToExpr`</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">low</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ToExpr</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">QuoteUnivOf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">QuoteExpr</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">quoteTypeExpr</span> <span class=\"o\">:=</span> <span class=\"n\">ToExpr.toTypeExpr</span> <span class=\"n\">α</span>\n  <span class=\"n\">quoteExpr</span> <span class=\"n\">a</span>   <span class=\"o\">:=</span> <span class=\"n\">ToExpr.toExpr</span> <span class=\"n\">a</span>\n\n\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">QuoteExpr</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">quoteTypeExpr</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"n\">quoteExpr</span> <span class=\"o\">:=</span> <span class=\"n\">go</span> <span class=\"n\">where</span>\n    <span class=\"n\">go</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span>      <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">contradiction</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span>    <span class=\"bp\">=&gt;</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat.zero_lt_succ</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span>  <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.lt_of_succ_lt_succ</span> <span class=\"n\">h</span>\n      <span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">go</span> <span class=\"n\">h</span>\n      <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Nat.succ_lt_succ</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">$</span><span class=\"n\">h</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">QuoteExpr</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">quoteTypeExpr</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"n\">quoteExpr</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">q</span><span class=\"o\">(⟨</span><span class=\"bp\">$</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">h</span><span class=\"o\">⟩)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Qq</span>\n</code></pre></div>",
        "id": 350291612,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1681641937
    },
    {
        "content": "<p>Re: the universe flexibility. I think we do lose the flexibility to define universe polymorphic instances, since we have provide a <code>Level</code> object .<br>\nIs it possible to define some universe polymorphic <code>quoteLevel.{u} : Level</code> so that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">quoteLevel.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span>  <span class=\"bp\">=</span>  <span class=\"n\">Level.ofNat</span> <span class=\"mi\">0</span>\n<span class=\"n\">quoteLevel.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span>  <span class=\"bp\">=</span>  <span class=\"n\">Level.ofNat</span> <span class=\"mi\">1</span>\n<span class=\"n\">quoteLevel.</span><span class=\"o\">{</span><span class=\"mi\">2</span><span class=\"o\">}</span>  <span class=\"bp\">=</span>  <span class=\"n\">Level.ofNat</span> <span class=\"mi\">2</span>\n<span class=\"bp\">...</span>\n</code></pre></div>\n<p>I would expect not.<br>\nThen again, I also wonder whether it's even possible to write a correct universe polymorphic <code>ToExpr</code> instance. Presumably, if the constructed expression indeed lives in some arbitrary universe <code>u</code>, the expressions contains a <code>Level</code> representation of this universe anyway.</p>",
        "id": 350292604,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1681642435
    },
    {
        "content": "<p>We already have this, its <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ToLevel#doc\">docs4#ToLevel</a></p>",
        "id": 350293708,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681642961
    },
    {
        "content": "<p>Hmm, that link 404's</p>",
        "id": 350293958,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1681643069
    },
    {
        "content": "<p>I found it at <a href=\"https://github.com/leanprover-community/mathlib4/blob/94c39a2c516923d789c4061d221b746708eed5dd/Mathlib/Tactic/ToLevel.lean\">https://github.com/leanprover-community/mathlib4/blob/94c39a2c516923d789c4061d221b746708eed5dd/Mathlib/Tactic/ToLevel.lean</a><br>\nThat one is indeed better than my attempt, thanks! <br>\nWhat I meant, though, is some definition of <code>quoteLevel</code> where even </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"n\">quoteLevel.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Would do the right thing, I expect this to be impossible</p>",
        "id": 350295171,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1681643615
    },
    {
        "content": "<p>What would be the point?</p>",
        "id": 350296677,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681644359
    },
    {
        "content": "<p>Just write <code>[ToLevel.{u}]</code> as a hypothesis instead</p>",
        "id": 350296735,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681644370
    },
    {
        "content": "<p>In all the cases where you actually need it I think Lean will find the instance</p>",
        "id": 350296792,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681644395
    },
    {
        "content": "<p>Yeah, I also think <code>ToLevel</code> is enough, I was just wondering if I was overlooking something.<br>\nMy definition of <code>QuoteExpr \\alpha</code> (where <code>\\alpha : Sort u</code> ) indeed depends on a <code>ToLevel.{u}</code> instance being found, whereas it is possible to define <code>ToExpr \\alpha</code> without it. Hence, in theory, you lose some flexibility. In practice, I expect actually defining a <em>correct</em> <code>ToExpr</code> instance is impossible without <code>ToLevel.{u}</code>. Unless something like <code>quoteLevel</code> as I described it were possible</p>",
        "id": 350298162,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1681644982
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/270676-lean4/topic/Qq.20and.20reflecting.20meta-level.20values/near/350291612\">said</a>:</p>\n<blockquote>\n<p>I mean, I just learned about <code>ToExpr</code> yesterday, so I'm maybe not the most qualified person on that subject, but it seems that for <code>Qq</code>'s purposes it's beneficial to generate more efficient representations if we can. Compile-times are already not great, so if we can cut that down a bit, that seems good. (If there are other issues that I'm overlooking, please do tell me).</p>\n<p>Now, since Kyle mentioned that maybe we're misusing <code>ToExpr</code>, I figured I could try making a dedicated <code>QuoteExpr</code> typeclass that <em>does</em> allow for <code>Prop</code>s. It also uses the <code>QQ</code> type-family for some extra type-safety (at the cost of flexibility with the universe)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">  Gives a meta-level representation of the universe in which some type `α` lives</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">class</span> <span class=\"n\">QuoteUnivOf</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- Object representing the universe of `α` -/</span>\n  <span class=\"n\">quoteUniv</span> <span class=\"o\">:</span> <span class=\"n\">Level</span>\n\n\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  Converts a value of type `α` into an expression that represents this value in Lean.</span>\n\n<span class=\"sd\">  This class differs from the built-in `ToExpr` in two ways:</span>\n<span class=\"sd\">    * It allows implementation for `α : Prop`, whereas `ToExpr` is only for `Type _`s</span>\n<span class=\"sd\">    * We use the `QQ` type family to assert the type of the returned expressions.</span>\n<span class=\"sd\">      This ensures this type information is available when implementors use the `q(⋅)` macro</span>\n<span class=\"sd\">      to construct the expression.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">class</span> <span class=\"n\">QuoteExpr</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">QuoteUnivOf</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- Expression representing the type `α` -/</span>\n  <span class=\"n\">quoteTypeExpr</span> <span class=\"o\">:</span> <span class=\"n\">QQ</span> <span class=\"o\">(</span><span class=\"n\">Expr.sort</span> <span class=\"n\">quoteUniv</span><span class=\"o\">)</span>\n  <span class=\"sd\">/-- Convert a value `a : α` into an expression that denotes `a` -/</span>\n  <span class=\"n\">quoteExpr</span>     <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">QQ</span> <span class=\"n\">quoteTypeExpr</span>\n</code></pre></div>\n<p>With this class, we can write the following</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Qq.QuoteExpr</span>\n<span class=\"kn\">import</span> <span class=\"n\">Qq.Macro</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"o\">(</span><span class=\"n\">Level</span> <span class=\"n\">ToExpr</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Qq</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">QuoteUnivOf</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Level.ofNat</span> <span class=\"mi\">0</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">QuoteUnivOf</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Level.ofNat</span> <span class=\"mi\">1</span><span class=\"o\">⟩</span>\n\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  Define a fallback instance of `QuoteExpr` for implementors of `ToExpr`</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">low</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ToExpr</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">QuoteUnivOf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">QuoteExpr</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">quoteTypeExpr</span> <span class=\"o\">:=</span> <span class=\"n\">ToExpr.toTypeExpr</span> <span class=\"n\">α</span>\n  <span class=\"n\">quoteExpr</span> <span class=\"n\">a</span>   <span class=\"o\">:=</span> <span class=\"n\">ToExpr.toExpr</span> <span class=\"n\">a</span>\n\n\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">QuoteExpr</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">quoteTypeExpr</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"n\">quoteExpr</span> <span class=\"o\">:=</span> <span class=\"n\">go</span> <span class=\"n\">where</span>\n    <span class=\"n\">go</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span>      <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">contradiction</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span>    <span class=\"bp\">=&gt;</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat.zero_lt_succ</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span>  <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.lt_of_succ_lt_succ</span> <span class=\"n\">h</span>\n      <span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">go</span> <span class=\"n\">h</span>\n      <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Nat.succ_lt_succ</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">$</span><span class=\"n\">h</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">QuoteExpr</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">quoteTypeExpr</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"n\">quoteExpr</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">q</span><span class=\"o\">(⟨</span><span class=\"bp\">$</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">h</span><span class=\"o\">⟩)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Qq</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> would you be interested in a PR to <code>Qq</code> with this typeclass? Even if <code>ToExpr</code> gets changed to also accept <code>Prop</code>s, having a <code>Qq</code> specific typeclass (with instances going back and forth) has the benefit of propagating expected types a bit better, if implementors use <code>q(...)</code> to construct their expression. Of course, it has the downside of being a bit confusing, having <code>ToExpr</code> and <code>QuoteExpr</code> for basically the same purpose.</p>",
        "id": 350602748,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1681760805
    },
    {
        "content": "<p>Here's another design:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.ToExpr</span>\n<span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Qq</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ReflectType</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ToLevel.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}]</span> <span class=\"n\">where</span>\n  <span class=\"n\">reflectType</span> <span class=\"o\">:</span> <span class=\"n\">QQ</span> <span class=\"o\">(</span><span class=\"n\">Expr.sort</span> <span class=\"n\">toLevel.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">ReflectType</span> <span class=\"o\">(</span><span class=\"n\">reflectType</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Reflect</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ToLevel.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}]</span> <span class=\"o\">[</span><span class=\"n\">ReflectType</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">reflect</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span>  <span class=\"n\">QQ</span> <span class=\"o\">(</span><span class=\"n\">reflectType</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">Reflect</span> <span class=\"o\">(</span><span class=\"n\">reflect</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 350608861,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681763106
    },
    {
        "content": "<p>This lets you reflect types even if their terms aren't in general reflectable. For example, function types:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ToLevel.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}]</span> <span class=\"o\">[</span><span class=\"n\">ToLevel.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}]</span> <span class=\"o\">[</span><span class=\"n\">ReflectType</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ReflectType</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">ToLevel.</span><span class=\"o\">{</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)}]</span> <span class=\"o\">:</span> <span class=\"n\">ReflectType</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">reflectType</span> <span class=\"o\">:=</span> <span class=\"n\">Expr.forallE</span> <span class=\"bp\">`</span><span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">reflectType</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">reflectType</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">.</span><span class=\"n\">default</span>\n</code></pre></div>",
        "id": 350608918,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681763129
    },
    {
        "content": "<p>It's also easy to use pre-existing <code>ToExpr</code> instances to define these instances:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ReflectType</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span>\n  <span class=\"n\">reflectType</span> <span class=\"o\">:=</span> <span class=\"n\">toTypeExpr</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Reflect</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span>\n  <span class=\"n\">reflect</span> <span class=\"o\">:=</span> <span class=\"n\">toExpr</span>\n</code></pre></div>",
        "id": 350609089,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681763186
    },
    {
        "content": "<p>I don't think I've got things quite right yet; universe variables don't seem to be handled properly. Ideally that function instance could be written using <code>q(...)</code> somehow.</p>",
        "id": 350610732,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681763784
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Qq.20and.20reflecting.20meta-level.20values/near/350202839\">said</a>:</p>\n<blockquote>\n<p>Shouldn't <code>Fin.toExpr</code> generate <code>ofNat</code> like it did in Lean 3?</p>\n</blockquote>\n<p>I've attempted to PR this in <a href=\"https://github.com/leanprover-community/mathlib4/pull/3486\">!4#3486</a>, though I can't work out how to use <code>=Q</code></p>",
        "id": 350611489,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681764088
    },
    {
        "content": "<blockquote>\n<p>This lets you reflect types even if their terms aren't in general reflectable.</p>\n</blockquote>\n<p>This is the design we had in Lean 3 I think with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/reflect\">docs#reflect</a> vs <a href=\"https://leanprover-community.github.io/mathlib_docs/find/reflected\">docs#reflected</a> (and also <a href=\"https://leanprover-community.github.io/mathlib_docs/find/reflected_value\">docs#reflected_value</a>)</p>",
        "id": 350611566,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681764123
    },
    {
        "content": "<p>I got as far as getting exciting new errors with this version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Qq</span> <span class=\"k\">in</span>\n<span class=\"n\">unsafe</span> <span class=\"kd\">instance</span> <span class=\"n\">toExpr</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ToExpr</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toTypeExpr</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"n\">toExpr</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">finZeroElim</span>\n    <span class=\"bp\">|</span> <span class=\"n\">n'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">i'</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.toExpr</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n      <span class=\"k\">let</span> <span class=\"n\">_n_eq</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">n'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span><span class=\"n\">Q</span> <span class=\"bp\">$</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n      <span class=\"k\">let</span> <span class=\"n\">pf</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">NeZero</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">NeZero.succ</span> <span class=\"bp\">$</span><span class=\"n\">n'</span><span class=\"o\">)</span>\n      <span class=\"n\">q</span><span class=\"o\">((</span><span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">NeZero</span> <span class=\"bp\">$</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">pf</span><span class=\"bp\">;</span> <span class=\"n\">OfNat.ofNat</span> <span class=\"bp\">$</span><span class=\"n\">i'</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">reduceEval</span><span class=\"o\">:</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">evaluate</span> <span class=\"n\">argument</span>\n  <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 350614806,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681765424
    },
    {
        "content": "<p>I was also thinking of making the value to be reflected a parameter to the class</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.ToExpr</span>\n<span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Qq</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ReflectType</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ToLevel.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}]</span> <span class=\"n\">where</span>\n  <span class=\"n\">reflectType</span> <span class=\"o\">:</span> <span class=\"n\">QQ</span> <span class=\"o\">(</span><span class=\"n\">Expr.sort</span> <span class=\"n\">toLevel.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span>\n\n\n<span class=\"kd\">class</span> <span class=\"n\">Reflect</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ToLevel.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}]</span> <span class=\"o\">[</span><span class=\"n\">ReflectType</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">reflect</span> <span class=\"o\">:</span> <span class=\"n\">QQ</span> <span class=\"o\">(</span><span class=\"n\">ReflectType.reflectType</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">Reflect</span> <span class=\"o\">(</span><span class=\"n\">reflect</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>That would allow us to reflect specific terms of types that we may not know how to reflect in general. In particular, with some clever instances we can make <code>reflect</code> work on types, too, making <code>ReflectType</code> just an internal implementation detail.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">ToLevel.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}]</span> <span class=\"o\">:</span> <span class=\"n\">ReflectType</span> <span class=\"o\">(</span><span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">reflectType</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">sort</span> <span class=\"n\">toLevel.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ToLevel.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}]</span> <span class=\"o\">[</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ReflectType</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Reflect</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">reflect</span> <span class=\"o\">:=</span> <span class=\"n\">r.reflectType</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ToLevel.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}]</span> <span class=\"o\">[</span><span class=\"n\">Reflect</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ReflectType</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">reflectType</span> <span class=\"o\">:=</span> <span class=\"n\">reflect</span> <span class=\"n\">α</span>\n\n\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Reflect</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span>\n  <span class=\"n\">reflect</span> <span class=\"o\">:=</span> <span class=\"n\">toTypeExpr</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Reflect</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n  <span class=\"n\">reflect</span> <span class=\"o\">:=</span> <span class=\"n\">toExpr</span> <span class=\"n\">n</span>\n\n\n<span class=\"k\">#check</span> <span class=\"n\">reflect</span> <span class=\"n\">Nat</span>\n<span class=\"k\">#check</span> <span class=\"n\">reflect</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 350615497,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1681765726
    },
    {
        "content": "<p>With this version we can even (ab)use typeclass synthesis for some symbolic reasoning:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">  Some structure that incorporates a function, thus cannot be reflected in general</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Foo</span> <span class=\"n\">where</span>\n  <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  Construct a `Foo` from just a `Nat`, using `id` as the function</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Foo.ofNat</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">⟩</span>\n\n\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Reflect</span> <span class=\"n\">Foo</span> <span class=\"n\">where</span>\n  <span class=\"n\">reflect</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Foo</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Reflect</span> <span class=\"o\">(</span><span class=\"n\">Foo.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">reflect</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Foo.ofNat</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n\n<span class=\"kn\">section</span>\n  <span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">)</span>\n\n  <span class=\"c\">/-</span>\n<span class=\"cm\">    Whoops, we cannot reflect `Foo` in general:</span>\n<span class=\"cm\">    failed to synthesize instance</span>\n<span class=\"cm\">      Reflect foo</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"k\">#check</span> <span class=\"n\">reflect</span> <span class=\"n\">foo</span>\n\n  <span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n  <span class=\"c\">/-</span>\n<span class=\"cm\">    But this does work!</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"k\">#check</span>\n    <span class=\"k\">let</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"n\">Foo.ofNat</span> <span class=\"n\">n</span>\n    <span class=\"n\">reflect</span> <span class=\"n\">bar</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I'm not sure actually defining these instances is a good idea, but it's cool!</p>",
        "id": 350616980,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1681766397
    },
    {
        "content": "<p>Congrats, you've reinvented (a QQ-friendly version of) <a href=\"https://leanprover-community.github.io/mathlib_docs/find/reflected\">docs#reflected</a>! But I agree that design looks useful, and I don't know why it was changed between Lean 3 and Lean 4</p>",
        "id": 350709786,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681807501
    },
    {
        "content": "<p><del>docs#Lean.ToLevel now exists. Is there a straightforward way to teach Qq about this?</del> nevermind, I guess it already existed above!</p>",
        "id": 374904419,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689249528
    }
]