[
    {
        "content": "<p>Thanks to the <code>TryThis</code> code and some code from the <code>say</code> tactic, using the Task framework here is a tool for running a tactic automatically in the background. By default this is <code>aesop?</code> but anything else can be used. The idea is to prove with a slightly different syntax: using <code>by#</code> in place of <code>by</code> with processes running in the background trying to complete the proof.</p>\n<p>I am posting here for initial feedback but will PR to mathlib for detailed feedback soon.  <span class=\"user-mention\" data-user-id=\"303675\">@Anand Rao Tadipatri</span> is working on something related.</p>\n<h2>Easy proofs</h2>\n<p><a href=\"/user_uploads/3121/RASwyrhy2_BylwjJ5DUCopDF/async-1.gif\">async-1.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/RASwyrhy2_BylwjJ5DUCopDF/async-1.gif\" title=\"async-1.gif\"><img src=\"/user_uploads/3121/RASwyrhy2_BylwjJ5DUCopDF/async-1.gif\"></a></div><p>If a proof is reasonably simple <code>aesop</code> will complete it. The <code>by#</code> notation is a macro for the more flexible notation:<br>\n<a href=\"/user_uploads/3121/C7bkrYTdz5qN7vssA5qxxMnG/async-2.gif\">async-2.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/C7bkrYTdz5qN7vssA5qxxMnG/async-2.gif\" title=\"async-2.gif\"><img src=\"/user_uploads/3121/C7bkrYTdz5qN7vssA5qxxMnG/async-2.gif\"></a></div><h2>Proofs needing help</h2>\n<p>The following is introduced to make sure Aesop cannot solve automatically:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">sillyN</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">silly</span> <span class=\"o\">:</span> <span class=\"n\">sillyN</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span>\n</code></pre></div>\n<p>In the next two illustrations once we have given enough hints, the proof is completed. Note that for even a complete proof we need a code-action to make <code>by#</code> into <code>by</code> to be valid Lean syntax.</p>\n<p><a href=\"/user_uploads/3121/ljmEC4oINP5a2urV2IaZtexE/async-3.gif\">async-3.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/ljmEC4oINP5a2urV2IaZtexE/async-3.gif\" title=\"async-3.gif\"><img src=\"/user_uploads/3121/ljmEC4oINP5a2urV2IaZtexE/async-3.gif\"></a></div><p><a href=\"/user_uploads/3121/T8k6GgGLXyM86IeMD7x0eCrP/async-4.gif\">async-4.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/T8k6GgGLXyM86IeMD7x0eCrP/async-4.gif\" title=\"async-4.gif\"><img src=\"/user_uploads/3121/T8k6GgGLXyM86IeMD7x0eCrP/async-4.gif\"></a></div><h2>Using other automation</h2>\n<p>In the next example we use <code>apply?</code> instead of <code>aesop?</code>. This is a little slower so does not finish within the builtin delay (50ms by default) but kicks in as we continue proving.</p>\n<p><a href=\"/user_uploads/3121/fh7oQ2aW3ZZji_OkxdKsCG3D/async-5.gif\">async-5.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/fh7oQ2aW3ZZji_OkxdKsCG3D/async-5.gif\" title=\"async-5.gif\"><img src=\"/user_uploads/3121/fh7oQ2aW3ZZji_OkxdKsCG3D/async-5.gif\"></a></div><h2>Using tactics without \"try this\"</h2>\n<p>Both <code>aesop?</code> and <code>apply?</code> have a \"Try this:\" message which is intercepted and used. If a tactic is not such a search, then it is tried and the proof is completed when it is enough to finish. This is illustrated by using <code>linarith</code>.</p>\n<p><a href=\"/user_uploads/3121/2JHPqldoSCfg6_oQ9xpPsIlB/async-6.gif\">async-6.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/2JHPqldoSCfg6_oQ9xpPsIlB/async-6.gif\" title=\"async-6.gif\"><img src=\"/user_uploads/3121/2JHPqldoSCfg6_oQ9xpPsIlB/async-6.gif\"></a></div><p>This also illustrates a limitation: we do not look through induction, cases, match etc. An easy workaround is to have a macro and manually enter this mode.</p>\n<h2>The source</h2>\n<p>The source is at <a href=\"https://github.com/siddhartha-gadgil/LeanAide/blob/main/LeanAide/Async.lean\">https://github.com/siddhartha-gadgil/LeanAide/blob/main/LeanAide/Async.lean</a></p>",
        "id": 378792005,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1690376427
    },
    {
        "content": "<p>The demos would be a lot easier to follow if you could switch off whatever is producing the grey text (assuming this is indeed completely unrelated to what you want to show us).</p>",
        "id": 378800599,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1690377907
    },
    {
        "content": "<p>Sure. That is Github copilot in the background (and is unrelated). I will redo with it off.</p>",
        "id": 378802020,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1690378158
    },
    {
        "content": "<p>I wondered what that was :)</p>",
        "id": 378803614,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1690378412
    },
    {
        "content": "<p>This is what I guessed. Thanks!</p>",
        "id": 378805071,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1690378679
    },
    {
        "content": "<p>Here are the demos with copilot off to avoid the distracting grey stuff:</p>\n<ol>\n<li>\n<p>Easy proofs: short and full syntax<br>\n<a href=\"/user_uploads/3121/tDMA3WeNkr3TEh6Oaa4unIgW/async-1a.gif\">async-1a.gif</a><br>\n<a href=\"/user_uploads/3121/sB6RRRYirnB7WH1ftHJ5FgDI/async-2a.gif\">async-2a.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/tDMA3WeNkr3TEh6Oaa4unIgW/async-1a.gif\" title=\"async-1a.gif\"><img src=\"/user_uploads/3121/tDMA3WeNkr3TEh6Oaa4unIgW/async-1a.gif\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/3121/sB6RRRYirnB7WH1ftHJ5FgDI/async-2a.gif\" title=\"async-2a.gif\"><img src=\"/user_uploads/3121/sB6RRRYirnB7WH1ftHJ5FgDI/async-2a.gif\"></a></div></li>\n<li>\n<p>Proofs that cannot be fully automatic: with rewriting to standard notation even when the user gives the full proof.<br>\n<a href=\"/user_uploads/3121/oHyI-Jh49PEfYMr9lHmArvlC/async-3a.gif\">async-3a.gif</a><br>\n<a href=\"/user_uploads/3121/TVkCq8uNOp1w3xnZP438R0JQ/async-4a.gif\">async-4a.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/oHyI-Jh49PEfYMr9lHmArvlC/async-3a.gif\" title=\"async-3a.gif\"><img src=\"/user_uploads/3121/oHyI-Jh49PEfYMr9lHmArvlC/async-3a.gif\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/3121/TVkCq8uNOp1w3xnZP438R0JQ/async-4a.gif\" title=\"async-4a.gif\"><img src=\"/user_uploads/3121/TVkCq8uNOp1w3xnZP438R0JQ/async-4a.gif\"></a></div></li>\n<li>\n<p>Using apply: also illustrating continuing running in the background even after the waiting period.<br>\n<a href=\"/user_uploads/3121/C3m7Edzc04RhW_OyFs3na6Tb/async-5a.gif\">async-5a.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/C3m7Edzc04RhW_OyFs3na6Tb/async-5a.gif\" title=\"async-5a.gif\"><img src=\"/user_uploads/3121/C3m7Edzc04RhW_OyFs3na6Tb/async-5a.gif\"></a></div></li>\n<li>\n<p>Using <code>linarith</code> instead of a search tactic: still tried after each step.<br>\n<a href=\"/user_uploads/3121/grEc_9tdgUoUrHXDDTDgjqBp/async-6a.gif\">async-6a.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/grEc_9tdgUoUrHXDDTDgjqBp/async-6a.gif\" title=\"async-6a.gif\"><img src=\"/user_uploads/3121/grEc_9tdgUoUrHXDDTDgjqBp/async-6a.gif\"></a></div></li>\n</ol>",
        "id": 378824560,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1690381746
    },
    {
        "content": "<p>PRed as <a href=\"https://github.com/leanprover-community/mathlib4/pull/6176\">#6176</a></p>\n<p>One small piece of this is a \"sorry tactic detector\". Is there something builtin for this? I try to use a tactic to prove <code>False</code> and it is <code>sorry</code> if it succeeds.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">isSorry</span> <span class=\"o\">(</span><span class=\"n\">tacticCode</span><span class=\"o\">:</span> <span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">tactic</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">goal</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">False</span><span class=\"o\">)</span>\n  <span class=\"n\">try</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">goals</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">Elab.runTactic</span>  <span class=\"n\">goal.mvarId</span><span class=\"bp\">!</span> <span class=\"n\">tacticCode</span>\n    <span class=\"n\">return</span> <span class=\"n\">goals.isEmpty</span>\n  <span class=\"n\">catch</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">return</span> <span class=\"n\">false</span>\n</code></pre></div>",
        "id": 379341705,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1690509581
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <br>\nI forgot that none of my examples illustrated the point that the main mode is tactics continuing to run in the background. If they finish successfully, the result is saved. A fresh elaboration with the same goal state and some stage triggers this.</p>\n<p>The following gif illustrates this (by making delay 0).<br>\n<a href=\"/user_uploads/3121/scUlvAeRNk-Mv2nYCT_86SPe/async-7.gif\">async-7.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/scUlvAeRNk-Mv2nYCT_86SPe/async-7.gif\" title=\"async-7.gif\"><img src=\"/user_uploads/3121/scUlvAeRNk-Mv2nYCT_86SPe/async-7.gif\"></a></div><ul>\n<li>When one runs <code>by#</code>, though the search is started there is no delay so it does not finish.</li>\n<li>When skip is run, the elaborator goes through the tactics again, and this time sees the completed proof and offers a code action (again there is no delay, but the proof was ready).</li>\n</ul>",
        "id": 385435155,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1692182710
    },
    {
        "content": "<p>The idea is that the user keeps trying to prove. If aesop (or chosen automation) could finish at some earlier stage, or essentially instantly after the current stage, a code action is offered to finish the proof.</p>",
        "id": 385435375,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1692182788
    }
]