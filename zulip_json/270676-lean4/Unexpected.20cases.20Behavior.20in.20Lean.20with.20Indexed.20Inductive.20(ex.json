[
    {
        "content": "<p>I encountered an issue while working through Software Foundations in Lean.<br>\nThis is from the regular expression example: <a href=\"https://softwarefoundations.cis.upenn.edu/lf-current/IndProp.html#lab268\">https://softwarefoundations.cis.upenn.edu/lf-current/IndProp.html#lab268</a></p>\n<p>Lean code: <a href=\"https://live.lean-lang.org/#url=https%3A%2F%2Fgist.githubusercontent.com%2Fspinylobster%2F5dba6397ed851d0fc26d6983620f6e88%2Fraw%2F579f927b230b20a0794b08eb9a4f74d74603a089%2Freg_exp.lean\">https://live.lean-lang.org/#url=https%3A%2F%2Fgist.githubusercontent.com%2Fspinylobster%2F5dba6397ed851d0fc26d6983620f6e88%2Fraw%2F579f927b230b20a0794b08eb9a4f74d74603a089%2Freg_exp.lean</a><br>\nRocq (Coq) code: <a href=\"https://proof-ninja.github.io/coqban/?gisturl=https%3A%2F%2Fgist.github.com%2Fspinylobster%2F2f42819357d1adcbd3389b5a60644575\">https://proof-ninja.github.io/coqban/?gisturl=https%3A%2F%2Fgist.github.com%2Fspinylobster%2F2f42819357d1adcbd3389b5a60644575</a></p>\n<p>The Lean proof in question is: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"o\">([</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=~</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Char</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">nomatch</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n</code></pre></div>\n<p>Since <code>=~ .Char x</code> can only match when the left-hand side is a single-element list, I expected the proof to be as short as: <code>by intro h; nomatch h</code><br>\n—just like in the Rocq proof.</p>\n<p>However, if I comment out the generalize line in Lean, cases h fails.<br>\nThe error message seems off-target, as if it’s trying <code>exp_match.MApp</code> or similar constructors that shouldn’t apply here.</p>\n<p>It appears that the order of indices in exp_match matters: swapping them avoids the error.</p>\n<p>Is this behavior an intentional part of Lean’s design, or is it a bug?</p>",
        "id": 538533983,
        "sender_full_name": "spinylobster",
        "timestamp": 1757452827
    },
    {
        "content": "<p>interesting</p>",
        "id": 538539355,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757455910
    }
]