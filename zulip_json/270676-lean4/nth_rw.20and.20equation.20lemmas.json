[
    {
        "content": "<p>When using <code>rw</code> to unfold a recursive definition using equation lemmas, it seems to find the first equation lemma whose LHS appears in the goal, and then find the leftmost occurrence of that LHS in the goal. I would've expected it to find the leftmost subexpression in the goal which matches <em>any</em> of the possible equation lemmas. Similarly, I would expect <code>nth_rw n</code> (AKA <code>rw (config := {occs := .pos [n]})</code>) to find the nth subexpression which matches any of the equation lemmas, not just the first equation lemma.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">([]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- unsolved goals; rewrites `[].length = 0` instead of `[x].length = [].length + 1`</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">([]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">config</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">occs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]})</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- same as above</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">([]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">config</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">occs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]})</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- error; `rw` can't find a second occurence for the `[].length = _` equation</span>\n\n<span class=\"c1\">-- Workaround: Use the specific desired equation lemma</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">([]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"bp\">.</span><span class=\"n\">eq_2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- success</span>\n</code></pre></div>\n<p>Should this be fixed?</p>",
        "id": 462212475,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1723583119
    },
    {
        "content": "<p>Maybe it should, although it could be non-trivial to achieve with the <code>rw</code> implementation, and since a work-around exist fixing may be not high priority. But certainly worth recording this as an issue against the lean repository.</p>",
        "id": 462219803,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1723586913
    },
    {
        "content": "<p>Made an issue at <a href=\"https://github.com/leanprover/lean4/pull/5026\">lean4#5026</a>!</p>",
        "id": 462224099,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1723589374
    },
    {
        "content": "<p>That's an interesting case. However, <code>simp only [List.length]</code> does exactly what you expect (and a tiny bit more mostly harmless stuff in some cases). Is there a reason why you must use <code>rw</code> instead of <code>simp only</code>?</p>",
        "id": 462233040,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1723594619
    },
    {
        "content": "<p>In the original example, the user didn't use <code>simp only</code> because they were solving exercises in a book that only taught <code>rw</code>. In regular Lean usage, another reason I can imagine is that <code>simp only</code> repeatedly applies the equation lemmas, which could cause performance issues if there are large terms involved</p>",
        "id": 462233353,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1723594805
    },
    {
        "content": "<p>Well, I don't know what book but, at an early stage of learning Lean, it might be better to introduce <code>List.length_nil</code> and <code>List.length_cons</code> than relying on equation lemmas for <code>List.length</code>.</p>",
        "id": 462234624,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1723595369
    },
    {
        "content": "<p>(Here is the original thread <a href=\"#narrow/stream/116395-maths/topic/Mechanics.20of.20Proof.20--.20Trouble.20rewriting.20factorial.20sometimes.3F/near/459950961\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Mechanics.20of.20Proof.20--.20Trouble.20rewriting.20factorial.20sometimes.3F/near/459950961</a>)</p>",
        "id": 462234763,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1723595449
    }
]