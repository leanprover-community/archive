[
    {
        "content": "<p>This is a minimized example where <code>isDefEq</code> assigns type incorrect expression to metavariables:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">lhs</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rhs</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">mkFreshExprMVar</span><span class=\"w\"> </span><span class=\"n\">lhs</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">defeq?</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">println</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">println</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"Unifiable? {defeq?}\"</span>\n<span class=\"w\">  </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">println</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"Type correct? {(← Meta.isTypeCorrect m)}\"</span>\n\n<span class=\"c1\">-- Unifying `foo` and `foo.bar ?m`</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``foo</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``foo.bar</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n</code></pre></div>\n<p>Note that the above behaviour does not show up in the following slightly modified example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Nat</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``foo.bar</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n</code></pre></div>",
        "id": 490074115,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1734655791
    },
    {
        "content": "<p>This is user error; <code>.app rhs m</code> has type <code>Nat</code>, but <code>lhs</code> has type <code>Type</code></p>",
        "id": 490075283,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734656475
    },
    {
        "content": "<p>You might be interested in Qq, which protects you from accidentally unifying things of the wrong types;</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Level</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVarQ</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">defeq?</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isDefEqQ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">println</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">println</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"Unifiable? {defeq? matches .defEq _}\"</span>\n<span class=\"w\">  </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">println</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"Type correct? {(← Meta.isTypeCorrect m)}\"</span>\n\n<span class=\"c1\">-- Unifying `foo.bar ⟨1⟩` and `foo.bar ?m`</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">bar</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 490075608,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734656686
    },
    {
        "content": "<p>(though actually there's a Qq bug here, the <code>u := u.succ</code> should be <code>v := v.succ</code>, but that leads to a crash)</p>",
        "id": 490076010,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734656982
    },
    {
        "content": "<p>What is the expected behaviour of isDefEq? Is it guaranteed to be correct only when the types of the two expressions are syntactically equal, or when the types of the two expressions are unifiable?</p>",
        "id": 490076154,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1734657091
    },
    {
        "content": "<p>I would like to know more because I need to unify expressions whose types are only known at runtime (and potentially with metavariables in their types) in my code.</p>",
        "id": 490076582,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1734657382
    },
    {
        "content": "<p>This looks like a bug to me. The <code>isDefEq</code> function is supposed to return true only if the expressions are definitionally equal, and the types are supposed to be definitionally equal in that case too.</p>",
        "id": 490079691,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734659374
    },
    {
        "content": "<p>It's probably gone unnoticed because most processes in Lean seem to do <code>isDefEq</code> of types of terms at some point as well.</p>",
        "id": 490079826,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734659457
    },
    {
        "content": "<p>Here's some of the trace:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">isDefEq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">3080</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">3080</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">assign</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">3080</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">beforeMkLambda</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">3080</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">checkTypes</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">3080</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n</code></pre></div>\n<p>It looks like what's happening is that it's something to do with a rule where if you have a one-field structure, it will reduce <code>x =?= y.1</code> to <code>y =?= { bar := x }</code>, but it seems to miss that <code>x</code> needs to have the correct type for this to apply.</p>\n<p>If you add another field to your structure, you can observe that they are no longer unifiable.</p>",
        "id": 490080309,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734659782
    },
    {
        "content": "<p>Thanks, I've reported this issue at <a href=\"https://github.com/leanprover/lean4/pull/6420\">lean4#6420</a></p>",
        "id": 490083418,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734662008
    },
    {
        "content": "<p>Huh, I thought I'd read in the past that <code>isDefeq</code> was only allowed to be called on terms whose types themselves could unify</p>",
        "id": 490137281,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734691985
    },
    {
        "content": "<p>I had never heard that, but it's possible it's true. I know that <code>isDefEq</code> does check types when unifying metavariables though, so if there were such an assumption, it's not being taken advantage of to make the algorithm simpler.</p>\n<p>Something that confuses me about this potential restriction is that this gives a lot of overhead to properly check that I never see done. Let's say we want to check that <code>x</code> and <code>y</code> are defeq. We infer their types and get <code>X</code> and <code>Y</code>. But we don't know that the types of <code>X</code> and <code>Y</code> are defeq yet, right? So we would need to infer <em>their</em> types to get <code>Sort u</code> and <code>Sort v</code> (after whnf), and then we can check that <code>u</code> and <code>v</code> are defeq, then <code>X</code> and <code>Y</code> are defeq, and then <code>x</code> and <code>y</code> are defeq. In the cases I can think of, at most meta code would check that <code>X</code> and <code>Y</code> are defeq, and it's to come up with better error messages, or maybe as a cheaper first pass at checking defeq.</p>",
        "id": 490219572,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734723248
    },
    {
        "content": "<p>What you describe is at least what Qq forces you to do...</p>",
        "id": 490246527,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734738706
    },
    {
        "content": "<p>Maybe for constructing terms, but there are plenty of metaprogramming tasks where you're not constructing terms but you want to test if terms are defeq.</p>\n<p>For example, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Tactic.AtomM.addAtom#doc\">docs#Mathlib.Tactic.AtomM.addAtom</a> is checking whether a term is defeq to a term that's in the AtomM state. It's <em>not</em> checking that types are defeq first, and even the Qq version <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Tactic.AtomM.addAtomQ#doc\">docs#Mathlib.Tactic.AtomM.addAtomQ</a> has a type signature that indicates it's not just for terms of a single type. That's just the first thing that came to mind, and searching for isDefEq across Lean and Mathlib, defeq testing without ensuring types are defeq first is frequent.</p>\n<p>Given that you both reacted with <span aria-label=\"this\" class=\"emoji emoji-1f446\" role=\"img\" title=\"this\">:this:</span> to <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>'s comment <span class=\"user-mention\" data-user-id=\"372804\">@Marcus Rossel</span> and <span class=\"user-mention\" data-user-id=\"432410\">@Arthur Adjedj</span>, I take it you've seen this documented somewhere? Would you mind digging it up?</p>",
        "id": 490248676,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734740191
    },
    {
        "content": "<blockquote>\n<p>For example, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Tactic.AtomM.addAtom#doc\">docs#Mathlib.Tactic.AtomM.addAtom</a> is checking whether a term is defeq to a term that's in the AtomM state. It's <em>not</em> checking that types are defeq first,</p>\n</blockquote>\n<p>For a linarith optimization that I was working on, I actually fix this in <a href=\"https://github.com/leanprover-community/mathlib4/pull/19821\">#19821</a> (draft)</p>",
        "id": 490249145,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734740554
    },
    {
        "content": "<p>You're saying it's a fix, but is it broken? It feels sort of like begging the question to call it a fix.</p>\n<p>(What's the performance impact of doing an <code>isLevelDefEq</code> and two <code>isDefEqQ</code>s rather than a single <code>isDefEq</code>? I could see it being net positive — doing <code>isDefEq</code> on types could exclude things quickly — but it's hard to say.)</p>",
        "id": 490257536,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734747847
    },
    {
        "content": "<p>Sorry, \"fix\" is the wrong word here. The context of the linarith change is one that wants to produces every term of the form <code>x * y</code>, but there is no need to do this unless <code>x</code> and <code>y</code> have the same type. So in this case it saves time by doing the <code>isDefeq</code> on the types  as part of the atomization, rather than in the quadratic loop.</p>",
        "id": 490258134,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734748410
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I think I was just conflating the matter with this answer: <a href=\"#narrow/stream/270676-lean4/topic/Unify.20level.20mvars/near/416858547\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Unify.20level.20mvars/near/416858547</a>.</p>",
        "id": 490284192,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1734774269
    },
    {
        "content": "<blockquote>\n<p>Given that you [...] reacted with <span aria-label=\"this\" class=\"emoji emoji-1f446\" role=\"img\" title=\"this\">:this:</span> to Eric Wieser's comment [...], I take it you've seen this documented somewhere? Would you mind digging it up?</p>\n</blockquote>\n<p>I don't believe I have seen this be documented in Lean in particular, it is however a folklore rule of type theory, and why I reacted that way. <br>\nTo give a more detailed answer, algorithmic checking for conversion comes in two flavors in most implementations: conversion is usually either typed or untyped. In Agda, the conversion algorithm takes another argument, that being the type of the terms being checked, whereas this is not the case in Lean and Coq (Lean is a bit of a weird mix though, since it does infer types when checking for eta-for-unit, more on that in a second). <br>\nThe justification behind not carrying this extra information is twofolds, 1. for performance reasons, and 2. because the fact that terms being checked for conversion should always be well-typed and have the same type appears as a natural invariant when writing a type-checker. <br>\nThe main upside from having typed conversion is that eta-expansion for types and structures becomes easier and more wide-spread. In agda for example, whenever agda checks for equality between two terms of a record type with eta, Agda will <strong>always</strong> eta-expand the two terms, making the algorithm in effect much simpler (in particular, it handles eta-for-unit for free).<br>\nI was going to point out that the aforementioned invariant (that two terms being compared should always have the same type) is visible in the kernel by the fact that <a href=\"https://github.com/leanprover/lean4/blob/16bc6ebcb6753ebd53eea4e9fbb078744c33cbd2/src/kernel/type_checker.cpp#L1056C20-L1056C39\"><code>is_def_eq_unit_like</code></a> does not check that the two types inferred are defeq, but is seems like <a href=\"https://github.com/leanprover/lean4/blob/16bc6ebcb6753ebd53eea4e9fbb078744c33cbd2/src/kernel/type_checker.cpp#L1065\">it does check</a> that in practice... In the kernel in particular, this additional check could very certainly be removed, and provide additional performance in this corner case.</p>\n<p>In any case, at the elaborator level, I would not be surprised if this invariant was not held in <code>isDefEq</code>, even more so when checking terms containing meta-variables, so this fix does not seem unreasonable to me.</p>",
        "id": 490293316,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1734782884
    },
    {
        "content": "<p>Looking more into this question at the kernel level, I am quite surprised that the kernel would be this conservative when it comes to verifying that two terms always have the same type. If the invariant that <code>isDefEq</code> is always called on well-typed terms that have the same type up to defeq is held, then a fair few optimisations could be done there. In particular:</p>\n<ul>\n<li>As mentioned before, <a href=\"https://github.com/leanprover/lean4/blob/16bc6ebcb6753ebd53eea4e9fbb078744c33cbd2/src/kernel/type_checker.cpp#L1056C20-L1056C39\"><code>is_def_eq_unit_like</code></a> would not need to do <a href=\"https://github.com/leanprover/lean4/blob/16bc6ebcb6753ebd53eea4e9fbb078744c33cbd2/src/kernel/type_checker.cpp#L1065\">this</a> additional check</li>\n<li>The algorithm would also need not verify that the <a href=\"https://github.com/leanprover/lean4/blob/16bc6ebcb6753ebd53eea4e9fbb078744c33cbd2/src/kernel/type_checker.cpp#L699\">domains</a> of lambda-terms need to have the same type (this would hold from the fact that they both have \"the same pi-type\", and that pi-types are injective)<br>\nI feel confident that digging more into this, one could find additional checks that could be skipped, if the invariant was to hold in the rest of the kernel.</li>\n</ul>",
        "id": 490293603,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1734783221
    },
    {
        "content": "<p>A quick scroll through all references of <code>is_def_eq</code> in the kernel indicates that these invariants <em>almost</em> hold. Indeed, <code>is_def_eq</code> is always only called on well-typed terms, and always on terms that have the same type <strong>up to level equality</strong>. In particular, when checking i.e a definition <code>def foo : A := a</code>, the kernel will:</p>\n<ul>\n<li>verify that both <code>A</code>and <code>a</code> have no fvar and are well-typed</li>\n<li>that <code>A</code> is a type, </li>\n<li>that the inferred type <code>A'</code> of <code>a</code> is defeq to <code>A</code>. </li>\n</ul>\n<p>However, even though it is certain that <code>A : Sort l</code> and <code>A' : Sort l'</code> for two levels <code>l l'</code>, there are at this point no guarantees that <code>l</code> and <code>l'</code> are defeq. If this additional check was added in <code>add_definition</code>, <code>add_theorem</code>, <code>add_opaque</code> and <code>add_mutual</code>, then the invariant would hold in the entire kernel (as well as all cpp libraries), and the two aforementioned checks could be removed completely.</p>",
        "id": 490296493,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1734785685
    },
    {
        "content": "<p>Thanks a lot for the detailed explanation <span class=\"user-mention\" data-user-id=\"432410\">@Arthur Adjedj</span>.</p>\n<p>I managed to cook up an example that causes the elaborator to create a type-incorrect term:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">error on 'example': application type mismatch</span>\n<span class=\"cm\">  { t := Type }</span>\n<span class=\"cm\">argument has type</span>\n<span class=\"cm\">  Type 1</span>\n<span class=\"cm\">but function has type</span>\n<span class=\"cm\">  Type v → S</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>\n<p>(I still haven't found one that doesn't make use of a tactic script.)</p>\n<p>This is taking advantage of the <a href=\"https://github.com/leanprover/lean4/pull/6420\">lean4#6420</a> issue, but it could be seen as taking advantage of any typechecker that fails to account for universe levels when unifying types.</p>",
        "id": 490319062,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734805627
    }
]