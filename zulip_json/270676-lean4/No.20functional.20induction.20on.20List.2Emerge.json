[
    {
        "content": "<p>It seems <code>fun_induction  List.merge</code> doesn't work. It throws the error : <code>`No functional induction theorem for</code> List.merge<code>, or function is mutually recursive</code></p>",
        "id": 575438614,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771899884
    },
    {
        "content": "<p><code>#check List.merge.induct</code> throws an unknown identifier error. However I can immediately get the lemma if I copy-paste the definition into my file</p>",
        "id": 575438710,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771899946
    },
    {
        "content": "<p>How do I get fun_induction working on List.merge?</p>",
        "id": 575439064,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771900161
    },
    {
        "content": "<p>this works in the web editor</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">info: List.merge.induct.{u_1} {α : Type u_1} (le : α → α → Bool) (motive : List α → List α → Prop)</span>\n<span class=\"sd\">  (case1 : ∀ (ys : List α), motive [] ys) (case2 : ∀ (xs : List α), (xs = [] → False) → motive xs [])</span>\n<span class=\"sd\">  (case3 :</span>\n<span class=\"sd\">    ∀ (x : α) (xs : List α) (y : α) (ys : List α), le x y = true → motive xs (y :: ys) → motive (x :: xs) (y :: ys))</span>\n<span class=\"sd\">  (case4 :</span>\n<span class=\"sd\">    ∀ (x : α) (xs : List α) (y : α) (ys : List α), ¬le x y = true → motive (x :: xs) ys → motive (x :: xs) (y :: ys))</span>\n<span class=\"sd\">  (xs ys : List α) : motive xs ys</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">merge</span><span class=\"bp\">.</span><span class=\"n\">induct</span>\n</code></pre></div>",
        "id": 575439958,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1771900713
    },
    {
        "content": "<p>I get an error in <a href=\"https://github.com/leanprover/cslib/pull/275\">cslib#275</a></p>",
        "id": 575440017,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771900754
    },
    {
        "content": "<p>Is this because of some module system thing?</p>",
        "id": 575440067,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771900782
    },
    {
        "content": "<p>the contents of <code>List.merge</code> isn't exposed</p>",
        "id": 575440155,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1771900839
    },
    {
        "content": "<p>I just need <code>fun_induction List.merge</code> to work</p>",
        "id": 575440200,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771900860
    },
    {
        "content": "<p>so if you're in a module that doesn't have access to the contents of <code>List.merge</code> then it will appear like an axiom to any tactics</p>",
        "id": 575440228,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1771900876
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">module</span>\n\n<span class=\"sd\">/-- error: Unknown constant `List.merge.induct` -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">merge</span><span class=\"bp\">.</span><span class=\"n\">induct</span>\n</code></pre></div>",
        "id": 575440278,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1771900902
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> and <span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span></p>",
        "id": 575440298,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771900911
    },
    {
        "content": "<p>It's a module system issue. Core is setup to not allow us to access List.merge by default</p>",
        "id": 575440336,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771900932
    },
    {
        "content": "<p>How do I bring it in scope?</p>",
        "id": 575440445,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771900997
    },
    {
        "content": "<p>you can <code>import all Init.Data.List.Sort.Basic</code></p>",
        "id": 575440536,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1771901053
    },
    {
        "content": "<p>It would be nice if the lemma is generated either way, though...</p>",
        "id": 575504624,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1771928638
    },
    {
        "content": "<p>Or, if it were as available as its type</p>",
        "id": 575504918,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1771928712
    },
    {
        "content": "<p>I think the lemma gets generated and is just hidden by the module system</p>",
        "id": 575505631,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771928890
    },
    {
        "content": "<p>Given that the lemma for functional induction is in essence a complete description of the function body having it exposed for a non exposed function would kind of defeat the whole point of the module system. The lemma would change on basically any modification to the function body that would be made which is akin to just putting <code>@[expose]</code> on the definition.</p>",
        "id": 575506925,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1771929245
    },
    {
        "content": "<p>Then we should probably just import all everything in core downstream in CSLib if we want to prove stuff about basic definitions. This sounds like pushing the module system rules to an extreme</p>",
        "id": 575507429,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771929400
    },
    {
        "content": "<p>What theorems are you missing?</p>",
        "id": 575514779,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1771931525
    },
    {
        "content": "<p>Being able to use fun_induction to prove that my monadic program evaluates identically to List.merge</p>",
        "id": 575514973,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771931580
    },
    {
        "content": "<p>And then use this equality for any theorem about the evaluation of the program.</p>",
        "id": 575515109,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771931622
    },
    {
        "content": "<p>This is a concrete example : <a href=\"https://github.com/leanprover/cslib/pull/275/changes#diff-f5c3e3be8e076ae58f336c517a22edece9330a5f7f33820be47324c3137c3ad4R68\">https://github.com/leanprover/cslib/pull/275/changes#diff-f5c3e3be8e076ae58f336c517a22edece9330a5f7f33820be47324c3137c3ad4R68</a></p>",
        "id": 575690938,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771994156
    },
    {
        "content": "<p>But essentially I advocate  this strategy for all algorithms in upstream libraries, where the recursive structure matches that of the algorithm. It simplifies correctness proofs immensely.</p>",
        "id": 575690990,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771994210
    },
    {
        "content": "<p>I guess the argument could be made that while the generated induction lemma is an implementation detail, an induction principle that shows the API lemmas are exhaustive should also itself be part of the API</p>",
        "id": 575691460,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1771994692
    },
    {
        "content": "<p>And using the fun induction principle of your local merge doesn't work? I haven't tried</p>",
        "id": 575696505,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1771998854
    },
    {
        "content": "<p>In this particular case the local merge has a weaker fun_induction principle that requires some extra manual case splitting (due to the branch condition being abstracted out); though not enough to be a major concern</p>",
        "id": 575697192,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1771999307
    },
    {
        "content": "<p>Another workaround is to have your own copy of <code>List.merge</code> (or even a function returning <code>Unit</code> with the same branching and recursive call), and use that function’s induction principle. I will be the identical to that of <code>List.merge</code>.  (Ok, granted, that trick does not work if you want to use the unfolding functional induction principle.)</p>",
        "id": 575739667,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1772015399
    },
    {
        "content": "<p>I already tried that. But it is duplication of code in a downstream library then. So it cannot pass review.</p>",
        "id": 575739902,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772015459
    },
    {
        "content": "<p>Broadly : There might be a case to be made for allowing localised replication of  non-exported definitions. This is especially the case when the local copy and upstream copy have orthogonal purposes which might clash at some point. Even though it means more code to fix when a breaking change happens, the errors are localised and decoupled from each other.  So core can change List.merge as it likes for its intended uses (maybe it is meant to be efficient). It wouldn’t affect other use cases. Localising errors and keeping code stable over upstream changes can be good enough reasons to duplicate non-exposed defs (maybe as private) which have different primary purposes. For example, if List.merge hypothetically had a different recursion structure tomorrow for performance reasons, this could cause a severe breakage in our use case, which is to simplify correctness proofs. And indeed the module system setup for this file clearly intends to discourage such uses. </p>\n<p>But that’s a discussion that is almost certainly not going to affect this PR.</p>",
        "id": 575743944,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772016627
    }
]