[
    {
        "content": "<p>(Original context: <a href=\"#narrow/stream/113488-general/topic/.22Missing.20Tactics.22.20list/near/446267660\">a request by Floris</a>)</p>\n<p>It still needs to be tested against mathlib, but here's a PR: <a href=\"https://github.com/leanprover/lean4/pull/4543\">lean4#4543</a></p>",
        "id": 446465343,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1719171625
    },
    {
        "content": "<p>I'm curious to see if this does the right thing on all the \"partially-applied <code>ext</code> lemmas\" in mathlib</p>",
        "id": 446481741,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1719180975
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, I tried deleting the manual <code>Fin.ext_iff</code>, as this fails the build in stage2, but then of course stage1 won't build. We need an <code>update-stage0</code> here, right? I think I'll wait to let you do that; I'd prefer not to update stage0 on others' PRs!</p>",
        "id": 446487570,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719185702
    },
    {
        "content": "<p>Here's a question: what should the binder types be for <code>ext_iff</code> lemmas? They are inconsistent in mathlib, and also we need to modify them because sometimes mathlib uses strict implicits in <code>ext</code> lemmas, which result in unusable <code>ext_iff</code> lemmas.</p>\n<p>Two options:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">ext_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">b</span>\n\n<span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">ext_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">b</span>\n</code></pre></div>\n<p>It's fairly common to need to specify <code>a</code> and <code>b</code>, so the second one is seeming better to me.</p>",
        "id": 446492929,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1719190147
    },
    {
        "content": "<p>I'm about 40% through mathlib now. Before I keep going, what do we think about these changes? <a href=\"https://github.com/leanprover-community/mathlib4/compare/nightly-testing...lean-pr-testing-4543\">https://github.com/leanprover-community/mathlib4/compare/nightly-testing...lean-pr-testing-4543</a></p>",
        "id": 446519542,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1719206149
    },
    {
        "content": "<p>5 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general/topic/.22Missing.20Tactics.22.20list\">#general &gt; \"Missing Tactics\" list</a> by <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span>.</p>",
        "id": 446519608,
        "sender_full_name": "Notification Bot",
        "timestamp": 1719206181
    },
    {
        "content": "<p>I only looked through about a quarter of that, but looks great.</p>",
        "id": 446520669,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719206958
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Generate.20ext_iff.20lemmas/near/446492929\">said</a>:</p>\n<blockquote>\n<p>Here's a question: what should the binder types be for <code>ext_iff</code> lemmas? They are inconsistent in mathlib, and also we need to modify them because sometimes mathlib uses strict implicits in <code>ext</code> lemmas, which result in unusable <code>ext_iff</code> lemmas.</p>\n<p>Two options:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">ext_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">b</span>\n\n<span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">ext_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">b</span>\n</code></pre></div>\n<p>It's fairly common to need to specify <code>a</code> and <code>b</code>, so the second one is seeming better to me.</p>\n</blockquote>\n<p>Is it that common? Skimming your patch to mathlib I think I only see the case where they are not specified</p>",
        "id": 446529095,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1719210733
    },
    {
        "content": "<p>My guess is that the vast majority of uses are just \"rewrite the whole goal\", and so implicit would be fine (and match our general convention for argument explicitness of <code>Iff</code>s)</p>",
        "id": 446529871,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1719211136
    },
    {
        "content": "<p>Yeah, I have never heard of a rule saying that <code>ext_iff</code> lemmas were an exception to the \"arguments to iff are implicit\" rule</p>",
        "id": 446532014,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1719212182
    },
    {
        "content": "<p>Is that rule written somewhere? I would like to start improving our documentation of rules for explicitness, but can't find much to start with!</p>",
        "id": 446532930,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719212551
    },
    {
        "content": "<p>Uh, it's not in <a href=\"https://leanprover-community.github.io/contribute/style.html\">#style</a></p>",
        "id": 446535168,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1719213389
    },
    {
        "content": "<p>I think it's in Yaël's head :)</p>",
        "id": 446535797,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1719213616
    },
    {
        "content": "<p>I think it's a collective hallucination, which if widespread enough should probably end up in <a href=\"https://leanprover-community.github.io/contribute/style.html\">#style</a></p>",
        "id": 446536764,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1719213982
    },
    {
        "content": "<p>I need to fetch croissants now, but I will explain the rules as I understand them later.</p>",
        "id": 446536789,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1719213997
    },
    {
        "content": "<p>I also know about this: it is a difference between goals that are iff and goals that are eq, right?</p>",
        "id": 446536802,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1719213999
    },
    {
        "content": "<blockquote>\n<p>Is it that common? Skimming your patch to mathlib I think I only see the case where they are not specified</p>\n</blockquote>\n<p>The PR would only be touching places where they aren't specified and where making them explicit causes an issue, right? I don't have any metrics on what I didn't need to change, but earlier I had skimmed through uses of <code>ext_iff</code> lemmas in mathlib and saw that passing in one or both terms via keyword arguments wasn't rare.</p>",
        "id": 446662804,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1719246778
    },
    {
        "content": "<p>Here are some considerations:</p>\n<ul>\n<li>The <code>ext_iff</code> generator for <code>@[ext]</code> placed on a structure makes the two arguments be explicit. I'm not sure if it's part of the interface that <code>x</code> and <code>y</code> are the names of these arguments, so relying on named arguments here is not great. (We can't just declare they're part of the interface: <code>x</code> or <code>y</code> might be names of parameters for the structure, and so these may be inaccessible.)</li>\n<li>We might want to leave this problem to the user and leave implicit/explicit alone for the <code>ext_iff</code> derived from a user <code>@[ext]</code> lemma, but like I said before, sometimes the \"<code>x</code>\" and \"<code>y</code>\" are strict implicit arguments here, making generated <code>ext_iff</code> unusable since the last arguments would be strict implicit.<ul>\n<li>We could decide to throw an error in this case. A source this problem is mathlib using the <code>Injective</code> theorem as the <code>ext</code> theorem, which we could say is not supported.</li>\n<li>Or we could turn strict implicits into implicits.</li>\n<li>However, in both these cases, we're allowing <code>ext_iff</code> lemmas to have inconsistent interfaces.</li>\n</ul>\n</li>\n<li>The LHS of the <code>ext_iff</code> theorem has very little structure. My thought earlier was that if you are going to be using it, it's not unlikely that you would want to rewrite a particular equality that appears in your goal, and these being explicit doesn't hurt its use in <code>rw</code> or <code>simp</code>.</li>\n<li>Most changes I've needed to make are messing around with term proofs that might be too clever. Many of them are also just using the mp direction, which is a trivial theorem that requires absolutely no knowledge about the type — this direction is a sort of basic congruence lemma for some function that happens to appear in the <code>ext</code> lemma.<ul>\n<li>I would rather see the forward direction be given its own name, if it should exist at all. Many times I've found it can be replaced with a <code>congr_arg</code>.</li>\n<li>I don't think the <code>ext_iff</code> theorem should care about being nice to use with <code>.mp</code> and <code>.mpr</code> since (1) I've already said what I don't like about the <code>.mp</code> direction and (2) the <code>.mpr</code> direction may as well use the <code>ext</code> lemma itself.</li>\n</ul>\n</li>\n</ul>",
        "id": 446665212,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1719247565
    },
    {
        "content": "<p>See also <a href=\"https://github.com/leanprover/lean4/pull/3643\">lean4#3643</a></p>",
        "id": 446689538,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1719254608
    },
    {
        "content": "<p>There's lots of bugs with <code>ext</code>, it needs a major overhaul!</p>",
        "id": 446690058,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1719254783
    },
    {
        "content": "<p>I think there should be a rule saying that <code>ext_iff</code> lemmas are an exception to the \"arguments to iff are implicit\" rule.</p>",
        "id": 446691590,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1719255363
    },
    {
        "content": "<p>Here's the current status:</p>\n<ul>\n<li>Now <a href=\"https://github.com/leanprover/lean4/pull/4543\">lean4#4543</a> makes all the arguments implicit for <code>ext_iff</code> theorems. It also makes the generated <code>ext</code> theorem use implicit arguments for the equated terms — this is at the suggestion of François in issue <a href=\"https://github.com/leanprover/lean4/pull/3643\">lean4#3643</a>, but also in practice it seems that mathlib doesn't use these arguments (lots of <code>Foo.ext _ _ ...</code>).</li>\n<li>The <code>ext</code> attribute now \"realizes\" the <code>ext</code> and <code>ext_iff</code> lemmas, meaning it creates them if they do not already exist. This helps get <code>@[ext local]</code> to work.</li>\n<li>I've built about 1400 mathlib files, with changes to about 90 (see <a href=\"https://github.com/leanprover-community/mathlib4/compare/nightly-testing...lean-pr-testing-4543\">the diff</a>). It's merely tedious work, and there do not seem to be any issues so far. Sometimes you have to write <code>@[ext (iff := false)]</code> for user ext lemmas that have dependent hypotheses, which is not supported at the moment.</li>\n<li>I've set up the core Lean PR to build and work without a stage0 update and still work with one (at least locally — still waiting on CI), but after the stage0 update there are a few lines that would be good to clean up. They're marked with \"TODO(kmill)\" comments.</li>\n</ul>",
        "id": 449868718,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720445022
    },
    {
        "content": "<p>Adding <code>@[scoped ext]</code> on a structure isn't implemented. One could imagine it means adding the <code>scoped ext</code> attribute to the generated ext lemma, but the general attribute processing logic throws an error if it sees any <code>scoped</code> attribute applied to a top-level declaration.</p>",
        "id": 449872134,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720445903
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Generate.20ext_iff.20lemmas/near/449868718\">said</a>:</p>\n<blockquote>\n<ul>\n<li>It also makes the generated <code>ext</code> theorem use implicit arguments for the equated terms — this is at the suggestion of François in issue <a href=\"https://github.com/leanprover-community/mathlib4/pull/3643\">#3643</a>, but also in practice it seems that mathlib doesn't use these arguments (lots of <code>Foo.ext _ _ ...</code>).</li>\n</ul>\n</blockquote>\n<p>I've often seen mathlib try to use <code>⦃⦄</code> arguments instead of <code>{}</code> for the equated terms: I think this is motivated by making it behave more like <code>Function.Injective</code></p>",
        "id": 449878672,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720447262
    },
    {
        "content": "<p>Certainly mathlib is not consistent about this, and <code>{}</code> is already a nice improvement over <code>()</code></p>",
        "id": 449878815,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720447288
    },
    {
        "content": "<p>I was thinking it would be better to restate <code>injective</code> lemmas rather than \"misuse\" the <code>ext</code> lemma. Mathlib's also not very consistent about stating these <code>injective</code> lemmas.</p>\n<p>Plus, sticking with <code>{}</code> here means that the lemma generator doesn't need special casing when there are no fields:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Unit'</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Unit'</span><span class=\"bp\">.</span><span class=\"n\">ext</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Unit'.ext {x y : Unit'} : x = y</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>Maybe that would be better with explicit arguments, since there are no other arguments determining <code>x</code> and <code>y</code> by unification, but it's usable.</p>",
        "id": 449955290,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720465029
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> I was wondering if we might merge <a href=\"https://github.com/leanprover/lean4/pull/4543\">lean4#4543</a> before finishing fixing mathlib, given that there don't seem to be any surprises, and then I can finish fixing it on a next nightly-testing. Otherwise I'll keep plodding along.</p>",
        "id": 449956949,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720465467
    },
    {
        "content": "<p>Yes, no objections to merging. Tonight's <code>nightly-testing</code> will be broken by various changes I've made today (upstreaming some things, changing some List lemmas). So merging today will result in <code>nightly-testing</code> being a bit of a mess, but I'm game.</p>",
        "id": 449964631,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1720466972
    },
    {
        "content": "<p>Most of my fixes will just come in from <code>git merge lean-pr-testing-4678</code>.</p>",
        "id": 449964672,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1720466987
    }
]