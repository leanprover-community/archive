[
    {
        "content": "<p>Hi, I'm working on STLC with de Bruijn indices in Lean4 <a href=\"https://github.com/ElifUskuplu/Stlc_deBruijn\">link</a>. I would like to formalize strong normalization for terms. I don't know how hard it is, but I have difficulties with the definition.</p>\n<p>According to notes I looked, the predicate of strongly normalized <code>SN</code> on terms should be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">SN</span> <span class=\"o\">:</span> <span class=\"n\">Term</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">sn</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">t'</span><span class=\"o\">,</span> <span class=\"n\">beta_red</span> <span class=\"n\">t</span> <span class=\"n\">t'</span> <span class=\"bp\">→</span> <span class=\"n\">SN</span> <span class=\"n\">t'</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">SN</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>where <code>beta_red</code> is the one-step reduction. Those notes were using \"Reducibility candidates\"  method to prove that <strong>every typable term is strongly normalized</strong>. This is how they formulate the strong normalization of STLC.</p>\n<p>It's said that <code>SN</code> is always backwards closed with respect to application. Namely, if <code>SN (t @ s)</code> then <code>SN t ∧ SN s</code>. It's said that the proof goes by induction on <code>SN (t @ s)</code>, but it does not seem easy to me. I think the idea is that if we have a reduction sequence starting with <code>t</code>,  then we can obtain a corresponded reduction sequence starting with <code>t @ s</code>. Since the letter halts in finitely many steps, so is the former. But, how we relate <code>SN</code> predicate with the property of having finite reduction sequences??</p>\n<p>I'm also not sure whether this is the right approach to prove the strong normalization of STLC. Is there any idea to formulate it other than using <code>SN</code> predicate??</p>",
        "id": 400250232,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699072233
    },
    {
        "content": "<p>IIRC <span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span> has a really nice presentation of this proof in his book \"Mathematical Logic and Computation\". Jeremy do you have anything else I could point to here?</p>",
        "id": 400262684,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699080353
    },
    {
        "content": "<p>Oh, apparently this was <span class=\"user-mention\" data-user-id=\"116134\">@Sarah Mameche</span> 's bachelor thesis (lean 3): <a href=\"https://www.ps.uni-saarland.de/~mameche/images/thesis.pdf\">https://www.ps.uni-saarland.de/~mameche/images/thesis.pdf</a></p>",
        "id": 400263178,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699080850
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/strong.20normalization.20of.20STLC/near/400262684\">said</a>:</p>\n<blockquote>\n<p>IIRC <span class=\"user-mention silent\" data-user-id=\"110865\">Jeremy Avigad</span> has a really nice presentation of this proof in his book \"Mathematical Logic and Computation\". Jeremy do you have anything else I could point to here?</p>\n</blockquote>\n<p>Thanks for the suggestion, I have this book. It says:</p>\n<blockquote>\n<p>A term t is strongly normalizing or strongly normalizable if there is no infinite sequence of one-step reductions beginning with t, that is, every sequence of one-step reductions starting from t is finite.</p>\n</blockquote>\n<p>I'm just not sure about how this is related with the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">SN</span> <span class=\"o\">:</span> <span class=\"n\">Term</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">sn</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">t'</span><span class=\"o\">,</span> <span class=\"n\">beta_red</span> <span class=\"n\">t</span> <span class=\"n\">t'</span> <span class=\"bp\">→</span> <span class=\"n\">SN</span> <span class=\"n\">t'</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">SN</span> <span class=\"n\">t</span>\n</code></pre></div>",
        "id": 400263185,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699080861
    },
    {
        "content": "<p>AFAIK that is indeed the right definition</p>",
        "id": 400263200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699080879
    },
    {
        "content": "<p><code>SN</code> is not actually the same thing as \"strongly normalizing\", or rather establishing the equivalence between those two is most of the proof</p>",
        "id": 400263239,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699080919
    },
    {
        "content": "<p><code>SN</code> has some nice properties that facilitate the proof</p>",
        "id": 400263265,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699080946
    },
    {
        "content": "<p>doing induction directly on the literal definition of \"strongly normalizing\" doesn't work</p>",
        "id": 400263322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699080976
    },
    {
        "content": "<p>I think in Jeremy's book <code>SN</code> is called \"strongly computable\"</p>",
        "id": 400263382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699081067
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/strong.20normalization.20of.20STLC/near/400263382\">said</a>:</p>\n<blockquote>\n<p>I think in Jeremy's book <code>SN</code> is called \"strongly computable\"</p>\n</blockquote>\n<p>I think this is \"Reducibility Relation\" in the note you shared.</p>",
        "id": 400263490,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699081174
    },
    {
        "content": "<p>actually I think I'm mixing things up, the <code>SN</code> inductive you defined is pretty clearly equivalent to \"every reduction sequence terminates\"</p>",
        "id": 400263808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699081384
    },
    {
        "content": "<p>And that's why \"every typable term is strongly normalized\" (using SN) is the same as \"The relation →1 is strongly normalizing (i.e. for each t, every sequence of one-step reductions starting from t is finite).\" in Jeremy's book, right?</p>",
        "id": 400264027,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699081579
    },
    {
        "content": "<p>Is the relation -&gt;1 is the same as <code>beta_red</code>?</p>",
        "id": 400264216,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699081770
    },
    {
        "content": "<p><code>beta_red</code> is the one-step reduction. Since I'm using locally nameless representation (de Bruijn indices), the definition is different than -&gt;1, but I think they are intuitively same.</p>",
        "id": 400264415,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699081932
    },
    {
        "content": "<p>I think I made progress: I've shown that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">SN_finlist</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Trm</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">SN</span> <span class=\"n\">t</span> <span class=\"bp\">→</span>\n <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Trm</span><span class=\"o\">),</span> <span class=\"o\">((</span><span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">beta_red</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)))))</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">normal</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">k</span><span class=\"o\">)))</span> <span class=\"o\">:</span>\n</code></pre></div>\n<p>This means if we have <code>SN t</code>, then for every sequence of beta reductions starting with <code>t</code>, there is a normal term in the sequence, namely, the sequence is eventually constant.</p>\n<p>I want to prove the other way, but I think I should define the proposition</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Trm</span><span class=\"o\">),</span> <span class=\"o\">((</span><span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">beta_red</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)))))</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">normal</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">k</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>inductively so that I can prove the other direction using induction on the definition we built. <br>\nI hope I could explain :) How can I define it using <code>inductive</code> environment?</p>",
        "id": 400273967,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699089158
    },
    {
        "content": "<p>Shouldn't it say that there is no such sequence? Can a <code>normal</code> term have a <code>beta_red</code>?</p>",
        "id": 400284664,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699093585
    },
    {
        "content": "<p>The converse you can prove by contradiction using the axiom of choice: Suppose <code>t</code> is not <code>SN</code>, then it has a <code>beta_red</code> which is also not <code>SN</code>, and so on, this defines an infinite sequence</p>",
        "id": 400285175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699093802
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/strong.20normalization.20of.20STLC/near/400284664\">said</a>:</p>\n<blockquote>\n<p>Shouldn't it say that there is no such sequence? Can a <code>normal</code> term have a <code>beta_red</code>?</p>\n</blockquote>\n<p>Sorry, I forgot to say. If a term <code>t</code> is <code>normal</code> it means whenever  <code>beta_red t u</code> holds, we have <code>t = u</code>. So in the definition I gave before, the sequence will be the constant <code>t</code> sequence after finite step. I think it gives the idea that every reduction sequence starting with <code>t</code> terminates, right?</p>",
        "id": 400306632,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699111052
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"622405\">@Elif Uskuplu</span> In that case you will have to modify the argument to only consider <code>beta_red</code> values not equal to the original, or else you could end up spuriously spinning on a non-normal term even though proper reductions exist</p>",
        "id": 400327463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699132465
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/strong.20normalization.20of.20STLC/near/400327463\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"622405\">Elif Uskuplu</span> In that case you will have to modify the argument to only consider <code>beta_red</code> values not equal to the original, or else you could end up spuriously spinning on a non-normal term even though proper reductions exist</p>\n</blockquote>\n<p>Sorry, I couldn't get it. If we have a reduction sequence <code>t_n</code>, namely <code>beta_red t_n t_{n+1}</code> for all <code>n</code>, and <code>t_k</code> is normal for some <code>k</code>, don't we have that the sequence is the constant <code>t_k</code> sequence after <code>k</code> steps? So we have only a finite sequence <code>t_0, t_1, ..., t_k</code>. Am I missing something?</p>",
        "id": 400328299,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699133613
    },
    {
        "content": "<p>yes, but what if you have a reduction sequence <code>t_n</code> with <code>beta_red t_n t_{n+1}</code> for all <code>n</code>, but it's <em>not</em> normal for any <code>k</code>? (i.e. the negation of your statement) This doesn't tell you anything: it could be that you just chose to repeat some non-normal term <code>t</code> forever without progressing</p>",
        "id": 400328552,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699133962
    },
    {
        "content": "<p>Put another way, I don't see why the statement <code>SN_finlist</code> would be true if <code>beta_red</code> is reflexive, because any term, even one which is <code>SN</code> but not normal, would have a trivial sequence which is just constantly <code>t</code> and fails the conclusion</p>",
        "id": 400328701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699134174
    },
    {
        "content": "<p>If <code>beta_red</code> is irreflexive, then the conclusion of the theorem is not strong enough, it should just be <code>∀ (f : Nat → Trm), ((f 0 = t) ∧ (∀ n, (beta_red (f n) (f (succ n))))) → False</code></p>",
        "id": 400328726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699134232
    },
    {
        "content": "<p><code>beta_red</code> is not reflexive, yes.</p>",
        "id": 400328779,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699134278
    },
    {
        "content": "<p>I think I see your point. If <code>SN t</code>is not true, we can find an infinite sequence of reduction via AC, but this might not give the negation of my statement . That's why it needs modification, right?</p>",
        "id": 400328890,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699134441
    },
    {
        "content": "<p>You can still prove the negation of your statement, because you can find an infinite sequence of <em>non-equal</em> reduction</p>",
        "id": 400329043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699134662
    },
    {
        "content": "<p>Right, I see. But, as you suggest, the right statement should be<code>∀ (f : Nat → Trm), ((f 0 = t) ∧ (∀ n, (beta_red (f n) (f (succ n))))) → False</code> to have the right definition in Jeremy's book?</p>",
        "id": 400329156,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699134845
    },
    {
        "content": "<p>If you have a <code>normal</code> term, I assume that it has no <code>beta_red</code> at all?</p>",
        "id": 400329188,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699134888
    },
    {
        "content": "<p>I didn't define it in that way, but you're right, I should define like this. If <code>normal</code> means no <code>beta_red</code>, my statement is ok?</p>",
        "id": 400329268,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699135004
    },
    {
        "content": "<p>Jeremy's book supports this definition:</p>\n<blockquote>\n<p>Definition 13.2.1. 1. A term t is <em>reducible</em> if there is some t′ such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><msub><mo>→</mo><mn>1</mn></msub><msup><mi>t</mi><mtext>′</mtext></msup></mrow><annotation encoding=\"application/x-tex\">t \\to_1 t^′</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\">→</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span>, and <em>irreducible</em> otherwise. A term that is irreducible is also said to be <em>normal</em>, or in <em>normal form</em>.</p>\n</blockquote>",
        "id": 400329271,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699135014
    },
    {
        "content": "<p>if normal means no <code>beta_red</code> then the statement is equivalent but unnecessarily complicated because you can immediately prove that a sequence with such <code>k</code> is impossible by just taking one more step</p>",
        "id": 400329328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699135088
    },
    {
        "content": "<p>I agree, it's better to take <code>... → False</code>.</p>",
        "id": 400329362,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699135186
    },
    {
        "content": "<p>Thanks for the discussion, what about the application? I mean I want to prove that if <code>SN (t @ s)</code> then <code>SN t</code> and <code>SN s</code> via induction on <code>SN</code>. But it does not seem easy to me. Do you think other characterization of <code>SN</code> works well?</p>",
        "id": 400329668,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699135372
    },
    {
        "content": "<p>Ah, that's what \"strongly computable\" is for</p>",
        "id": 400329806,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699135560
    },
    {
        "content": "<p>it is importantly defined by recursion on types:</p>\n<blockquote>\n<p>For each type α, we define the set of strongly computable terms of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span>:<br>\n* If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> is a term of a basic type, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> is strongly computable if and only if it is strongly normalizing.<br>\n* If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> is a term of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">α → β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> is strongly computable if and only if for every strongly computable <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span> of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">t s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">s</span></span></span></span> is strongly computable.<br>\n* If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> is a term of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>×</mo><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">α × β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> is strongly computable if and only if both <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><msub><mo stretchy=\"false\">)</mo><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">(t)_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><msub><mo stretchy=\"false\">)</mo><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">(t)_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> are strongly computable.</p>\n</blockquote>",
        "id": 400329881,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699135665
    },
    {
        "content": "<p>in some sense this explains why STLC has strong normalization while LC doesn't - at some point you need to make use of the typing structure in the proof</p>",
        "id": 400330040,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699135858
    },
    {
        "content": "<p>I see, probably the problem is that I'm referring different notes and the definition varies. Strong computable is like reducibility candidate in the note you shared first. We need to prove CR1,CR2,CR3 lemmas in that note (these are like Lemma 13.2.7. in Jeremy's book). And the proof of lemmas uses the fact <code>SN (t @ s)</code> then <code>SN t</code> and <code>SN s</code>. That's why I'm not sure if strongly computable notion is suitable for my case. In the end, I think the first thing I should do is referring only one textbook or note <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>  to avoid confusion.</p>",
        "id": 400330257,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699136108
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Thank you for taking the time.</p>",
        "id": 400330361,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699136223
    },
    {
        "content": "<p>IIRC Jeremy's proof is very efficient, I think the reducibility candidate proof is closer to the original version of the proof</p>",
        "id": 400330507,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699136399
    },
    {
        "content": "<p>but yes, doing both proofs at the same time is likely to be confusing :)</p>",
        "id": 400330573,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699136436
    },
    {
        "content": "<p>Well, it's almost done, but I still need to characterize the height notion for a strongly normalizing term. I mean I don't know how can I formalize the expression <em>for some n, every sequence of one-step reductions starting from t has length at most n</em> ?</p>",
        "id": 401581310,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699767581
    },
    {
        "content": "<p>I'm not sure this is true, or at least it doesn't follow from strong normalization alone</p>",
        "id": 401589500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699775767
    },
    {
        "content": "<p>for example, if we consider decreasing sequences of ordinals starting from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>, it is true that every sequence terminates, but it is not true that there exists an n such that every sequence of reductions has length at most n</p>",
        "id": 401589636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699775914
    },
    {
        "content": "<p>This is from the book:</p>\n<blockquote>\n<p>Lemma 13.2.4. A term t is strongly normalizing if and only if for some n every sequence of one-step reductions starting from t has length at most n.</p>\n<p>Proof : The backward direction is immediate. To prove the forward direction, suppose t is strongly normalizing. Build a tree with t at the root; as children of node labeled s, add a node for each term s' such that s →1 s' . Clearly this tree is finitely branching. Strong normalization implies that there is no infinite branch through the tree. By Proposition 1.4.4 (Kőnig’s lemma), the tree is finite.</p>\n<p>In the proof below, whenever t is strongly normalizing, let h(t) denote the least n such that every sequence of one-step reductions from t has length at most n. Note that if t is strongly normalizing and t →1 s, then s is strongly normalizing as well and h(s) &lt; h(t).<br>\n...</p>\n</blockquote>",
        "id": 401589676,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699775971
    },
    {
        "content": "<p>Oh I see, if you have finite branching then yes it follows</p>",
        "id": 401589694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699776000
    },
    {
        "content": "<p>the rank of each term is the max of all of its possible reductions plus 1</p>",
        "id": 401589786,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699776039
    },
    {
        "content": "<p>and this is well founded by strong normalization</p>",
        "id": 401589813,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699776055
    },
    {
        "content": "<p>I understand this conceptually, but I couldn't figure it out how can I write this expression as a Lean code. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 401590036,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699776168
    },
    {
        "content": "<p>I mean the RHS of Lemma 13.2.4</p>",
        "id": 401590094,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699776236
    },
    {
        "content": "<p>do you know how to state it?</p>",
        "id": 401590148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699776260
    },
    {
        "content": "<p>e.g. \"sequence of one step reductions\"</p>",
        "id": 401590159,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699776277
    },
    {
        "content": "<p>I think you already wrote a variation on that for infinite sequences</p>",
        "id": 401590187,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699776311
    },
    {
        "content": "<p>you can prove it by induction on SN</p>",
        "id": 401590199,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699776331
    },
    {
        "content": "<p>Yes, <code>(f : Nat → Trm), ((f 0 = t) ∧ (∀ n, (beta_red (f n) (f (succ n)))))</code> gives a sequence of one step reductions starting from t, right?</p>",
        "id": 401590281,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699776377
    },
    {
        "content": "<p>yes but that is infinite length</p>",
        "id": 401590290,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699776394
    },
    {
        "content": "<p>you need one of length n</p>",
        "id": 401590299,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699776404
    },
    {
        "content": "<p>So I should change <code>Nat</code> with set of n numbers?</p>",
        "id": 401590345,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699776438
    },
    {
        "content": "<p>or you could say <code>\\all i &lt; n, beta_red (f i) (f (succ i))</code></p>",
        "id": 401590369,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699776469
    },
    {
        "content": "<p>I see, that makes sense. Thanks.</p>",
        "id": 401590452,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699776536
    },
    {
        "content": "<p>deleted</p>",
        "id": 401595962,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699780867
    },
    {
        "content": "<p>Sorry for the possible repetition, but it's like I'm entering a vicious circle :)</p>\n<p>I have two definitions of being strongly normalizable: First is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">strongly_normalizable</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Trm</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Trm</span><span class=\"o\">),</span> <span class=\"o\">(((</span><span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">beta_red</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)))))</span> <span class=\"bp\">→</span> <span class=\"n\">False</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The other is inductive version, I think it's better than working with finite sequences:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">SN</span> <span class=\"o\">:</span> <span class=\"n\">Trm</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">sn</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">t'</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">beta_red</span> <span class=\"n\">t</span> <span class=\"n\">t'</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">SN</span> <span class=\"n\">t'</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">SN</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>The first one is good for to show that if <code>app t u</code> is strongly normalizable, then so are <code>t</code> and <code>s</code>. I need this fact in the base case of CR3 (lemma 13.2.7 c). </p>\n<p>The second one is good for finishing the last step in the arrow case of CR3. </p>\n<p>Thus, I would prefer to use both interchangeably, but the equivalence between them seems hard to me. I mean it seems we need AC, but in the formalization, I'm not sure how can I use it. Or I'm not sure if the idea is right.  So my remaining difficulty is only to show the equivalence between these definitions (if exists).</p>",
        "id": 401658429,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699838071
    },
    {
        "content": "<p>What is the issue? I thought I already explained that one <a href=\"#narrow/stream/270676-lean4/topic/strong.20normalization.20of.20STLC/near/400285175\">above</a>, so if this is giving you trouble you should show more of your work and what part is causing problems</p>",
        "id": 401856714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699914958
    },
    {
        "content": "<p>I suspect that any proof using <code>strongly_normalizable</code> can be reframed to use <code>SN</code> instead though, and then you won't need the equivalence</p>",
        "id": 401856873,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699915015
    },
    {
        "content": "<p>Let me also write here, both I learned the way to handle the equivalence between <code>strongly_normalizable</code> and <code>SN</code> via a suitable choice, and I learned to solve the issue that cause such a need for equivalence. For the discussion, <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/suitable.20choice\">see</a>. So, as <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  pointed, no need the equivalence. Thanks again.</p>",
        "id": 401871021,
        "sender_full_name": "Elif Uskuplu",
        "timestamp": 1699922156
    }
]