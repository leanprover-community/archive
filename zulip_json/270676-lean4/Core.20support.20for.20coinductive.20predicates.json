[
    {
        "content": "<p>Hi folks!</p>\n<p>The latest nightly (nightly-2025-10-08) contains now core support for <code>inductive</code>-like syntax for defining coinductive predicates.</p>\n<p>Here is an example of an infinite transition in a relation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"n\">coinductive</span><span class=\"w\"> </span><span class=\"n\">infSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">infSeq</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">infSeq</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>Out of this, you automatically get the following coinduction proof principle:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">infSeq</span><span class=\"bp\">.</span><span class=\"n\">coinduct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hyp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">infSeq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">✝</span>\n</code></pre></div>\n<p>To access the coinduction proof principle for a predicate, just postfix its name with <code>.coinduct</code><br>\nFor each predicate you get generated all its constructors, as well as <code>casesOn</code>. For example, the constructor you get is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">infSeq</span><span class=\"bp\">.</span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">infSeq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">infSeq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>The machinery also supports <code>mutual</code> blocks, as well as mixing inductive and coinductive predicate definitions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">mutual</span>\n<span class=\"w\">  </span><span class=\"n\">coinductive</span><span class=\"w\"> </span><span class=\"n\">tick</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">tock</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tick</span>\n\n<span class=\"w\">  </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">tock</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">tick</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tock</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>Here is an example of the mutual (co)induction proof principle.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">mutual_induct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pred_1</span><span class=\"w\"> </span><span class=\"n\">pred_2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hyp_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pred_1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">pred_2</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hyp_2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pred_1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">pred_2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">pred_1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tick</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tock</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">pred_2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Under the hood, everything relies on encoding things using lattice theory and checking monotonicity, while sharing a lot of  internals with <code>partial_fixpoint</code>. I am super happy to share the details if you have any questions.</p>\n<p>If you have  any feedback about this feature or you are stuck with using it, I would be more than happy to hear it. Feel free to drop a DM to me at any point or simply reply to this thread.</p>",
        "id": 543733948,
        "sender_full_name": "Wojciech Różowski",
        "timestamp": 1759926241
    },
    {
        "content": "<p>Hi Wojciech, I'd like to understand the details a bit more. This is a subject that comes up on the discord every now and then. Is there a write up somewhere that explains the internals?</p>",
        "id": 543735347,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759926626
    },
    {
        "content": "<p>Sadly, not yet! I am planning to sync at some point with <span class=\"user-mention\" data-user-id=\"354934\">@David Thrane Christiansen</span>  and add appropriate sections to the reference manual.</p>\n<p>Essentially, the idea is as follows:<br>\nOut of a coinductive definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">coinductive</span><span class=\"w\"> </span><span class=\"n\">infSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">infSeq</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">infSeq</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>we generate a \"flat\" inductive, that describes its one-step behaviour:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">infSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">infSeq</span><span class=\"bp\">._</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">call</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">   </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">infSeq</span><span class=\"bp\">._</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">call</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">infSeq</span><span class=\"bp\">._</span><span class=\"n\">functor</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">infSeq</span><span class=\"bp\">._</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">call</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>Such \"flat\" inductive valued in Prop can be equivalently rewritten to a following form: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">infSeq</span><span class=\"bp\">._</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">existential</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">infSeq</span><span class=\"bp\">._</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">call</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">infSeq</span><span class=\"bp\">._</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">call</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>Think of it as a disjunction of all constructors. </p>\n<p>This definition is used to kick-off the <code>partial_fixpoint</code> machinery (for more details see the <a href=\"https://lean-lang.org/doc/reference/latest/Definitions/Recursive-Definitions/#--tech-term-partial-fixpoint\">reference manual</a>), but specialised to lattice theory. In fact, you can define (co)inductive predicates as a tail-recursive function and using <code>inductive_fixpoint</code>/<code>coinductive_fixpoint</code> termination hint.</p>\n<p>Well-definedness of such definitions relies on monotonicity of the map extracted from the rules. We rely on a syntax driven tactic employed by <code>partial_fixpoint</code> and we have ready made monotonicity lemmas, that cover most of the typical examples. In fact, if your (co)inductive definitions are positive or if you mix induction and coinduction all inductive calls in coinductive definitions are in negative positions (and vice versa) then the tactic handles that immediately.</p>",
        "id": 543737611,
        "sender_full_name": "Wojciech Różowski",
        "timestamp": 1759927244
    },
    {
        "content": "<p>A few things I've noticed:</p>\n<ol>\n<li>the implicitness for parameters is wrong (<code>p</code> and <code>q</code> should be implicit in <code>inl</code>):</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">coinductive</span><span class=\"w\"> </span><span class=\"n\">MyOr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- info: MyOr.inl (p q : Prop) (h : p) : MyOr p q -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">MyOr</span><span class=\"bp\">.</span><span class=\"n\">inl</span>\n</code></pre></div>\n<ol start=\"2\">\n<li>the definitions are slightly verbose, e.g.:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">coinductive</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">thing</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">info: def Test.thing : Test :=</span>\n<span class=\"sd\">Eq.mpr (id (congrArg (fun _a =&gt; _a) Test.functor_unfold)) (Test._functor.thing Test)</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"bp\">.</span><span class=\"n\">thing</span><span class=\"w\"> </span><span class=\"c1\">-- could be `Eq.mpr Test.functor_unfold Test._functor.thing` (with `Test` implicit)</span>\n</code></pre></div>\n<ol start=\"3\">\n<li><code>match</code> doesn't work:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">coinductive</span><span class=\"w\"> </span><span class=\"n\">Simple</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">testMe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Simple</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<ol start=\"4\">\n<li>The <code>partial_fixpoint</code>-based <code>inductive</code> command is often more powerful than the regular one but there doesn't seem to be a way to activate it without putting it into a mutual block with a coinductive:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- mutual</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Simple</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"c1\">-- only works when the rest is not commented out</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Simple</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- coinductive Null (p : Prop) : Prop where</span>\n\n<span class=\"c1\">-- end</span>\n</code></pre></div>\n<ol start=\"5\">\n<li>The \"<code>coinductive</code> keyword can only be used to define predicates\" error sometimes appears in the wrong place (take e.g. the previous example with <code>coinductive Null (p : Prop) where</code> instead, the error will appear on <code>Simple</code>).</li>\n<li>The induction and coinduction principles use non-standard names (maybe use <code>motive</code> / <code>motive_&lt;n&gt;</code> and <code>&lt;constructor name&gt;</code> instead of <code>pred_&lt;n&gt;</code> and <code>hyp_&lt;n&gt;</code>).</li>\n</ol>\n<p>The first two and last two seem to be pretty simple to fix while the third one probably requires some work (e.g. <code>Eq.rec</code> support for <code>match</code>?) and the fourth one requires some thought into what kind of syntax to use.</p>",
        "id": 543852716,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1759969966
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"873547\">@Robin Arnez</span> for such a detailed info.</p>\n<ol>\n<li>I will look into implicitness of the arguments - to be frank with you I did not notice something like that was the case for inductives.</li>\n<li>Hmm, I guess this is the matter of the metaprogramming code generating too verbose of a code.</li>\n<li>Yes, indeed! Match statements are not supported yet. I know that in the near future <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span>  is planning to look into match compilation pipeline and allow it to be extensible. That's why I delayed working on it for now, and also wanted to see if people would really use <code>match</code> on coinductive predicates in practice.</li>\n<li>Hmm, that is an interesting point. It is quite easy to allow users to elaborate inductives using the lattice-theoretic approach, but I did not anticipate the interest of users in such a feature. I guess it is nice that you can weaken positivity to monotonicity.</li>\n<li>Yes, this is on purpose. From what I understand, for inductives, by default if you don't put that it is an arrow into <code>Prop</code>, it is implicitly living in <code>Type</code>. We wanted to follow the same convention and make it clear to the user, that you can only coinductively define things that live in <code>Prop</code>.</li>\n<li>Fair enough, that is a good hint for the naming scheme.</li>\n</ol>",
        "id": 543890496,
        "sender_full_name": "Wojciech Różowski",
        "timestamp": 1759995762
    },
    {
        "content": "<p>If core later chooses to add support for coinductive non-Prop types, will this be compatible with the coinductive predicate syntax and semantics? My understanding is that coinductive non-Prop types would currently suffer from a performance issue, but that the issue was fixable.</p>",
        "id": 543898207,
        "sender_full_name": "Niels Voss",
        "timestamp": 1759998211
    },
    {
        "content": "<p>This is what I would expect. See (5) in my previous message. Precisely, in the situation when the inferred universe is <code>Type u</code>, some coinductive data package could be used, if one decided to implement it and have it in core.</p>",
        "id": 543898746,
        "sender_full_name": "Wojciech Różowski",
        "timestamp": 1759998358
    },
    {
        "content": "<p>It's been a while since I used coinduction (and even then I hardly did anything with it) but assuming I'm not misremembering, didn't Rocq encounter problem because they supported coinductive types with multiple constructors directly (as opposed to only supporting coinductive records/structures)? Agda seems to call the former approach \"Old Coinduction\" (see <a href=\"https://agda.readthedocs.io/en/latest/language/coinduction.html#old-coinduction\">https://agda.readthedocs.io/en/latest/language/coinduction.html#old-coinduction</a>) which is not recommended for some reason?</p>",
        "id": 543899648,
        "sender_full_name": "Niels Voss",
        "timestamp": 1759998600
    },
    {
        "content": "<p>Ah, I see. So from what I understand, this is related to the approach of adding coinduction to the underlying type theory/kernel. And indeed, Rocq and Agda had some issues with positive formulation of coinductive types via constructors and went for negative formulations via copatterns/destructors.</p>",
        "id": 543900038,
        "sender_full_name": "Wojciech Różowski",
        "timestamp": 1759998701
    },
    {
        "content": "<p>In our approach, which only applies to (arrows into) <code>Prop</code>, we simply rely on lattice theory and compile constructors to monotone map on lattices, which does not require any kernel extensions and is simply encoded.</p>",
        "id": 543900213,
        "sender_full_name": "Wojciech Różowski",
        "timestamp": 1759998749
    },
    {
        "content": "<p>From what I remember, in Agda/Rocq there is quite of subtlety of having eta conversions for coinductive types, which can make type checking non-terminating.</p>",
        "id": 543900761,
        "sender_full_name": "Wojciech Różowski",
        "timestamp": 1759998887
    },
    {
        "content": "<p>I see (or at least I think I might). I'm just wondering if it could potentially be that if Lean chooses to add coinductive non-Prop types in the future, if we would only support coinductive records rather than coinductive types with custom constructors, and if this would mean that <code>coinductive</code> could only ever be used for <code>Prop</code> and that all other coinductive types would have to use <code>costructure</code> or something.</p>",
        "id": 543901442,
        "sender_full_name": "Niels Voss",
        "timestamp": 1759999084
    },
    {
        "content": "<p>Okay, now I also see what you meant. In the hypothetical scenario, where Lean decides to extend its kernel with coinductive types, I would agree  that copatterns/coinductive records approach might be the most reasonable syntax for specifying these and <code>coinductive</code> keyword in current form, would only make sense for those lattice-theoretic predicates.</p>",
        "id": 543902001,
        "sender_full_name": "Wojciech Różowski",
        "timestamp": 1759999246
    },
    {
        "content": "<p>On the other hand, I could envision someone extending the Qpf framework (which encodes coinductive data via constructions on quotients on polynomial functors) to be able to also handle indices and use it for coinductive data and have <code>coinductive</code> keyword to rely on it when dealing with things beyond predicates.</p>",
        "id": 543902448,
        "sender_full_name": "Wojciech Różowski",
        "timestamp": 1759999359
    },
    {
        "content": "<p>The reason we focused on predicates is that you can often get by with coinductive predicates only (i.e. you work with bisimulations rather than bisimilarity equivalence classes) and their encoding is quite simple and relies on lattice theory, rather than more involved things like qpf (mentioned earlier) or bnf (in the case of Isabelle).</p>",
        "id": 543902827,
        "sender_full_name": "Wojciech Różowski",
        "timestamp": 1759999483
    },
    {
        "content": "<p>So if we never extend Lean's kernel (which we probably won't) and we implement coinduction in \"userspace\" using QPF, then the problems that Rocq and Agda encountered go away?</p>",
        "id": 543902921,
        "sender_full_name": "Niels Voss",
        "timestamp": 1759999514
    },
    {
        "content": "<p>Oh for (5) I meant doing something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">rs</span><span class=\"bp\">.</span><span class=\"n\">findIdxM?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forallTelescopeReducing</span><span class=\"w\"> </span><span class=\"bp\">·.</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">body</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">body</span><span class=\"bp\">.</span><span class=\"n\">isProp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">throwErrorAt</span><span class=\"w\"> </span><span class=\"n\">views</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">!.</span><span class=\"n\">declId</span><span class=\"w\"> </span><span class=\"s2\">\"`coinductive` keyword can only be used to define predicates\"</span>\n</code></pre></div>\n<p>rather than always targeting the first one</p>",
        "id": 543922025,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1760005363
    },
    {
        "content": "<p>Ah sorry <span class=\"user-mention\" data-user-id=\"873547\">@Robin Arnez</span> , thanks for hinting that!</p>",
        "id": 543922724,
        "sender_full_name": "Wojciech Różowski",
        "timestamp": 1760005585
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/270676-lean4/topic/Core.20support.20for.20coinductive.20predicates/near/543902921\">said</a>:</p>\n<blockquote>\n<p>So if we never extend Lean's kernel (which we probably won't) and we implement coinduction in \"userspace\" using QPF, then the problems that Rocq and Agda encountered go away?</p>\n</blockquote>\n<p>Yes, this is what I would expect. For example <code>codata</code> keyword in <span class=\"user-mention\" data-user-id=\"481133\">@Alex Keizer</span>'s reimplementation of qpf relies on positive formulation of codata via constructors.</p>",
        "id": 543922921,
        "sender_full_name": "Wojciech Różowski",
        "timestamp": 1760005649
    },
    {
        "content": "<p>Indeed, by doing coinductive data in \"userspace\", as you call it, we don't have to worry about introducing inconsistencies to the type theory, given we don't touch the type theory at all, so we can have positive coinduction without issue.</p>",
        "id": 543924162,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1760006045
    },
    {
        "content": "<p>Does <code>coinductive</code> support families? (I've tried to use it for my <code>compute_asymptotics</code> tactic to redefine <a href=\"https://github.com/leanprover-community/mathlib4/blob/d09750962792e4c466e5110b8f0576c5710eb15b/Mathlib/Tactic/ComputeAsymptotics/Multiseries/Defs.lean#L1040\">PreMS.Approximates</a> but got lots of <code>type mismatch</code> error).</p>\n<p>In the following minimal example it complains about metavariables:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">coinductive</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>",
        "id": 569891278,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1769277370
    },
    {
        "content": "<p>Thank you for providing the example - I will have a look to see what is going wrong with this.</p>",
        "id": 569892997,
        "sender_full_name": "Wojciech Różowski",
        "timestamp": 1769278805
    },
    {
        "content": "<p>But yes, it is supposed to support arrows into Prop.</p>",
        "id": 569893089,
        "sender_full_name": "Wojciech Różowski",
        "timestamp": 1769278910
    },
    {
        "content": "<p>I had a look at the snippet that <span class=\"user-mention\" data-user-id=\"552388\">@Vasilii Nesterov</span> provided and it turns out it triggered a metavariable unification issue inside of <code>Lean.Meta.MkIffOfInductiveProp</code>. I have made a fix to this <a href=\"https://github.com/leanprover/lean4/pull/12219\">in this PR</a> and hopefully soon will get it merged.</p>",
        "id": 570661660,
        "sender_full_name": "Wojciech Różowski",
        "timestamp": 1769635112
    },
    {
        "content": "<p>Update: just merged that. Please let me know if you encounter any issues and thanks again for reporting that one.</p>",
        "id": 571402775,
        "sender_full_name": "Wojciech Różowski",
        "timestamp": 1770030195
    },
    {
        "content": "<p>Are there plans to get stronger co-induction principles than the standard \"single-step\" co-induction principle provided by <code>coinduct</code>? In particular, I am thinking about something like parametrized co-induction as provided by the <a href=\"https://github.com/snu-sf/paco\">paco library</a> or the <a href=\"https://github.com/damien-pous/coinduction\">companion technique</a> by Pous?</p>",
        "id": 571419971,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1770035421
    },
    {
        "content": "<p>That's a great question. It is not something that I originally planned, but I have been thinking about it, and if I ever had more time to dedicate to this project, this would be one of the first things I would consider.</p>",
        "id": 571505154,
        "sender_full_name": "Wojciech Różowski",
        "timestamp": 1770058903
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"644702\">Wojciech Różowski</span> <a href=\"#narrow/channel/270676-lean4/topic/Core.20support.20for.20coinductive.20predicates/near/571402775\">said</a>:</p>\n<blockquote>\n<p>Update: just merged that. Please let me know if you encounter any issues and thanks again for reporting that one.</p>\n</blockquote>\n<p>This works, awesome! I'll wait for it to reach Mathlib and try in my code</p>",
        "id": 571741515,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1770145831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"574718\">Michael Sammler</span> <a href=\"#narrow/channel/270676-lean4/topic/Core.20support.20for.20coinductive.20predicates/near/571419971\">said</a>:</p>\n<blockquote>\n<p>Are there plans to get stronger co-induction principles than the standard \"single-step\" co-induction principle provided by <code>coinduct</code>? In particular, I am thinking about something like parametrized co-induction as provided by the <a href=\"https://github.com/snu-sf/paco\">paco library</a> or the <a href=\"https://github.com/damien-pous/coinduction\">companion technique</a> by Pous?</p>\n</blockquote>\n<p>I think <span class=\"user-mention\" data-user-id=\"1016077\">@Sam Hart</span> ported Paco: <a href=\"https://github.com/leanprover-community/mathlib4/pull/34035\">#34035</a>. This is great!</p>",
        "id": 574022923,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1771206300
    },
    {
        "content": "<p>I tried using <code>coinductive</code> in Mathlib, but it <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/22308313610/job/64533229349?pr=28291\">triggers</a> some linters:</p>\n<ol>\n<li>It complains that constructors of a coinductive predicate are <code>def</code>s instead of <code>theorem</code>s.</li>\n<li>And that <code>functor_unfold</code> and <code>casesOn</code> don't have docstrings.</li>\n</ol>\n<p>In my opinion, the first should be fixed in the <code>coinductive</code> implementation, and the second may be added as an exception in the linter.</p>",
        "id": 575304360,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1771855086
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"552388\">@Vasilii Nesterov</span> for hinting that, I will look into this!</p>",
        "id": 575308767,
        "sender_full_name": "Wojciech Różowski",
        "timestamp": 1771856254
    }
]