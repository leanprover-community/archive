[
    {
        "content": "<p>Hi! Is there an option to disable inlining in the compiler, to make it easier to read the IR of a function?</p>",
        "id": 494220114,
        "sender_full_name": "Leo Stefanesco",
        "timestamp": 1737056078
    },
    {
        "content": "<p>There isn't. This also feels a bit like a <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> question, inlining is of utmost importance for so much stuff that happens in the compiler so the resulting IR usually completely depends on inlining being done, for example:</p>\n<ul>\n<li>Is there potential for reuse with FBIP</li>\n<li>Where do we need to add reference counts?</li>\n<li>Can we do classic functional optimizations like cases-of-cases?</li>\n</ul>\n<p>Do you have a reason to want to read version of the IR that will potentially behave completely different from the actually optimized one?</p>",
        "id": 494221382,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1737056654
    },
    {
        "content": "<p>My goal is to try to see if I'm getting reuse with FBIP. I tried to use <code>set_option trace.compiler.ir.rc</code> but it prints huge functions because of inlining, and was hoping that without inlining it would be clear if my function doesn't touch the ref counters. Is there a better way to see if my objects are being reused?</p>",
        "id": 494223343,
        "sender_full_name": "Leo Stefanesco",
        "timestamp": 1737057460
    },
    {
        "content": "<p>Right, you definitely <em>need</em> to have inlining enabled for reuse to happen optimally so disabling it is not an option for this at all. And no there is currently no better way apart from reasoning about the IR. That being said experienced Lean programmers at least have an intuition about what kind of code patterns will and won't give you reuse.</p>",
        "id": 494228250,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1737059613
    }
]