[
    {
        "content": "<p>Is there a nice way to take a given theorem and replace all occurrences of <code>↔</code> in the theorem statement with <code>=</code> and fix the proof accordingly? For example, say we know:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Iff</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_ne_one</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">elim</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">true_iff_false</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">elim</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Then is there an easy way to generate a proof of <code>(0 = 1) = (True = False)</code>?</p>",
        "id": 492970093,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1736521980
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=iff_eq_eq#doc\">docs#iff_eq_eq</a></p>",
        "id": 492970594,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1736522135
    },
    {
        "content": "<p>That won't suffice, as I do not only want to replace top-level <code>↔</code>s.</p>",
        "id": 492970749,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1736522170
    },
    {
        "content": "<p>Any translation of a proof to an \"equivalent but not identical\" proof is bound to be tricky along the edges.</p>",
        "id": 492970802,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1736522186
    },
    {
        "content": "<p>So simp_rw [iff_eq_eq]?</p>",
        "id": 492970843,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1736522199
    },
    {
        "content": "<p>Or if you're saying you already have a related proof, simpa?</p>",
        "id": 492970993,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1736522244
    },
    {
        "content": "<p>You can scan the expression for the proof, replacing the iff with equalities, prepended by the application of the lemma that Yakov pointed out, but I think that it will be a little painful to get it to work in a robust manner.</p>",
        "id": 492970999,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1736522246
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> What are your concerns wrt robustness? I was hoping I could traverse the proof term and for every subterm whose type contains a <code>↔</code>, traverse to the subterm which constructs the <code>↔</code> and apply <code>propext</code> to it.</p>",
        "id": 492971616,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1736522447
    },
    {
        "content": "<p>My concerns are not specific to this situation, but generic: any translation <code>proof --&gt; proof</code> that I tried, not matter how trivial it looked without being the identity, met some resistance somewhere.</p>",
        "id": 492972004,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1736522547
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> Just from trying a handful of examples even <code>simp only</code> seems to do the job.</p>",
        "id": 492972996,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1736522884
    },
    {
        "content": "<p>Well, until dependent type stuff enters the game:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iff_eq_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 492973576,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1736523071
    },
    {
        "content": "<p>... enter the edge cases.</p>",
        "id": 492973808,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1736523139
    },
    {
        "content": "<p>Have you tried <code>simpa [iff_eq_eq] using t</code></p>",
        "id": 492982000,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1736525792
    },
    {
        "content": "<p><code>rw [iff_eq_eq, t]</code> actually works here. I've noticed more cases where <code>simp</code> is less powerful than <code>rw</code> recently, most recently <a href=\"https://github.com/leanprover-community/mathlib4/pull/20512#discussion_r1907184218\">here</a>.</p>",
        "id": 492990549,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1736528704
    }
]