[
    {
        "content": "<p>I am playing with groups and order ATM. I am trying the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Nat.find_after</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidablePred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span><span class=\"n\">n'</span><span class=\"o\">,</span> <span class=\"n\">n'</span> <span class=\"bp\">&gt;=</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">n'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">n</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">Nat.find_after</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Nat.find</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidablePred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.find_after</span> <span class=\"n\">p</span> <span class=\"mi\">0</span> <span class=\"n\">H</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">ExtendedNat</span>\n<span class=\"bp\">|</span> <span class=\"n\">Finite</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">ExtendedNat</span>\n<span class=\"bp\">|</span> <span class=\"n\">Infinite</span> <span class=\"o\">:</span> <span class=\"n\">ExtendedNat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Order</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Pow</span> <span class=\"n\">T</span> <span class=\"n\">Nat</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OfNat</span> <span class=\"n\">T</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ExtendedNat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"bp\">∃</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">t</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"k\">then</span> <span class=\"bp\">.</span><span class=\"n\">Finite</span> <span class=\"o\">(</span><span class=\"n\">Nat.find</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">t</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"bp\">.</span><span class=\"n\">Infinite</span>\n</code></pre></div>\n<p>I think it's sound. Just need to pass it through Lean.</p>",
        "id": 393312033,
        "sender_full_name": "Ben",
        "timestamp": 1695756687
    },
    {
        "content": "<p>I have read the mathlib <code>Nat.find</code>and std <code>WellFounded.fix</code> but couldn't quite figure out how to use them in a simple way?</p>",
        "id": 393312064,
        "sender_full_name": "Ben",
        "timestamp": 1695756703
    },
    {
        "content": "<p>Is there a way I can take my current statements and fix the current issues</p>\n<ul>\n<li>Proving <code>Nat.find_after</code> using <code>H</code> as a termination condition</li>\n<li>Modifying <code>H</code> in to alter or add the antecedent <code>n' &gt; n</code></li>\n<li>Use the condition in <code>if</code> to pass to <code>Nat.find</code> (currently it doesn't like the underscore :( )</li>\n</ul>",
        "id": 393312463,
        "sender_full_name": "Ben",
        "timestamp": 1695756846
    }
]