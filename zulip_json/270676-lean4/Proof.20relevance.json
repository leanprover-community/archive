[
    {
        "content": "<p>We are doing some proof relevant proofs, so that the proofs are proven in the Type universe instead of Prop. For this we have had to redefine quite a bit of Eq and Decidable and we don't have the rewrite tactic working yet. Has anyone ever attempted this in Lean or are we the first?</p>\n<p><a href=\"https://github.com/katydid/proofs/blob/main/Katydid/Std/Tipe.lean\">https://github.com/katydid/proofs/blob/main/Katydid/Std/Tipe.lean</a><br>\n<a href=\"https://github.com/katydid/proofs/blob/main/Katydid/Std/TDecidable.lean\">https://github.com/katydid/proofs/blob/main/Katydid/Std/TDecidable.lean</a></p>",
        "id": 417106504,
        "sender_full_name": "awalterschulze",
        "timestamp": 1705859613
    },
    {
        "content": "<p>Also I this function seems illegal to me</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">TEq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TEq</span> <span class=\"n\">x</span> <span class=\"n\">x</span>\n\n<span class=\"c1\">-- legal</span>\n<span class=\"kd\">def</span> <span class=\"n\">eq_of_teq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">TEq</span> <span class=\"n\">a</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- illlegal</span>\n<span class=\"kd\">def</span> <span class=\"n\">teq_of_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TEq</span> <span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>since technically I am now defining a function that goes from Prop to Type, which is usually not allowed.</p>",
        "id": 417106603,
        "sender_full_name": "awalterschulze",
        "timestamp": 1705859695
    },
    {
        "content": "<p>Seems fine to me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">TEq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TEq</span> <span class=\"n\">x</span> <span class=\"n\">x</span>\n\n<span class=\"c1\">-- legal</span>\n<span class=\"kd\">def</span> <span class=\"n\">eq_of_teq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">TEq</span> <span class=\"n\">a</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:=</span>\n  <span class=\"n\">h.rec</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- illlegal</span>\n<span class=\"kd\">def</span> <span class=\"n\">teq_of_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TEq</span> <span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:=</span>\n  <span class=\"n\">h.rec</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 417110122,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705862560
    },
    {
        "content": "<p>But I also see now that you have essentially the same thing in the file linked above. What do you mean by \"illegal\"?</p>",
        "id": 417110895,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705863244
    },
    {
        "content": "<p>Take a look at <a href=\"https://lean-forward.github.io/logical-verification/2018/41_notes.html\">https://lean-forward.github.io/logical-verification/2018/41_notes.html</a>, the sections about elimination. Usually Prop to Type is disallowed, but Eq is a \"syntactic subsingleton\" so it's allowed to eliminate to Type.</p>",
        "id": 417111720,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705863937
    },
    {
        "content": "<p>I've been thinking about this somewhat with asymptotics, in particular I want to keep track of a multiple but I don't really care which. And so I've been trying to work with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">ALE</span> <span class=\"o\">[</span><span class=\"n\">CanonicallyOrderedLatticeCommSemiring</span> <span class=\"n\">θ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">CostFunction</span> <span class=\"n\">α</span> <span class=\"n\">θ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">θ</span>\n  <span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">θ</span>\n  <span class=\"n\">ale</span><span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"bp\">↑</span><span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"bp\">↑</span><span class=\"n\">k</span>\n</code></pre></div>\n<p>instead of <code>∃ (m k: θ), x ≤ ↑m * y + ↑k</code> but its definitely awkward with not having simp in this case, so it would be kind of cool if we could have simp-equivalent tactics. So I've given it a some thought in terms of, I want to be able to produce a variable of this type, but I'm not super picky about which variable it is (although tighter bounds are \"nicer\").</p>\n<p>That being said, I feel like most of the infrastructure already exists. I'm not sure from a practical perspective TEq differs from Eq. And I think in general most of the infrastructure already exists using normal lean functions, for example I think<code>Tiso</code> is just <code>Equiv</code>.</p>",
        "id": 417149638,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1705892474
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"562941\">Andrew Carter</span> <a href=\"#narrow/stream/270676-lean4/topic/Proof.20relevance/near/417149638\">said</a>:</p>\n<blockquote>\n<p>And I think in general most of the infrastructure already exists using normal lean functions, for example I think<code>Tiso</code> is just <code>Equiv</code>.</p>\n</blockquote>\n<p>This sounds correct to me; I wouldn't expect you to need any new types in your goal to make things \"proof\" relevant, we already lately have all the types you need (<code>And</code> →<code>PProd</code>, <code>Or</code> → <code>PSum</code>, <code>Exists</code> →<code>PSigma</code>, no change needed for <code>Eq</code>)</p>",
        "id": 417175097,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705910492
    },
    {
        "content": "<p>Don't you still need to boost <code>Eq</code> to <code>TEq</code>? Otherwise it'll be subject to proof irrelevance.</p>",
        "id": 417175659,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705910762
    },
    {
        "content": "<p>I'm also not sure about <code>Tiso</code> being <code>Equiv</code>, since <code>Equiv</code> is puts the left- and right-inverse proofs into <code>Prop</code>, so it's hiding proof irrelevance.</p>\n<p>Certainly they're equivalent however:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">TEq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TEq</span> <span class=\"n\">x</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">TEq_equiv</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">TEq</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">invFun</span> <span class=\"bp\">|</span> <span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">_</span>\n  <span class=\"n\">left_inv</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">right_inv</span> <span class=\"bp\">|</span> <span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 417180885,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705913080
    },
    {
        "content": "<p>Doesn't this mean that TEq is basically proof irrelevant too?</p>",
        "id": 417182108,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1705913603
    },
    {
        "content": "<p>What does \"basically\" proof irrelevant mean? The condition of proof irrelevance would be that given two terms of <code>TEq x y</code> they are defeq.</p>",
        "id": 417183412,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705914094
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> As I understand it, your question could be rephrased as \"are all inhabitants of <code>TEq x y</code>equal to each other\". In Lean, they are propositionally equal (this terminology is a bit confusing here - what's meant is \"they can be proven to be equal\", not \"it's a <code>Prop</code>\"):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">TEq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TEq</span> <span class=\"n\">x</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">TEq.all_tequal</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">TEq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TEq</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span>\n  <span class=\"n\">cases</span> <span class=\"n\">q</span>\n  <span class=\"n\">apply</span> <span class=\"n\">refl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">TEq.all_equal</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">TEq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span>\n  <span class=\"n\">cases</span> <span class=\"n\">q</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>But as <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> pointed out, we also care about what the type theory lets you consider equal without requiring a proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">TEq.all_equal</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">TEq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  tactic 'rfl' failed, equality lhs</span>\n<span class=\"cm\">    p</span>\n<span class=\"cm\">  is not definitionally equal to rhs</span>\n<span class=\"cm\">    q</span>\n\n<span class=\"cm\">  α✝: Type u_1</span>\n<span class=\"cm\">  xy: α✝</span>\n<span class=\"cm\">  pq: TEq x y</span>\n<span class=\"cm\">  ⊢ p = q</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Eq.all_equal</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>The fact that <code>TEq.all_equal</code> and <code>TEq.all_tequal</code> are true in Lean is actually an instance of a deep issue in type theory. Everyone used to just assume that this was the case, but nobody succeeded in proving it. Some version of it was often adopted as an axiom (the things to search for are \"UIP\" and \"axiom K\"), and it was provable using Coquand's initial formulation of dependent pattern matching, but the proof never went through. Then, Hofmann and Streicher published \"The Groupoid Interpretation of Type Theory\" in which they give a model in which this axiom is false.</p>\n<p>In Lean, we just treat types as sets and so this is fine, and you don't really have to worry about which equality proof you have. But this is not true in every system out there, and it rules out certain type system features that are incompatible with it.</p>",
        "id": 417185155,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1705914648
    },
    {
        "content": "<p>I did mean that 'this means that TEq is a subsingleton/TSubsingleton', so I feel like this makes this construction useless in Lean. I'm a bit surprised it's true, however, as I thought systems without UIP/K basically define equality the same way, but without having proof irrelevance in the kernel, it no longer even becomes provable propositionally that all instances of the identity type are equal - why does this fail with TEq here?</p>",
        "id": 417187412,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1705915488
    },
    {
        "content": "<p>UIP is known to be infectious like this. Otherwise we could do HoTT by just moving to <code>TEq</code>. :(</p>",
        "id": 417189071,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1705916066
    },
    {
        "content": "<p>The Lean 3 HoTT repo does define <a href=\"https://github.com/gebner/hott3/blob/7ead7a8a2503049eacd45cbff6587802bae2add2/src/hott/init/path0.lean#L18\"><code>Type</code>-valued equality</a> and implement a <a href=\"https://github.com/gebner/hott3/blob/7ead7a8a2503049eacd45cbff6587802bae2add2/src/hott/init/meta/rewrite.lean\">rewrite tactic</a>, but it also disables large elimination altogether. I can't find the same def in this <a href=\"https://github.com/forked-from-1kasper/ground_zero/tree/master\">Lean 4 repo</a>.</p>\n<p>I think I had a similar idea as awalterschulze <a href=\"#narrow/stream/113488-general/topic/Creating.20own.20Prop.20universe/near/290328980\">here</a>, but realized it doesn't work (inconsistent with univalence + large elimination).</p>",
        "id": 417250293,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1705936276
    },
    {
        "content": "<p>Wow amazing responses. Thank you for everyone's help<br>\nWe have been reading through this and it has been really interesting, but I wouldn't say we understood everything. Definitely more reading to do.</p>\n<p>But it seems like there might not be a way to do proof relevance in Lean?</p>\n<p>The use case is that we want to represent a language using :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Lang</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n</code></pre></div>\n<p>We want proof relevance to distinguish between different parses.</p>",
        "id": 417306071,
        "sender_full_name": "awalterschulze",
        "timestamp": 1705953857
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"557483\">awalterschulze</span> <a href=\"#narrow/stream/270676-lean4/topic/Proof.20relevance/near/417306071\">said</a>:</p>\n<blockquote>\n<p>We want proof relevance to distinguish between different parses.</p>\n</blockquote>\n<p>Yeah, we are facing similar issues when working towards computational Complexity.<br>\nThe approach I'm currently taking is to build a parallel language in Lean structures,<br>\nand an execution model. Then simulate the execution model in Lean. Ideally there would be some sort of nice DSL interface so it looks like you are writing normal lean, but actually you are building structures.</p>\n<p>I.e. write a normal Lean function that takes a Lean structure that represents a Lean function and works through proving a proof relevance and provides a trace of all the steps it did (probably some form of <code>Nat -&gt; Step</code>).</p>\n<p>This might be a heavy lift for Proof relevance since you'd have to simulate a lot of Lean inside of Lean,<br>\nas opposed to Computational Complexity which can start with very simple constructs.</p>",
        "id": 417335159,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1705966029
    },
    {
        "content": "<p>It's not so clear to me what your respective applications are, but note that UIP doesn't necessarily mean that you can't do proof-relevant developments in Lean. For example, here is a proof-relevant membership predicate on lists:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">In</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">here</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">In</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">later</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">In</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">→</span> <span class=\"n\">In</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">In.getIndex</span> <span class=\"o\">:</span> <span class=\"n\">In</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">→</span> <span class=\"bp\">Σ'</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">xs.get</span><span class=\"bp\">?</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">here</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">List.get</span><span class=\"bp\">?</span><span class=\"o\">]⟩</span>\n  <span class=\"bp\">|</span> <span class=\"n\">later</span> <span class=\"n\">y</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h.getIndex</span>\n    <span class=\"o\">⟨</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">List.get</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">]⟩</span>\n</code></pre></div>\n<p>If you do need specifically proof-relevant equality, I would switch to Coq or Agda. Lean actively works against you in that case.</p>",
        "id": 417428916,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1706010626
    },
    {
        "content": "<p>I don't see why you need a proof relevant prop for your usage. You need an inductive type for counting steps and props on this type.</p>",
        "id": 417451185,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1706018334
    },
    {
        "content": "<p>You can add the traces as a parameter to one of your constructors. Thus objects with different traces are treated unequally.</p>",
        "id": 417452274,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1706018643
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 417452412,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1706018677
    },
    {
        "content": "<p>that being said, I think you might find it easier to create a simple imperative language in which you can embed lean functions with separate complexity annotations and derive conditional results, rather than recreate lean in lean and trace the number of lean steps in executing that function. That would actually be much closer to how modern researchers work (although they do use complexity assertions which are either theorems or conjectures, rather than arbitrary assertions. Alternatively instead of annotating complexities, you could just parametrize them and then write conditional theorem statements with values for those parameters.</p>",
        "id": 417452957,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1706018837
    },
    {
        "content": "<p>I find the current attempts in the ITP community to verify algorithms by writing implementable/executable code pointless, since that is very far from how most algorithms theory research works these days.</p>",
        "id": 417453983,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1706019133
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/270676-lean4/topic/Proof.20relevance/near/417250293\">said</a>:</p>\n<blockquote>\n<p>The Lean 3 HoTT repo does define <a href=\"https://github.com/gebner/hott3/blob/7ead7a8a2503049eacd45cbff6587802bae2add2/src/hott/init/path0.lean#L18\"><code>Type</code>-valued equality</a> and implement a <a href=\"https://github.com/gebner/hott3/blob/7ead7a8a2503049eacd45cbff6587802bae2add2/src/hott/init/meta/rewrite.lean\">rewrite tactic</a>, but it also disables large elimination altogether. I can't find the same def in this <a href=\"https://github.com/forked-from-1kasper/ground_zero/tree/master\">Lean 4 repo</a>.</p>\n</blockquote>\n<p>It’s here: <a href=\"https://github.com/forked-from-1kasper/ground_zero/blob/a3122579f48dc7aa9a65be33d218249569980327/GroundZero/Types/Id.lean#L16-L17\">https://github.com/forked-from-1kasper/ground_zero/blob/a3122579f48dc7aa9a65be33d218249569980327/GroundZero/Types/Id.lean#L16-L17</a></p>",
        "id": 418228523,
        "sender_full_name": "Siegmentation Fault",
        "timestamp": 1706256502
    },
    {
        "content": "<p>This is amazing, wow</p>\n<p>So a little guess work here, but it seems like</p>\n<p>If you add the hott prefix to a theorem, the it checks that large elimination is not used and this way proof relevance is retained. Is that true?</p>",
        "id": 418312455,
        "sender_full_name": "awalterschulze",
        "timestamp": 1706287404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"557483\">awalterschulze</span> <a href=\"#narrow/stream/270676-lean4/topic/Proof.20relevance/near/418312455\">said</a>:</p>\n<blockquote>\n<p>If you add the hott prefix to a theorem, the it checks that large elimination is not used and this way proof relevance is retained. Is that true?</p>\n</blockquote>\n<p>Yes exactly.</p>",
        "id": 418405943,
        "sender_full_name": "Siegmentation Fault",
        "timestamp": 1706350295
    },
    {
        "content": "<p>We tried hott and it is pretty seamless, where it becomes really hard not to use large elimination</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">hott</span> <span class=\"kd\">def</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">a_or_b</span> <span class=\"o\">[</span><span class=\"sc\">'a'</span><span class=\"o\">]</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n</code></pre></div>\n<p>Since our regular expressions, seems to have it built in, in Char.ofNat.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">uses</span> <span class=\"n\">large</span> <span class=\"n\">eliminator</span><span class=\"o\">:</span> <span class=\"n\">Eq.rec</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Eq.ndrec</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Bool.noConfusion</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Nat.ble_succ_eq_true.match_1</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Nat.ble_succ_eq_true</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Nat.ble_eq_true_of_le</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Nat.not_le_of_not_ble_eq_true</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Nat.decLe</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Nat.decLt</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Char.ofNat.proof_2</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Char.ofNat</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">hp</span>\n</code></pre></div>\n<p>So I think it is also going to be really hard to actually use hott.</p>",
        "id": 418787095,
        "sender_full_name": "awalterschulze",
        "timestamp": 1706602987
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/270676-lean4/topic/Proof.20relevance/near/417428916\">said</a>:</p>\n<blockquote>\n<p>It's not so clear to me what your respective applications are, but note that UIP doesn't necessarily mean that you can't do proof-relevant developments in Lean. For example, here is a proof-relevant membership predicate on lists:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">In</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">here</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">In</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">later</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">In</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">→</span> <span class=\"n\">In</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">In.getIndex</span> <span class=\"o\">:</span> <span class=\"n\">In</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">→</span> <span class=\"bp\">Σ'</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">xs.get</span><span class=\"bp\">?</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">here</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">List.get</span><span class=\"bp\">?</span><span class=\"o\">]⟩</span>\n  <span class=\"bp\">|</span> <span class=\"n\">later</span> <span class=\"n\">y</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h.getIndex</span>\n    <span class=\"o\">⟨</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">List.get</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">]⟩</span>\n</code></pre></div>\n<p>If you do need specifically proof-relevant equality, I would switch to Coq or Agda. Lean actively works against you in that case.</p>\n</blockquote>\n<p>We took a while to understand this, but it has been very helpful.<br>\nI understand now, we have use Eq in Prop, if we pair it in a PSigma Σ' with the proof relevant part to preserve how the string was parsed. This is still a work in progress, but already an improvement:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">TEq.</span><span class=\"o\">{</span><span class=\"n\">tu</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">tu</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">tu</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">TEq</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"s2\">\" ≡ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">TEq</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Lang</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">concat</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Lang</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">Lang</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Lang</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"bp\">Σ'</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">w</span> <span class=\"bp\">≡</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">++</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"bp\">×</span> <span class=\"n\">Q</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>With some use of <code>cases</code> we can use rewrite tactics, so that is great.<br>\nBut it is a bit annoying to have to destruct, I was wondering if there is a way always unfold, but it seems unfolding from Type to Prop in TEq's case, is not really possible without explicitly calling <code>cases</code>.</p>",
        "id": 418808087,
        "sender_full_name": "awalterschulze",
        "timestamp": 1706610910
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"557483\">awalterschulze</span> <a href=\"#narrow/stream/270676-lean4/topic/Proof.20relevance/near/418787095\">said</a>:</p>\n<blockquote>\n<p>We tried hott and it is pretty seamless, where it becomes really hard not to use large elimination</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">hott</span> <span class=\"kd\">def</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">a_or_b</span> <span class=\"o\">[</span><span class=\"sc\">'a'</span><span class=\"o\">]</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n</code></pre></div>\n<p>Since our regular expressions, seems to have it built in, in Char.ofNat.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">uses</span> <span class=\"n\">large</span> <span class=\"n\">eliminator</span><span class=\"o\">:</span> <span class=\"n\">Eq.rec</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Eq.ndrec</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Bool.noConfusion</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Nat.ble_succ_eq_true.match_1</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Nat.ble_succ_eq_true</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Nat.ble_eq_true_of_le</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Nat.not_le_of_not_ble_eq_true</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Nat.decLe</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Nat.decLt</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Char.ofNat.proof_2</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Char.ofNat</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">hp</span>\n</code></pre></div>\n<p>So I think it is also going to be really hard to actually use hott.</p>\n</blockquote>\n<p>Lean’s standard library and many standard tactics (like <code>simp</code>) heavily depend on the large elimination, so yes, HoTT way won’t be a cakewalk.<br>\nHowever, you can <em>try</em> either rewrite all <code>Char</code>-related machinery yourself avoiding large elimination (what is probably not that easy) or mark required machinery as <code>@[hottAxiom]</code> to use it (I don’t think that stuff like <code>Chat.ofNat</code> or <code>Nat.decLt</code> is incompatible with the univalence, so it should be safe to do that, but you need to work <em>very</em> carefully here).</p>",
        "id": 418972936,
        "sender_full_name": "Siegmentation Fault",
        "timestamp": 1706680675
    },
    {
        "content": "<p>Actually we can do both: construct without large elimination (i.e. in the <code>hott</code> environment) term of the same type as the problematic one (like <code>Nat.decLe</code>) as the evidence of its compatibility with the univalence and then mark problematic term as <code>@[hottAxiom]</code>.</p>",
        "id": 418974956,
        "sender_full_name": "Siegmentation Fault",
        "timestamp": 1706681920
    },
    {
        "content": "<p>In fact you could probably introduce an attribute <code>@[hottReplacement foo]</code>, that would check that <code>foo</code> has the same type as the current declaration. Then later invocations of <code>@[hott]</code> could take this into account.</p>",
        "id": 418976511,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1706683012
    },
    {
        "content": "<p>There will be no problems in this approach with <code>Prop</code>’s and (probably) <code>hprop</code>’s, but what to do with the rest?</p>",
        "id": 418977171,
        "sender_full_name": "Siegmentation Fault",
        "timestamp": 1706683463
    },
    {
        "content": "<p>Anyway I tried: <a href=\"https://github.com/forked-from-1kasper/ground_zero/blob/805cee1e60c020ab6c6469be8217943f9a86bfd5/GroundZero/Theorems/Nat.lean#L328-L417\">https://github.com/forked-from-1kasper/ground_zero/blob/805cee1e60c020ab6c6469be8217943f9a86bfd5/GroundZero/Theorems/Nat.lean#L328-L417</a></p>",
        "id": 419016995,
        "sender_full_name": "Siegmentation Fault",
        "timestamp": 1706699439
    },
    {
        "content": "<p>Using <span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> 's technique we found a way to preserve proof relevance, but still use normal equality <code>=</code> and also not require HoTT. So this simplifies things a lot.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">concat</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Lang</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">Lang</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Lang</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"bp\">Σ'</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">×'</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">×'</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">++</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 419627250,
        "sender_full_name": "awalterschulze",
        "timestamp": 1706982332
    },
    {
        "content": "<p>We do still have very few use cases when we need Type Equality:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"s2\">\" ≡ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">TEq</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">emptyStr</span> <span class=\"o\">:</span> <span class=\"n\">Lang</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">w</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">w</span> <span class=\"bp\">≡</span> <span class=\"o\">[]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">char</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">Lang</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">w</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">w</span> <span class=\"bp\">≡</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>We are struggling to decide between two definitions of TEq</p>\n<p>1) Allows us to use <code>rfl</code>, but we cannot use <code>rw</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">TEq.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TEq</span> <span class=\"n\">x</span> <span class=\"n\">x</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">refl</span><span class=\"o\">]</span> <span class=\"n\">TEq.refl</span>\n</code></pre></div>\n<p>Hopefully we are doing something wrong and there is a way to help this definition to work with <code>rw</code>?</p>\n<p>2) Doesn't allow us to use <code>rfl</code>, but allows us to use <code>rw</code> after <code>constructor</code> or <code>cases</code>, which gets annoying, but it useful.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">TEq.</span><span class=\"o\">{</span><span class=\"n\">tu</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">tu</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">tu</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">TEq</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">rewrite_test</span><span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≡</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≡</span> <span class=\"n\">c</span><span class=\"o\">),</span>\n    <span class=\"n\">a</span> <span class=\"bp\">≡</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">ab</span> <span class=\"n\">bc</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">cases</span> <span class=\"n\">ab</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"n\">ab</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ab</span><span class=\"o\">]</span>\n    <span class=\"n\">cases</span> <span class=\"n\">bc</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"n\">bc</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">bc</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 419627632,
        "sender_full_name": "awalterschulze",
        "timestamp": 1706982656
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"557483\">awalterschulze</span> <a href=\"#narrow/stream/270676-lean4/topic/Proof.20relevance/near/419627250\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">concat</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Lang</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">Lang</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Lang</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"bp\">Σ'</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">×'</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">×'</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">++</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I think the <code>×'</code> in there could be <code>\\and</code>s.</p>",
        "id": 419696264,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1707050905
    },
    {
        "content": "<p>Why do you need <code>TEq</code> in the definitions of <code>emptyStr</code> and <code>char</code>?</p>",
        "id": 419696297,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1707050964
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/270676-lean4/topic/Proof.20relevance/near/419696297\">said</a>:</p>\n<blockquote>\n<p>Why do you need <code>TEq</code> in the definitions of <code>emptyStr</code> and <code>char</code>?</p>\n</blockquote>\n<p>I think what might be relevant is the definition of Lang, sorry for not sharing that earlier</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Lang</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n</code></pre></div>\n<p>As far as I understand Lang has to be in Type, because otherwise you can't do pattern matching (proof relevance) on the Sigma parts that are returned by concat.</p>",
        "id": 419698413,
        "sender_full_name": "awalterschulze",
        "timestamp": 1707053060
    },
    {
        "content": "<p>I think an example of what you actually want to do with/prove about <code>concat</code> in the end would be very helpful, this is too vague to really help you</p>",
        "id": 419699001,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1707053598
    },
    {
        "content": "<p>Fair enough, hard to find the balance between sharing too much and too little and TBH I only figured out what I want this week. Sorry for not sharing earlier.</p>\n<p>This is not an exact goal, but it gives an idea. I want to be able to print out the parse tree, which is represented by the proof. <br>\nFor this I need to be able to do cases on the resulting expression to see which paths were contradictions and which were successful.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">example_of_proof_relevant_parse</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">or</span> <span class=\"o\">(</span><span class=\"n\">char</span> <span class=\"sc\">'a'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">char</span> <span class=\"sc\">'b'</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">toList</span> <span class=\"s2\">\"a\"</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span>\n  <span class=\"n\">cases</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"n\">xa</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">cases</span> <span class=\"n\">xa</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"n\">eq</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">cases</span> <span class=\"n\">eq</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">exact</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inr</span> <span class=\"n\">xb</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">cases</span> <span class=\"n\">xb</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"n\">eq</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">contradiction</span>\n</code></pre></div>\n<p>I am still working on a print function.</p>",
        "id": 419699373,
        "sender_full_name": "awalterschulze",
        "timestamp": 1707053924
    },
    {
        "content": "<p>Thanks, it makes more sense now to me. But is your set of operations really open, or do you know all of them beforehand? If it's the latter, you should define them as a standard inductive type, and then parse trees of them as a standard inductive family of types.</p>",
        "id": 419700284,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1707054748
    },
    {
        "content": "<p>Glad it makes sense, phew. I was struggling to quickly write a better function.</p>\n<p>We tried the Inductive Predicate route in Coq a few years ago, but ended up running into the <code>strictly positive limitation</code>, because of the <code>not</code> operator. So we didn't even try it again in Lean ... until now.</p>\n<p>Here is a small reproduction of the issue in Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Regex</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">emptyset</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span>\n  <span class=\"bp\">|</span> <span class=\"n\">not</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"bp\">→</span> <span class=\"n\">Regex</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Lang</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lang_emptyset</span> <span class=\"o\">(</span><span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n    <span class=\"n\">False</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"n\">Lang</span> <span class=\"n\">emptyset</span> <span class=\"n\">str</span>\n  <span class=\"bp\">|</span> <span class=\"n\">not</span> <span class=\"o\">(</span><span class=\"n\">str</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span> <span class=\"n\">Regex</span><span class=\"o\">):</span>\n    <span class=\"o\">((</span><span class=\"n\">Lang</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">str</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"n\">Lang</span> <span class=\"o\">(</span><span class=\"n\">not</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">str</span>\n</code></pre></div>\n<p>In gives the error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">kernel</span><span class=\"o\">)</span> <span class=\"n\">arg</span> <span class=\"bp\">#</span><span class=\"mi\">4</span> <span class=\"n\">of</span> <span class=\"bp\">'</span><span class=\"n\">Lang.not'</span> <span class=\"n\">has</span> <span class=\"n\">a</span> <span class=\"n\">non</span> <span class=\"n\">positive</span> <span class=\"n\">occurrence</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">datatypes</span> <span class=\"n\">being</span> <span class=\"n\">declared</span>\n</code></pre></div>\n<p>Keeping things open solves this strictly positive problem, but also less importantly opens up the operators to be easily extendible by users. For example, there are many variants of the shuffle operator, I know which one I prefer, but I don't know which a user might prefer.</p>\n<p>Another important reason is that we are trying replicate a paper in Agda, so we are trying to stick as closely as possible to the definitions, so we can have a fair comparison between the two languages.</p>",
        "id": 419702213,
        "sender_full_name": "awalterschulze",
        "timestamp": 1707056627
    },
    {
        "content": "<p>Ah, <code>not</code> is an interesting addition but now I'm even more confused about your ultimate goals - what even is a parse tree of <code>not</code>? Essentially that is the question Lean is failing to answer when you give it that definition.</p>\n<blockquote>\n<p>Another important reason is that we are trying replicate a paper in Agda, so we are trying to stick as closely as possible to the definitions, so we can have a fair comparison between the two languages.</p>\n</blockquote>\n<p>Sounds like that paper may be relevant for us to better understand your goal :)</p>",
        "id": 419702784,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1707057164
    },
    {
        "content": "<p>Good points and also now that you mentioned it, that is a very good question and I see now that I got my requirements mixed up.</p>\n<p>I had and have the requirement for the <code>not</code> operator from a previous and future project.<br>\nBut it doesn't seem as though the <code>not</code> operator is present in this Agda reproving project, so I got confused.</p>\n<p>I'll have to do some homework to find out why the Agda paper without the <code>not</code> operator, chose to create an open definition. Here is the paper <a href=\"http://conal.net/papers/language-derivatives/\">http://conal.net/papers/language-derivatives/</a> we are trying to reprove in Lean.</p>",
        "id": 419704002,
        "sender_full_name": "awalterschulze",
        "timestamp": 1707058263
    },
    {
        "content": "<p>Ah, sections 4.2/4.3 with inductive definition of the language vs coinductive definition of parsing is quite nice, though of course the latter is less easily replicated in Lean</p>",
        "id": 419706677,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1707060402
    },
    {
        "content": "<p>Apparently Conal has an idea for how to get around the coinductive part in Lean, but we are aware that this might be a problem in future.</p>",
        "id": 425674174,
        "sender_full_name": "awalterschulze",
        "timestamp": 1709978883
    },
    {
        "content": "<p>In the mean time I tried</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Regex</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">emptyset</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">emptystr</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">char</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">or</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">concat</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">star</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Lang</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lang_emptyset</span> <span class=\"o\">(</span><span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n    <span class=\"n\">False</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"n\">Lang</span> <span class=\"n\">Regex.emptyset</span> <span class=\"n\">str</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lang_emptystr</span><span class=\"o\">:</span>\n    <span class=\"n\">Lang</span> <span class=\"n\">Regex.emptystr</span> <span class=\"o\">([]:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lang_char</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n    <span class=\"n\">Lang</span> <span class=\"o\">(</span><span class=\"n\">Regex.char</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">c</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lang_or</span> <span class=\"o\">(</span><span class=\"n\">str</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r1</span> <span class=\"n\">r2</span><span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n    <span class=\"n\">Lang</span> <span class=\"n\">r1</span> <span class=\"n\">str</span> <span class=\"bp\">⊕</span> <span class=\"n\">Lang</span> <span class=\"n\">r2</span> <span class=\"n\">str</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"n\">Lang</span> <span class=\"o\">(</span><span class=\"n\">Regex.or</span> <span class=\"n\">r1</span> <span class=\"n\">r2</span><span class=\"o\">)</span> <span class=\"n\">str</span>\n</code></pre></div>\n<p>But I get the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">kernel</span><span class=\"o\">)</span> <span class=\"n\">invalid</span> <span class=\"n\">nested</span> <span class=\"kd\">inductive</span> <span class=\"n\">datatype</span> <span class=\"bp\">'</span><span class=\"n\">Sum'</span><span class=\"o\">,</span> <span class=\"n\">nested</span> <span class=\"kd\">inductive</span> <span class=\"n\">datatypes</span> <span class=\"kd\">parameters</span> <span class=\"n\">cannot</span> <span class=\"n\">contain</span> <span class=\"kn\">local</span> <span class=\"kd\">variables</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>This also has the same problem in Prop</p>\n<p>In this case, I am pretty sure I am making a noob mistake</p>",
        "id": 425674566,
        "sender_full_name": "awalterschulze",
        "timestamp": 1709979285
    },
    {
        "content": "<p>This error is to be expected, and there are no easy way to use <code>Sum</code> the way you want to here. This definition is equivalent, altought it might be more bothersome to work with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Regex</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">emptyset</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">emptystr</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">char</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">or</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">concat</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">star</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Lang</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lang_emptyset</span> <span class=\"o\">(</span><span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n    <span class=\"n\">False</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"n\">Lang</span> <span class=\"n\">Regex.emptyset</span> <span class=\"n\">str</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lang_emptystr</span><span class=\"o\">:</span>\n    <span class=\"n\">Lang</span> <span class=\"n\">Regex.emptystr</span> <span class=\"o\">([]:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lang_char</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n    <span class=\"n\">Lang</span> <span class=\"o\">(</span><span class=\"n\">Regex.char</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">c</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lang_or</span> <span class=\"o\">(</span><span class=\"n\">str</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r1</span> <span class=\"n\">r2</span><span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n    <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">r1</span> <span class=\"bp\">⊕'</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">r2</span><span class=\"o\">))</span><span class=\"bp\">→</span>\n    <span class=\"n\">Lang</span> <span class=\"n\">r</span> <span class=\"n\">str</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"n\">Lang</span> <span class=\"o\">(</span><span class=\"n\">Regex.or</span> <span class=\"n\">r1</span> <span class=\"n\">r2</span><span class=\"o\">)</span> <span class=\"n\">str</span>\n</code></pre></div>",
        "id": 425681538,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1709986247
    },
    {
        "content": "<p>As a sidenote, your inductive definition would be accepted in Coq, since they do not check for free variables occurences in nested applications like Lean does. </p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Inductive</span> <span class=\"n\">Regex</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"o\">|</span> <span class=\"n\">regex_or</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Regex</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Regex</span> <span class=\"n\">A</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Inductive</span> <span class=\"n\">Lang</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"n\">list</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"o\">|</span> <span class=\"n\">lang_or</span> <span class=\"o\">{</span><span class=\"n\">str</span> <span class=\"n\">r1</span> <span class=\"n\">r2</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"n\">Lang</span> <span class=\"n\">A</span> <span class=\"n\">r1</span> <span class=\"n\">str</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Lang</span> <span class=\"n\">A</span> <span class=\"n\">r2</span> <span class=\"n\">str</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Lang</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">regex_or</span> <span class=\"o\">_</span> <span class=\"n\">r1</span> <span class=\"n\">r2</span><span class=\"o\">)</span> <span class=\"n\">str</span><span class=\"o\">.</span>\n</code></pre></div>\n<p>Would anyone know what the justification for such a check is ? My intuition tells me that such a check is not useful on \"small\" parameters, since they can arbitrarily be lifted to indices without reducing the logical expressivity of the inductive type.</p>",
        "id": 425681868,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1709986574
    },
    {
        "content": "<p>Another way to make this work would be to manually translate your nested inductive type into a mutual one as such:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Lang</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}:</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lang_emptyset</span> <span class=\"o\">(</span><span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n    <span class=\"n\">False</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"n\">Lang</span> <span class=\"n\">Regex.emptyset</span> <span class=\"n\">str</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lang_emptystr</span><span class=\"o\">:</span>\n    <span class=\"n\">Lang</span> <span class=\"n\">Regex.emptystr</span> <span class=\"o\">([]:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lang_char</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n    <span class=\"n\">Lang</span> <span class=\"o\">(</span><span class=\"n\">Regex.char</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">c</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lang_or</span> <span class=\"o\">(</span><span class=\"n\">str</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r1</span> <span class=\"n\">r2</span><span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n    <span class=\"n\">SumLang</span> <span class=\"n\">r1</span> <span class=\"n\">r2</span> <span class=\"n\">str</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"n\">Lang</span> <span class=\"o\">(</span><span class=\"n\">Regex.or</span> <span class=\"n\">r1</span> <span class=\"n\">r2</span><span class=\"o\">)</span> <span class=\"n\">str</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">SumLang</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"o\">:</span> <span class=\"n\">Lang</span> <span class=\"n\">r1</span> <span class=\"n\">str</span> <span class=\"bp\">→</span> <span class=\"n\">SumLang</span> <span class=\"n\">r1</span> <span class=\"n\">r2</span> <span class=\"n\">str</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inr</span> <span class=\"o\">:</span> <span class=\"n\">Lang</span> <span class=\"n\">r2</span> <span class=\"n\">str</span> <span class=\"bp\">→</span> <span class=\"n\">SumLang</span> <span class=\"n\">r1</span> <span class=\"n\">r2</span> <span class=\"n\">str</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 425682740,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1709987509
    },
    {
        "content": "<p>This one is probably the  simplest </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">r1</span> <span class=\"bp\">⊕'</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">r2</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>But I would also like to know why it was decided to check these free variables, when it isn't done in Coq</p>",
        "id": 425684796,
        "sender_full_name": "awalterschulze",
        "timestamp": 1709989547
    },
    {
        "content": "<p>Just do two rules for <code>or</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Lang</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lang_emptyset</span> <span class=\"o\">(</span><span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n    <span class=\"n\">False</span> <span class=\"bp\">-&gt;</span>\n    <span class=\"n\">Lang</span> <span class=\"n\">Regex.emptyset</span> <span class=\"n\">str</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lang_emptystr</span><span class=\"o\">:</span>\n    <span class=\"n\">Lang</span> <span class=\"n\">Regex.emptystr</span> <span class=\"o\">([]:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lang_char</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n    <span class=\"n\">Lang</span> <span class=\"o\">(</span><span class=\"n\">Regex.char</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">c</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lang_or1</span> <span class=\"o\">(</span><span class=\"n\">str</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r1</span> <span class=\"n\">r2</span><span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n    <span class=\"n\">Lang</span> <span class=\"n\">r1</span> <span class=\"n\">str</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Lang</span> <span class=\"o\">(</span><span class=\"n\">Regex.or</span> <span class=\"n\">r1</span> <span class=\"n\">r2</span><span class=\"o\">)</span> <span class=\"n\">str</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lang_or2</span> <span class=\"o\">(</span><span class=\"n\">str</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r1</span> <span class=\"n\">r2</span><span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n    <span class=\"n\">Lang</span> <span class=\"n\">r2</span> <span class=\"n\">str</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Lang</span> <span class=\"o\">(</span><span class=\"n\">Regex.or</span> <span class=\"n\">r1</span> <span class=\"n\">r2</span><span class=\"o\">)</span> <span class=\"n\">str</span>\n</code></pre></div>",
        "id": 425685074,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1709989744
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"557483\">awalterschulze</span> <a href=\"#narrow/stream/270676-lean4/topic/Proof.20relevance/near/425684796\">said</a>:</p>\n<blockquote>\n<p>This one is probably the  simplest </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">r1</span> <span class=\"bp\">⊕'</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">r2</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>But I would also like to know why it was decided to check these free variables, when it isn't done in Coq</p>\n</blockquote>\n<p>The main reason, as far as I can see, is that to check for nested positivity in the kernel, Lean first converts nested inductive types into equivalent mutual inductive types, similarly to what I've done above with <code>SumLang</code>. The issue seems to be that converting nested inductives with free variables in the nested appeareances is just harder to do, I don't think there is any theoretical reason behind it.</p>",
        "id": 425685876,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1709990454
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"432410\">@Arthur Adjedj</span> <a href=\"#narrow/stream/270676-lean4/topic/Proof.20relevance/near/425681868\">said</a>:</p>\n<blockquote>\n<p>As a sidenote, your inductive definition would be accepted in Coq, since they do not check for free variables occurences in nested applications like Lean does. </p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Inductive</span> <span class=\"n\">Regex</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"o\">|</span> <span class=\"n\">regex_or</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Regex</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Regex</span> <span class=\"n\">A</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Inductive</span> <span class=\"n\">Lang</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Regex</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"n\">list</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"o\">|</span> <span class=\"n\">lang_or</span> <span class=\"o\">{</span><span class=\"n\">str</span> <span class=\"n\">r1</span> <span class=\"n\">r2</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"n\">Lang</span> <span class=\"n\">A</span> <span class=\"n\">r1</span> <span class=\"n\">str</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Lang</span> <span class=\"n\">A</span> <span class=\"n\">r2</span> <span class=\"n\">str</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Lang</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">regex_or</span> <span class=\"o\">_</span> <span class=\"n\">r1</span> <span class=\"n\">r2</span><span class=\"o\">)</span> <span class=\"n\">str</span><span class=\"o\">.</span>\n</code></pre></div>\n<p>Would anyone know what the justification for such a check is ? My intuition tells me that such a check is not useful on \"small\" parameters, since they can arbitrarily be lifted to indices without reducing the logical expressivity of the inductive type.</p>\n</blockquote>\n<p>This doesn't really address the main question, but I want to remark on the polarity of this implication: A justification is required to <em>omit</em> a check. The baseline position is that everything even slightly weird is disallowed because we only want to permit those things we understand and have a reasonable soundness argument for. One does not need a justification for why some variation is disallowed.</p>",
        "id": 425858774,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710146074
    },
    {
        "content": "<p>I totally agree with this, and perhaps I worded my remark wrong. To rephrase my thoughts: the way nested inductive types are currently checked in the kernel is that nested inductives are translated into mutual ones before checking for strict positivity, universe sizes, generating recursors… The current implementation of the nested =&gt; mutual preprocessor does not handle free variables in parameters of nested appearances, and I am now fairly confident its algorithm could be extended to support that. Indeed, any local variables appearing in parameters  of a nested appearance could be translated into indices of the translated mutual type. Such a preprocessor would be fairly more complex than the current one, but wouldn't endanger the soundness of the kernel in any way, since the fundamental checks would still be performed on the mutual translation.</p>",
        "id": 425863790,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1710147662
    },
    {
        "content": "<p>Could you do a worked example? I'm still not sure how you are generalizing the variables</p>",
        "id": 425875735,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710151963
    },
    {
        "content": "<p>I think it also runs into issues identifying when you have generated the type already</p>",
        "id": 425875872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710152039
    },
    {
        "content": "<p>The translation made earlier in the thread where <code>SumLang</code> appears in such an example, though I plan on making a more detailed explanation of this process when I have time to do so. I am also already working on such an implementation for my own curiosity, and hope to have something working in the following weeks, even if this was to never be merged. I can get back to you later today with more details.</p>",
        "id": 425877721,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1710152764
    },
    {
        "content": "<p>What would you do if it was <code>Sum (Lang r1 \"a\") (Lang r2 str)</code>? And if it shows up twice or with variations would it count as a new mutual inductive or not?</p>",
        "id": 425878229,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710152930
    },
    {
        "content": "<p>Since the kernel already handles such cases where the indices may vary in the nesting (i.e writing <code>Lang .emptystr \"a\" ⊕ Lang .emptystr \"b\"</code> already works), I don't think handling such things would be a problem.</p>\n<p>As for checking variations of the inductive, it is true that the kernel checks if the mutual equivalent of the nested appearance has already been created so at to not duplicate those. I believe a safe, altough expensive way to make sure all needed variations are made without overlaps would be to either not check for duplicates, and always create a new inductive in the mutual block when encountering a nested appearance, or to add a notion of equivalence between inductive types in the kernel, where two inductives would be equivalent iff they have the same type signatures, same constructor names, and same constructor types, all modulo alpha-equivalence.</p>",
        "id": 425885751,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1710155498
    },
    {
        "content": "<p>Again, I am short on time now, but should be able to give a more detailed presentation of my idea later today.</p>",
        "id": 425885933,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1710155562
    },
    {
        "content": "<p>Consider an inductive type <code>Foo Ps Is</code> with parameters <code>Ps</code>and indices <code>Is</code> and a constructor <code>foo</code> which type contains a term of the form <code>I As Bs</code>, where <code>I</code> is a previously defined inductive type, <code>As</code> are parameters of <code>I</code>, and <code>Bs</code> indices of I, such that <code>Foo Ps</code> occurs in <code>As</code>.</p>\n<p>Currently, the kernel creates an auxiliary inductive type <code>I_aux</code>, with parameters <code>Ps</code> and with the same indices as <code>I</code>, for which the type signature, (resp. the types of its constructors) is the type signature of <code>I</code> in which its original parameters are replaced with <code>As</code>. However, if <code>As</code> was to contain local variables (read: free variables that aren't parameters <code>Ps</code>), this would lead to an ill-formed and ill-typed auxiliary inductive. Thus, a good solution would be to collect the local variables in <code>As</code>, and to prepend the indices of <code>I_aux</code> with types corresponding to those variables.<br>\nIn practice, the following changes need to be made:</p>\n<ul>\n<li>In <a href=\"https://github.com/leanprover/lean4/blob/1388f6bc83b5ea085fe14faa1db213e745c3e398/src/kernel/inductive.cpp#L916\"><code>is_nested_inductive_app</code></a>, return not only the inductive val, but also the loose bvars collected in the parameters of the term.</li>\n<li>\n<p>In <a href=\"https://github.com/leanprover/lean4/blob/1388f6bc83b5ea085fe14faa1db213e745c3e398/src/kernel/inductive.cpp#L959\"><code>replace_if_nested</code></a>, add a parameter to the function, that being a buffer of the types of variables encountered during the traversal of the constructor, prepend <a href=\"https://github.com/leanprover/lean4/blob/1388f6bc83b5ea085fe14faa1db213e745c3e398/src/kernel/inductive.cpp#L1000\"><code>auxJ_type</code></a><br>\n  and each <a href=\"https://github.com/leanprover/lean4/blob/1388f6bc83b5ea085fe14faa1db213e745c3e398/src/kernel/inductive.cpp#L1015\"><code>auxJ_cnstr_type</code></a> with the types associated with the loose bvars</p>\n</li>\n<li>\n<p>Modify <a href=\"https://github.com/leanprover/lean4/blob/1388f6bc83b5ea085fe14faa1db213e745c3e398/src/kernel/inductive.cpp#L1027\"><code>replace_all_nested</code></a> to store the types of variables encountered during the traversal, and to give those to <a href=\"https://github.com/leanprover/lean4/blob/1388f6bc83b5ea085fe14faa1db213e745c3e398/src/kernel/inductive.cpp#L959\"><code>replace_if_nested</code></a></p>\n</li>\n</ul>\n<p>Furthermore, regarding your remark for duplications, I believe storing not only the parameters, but also the indices of nested occurences in <a href=\"https://github.com/leanprover/lean4/blob/1388f6bc83b5ea085fe14faa1db213e745c3e398/src/kernel/inductive.cpp#L884\"><code>m_nested_aux</code></a>, and adapting the check in <a href=\"https://github.com/leanprover/lean4/blob/1388f6bc83b5ea085fe14faa1db213e745c3e398/src/kernel/inductive.cpp#L980\"><code>replace_if_nested</code></a> accordingly would be enough to ensure the same behaviour than the current one in that regard.</p>\n<p>As for restoring the nested results back from the mutual ones, I believe there should be little work to do on that part, if all goes well.</p>",
        "id": 425981429,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1710180503
    },
    {
        "content": "<p>We got it working: <a href=\"https://github.com/katydid/symbolic-automatic-derivatives\">https://github.com/katydid/symbolic-automatic-derivatives</a></p>\n<p>I just want to thank everyone for their help and say sorry for disappearing.<br>\nIt is tough to find time to have fun in Lean in between work, etc.</p>\n<p>I say working, but we still have one big problem. We are using <code>unsafe</code>, to get around the coinduction issue and would like to find another solution, but this is probably a discussion for <a href=\"#narrow/stream/270676-lean4/topic/how.20to.20hack.20around.20the.20lack.20of.20coinduction\">a new thread</a>. The rest is trivial, just a few small proofs, that we probably know how to do, but just need to find the time to complete.</p>\n<p>All the type definitions are otherwise working. Thank you for all your help</p>",
        "id": 465848281,
        "sender_full_name": "awalterschulze",
        "timestamp": 1724878488
    }
]