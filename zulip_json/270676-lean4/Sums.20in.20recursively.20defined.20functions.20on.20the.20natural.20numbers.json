[
    {
        "content": "<p>I am trying to understand the faculties and limitations of Lean in defining functions on the natural numbers recursively. Is it possible to sum over values of all smaller arguments in defining the function?</p>\n<p>Here are some naive attempts with a toy example as an MWE. They yield an error \"fail to show termination\".</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Ring</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">BigOperators</span><span class=\"bp\">.</span><span class=\"n\">Fin</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span>\n\n<span class=\"c1\">--does not work - Lean4 cannot establish termination of recursion ahead.</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">frec1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\">   </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">frec1</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">frec1</span><span class=\"w\"> </span><span class=\"mi\">5</span>\n\n<span class=\"c1\">--does not work - Lean4 cannot establish termination of recursion ahead.</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">frec2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\">   </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">frec2</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">frec2</span><span class=\"w\"> </span><span class=\"mi\">5</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">frec3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\">   </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">frec3</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">frec3</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"c1\">--work around: first frec3 n means ∑ᵢ&lt;ₙ (frec3 i) and second frec3 n stands for itself.</span>\n<span class=\"c1\">--this requires some rewriting on the part of the user, unsatisfactory.</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">frec3</span><span class=\"w\"> </span><span class=\"mi\">5</span>\n</code></pre></div>\n<p>Does anyone know how to achieve this without resorting to work arounds as indicated above?</p>\n<p>Remark: I have Lean 4.5 installed, which might be outdated and the libraries might have changed names.</p>",
        "id": 533644849,
        "sender_full_name": "Thomas Preu",
        "timestamp": 1754824727
    },
    {
        "content": "<p>You can use:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">frec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">frec</span><span class=\"w\"> </span><span class=\"n\">i</span>\n</code></pre></div>",
        "id": 533645390,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754825382
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"680252\">@Thomas Preu</span> this is because when you have <code>i in Finset.range (Nat.succ n)</code>, in the context of the application <code>frec1 i</code>, Lean only knows that <code>i</code> is a natural number</p>",
        "id": 533645556,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754825577
    },
    {
        "content": "<p>summing over Fin n as instructed above allows you to carry the proof of i &lt; n</p>",
        "id": 533645576,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754825590
    },
    {
        "content": "<p>Finset.range (Nat.succ n) returns a term of Finset (Nat), and the summation syntax sums over a function on Nat when you have Finset Nat</p>",
        "id": 533645599,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754825622
    },
    {
        "content": "<p>Thanks for the help and the explanation, now it works.</p>",
        "id": 533652134,
        "sender_full_name": "Thomas Preu",
        "timestamp": 1754832730
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> Interestingly enough the standalone sum does not work like this.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- works</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"c1\">-- yields error \"failed to synthesize AddCommMonoid (Fin 5)\"</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span>\n</code></pre></div>\n<p>Do you have an explanation for that?</p>",
        "id": 533652752,
        "sender_full_name": "Thomas Preu",
        "timestamp": 1754833472
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"680252\">@Thomas Preu</span> if you just type <code>i</code> it interprets it as a term of <code>Fin 5</code>, which has no addition defined</p>",
        "id": 533652796,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754833508
    },
    {
        "content": "<p>but in the code above <code>frec</code> forces it to be coerced to <code>Nat</code></p>",
        "id": 533652811,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754833519
    },
    {
        "content": "<p>Now it works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 533653164,
        "sender_full_name": "Thomas Preu",
        "timestamp": 1754833895
    },
    {
        "content": "<p>lean tip: basically don't ever type the uparrow, it only confuses you</p>",
        "id": 533653179,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754833919
    },
    {
        "content": "<p>OK, so this works better:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 533653300,
        "sender_full_name": "Thomas Preu",
        "timestamp": 1754834042
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/270676-lean4/topic/Sums.20in.20recursively.20defined.20functions.20on.20the.20natural.20numbers/near/533653179\">said</a>:</p>\n<blockquote>\n<p>lean tip: basically don't ever type the uparrow, it only confuses you</p>\n</blockquote>\n<p>I don't agree with this tip - sometimes you need to specify exactly where the coercion goes, e.g. <code>(&lt;arrow&gt;(a+b) : Int)</code></p>",
        "id": 533656106,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1754836925
    },
    {
        "content": "<p>but that isn't simp NF</p>",
        "id": 533656151,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754836979
    },
    {
        "content": "<p>i think it's better to drill into people the idea that the simp NF is ↑a + ↑b not ↑(a+b)</p>",
        "id": 533656178,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754837002
    },
    {
        "content": "<p>I don't see how your comment is relevant</p>",
        "id": 533656401,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1754837232
    },
    {
        "content": "<p>if we tell people that the idiomatic way is (term : expected type), then they will type (a + b : Int) and see  ↑a + ↑b, which is the correct simpNF</p>",
        "id": 533656438,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754837268
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/stream/270676-lean4/topic/Sums.20in.20recursively.20defined.20functions.20on.20the.20natural.20numbers/near/533656438\">said</a>:</p>\n<blockquote>\n<p>if we tell people that the idiomatic way is (term : expected type), then they will type (a + b : Int) and see  ↑a + ↑b, which is the correct simpNF</p>\n</blockquote>\n<p>In general, is this considered the preferred way for users to discover simp normal forms? Is there documentation that recommends this?</p>",
        "id": 533662590,
        "sender_full_name": "Chris Henson",
        "timestamp": 1754844371
    },
    {
        "content": "<p>well all of the map_add lemmas look like f(a+b) = f a + f b</p>",
        "id": 533662673,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754844453
    },
    {
        "content": "<p>What I, as a beginner, take from this:</p>\n<ol>\n<li>The ↑ specifies the exact subterm that is supposed to be coerced.</li>\n<li>Lean output features them by default if coercions occur.</li>\n<li>Usually when coercions are not automatically inferred by Lean, type annotation like <code>(... : type)</code> is sufficient, ↑ is not necessary, ↑ is considered obfuscating to human readers and should therefore be omitted.</li>\n<li>Sometimes however, type annotation is not enough and then an additional ↑ clarifies the place of coercion.</li>\n</ol>\n<p>Did I get this right from your discussion? Did I miss something?</p>",
        "id": 533934798,
        "sender_full_name": "Thomas Preu",
        "timestamp": 1754988530
    },
    {
        "content": "<p>that's what i think anyway</p>",
        "id": 533935689,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754988869
    },
    {
        "content": "<p>One more thing - the default coercion is \"no coercion\", so if you don't specify what to coerce to then even if you put a <code>↑</code> if you haven't disallowed \"no coercion\" as an option then that's what will happen.</p>",
        "id": 533952300,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754995073
    },
    {
        "content": "<p>I prefer something like <code>((a + b : Nat) : Int)</code> for this kind of coercion -- it's a bit clearer and the elaborator can't really do anything wrong</p>",
        "id": 536277303,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1756226732
    }
]