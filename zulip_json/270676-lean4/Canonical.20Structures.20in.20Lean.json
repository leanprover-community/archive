[
    {
        "content": "<p>Hi, I am currently working in project of translation to Lean where I need to define a class Type’ and several instances of such, a minimal example of what I am doing would be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">el</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">type</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeSort</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">type</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">nat'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">el</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">bool'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">el</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>I am using coercion soLean identifies any A:Type’ as a A.Type when A is used as type, e.g, <code>x:A</code>  or <code>A -&gt; A</code>.</p>\n<p>Now what I need is these instances to acts as “canonical” in the sense that the following function type checks no matter the instance when applied to in this case <code>true</code> or <code>Nat.zero</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">TEST</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>However, this only works for the last instance defined in the code, that is, <code>#check TEST true</code> is correct while <code>#check TEST Nat.zero</code> is not. Is there a way to force Lean to look for the suited instance given the type param? (this one is inferred from <code>x</code> and using <code>CoeSort</code>) For instance, Rocq achieves this using the <a href=\"https://rocq-prover.org/doc/V9.1.0/refman/language/extensions/canonical.html\">canonical structure mechanism</a>.</p>",
        "id": 569446159,
        "sender_full_name": "Ivan Martinez Comas",
        "timestamp": 1769075188
    },
    {
        "content": "<p>You <em>could</em> make <code>Type'</code> a structure and setup unification hints like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">unif_hint</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">nat'</span><span class=\"w\"> </span><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"kn\">unif_hint</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">bool'</span><span class=\"w\"> </span><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n</code></pre></div>\n<p>but maybe the question is: why not</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">el</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">type</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">nat'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">el</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">bool'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">el</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">TEST</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>",
        "id": 569464452,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1769081015
    },
    {
        "content": "<p>Oh thanks! The first approach is what i was looking for. I will look into the other one as well but I think it does not match my purposes. Thanks!</p>",
        "id": 569481478,
        "sender_full_name": "Ivan Martinez Comas",
        "timestamp": 1769086287
    },
    {
        "content": "<p>I think that this confusion might actually come from a difference between the bundling philosphy behind canonical structures and behind mathlib class inference system. If you compare MathComp's way of saying that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> is a group, namely</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Canonical</span><span class=\"w\"> </span><span class=\"n\">int_ZmodType</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ZmodType</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"n\">intZmod</span><span class=\"bp\">.</span><span class=\"n\">Mixin</span>\n</code></pre></div>\n<p>with Mathlib's <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Group/Int/Defs.html#Int.instAddCommGroup\">Int.instAddCommGroup</a> you see that </p>\n<ol>\n<li>Rocq / MathComp approach is to say \"<code>int</code> gives rise to a record of the form<code>ZmodType</code> (which is defined as a record via <code>Definition zmodType := Zmodule.Pack class.</code>, see Chap 8.3 of Mahboubi-Tassi's book), namely <code>intZmod.Mixin</code>: so, now, when <code>Rocq</code> needs (say) addition on <code>int</code> it can try to see whether there exists a mixin of the form <code>ZmodType</code> containing <code>int</code> as a field, and this is precisely the record <code>int_ZmodType</code>.  In this view, <code>ZmodType</code> is a \"pattern\" of records, each containing a type, an addition, etc... In particular, one can define <em>two</em> terms in <code>ZmodType</code>, each with a different underlying type. What is \"Canonical\" is then the choice of <em>a</em> record whose underlying type would be, say, <code>int</code>. </li>\n<li>Lean takes a different approach, and says that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddCommGroup#doc\">docs#AddCommGroup</a> has a <code>G : Type*</code> parameter, but then <code>AddCommGroup G</code> consists of all add-comm-group structures on <code>G</code> and declaring an instance of <code>AddCommGroup</code> does not make any sense, you can only define an instace of a <code>AddCommGroup ℤ</code>, which will be \"the unique add comm group structure on the integers\".</li>\n</ol>\n<p>To my eyes, writing <code>class Type' where...</code> is very much <code>Rocq</code>-idiomatic but not <code>Lean</code>idiomatic. In particular, writing <code>instance nat ' : Type'</code> basically declares that the <em>only</em> preferred term in <code>Type'</code> is <code>nat'</code>, and when on the second line you type <code>instance bool' : Type' </code> you replace this prefered term in <code>Type'</code> with the new one (hence killing the previous one). Indeed, if you compare</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">el</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeSort</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">type</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">TEST</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">nat'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">el</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">}</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">bool'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">el</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">TEST</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">TEST</span><span class=\"w\"> </span><span class=\"n\">true</span>\n</code></pre></div>\n<p>with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">el</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeSort</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">type</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">TEST</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">bool'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">el</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">}</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">nat'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">el</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">TEST</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">TEST</span><span class=\"w\"> </span><span class=\"n\">true</span>\n</code></pre></div>\n<p>(where I've swapped the instances), you see that what fails in both cases is the first instance, since it was forgotten by the second. </p>\n<p>The usual Mathlib/Lean approach is to avoid bundling the type inside the structure, and this is exactly what <span class=\"user-mention\" data-user-id=\"873547\">@Robin Arnez</span> is suggesting with the second option <code>class Type' (type : Type)</code>: in that case, you would construct two different instances, one for <code>Type' Bool</code> and one for <code>Type' Nat</code>, that would not conflict with each other.</p>",
        "id": 569503697,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1769092085
    },
    {
        "content": "<p>Hi, thaks for the explanation. I had more experience in Rocq and I was looking for something alike but after some testing and learning of Lean's type classes I realized that indeed, this second approach works much better, thanks!</p>",
        "id": 571646074,
        "sender_full_name": "Ivan Martinez Comas",
        "timestamp": 1770121353
    }
]