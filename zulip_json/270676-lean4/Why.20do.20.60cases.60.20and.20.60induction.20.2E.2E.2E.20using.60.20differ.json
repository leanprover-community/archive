[
    {
        "content": "<p>e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">ex_cases_or</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hpp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">hpp</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">assumption</span>\n<span class=\"k\">#print</span><span class=\"w\"> </span><span class=\"n\">ex_cases_or</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">ex_induction_or</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hpp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">hpp</span><span class=\"w\"> </span><span class=\"n\">using</span><span class=\"w\"> </span><span class=\"n\">Or.casesOn</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">assumption</span>\n<span class=\"k\">#print</span><span class=\"w\"> </span><span class=\"n\">ex_induction_or</span>\n</code></pre></div>\n<p>In this case, the expressions are</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">ex_cases_or</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">hpp</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Or.casesOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">hpp</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hpp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">h_1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">h_1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Eq.refl</span><span class=\"w\"> </span><span class=\"n\">hpp</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">ex_induction_or</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">hpp</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Or.casesOn</span><span class=\"w\"> </span><span class=\"n\">hpp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>In <code>Lean/Meta/Tactic/Cases.lean</code>, <code>cases</code> calls <code>induction</code> in its implementation, so why does it behave differently?</p>",
        "id": 506580613,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1742331854
    },
    {
        "content": "<p>The situation is that they both use the same underlying framework, which happens to use \"induction\" in the name, but both <code>cases</code> and <code>induction</code> are different frontends to this backend.</p>\n<p>They both use the same underlying framework, but <code>cases</code> can handle indexed inductive types where the indices aren't variables. It basically does <code>generalize</code> on all the indices for you automatically. I'm not sure why this restriction is in place exactly. Maybe it's because otherwise the inductive hypotheses will have all these additional equality hypotheses? Or maybe it could be done but <code>induction</code> would need to work out which of these generalized variables should be added to the <code>generalizing</code> clause, and that hasn't been done yet?</p>\n<p>It looks like the difference in your examples is from <code>cases</code> not being efficient with its generalizations.</p>",
        "id": 506586954,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742334408
    },
    {
        "content": "<p>On a related note, is there any way to make <code>induction</code> do the generalization?</p>",
        "id": 506596225,
        "sender_full_name": "Jad Ghalayini",
        "timestamp": 1742338678
    },
    {
        "content": "<p>Unfortunately no, you have to <code>generalize</code> manually.</p>",
        "id": 506598089,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742339568
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Why.20do.20.60cases.60.20and.20.60induction.20.2E.2E.2E.20using.60.20differ/near/506586954\">said</a>:</p>\n<blockquote>\n<p>The situation is that they both use the same underlying framework, which happens to use \"induction\" in the name, but both <code>cases</code> and <code>induction</code> are different frontends to this backend.</p>\n<p>They both use the same underlying framework, but <code>cases</code> can handle indexed inductive types where the indices aren't variables. It basically does <code>generalize</code> on all the indices for you automatically. I'm not sure why this restriction is in place exactly. Maybe it's because otherwise the inductive hypotheses will have all these additional equality hypotheses? Or maybe it could be done but <code>induction</code> would need to work out which of these generalized variables should be added to the <code>generalizing</code> clause, and that hasn't been done yet?</p>\n<p>It looks like the difference in your examples is from <code>cases</code> not being efficient with its generalizations.</p>\n</blockquote>\n<p>Does this mean any instance of <code>cases</code> can be replaced by <code>induction</code>?</p>",
        "id": 506656499,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1742370901
    },
    {
        "content": "<p>Can you expand on what you mean? Because what I was saying is that <code>cases</code> has an additional feature that <code>induction</code> doesn't have, so you can't replace the token <code>cases</code> with <code>induction</code> and expect it to work.</p>",
        "id": 506760303,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742398049
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Why.20do.20.60cases.60.20and.20.60induction.20.2E.2E.2E.20using.60.20differ/near/506760303\">said</a>:</p>\n<blockquote>\n<p>Can you expand on what you mean? Because what I was saying is that <code>cases</code> has an additional feature that <code>induction</code> doesn't have, so you can't replace the token <code>cases</code> with <code>induction</code> and expect it to work.</p>\n</blockquote>\n<p>Is it possible to replace every single instance of <code>cases</code> with <code>induction</code> combined with <code>revert</code> or <code>generalize</code>?</p>",
        "id": 506856677,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1742433057
    },
    {
        "content": "<p>Seems plausible. You might often need <code>rename_i</code> as well.</p>",
        "id": 507050856,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742496269
    }
]