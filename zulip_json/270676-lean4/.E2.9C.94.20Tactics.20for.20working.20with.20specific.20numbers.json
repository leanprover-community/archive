[
    {
        "content": "<p>I have been running into some trouble working with straightforward results that have to do with specific instances of numbers.  These results are easy to obtain with #eval, but I’ve had trouble obtaining them in a proof environment.  I understand that this is part of the fundamental nature of theorem proving, but I’d like to know if there is a general way of dealing with this type of issue, or if it is really a case by case situation.</p>\n<p>Two example that I’ve encountered are the following.  One is finding the factors of 36.  I can define the finset of factors, and I can define the prime factorization in two ways using the definitions in Mathlib.Data.Nat.Factorization.Basic and Mathlib.Data.Nat.Factors, but I have trouble proving basic results such as </p>\n<p>Nat.divisors 36 = {1, 2, 3, 4, 6, 9, 12, 18, 36}</p>\n<p>I understand that you can prove this with the prime factorization, but neither library seems to have appropriate lemmas, and I have also checked the results in Mathlib.Data.Nat.Prime, Mathlib.Data.Nat.Factorization.PrimePow, Mathlib.NumberTheory.Divisors, Mathlib.RingTheory.UniqueFactorizationDomain</p>\n<p>An even more basic example is the following, which can also clearly be evaluated with #eval</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Int.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Order.Floor</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">soln</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_soln</span> <span class=\"o\">:</span> <span class=\"n\">soln</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">520</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">+</span><span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sol_fract</span> <span class=\"o\">:</span> <span class=\"n\">Int.fract</span> <span class=\"n\">soln</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n <span class=\"n\">unfold</span> <span class=\"n\">Int.fract</span>\n <span class=\"k\">have</span> <span class=\"n\">temp</span> <span class=\"o\">:</span> <span class=\"bp\">⌊</span><span class=\"n\">sol_ex</span><span class=\"bp\">⌋</span> <span class=\"bp\">=</span> <span class=\"mi\">520</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n <span class=\"n\">norm_num</span>\n <span class=\"n\">simp</span>\n <span class=\"gr\">sorry</span>\n <span class=\"n\">norm_num</span>\n <span class=\"n\">simp</span>\n <span class=\"n\">linarith</span>\n <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This contains a few, but not all,, of the tactics I tried here. My question is not how to solve this particular problem, or even both, but whether there is a general strategy for cases of particular examples of numbers. Help in solving these particular examples, however, would help me understand the larger goal though.</p>",
        "id": 395447440,
        "sender_full_name": "Teddy Baker",
        "timestamp": 1696706488
    },
    {
        "content": "<p><code>norm_num</code> is the correct tactic, yeah</p>",
        "id": 395448443,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1696707392
    },
    {
        "content": "<p>I thought I'd seen something relevant recently, but it was probably <a href=\"https://github.com/leanprover-community/mathlib4/pull/7089\">#7089</a></p>",
        "id": 395448837,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1696707623
    },
    {
        "content": "<p>Does <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.fract_ofNat_add#doc\">docs#Int.fract_ofNat_add</a> apply?</p>",
        "id": 395449103,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1696707806
    },
    {
        "content": "<p>It doesn't help that you seem to use both <code>soln</code> and <code>sol_x</code> for the same thing</p>",
        "id": 395449655,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1696708142
    },
    {
        "content": "<p>(This is an autoImplicit bug, if we're tracking them)</p>",
        "id": 395449679,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1696708176
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Int.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Order.Floor</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">soln</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_soln</span> <span class=\"o\">:</span> <span class=\"n\">soln</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">520</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">+</span><span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sol_fract</span> <span class=\"o\">:</span> <span class=\"n\">Int.fract</span> <span class=\"n\">soln</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h_soln</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Int.fract_ofNat_add</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"n\">Int.fract_eq_self.mpr</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">norm_num</span>\n  <span class=\"n\">done</span>\n</code></pre></div>",
        "id": 395450126,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1696708602
    },
    {
        "content": "<p>You're right, Int.fract_ofNat_add works, thanks!  How about for the factorization of 36?  The code for that would be </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Int.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Order.Floor</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.NumberTheory.Divisors</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"n\">soln_set</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">6</span><span class=\"o\">,</span> <span class=\"mi\">9</span><span class=\"o\">,</span> <span class=\"mi\">12</span><span class=\"o\">,</span> <span class=\"mi\">18</span><span class=\"o\">,</span> <span class=\"mi\">36</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">div_36</span> <span class=\"o\">:</span> <span class=\"n\">Nat.divisors</span> <span class=\"mi\">36</span> <span class=\"bp\">=</span> <span class=\"n\">soln_set</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Finset.ext_iff.mpr</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Iff.intro</span>\n  <span class=\"n\">intro</span> <span class=\"n\">ha</span>\n  <span class=\"n\">replace</span> <span class=\"n\">ha</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.mem_divisors.mp</span> <span class=\"n\">ha</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 395454563,
        "sender_full_name": "Teddy Baker",
        "timestamp": 1696712618
    },
    {
        "content": "<p>By brute force:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">div_36</span> <span class=\"o\">:</span> <span class=\"n\">Nat.divisors</span> <span class=\"mi\">36</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">6</span><span class=\"o\">,</span> <span class=\"mi\">9</span><span class=\"o\">,</span> <span class=\"mi\">12</span><span class=\"o\">,</span> <span class=\"mi\">18</span><span class=\"o\">,</span> <span class=\"mi\">36</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Finset.ext_iff.mpr</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Nat.mem_divisors</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_singleton</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_insert</span><span class=\"o\">,</span> <span class=\"n\">and_true</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Iff.intro</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hadvd</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.le_of_dvd</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">)</span> <span class=\"n\">hadvd</span>\n    <span class=\"n\">interval_cases</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">norm_num</span> <span class=\"n\">at</span> <span class=\"n\">hadvd</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">norm_num</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>though this, also, I'd expect to be in scope for <code>norm_num</code> on its own</p>",
        "id": 395457718,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1696716039
    },
    {
        "content": "<p>This is really useful, thanks!  I have to learn more about some of the tactics you used here.  Also, I think this basically answers my more general question, which is that there is no really general strategy for obtaining properties of numbers that can be evaluated with #eval, you have to directly prove those properties.   It is a bit of a change of mindset, but I can get used to it!  Thanks again.</p>",
        "id": 395476597,
        "sender_full_name": "Teddy Baker",
        "timestamp": 1696731025
    },
    {
        "content": "<p>Right, #eval is allowed to use functions which aren't verified by lean's kernel. If you want a proof you have to work harder.</p>",
        "id": 395503554,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696750470
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"648334\">@Teddy Baker</span>, I think the previous answers omitted to say this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.NumberTheory.Divisors</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Sort</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">div_36</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Nat.divisors</span> <span class=\"mi\">36</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sort</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">≤</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">6</span><span class=\"o\">,</span> <span class=\"mi\">9</span><span class=\"o\">,</span> <span class=\"mi\">12</span><span class=\"o\">,</span> <span class=\"mi\">18</span><span class=\"o\">,</span> <span class=\"mi\">36</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 395512455,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1696755680
    },
    {
        "content": "<p>Now, proofs by <code>rfl</code> often scale badly, but they do often work!</p>",
        "id": 395512508,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1696755723
    },
    {
        "content": "<p>That is very elegant, thanks so much!  It looks like you don't even need the sort, this even seems to work</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Int.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.NumberTheory.Divisors</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Basic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">div_36</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Nat.divisors</span> <span class=\"mi\">36</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">6</span><span class=\"o\">,</span> <span class=\"mi\">9</span><span class=\"o\">,</span> <span class=\"mi\">12</span><span class=\"o\">,</span> <span class=\"mi\">18</span><span class=\"o\">,</span> <span class=\"mi\">36</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I didn't realize that the rfl tactic could be so useful in this situation.  It's good to know that it doesn't scale well, but for small examples like this it will be sufficient!</p>",
        "id": 395844063,
        "sender_full_name": "Teddy Baker",
        "timestamp": 1696930729
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648334\">Teddy Baker</span> has marked this topic as resolved.</p>",
        "id": 395844133,
        "sender_full_name": "Notification Bot",
        "timestamp": 1696930756
    }
]