[
    {
        "content": "<p>Until stumbling upon this unexpected behaviour</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Int.negSucc_not_nonneg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n<span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Int.negSucc_not_nonneg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- is OK</span>\n</code></pre></div>\n<p>I was convinced that <code>exact</code> was really not doing much. Then I tried to look inside its definition in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Tactic.evalExact#doc\">docs#Lean.Elab.Tactic.evalExact</a> and I cannot understand what, in that definition, is responsible for the behaviour in the example above.</p>",
        "id": 471553894,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1726775542
    },
    {
        "content": "<p>Could it be the <code>EnsuringType</code> kicking in?</p>",
        "id": 471554478,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1726775861
    },
    {
        "content": "<p>On line 76, you mean?</p>",
        "id": 471554591,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1726775912
    },
    {
        "content": "<p>Indeed (I'm on mobile, sorry for being cryptic).</p>",
        "id": 471554681,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1726775959
    },
    {
        "content": "<p>I think that there you pass extra information to Lean.</p>",
        "id": 471554707,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1726775973
    },
    {
        "content": "<p>also <code>by</code> delays elaboration</p>",
        "id": 471554740,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726775991
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 471554832,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1726776013
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/270676-lean4/topic/Implementation.20of.20exact/near/471554681\">said</a>:</p>\n<blockquote>\n<p>Indeed (I'm on mobile, sorry for being cryptic).</p>\n</blockquote>\n<p>But then why does it succeed in the second call? After </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">negSucc_not_nonneg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span>\n</code></pre></div>\n<p>is expects a term of the same type.</p>",
        "id": 471554867,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1726776026
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Implementation.20of.20exact/near/471554740\">said</a>:</p>\n<blockquote>\n<p>also <code>by</code> delays elaboration</p>\n</blockquote>\n<p>Can you expand a bit on this?</p>",
        "id": 471554894,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1726776037
    },
    {
        "content": "<p>I think that there are a few things at play that end up having similar effects.  I hope that if I say something wrong, someone will correct me!</p>\n<p>When you write a proof (especially in tactic mode), you often leave work to lean to do to figure out what lots of implicit terms are.  The two mechanism for addressing incomplete information that are at play here are</p>\n<ul>\n<li>using information from the goal to squeeze out some more information,</li>\n<li>wait out until some other missing terms have been figured out and use that information to fill in more blanks.</li>\n</ul>\n<p>The former is what <code>exact</code> does (possibly with the <code>EnsuringType</code>).</p>\n<p>The latter is probably what Mario is referring to: when Lean sees <code>by</code> it decides to try harder to figure out the rest, before coming back to this specific hole.</p>\n<p><code>apply</code> creates a new metavariable.  In this context it probably means that it decides to delay figuring out what the hole is until you give it more information after <code>apply</code> is done.</p>\n<p>Often, information is redundant enough that these three methods work interchangeably.  Sometimes, the information is involved enough that some of these methods work, while others do not.</p>",
        "id": 471558880,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1726777842
    },
    {
        "content": "<p>I honestly do not know the details of what is going on here, but I'm guessing that some combination of the above plays a role!  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 471558998,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1726777893
    },
    {
        "content": "<p>Thanks! What you say agrees (about <code>exact</code> and <code>apply</code>, I had no idea that <code>by</code> really do have some effect) with my rough picture. But if someone is willing to fill in more details I'd be happy to read them! <span aria-label=\"nerd\" class=\"emoji emoji-1f913\" role=\"img\" title=\"nerd\">:nerd:</span></p>",
        "id": 471559365,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1726778030
    },
    {
        "content": "<p>I believe the issue here is the expression <code>(0 + 0).succ</code>. Lean doesn't know what function <code>.succ</code> is referring to, because it doesn't know the type of <code>0 + 0</code>, because it's waiting for the type of <code>0</code> to be resolved. It will be default-resolved to <code>Nat</code>, but this is supposed to happen \"last\", and in particular it tries to resolve the application involving <code>h</code> before type defaulting. But because the whole expression <code>(0+0).succ</code> is stuck, all it knows is that the type of <code>(Int.negSucc_not_nonneg ?).mp</code> is <code>0 ≤ Int.negSucc ? → False</code> so applying that to <code>h</code> means solving <code>0 &lt; -1 =?= 0 ≤ Int.negSucc ?</code>, which is wrong on a few levels.</p>",
        "id": 471560641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726778607
    },
    {
        "content": "<p>note that even the version that works is pretty sus, you have <code>h : 0 &lt; -1</code> and the function is expecting a proof of <code>0 &lt;= -2</code></p>",
        "id": 471560777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726778658
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Implementation.20of.20exact/near/471560641\">said</a>:</p>\n<blockquote>\n<p>I believe the issue here is the expression <code>(0 + 0).succ</code>. Lean doesn't know what function <code>.succ</code> is referring to, because it doesn't know the type of <code>0 + 0</code>, because it's waiting for the type of <code>0</code> to be resolved. It will be default-resolved to <code>Nat</code>, but this is supposed to happen \"last\", and in particular it tries to resolve the application involving <code>h</code> before type defaulting. But because the whole expression <code>(0+0).succ</code> is stuck, all it knows is that the type of <code>(Int.negSucc_not_nonneg ?).mp</code> is <code>0 ≤ Int.negSucc ? → False</code> so applying that to <code>h</code> means solving <code>0 &lt; -1 =?= 0 ≤ Int.negSucc ?</code>, which is wrong on a few levels.</p>\n</blockquote>\n<p>Oh, I see. You mean that at the point  <code>Int.negSucc_not_nonneg</code> it is just waiting for a Nat, and there might be a function <code>.succ</code> from some type <code>T</code> to <code>Nat</code> that maps <code>((0 : T) + (0 : T)).succ</code> to some <code>Nat</code>, and Lean is waiting to undestand what <code>T</code> is?</p>",
        "id": 471561190,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1726778852
    },
    {
        "content": "<p>exactly</p>",
        "id": 471561207,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726778863
    },
    {
        "content": "<p>I think if you did <code>(.succ (0 + 0))</code> instead it would work since the type deduction goes the other way</p>",
        "id": 471561303,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726778899
    },
    {
        "content": "<p>Oh, nice. But then why all this disappears in the second call? When you say that <code>by</code> delays elaboration, do you mean that after the <code>by</code> Lean creates a metavariable precisely there <code>T</code> should land?</p>",
        "id": 471561435,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1726778974
    },
    {
        "content": "<p>because <code>by</code> comes <em>after</em> the default types are resolved</p>",
        "id": 471561538,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726779011
    },
    {
        "content": "<p><code>by</code> has even lower priority than default types</p>",
        "id": 471561569,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726779029
    },
    {
        "content": "<p>(everyone wants to come last)</p>",
        "id": 471561598,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726779044
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Implementation.20of.20exact/near/471561303\">said</a>:</p>\n<blockquote>\n<p>I think if you did <code>(.succ (0 + 0))</code> instead it would work since the type deduction goes the other way</p>\n</blockquote>\n<p>Indeed, it works as (you) expected!</p>",
        "id": 471561617,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1726779055
    },
    {
        "content": "<p>Related <a href=\"#narrow/stream/116395-maths/topic/Heavy.20rfl/near/469781815\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Heavy.20rfl/near/469781815</a></p>",
        "id": 471561665,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1726779079
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Implementation.20of.20exact/near/471561538\">said</a>:</p>\n<blockquote>\n<p>because <code>by</code> comes <em>after</em> the default types are resolved</p>\n</blockquote>\n<p>But is it \" coming\" somewhere? Or do you mean that every term constructed with a <code>by</code> comes last?</p>",
        "id": 471561705,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1726779106
    },
    {
        "content": "<p>every <code>by</code> block is delayed until every other elaboration problem and available trick is used</p>",
        "id": 471561799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726779141
    },
    {
        "content": "<p>that way the goal state doesn't have confusing metavariables in it which are already resolved later in the term</p>",
        "id": 471561875,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726779176
    },
    {
        "content": "<p>Oh, so this really have little to do with <code>exact</code> in the end, it is really  the priority of<code>by</code>.</p>",
        "id": 471561905,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1726779192
    },
    {
        "content": "<p>Wow.</p>",
        "id": 471561933,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1726779210
    },
    {
        "content": "<p>one of the design criteria of tactic mode is that elaboration should be predictable and in-order top down</p>",
        "id": 471562032,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726779247
    },
    {
        "content": "<p>And just to be sure: the <code>(.succ (0+0))</code> trick works because Lean parses right to left and first sees the <code>0</code>, it defaults it to <code>0 : Nat</code>, so <code>.succ</code> must be <code>Nat.succ</code> and everything goes smoothly?</p>",
        "id": 471562068,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1726779268
    },
    {
        "content": "<p>but term mode is a crazy dance of priorities and out of order execution</p>",
        "id": 471562073,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726779272
    },
    {
        "content": "<p>It's not because of parsing order, it's because <code>(.succ ...)</code> elaborates to <code>T.succ</code> where <code>T</code> is the expected type, while <code>(...).succ</code> elaborates to <code>T.succ</code> where <code>T</code> is the type of <code>(...)</code></p>",
        "id": 471562240,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726779348
    },
    {
        "content": "<p>we know the expected type is <code>Nat</code>, we don't know the type of <code>0 + 0</code></p>",
        "id": 471562322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726779368
    },
    {
        "content": "<p>This works too:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">negSucc_not_nonneg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>",
        "id": 471562339,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1726779375
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Implementation.20of.20exact/near/471562240\">said</a>:</p>\n<blockquote>\n<p>It's not because of parsing order, it's because <code>(.succ ...)</code> elaborates to <code>T.succ</code> where <code>T</code> is the expected type, while <code>(...).succ</code> elaborates to <code>T.succ</code> where <code>T</code> is the type of <code>(...)</code></p>\n</blockquote>\n<p>Crystal clear, thanks! <span aria-label=\"crystal\" class=\"emoji emoji-1f48e\" role=\"img\" title=\"crystal\">:crystal:</span> (although dotted identifier notation is still somewhat arcane to me in its implementation details).</p>",
        "id": 471562398,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1726779403
    },
    {
        "content": "<p>don't worry, it's arcane even to the people that wrote it</p>",
        "id": 471562677,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726779513
    }
]