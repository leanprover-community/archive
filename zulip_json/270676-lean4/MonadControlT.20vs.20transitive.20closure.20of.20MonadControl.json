[
    {
        "content": "<p>The doc string for the <code>MonadControlT</code> class says \"Transitive closure of MonadControlT\". If this is the case, why is the input <code>MonadControlT.stM m n α</code> of <code>MonadControlT.restoreM</code> not wrapped in <code>m</code>? I don't really understand this stuff well enough to figure out if there's some intentional difference between <code>MonadControlT.stM</code> and <code>MonadControl.stM</code> that works out because of typeclass resolution, but it seemed off to me</p>",
        "id": 402386678,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1700111351
    },
    {
        "content": "<p>I'm writing down and formalizing the laws for <code>MonadControl</code> as stated in Haskell's <code>monad-control</code> package and this is tripping me up. There also seem to be some design decisions in haskell monad transformers libraries that are influenced by parametricity, more specifically there are external free theorems that we can't prove in lean because e.g. they fail in the precense of LEM and this implies certain coherence conditions for the typeclasses. I'm not sure if this is relevant to anything right now, but I wanted to point it out</p>",
        "id": 402387172,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1700111710
    },
    {
        "content": "<p>The \"transitive closure\" refers to the declared instances, not to their methods. This means that <code>MonadControlT</code> and <code>MonadControl</code> provide the exact same interface, but <code>MonadControl</code> instances perform only one step of lifting (from <code>m</code>, say, to <code>Reader σ m</code>) while <code>MonadControlT</code> instances perform any finite number of steps (from <code>m</code>, say, to <code>Reader σ (ExceptT ε m)</code>).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">ε</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">MonadControl</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">ReaderT</span> <span class=\"n\">σ</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">MonadControl</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">ExceptT</span> <span class=\"n\">ε</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">MonadControl</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">ReaderT</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">ExceptT</span> <span class=\"n\">ε</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"c1\">-- fails</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">MonadControlT</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">ReaderT</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">ExceptT</span> <span class=\"n\">ε</span> <span class=\"n\">m</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>So in practice, you always declare <code>MonadControl</code> instances and when you have a function that uses the <code>MonadControl</code> interface, you give it a <code>MonadControlT</code> instance argument. There's also a similar pattern for <code>MonadLift</code>/<code>MonadLiftT</code> and probably similar classes.</p>",
        "id": 402444146,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1700132914
    },
    {
        "content": "<p>But they don't have the same interface, the type of restoreM is different</p>",
        "id": 402503883,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1700150617
    },
    {
        "content": "<p>Ah! Sorry, I didn't realise there was a discrepancy there even though you pointed it out explicitly. I'm not sure that's intentional.</p>",
        "id": 402507164,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1700151560
    }
]