[
    {
        "content": "<p>I should probably write these ideas down more properly and work through them to find the flaws myself, but maybe you’ll excuse me conveying half-baked ideas in order to be told why it can’t be done :-)</p>\n<h3>Goals</h3>\n<p>I have three goals in mind here</p>\n<ul>\n<li>Right now the kernel has built-in support for nested recursion. It would be desirable to pull most of that complexity out of the kernel, leaving only in the kernel what really needs to be there.</li>\n<li>If what’s left in the kernel is simpler, maybe it can be reasonably made to support nested recursion with indices.</li>\n<li>If the stars align well, we might actually get recursion through <code>List.map</code> or so (this is the part that I didn’t think through yet)</li>\n</ul>\n<h3>Prelude: refining axioms</h3>\n<p>To warm up, I’d like to pose this question: Can we “safely” refine an axiom to a definition after the fact?</p>\n<p>Say we define <code>axiom foo : ty</code>, then do some more declaration, and then tell the kernel: “Actually, here is a definition for <code>foo</code>; <code>def foo : ty := e</code>, just forget that it was an axiom before and from now on consider it a definition.</p>\n<p>It seems to me that this operation might be safe, after all, nothing in the environment could depend on a property of <code>foo</code> that will be no longer true, won't it?</p>\n<p>Probably to preserve certain metatheoretical properties of the system, the kernel should check that <code>e</code> does not (transitively) depend on <code>foo</code> itself, to avoid cyclical definitions. That’s fine.</p>\n<h3>Refining inductives</h3>\n<p>Assuming the above holds water, and thinking of the <code>inductive</code> command as morally introducing a bunch of axioms (the type former, the constructors, the recursor), I wonder: Can we do a similar environment surgery with inductives?</p>\n<p>Maybe something like this: For an inductive <code>T</code>, given proposed definition values for the “axioms” <code>T</code>, <code>T.con</code> and <code>T.rec</code> (say, <code>T'</code>, <code>con'</code> and <code>rec'</code>) such that</p>\n<ul>\n<li>the types of <code>T</code> and <code>T'</code> agree</li>\n<li>the type of <code>T.con</code> with <code>T'</code> substituted for <code>T'</code> agrees with the type of <code>con'</code></li>\n<li>the type of <code>T.rec</code> with <code>T'</code> substituted for <code>T'</code> agrees with the type of <code>rec'</code></li>\n<li>the iota-rule for <code>T.rec</code>, which states that <code>T.rec … T.con = e</code>, still holds definitionally: <code>T.rec' … T.con' = e</code> (probably under suitable substitutions)</li>\n<li>some more conditions  to avoid cyclic definitions<br>\nit we can replace the inductive definition of  <code>T</code>, <code>T.con</code> and <code>T.rec</code> with plain definitions.</li>\n</ul>\n<p>Intuitively it feels sounds, and a soundness proof that constructs a model of our types should hopefully still go through when we give a model of the type explicitly (and later).</p>\n<h3>Silly example</h3>\n<p>For example, presumably we could add the definitions (modulo typos)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">()</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">()</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">())</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"c1\">-- in general this may be more involved</span>\n</code></pre></div>\n<p>to subsume the existing <code>Nat</code>, could we?</p>\n<h3>Why the bother?</h3>\n<p>As alluded to above, my hope would be that we can move the kernel's construction for nested inductives out of the kernel and leave only code to check and perform this surgery. For an inductive like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Tree</span>\n</code></pre></div>\n<p>we’d first generate a mutual inductive involving <code>Tree</code> and <code>ListTree</code> (like the kernel internally already does), and then afterwards replace <code>ListTree</code> with <code>List Tree</code>. In particular <code>ListTree.rec</code> would be replaced with a suitable application of <code>List.rec</code>, and than in tern might allow us to actually allow</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"bp\">.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>as a structural definition, as long as the <code>List.fold</code> itself is defined in terms of <code>Tree.rec</code>. (Ah, I should think if this still holds with the <code>.brecOn</code> instead of <code>.rec</code>).</p>\n<p>(If this holds, maybe we could even go further and let the kernel only support non-mutual inductives, and let the elaborator perform the necessary encoding to define a non-mutual type first (using idices?), and then use this kind of post-hoc surgery to recover the definitions that the user wrote, including nice definitional properties.)</p>\n<h3>So?</h3>\n<p>Very likely someone has thought about this before and found good reasons why it just doesn’t work. Does someone here know more?</p>",
        "id": 451183343,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1720882479
    },
    {
        "content": "<p>While I don't know the specifics of the kernel at the time, I believe Lean 3's kernel did not handle mutual/nested inductives by itself (according to <a href=\"https://github.com/leanprover/lean3/blob/f8ed407d073e172eb9131e836b416f29628375fd/src/kernel/inductive/inductive.cpp#L27\">this</a> comment), but instead relied on a translation to indexed inductive types like the one you're describing. Regarding the handling of the recursor, a first look at <a href=\"https://github.com/leanprover/lean3/blob/f8ed407d073e172eb9131e836b416f29628375fd/src/library/inductive_compiler/mutual.cpp#L707\">the code</a> makes me believe this sort of axiomatic juggling wasn't really necessary. Since the recursor between the base mutual type and the indexed encoding are different (namely, the indexed version has only one motive), the \"new\" recursor is instead written as a def using the indexed version. As for nested inductive types, It looks like the whole reduction strategy was made using <code>sizeof</code>s. I am not sure how this implementation would handle i.e reflexive nested datatypes such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">list</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Tree</span>\n</code></pre></div>\n<p>Trying this on the online Lean 3 web editor, it seems to be looping indefinitely ?</p>\n<p>In any case, I think the main reason to avoid using the encodings (and possibly the main reason why they were ditched in the first place ?) is performance. This seems to be shortly described <a href=\"https://github.com/leanprover/lean3/blob/f8ed407d073e172eb9131e836b416f29628375fd/src/library/inductive_compiler/nested.cpp#L71\">here</a>, but I think there should be more to the story.</p>",
        "id": 451198576,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1720890021
    },
    {
        "content": "<blockquote>\n<p>If what’s left in the kernel is simpler, maybe it can be reasonably made to support nested recursion with indices.</p>\n</blockquote>\n<p>As for this, my opinion is that a working solution to handle this would be to modify the kernel's internal translation layer between nested and mutual types to handle these cases. To be more precise, after having experimented on this some time ago, it looks like any such nested inductive can be encoded as a mutual type by having the free variables present in the nested occurence become indices of the nested translation. <br>\nFor example, this (nonsensical) nested indexed inductive</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>Could be encoded as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n<span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">OptionFoo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OptionFoo</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OptionFoo</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OptionFoo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I have an experiment fork <a href=\"https://github.com/arthur-adjedj/lean4/tree/free_vars_nested\">here</a> which aims to add this \"management of free variables\" feature to the nested -&gt; mutual preprocessor. It doesn't work (yet) on any truly complex examples, but this basic implementation, and the examples I've met along the way make me confident that this translation can be done in most, of not all cases.</p>",
        "id": 451200742,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1720891037
    },
    {
        "content": "<p>Thanks for digging up that commend and the other references!</p>\n<p>The performance problem mentioned in that comment (simp only indexing on the head symbol) should no longer be the case with the discrimination tree of lean4).</p>\n<p>Just adding this feature to the kernel is of course an option, if extending the trust base is fine, or if it's needed for performance, and it’s good to see that you seem to have figured out most of it.</p>\n<p>Although that would not provide the other benefit, namely allowing nested recursion in the form of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"bp\">.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>would it?</p>",
        "id": 451229376,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1720907541
    },
    {
        "content": "<blockquote>\n<p>Just adding this feature to the kernel is of course an option, if extending the trust base is fine</p>\n</blockquote>\n<p>I think such a modification to the kernel wouldn't have a big impact on the size of the TCB. After all, all important checks (namely universe sizes, strict positivity, the generation of recursors etc...) are made <em>after</em> the translation into mutual types, which means that, as long as the translation doesn't produce an ill-formed inductive type (which would i.e contain fvars/mvars in its type and whatnot) (which would throw an error at that point), and as long as the translation back from mutual to nested doesn't change much (and, from my experiment, it looks like it would be largely the same), then the code could be just as trustable IMO.</p>\n<blockquote>\n<p>Although that would not provide the other benefit</p>\n</blockquote>\n<p>It wouldn’t, no. I don’t see any obvious way to manage these things, let alone a solution that would imply tinkering with the kernel.</p>",
        "id": 451231380,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1720908467
    },
    {
        "content": "<p>Yes, kernel tinkering would be required in any case for that.</p>",
        "id": 451231751,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1720908635
    },
    {
        "content": "<p>If we allow ourselves more kernel tinkering, then we could achieve that by extending the “translation back” to not just replace <code>OptionFoo α</code> with <code>Option (Foo α)</code> in the types of the constructors and the recursors, but also in the reduction rules for <code>Foo.rec</code> replace <code>OptionFoo.rec</code> with a suitable instantiation of <code>Option.rec</code> (with<code>Foo.rec</code> appearing in the minor premises). If finding this instantiation is of manageable complexity for doing it in kernel, this would maybe admit the definitional equalites we’d need for nested recursion.</p>",
        "id": 451233449,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1720909428
    },
    {
        "content": "<p>I would prefer we have a better soundness story for kernel extensions than \"it seems like it should work\". At the very least, there should be a precise description of the semantics and ideally a proof of soundness of the reduction relative to other things we understand. Certainly keep me in the loop for any kernel changes, because this will significantly impact lean4lean (both the kernel and the theorem statements).</p>",
        "id": 451240242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1720915584
    },
    {
        "content": "<p>I would love to see nested inductives removed from the kernel, but adding definitional equalities after the fact is problematic because it affects the overall rewrite system, and the wrong things can cause normalization to diverge.</p>",
        "id": 451240655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1720915973
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"432410\">Arthur Adjedj</span> <a href=\"#narrow/stream/270676-lean4/topic/kernel.20extension.3A.20refining.20inductives.3F/near/451198576\">said</a>:</p>\n<blockquote>\n<p>As for nested inductive types, It looks like the whole reduction strategy was made using <code>sizeof</code>s. I am not sure how this implementation would handle i.e reflexive nested datatypes such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">list</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Tree</span>\n</code></pre></div>\n</blockquote>\n<p>The lean 3 implementation was both buggy and incomplete, but the correct mutual encoding for that example is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">mutual</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ListTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">ListTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ListTree</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ListTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ListTree</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>which itself can be reduced to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">TreeKind</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ListTree</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">TreeGen</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TreeKind</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">TreeGen</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ListTree</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">TreeGen</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Tree</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TreeGen</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ListTree</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TreeGen</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">TreeGen</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ListTree</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">TreeGen</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ListTree</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">TreeGen</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Tree</span>\n</code></pre></div>",
        "id": 451240926,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1720916236
    },
    {
        "content": "<p>Mario, no worries, this is me musing on a weekend, so no changes imminent :-). And I absolutely agree that “it seems it should work” is the beginning, not the end - hence me asking the experts here.</p>\n<p>What is your sense of the simpler “Prelude” suggestion above, about replacing axioms with compatible definitions? Would that be sound?</p>\n<p>In which formal setting would one try a soundness proof, or are we not there yet where we can formally proof soundness of extensions?</p>\n<p>(My reduction argument at least for the axiom replacement would be to relate it to the environment produces when it was a definition from the start, trying to show that all typing judgments still hold with the axiom instantiated. For refining a non-mutual inductive the same might work; for refining one of a mutual inductive the argument might need to be more involved, and could maybe be based on a soundness proof that constructs a model, by choosing the “right” model initially.)</p>",
        "id": 451329265,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1720941468
    },
    {
        "content": "<p>So, looking at this from the angle that making the in-kernel translation of nested inductives more powerful, I do wonder:<br>\nIsn’t it a bit inconsistent that when rewriting back from the auxillary type (<code>ListTree</code>) to the desired type (<code>List Tree</code>), we rewrite the type and the constructors, but we don’t rewrite the recursor?</p>\n<p>More concretely:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Tree</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">explicit</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">funBinderTypes</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"c1\">-- This the generated rule's RHS.</span>\n<span class=\"c1\">-- The type and constructors of the auxillary `ListTree` have been replaced</span>\n<span class=\"c1\">-- by their `List Tree` counterpats, but we still see `Tree.rec_1`.</span>\n<span class=\"c1\">-- Can we replace that with `List.rec`?</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">info: fun</span>\n<span class=\"sd\">    (motive_1 : Tree → Sort u)</span>\n<span class=\"sd\">    (motive_2 : List Tree → Sort u)</span>\n<span class=\"sd\">    (node : (a : List Tree) → motive_2 a → motive_1 (Tree.node a))</span>\n<span class=\"sd\">    (nil : motive_2 (@List.nil Tree))</span>\n<span class=\"sd\">    (cons : (head : Tree) → (tail : List Tree) → motive_1 head → motive_2 tail → motive_2 (@List.cons Tree head tail))</span>\n<span class=\"sd\">    (a : List Tree) =&gt;</span>\n<span class=\"sd\">  node a (@Tree.rec_1 motive_1 motive_2 node nil cons a)</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"o\">(</span><span class=\"n\">whitespace</span><span class=\"o\">:=</span><span class=\"n\">lax</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"n\">run_meta</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">recVal</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getConstInfoRec</span><span class=\"w\"> </span><span class=\"ss\">``Tree.rec</span>\n<span class=\"w\">  </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">recVal</span><span class=\"bp\">.</span><span class=\"n\">rules</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">!.</span><span class=\"n\">rhs</span>\n\n<span class=\"c1\">-- Here is a definition with the same type as `Tree.rec_1`, but referring to `List.rec` instead.</span>\n\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"bp\">.</span><span class=\"n\">rec_1_impl</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">motive_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive_1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Tree</span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive_1</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">ts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ih_tail</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Tree</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">motive_1</span><span class=\"w\"> </span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ih_tail</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ts</span>\n\n\n<span class=\"c1\">-- With this, I could imagine the following rule RHS'</span>\n\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">proposedRuleRHS</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">motive_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive_1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Tree</span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive_1</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Tree</span><span class=\"bp\">.</span><span class=\"n\">rec_1_impl</span><span class=\"w\"> </span><span class=\"n\">motive_1</span><span class=\"w\"> </span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I wonder if this rewriting (if done correctly) was sound? And if so, whether it's within the complexity budget we have for the kernel.</p>\n<p>So what is this rewriting? Vaguely, pass the <code>motive</code>s corresponding to the desired type to its recursor, and and <code>F</code>-args  for its constructor, with every <code>x_ih</code> parameter that isn't provided by the new desired recursor, i.e. for a new type, instantiated with that type’s <code>.rec</code> and full set of motives/F-args.</p>\n<p>After this there should be no more auxillary types, constructors or recursors visible.</p>\n<p><span class=\"user-mention\" data-user-id=\"432410\">@Arthur Adjedj</span> maybe something to try on your various experimental branches :)</p>\n<p>(I’m recording this idea  at <a href=\"https://github.com/leanprover/lean4/issues/4749\">https://github.com/leanprover/lean4/issues/4749</a> for posterity.)</p>",
        "id": 451449195,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1721034626
    },
    {
        "content": "<p>To give an update on this: I have experimented more with nested indexed inductive types at the kernel level, and am confident I have a robust implementation <a href=\"https://github.com/arthur-adjedj/lean4/tree/free_vars_nested\">here</a>. The main changes in this branch are as described previously: the kernel now collects all bvars present in the parameters of a nested occurrences, and adds them as indices of the auxiliary inductive associated with the nested occurrence, as well as carry this information around to ensure the translation back to be correct. One major change induced by this is that the recursors' shape changes slightly in nested indexed inductive types. I'll show it through an example:<br>\nConsider the following type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> Trees of depth at most n-/</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n</code></pre></div>\n<p>Because <code>n</code> appears freely in the parameter of <code>List</code>, the auxiliary translation now needs to take this into account, producing the following mutual inductive:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">mutual</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}:</span><span class=\"w\"> </span><span class=\"n\">ListTest</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">ListTest</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ListTest</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ListTest</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ListTest</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>All well and good. This leads to the following (mutual) recursor:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">ListTest</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ListTest</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ListTest</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive_1</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Test</span><span class=\"bp\">.</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">ListTest</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ListTest</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive_1</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">a_1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ListTest</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a_1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ListTest</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">t</span>\n</code></pre></div>\n<p>However, the translated recursor now looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Test</span><span class=\"bp\">.</span><span class=\"n\">rec_1</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive_1</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Test</span><span class=\"bp\">.</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive_1</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">t</span>\n</code></pre></div>\n<p>Notice that despite the <code>List</code> type not having indices, the recursor's shape now looks like it does. Because of this, it is necessary that the reduction algorithm for recursors now handle a notion of \"added indices\" (implementation <a href=\"https://github.com/arthur-adjedj/lean4/blob/5d1a26511761fa031eb8b9601f2553089542fd96/src/Lean/Meta/WHNF.lean#L208\">here</a>, which makes use of <a href=\"https://github.com/leanprover/lean4/pull/5679\">lean4#5679</a>). Another solution would be to implement Joachim's <a href=\"https://github.com/leanprover/lean4/pull/4749\">lean4#4749</a>, so that these auxiliary recursor would be rewritten into the right recursors.</p>\n<p>The branch currently compiles all of lean core and passes all tests. One remaining issue is that the generation of <code>SizeOf</code> instances currently doesn't work on nested indexed inductives, probably because of the change in shape of the auxiliary recursors. Other than that, all other helper definitions such as <code>below</code>, <code>brecOn</code>, <code>casesOn</code>, <code>noConfusion</code> etc... all  work as expected. Examples of inductive types that used to not be handled can be found <a href=\"https://github.com/arthur-adjedj/lean4/blob/free_vars_nested/tests/lean/run/free_vars_in_nested.lean\">here</a>.</p>",
        "id": 477406337,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1729159670
    },
    {
        "content": "<p>That’s exciting! Do we have an RFC or issue describing your design here, just to have something more discoverable than a zulip thread?</p>\n<p>I assume these “extra recursors” will also have t be taken into account in other places in lean, so maybe <a href=\"https://github.com/leanprover/lean4/pull/4749\">lean4#4749</a> would be a nice alternative that keep the complexity a bit more isolated.</p>\n<p>Overall the complexity of this feature is a bit scary. If I’d have to bet on where an unsoundness bug (due to a kernel programming oversight, not fundamentally)  would be found, the mutual inductive handling would be high on my list.</p>",
        "id": 477415212,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729162940
    },
    {
        "content": "<blockquote>\n<p>Do we have an RFC or issue describing your design here, just to have something more discoverable than a zulip thread?</p>\n</blockquote>\n<p>I don't believe so, though there is an issue linked to this feature, namely <a href=\"https://github.com/leanprover/lean4/pull/2195\">lean4#2195</a>. I can write a more detailed description in an RFC.</p>\n<blockquote>\n<p>I assume these “extra recursors” will also have t be taken into account in other places in lean, so maybe <a href=\"https://github.com/leanprover/lean4/pull/4749\">lean4#4749</a> would be a nice alternative that keep the complexity a bit more isolated.</p>\n</blockquote>\n<p>I do agree that translating auxiliary recursors would be ideal.</p>\n<blockquote>\n<p>If I’d have to bet on where an unsoundness bug would be found, the mutual inductive handling would be high on my list.</p>\n</blockquote>\n<p>I must agree with this. The most complex part of the kernel is certainly the handling/checking of inductive types. It has to manage many different elements and it's easy to get lost in the details. <br>\nOne big issue I have seen when working on the kernel is that despite inductive types  and their constructors being checked to be type-correct during their constructions (namely <a href=\"https://github.com/arthur-adjedj/lean4/blob/0c62943a6d2a49051bca74d5ad4fa07a36b426a2/src/kernel/inductive.cpp#L213\">here</a> and <a href=\"https://github.com/arthur-adjedj/lean4/blob/0c62943a6d2a49051bca74d5ad4fa07a36b426a2/src/kernel/inductive.cpp#L414\">here</a>), recursors  (and their reduction rules) never get type-checked, and the kernel is happy to add a possibly ill-typed recursor to the environment. I believe the kernel would benefit from checking those things before adding them to the environment, and throw an error if something wrong happened there.</p>",
        "id": 477416586,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1729163433
    },
    {
        "content": "<blockquote>\n<p>I believe the kernel would benefit from checking those things before adding them to the environment, and throw an error if something wrong happened there.</p>\n</blockquote>\n<p>That would just be a sanity check against implementation bugs, right? There is no way a user can somehow make the kernel construct an ill-typed constructor?</p>",
        "id": 477416937,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729163577
    },
    {
        "content": "<p>It would be yes. I am arguing that if a kernel programming oversight was to produce an ill-typed recursor, the kernel would still add it to the environment, and that checking this would add more trust to the system.</p>",
        "id": 477417062,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1729163638
    },
    {
        "content": "<p>Yes, that shouldn't hurt and not be too expensive either.</p>",
        "id": 477420287,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729164783
    },
    {
        "content": "<p>To test the limits of my implementation, I've tried to see if any \"beefy\" nested indexed inductive would work on that branch. I've decided to formalize a logical relation for Martin-Löf Type Theory (this is a direct port of the <a href=\"https://github.com/CoqHott/logrel-coq\">logrel-coq</a> formalization described in <a href=\"https://hal.science/hal-04214008v2\">Martin-Löf à la Coq</a>) which is an indexed inductive which relies on nested packings to function. I am happy to say that the following <a href=\"https://github.com/arthur-adjedj/logrel-lean/blob/699bc61dc9217cc8e50fd88de9ffccf41e29df66/LogrelLean/LogicalRelation.lean#L499\">definition</a> compiles locally with no issue.</p>",
        "id": 477453800,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1729174318
    },
    {
        "content": "<p>Just a reminder to relevant parties: Please <strong>ping me</strong> when anything in the kernel changes. I am maintaining a <a href=\"https://github.com/digama0/lean4lean\">carbon copy of the C++ code in lean</a> and I want to make sure it stays that way</p>",
        "id": 477730641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729283549
    },
    {
        "content": "<p>Re: type-incorrect recursors, proving these types are correct is of course on the agenda for lean4lean, although it might be a while before the project gets that far</p>",
        "id": 477730858,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729283645
    },
    {
        "content": "<p>For the last few months' spare time, I have been working on giving a model to a rather complicated inductive type, which involves induction-induction, induction-recursion, and recursion-recursion (so, an \"IIRRT\" I guess?). The approach I am pursuing to make this possible in Lean, is to split the IIRRT up into a type-index-erased (E) half and a wellformedness (W) half, and then at the very end stitch those together using subtypes. Then you can define a recursor for this IIRRT, and prove iota rules for it, which miiiiiight (not sure) even hold definitionally but would be extremely non-performant either way. In order to provide a model, you have to prove things about the E half before you can even state the corresponding W half, i.e. your IIRRT-mutual block would have to also contain theorems inside the mutual block; but this is not a problem if you split it up into E and W halves. At the very end you end up with a whole bunch of defs for the type former(s), your recursive functions, the recursor, and theorems about the recursor.</p>\n<p>I would love to be able to use this IIRRT in a comfortable way, that is: Users should never see the inner workings of it (the E and W halves), users should be able to use pattern matching using the derived recursor, and iota rules should hold definitionally without a big performance hit.</p>\n<p>It sounds like refining inductives might provide a way to make this possible?</p>\n<p>If this is possible, we could add induction-induction and (small) induction-recursion to Lean, and make it actually pleasant to use! All while actually making the kernel smaller.</p>",
        "id": 479159628,
        "sender_full_name": "Max Nowak 🐉",
        "timestamp": 1730058267
    },
    {
        "content": "<p>Basically I want Lean to trust me and give me definitional iota rules, because I can provide a model for it. And then I want Lean to forget the model.</p>",
        "id": 479159968,
        "sender_full_name": "Max Nowak 🐉",
        "timestamp": 1730058573
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"416280\">Max Nowak 🐉</span> <a href=\"#narrow/channel/270676-lean4/topic/kernel.20extension.3A.20refining.20inductives.3F/near/479159968\">said</a>:</p>\n<blockquote>\n<p>Basically I want Lean to trust me and give me definitional iota rules, because I can provide a model for it. And then I want Lean to forget the model.</p>\n</blockquote>\n<p>That sounds useful! It’s not quite what I suggested in the present thread, which goes the other way: Let the kernel construct an inductive type (with all the limitations this has), then give a model of this type using other types, and then make the first type disappear (by making the type former, constructor and recursors definitions).</p>\n<p>That’s probably too limited for what you want, which is from a model create a type that the kernel wouldn’t create itself otherwise.</p>",
        "id": 479160252,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1730058840
    },
    {
        "content": "<p>I think it makes sense to first provide a model (which you can do already), and then have the ability to wave a magic wand and enchant it into a proper inductive(-recursive) type.</p>",
        "id": 479160415,
        "sender_full_name": "Max Nowak 🐉",
        "timestamp": 1730058975
    },
    {
        "content": "<p>I’m not disagreeing</p>",
        "id": 479160479,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1730059044
    },
    {
        "content": "<p>Neither am I. But yeah it's a slightly different approach.</p>",
        "id": 479160597,
        "sender_full_name": "Max Nowak 🐉",
        "timestamp": 1730059107
    },
    {
        "content": "<p>This would be super cool</p>",
        "id": 479160603,
        "sender_full_name": "Max Nowak 🐉",
        "timestamp": 1730059115
    },
    {
        "content": "<p>You could strip mutual inductive types from the kernel entirely this way, and only have indexed W-types as the foundation. Then build your ladder into more and more complicated inductive types, but none of that is part of the trusted code base now, and it would only use the kernel's magic wand, provided you can give it a model.</p>",
        "id": 479160810,
        "sender_full_name": "Max Nowak 🐉",
        "timestamp": 1730059264
    },
    {
        "content": "<p>I guess this might be understood like this: axioms are actually <em>assumptions</em> (like the assumptions the <code>variable</code> command introduces), which turn into additional lambdas before every subsequent definition, and \"refining axioms\" corresponds to applying concrete arguments to the lambdas.</p>\n<p>However, this still does not allow additional <em>definitional</em> equalities to be introduced; at the very least, constraints must be added to preserve confluence and therefore subject reduction, otherwise it can <a href=\"https://hal.science/hal-02901011v2/document\">go wild</a> even when those are valid propositional equalities...? (Though the examples in this paper all involve additional assumptions...)</p>",
        "id": 479167741,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1730066020
    },
    {
        "content": "<p>(unless those are defeqs derivable from existing defeqs, in which case the refined axioms are more like additional <code>let</code>s prefixed to every definition)</p>",
        "id": 479169346,
        "sender_full_name": "Zhanrong Qiao",
        "timestamp": 1730067441
    }
]