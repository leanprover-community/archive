[
    {
        "content": "<p>If I have <code>n : Nat</code>, then I can write <code>toExpr n : Expr</code> to quote it into a kernel term. Suppose I also have a proof <code>h : n = 2</code>. Can I somehow quote it to obtain <code>pf : Q($(toExpr n) = 2)</code>?</p>",
        "id": 515576166,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1746131225
    },
    {
        "content": "<p>The only way I know of doing this is to hard-code the proof.</p>",
        "id": 515576427,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746131318
    },
    {
        "content": "<p>since proofs are erased in the compiler</p>",
        "id": 515576528,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746131356
    },
    {
        "content": "<p>I see what you're saying, maybe my question doesn't even make sense; it would be asking that <code>toExpr</code> produce an <code>Expr</code> from a runtime value that's effectively <code>Unit</code>.</p>",
        "id": 515576623,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1746131397
    },
    {
        "content": "<p>What's your application?</p>",
        "id": 515576858,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746131477
    },
    {
        "content": "<p>For <code>h : n = 2</code> the proof that <code>$(toExpr n) = 2</code> is just <code>rfl</code></p>",
        "id": 515576923,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746131509
    },
    {
        "content": "<p>The actual use case is more complicated. I have some type, <code>Foo</code>, and a <code>Foo</code>-checking function <code>partial def check (a : Foo) : Except String { _u : Unit // GoodFoo a }</code>. Then I run it at the meta-level (in an elaborator), and if it succeeds, I wish to produce a proof in <code>Q(GoodFoo $(toExpr a))</code>. (<code>Foo</code> is the syntax of a type theory and <code>check</code> is a typechecker, but I think that doesn't matter here.)</p>",
        "id": 515577558,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1746131743
    },
    {
        "content": "<p>(Thinking about it further, being able to reflect proofs like this is some analogue of <code>nativeDecide</code>, since the original checking runs in the interpreter.)</p>",
        "id": 515578048,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1746131915
    },
    {
        "content": "<p>This is just <code>decide</code></p>",
        "id": 515578332,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746132034
    },
    {
        "content": "<p>Write a <code>Decidable</code> instance</p>",
        "id": 515578353,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746132043
    },
    {
        "content": "<p>Actually, is this <code>decide</code>? It might be partial.</p>",
        "id": 515578417,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746132066
    },
    {
        "content": "<p>hmmmmmmmm</p>",
        "id": 515578435,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746132073
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/270676-lean4/topic/Quoting.20proofs.20with.20.60ToExpr.60/near/515578417\">said</a>:</p>\n<blockquote>\n<p>Actually, is this <code>decide</code>? It might be partial.</p>\n</blockquote>\n<p>Sorry yeah, it's <code>partial def check</code>.</p>",
        "id": 515578569,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1746132124
    },
    {
        "content": "<p>oh no</p>",
        "id": 515578637,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746132159
    },
    {
        "content": "<p>so you can't prove anything at all?</p>",
        "id": 515578689,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746132186
    },
    {
        "content": "<p>I have an idea! You can make <code>check</code> return the <code>Expr</code> instead of the useless proof.</p>",
        "id": 515578903,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746132262
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/270676-lean4/topic/Quoting.20proofs.20with.20.60ToExpr.60/near/515578903\">said</a>:</p>\n<blockquote>\n<p>I have an idea! You can make <code>check</code> return the <code>Expr</code> instead of the useless proof.</p>\n</blockquote>\n<p>Indeed this would be the standard approach, I just really didn't want to do that (because it makes the code of <code>check</code> strictly less readable); but I may have to.</p>",
        "id": 515578993,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1746132300
    },
    {
        "content": "<p>So what such a reflection principle is really asserting is that all the <code>ToExpr</code> implementations are correct, at least on <code>GoodFoo</code>s. In certain cases we can prove this directly - or more accurately, construct <code>Q(GoodFoo $(toExpr a))</code> - without changing <code>check</code> itself. I think this can only work if the proof term is constructible by recursion on <code>a</code> only (so on data, not on a proof), which may need some inversion principles.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">GoodNat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GoodNat</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GoodNat</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">GoodNat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">GoodNat.pred</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GoodNat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">GoodNat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">GoodNat.toExpr</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GoodNat</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">toExpr</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">GoodNat</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">one</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">GoodNat.pred</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">toExpr</span>\n<span class=\"w\">    </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 515583477,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1746134166
    },
    {
        "content": "<p>(Something that's probably not useful for you, but I was reminded of this recently: sometimes having a runtime value <em>is</em> enough to synthesize a proof, though probably most cases are fairly trivial. The only one that comes to mind is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instToExprFin#doc\">docs#instToExprFin</a>)</p>",
        "id": 515586748,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1746135632
    }
]