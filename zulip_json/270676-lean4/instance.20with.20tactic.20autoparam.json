[
    {
        "content": "<p>is there a way to get something like this working?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">UInt8.size</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CoeDep</span> <span class=\"n\">Char</span> <span class=\"o\">(</span><span class=\"n\">Char.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">UInt8</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">instCoeDepCharOfNatUInt8</span> <span class=\"o\">:</span> <span class=\"n\">CoeDep</span> <span class=\"n\">Char</span> <span class=\"sc\">'a'</span> <span class=\"n\">UInt8</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">CoeDep</span> <span class=\"n\">Char</span> <span class=\"sc\">'a'</span> <span class=\"n\">UInt8</span>\n</code></pre></div>\n<p>the synth line fails unfortunately</p>",
        "id": 342972927,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1679249223
    },
    {
        "content": "<p>Oh wait, meant for this to be in <a class=\"stream\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4\">#lean4</a> if someone is able to move it &gt;_&lt;</p>",
        "id": 342972957,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1679249245
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/instance.20with.20tactic.20autoparam\">#mathlib4 &gt; instance with tactic autoparam</a> by <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>.</p>",
        "id": 342973569,
        "sender_full_name": "Notification Bot",
        "timestamp": 1679249582
    },
    {
        "content": "<p>I don't think you can use <code>decide</code> like that, but you can trick the typeclass synthesis system into proving such inequalities. E.g., the following is part of mathlib (<a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/Fin/Fin2.lean\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/Fin/Fin2.lean</a>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- This is a simple type class inference prover for proof obligations</span>\n<span class=\"sd\">  of the form `m &lt; n` where `m n : ℕ`. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">IsLT</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- The unique field of `Fin2.IsLT`, a proof that `m &lt; n`. -/</span>\n  <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">fin2.is_lt</span> <span class=\"n\">Fin2.IsLT</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">IsLT.zero</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsLT</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">succ_pos</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">IsLT.succ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">IsLT</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsLT</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">succ_lt_succ</span> <span class=\"n\">l.h</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/-- Use type class inference to infer the boundedness proof, so that we can directly convert a</span>\n<span class=\"sd\">`Nat` into a `Fin2 n`. This supports notation like `&amp;1 : Fin 3`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">ofNat'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLT</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">],</span> <span class=\"n\">Fin2</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">absurd</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">Nat.not_lt_zero</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">fz</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">fs</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ofNat'</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">⟨</span><span class=\"n\">lt_of_succ_lt_succ</span> <span class=\"n\">h</span><span class=\"o\">⟩)</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">fin2.of_nat'</span> <span class=\"n\">Fin2.ofNat'</span>\n</code></pre></div>",
        "id": 342979262,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1679253101
    },
    {
        "content": "<p>I'm a bit worried doing that, just because chars get kind of big sometimes and I don't want tc synthesis to have to synthesize a chain of 200 elements instead of calling a dedicated tactic :/</p>",
        "id": 342980049,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1679253611
    },
    {
        "content": "<p>maybe this is a feature request, heh</p>",
        "id": 342980066,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1679253628
    },
    {
        "content": "<p>You could generate 256 instances instead for a chain length of 1</p>",
        "id": 342987601,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679258507
    },
    {
        "content": "<p>Being able to use autoparams for effectively running custom code as part of typeclass synthesis would be a very useful and powerful feature for sure.</p>",
        "id": 343085013,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1679310080
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/instance.20with.20tactic.20autoparam/near/342987601\">said</a>:</p>\n<blockquote>\n<p>You could generate 256 instances instead for a chain length of 1</p>\n</blockquote>\n<p>Given you can do this with a macro and write only a handful of lines of code, I think this is a perfectly reasonable hack for UInt8; though I wouldn't advise it for Uint16</p>",
        "id": 343085208,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679310133
    },
    {
        "content": "<p>You can do this in a roundabout way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Decide</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">isTrue</span> <span class=\"o\">:</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">Decide</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">isTrue</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">Decide.mk</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Decide</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">UInt8.size</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">CoeDep</span> <span class=\"n\">Char</span> <span class=\"o\">(</span><span class=\"n\">Char.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">UInt8</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Decide.isTrue</span><span class=\"o\">⟩</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"sc\">'a'</span> <span class=\"o\">:</span> <span class=\"n\">UInt8</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 343495807,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1679425038
    },
    {
        "content": "<p>How much reduction does this perform on<code>Decidable</code> instances to work out if they match <code>isTrue</code>?</p>",
        "id": 343496826,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679425306
    },
    {
        "content": "<p><code>Decidable p</code> is an instance-implicit argument, so it is unified with semireducible transparency.</p>",
        "id": 343498349,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1679425740
    },
    {
        "content": "<p>It's essentially the same thing that <code>by decide</code> does under the hood.</p>",
        "id": 343498615,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1679425825
    },
    {
        "content": "<p>ah, very cool, that should work for my purposes</p>",
        "id": 343527153,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1679435164
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/instance.20with.20tactic.20autoparam/near/342972927\">said</a>:</p>\n<blockquote>\n<p>is there a way to get something like this working?</p>\n</blockquote>\n<p>The short answer from an implementation view is: the mutual recursion between typeclass synthesis and unification is already one of the most complicated parts of the system. Adding tactic execution to the mix would make the complexity explode, and likely complicate caching as well.</p>",
        "id": 343609770,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1679475308
    },
    {
        "content": "<p>It seems very reasonable to keep it limited to <code>decide</code> esque problems -- anything beyond that feels like too much to expect tc synthesis to do. Maybe we can add the <code>Decide</code> class to Std.</p>",
        "id": 343755452,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1679509712
    },
    {
        "content": "<p>I still think that we should just allow tactic execution there, but require of implementers that the tactic must be pure, because the result will be cached just like a typeclass resolution problem</p>",
        "id": 343806307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679529286
    },
    {
        "content": "<p>Disallowing tactics just causes people to implement execution more poorly using the typeclass system. There are many cases where you can do significantly better with a custom automation</p>",
        "id": 343806376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679529337
    },
    {
        "content": "<p>For example, my project often has typeclass problems of the form <code>\\all (i : Fin 3), Foo (f i)</code>, (where the 3 might be any concrete, known number) which I want to automatically be inferred from instances of <code>Foo (f 0)</code>, <code>Foo (f 1)</code> and <code>Foo (f 2)</code>. This is doable by having a chain of instances, effectively doing induction on the <code>Fin</code> (but even then I had to add an auxiliary typeclass, or the synthesis would somehow fail).<br>\nI would love to just say something like <code>by intro i; fin_cases i; inferInstance</code></p>",
        "id": 343989085,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1679580327
    }
]