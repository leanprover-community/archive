[
    {
        "content": "<p>I have been experimenting with the \"canonicalizer\" recently, and I am confused by its transparency configuration.  What exactly does this configuration do?  I had initially assumed that if <code>e</code> and <code>e'</code> were defeq at transparency <code>red</code> then they would canonicalize to the same thing when CanonM is set up with transparency <code>red</code>.  But this seems not to be the case -- here are two expressions which are defeq at default transparency and do not canonicalize to the same thing at default transparency.</p>",
        "id": 482304698,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731556284
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Canonicalizer</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">canonEqSides</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MVarId</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CanonM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">getType</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eq?</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">unreachable!</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">lhs'</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">canon</span><span class=\"w\"> </span><span class=\"n\">lhs</span>\n<span class=\"w\">  </span><span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">debug</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"s2\">\"canonicalized {lhs} to {lhs'}\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rhs'</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">canon</span><span class=\"w\"> </span><span class=\"n\">rhs</span>\n<span class=\"w\">  </span><span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">debug</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"s2\">\"canonicalized {rhs} to {rhs'}\"</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"foo\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">liftMetaMAtMain</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">canonEqSides</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run'</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">default</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">debug</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">foo</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">[debug] canonicalized x to x</span>\n\n<span class=\"cm\">[debug] canonicalized id x to id x</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 482304705,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731556288
    },
    {
        "content": "<p>Relatedly, <code>omega</code> apparently doesn't let the user specify a transparency level (the way that Mathlib's <code>ring</code>, <code>linarith</code> etc. do).  Is that because cataloguing atoms using the canonicalizer (rather than <code>isDefEq</code>) makes this impossible?  (cc <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span>)</p>",
        "id": 482304967,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731556455
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=id#doc\">docs#id</a></p>",
        "id": 482306554,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731557548
    },
    {
        "content": "<p>Looking at the code of <code>canon</code>, the transparency setting is only used when checking if two things with the same hash aren't defeq - it isn't part of the hashing</p>",
        "id": 482306903,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731557816
    },
    {
        "content": "<p>You could <code>reduce</code> before canonicalizing, I guess. A more sophisticated algorithm could lazily compute the hash, repeatedly <code>whnf</code>-ing, but that doesn't seem to be implemented</p>",
        "id": 482307106,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731557969
    },
    {
        "content": "<p>I don't follow, sorry -- what does <code>reduce</code> have to do with transparency? (It's my first time looking at that function.)</p>",
        "id": 482307865,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731558557
    },
    {
        "content": "<p>If you call <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.reduce#doc\">docs#Lean.Meta.reduce</a> before running <code>canon</code> that would solve the problem, although it'll be very inefficient</p>",
        "id": 482308050,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731558690
    },
    {
        "content": "<p>But generally this seems out-of-scope for <code>CanonM</code> — the docstring states</p>\n<blockquote>\n<p>This module aims to efficiently identify terms that are structurally different, definitionally equal, and structurally equal when we disregard implicit arguments like @id (Id Nat) x and @id Nat x</p>\n</blockquote>",
        "id": 482308181,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731558796
    },
    {
        "content": "<p>I'm a bit surprised to hear this would be out of scope, because I believe CanonM is now recommended for atom-identication in algebraic tactics, and traditionally (at least in mathlib) such tactics have supported a configurable reducibility level.</p>",
        "id": 482308872,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731559222
    },
    {
        "content": "<p>I could try to implement my idea with <code>whnf</code> if that'll be helpful, I think it should be able to support this</p>",
        "id": 482309060,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731559379
    },
    {
        "content": "<p>Well, who knows, maybe the current advice is that algebraic tactics should <em>not</em> support multiple reducibility levels, and that instead users should unfold/zeta-reduce/etc in a separate step before the algebraic automation ...</p>",
        "id": 482309927,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731560048
    },
    {
        "content": "<p>I think that's the case, Heather. There's just a trade off here between \"I want tactics that just work, doing extra work as required\" and \"I want tactics with reliable performance\". You get to pick a failure mode... :-) That said, I think it's pretty reasonable if Lean and Mathlib make differing choices on this question.</p>",
        "id": 482313827,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1731562960
    },
    {
        "content": "<p>OK, thanks!  But maybe it would not be unreasonable to adopt this paradigm in Mathlib, too.</p>",
        "id": 482313998,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731563095
    },
    {
        "content": "<p>I was curious whether the no-transparency-configurability enforced by <code>CanonM</code> was actively recommended now for algebraic automation ... or whether it was just that you hadn't thought about it yet.  Sounds like it's the former?</p>",
        "id": 482314190,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731563226
    },
    {
        "content": "<p>(I've been experimenting with switching over AtomM to use CanonM, which is where I noticed this.)</p>",
        "id": 482314577,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731563463
    },
    {
        "content": "<p>Yeah, I think so. I think we should avoid hiding arbitrarily difficult defeq problems inside the running of other tactics.</p>",
        "id": 482314587,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1731563469
    },
    {
        "content": "<p>When we did this switch for <code>omega</code> there were one or two regressions. Fewer than I expected, however.</p>",
        "id": 482314619,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1731563503
    },
    {
        "content": "<p>My mostly-fixed <a href=\"https://github.com/leanprover-community/mathlib4/tree/HM-canonM\">branch#HM-canonM</a> touches 48 files so far, which is honestly pretty small in proportion to the number of files which use <code>ring</code>, <code>abel</code>, <code>linarith</code>, <code>module</code>, ... somewhere.</p>",
        "id": 482314955,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731563729
    },
    {
        "content": "<p>Like Heather, I'm concerned about the user experience here. Lean tactics already use a range of notions of equality (usually not properly documented), including at least</p>\n<ul>\n<li>defeq at default transparency</li>\n<li>defeq at reducible transparency</li>\n<li>defeq at default transparency but same <code>DiscrTree</code> keys (which are computed at reducible transparency but omit some parts of an expression)</li>\n</ul>\n<p>This approach adds one (or two) more:</p>\n<ul>\n<li>defeq at transparency <code>T</code> and structurally equal when ignoring implicit (but not instance) arguments</li>\n</ul>\n<p>It seems inevitable to me that will degrade the user experience for new and intermediate-level users. So unless there's an actual performance issue, I would prefer that tactics continue to standardise on reducible transparency.</p>\n<p>The most performant way to achieve this would now likely be:</p>\n<ul>\n<li><code>reduce (explicitOnly := true) (skipTypes := false) (skipProofs := true)</code></li>\n<li><code>canon</code></li>\n</ul>\n<p>The <code>skipProofs := true</code> is based on the observation that the canonicaliser seems to ignore proofs as well, but I'm not sure about that.</p>",
        "id": 482363113,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1731582101
    },
    {
        "content": "<p>There was very much a performance issue in <code>omega</code>.</p>",
        "id": 482497558,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1731625042
    },
    {
        "content": "<p>Yeah, but have you tried the middle ground I sketched? If this turns out to have reasonable performance, I think it would be worth sacrificing a bit of performance for sensible semantics.</p>",
        "id": 482500088,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1731626341
    },
    {
        "content": "<p>Sorry, could you say more explicitly what your suggestion is? I don't understand yet.</p>",
        "id": 482501351,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1731627003
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/channel/270676-lean4/topic/Transparency.20in.20CanonM/near/482363113\">said</a>:</p>\n<blockquote>\n<ul>\n<li><code>reduce (explicitOnly := true) (skipTypes := false) (skipProofs := true)</code></li>\n<li><code>canon</code></li>\n</ul>\n</blockquote>\n<p>This one. So reduce in explicit arguments (and types?) with reducible transparency before canonicalising. Afaict, this should ensure that expressions are considered equal iff they are reducibly defeq.</p>",
        "id": 482502391,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1731627610
    },
    {
        "content": "<p>Oh! I didn't understand that those were intended sequentially.</p>",
        "id": 482504421,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1731628776
    },
    {
        "content": "<p>Unfortunately I don't have a great benchmark for the problem cases where we introduced <code>CanonM</code> for <code>omega</code>.</p>",
        "id": 482504671,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1731628863
    },
    {
        "content": "<p>Maybe if we can produce such a benchmark again we could see how expensive adding a <code>reduce</code> step would be.</p>",
        "id": 482504729,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1731628901
    },
    {
        "content": "<p>Great, thanks! I want to start using this strategy more in Aesop as well, so I'm very curious about the performance implications.</p>",
        "id": 482505125,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1731629050
    },
    {
        "content": "<p>Does <code>reduce</code> have variants for different transparencies? If so (going back to my initial question in this thread) that approach would also allow omega to support a transparency config.</p>",
        "id": 482505167,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731629071
    },
    {
        "content": "<p><code>reduce</code> respects transparency afaik, so <code>withTransparency md &lt;| reduce e</code>.</p>",
        "id": 482506558,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1731629762
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span>, I was thinking about this a bit more today. Should we really expect that reducing <code>a</code> and <code>b</code> (and then doing a quick comparison) is faster than running <code>isDefEq a b</code>? Won't it often happen that <code>a</code> and <code>b</code> are complicated and take a while to reduce, but nonetheless they are very similar structurally (or even the same) and <code>isDefEq</code> can succeed fast?</p>",
        "id": 482707138,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731711137
    },
    {
        "content": "<p>I don't know what algorithm <code>isDefEq</code> implements, but I would hope that it can identify <code>id a</code> and <code>a</code> without reducing them both to some normal form ... and if <code>a</code> is complicated, that should be a lot faster, right?</p>",
        "id": 482707546,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731711407
    },
    {
        "content": "<p>One thing to watch out for when using <code>AtomM</code> / <code>isDefEq</code> is whether you actually want it to assign metavariables, which can probably make it much more expensive</p>",
        "id": 482708826,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731712165
    },
    {
        "content": "<p>I have been noticing lately that in a few places people are relying on the fact that <code>AtomM</code>-based tactics can assign metavariables (e.g. <span class=\"user-mention\" data-user-id=\"464700\">@David Ang</span> does sometimes in the elliptic curves files) ... I think it would be better not to do this!</p>",
        "id": 482709008,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731712277
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/channel/270676-lean4/topic/Transparency.20in.20CanonM/near/482709008\">said</a>:</p>\n<blockquote>\n<p>I have been noticing lately that in a few places people are relying on the fact that <code>AtomM</code>-based tactics can assign metavariables (e.g. <span class=\"user-mention silent\" data-user-id=\"464700\">David Ang</span> does sometimes in the elliptic curves files) ... I think it would be better not to do this!</p>\n</blockquote>\n<p>Should we add a <code>withNewMCtxDepth</code> for now?</p>",
        "id": 482908659,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1731889184
    },
    {
        "content": "<p>I'm not familiar with that function -- this is a fix to prevent tactics from creating goals whose type contains metavariables?  How does it work?</p>",
        "id": 482929157,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731905660
    },
    {
        "content": "<p>Here's an example, anyway, appearing in the library as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WeierstrassCurve.addY_sub_negY_addY#doc\">docs#WeierstrassCurve.addY_sub_negY_addY</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">AlgebraicGeometry</span><span class=\"bp\">.</span><span class=\"n\">EllipticCurve</span><span class=\"bp\">.</span><span class=\"n\">Affine</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">WeierstrassCurve</span><span class=\"w\"> </span><span class=\"n\">Affine</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Affine</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">}</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x₁</span><span class=\"w\"> </span><span class=\"n\">x₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y₁</span><span class=\"w\"> </span><span class=\"n\">y₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">x₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"n\">x₃</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"bp\">.</span><span class=\"n\">addX</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"w\"> </span><span class=\"n\">x₂</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">W</span><span class=\"bp\">.</span><span class=\"n\">slope</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"w\"> </span><span class=\"n\">x₂</span><span class=\"w\"> </span><span class=\"n\">y₁</span><span class=\"w\"> </span><span class=\"n\">y₂</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"n\">y₃</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"bp\">.</span><span class=\"n\">addY</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"w\"> </span><span class=\"n\">x₂</span><span class=\"w\"> </span><span class=\"n\">y₁</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">W</span><span class=\"bp\">.</span><span class=\"n\">slope</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"w\"> </span><span class=\"n\">x₂</span><span class=\"w\"> </span><span class=\"n\">y₁</span><span class=\"w\"> </span><span class=\"n\">y₂</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">y₃</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"bp\">.</span><span class=\"n\">negY</span><span class=\"w\"> </span><span class=\"n\">x₃</span><span class=\"w\"> </span><span class=\"n\">y₃</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">      </span><span class=\"o\">((</span><span class=\"n\">y₂</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"bp\">.</span><span class=\"n\">negY</span><span class=\"w\"> </span><span class=\"n\">x₂</span><span class=\"w\"> </span><span class=\"n\">y₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x₁</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">x₃</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y₁</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"bp\">.</span><span class=\"n\">negY</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"w\"> </span><span class=\"n\">y₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x₂</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">x₃</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x₂</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">addY</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">negY</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">eq_div_iff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sub_ne_zero</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">linear_combination</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">cyclic_sum_Y_mul_X_sub_X</span><span class=\"w\"> </span><span class=\"n\">y₁</span><span class=\"w\"> </span><span class=\"n\">y₂</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n</code></pre></div>",
        "id": 482929256,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731905725
    },
    {
        "content": "<p>If you separate the <code>linear_combination</code> into two steps,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">linear_combination</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">norm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">skip</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">cyclic_sum_Y_mul_X_sub_X</span><span class=\"w\"> </span><span class=\"n\">y₁</span><span class=\"w\"> </span><span class=\"n\">y₂</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"n\">ring</span>\n</code></pre></div>\n<p>you'll see that the <code>ring</code> is solving a goal which contains metavariables.</p>",
        "id": 482929398,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731905801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/channel/270676-lean4/topic/Transparency.20in.20CanonM/near/482929157\">said</a>:</p>\n<blockquote>\n<p>I'm not familiar with that function -- this is a fix to prevent tactics from creating goals whose type contains metavariables?  How does it work?</p>\n</blockquote>\n<p>It increases the context depth, and <code>isDefEq</code> and similar don't assign metavariables with a smaller depth then the context's. There's a few sentences about that in <a href=\"https://leanprover-community.github.io/lean4-metaprogramming-book/main/04_metam.html#metavariable-depth\">https://leanprover-community.github.io/lean4-metaprogramming-book/main/04_metam.html#metavariable-depth</a></p>",
        "id": 482929442,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731905832
    },
    {
        "content": "<p>It is <em>correctly</em> (for this application) identifying atoms which could be unified, and unifying them.</p>",
        "id": 482929460,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731905844
    },
    {
        "content": "<p>But I think it's dangerous to be relying on this -- and in fact this is a sign that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WeierstrassCurve.cyclic_sum_Y_mul_X_sub_X#doc\">docs#WeierstrassCurve.cyclic_sum_Y_mul_X_sub_X</a> should change its <code>W</code> argument from implicit to explicit.</p>",
        "id": 482929595,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731905918
    },
    {
        "content": "<p>Yes, I think adding a  <code>withNewMCtxDepth</code> would prevent it from doing something correct, but which we do not want it to do!</p>",
        "id": 482937572,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1731910300
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/channel/270676-lean4/topic/Transparency.20in.20CanonM/near/482707138\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span>, I was thinking about this a bit more today. Should we really expect that reducing <code>a</code> and <code>b</code> (and then doing a quick comparison) is faster than running <code>isDefEq a b</code>? Won't it often happen that <code>a</code> and <code>b</code> are complicated and take a while to reduce, but nonetheless they are very similar structurally (or even the same) and <code>isDefEq</code> can succeed fast?</p>\n</blockquote>\n<p>For one-off comparisons, <code>isDefEq</code> is indeed much faster than full reduction + equality check. However, I think it's possible that when an expression participates in many comparisons, the eager reduction (at reducible transparency, which is hopefully not too costly) pays off. Eager reduction might also allow us to use more fancy techniques from automated reasoning, e.g. faster indexing schemes. I don't have any data on this yet, but I think it's an interesting research direction.</p>",
        "id": 483084034,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1731951945
    },
    {
        "content": "<p>Interesting, thanks!</p>",
        "id": 483085587,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731952375
    },
    {
        "content": "<p>(but noting this is a research direction: I don't think we want to be running <code>reduce</code> before <code>canon</code> in any Mathlib tactics at this point)</p>",
        "id": 483182330,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1731992143
    }
]