[
    {
        "content": "<p>I find that the example in the tutorial (<a href=\"https://lean-lang.org/theorem_proving_in_lean4/axioms_and_computation.html#quotients\">https://lean-lang.org/theorem_proving_in_lean4/axioms_and_computation.html#quotients</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Quot</span><span class=\"bp\">.</span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">f_respects</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">mod7Rel</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>uses the feature that the kernel <strong>automatically</strong> simplifies <code>Quot.lift f f_respects (Quot.mk mod7Rel a)</code> into <code>f a</code>. Is there an <strong>explicit axiom</strong> for the Quot type that justifies this simplification behavior? Specifically, I am looking for an explicit axiom that connects Quot.lift and <a href=\"http://Quot.mk\">Quot.mk</a> in this manner, instead of relying on the kernel’s implicit behavior.</p>",
        "id": 503941112,
        "sender_full_name": "Lingwei Peng (彭灵伟)",
        "timestamp": 1741319085
    },
    {
        "content": "<p>There's no axiom in the <code>axiom</code> sense at least.</p>\n<p>You should take a look at the docstrings in the Prelude: <a href=\"https://github.com/leanprover/lean4/blob/e9f2e1861e746c2aba134215e56fcd6e7eb62d50/src/Init/Prelude.lean#L382-L440\">https://github.com/leanprover/lean4/blob/e9f2e1861e746c2aba134215e56fcd6e7eb62d50/src/Init/Prelude.lean#L382-L440</a></p>\n<p>These are all part of the definition of quotients. You should think of it as being why inductive recursors have simplification rules too. Their definitional equality properties are part of the theory.</p>",
        "id": 503945229,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741321561
    },
    {
        "content": "<p>(When I skimmed it, I didn't find the reduction rule at first, but rereading I see it's on the <code>Quot.lift</code> docstring in words.)</p>",
        "id": 503945405,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741321666
    },
    {
        "content": "<p>If you want the justification for this rule, a way to think about it is that <code>Quot X</code> is \"<code>X</code> with a different <code>Eq</code>\". That's to say, <code>Quot X</code> can be represented as <code>X</code> itself, but (1) you're allowed to prove that more things are <code>Eq</code> than there \"really\" are (using the relation), and (2) if you have a function <code>f : X -&gt; Y</code> with the property that <code>f x = f y</code> whenever <code>x</code> is related to <code>y</code>, then it's safe to make a function <code>Quot X -&gt; Y</code> that evaluates <code>f</code> on the underlying <code>X</code> element of the <code>Quot X</code> element. That is, we can have a reduction rule where <code>Quot.lift f pf (Quot.mk R x)</code> evaluates to <code>f x</code>.</p>",
        "id": 503949722,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741324066
    },
    {
        "content": "<p>Thanks</p>",
        "id": 504238599,
        "sender_full_name": "Lingwei Peng (彭灵伟)",
        "timestamp": 1741412866
    }
]