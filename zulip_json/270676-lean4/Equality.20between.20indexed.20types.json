[
    {
        "content": "<p>Is there a general pattern for handling equality of two terms of an indexed type where the indexes are not definitionally equal but are propositionally equal? The equality can't be stated since they aren't definitionally equal, and trying to do rewrites in the definition itself introduces a lot of <code>Eq.mp</code>/<code>Eq.mpr</code> which makes reasoning about them extremely hard in my experience. I can try to come up with an example, but I've run into this a lot and just wanted to see if there's an agreed upon approach.</p>\n<p>I know in Agda, for example, you can state rewrite rules for propositional equality and then you can state the equality since they will unify.</p>",
        "id": 356607410,
        "sender_full_name": "Scott Godwin",
        "timestamp": 1683527876
    },
    {
        "content": "<p>Are you looking for coercions by any chance? There is the Coe typeclass if that is the case.</p>",
        "id": 356612288,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683529466
    },
    {
        "content": "<p>There is also <code>HEq</code>, which is a heterogeneous equality.</p>",
        "id": 356612739,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1683529613
    },
    {
        "content": "<p>Here is a highly contrived example that illustrates what I mean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">baz</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>In the definition of <code>baz</code> itself, I can't call <code>bar f₁ f₂</code> because their indexes are not definitionally equal, but they are propositionally equal.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/Equality.20between.20indexed.20types/near/356612288\">said</a>:</p>\n<blockquote>\n<p>Are you looking for coercions by any chance? There is the Coe typeclass if that is the case.</p>\n</blockquote>\n<p>I haven't actually used <code>Coe</code> before, but it doesn't seem like it's appropriate in this situation?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/270676-lean4/topic/Equality.20between.20indexed.20types/near/356612739\">said</a>:</p>\n<blockquote>\n<p>There is also <code>HEq</code>, which is a heterogeneous equality.</p>\n</blockquote>\n<p>Sometimes you can do that, but like the example above, I don't see how you'd use it.</p>",
        "id": 356615780,
        "sender_full_name": "Scott Godwin",
        "timestamp": 1683530653
    },
    {
        "content": "<p>I don't know myself how to make proper use of HEq but you can go like so if you want:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">lhs</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rhs</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">lhs</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">rhs</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">baz</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span> <span class=\"o\">(</span><span class=\"n\">Nat.add_comm</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>or alternatively:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">lhs</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rhs</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">lhs</span> <span class=\"bp\">=</span> <span class=\"n\">rhs</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">baz</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"n\">f₁</span> <span class=\"o\">((</span><span class=\"n\">Nat.add_comm</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">▸</span> <span class=\"n\">f₂</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 356616229,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1683530814
    },
    {
        "content": "<p>Coercions will work well for this example. You need to define coercions for <code>Foo (n+m)</code> and <code>Foo (m+n)</code>. Alternatively in this particular case <code>Nat.add_comm _  _ \\t term</code> also helps</p>",
        "id": 356617422,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683531228
    },
    {
        "content": "<p>(Replace <code>\\t</code> with the Unicode variant)</p>",
        "id": 356617605,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683531266
    },
    {
        "content": "<p>Rather than using the coercion framework people usually get around this by writing a bespoke wrapper for <code>Eq.rec</code> and training the simplifier on it. See for example <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.eq_to_hom\">docs#category_theory.eq_to_hom</a> in the lean 3 category theory library; it produces a morphism A -&gt; B from a proof of A=B. </p>\n<p>This issue is a standard thorn in the side of dependent type theory</p>",
        "id": 356618864,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683531628
    },
    {
        "content": "<p>You might also like to see how <code>Fin n</code> works.</p>",
        "id": 356640219,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683537196
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin#doc\">docs4#Fin</a></p>",
        "id": 356643241,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683537963
    },
    {
        "content": "<p>Thanks for the responses. I'll admit that when casting starts getting involved, I start getting a bit lost. It obviously makes sense to do it, but then I run into situations where I need to give a term of an indexed  type <code>SomeType (... a ... )</code> but I instead I have something like <code>SomeType (... (Eq.mp _ a) ...)</code> and I'm just not sure how to proceed. For example, this is the actual error message I'm stuck on (trying to prove strong normalization of the STLC as an exercise):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">h</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">HereditarilyNormalizing</span>\n    <span class=\"o\">(</span><span class=\"n\">Expr.application</span>\n      <span class=\"o\">(</span><span class=\"n\">application</span><span class=\"bp\">ᵣ</span> <span class=\"n\">fs</span>\n        <span class=\"o\">(</span><span class=\"n\">Eq.mpr</span>\n          <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span>\n            <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">arrow</span><span class=\"bp\">ᵣ</span> <span class=\"o\">(</span><span class=\"n\">Ty.arrow</span> <span class=\"n\">f.τ</span> <span class=\"n\">τ'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f.τ</span><span class=\"o\">)</span> <span class=\"n\">fs</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n              <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">arrow</span><span class=\"bp\">ᵣ</span> <span class=\"n\">τ'</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f.τ</span><span class=\"o\">)</span> <span class=\"n\">fs</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">f.τ</span><span class=\"o\">])))</span>\n          <span class=\"o\">(</span><span class=\"n\">Eq.mpr</span>\n            <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span>\n              <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">arrow</span><span class=\"bp\">ᵣ</span> <span class=\"n\">τ'</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f.τ</span><span class=\"o\">)</span> <span class=\"n\">fs</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">f.τ</span><span class=\"o\">]))</span> <span class=\"bp\">=</span>\n                <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">List.foldr</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">τ'</span> <span class=\"n\">τ</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Ty.arrow</span> <span class=\"n\">τ'</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Ty.arrow</span> <span class=\"n\">f.τ</span> <span class=\"n\">τ'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f.τ</span><span class=\"o\">)</span> <span class=\"n\">fs</span><span class=\"o\">)))</span>\n            <span class=\"o\">(</span><span class=\"n\">Eq.mp</span>\n              <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span>\n                <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">arrow</span><span class=\"bp\">ᵣ</span> <span class=\"n\">τ'</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f.τ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fs</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">])))</span> <span class=\"bp\">=</span>\n                  <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span>\n                    <span class=\"n\">List.foldr</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">τ'</span> <span class=\"n\">τ</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Ty.arrow</span> <span class=\"n\">τ'</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">List.foldr</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">τ'</span> <span class=\"n\">τ</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Ty.arrow</span> <span class=\"n\">τ'</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"n\">τ'</span> <span class=\"o\">[</span><span class=\"n\">f.τ</span><span class=\"o\">])</span>\n                      <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f.τ</span><span class=\"o\">)</span> <span class=\"n\">fs</span><span class=\"o\">)))</span>\n              <span class=\"o\">(</span><span class=\"n\">Expr.var</span>\n                <span class=\"o\">(</span><span class=\"n\">Eq.mpr</span>\n                  <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span>\n                    <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">∋</span> <span class=\"n\">arrow</span><span class=\"bp\">ᵣ</span> <span class=\"n\">τ'</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f.τ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fs</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">])))</span> <span class=\"bp\">=</span>\n                      <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">∋</span> <span class=\"n\">List.foldr</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">τ'</span> <span class=\"n\">τ</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Ty.arrow</span> <span class=\"n\">τ'</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"n\">τ'</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f.τ</span><span class=\"o\">)</span> <span class=\"n\">fs</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">τ</span><span class=\"o\">])))</span>\n                  <span class=\"o\">(</span><span class=\"n\">Eq.mpr</span>\n                    <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span>\n                      <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">∋</span> <span class=\"n\">List.foldr</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">τ'</span> <span class=\"n\">τ</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Ty.arrow</span> <span class=\"n\">τ'</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"n\">τ'</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f.τ</span><span class=\"o\">)</span> <span class=\"n\">fs</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">τ</span><span class=\"o\">]))</span> <span class=\"bp\">=</span>\n                        <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">∋</span> <span class=\"n\">List.foldr</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">τ'</span> <span class=\"n\">τ</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Ty.arrow</span> <span class=\"n\">τ'</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Ty.arrow</span> <span class=\"n\">τ</span> <span class=\"n\">τ'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f.τ</span><span class=\"o\">)</span> <span class=\"n\">fs</span><span class=\"o\">)))</span>\n                    <span class=\"n\">a</span><span class=\"o\">)))))))</span>\n      <span class=\"n\">e'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">HereditarilyNormalizing</span> <span class=\"o\">(</span><span class=\"n\">Expr.application</span> <span class=\"o\">(</span><span class=\"n\">application</span><span class=\"bp\">ᵣ</span> <span class=\"n\">fs</span> <span class=\"o\">(</span><span class=\"n\">Expr.var</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"n\">e'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n</code></pre></div>\n<p>I'm sure it could be cleaned up significantly, but was just trying to get it to typecheck first. I don't really expect anyone to figure it out from that and I don't really know of a good way to create a MWE, just noting that my types become polluted with all these <code>Eq.mp</code>/<code>Eq.mpr</code>s after doing these kinds of casts.</p>",
        "id": 356644140,
        "sender_full_name": "Scott Godwin",
        "timestamp": 1683538207
    },
    {
        "content": "<p>In addition to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.eqToHom#doc\">docs4#CategoryTheory.eqToHom</a>, two other mathlib case studies in having functions to manipulate indices into the right form are <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Walk.copy#doc\">docs4#SimpleGraph.Walk.copy</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quiver.Hom.cast#doc\">docs4#Quiver.Hom.cast</a></p>",
        "id": 356646285,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683538695
    },
    {
        "content": "<p>I didn't actually test this, but a way this design pattern could apply in this case is like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Foo.cast</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">baz</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"n\">f₁</span> <span class=\"o\">(</span><span class=\"n\">f₂.cast</span> <span class=\"o\">(</span><span class=\"n\">add_comm</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 356646825,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683538820
    },
    {
        "content": "<p>Unrestricted <code>Eq.mpr</code>/<code>Eq.rec</code>/etc. tend to be annoying to work with; having a wrapper helps constrain exactly what is being rewritten.</p>",
        "id": 356647039,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683538877
    },
    {
        "content": "<p>If you look in the <code>SimpleGraph.Walk</code> module, you can take a look at how helper lemmas for the wrapper are proved. You usually write lemmas where the index equalities are between <em>variables</em> (rather than arbitrary expressions), then start the proof with <code>subst_vars</code>. Many times then the proof of the helper lemmas is <code>rfl</code> after this.</p>",
        "id": 356647542,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683538964
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/tensor_power.cast\">docs#tensor_power.cast</a> is another example. Note this is an example of it often being nicer not to just use the triangle.</p>",
        "id": 356649121,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683539356
    },
    {
        "content": "<p>(<a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin.cast\">docs#fin.cast</a> being the other main example of that pattern)</p>",
        "id": 356649613,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683539452
    },
    {
        "content": "<p>Thanks, I'll try defining <code>cast</code> and the corresponding lemmas on the related indexed types and see where that gets me.</p>",
        "id": 356650921,
        "sender_full_name": "Scott Godwin",
        "timestamp": 1683539763
    },
    {
        "content": "<p>Spent some time on this, defining all the cast lemmas etc and was able to get the proof to go through (or at least the part I was having trouble with, still have a couple more to go)! Thanks again for the help everyone!</p>",
        "id": 356680671,
        "sender_full_name": "Scott Godwin",
        "timestamp": 1683547159
    }
]