[
    {
        "content": "<p>Hello! I have a question on the compiler: when I open my package in VSCode, the CPU runs at 100% with 8 threads compiling at the same time. When I type <code>lake build</code> on the same project, I can only see one thread. I tried to use the flag <code>--threads=8</code>, but I don't see any difference. What am I doing wrong or misunderstanding?<br>\nRunning on Windows 10 with <code>leanprover/lean4:nightly-2023-07-12</code></p>",
        "id": 391226113,
        "sender_full_name": "G G",
        "timestamp": 1694798648
    },
    {
        "content": "<p>I was under the impression it used all the threads by default..... let me test</p>",
        "id": 391228793,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694799545
    },
    {
        "content": "<p>Yeah, on my machine <code>lake build</code> with no flags uses all cores.</p>\n<p>Note that lake caches the files it builds, so unless you're doing <code>lake clean</code> it probably doesn't need to do much work on subsequent builds.</p>",
        "id": 391229151,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694799674
    },
    {
        "content": "<p>mathlib is already cached. I have a single big file in my package: is it because a single file takes a single thread only?</p>",
        "id": 391230845,
        "sender_full_name": "G G",
        "timestamp": 1694800266
    },
    {
        "content": "<p>Yep, the multithreading is only between files</p>",
        "id": 391231030,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694800336
    },
    {
        "content": "<p>If your file is getting slow enough that you think \"I wish I could compile on multiple threads\", that means you should split up the file <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 391231076,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694800360
    },
    {
        "content": "<p>(for the server, calculating the dependency graph between files is just much cheaper than calculating the dependencies between individual definitions, because you write out file dependencies as imports. so you get quite good CPU utilization with minimal overhead on mathlib-sized projects)</p>",
        "id": 391231374,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694800461
    },
    {
        "content": "<p>I see! The file is autogenerated that's the reason it's very long! I shall improve the code generation</p>",
        "id": 391231779,
        "sender_full_name": "G G",
        "timestamp": 1694800610
    },
    {
        "content": "<p>I believe that this is a regression from Lean 3, which I think could use multiple threads on one file (the orange bars were not always a continuous segment in Lean 3).</p>",
        "id": 391232175,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694800740
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"650503\">G G</span> has marked this topic as resolved.</p>",
        "id": 391259808,
        "sender_full_name": "Notification Bot",
        "timestamp": 1694810422
    }
]