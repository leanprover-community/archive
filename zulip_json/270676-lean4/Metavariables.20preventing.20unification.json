[
    {
        "content": "<p>I'm running into a puzzling situation. I've been able to minimize it to the following MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">tester</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tester</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HList</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- Doesn't unify</span>\n<span class=\"w\">    </span><span class=\"n\">with_unfolding_all</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- Does unify</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>I would expect the first <code>try rfl</code> to work. It seems like the unresolved metavariable is preventing Lean from seeing through the defeq (if you fill in the metavariable before trying <code>rfl</code> it works with no problem) though... If that was it, I suppose I'd be satisfied with \"this just doesn't work\". The weird thing is <code>with_unfolding_all</code> must be doing something beyond just unfolding definitions, because <code>with_unfolding_all rfl</code> does work, despite the metavariable still being there!</p>\n<p>I've tried to parse through the <code>trace.Meta.isDefEq</code> traces but I wasn't able to gather much from them (maybe I should be looking at something else?) What exactly is preventing the unification from going through in the first case, and what is <code>with_unfolding_all</code> doing to make it work in the second?</p>",
        "id": 507429296,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1742632154
    },
    {
        "content": "<p>It's because <code>match</code> is semireducible</p>",
        "id": 507445364,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1742645077
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> is there any way to control that? For example, the same works for Lists:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">tester2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tester2</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"mi\">17</span>\n</code></pre></div>\n<p>Making the HList matcher reducible would definitely help, given we have examples like this all over our codebase.</p>",
        "id": 507451639,
        "sender_full_name": "Marcin Kostrzewa",
        "timestamp": 1742649995
    },
    {
        "content": "<p>defeq doesn't always play nice with metavariables.<br>\ntry:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tester</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HList</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨?_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 507491013,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1742676521
    },
    {
        "content": "<p>Thanks, but this is just an artificial example distilled down from the actual problem. The actual problem pops up in a custom tactic that uses <code>apply</code> with user-provided theorems. So to avoid these mvars we'd have to parse the provided theorem and figure out the assignments ourselves – not impossible, but pretty much duplicating the work that <code>apply</code> should be doing and re-solving the problem that mvars were invented to solve. If we could just get the HList recursor to play nicely that would be awesome. Also not ruling out just bumping the transparency setting for that tactic, but I'm worried about the performance impact of that.</p>",
        "id": 507495977,
        "sender_full_name": "Marcin Kostrzewa",
        "timestamp": 1742680086
    },
    {
        "content": "<p>You can try to use <code>goal.apply e { newGoals := .all }</code> (MVarId.apply) if you want to avoid this problem</p>",
        "id": 507510783,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1742692664
    },
    {
        "content": "<p>(I don't know what exactly your tactic aims to do so I can't tell whether this applies)</p>",
        "id": 507510942,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1742692791
    },
    {
        "content": "<p>With batteries, you can also use <code>fapply</code> if you want macro instead of elaboration</p>",
        "id": 507511011,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1742692837
    },
    {
        "content": "<p>So the whole issue happens inside the call to <code>apply</code>, our problem is not \"we ended up with weird mvars\", the problem is \"<code>apply</code> creates mvars and then cannot unify the term it created with the goal\". We start from an mvar-free goal, try to apply a theorem and <code>apply</code> fails and deep within the traces of <code>isDefEq</code>s the actual reason for failure _looks like_ what we've recreated with the <code>apply Exists.intro</code> above. But the mvar that blocks the unification is not the result of us doing something weird, it's the result of <code>apply</code> working correctly and then <code>isDefEq</code> not being able to deal with that.</p>\n<p>And the transparency stuff comes in at the apply level – we have <code>apply foo</code> failing and <code>with_unfolding_all apply foo</code> succeeding. We've just trimmed it down to this tiny repro to avoid having to copy-paste a bajillion auxiliary definitions. Sorry if I wasn't clear enough with the real nature of this.</p>",
        "id": 507517467,
        "sender_full_name": "Marcin Kostrzewa",
        "timestamp": 1742698131
    }
]