[
    {
        "content": "<p>Running <code>time lean</code> on <a href=\"/user_uploads/3121/lpTtSp3UhsaBuVpyIAv6zlmT/test_33_extra.lean\">test_33_extra.lean</a> gives 138.28s user 9.81s system 95% cpu 2:34.67 total.  Running <code>grep '^\\[' | grep -o '\\[[0-9][^]]*\\]' | grep -o '[0-9\\.]*' | awk '{s+=$1} END {print s}'</code> on <a href=\"/user_uploads/3121/DpHx4U2-hfzcB122oN0jvkX2/log\">the output</a> gives 0.500827, which is much smaller.  Where is all the time going?  (And how do I make Lean faster on this?). (I'm using Lean (version 4.18.0, arm64-apple-darwin23.6.0, commit 11ccbced7964, Release))</p>",
        "id": 513307174,
        "sender_full_name": "Jason Gross",
        "timestamp": 1745183308
    },
    {
        "content": "<p>I guess <code>lean --profile</code> shows that most of the time is spent parsing...</p>",
        "id": 513441054,
        "sender_full_name": "Jason Gross",
        "timestamp": 1745256952
    },
    {
        "content": "<p>It seems that 40 min spent on parsing (on a larger version of this file) is a bit egregious.  What's the complicated thing the parser is doing?</p>",
        "id": 513451809,
        "sender_full_name": "Jason Gross",
        "timestamp": 1745261257
    },
    {
        "content": "<p>there used to be an issue with exponential parsing due to backtracking. This was fixed using a cache, but my guess is that your example is somehow foiling the cache strategy</p>",
        "id": 513452312,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745261455
    },
    {
        "content": "<p>The example is basically one big S-expression (a bunch of nested applications), cf also <a href=\"https://github.com/leanprover/lean4/issues/8038\">https://github.com/leanprover/lean4/issues/8038</a>.  What's the backtracking that would be going on?  / how would you debug whether it's due to cache misses?</p>",
        "id": 513452793,
        "sender_full_name": "Jason Gross",
        "timestamp": 1745261658
    },
    {
        "content": "<p>There is also an issue that I think was never properly fixed where if you do not manually factor your grammar, e.g. using <code>\"(\" term (\":\" term)? \")\"</code> instead of <code>\"(\" term \")\"</code> and <code>\"(\" term \":\" term\")\"</code> as separate productions, then backtracking is triggered. Most of these cases were solved in lean by manually factoring, but this is no help if a lean syntax looks similar to a user syntax. If it's two user syntaxes then there is hope you can do the factoring yourself</p>",
        "id": 513452826,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745261672
    },
    {
        "content": "<p>The code is just</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n<span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">Test</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eq_haa_a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">maxRecDepth</span><span class=\"w\"> </span><span class=\"mi\">150000</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(((</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">(((</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">(((</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">more</span><span class=\"w\"> </span><span class=\"n\">stuff</span><span class=\"w\"> </span><span class=\"n\">here</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"o\">}</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Test</span>\n</code></pre></div>\n<p>Is there conflicting user syntax in Std.Tactic?</p>",
        "id": 513453070,
        "sender_full_name": "Jason Gross",
        "timestamp": 1745261764
    },
    {
        "content": "<p>no, Std is in core too</p>",
        "id": 513453104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745261785
    },
    {
        "content": "<p>all core syntax is defined in one place</p>",
        "id": 513453147,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745261804
    },
    {
        "content": "<p>so this is the app elaborator indeed</p>",
        "id": 513453160,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745261811
    },
    {
        "content": "<p>You don't even need to import <code>Std.Tactic</code> for this right?</p>",
        "id": 513453180,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1745261818
    },
    {
        "content": "<p>As for how to debug, I guess you should look at a trace message for the parser-category parser, not sure if one exists</p>",
        "id": 513453192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745261822
    },
    {
        "content": "<p><span aria-label=\"this\" class=\"emoji emoji-1f446\" role=\"img\" title=\"this\">:this:</span> even if the declarations don't exist it would presumably take forever parsing before realizing this</p>",
        "id": 513453272,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745261855
    },
    {
        "content": "<p>I tried</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">profiler</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">profiler</span><span class=\"bp\">.</span><span class=\"n\">threshold</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"n\">true</span>\n</code></pre></div>\n<p>but this does not include parsing.   (Does this bit require <code>Std.Tactic</code>?) <code>--profile</code> shows time spent parsing, but does not give details.</p>",
        "id": 513453371,
        "sender_full_name": "Jason Gross",
        "timestamp": 1745261887
    },
    {
        "content": "<p>you can't <code>#time</code> parsing, because by the time you know you are timing you've already parsed</p>",
        "id": 513453428,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745261912
    },
    {
        "content": "<p>Yeah I don't think the parsing was ever hooked up to the verbose profiler unfortunately, but I think it definitely should be.</p>",
        "id": 513453506,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1745261943
    },
    {
        "content": "<p>sure, but even if I call the <code>set_option</code>s above the section start, parsing still does not show up</p>",
        "id": 513453511,
        "sender_full_name": "Jason Gross",
        "timestamp": 1745261945
    },
    {
        "content": "<p>The entries in <code>trace.profiler</code> are manually created by the meta programs with <code>withTraceNode</code> and the parser is presumably lacking such a trace node right now</p>",
        "id": 513453606,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1745261993
    },
    {
        "content": "<p>actually you might have trouble doing that, it looks like <code>withTraceNode</code> requires an IO extending monad and I think the parser monad is pure</p>",
        "id": 513453890,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745262090
    },
    {
        "content": "<p>actually there isn't even a monad</p>",
        "id": 513453995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745262123
    },
    {
        "content": "<p>it's all explicit state passing</p>",
        "id": 513454032,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745262132
    }
]