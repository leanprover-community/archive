[
    {
        "content": "<p>I didn't find any free monad type implemented, so I tried to implement one myself. However, I get a strange error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">FreeM</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pure</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">FreeM</span> <span class=\"n\">m</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">joined</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">FreeM</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">FreeM</span> <span class=\"n\">m</span> <span class=\"n\">α</span>\n</code></pre></div>\n<blockquote>\n<p>(kernel) arg <a href=\"https://github.com/leanprover-community/mathlib/pull/3\">#3</a> of 'FreeM.joined' contains a non valid occurrence of the datatypes being declared</p>\n</blockquote>\n<p>Can someone please explain what's wrong and how to make a free monad type in Lean?</p>\n<p>Thanks,<br>\nTage</p>",
        "id": 349327430,
        "sender_full_name": "Tage Johansson",
        "timestamp": 1681467721
    },
    {
        "content": "<p>Adding  the word <code>unsafe</code> would presumably fix it</p>",
        "id": 349330213,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681468417
    },
    {
        "content": "<p>This is the strict positivity restriction, which (necessarily) disallows this type. Do we have any documentation on this? #positivity?</p>",
        "id": 349330300,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1681468442
    },
    {
        "content": "<p>I can add <code>unsafe</code>. But what implications would that have. I think that someone needs to know what he/she is doing when using such a keyword.<br>\nOr is there any other way to implement free monads in Lean that is more safe?</p>",
        "id": 349339028,
        "sender_full_name": "Tage Johansson",
        "timestamp": 1681470437
    },
    {
        "content": "<p><code>unsafe</code> means \"anything that uses this construction will also be <code>unsafe</code>\", and any proof marked <code>unsafe</code> cannot be trusted. If all you care about is executing (rather than verifying) code, then <code>unsafe</code> is no concern</p>",
        "id": 349340298,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681470760
    },
    {
        "content": "<p>Lean forces you to add <code>unsafe</code> here in the first place because <code>inductive</code> types that recurse in this way cannot be trusted in proofs</p>",
        "id": 349340483,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681470829
    },
    {
        "content": "<p><a href=\"https://blog.poisson.chat/posts/2021-10-20-initial-final-free-monad.html\">This blog post</a> shows how (some representation of) the free monad can be defined in a way that doesn't  fall foul of strict positivity.</p>",
        "id": 349341491,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1681471082
    },
    {
        "content": "<p>funny thing I discovered whilst trying to learn from the blogpost: why does this code work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Logic.Unique</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">id</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Unique</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">inferInstance</span><span class=\"o\">,</span>\n <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">h</span>\n            <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>but if you comment out the <code>apply h</code>, it doesn't? :)</p>",
        "id": 349356941,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1681473868
    },
    {
        "content": "<p>I found this in Lean3 where this solution was originally given by <code>hint</code>, but I think the sneaky thing is even less obvious in Lean4</p>",
        "id": 349357155,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1681473914
    },
    {
        "content": "<p>(oh, this isn't true, don't mind me - I did a very cursory reading of the thing and now realise that this is nonsense... - the Lean issue caused is funny though!)</p>",
        "id": 349359556,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1681474406
    },
    {
        "content": "<p>but without choice, <code>∀ α, α → α</code> is unique, right?</p>",
        "id": 349369471,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1681476178
    },
    {
        "content": "<p>or well it's undecidable whether it has anything else than <code>id</code></p>",
        "id": 349369517,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1681476190
    },
    {
        "content": "<p>This sounds like the \"theorems for free\" paper. If you don't allow stuff like \"if alpha = nat then \\lam x, 0 else id\" then yes, you can only have id. I guess the theorems for free paper explains the assumptions necessary to make this true (but possibly not provable).</p>",
        "id": 349370660,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1681476467
    },
    {
        "content": "<p>It's false with choice, undecidable without, and true with parametricity, though I do not know of any proof-assistant that implements parametricity in its core theory.</p>",
        "id": 349370833,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1681476505
    },
    {
        "content": "<p>the blogpost actually mentions theorems for free</p>",
        "id": 349371064,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1681476560
    },
    {
        "content": "<p>parametricity (which gives you uniqueness of <code>∀ α, α → α</code>) and LEM are essentially opposites, and you can prove a strong result about this in HoTT for example: &lt;<a href=\"https://homotopytypetheory.org/2016/02/24/parametricity-and-excluded-middle/\">https://homotopytypetheory.org/2016/02/24/parametricity-and-excluded-middle/</a>&gt;</p>\n<p>but parametricity is a hard result to internalize into a theory (in particular, if you had a generic proof of parametricity for polymorphic functions, the proof won’t itself be parametric)</p>",
        "id": 349371459,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1681476618
    },
    {
        "content": "<p>also, undecidable isn’t the right word to be using here, it should technically be called independent (of the axioms), as in the independence of the continuum hypothesis</p>",
        "id": 349372029,
        "sender_full_name": "Verity Scheel",
        "timestamp": 1681476728
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span>, that works because you didn't write what you intended to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">oops</span> <span class=\"o\">:</span> <span class=\"n\">Unique</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">inferInstance</span><span class=\"o\">,</span>\n <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">h</span>\n            <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">oops</span> <span class=\"c1\">-- oops : Unique (∀ (α : Prop), α → α)</span>\n</code></pre></div>",
        "id": 349372142,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681476755
    },
    {
        "content": "<p>If you use <code>Unique (∀ α : Sort u, α → α)</code> then you'll find you can't prove it</p>",
        "id": 349372558,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681476824
    },
    {
        "content": "<p>no, I know Eric, just thought it was an interesting thing that may be overlooked if you're on autopilot :)</p>",
        "id": 349373134,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1681476933
    },
    {
        "content": "<p>I think it adds weight to the \"<code>Sort _</code> should not mean a free universe metavariable but just a newly instantiated universe\" argument</p>",
        "id": 349373251,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1681476956
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/270676-lean4/topic/Free.20monad/near/349330300\">said</a>:</p>\n<blockquote>\n<p>This is the strict positivity restriction, which (necessarily) disallows this type.</p>\n</blockquote>\n<p>Is strict positivity too strict in this case? Is it possible to prove a contradiction if it were allowed as a type?</p>\n<p>Ah, maybe if <code>α = Empty</code>, you could have <code>m := fun X =&gt; if card X = 0 then Unit else Empty</code>.</p>",
        "id": 349383419,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681478906
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111651\">Verity Scheel</span> <a href=\"#narrow/stream/270676-lean4/topic/Free.20monad/near/349371459\">said</a>:</p>\n<blockquote>\n<p>parametricity (which gives you uniqueness of <code>∀ α, α → α</code>) and LEM are essentially opposites, and you can prove a strong result about this in HoTT for example: &lt;<a href=\"https://homotopytypetheory.org/2016/02/24/parametricity-and-excluded-middle/\">https://homotopytypetheory.org/2016/02/24/parametricity-and-excluded-middle/</a>&gt;</p>\n<p>but parametricity is a hard result to internalize into a theory (in particular, if you had a generic proof of parametricity for polymorphic functions, the proof won’t itself be parametric)</p>\n</blockquote>\n<p>this proof reminds me of Diaconescu's theorem!</p>",
        "id": 349385819,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1681479421
    },
    {
        "content": "<p>I was finally able to implement my <code>FreeM</code> based on the <a href=\"https://blog.poisson.chat/posts/2021-10-20-initial-final-free-monad.html\">article you posted</a>. The definition is quite uggly but I have implemented Monad for it and I have also made a run function <code>FreeM.run [Monad m] (FreeM m a) : m a</code>.<br>\nI have not implemented <code>LawfulMonad</code> though so I can't be absolutely sure it is correct.</p>\n<p>Thans for the help!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\"> - A free monad, which turns any functor `m` into a monad.</span>\n<span class=\"sd\"> - The usual inductive definition of `FreeM` doesn't work in Lean due to strict positivity checking.</span>\n<span class=\"sd\"> - Therefore we use an EQUIVALENT formulation as described</span>\n<span class=\"sd\"> - [here](https://blog.poisson.chat/posts/2021-10-20-initial-final-free-monad.html).</span>\n<span class=\"sd\"> -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">FreeM</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n  <span class=\"o\">((</span><span class=\"n\">FreeMonad</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">FreeMonad</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">FreeMonad</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">FreeMonad</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">FreeMonad</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FreeM.pure</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">FreeM</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Pure.pure</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FreeM.bind</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">FreeM</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">FreeM</span> <span class=\"n\">m</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">FreeM</span> <span class=\"n\">m</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">FreeMonad</span> <span class=\"n\">_</span> <span class=\"n\">join</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Bind.bind</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">FreeMonad</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">FreeMonad</span> <span class=\"n\">join</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">FreeMonad</span> <span class=\"n\">join</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FreeM.run</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">FreeM</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">f</span> <span class=\"n\">m</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">id</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Monad</span> <span class=\"o\">(</span><span class=\"n\">FreeM</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">pure</span> <span class=\"o\">:=</span> <span class=\"n\">FreeM.pure</span>\n  <span class=\"n\">bind</span> <span class=\"o\">:=</span> <span class=\"n\">FreeM.bind</span>\n</code></pre></div>",
        "id": 349986648,
        "sender_full_name": "Tage Johansson",
        "timestamp": 1681487320
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"544752\">@Tage Johansson</span> Here's it cleaned up a little:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">FreeMonad</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Monad</span> <span class=\"n\">m</span> <span class=\"n\">where</span>\n  <span class=\"n\">is_free</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FreeM</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n  <span class=\"o\">((</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">FreeMonad</span> <span class=\"n\">f</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FreeM.pure</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">FreeM</span> <span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Pure.pure</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FreeM.bind</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">FreeM</span> <span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">FreeM</span> <span class=\"n\">f</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">FreeM</span> <span class=\"n\">f</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"n\">m</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">g</span> <span class=\"n\">y</span> <span class=\"n\">m</span> <span class=\"c1\">-- or `x m &gt;&gt;= (g · m)` for short</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">FreeMonad</span> <span class=\"n\">m</span> <span class=\"n\">m</span> <span class=\"n\">where</span>\n  <span class=\"n\">is_free</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">Monad.join</span> <span class=\"c1\">-- or `(· &gt;&gt;= id)` to be mathlib-free</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FreeM.run</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">FreeM</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">m</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Monad</span> <span class=\"o\">(</span><span class=\"n\">FreeM</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">pure</span> <span class=\"o\">:=</span> <span class=\"n\">FreeM.pure</span>\n  <span class=\"n\">bind</span> <span class=\"o\">:=</span> <span class=\"n\">FreeM.bind</span>\n</code></pre></div>\n<p>(I also switched <code>m</code> to <code>f</code> when it's just a function rather than a monad.)</p>",
        "id": 350000823,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681491068
    },
    {
        "content": "<p>To define a <code>LawfulMonad</code> instance I think <code>FreeM</code> needs to be modified to be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">FreeM</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n  <span class=\"o\">((</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">FreeMonad</span> <span class=\"n\">f</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">LawfulMonad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 350007519,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681492812
    },
    {
        "content": "<p>Yep, with this it's lawful:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">FreeMonad</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Monad</span> <span class=\"n\">m</span> <span class=\"n\">where</span>\n  <span class=\"n\">is_free</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FreeM</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n  <span class=\"o\">((</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">FreeMonad</span> <span class=\"n\">f</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">LawfulMonad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FreeM.pure</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">FreeM</span> <span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Pure.pure</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FreeM.bind</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">FreeM</span> <span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">FreeM</span> <span class=\"n\">f</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">FreeM</span> <span class=\"n\">f</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"n\">m</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">·</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">FreeMonad</span> <span class=\"n\">m</span> <span class=\"n\">m</span> <span class=\"n\">where</span>\n  <span class=\"n\">is_free</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">id</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FreeM.run</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LawfulMonad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">FreeM</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">m</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Monad</span> <span class=\"o\">(</span><span class=\"n\">FreeM</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">pure</span> <span class=\"o\">:=</span> <span class=\"n\">FreeM.pure</span>\n  <span class=\"n\">bind</span> <span class=\"o\">:=</span> <span class=\"n\">FreeM.bind</span>\n\n<span class=\"c1\">-- Probably there are more precise proofs!</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">LawfulMonad</span> <span class=\"o\">(</span><span class=\"n\">FreeM</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">map_const</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">id_map</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">funext</span> <span class=\"n\">m</span><span class=\"bp\">;</span> <span class=\"n\">funext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Functor.map</span><span class=\"o\">,</span> <span class=\"n\">FreeM.bind</span><span class=\"o\">,</span> <span class=\"n\">FreeM.pure</span><span class=\"o\">]</span>\n  <span class=\"n\">comp_map</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">funext</span> <span class=\"n\">m</span><span class=\"bp\">;</span> <span class=\"n\">funext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Functor.map</span><span class=\"o\">,</span> <span class=\"n\">FreeM.bind</span><span class=\"o\">,</span> <span class=\"n\">FreeM.pure</span><span class=\"o\">]</span>\n  <span class=\"n\">seqLeft_eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">funext</span> <span class=\"n\">m</span><span class=\"bp\">;</span> <span class=\"n\">funext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Functor.map</span><span class=\"o\">,</span> <span class=\"n\">FreeM.bind</span><span class=\"o\">,</span> <span class=\"n\">FreeM.pure</span><span class=\"o\">,</span> <span class=\"n\">Seq.seq</span><span class=\"o\">,</span> <span class=\"n\">SeqLeft.seqLeft</span><span class=\"o\">]</span>\n  <span class=\"n\">seqRight_eq</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">funext</span> <span class=\"n\">m</span><span class=\"bp\">;</span> <span class=\"n\">funext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Functor.map</span><span class=\"o\">,</span> <span class=\"n\">FreeM.bind</span><span class=\"o\">,</span> <span class=\"n\">FreeM.pure</span><span class=\"o\">,</span> <span class=\"n\">Seq.seq</span><span class=\"o\">,</span> <span class=\"n\">SeqRight.seqRight</span><span class=\"o\">]</span>\n  <span class=\"n\">pure_seq</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">funext</span> <span class=\"n\">m</span><span class=\"bp\">;</span> <span class=\"n\">funext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Functor.map</span><span class=\"o\">,</span> <span class=\"n\">FreeM.bind</span><span class=\"o\">,</span> <span class=\"n\">FreeM.pure</span><span class=\"o\">,</span> <span class=\"n\">Seq.seq</span><span class=\"o\">,</span> <span class=\"n\">pure</span><span class=\"o\">]</span>\n  <span class=\"n\">bind_pure_comp</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">funext</span> <span class=\"n\">m</span><span class=\"bp\">;</span> <span class=\"n\">funext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Functor.map</span><span class=\"o\">,</span> <span class=\"n\">FreeM.bind</span><span class=\"o\">,</span> <span class=\"n\">FreeM.pure</span><span class=\"o\">,</span> <span class=\"n\">pure</span><span class=\"o\">,</span> <span class=\"n\">bind</span><span class=\"o\">]</span>\n  <span class=\"n\">bind_map</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">funext</span> <span class=\"n\">m</span><span class=\"bp\">;</span> <span class=\"n\">funext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Functor.map</span><span class=\"o\">,</span> <span class=\"n\">FreeM.bind</span><span class=\"o\">,</span> <span class=\"n\">FreeM.pure</span><span class=\"o\">,</span> <span class=\"n\">pure</span><span class=\"o\">,</span> <span class=\"n\">bind</span><span class=\"o\">,</span> <span class=\"n\">Seq.seq</span><span class=\"o\">]</span>\n  <span class=\"n\">pure_bind</span> <span class=\"n\">x</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">funext</span> <span class=\"n\">m</span><span class=\"bp\">;</span> <span class=\"n\">funext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Functor.map</span><span class=\"o\">,</span> <span class=\"n\">FreeM.bind</span><span class=\"o\">,</span> <span class=\"n\">FreeM.pure</span><span class=\"o\">,</span> <span class=\"n\">pure</span><span class=\"o\">,</span> <span class=\"n\">bind</span><span class=\"o\">]</span>\n  <span class=\"n\">bind_assoc</span> <span class=\"n\">x</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">funext</span> <span class=\"n\">m</span><span class=\"bp\">;</span> <span class=\"n\">funext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Functor.map</span><span class=\"o\">,</span> <span class=\"n\">FreeM.bind</span><span class=\"o\">,</span> <span class=\"n\">FreeM.pure</span><span class=\"o\">,</span> <span class=\"n\">pure</span><span class=\"o\">,</span> <span class=\"n\">bind</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 350009583,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681493374
    },
    {
        "content": "<p>isn't <code>extends Monad m</code> unsafe there because Lean can't infer <code>f</code>?</p>",
        "id": 350010354,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681493579
    },
    {
        "content": "<p>Hmm, I suppose so from the <code>FreeMonad.toMonad</code> instance; that's an unfortunate restriction. It shouldn't be hard to turn that into a <code>[Monad m]</code> argument to the class and fix everything else up.</p>",
        "id": 350011359,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681493843
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Free.20monad/near/350010354\">said</a>:</p>\n<blockquote>\n<p>isn't <code>extends Monad m</code> unsafe there because Lean can't infer <code>f</code>?</p>\n</blockquote>\n<p>Sorry,  but what do you mean? What is unsafe? Why is it \"unsafe\" to extend with <code>Monad</code>?</p>",
        "id": 350018178,
        "sender_full_name": "Tage Johansson",
        "timestamp": 1681495887
    },
    {
        "content": "<p>It's the standard \"don't write <code>Foo (A B) extends Bar A</code> because the generated <code>Foo.toBar</code> instance has a <code>B</code> that Lean has no way of solving\" problem</p>",
        "id": 350021258,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681496898
    }
]