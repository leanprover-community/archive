[
    {
        "content": "<p>There is a behaviour that I have come to accept about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.withSetOptionIn#doc\">docs#Lean.withSetOptionIn</a> but that I think could be improved.</p>",
        "id": 548306657,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1762002509
    },
    {
        "content": "<p><code>withSetOptionIn</code> is used by virtually all mathlib linters and also some core ones and recursively peels off <code>set_option ... in</code> at the start of a command, before linting the \"inner\" command with the appropriate options set.</p>",
        "id": 548306670,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1762002518
    },
    {
        "content": "<p>The behaviour that I would <em>like</em>, though is that it would see through <em>all</em> <code>set_option ... in</code>, even if they are not the outermost.</p>",
        "id": 548306672,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1762002524
    },
    {
        "content": "<p>Here is an example.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Linter</span><span class=\"bp\">.</span><span class=\"n\">List</span>\n\n<span class=\"c1\">-- warning present</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">indexVariables</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- warning not present</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">indexVariables</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 548306679,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1762002529
    },
    {
        "content": "<p>In the first example, the outermost <code>set_option</code> is correctly processed, the linter sees through it and activates itself in the included command.</p>",
        "id": 548306684,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1762002534
    },
    {
        "content": "<p>In the second example, <code>withSetOptionIn</code> does nothing, since the outermost modifier is <code>variable</code>, which means that the <code>set_option</code> does <em>not</em> get applied to the resulting command and the linter stays off.</p>",
        "id": 548306688,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1762002537
    },
    {
        "content": "<p>Would it be possible to get <code>withSetOptionIn</code> to see through \"all\" modifiers?  Or at least the common ones, like <code>open</code>, <code>variable</code>, maybe also <code>include</code> and <code>omit</code>?</p>",
        "id": 548306690,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1762002538
    },
    {
        "content": "<p>(At the very least, we could have a linter which alerts the user to any unused <code>set_option linter.foo _ in</code>s throughout the syntaxâ€¦but if it can be done in a way that makes sense, actually processing the <code>set_option</code>s would definitely be much better! <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span>)</p>",
        "id": 548328344,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1762020947
    },
    {
        "content": "<p>The unnecessary set_option_in linter is <a href=\"https://github.com/leanprover-community/mathlib4/pull/13653\">#13653</a>, but I do not remember when the last time that I used was...</p>",
        "id": 553241100,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1762085575
    },
    {
        "content": "<p>I've made <a href=\"https://github.com/leanprover-community/mathlib4/pull/31188\">#31188</a> which runs it on current master. Help fixing any true issues it finds is welcome!</p>",
        "id": 553254974,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1762099343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/channel/270676-lean4/topic/withSetOptionIn.20improvement.3F/near/553241100\">said</a>:</p>\n<blockquote>\n<p>The unnecessary set_option_in linter is <a href=\"https://github.com/leanprover-community/mathlib4/pull/13653\">#13653</a>, but I do not remember when the last time that I used was...</p>\n</blockquote>\n<p>Ah, nice! This is a \"heavy-duty\" approach which elaborates the command multiple times, and compares the difference, right? This is definitely great for its purpose/running once in a while, but I'm wondering if we can have a lightweight always-running linter that checks for <code>set_option</code>s which are <em>definitely</em> irrelevant too.</p>",
        "id": 553451364,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1762194230
    },
    {
        "content": "<p>Yes, this was one of my experiment with understanding linters.  With respect to speed, I think that it only acts on syntax that starts with <code>set_option ... in</code> so it should be quick for most declarations.  It also never really worked well for heartbeats, so maybe it could exclude those by default.</p>\n<p>Anyway, a better tool would be great!</p>",
        "id": 553452281,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1762194489
    },
    {
        "content": "<p>Some initial thoughts here on the actual topic:</p>\n<ul>\n<li>The obvious issue is that a few linters will <em>want</em> to lint <code>in</code>-modifiers like <code>variable ... in</code>, or will want to lint <em>certain</em> <code>in</code>-modifiers (e.g. \"just <code>variable</code>). Maybe we could use some API to make processing <code>set_option</code> up to certain <code>in</code>-modifiers convenient, and let those opt-in to that approach, since...</li>\n<li>...Many linters <em>will</em> want to discard <em>all</em> <code>in</code> modifiers. I agree we should make this convenient!</li>\n<li>Some linters will want to go even further, and traverse the syntax tree to find the target of their linting action. Is there API for handling term and tactic mode <code>set_option</code> properly when doing this? I don't believe I've seen it, but I might just be unaware.</li>\n</ul>\n<p>So to summarize, I think we've got three cases:</p>\n<ul>\n<li>Linters that want to lint <code>in</code>-modifiers, broken down into<ul>\n<li>Linters that want to target specific <code>in</code> modifers</li>\n<li>Linters that might target any <code>in</code> modifier</li>\n</ul>\n</li>\n<li>Linters that want to lint the body of a command, and want to skip all <code>in</code>-modifiers</li>\n<li>Linters that traverse the syntax tree, potentially linting anything (terms, tactics, etc.)</li>\n</ul>\n<p>Maybe this kind of breakdown (if we agree it's comprehensive!) can help us figure out what <code>withSetOptionIn</code>-like tools should be available. :)</p>",
        "id": 553453498,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1762194840
    },
    {
        "content": "<p>(And, likewise, if we record what category each linter falls into, we can do cheap linting for \"definitely useless\" <code>set_option</code>s. E.g. a term-mode invocation of <code>set_option linter.foo in</code> definitely won't be used for a command-body linter, etc.)</p>",
        "id": 553458067,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1762195855
    },
    {
        "content": "<p>Before making it so granular, I think that already extracting from a syntax term the <del>maximal</del>minimal subtrees that are themselves commands could be useful.  If those came with a memory of the state of the relevant monads/environment, that would be even better!</p>",
        "id": 553543836,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1762242024
    },
    {
        "content": "<p>If someone is interested in inspecting various combinations of modifiers, it seems fair to let them be on their own!</p>",
        "id": 553544001,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1762242101
    }
]