[
    {
        "content": "<p>how can I fix this?</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>PANIC at _private.Lean.Environment.0.Lean.AsyncConsts.add Lean.Environment:464:4: duplicate normalized declaration name parseByteArray vs. parseByteArray\nbacktrace:\n/home/ubuntu/.elan/toolchains/leanprover--lean4---v4.22.0/lib/lean/libleanshared.so(lean_panic+0xf5) [0x7ffab85a0295]\n/home/ubuntu/.elan/toolchains/leanprover--lean4---v4.22.0/lib/lean/libleanshared.so(lean_panic_fn+0x15) [0x7ffab85a0475]\n/home/ubuntu/.elan/toolchains/leanprover--lean4---v4.22.0/lib/lean/libleanshared.so(l_Lean_Environment_addConstAsync+0xa72) [0x7ffab2acb182]\n/home/ubuntu/.elan/toolchains/leanprover--lean4---v4.22.0/lib/lean/libleanshared.so(l_Lean_addDecl___lam__2+0x75d) [0x7ffab2a298ed]\n/home/ubuntu/.elan/toolchains/leanprover--lean4---v4.22.0/lib/lean/libleanshared.so(l_Lean_addDecl+0x19bb) [0x7ffab2a2d16b]\n/home/ubuntu/.elan/toolchains/leanprover--lean4---v4.22.0/lib/lean/libleanshared.so(l_Array_forIn_x27Unsafe_loop___at_____private_Lean_Elab_PreDefinition_Main_0__Lean_Elab_addSorried_spec__0+0x527) [0x7ffab3a485c7]\n/home/ubuntu/.elan/toolchains/leanprover--lean4---v4.22.0/lib/lean/libleanshared.so(l___private_Lean_Elab_PreDefinition_Main_0__Lean_Elab_addSorried+0x44) [0x7ffab3a49894]\n/home/ubuntu/.elan/toolchains/leanprover--lean4---v4.22.0/lib/lean/libleanshared.so(l_Array_forIn_x27Unsafe_loop___at___Lean_Elab_addPreDefinitions_spec__13___redArg+0x6da9) [0x7ffab3a6c0c9]\n/home/ubuntu/.elan/toolchains/leanprover--lean4---v4.22.0/lib/lean/libleanshared.so(l_Lean_Elab_addPreDefinitions___lam__1+0x57e) [0x7ffab3a6db6e]\n/home/ubuntu/.elan/toolchains/leanprover--lean4---v4.22.0/lib/lean/libleanshared.so(l_Lean_Elab_addPreDefinitions___lam__1___boxed+0xcc) [0x7ffab3a6e61c]\n/home/ubuntu/.elan/toolchains/leanprover--lean4---v4.22.0/lib/lean/libleanshared.so(lean_apply_7+0xc0b) [0x7ffab85b586b]\n</code></pre></div>\n<p>It's not full log. It's just start.</p>",
        "id": 542443425,
        "sender_full_name": "Pavel Klimov",
        "timestamp": 1759309446
    },
    {
        "content": "<p>Renaming the function doesn't help</p>",
        "id": 542446584,
        "sender_full_name": "Pavel Klimov",
        "timestamp": 1759310432
    },
    {
        "content": "<p>What is it that you are doing? <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 542446611,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1759310443
    },
    {
        "content": "<p>I'm just writing normal lean code</p>",
        "id": 542446717,
        "sender_full_name": "Pavel Klimov",
        "timestamp": 1759310474
    },
    {
        "content": "<p>no magic</p>",
        "id": 542446860,
        "sender_full_name": "Pavel Klimov",
        "timestamp": 1759310512
    },
    {
        "content": "<p>Please do provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, we can't help you without seeing what you are doing</p>",
        "id": 542446875,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1759310517
    },
    {
        "content": "<p>oh, ok, will try <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>",
        "id": 542446999,
        "sender_full_name": "Pavel Klimov",
        "timestamp": 1759310546
    },
    {
        "content": "<p>While I'm trying to make mwe, I can tell you also that it also has following error:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>Cannot derive parseByteArray._mutual.eq_def\n  failed to generate equational theorem for 'parseByteArray._mutual'\n</code></pre></div>",
        "id": 542460554,
        "sender_full_name": "Pavel Klimov",
        "timestamp": 1759314783
    },
    {
        "content": "<p>here is <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">async</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Ty</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">width</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">struct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">packed</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elementTypes</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">BEq</span>\n\n<span class=\"kn\">mutual</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">listOfTypesToType</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Empty</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"bp\">.</span><span class=\"n\">toType</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"bp\">.</span><span class=\"n\">toType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">listOfTypesToType</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"bp\">.</span><span class=\"n\">toType</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"n\">width</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">width</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">struct</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">elementTypes</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">listOfTypesToType</span><span class=\"w\"> </span><span class=\"n\">elementTypes</span>\n\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">typeSize</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">struct</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">elementTypes</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elementTypes</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">typeSize</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">typeSizeGeZero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">typeSize</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">typeSize</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">struct</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">elementType</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">typeSize</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">elementType</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">omega</span>\n\n<span class=\"kn\">mutual</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">structParseByteArray</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">packed</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">types</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ByteArray</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">offset</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">        </span><span class=\"n\">Except</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">listOfTypesToType</span><span class=\"w\"> </span><span class=\"n\">types</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">types</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"s2\">\"empty struct\"</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">alignment</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">packed</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">8</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">alignedOffset</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">offset</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">alignment</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">alignment</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">nextOffset</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">alignedOffset</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">8</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">currentData</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">extract</span><span class=\"w\"> </span><span class=\"n\">alignedOffset</span><span class=\"w\"> </span><span class=\"n\">nextOffset</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">parseByteArray</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">currentData</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">first</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">head1</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tail1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">second</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">structParseByteArray</span><span class=\"w\"> </span><span class=\"n\">packed</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">head1</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tail1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"n\">nextOffset</span>\n<span class=\"w\">      </span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">second</span><span class=\"w\"> </span><span class=\"bp\">⟩</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">types</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">typeSize</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"o\">)</span>\n<span class=\"n\">decreasing_by</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">omega</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">typeSizeGeZero</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">parseByteArray</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ByteArray</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">        </span><span class=\"n\">Except</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"bp\">.</span><span class=\"n\">toType</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">struct</span><span class=\"w\"> </span><span class=\"n\">packed</span><span class=\"w\"> </span><span class=\"n\">elementTypes</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">structParseByteArray</span><span class=\"w\"> </span><span class=\"n\">packed</span><span class=\"w\"> </span><span class=\"n\">elementTypes</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throw</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"not implemented\"</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">typeSize</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"n\">decreasing_by</span><span class=\"w\"> </span><span class=\"n\">all_goals</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">typeSize</span><span class=\"o\">]</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 542520215,
        "sender_full_name": "Pavel Klimov",
        "timestamp": 1759331242
    },
    {
        "content": "<p>Opening this in <a href=\"http://live.lean-lang.org\">live.lean-lang.org</a> does not show any errors.</p>",
        "id": 544650904,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1760412295
    },
    {
        "content": "<p>As far as I know, in live lean always most recent version of lean4. My code crash in <code>v4.22.0</code>version.</p>",
        "id": 544698186,
        "sender_full_name": "Pavel Klimov",
        "timestamp": 1760433517
    },
    {
        "content": "<p>Then upgrade. :-)</p>",
        "id": 544716796,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1760439478
    }
]