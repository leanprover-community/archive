[
    {
        "content": "<p>Is it possible to unfold definition of instance in a proof?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Node</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">leaf</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">children</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"o\">)</span>\n\n<span class=\"kn\">mutual</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">beq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">children1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">children2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">listBeq</span><span class=\"w\"> </span><span class=\"n\">children1</span><span class=\"w\"> </span><span class=\"n\">children2</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">listBeq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">beq</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">listBeq</span><span class=\"w\"> </span><span class=\"n\">xs1</span><span class=\"w\"> </span><span class=\"n\">xs2</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">nodeBEqInst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">beq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">beq</span>\n</code></pre></div>\n<p>in proofs, <code>rw [BEq.beq]</code> will translate <code>==</code> into <code>nodeBEqInst.1</code> and then, is there way to convert it into Node.beq and use its definition?</p>",
        "id": 540919098,
        "sender_full_name": "Pavel Klimov",
        "timestamp": 1758594666
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"900336\">@Pavel Klimov</span> keep unfolding:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"bp\">.</span><span class=\"n\">beq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nodeBEqInst</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"n\">only</span>\n</code></pre></div>",
        "id": 540966993,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758619365
    },
    {
        "content": "<p>In this case, <code>simp only [BEq.beq]</code> does the job, because <code>simp only</code> also expands projections.</p>",
        "id": 540968801,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758619901
    },
    {
        "content": "<p>You can also spell it like this: <code>simp only [(· == ·)]</code></p>",
        "id": 540969173,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758620025
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> Thanks! I tried only <code>rw [nodeBEqInst.1]</code> which didn't work. I didn't know about <code>dsimp</code> existence.<br>\n<span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> nice one!</p>\n<p>Sad, though, it doesn't work if BEq instance is given by <code>deriving</code> statement <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>",
        "id": 540987791,
        "sender_full_name": "Pavel Klimov",
        "timestamp": 1758626715
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"900336\">@Pavel Klimov</span> that's because <code>nodeBEqInst.1</code> is actually two things: the <code>nodeBEqInst</code>, and the <code>.1</code>.</p>",
        "id": 540987909,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758626755
    },
    {
        "content": "<p>Yes, if you want to prove anything about the instance, you shouldn't use <code>deriving</code>. I would have suggested trying <code>deriving DecidableEq</code>, but that doesn't seem to work here.</p>",
        "id": 540989172,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758627182
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/270676-lean4/topic/Unfold.20instance.20definition.20in.20a.20proof/near/540989172\">said</a>:</p>\n<blockquote>\n<p>Yes, if you want to prove anything about the instance, you shouldn't use <code>deriving</code></p>\n</blockquote>\n<p>This is (slowly) changing! In the latest nightly, there is now a <code>reduceBEq</code> simproc which will unfold derived <code>BEq</code> instances. Sadly, for now this only works for non-nested inductives, so it's not useful for <span class=\"user-mention silent\" data-user-id=\"900336\">Pavel Klimov</span>'s example yet.</p>",
        "id": 540989985,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1758627453
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> what is <code>.1</code> then? First element of what? Can I specify in <code>rw</code> or <code>simp</code> exactly <code>.1</code> part of <code>nodeBEqInst</code>?</p>",
        "id": 541090882,
        "sender_full_name": "Pavel Klimov",
        "timestamp": 1758658019
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"900336\">@Pavel Klimov</span> it's some built-in notation that means \"the first part of the structure\"</p>",
        "id": 541091128,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758658115
    },
    {
        "content": "<p>I'm getting a bit meta here, but the corresponding <code>Lean.Expr</code> is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr.proj#doc\">docs#Lean.Expr.proj</a> (ignore the meta stuff if it confuses you); the point here is that it's a separate atomic notation and not based on anything else</p>",
        "id": 541091325,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758658202
    },
    {
        "content": "<p>Well, <code>nodeBEqInst</code> is of type <code>BEq Node</code> and <code>BEq</code> is a structure with the first field <code>BEq.beq</code>; usually you'd have <code>nodeBEqInst.beq a b</code> (which gets the <code>a == b</code>) notation but you unfolded that so you get what's called a primitive projection which is a detail of how projections are supported in Lean.</p>",
        "id": 541091459,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1758658257
    },
    {
        "content": "<p>for example, <code>a ↔ b</code> is another structure with the first field being <code>a → b</code> and the second field being <code>b → a</code>, so if you have <code>h : a ↔ b</code>, then you have access to <code>h.1 : a → b</code> and <code>h.2 : b → a</code>.<br>\n(<a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Core.html#Iff\">https://leanprover-community.github.io/mathlib4_docs/Init/Core.html#Iff</a>)</p>",
        "id": 541091686,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758658351
    },
    {
        "content": "<p>If you write <code>.1</code> or <code>.2</code> etc. yourself, you're usually not going to get a primitive projection but a projection function; these projection functions are implemented using primitive projections though. Primitive projections exist for inductives with exactly one constructor (e.g. structures) and are basically equivalent to a match that extracts the nth element:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">ABC</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">xyz</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ABC</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">xyz</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ABC</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">xyz</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 541092230,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1758658587
    },
    {
        "content": "<p>so somehow nobody here provided the correct answer, which I only discovered recently thanks to <span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> :</p>\n<p><span class=\"user-mention\" data-user-id=\"900336\">@Pavel Klimov</span> the way to do it is <code>by unfold_projs</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">DefEqTransformations</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold_projs</span>\n<span class=\"w\">  </span><span class=\"n\">guard_target</span><span class=\"w\"> </span><span class=\"bp\">=ₛ</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Subset</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n</code></pre></div>\n<p>(which I now realise is in mathlib not core)</p>",
        "id": 546707093,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761232411
    },
    {
        "content": "<p>I didn't realize it was the \"correct\" answer</p>",
        "id": 546744699,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761243993
    },
    {
        "content": "<p>It's not a great idea to use that in code you want to maintain, I wouldn't say</p>",
        "id": 546745430,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1761244258
    },
    {
        "content": "<p>The correct answer is <code>rw [Set.subset_def]</code></p>",
        "id": 546745551,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1761244288
    }
]