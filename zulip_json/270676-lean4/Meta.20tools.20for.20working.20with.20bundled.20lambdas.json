[
    {
        "content": "<p>I'm planning to write bunch of meta programming tools to deal with lambda functions that are bundled morphisms.  What I mean by this? I want to work with expressions like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ArrayN</span> <span class=\"n\">Float</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">⊞</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">∑</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>where <code>ArrayN</code> is fixed size array and the notation <code>⊞ i, f i</code> creates <code>ArrayN Float n</code> for <code>f : Fin n → Float</code></p>\n<p>or expression like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">df</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">∞</span><span class=\"o\">(</span><span class=\"n\">ℝⁿ</span><span class=\"o\">,</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span><span class=\"o\">[</span><span class=\"n\">C</span><span class=\"bp\">∞</span><span class=\"o\">]</span> <span class=\"bp\">⟪∇</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∇</span> <span class=\"n\">df</span> <span class=\"n\">x</span><span class=\"bp\">⟫</span>\n</code></pre></div>\n<p>where <code>λ x =&gt;[C∞] f x</code> is a smooth function, <code>C∞(ℝⁿ, ℝ)</code>, assuming <code>f : ℝⁿ → ℝ</code> can be proven to be smooth by a tactic similar to <code>continuity</code>.</p>\n<p>In particular, I want to have generalizations of <code>getAppFn</code>, <code>getAppArgs</code>, <code>mkAppM</code>, <code>headBeta</code>, <code>eta</code>, <code>lambdaTelescope</code> and probably bunch of others.</p>\n<p>I would like to make this mathlib friendly as much as possible and would appreciate some advice on what should I look out for. Also if someone else would find this useful I'm happy to accept feature requests.</p>\n<p>What is the go-to reference on bundled morphisms? I'm aware of <a href=\"https://arxiv.org/abs/2202.01629\">Use and abuse of instance parameters in the Lean mathematical library</a> which I should read once again.</p>",
        "id": 346613175,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1680537594
    },
    {
        "content": "<p>I have a duct-tapped prototype of these tools <a href=\"https://github.com/lecopivo/SciLean/blob/40a751e586ec71a885aaeff253cd8e9727c6a4bd/SciLean/Core/Tactic/FunctionTransformation/FunTelescope.lean\">here</a></p>",
        "id": 346614028,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1680537782
    },
    {
        "content": "<p>Another question, what would be the best way to register a new morphism type? For continuous map, I would expect to somehow register these three functions<code>ContinuousMap</code>, <code>ContinousMap.mk</code>, <code>ContinousMap.toFun</code>. One of the nice things is that <code>ContinousMap.mk</code> already has auto parameter that gets discharged by <code>continuity</code>. </p>\n<p>It is not clear to me at all what should I do for <code>RingHom</code>.</p>",
        "id": 346615841,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1680538201
    }
]