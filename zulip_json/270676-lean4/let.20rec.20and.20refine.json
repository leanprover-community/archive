[
    {
        "content": "<p>Are there plans to allow using <code>let rec</code> with <code>refine</code>? Like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">   </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">?_;</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>Ideally this should produce a goal with <code>n : Nat</code> and <code>f: Nat -&gt; Nat</code> in the context and <code>Nat</code> as the goal, though not sure if this interacts with the termination checker in a weird way. Right now it just gives an error on the <code>?_</code> saying \"don't know how to synthesize placeholder\".</p>\n<p>I'm essentially trying to use this to produce a computable recursive function in tactic mode, because of the limitations of functions generated using <code>induction</code>. Writing a top level recursive definition doesn't work because I'm trying to build some machinery for automatically synthesizing Equivs between certain types.</p>",
        "id": 546955340,
        "sender_full_name": "Alex Sanchez-Stern",
        "timestamp": 1761329815
    },
    {
        "content": "<p>Well, <code>let rec</code> more or less defines a top-level recursive definition though</p>",
        "id": 547012697,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1761350134
    },
    {
        "content": "<p>Sure, but it can be generated using tactics in a way that top-level recursive definitions can't. If necessary, I'll go up a level and use more general metaprogramming constructs, but this seems like a reasonable thing to support at the tactic level.</p>",
        "id": 547558879,
        "sender_full_name": "Alex Sanchez-Stern",
        "timestamp": 1761674518
    },
    {
        "content": "<p>My feeling is I don't know what you're doing exactly but you almost certainly shouldn't do it like this.</p>",
        "id": 547913167,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1761824722
    },
    {
        "content": "<p>You're saying, it shouldn't be possible to prove two types Equiv just using tactics? Or that it only shouldn't be possible when the types are inductive? For non-recursive types like structures it works just fine.</p>",
        "id": 547998575,
        "sender_full_name": "Alex Sanchez-Stern",
        "timestamp": 1761846271
    },
    {
        "content": "<p>You shouldn't use tactics to construct data</p>",
        "id": 548023334,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761854496
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"981900\">@Alex Sanchez-Stern</span> <br>\nYou can get a sort of computable induction with this workaround:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">compRec</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">zero</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">compRec</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">factorial</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">compRec</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">sofar</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">sofar</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">factorial</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">factorial</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">factorial</span><span class=\"w\"> </span><span class=\"mi\">4</span>\n</code></pre></div>",
        "id": 553230991,
        "sender_full_name": "Yves Jäckle",
        "timestamp": 1762075505
    },
    {
        "content": "<p>You shouldn't do that though...</p>",
        "id": 553231545,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1762076022
    },
    {
        "content": "<p>There's much better support for functions written with recursion.</p>",
        "id": 553231621,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1762076056
    },
    {
        "content": "<p>I mean, I wouldn't try to commit something with tactic-written functions to mathlib, but there are a lot of different applications of Lean where being able to prove types equivalent purely using bounded automation is useful. I care a lot about being able to use the tooling in a way that fully respects the curry-howard correspondence and doesn't have things you can only write in \"proof style\" or \"program style\"</p>",
        "id": 553462930,
        "sender_full_name": "Alex Sanchez-Stern",
        "timestamp": 1762197453
    },
    {
        "content": "<p>You can also create global declarations using tactics (including recursive ones), if that's part of the concern. For that you can see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.addPreDefinitions#doc\">docs#Lean.Elab.addPreDefinitions</a></p>",
        "id": 553474997,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1762201832
    },
    {
        "content": "<p>Ah, that does seem useful, thanks!</p>",
        "id": 553476528,
        "sender_full_name": "Alex Sanchez-Stern",
        "timestamp": 1762202471
    }
]