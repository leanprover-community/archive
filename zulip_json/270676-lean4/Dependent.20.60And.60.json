[
    {
        "content": "<p>How does one write a dependent <code>And</code> in Lean 4? <code>PSigma</code> is not in <code>Prop</code> and <code>Exists</code> does not permit destructing into non-<code>Prop</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- tactic 'induction' failed, recursor 'Exists.casesOn' can only eliminate into Prop</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">law</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a.size</span><span class=\"o\">,</span> <span class=\"n\">a.get</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">lt_size</span><span class=\"o\">,</span> <span class=\"n\">z_eq</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">law</span>\n  <span class=\"n\">i</span>\n\n<span class=\"c1\">-- has type `Type`, but is expected to have type `Prop`</span>\n<span class=\"kd\">def</span> <span class=\"n\">law</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ'</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a.size</span><span class=\"o\">,</span> <span class=\"n\">a.get</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 401433834,
        "sender_full_name": "Mac Malone",
        "timestamp": 1699647834
    },
    {
        "content": "<p>Writing your own <code>PropSigma</code> also gives out a code generation error which, to me, looks like a bug:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">PropSigma</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">PropSigma</span> <span class=\"n\">Q</span>\n\n<span class=\"c1\">--unsupported `PropSigma.casesOn` application during code generation</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">law</span> <span class=\"o\">:</span> <span class=\"n\">PropSigma</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a.size</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.get</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">lt_size</span><span class=\"o\">,</span> <span class=\"n\">z_eq</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">law</span>\n  <span class=\"n\">i</span>\n</code></pre></div>\n<p>edit : nevermind, this behaviour is already documented in the <a href=\"https://github.com/leanprover/lean4/blob/fd0a209f7425f021d110c9469aac62434ec63367/src/Lean/Compiler/LCNF/ToLCNF.lean#L550\">relevant code</a>.</p>",
        "id": 401434172,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1699648068
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 401434468,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1699648244
    },
    {
        "content": "<p>With <code>exists</code> you can use </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Classical.choose</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.choose_spec#doc\">docs#Classical.choose_spec</a>, but I agree when <code>u = 0</code> (i.e. <code>α : Prop</code>) we should have a version not relying on the axiom of choice.</p>",
        "id": 401434856,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1699648521
    },
    {
        "content": "<p>Another hacky solution is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">PropSigma</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">PropSigma</span> <span class=\"n\">Q</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">PropSigma.fst</span> <span class=\"o\">{</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">PropSigma</span> <span class=\"n\">Q</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">intro</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">PropSigma.snd</span> <span class=\"o\">{</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">PropSigma</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span> <span class=\"n\">s.fst</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">intro</span> <span class=\"n\">h</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">law</span> <span class=\"o\">:</span> <span class=\"n\">PropSigma</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a.size</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.get</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"n\">lt_size</span> <span class=\"o\">:=</span> <span class=\"n\">law.fst</span>\n  <span class=\"k\">have</span> <span class=\"n\">z_eq</span> <span class=\"o\">:=</span> <span class=\"n\">law.snd</span>\n  <span class=\"n\">i</span>\n</code></pre></div>\n<p>But this removes the ability to use pattern matching syntax for proper destructing.</p>",
        "id": 401434997,
        "sender_full_name": "Mac Malone",
        "timestamp": 1699648623
    },
    {
        "content": "<p>Hmm, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Exists.fst#doc\">docs#Exists.fst</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Exists.snd#doc\">docs#Exists.snd</a> are already there! You can even write <code>law.1</code> <code>law.2</code>.</p>",
        "id": 401435293,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1699648806
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> Interesting, so it is just the <code>casesOn</code> eliminator that is broken for this special case.</p>",
        "id": 401435663,
        "sender_full_name": "Mac Malone",
        "timestamp": 1699649069
    },
    {
        "content": "<p>I think it's behaving as expected as your goal is <code>Nat : Type</code> not <code>_ : Prop</code>.</p>",
        "id": 401435946,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1699649269
    },
    {
        "content": "<p>For example these work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">Exists.fst'</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">a</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Exists.snd'</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">h.fst'</span> <span class=\"o\">:=</span> <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">ha</span>\n</code></pre></div>",
        "id": 401436266,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1699649456
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> Yes, but the problem is there is overlooked case of a dependent and which does need some type (possibly <code>Exists</code>) that properly destructors for it.</p>",
        "id": 401436307,
        "sender_full_name": "Mac Malone",
        "timestamp": 1699649491
    },
    {
        "content": "<p>However, given that <code>.1</code> and <code>.2</code> work for exists, there is the following less hacky solution to the problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">Exists.toAnd</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Exists</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">And</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">x.1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">x.1</span><span class=\"o\">,</span> <span class=\"n\">x.2</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- tactic 'induction' failed, recursor 'Exists.casesOn' can only eliminate into Prop</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">law</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a.size</span><span class=\"o\">,</span> <span class=\"n\">a.get</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">lt_size</span><span class=\"o\">,</span> <span class=\"n\">z_eq</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">law.toAnd</span>\n  <span class=\"n\">i</span>\n</code></pre></div>",
        "id": 401436479,
        "sender_full_name": "Mac Malone",
        "timestamp": 1699649597
    },
    {
        "content": "<p>I see, apparently casesOn is designed to support more, as this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">And.fst</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 401436679,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1699649707
    },
    {
        "content": "<p>I suppose you could also do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">lt_size</span> <span class=\"o\">:=</span> <span class=\"n\">law.1</span><span class=\"bp\">;</span> <span class=\"k\">have</span> <span class=\"n\">z_eq</span> <span class=\"o\">:=</span> <span class=\"n\">law.2</span>\n</code></pre></div>\n<p>In Lean 3 it used to be possible to do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">lt_size</span><span class=\"o\">,</span> <span class=\"n\">z_eq</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">law.1</span><span class=\"o\">,</span> <span class=\"n\">law.2</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>in tactic mode.</p>",
        "id": 401436735,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1699649758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/270676-lean4/topic/Dependent.20.60And.60/near/401435293\">said</a>:</p>\n<blockquote>\n<p>You can even write <code>law.1</code> <code>law.2</code>.</p>\n</blockquote>\n<p>How does this work?</p>",
        "id": 401451694,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699661543
    },
    {
        "content": "<p>I don't know! I think it's Lean 4's new feature and I don't think it work in Lean 3.<br>\nProbably related to <a href=\"#narrow/stream/270676-lean4/topic/invalid.20kernel.20projection.20error.20error\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/invalid.20kernel.20projection.20error.20error</a></p>",
        "id": 401462138,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1699667430
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Dependent.20.60And.60/near/401451694\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/270676-lean4/topic/Dependent.20.60And.60/near/401435293\">said</a>:</p>\n<blockquote>\n<p>You can even write <code>law.1</code> <code>law.2</code>.</p>\n</blockquote>\n<p>How does this work?</p>\n</blockquote>\n<p>I believe it is because the projection is treated as a separate function of type <code>law.1 : Exists p -&gt; Prop</code> and thus eliminator with that function is eliminating into <code>Prop</code> which works whereas in the destructing case it is eliminating into the arbitrary return type.</p>",
        "id": 401462530,
        "sender_full_name": "Mac Malone",
        "timestamp": 1699667697
    },
    {
        "content": "<p>Projections are typechecked such that <code>x.1</code> is valid iff <code>x.casesOn fun a _ =&gt; a</code> would be type correct</p>",
        "id": 401585777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699772044
    }
]