[
    {
        "content": "<p>Hello lean community,</p>\n<p>is it possible to set up a delaborator that works on idents? <br>\nMy problem is, that I generate variables with \"ugly\" names. I would like to delaborate calls to them (e.g. I call the variable a_xyz123_r, but want to show the user only r). </p>\n<p>I already confirmed, that it is possible to add this delaboration to operations that use the reference (calls) and only show the r (e.g. a_xyz123_r + a_xyz123_r to r + r). Here I can simply use the operation as entry point and change the name of the operands to only the last part. However, I fail to find an appropriate entry point (if there is one) for delaboration in idents.</p>\n<p>Please let me know if there is an entry point to delaborate Idents and how to use it.</p>",
        "id": 495231614,
        "sender_full_name": "Codegoblin",
        "timestamp": 1737537123
    },
    {
        "content": "<p>Why are you calling your variables so weird to begin with? This feels like a bit of <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a></p>",
        "id": 495232168,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1737537276
    },
    {
        "content": "<p>Hello <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> ,</p>\n<p>the reason for this is, to ensure that the variable name is unique. I (tried) creating a DSL (of Alloy) which supports multiple modules (and signatures with relations). These modules are named and can (theoretical) have conflicting/same names. E.g. module m1 has the signature a with the relation r. This module m1 is now imported into module m2 which can also contain the signature a with relation r. </p>\n<p>To ensure that I can identify which signature and relation belong to each other, the \"best\" solution I could think of was to name them accordingly (+ the weird strings to not block names) e.g. the relation in m1 would be named m1_φ_a_ξ_r instead of only r. </p>\n<p>This works, but is ugly for the user to read. I would like the user to see the name he originally gave (so only r instead of m1_φ_a_ξ_r ). </p>\n<p>Maybe there is also a much easier Solution for my problem.</p>",
        "id": 495233941,
        "sender_full_name": "Codegoblin",
        "timestamp": 1737537791
    },
    {
        "content": "<p>Hello,</p>\n<p>the reason I need this is that the DSL (Alloy) uses another namespace concept. I want to map this to the namespace concept of lean.</p>\n<p>E.g. here</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>In the theorem x a.b.c is delaborated (?) to b.c <br>\nI would like to understand how this is done, in order to apply this mechanism</p>",
        "id": 496069725,
        "sender_full_name": "Codegoblin",
        "timestamp": 1737969251
    },
    {
        "content": "<p>Delaborating constants isn't easily overridable. <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/PrettyPrinter/Delaborator/Builtins.lean#L91\">Here's</a> the function responsible, and it's called indirectly through <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/PrettyPrinter/Delaborator/Builtins.lean#L551\">the app delaborator</a></p>\n<p>If your constants are not functions, then you could add an app delaborator of your own that looks for constants. (Design notes: the app delaborator is responsible for both applications and constants. A constant is considered to be an \"arity-0\" application.)</p>\n<p>If your constants might be applied, then this will be more difficult.</p>",
        "id": 496071895,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737970026
    },
    {
        "content": "<p>Hello <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> ,</p>\n<p>thank you for your answer. I will try a workaround without delaborating the constants directly, then.</p>",
        "id": 496096010,
        "sender_full_name": "Codegoblin",
        "timestamp": 1737976285
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"710184\">Codegoblin</span> has marked this topic as resolved.</p>",
        "id": 496096069,
        "sender_full_name": "Notification Bot",
        "timestamp": 1737976294
    }
]