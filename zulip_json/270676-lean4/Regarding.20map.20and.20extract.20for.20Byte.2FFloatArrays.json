[
    {
        "content": "<p>Hi all;</p>\n<p>I notice that <code>ByteArray</code> and <code>FloatArray</code>  lack <code>map</code>, and <code>FloatArray</code> also lacks <code>extract</code>.  Is there a performance reason for this, or just that these operations were not needed for these types?</p>\n<p>I would like to understand how compiler optimizations are applied to these two types in order to avoid doing something bad.  Say I write an <code>extract</code> function for <code>FloatArray</code> as follows (NOT compatible with the current API):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">inline</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">FloatArray.extractAux</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">C</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">FloatArray.extractAux</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">C.push</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">A.get</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">start.succ</span><span class=\"w\"> </span><span class=\"n\">k</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inline</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">FloatArray.extract</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">A.size</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"o\">⟨</span><span class=\"bp\">#</span><span class=\"o\">[]⟩</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">FloatArray.extractAux</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">       </span><span class=\"o\">(</span><span class=\"n\">FloatArray.mkEmpty</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"n\">size</span>\n</code></pre></div>\n<p>Is there something bad happening here?  If so, what are the tools if any to test performance pitfalls in the above code?</p>\n<p>A similar question applies to <code>map</code>: would the obvious implementation of <code>map</code> create performance problems?</p>",
        "id": 452971124,
        "sender_full_name": "Number Eighteen",
        "timestamp": 1721558894
    },
    {
        "content": "<p>Note that <code>ByteArray</code> and <code>FloatArray</code> are scalar arrays, which are implemented differently from <code>Array</code>. The issue with <code>map</code> is that in-place optimization is not possible for <code>ByteArray</code> except for maps <code>UInt8 -&gt; UInt8</code>. (Similarly for <code>FloatArray</code>.) So there is no major advantage over a plain <code>for</code> loop.</p>\n<p>The reason <code>ByteArray.extract</code> exists is that it is a common special case of <code>ByteArray.copySlice</code>, which is basically Lean's wrapper around C's <code>memcpy</code>. There is no similar low-level function for <code>FloatArray</code> implemented in Lean core, so there is currently no <code>FloatArray.copySlice</code> nor <code>FloatArray.extract</code>. I think that's an omission.</p>\n<p>I think Lean core would currently accept these only if they come with efficient low-level implementations. That said, all of these would be welcome additions to <a href=\"https://github.com/leanprover-community/batteries/\"><code>Batteries</code></a>, even if implemented as for loops.</p>",
        "id": 452979363,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1721565304
    },
    {
        "content": "<p>See <a href=\"https://github.com/leanprover-community/batteries/pull/902\">batteries#902</a></p>",
        "id": 455704233,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1722531186
    }
]