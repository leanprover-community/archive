[
    {
        "content": "<p>Will the new <a href=\"https://lean-lang.org/doc/reference/latest/The-Module-System/#module-system\">module system</a> be true first class modules, as in <a href=\"https://people.mpi-sws.org/~rossberg/1ml/\">1ML style</a>, with one language for modules and core expressions ? </p>\n<p>If not, what is the technical flavor of those modules ?</p>\n<p>More than a few languages have half-baked module systems,  it would be a shame if Lean went that way.</p>",
        "id": 537007495,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1756673069
    },
    {
        "content": "<p>The new module system is not at all about providing something you would see in an ML language. It's about providing a way to more clearly define which symbols defined within a Lean file are visible to importers of said file in order to enable things like faster (re)compilation and more clearly defined APIs.</p>",
        "id": 537007840,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1756673407
    },
    {
        "content": "<p>My understanding is that some of the main use cases of ML-style modules, ad hoc polymorphism and abstraction, are handled by Lean's typeclass system. It's a different design space too, since there's not so much of a focus on decidable inference, and higher-kinded typeclasses are accepted too.</p>\n<p>Lean 3 used to have <code>parameters</code> for uniformly parameterizing a set of declarations, which you might call a \"half-baked ML module system\", but that feature was not included in Lean 4, in favor of typeclasess.</p>\n<p>Maybe something that's missing in Lean that's sort of handled by ML modules is first-class inductive type descriptions? Sometimes it would be nice to be able to have nested inductive types that are parameterized by another type. Something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">inductive_schema</span><span class=\"w\"> </span><span class=\"n\">TreeOf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">container</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IndType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">TreeOf</span><span class=\"w\"> </span><span class=\"n\">container</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">container</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TreeOf</span><span class=\"w\"> </span><span class=\"n\">container</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">TreeOf</span><span class=\"w\"> </span><span class=\"n\">container</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Pair</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">BinaryTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">TreeOf</span><span class=\"w\"> </span><span class=\"n\">Pair</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">TreeOf</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>The <code>TreeOf</code> type isn't a valid inductive type on its own. The kernel needs <code>container</code> to be a concrete inductive type to be able to check that the whole type is well-formed.</p>",
        "id": 537144742,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756745450
    },
    {
        "content": "<p>\"module\" is probably an overloaded term, and as Henrik was highlighting, lean modules might not refer to some other classical notion of modules which I thought they were.</p>\n<p>By \"half-baked module system\" I mean a module system that is not backed by a clear theory and erasable to some calculus. 1ML modules, as far as I know, are just very useful syntactic constructs which stand for some encoding in system-F-omega (cf <a href=\"https://people.mpi-sws.org/~rossberg/1ml/1ml-jfp-draft.pdf\">f-ing</a> ) giving a clear interpretation of what they stand for.</p>\n<p>As a design, modules in this language refers to not just some ad-hoc facility bolted on top, incompatible with the rest of the language but forms a coherent whole. Having one language for both has a few important benefits.</p>\n<p>Type classes, in the language of modules, builds those modules for you through instance search, instead of you having to build and provide them by hand. It has its own limitation as it requires a global picture of the whole system, and is only available at compile time. </p>\n<p>Of course each has benefit and negative side,  but they both provide a dictionary of ad-hoc operation to some polymorphic code.  Admittedly, mixing both is a challenge, but Lean folks are so amazing  so far ;)</p>",
        "id": 537245959,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1756805549
    }
]