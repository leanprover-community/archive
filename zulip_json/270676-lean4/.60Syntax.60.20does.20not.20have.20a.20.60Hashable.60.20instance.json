[
    {
        "content": "<p>I often find myself wanting to store <code>Syntax</code> in a <code>HashSet</code>/<code>HashMap</code> and eventually resort to storing something else instead, since <code>Syntax</code> does not have a <code>Hashable</code> instance.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Syntax</span>\n</code></pre></div>\n<p>Is this on purpose?  If so, why?</p>",
        "id": 466761359,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725224375
    },
    {
        "content": "<p>Syntax objects are huge, I wouldn't recommend hashing them. What I usually do is take the node kind and the start/end position; this is generally enough to uniquely define a syntax in the file</p>",
        "id": 466761564,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1725224443
    },
    {
        "content": "<p>Yes, this is also what I end up doing.</p>",
        "id": 466761617,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725224473
    },
    {
        "content": "<p>However, <code>Expr</code>s are also huge, but hashable.</p>",
        "id": 466761632,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725224484
    },
    {
        "content": "<p>Anyway, I am happy already knowing that it is a conscious decision, rather than an oversight!  At least, I do not feel silly when I work around it.</p>",
        "id": 466761804,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725224546
    },
    {
        "content": "<p><code>Expr</code> caches its hash code in every node so its fast.</p>",
        "id": 466761808,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1725224553
    },
    {
        "content": "<p>Henrik, I will probably have to look more deeply at what a hashable instance really is and what it is for <code>Expr</code> to understand your comment.  Thanks!</p>",
        "id": 466762578,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725224958
    },
    {
        "content": "<p><code>Hashable</code> provides a <code>hash</code> function that takes an object and produces a 64 bit hash code for the object. <code>Expr</code> is a type that is constructed specifically so that this 64 bit hash code is already contained in every node of an <code>Expr</code> tree. This makes computing the hash of an <code>Expr</code> an <code>O(1)</code> operation. With <code>Syntax</code> on the other hand you actually have to traverse the whole tree because the codes are not prefixed so it is <code>O(n)</code> when <code>n</code> is the size of the <code>Syntax</code> tree</p>",
        "id": 466762876,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1725225098
    },
    {
        "content": "<p>Ok, thanks for the explanation!  It removed a layer of opaqueness from my understanding!</p>",
        "id": 466763290,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725225368
    }
]