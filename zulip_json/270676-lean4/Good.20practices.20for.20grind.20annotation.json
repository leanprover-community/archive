[
    {
        "content": "<p>Hello,<br>\ni am currently working on a project and want to make good use of the <code>grind</code> tactic.<br>\nSimilarly to <code>@[simp]</code>, theorems can be annotated with <code>@[grind]</code> (or some variant of that, like @[grind =] etc.). While it is clear to me when to annotate with <code>@[simp]</code> i struggle with a good intuition on when to annotate with the<code>@[grind]</code> variants. </p>\n<p>So now i am wondering,</p>\n<ul>\n<li>Are there any downsides to just annotate each of my theorems with just <code>@[grind]</code> except performance ?</li>\n<li>Are there some best practices on what to annotate and if so, how to annotate each theorem with some variation of <code>@[grind]</code></li>\n<li>Is there some official guideline for annotation with <code>@[grind]</code> like there is for <code>@[simp]</code> like in the doc. of Mathlib ?</li>\n</ul>\n<p>Thanks in advance :)</p>",
        "id": 542048020,
        "sender_full_name": "HenrikT",
        "timestamp": 1759154299
    },
    {
        "content": "<p>I have been wondering about these things too. I am sometimes confused by why a theorem doesn't work with grind but does work with something like <code>@[simp]</code>. I mainly want to know if there some advice for writing theorems in a way that works better for grind.</p>",
        "id": 542053585,
        "sender_full_name": "Julia Scheaffer",
        "timestamp": 1759155558
    },
    {
        "content": "<p><a href=\"https://lean-lang.org/doc/reference/latest/The--grind--tactic/E___matching/\">https://lean-lang.org/doc/reference/latest/The--grind--tactic/E___matching/</a></p>",
        "id": 542072381,
        "sender_full_name": "Lawrence Wu (llllvvuu)",
        "timestamp": 1759159743
    },
    {
        "content": "<p>So what i get from reading this article is, that:</p>\n<ul>\n<li>you can increase resource limits for cases when grind runs out (decreasing them for performance reasons is also an option i guess)</li>\n<li>define (multi-)patterns for each theorem that when present, grind will attempt to instantiate the corresponding theorem </li>\n<li>the grind attribute generates a (multi-)patterns using a heuristic</li>\n</ul>\n<p>However while the article states that:  (*) \"Although it is tempting to just use <code>@[grind]</code> by default, we recommend using one of the other forms when it achieves the desired effect.\", it does not explicitly state why it is not recommended.</p>\n<p>I assume that while performance is one factor, another factor could be that the automatically generated patters can be too restrictive, thus theorems that are applicable are not instantiated by <code>grind</code>, thus <code>grind</code> fails more often. Am i correct in that assumption ?</p>\n<p>If so, does this entail that one should use <code>grind</code> in combination with a custom pattern for each theorem, if performance allows it ? </p>\n<p>As a side-node to this, if i define a very narrow pattern for each theorem instead of just using <code>@[grind]</code>, wouldn't i often have to constantly update the pattern each time i write a new theorem using a slightly different pattern, thus making the workflow of just using <code>@[grind]</code> (or using overly broad patterns) more feasible (if performance allows it) ?</p>\n<p>The article does not mention any clear guidelines for how/when to annotate with <code>@[grind]</code> (or some variant of it), except the quote (*) seen above.</p>\n<p>Maybe someone with some experience in <code>grind</code> can chime in ?<br>\nThanks in advance :)</p>",
        "id": 542096975,
        "sender_full_name": "HenrikT",
        "timestamp": 1759166264
    },
    {
        "content": "<p>Your worry about grind patterns being too narrow is probably the opposite of what you should worry about. What you should avoid is a grind pattern that triggers a lot when the lemma is not relevant.</p>\n<p>In any case, it is usually intuitively clear whether you want <code>@[grind =]</code>, <code>@[grind \\l]</code> or <code>@[grind \\r]</code> so I donâ€™t think this (along with inspecting the <code>grind?</code>) is onerous or undue effort</p>",
        "id": 542099729,
        "sender_full_name": "Lawrence Wu (llllvvuu)",
        "timestamp": 1759167046
    },
    {
        "content": "<blockquote>\n<p>wouldn't i often have to constantly update the pattern each time i write a new theorem using a slightly different pattern</p>\n</blockquote>\n<p>I don't understand what this means. But grind annotations in core and mathlib, as far as I can tell, have not required maintenance once set.</p>",
        "id": 542100027,
        "sender_full_name": "Lawrence Wu (llllvvuu)",
        "timestamp": 1759167138
    },
    {
        "content": "<p>What i was trying to say is,<br>\nSay i have all my theorems marked with very narrow patterns.<br>\nNow when i add new code / theorems which i want to prove using <code>grind, can </code>grind` fails because the patterns i have chosen worked only for the existing theorems but not for the new use case in the new theorem ?<br>\nThus wouldn't i have to update the patterns each time there is a new use case ?<br>\nMaybe i am looking at it wrongly ?</p>",
        "id": 542102339,
        "sender_full_name": "HenrikT",
        "timestamp": 1759167869
    },
    {
        "content": "<p>\"What you should avoid is a grind pattern that triggers a lot when the lemma is not relevant.\"</p>\n<p>So i can write <code>set_option diagnostics true in</code> above the theorem in question and unfold the <code>E-matching instances</code> tab to see how often each theorem is instantiated. </p>\n<p>However, how do i know from this diagnostic if a patterns is triggered too often or is not relevant at all. Is there some way to tell ?</p>",
        "id": 542103726,
        "sender_full_name": "HenrikT",
        "timestamp": 1759168326
    },
    {
        "content": "<blockquote>\n<p>Thus wouldn't i have to update the patterns each time there is a new use case ?</p>\n</blockquote>\n<p>Then you shouldn't use <code>grind</code> IMO, or you should explicitly pass in like <code>grind [mylemma]</code>. The point of a <code>grind</code> annotation is that it should be knowable without looking at the specific downstream uses. Adding a global grind pattern for a specific use would be a mis-use.</p>",
        "id": 542106741,
        "sender_full_name": "Lawrence Wu (llllvvuu)",
        "timestamp": 1759169084
    }
]