[
    {
        "content": "<p>A student of mine has run into the following problem: using tactics to construct data, the order of elaboration can cause type checking to fail prematurely. His MWE is below. If you'll accept for the moment that using tactics to construct data is actually a reasonable thing to do in our application, is there anything we can do to tweak the elaboration order that might make this work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Dict</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">Dict</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">hs</span> <span class=\"n\">nm</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Dict</span> <span class=\"n\">hs</span> <span class=\"bp\">→</span> <span class=\"n\">Dict</span> <span class=\"o\">((</span><span class=\"n\">nm</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">hs</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- This is Type-valued predicate</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">List.MemT</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span>\n  <span class=\"bp\">|</span> <span class=\"n\">hd</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">List.MemT</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">tl</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">List.MemT</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">→</span> <span class=\"n\">List.MemT</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">List.removeMem</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">List.MemT</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">hd</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">xs</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">tl</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">removeMem</span> <span class=\"n\">xs</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Dict.dropEntry</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"kt\">Type</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">nm</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">Dict</span> <span class=\"n\">hs</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">List.MemT</span> <span class=\"o\">(</span><span class=\"n\">nm</span><span class=\"o\">,</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"n\">hs</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Dict</span> <span class=\"o\">(</span><span class=\"n\">hs.removeMem</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">hd</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">xs</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">tl</span> <span class=\"n\">h'</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">dropEntry</span> <span class=\"n\">nm</span> <span class=\"n\">xs</span> <span class=\"n\">h'</span><span class=\"o\">)</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"mem\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">List.MemT.hd</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">List.MemT.tl</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">d1</span> <span class=\"o\">:</span> <span class=\"n\">Dict</span> <span class=\"o\">[(</span><span class=\"s2\">\"a\"</span><span class=\"o\">,</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"s2\">\"b\"</span><span class=\"o\">,</span> <span class=\"n\">Bool</span><span class=\"o\">)]</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"mi\">4</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">true</span> <span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">d2</span> <span class=\"o\">:</span> <span class=\"n\">Dict</span> <span class=\"o\">[(</span><span class=\"s2\">\"a\"</span><span class=\"o\">,</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"s2\">\"b\"</span><span class=\"o\">,</span> <span class=\"n\">Nat</span><span class=\"o\">)]</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"mi\">3</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"mi\">1</span> <span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- These terms elaborate correctly...</span>\n<span class=\"k\">#check</span> <span class=\"n\">d1.dropEntry</span> <span class=\"s2\">\"b\"</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">mem</span><span class=\"o\">)</span> <span class=\"c1\">-- Dict (List.removeMem [(\"a\", Nat), (\"b\", Bool)] (List.MemT.tl List.MemT.hd))</span>\n<span class=\"k\">#check</span> <span class=\"n\">d2.dropEntry</span> <span class=\"s2\">\"b\"</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">mem</span><span class=\"o\">)</span> <span class=\"c1\">-- Dict (List.removeMem [(\"a\", Nat), (\"b\", Nat)] (List.MemT.tl List.MemT.hd))</span>\n\n<span class=\"c1\">-- And their types are definitionally equal</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Dict</span> <span class=\"o\">(</span><span class=\"n\">List.removeMem</span> <span class=\"o\">[(</span><span class=\"s2\">\"a\"</span><span class=\"o\">,</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"s2\">\"b\"</span><span class=\"o\">,</span> <span class=\"n\">Bool</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">List.MemT.tl</span> <span class=\"n\">List.MemT.hd</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n  <span class=\"n\">Dict</span> <span class=\"o\">(</span><span class=\"n\">List.removeMem</span> <span class=\"o\">[(</span><span class=\"s2\">\"a\"</span><span class=\"o\">,</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"s2\">\"b\"</span><span class=\"o\">,</span> <span class=\"n\">Nat</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">List.MemT.tl</span> <span class=\"n\">List.MemT.hd</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- Type-correctness of this equality depends on the proof produced by `mem`</span>\n<span class=\"kd\">def</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">d1.dropEntry</span> <span class=\"s2\">\"b\"</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">mem</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">d2.dropEntry</span> <span class=\"s2\">\"b\"</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">mem</span><span class=\"o\">)</span> <span class=\"c1\">-- fails</span>\n<span class=\"kd\">def</span> <span class=\"n\">p'</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">d1.dropEntry</span> <span class=\"s2\">\"b\"</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">tl</span> <span class=\"bp\">.</span><span class=\"n\">hd</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">d2.dropEntry</span> <span class=\"s2\">\"b\"</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">tl</span> <span class=\"bp\">.</span><span class=\"n\">hd</span><span class=\"o\">)</span> <span class=\"c1\">-- succeeds</span>\n</code></pre></div>",
        "id": 404322153,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1701053681
    },
    {
        "content": "<p><code>(d1.dropEntry \"b\" (by mem) :) = (d2.dropEntry \"b\" (by mem) :)</code> works</p>",
        "id": 404323870,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701054415
    },
    {
        "content": "<p>My eye can only see a <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> and mismatched parens -- I guess this is a type annotation without providing the type, that's different from <code>: _</code> somehow?</p>",
        "id": 404324094,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1701054542
    },
    {
        "content": "<p>it's like <code>: _</code> from lean 3</p>",
        "id": 404324113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701054556
    },
    {
        "content": "<p>in lean 4 <code>: _</code> does nothing</p>",
        "id": 404324118,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701054564
    },
    {
        "content": "<p><code>(e :)</code> is basically the same as <code>have := e; this</code> where the <code>have :=</code> is a separate tactic block</p>",
        "id": 404324156,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701054598
    },
    {
        "content": "<p>that is, it elaborates <code>e</code> as much as possible, then asserts that the resulting type is equal to the expected type</p>",
        "id": 404324236,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701054627
    },
    {
        "content": "<p>rather than using the expected type to influence elaboration</p>",
        "id": 404324254,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701054643
    },
    {
        "content": "<p>So, exactly what we want here. That's perfect, and I only thought to try <code>: _</code>. Thanks!</p>",
        "id": 404324280,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1701054667
    }
]