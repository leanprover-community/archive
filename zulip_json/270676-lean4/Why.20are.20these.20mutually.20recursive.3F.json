[
    {
        "content": "<p>I have the following mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">TInv</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">//</span> <span class=\"n\">TInv</span> <span class=\"n\">t</span><span class=\"o\">})</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">TInv</span> <span class=\"o\">(</span><span class=\"n\">T.c</span> <span class=\"n\">a.val</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>And the Lean kernel complains that \"(kernel) mutually inductive types must live in the same universe\", but I do not see what is mutually recursive about these two types.</p>",
        "id": 340338932,
        "sender_full_name": "Max Nowak 游낼",
        "timestamp": 1678276361
    },
    {
        "content": "<p><code>TInv</code> is nested and is therefore presumably translated to a mutual inductive type before it reaches the kernel.</p>",
        "id": 340339432,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1678276521
    },
    {
        "content": "<p>I thought you can construct <code>Declaration</code>s (from <code>Expr</code> yourself) which contain nested <code>TInv</code> and <code>addDecl</code> those directly to the kernel, skipping the elaborator?</p>",
        "id": 340339646,
        "sender_full_name": "Max Nowak 游낼",
        "timestamp": 1678276580
    },
    {
        "content": "<p>So then the \"mutual inductive type must live in the same universes\" does <em>not</em> refer to T and TInv, but rather to TInv and whatever other mutual declaration is generated by the elaborator?</p>",
        "id": 340339970,
        "sender_full_name": "Max Nowak 游낼",
        "timestamp": 1678276677
    },
    {
        "content": "<p>Yes, the specialization of <code>Subtype</code>. But this transformation is done in the kernel, not in the elaborator.</p>",
        "id": 340340241,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1678276731
    },
    {
        "content": "<p>See also <a href=\"#narrow/stream/270676-lean4/topic/Mutual.20inductive.20universe\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Mutual.20inductive.20universe</a></p>",
        "id": 340340278,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1678276739
    },
    {
        "content": "<p>Specialization? I have encountered that term a few times before but thus far joyfully ignored it.</p>\n<p>If the transformation is done in the kernel, I suppose there is no way around it, even if I define my own copy of <code>Subtype</code>.</p>",
        "id": 340343617,
        "sender_full_name": "Max Nowak 游낼",
        "timestamp": 1678277544
    },
    {
        "content": "<p>I was hoping to simplify my code generating binders <code>(a : T) -&gt; (prf : TInv a) -&gt; ...</code> (which works) into just a subtype.</p>",
        "id": 340344602,
        "sender_full_name": "Max Nowak 游낼",
        "timestamp": 1678277827
    },
    {
        "content": "<p>When Lean sees a nested inductive type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">T</span>\n  <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span>\n</code></pre></div>\n<p>it translates this into the mutual inductive types</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">AT</span>\n  <span class=\"bp\">&lt;</span><span class=\"n\">constructors</span> <span class=\"n\">mentioning</span> <span class=\"n\">T</span><span class=\"bp\">&gt;</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">T</span>\n  <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">AT</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span>\n</code></pre></div>\n<p>where <code>AT</code> is isomorphic to <code>A T</code> (and hence a specialisation of <code>A</code>). Here, <code>A</code> is <code>Subtype</code>. You can perform this translation yourself to get a sense of what might be going wrong.</p>\n<p>With that said, if you can easily avoid nested/mutual inductive types, I would highly recommend you do that. Lean's support for them is still pretty rough.</p>",
        "id": 340345937,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1678278252
    },
    {
        "content": "<p>Sigh, yeah, I suppose I will just avoid Subtype and keep my old approach, which will get fiddly in other places.</p>",
        "id": 340348765,
        "sender_full_name": "Max Nowak 游낼",
        "timestamp": 1678279121
    }
]