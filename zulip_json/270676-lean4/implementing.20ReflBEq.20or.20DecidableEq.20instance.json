[
    {
        "content": "<p>I have following proof</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">zip</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">zip</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">âŠ¢</span>\n<span class=\"w\">    </span><span class=\"n\">trivial</span>\n</code></pre></div>\n<p>I suppose it works because of  <code>BEq.rfl</code> theorem, which states</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">BEq</span><span class=\"bp\">.</span><span class=\"n\">rfl</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ReflBEq</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n</code></pre></div>\n<p>Why I think so? Well... More close to my actual case is following code</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyType</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">BEq</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myFunc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">MyType</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">a</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">b</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">test1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">zip</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">myFunc</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">myFunc</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">zip</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">âŠ¢</span>\n<span class=\"w\">    </span><span class=\"n\">trivial</span>\n</code></pre></div>\n<p>You may ask \"why not use deriving DecidableEq instead?\". I'll answer a bit later. But you should see here this proof doesn't work anymore. So, while trying to prove it manually, I arrived at theorem \"BEq.rfl\", and found out that if I add instance ReflEq:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ReflBEq</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Then proof of theorem test1 will work once again. But here comes the twist. The type for which I want to implement ReflBEq actually something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Node</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">leaf</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">children</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">BEq</span>\n</code></pre></div>\n<p>And here, I can't use <code>deriving DecidableEq</code>, it says</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"n\">handlers</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">been</span><span class=\"w\"> </span><span class=\"n\">implemented</span><span class=\"w\"> </span><span class=\"n\">yet</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kn\">class</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">DecidableEq'</span><span class=\"w\"> </span><span class=\"n\">types</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Node</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>And <code>induction tactic</code> says</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">'</span><span class=\"n\">induction'</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"n\">does</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"n\">nested</span><span class=\"w\"> </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">types</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">eliminator</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">rec'</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">multiple</span><span class=\"w\"> </span><span class=\"n\">motives</span>\n</code></pre></div>\n<p>So I tried tactic <code>cases</code>, and then very fist case has goal</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">âŠ¢</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n</code></pre></div>\n<p>And <code>rfl</code> doesn't work anymore. And I don't know how to prove it. I don't even know how to unfold ==. I tried <code>rw [BEq.beq]</code>, and it did something, but then I don't know what to do next.</p>\n<p>I also tried to use recursors:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ReflBEq</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">rec</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">motive_1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">children</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">v</span>\n<span class=\"w\">    </span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Lines <code>nil</code>, <code>cons</code> works, but <code>leaf</code> and <code>node</code> asking proofs of same cases as in <code>cases</code> tactic.</p>\n<p>Then I tried to implement BEq instance myself, to be able to use its definition, but then I also stuck, but this time I was able to write implementation, but I'm unable to prove its termination:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\">  </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">children</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">children</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">max?</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"c1\">--mutual</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">singleEq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">children</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">children1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">children</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">children1</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n<span class=\"w\">    </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">children</span><span class=\"bp\">.</span><span class=\"n\">zip</span><span class=\"w\"> </span><span class=\"n\">children1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">children</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n<span class=\"w\">        </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">children</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">      </span><span class=\"n\">singleEq</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">size</span>\n</code></pre></div>\n<p>I'm new to formal proofs, so probably I'm doing something wrong, for example metrics of decreasing I pick is wrong, etc.</p>\n<p>So... My question is following: How can I define <code>ReflBEq</code>, or, perhaps <code>DecidableEq</code> in case like that? What should I do?</p>",
        "id": 540584384,
        "sender_full_name": "Pavel Klimov",
        "timestamp": 1758373449
    },
    {
        "content": "<p>try writing a <code>BEq</code> or <code>DecidableEq</code> yourself!</p>",
        "id": 540584880,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758373930
    },
    {
        "content": "<p>you can copy off of <a class=\"message-link\" href=\"/#narrow/channel/113488-general/topic/Proving.20DecidableEq.20of.20inductive.20type.20recursively.20using.20it/near/538953199\">#general &gt; Proving DecidableEq of inductive type recursively using it @ ðŸ’¬</a> if you get stuck</p>",
        "id": 540584929,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758373968
    },
    {
        "content": "<p>If you read carefully, you will see that I tried to implement them myself<br>\nThanks for the link, will check it out.</p>",
        "id": 540584966,
        "sender_full_name": "Pavel Klimov",
        "timestamp": 1758373998
    },
    {
        "content": "<p>I was able to implement <code>DecidableEq</code> for my type. It has 7 constructors, so my question is: is it normal to have 49 cases? It's because <code>TestTy.noConfusion</code> each time has different specification. And, when I have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">case3</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">num</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TestTy</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>to have its proof using tactics?</p>",
        "id": 540588236,
        "sender_full_name": "Pavel Klimov",
        "timestamp": 1758377502
    },
    {
        "content": "<p>Hi Pavel,<br>\nto your question</p>\n<blockquote>\n<p>It has 7 constructors, so my question is: is it normal to have 49 cases?</p>\n</blockquote>\n<p>I guess you need to check all combinations, which gives you n^2 cases for n constructors.<br>\nI'm not sure of it makes sense in your case, but maybe you can use multiple types instead of one and in combination with inheritance.<br>\nI had a similar issue with DeciableLT - my code can be found <a href=\"https://github.com/runbikeswim/lean-semver/blob/main/SemVer/Basic.lean#L515\">here</a>.</p>\n<p>Regards, Stefan</p>",
        "id": 540589892,
        "sender_full_name": "Stefan Kusterer",
        "timestamp": 1758379032
    },
    {
        "content": "<p>Can I avoid using recursors? Is it really good to have ReflBEq? Because my proof is working with only DecidableEq, but as a practice I tried to define ReflBEq. This is what I got:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">mutual</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">beq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">children1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">children2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">listBeq</span><span class=\"w\"> </span><span class=\"n\">children1</span><span class=\"w\"> </span><span class=\"n\">children2</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">listBeq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">beq</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">listBeq</span><span class=\"w\"> </span><span class=\"n\">xs1</span><span class=\"w\"> </span><span class=\"n\">xs2</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">beq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">beq</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">beq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">listBeq</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ReflBEq</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">rec</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">motive_1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">beq</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">listBeq</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">ih1</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n<span class=\"w\">    </span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">trivial</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp_all!</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 540604122,
        "sender_full_name": "Pavel Klimov",
        "timestamp": 1758393025
    },
    {
        "content": "<p>Also, why it doesn't work if I write <code>==</code> instead of <code>Node.beq</code> and <code>Node.listBeq</code>?</p>",
        "id": 540604264,
        "sender_full_name": "Pavel Klimov",
        "timestamp": 1758393189
    }
]