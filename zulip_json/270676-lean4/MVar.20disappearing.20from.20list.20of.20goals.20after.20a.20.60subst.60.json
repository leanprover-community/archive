[
    {
        "content": "<p>Hi, I had a question about the expected behaviour of metavariables in Lean, as there are situations when <code>MVars</code> can get assigned with new <code>MVars</code>, where the new <code>MVars</code> are not added to the goal, making them disappear from the list of goals.  This leads to us losing track of <code>MVars</code>, and results in:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">kernel</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">declaration</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">metavariables</span><span class=\"w\"> </span><span class=\"bp\">'_</span><span class=\"n\">example'</span>\n</code></pre></div>\n<p>because there are unassigned <code>MVars</code> in the proof term.  Is this something others have encountered?  In Coq there is a \"shelf\", and evars have to be unshelved at the end of the proof if they remained unassigned.  I'll post a detailed example below.</p>",
        "id": 464368446,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1724331745
    },
    {
        "content": "<p>In the example below we create a small tactic called <code>createMVar</code>, which doesn't do anything useful but just shows the problem.  We have other tactics that do useful things with the MVar that exhibit the same problem.  The tactic creates a <code>natural</code> or <code>syntheticOpaque</code> <code>MVar</code> in the context, as part of the type of an equality hypothesis, where the proof is <code>rfl</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">(:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It then returns the modified goal MVar with the updated context, as well as a new goal for <code>?m</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Tactic</span>\n\n<span class=\"n\">syntax</span><span class=\"w\"> </span><span class=\"n\">naturalOrSynthetic</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"natural\"</span><span class=\"w\"> </span><span class=\"bp\">&lt;|&gt;</span><span class=\"w\"> </span><span class=\"s2\">\"synthetic\"</span>\n\n<span class=\"n\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"createMVar\"</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">naturalOrSynthetic</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">withMainContext</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mvarKind</span><span class=\"w\"> </span><span class=\"bp\">←</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">naturalOrSynthetic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">natural</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">MetavarKind.natural</span>\n<span class=\"w\">                 </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">naturalOrSynthetic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">synthetic</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">MetavarKind.syntheticOpaque</span>\n<span class=\"w\">                 </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkConst</span><span class=\"w\"> </span><span class=\"ss\">``Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mvarKind</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppOptM</span><span class=\"w\"> </span><span class=\"ss\">``Eq</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">mkConst</span><span class=\"w\"> </span><span class=\"ss\">``Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mkConst</span><span class=\"w\"> </span><span class=\"ss\">``Nat.zero</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``Eq.refl</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">mkConst</span><span class=\"w\"> </span><span class=\"ss\">``Nat.zero</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">liftMetaTactic</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">mvarId</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">newMVar</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mvarId.assert</span><span class=\"w\"> </span><span class=\"ss\">`HR</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">proof</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">newMVar</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">newMVar.intro1P</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">newMVar</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l.mvarId</span><span class=\"bp\">!</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Create a natural MVar in an hypothesis and add it as a goal</span>\n<span class=\"w\">  </span><span class=\"n\">createMVar</span><span class=\"w\"> </span><span class=\"n\">natural</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Substitution assigns the MVar with a new MVar, making the goal disappear</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Solve the only remaining goal</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"c1\">-- (kernel) declaration has metavariables '_example'</span>\n</code></pre></div>\n<p>Creating a <code>natural</code> <code>MVar</code>, which is the behaviour we want because eventually we would like to unify the <code>MVar</code> through <code>isDefEq</code> results in the MVar goal disappearing.  This means that if we happen to not unify the <code>MVar</code> naturally, there won't be any references left that we could use to assign it explicitly.</p>\n<p>Using a <code>syntheticOpaque</code> <code>MVar</code> exhibits the behaviour we are looking for, where the goal is still left open after the substitution, and we can fill it using <code>exact 0</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">createMVar</span><span class=\"w\"> </span><span class=\"n\">synthetic</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"n\">construction</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>Digging down further, the real issue seems to be in the <code>revert</code> function.  It assigns any natural <code>MVar</code> that is encountered, which makes sense for the main goal, but for other <code>MVar</code> it will assign them but won't return the new MVar reference.</p>\n<p>The code below shows that <code>revert</code> will remove the second goal associated with the <code>MVar</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">createMVar</span><span class=\"w\"> </span><span class=\"n\">natural</span>\n<span class=\"w\">  </span><span class=\"n\">run_tac</span><span class=\"w\"> </span><span class=\"n\">withMainContext</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getFVarId</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`s</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">liftMetaTactic</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">mvarId</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mvarId</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mvarId.revert</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">s</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mvarId</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">intros</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">constructor</span>\n</code></pre></div>\n<p><code>revert</code> seems to eventually call <code>elimMVar</code> on the main goal, but eventually also applies <code>elimMVar</code> on the <code>MVar</code> we introduced (through <code>elimApp</code>), resulting in an assignment of the <code>MVar</code>.  It is therefore removed from the list of goals, but it is never substituted by a new goal for the newly introduced <code>MVar</code>.</p>\n<p>The main questions I had were the following:</p>\n<ul>\n<li>\n<p>Is it expected that all <code>MVar</code> should have an associated goal (if these are not assigned or used within a tactic internally)?  In this case, it would seem like the interface of the <code>revert</code> function is not expressive enough, and it might have to return a list of new goals instead of just the main new <code>MVar</code>.</p>\n</li>\n<li>\n<p>Otherwise, is there a <code>Shelf</code>, similar to Coq?  Coq doesn't try and keep track of all the <code>MVar</code> as goals, instead they are saved and at the end of the proof the <code>MVar</code> that are present in the proof but are not assigned can be <code>Unshelved</code> and assigned explicitly.</p>\n</li>\n<li>\n<p>We are thinking of implementing a tactic which will check the proof term and \"unshelve\" all the unassigned <code>MVar</code> that are left in the proof term.  This would essentially be a wrapper around <code>by</code>, which then produces new goals for all the <code>MVar</code> that were unassigned in the proof.</p>\n</li>\n</ul>\n<p>Finally, we may also be misusing <code>MVar</code>, and currently we have a few cases where we actually don't care about the exact value of the <code>MVar</code>.  Instead, we partially assign them until we find a contradiction.  But this fails because they remain unassigned even though there are no goals to assign them anymore (because <code>subst</code> eliminates them).  However, we also think that we have found cases where <code>MVar</code> introduced by <code>apply</code> disappear and lead to the same issue.</p>",
        "id": 464369005,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1724331816
    },
    {
        "content": "<p>that situation is considered a bug in the tactic that lost track of the goals</p>",
        "id": 464369030,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1724331820
    },
    {
        "content": "<p>Yeah that makes sense, I posted the detailed example, and <code>subst</code>, or more precisely <code>revert</code> assigns the <code>MVar</code> with a new <code>MVar</code> without adding it to the goal.</p>",
        "id": 464370105,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1724331933
    },
    {
        "content": "<p>in your example, I think <code>createMVar</code> is also misbehaving, because <code>proof</code> does not have the same type as <code>app</code>, which I'm guessing <code>MVarId.assert</code> assumes</p>",
        "id": 464370635,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1724332004
    },
    {
        "content": "<p>you need to unify <code>app</code> with the type of <code>proof</code> and this process will end up solving the metavariable <code>l</code> you have created</p>",
        "id": 464370828,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1724332037
    },
    {
        "content": "<p>Hmm, I was just trying to write a tactic which leaves unassigned <code>MVars</code> in the context.  I think that this proof should still type-check at the end if we ever assign the <code>MVar</code>.</p>",
        "id": 464371129,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1724332086
    },
    {
        "content": "<p>Of course if we assign it correctly, so it should always be assigned to <code>0</code>, otherwise we get a panic during the final term type checking.</p>",
        "id": 464371319,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1724332123
    },
    {
        "content": "<p>you could create a metavariable for <code>proof</code> instead of using <code>Eq.refl</code></p>",
        "id": 464371568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1724332166
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"688543\">Yann Herklotz</span> <a href=\"#narrow/stream/270676-lean4/topic/MVar.20disappearing.20from.20list.20of.20goals.20after.20a.20.60subst.60/near/464371319\">said</a>:</p>\n<blockquote>\n<p>Of course if we assign it correctly, so it should always be assigned to <code>0</code>, otherwise we get a panic during the final term type checking.</p>\n</blockquote>\n<p>Well there is nothing that is keeping track of this fact, that it should not be assigned to anything other than <code>0</code>, which is why this is considered an invariant violation</p>",
        "id": 464372153,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1724332264
    },
    {
        "content": "<p>But this doesn't lead to inconsistencies right? If you ever use the hypothesis the <code>MVar</code> will be unified, and the expression will be present in the term, and it will be type checked, at which point the user has to ensure that they unified correctly (otherwise it results in a panic which makes sense).  I'm trying to see if adding it as the proof goal leads to the same issue though.</p>",
        "id": 464373220,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1724332442
    },
    {
        "content": "<p>Here's a version that creates another metavariable for <code>proof</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"n\">naturalOrSynthetic</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"natural\"</span><span class=\"w\"> </span><span class=\"bp\">&lt;|&gt;</span><span class=\"w\"> </span><span class=\"s2\">\"synthetic\"</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"createMVar\"</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">naturalOrSynthetic</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">withMainContext</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mvarKind</span><span class=\"w\"> </span><span class=\"bp\">←</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">naturalOrSynthetic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">natural</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">MetavarKind</span><span class=\"bp\">.</span><span class=\"n\">natural</span>\n<span class=\"w\">                 </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">naturalOrSynthetic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">synthetic</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">MetavarKind</span><span class=\"bp\">.</span><span class=\"n\">syntheticOpaque</span>\n<span class=\"w\">                 </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">unreachable!</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkConst</span><span class=\"w\"> </span><span class=\"ss\">``Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mvarKind</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppOptM</span><span class=\"w\"> </span><span class=\"ss\">``Eq</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">mkConst</span><span class=\"w\"> </span><span class=\"ss\">``Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mkConst</span><span class=\"w\"> </span><span class=\"ss\">``Nat.zero</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVar</span><span class=\"w\"> </span><span class=\"n\">app</span>\n<span class=\"w\">  </span><span class=\"n\">liftMetaTactic</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">mvarId</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">newMVar</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mvarId</span><span class=\"bp\">.</span><span class=\"n\">assert</span><span class=\"w\"> </span><span class=\"ss\">`HR</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">proof</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">newMVar</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">newMVar</span><span class=\"bp\">.</span><span class=\"n\">intro1P</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">newMVar</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">mvarId!</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"bp\">.</span><span class=\"n\">mvarId!</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Create a natural MVar in an hypothesis and add it as a goal</span>\n<span class=\"w\">  </span><span class=\"n\">createMVar</span><span class=\"w\"> </span><span class=\"n\">natural</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Substitution assigns the MVar with a new MVar, making the goal disappear</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>",
        "id": 464373471,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1724332486
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"688543\">Yann Herklotz</span> <a href=\"#narrow/stream/270676-lean4/topic/MVar.20disappearing.20from.20list.20of.20goals.20after.20a.20.60subst.60/near/464373220\">said</a>:</p>\n<blockquote>\n<p>and it will be type checked</p>\n</blockquote>\n<p>Terms are not eagerly typechecked multiple times during elaboration for performance reasons. So each tactic and elaborator is responsible for contributing only well-typed-ly to the goal</p>",
        "id": 464374040,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1724332570
    },
    {
        "content": "<p>if a tactic fails to uphold its part of the bargain, the kernel will catch the typing error and this is a tactic bug</p>",
        "id": 464374420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1724332632
    },
    {
        "content": "<p>Interesting, would you expect the goal associated with the <code>MVar</code> in the context to disappear?  It will be assigned when providing the proof to the hypothesis I guess.</p>",
        "id": 464374495,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1724332646
    },
    {
        "content": "<p>I think some of the guidance around this is mixed, but I think the prevailing opinion is that dependent mvars should be goals, because otherwise you can contrive situations where they are not solved, as in my example here where I used <code>cases x</code> to avoid solving the mvar in the goal en passant</p>",
        "id": 464375077,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1724332737
    },
    {
        "content": "<p>meaning that this behavior is a bug in <code>subst</code></p>",
        "id": 464375271,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1724332772
    },
    {
        "content": "<p>although I guess tactics will not normally use natural mvars in this situation</p>",
        "id": 464376133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1724332909
    },
    {
        "content": "<p>and <code>subst</code> does not have the same behavior on synthetic mvars</p>",
        "id": 464376309,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1724332927
    },
    {
        "content": "<p>Ah I didn't see the <code>x</code>, OK that makes sense.  Do the questions I added at the end make sense as possible solutions? I would guess that <code>revert</code> needs to be a bit more expressive and return a list of fresh <code>MVars</code> that it introduced.</p>\n<p>We use natural mvars so that we can already unify them in the main goal if we can, instead of having to explicitly assign them.  This seems to be similar to the behaviour of <code>apply</code> right?</p>",
        "id": 464376742,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1724333002
    },
    {
        "content": "<p>And I think we found similar behaviour in <code>apply</code>, but haven't quite reduced it yet.  We have to be very careful about using apply explicitly with the right number of <code>_</code>, otherwise it leads to mvars also disappearing that were introduced by <code>apply</code>.</p>",
        "id": 464376822,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1724333018
    },
    {
        "content": "<p>But it's true, <code>subst</code> behaves correctly on synthetic mvars.</p>",
        "id": 464377013,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1724333048
    },
    {
        "content": "<p>there is a tactic along the lines of your last bullet, called <code>recover</code>, but it's basically only for debugging purposes</p>",
        "id": 464378135,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1724333240
    },
    {
        "content": "<p>Ah interesting thank you, I'll have a look at that, but yes it doesn't seem like the best solution.  We essentially just have some cases in our proof where we can prove a contradiction without assigning some mvars, and currently they completely disappear, leading to a kernel panic.  And I'm not sure how our tactic can keep track of them other than adding them to the goal, which doesn't seem to work when they are natural and we use <code>subst</code> or <code>revert</code>.</p>",
        "id": 464380341,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1724333600
    },
    {
        "content": "<p>why not make them synthetic?</p>",
        "id": 464384994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1724334499
    },
    {
        "content": "<p>We would like tactics like <code>apply</code> in the main goal to be able to assign the mvars through unification.  And I believe that some new mvars introduced by <code>apply</code> will also be natural.</p>",
        "id": 464386357,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1724334944
    },
    {
        "content": "<p>There are just some cases where we prove a contradiction without having to unify all mvars, in which case we don't actually care about their value.  Maybe these mvars should never have been created in the first place, but they make finding the contradiction much easier.</p>",
        "id": 464387241,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1724335200
    },
    {
        "content": "<p>Is it a rule that goals should be synthetic mvars?  Tactics like <code>apply</code> seem to manage not to do this though, because they create goals for mvars that can be assigned by unification.</p>",
        "id": 464388564,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1724335598
    },
    {
        "content": "<p>The fact that <code>apply</code> isn't creating synthetic mvar goals might be an oversight. Tactics seem to be inconsistent about this.</p>\n<p>The concept behind synthetic metavariables is that defeq inside of elaboration shouldn't be able to assign certain metavariables. Instead, all of these unifications can happen in a separate stage post-elaboration where synthetic metavariables become assignable, using the <code>withAssignableSyntheticOpaque</code> combinator. (Tactics seem to be inconsistent about using this combinator too.)</p>",
        "id": 464441899,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724348076
    },
    {
        "content": "<p>Ah thanks, I was under the impression that having to use <code>withAssignableSyntheticOpaque</code> in our tactics was a bit of a hack, but it's interesting to know that it's deliberate and the reasoning behind it. That makes sense, and we'll try using synthetic mvars then. </p>\n<p>Should <code>apply</code> be using <code>withAssignableSyntheticOpaque</code> as well? Because when one is using apply one often wants to force unification.</p>",
        "id": 464583038,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1724401467
    }
]