[
    {
        "content": "<p>I was trying to make <code>bound</code> know about <code>Finset.le_sup</code> at least in the <code>Finset.univ</code> case, but I am running into apply failures:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Lattice</span><span class=\"bp\">.</span><span class=\"n\">Fold</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Bound</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- Failed attempt at a version of `Finset.le_sup` that works inside `bound` -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">bound</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">le_univ_sup</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SemilatticeSup</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OrderBot</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"bp\">.</span><span class=\"n\">sup</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">le_sup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">mem_univ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- If we use `f` directly, `bound` works -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">bound_works</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"bp\">.</span><span class=\"n\">sup</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">bound</span>\n\n<span class=\"sd\">/-- If we have a fancier expression, `bound` fails -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">bound_fails</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"bp\">.</span><span class=\"n\">sup</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- apply Finset.le_univ_sup (f := fun x ↦ (f x) ^ 2)  -- Works</span>\n<span class=\"w\">  </span><span class=\"n\">bound</span><span class=\"w\">  </span><span class=\"c1\">-- Fails</span>\n\n<span class=\"sd\">/-- Indeed, `apply` already fails for the fancy expression version -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">apply_fails</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"bp\">.</span><span class=\"n\">sup</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- apply Finset.le_univ_sup (f := fun x ↦ (f x) ^ 2)  -- Works</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">le_univ_sup</span><span class=\"w\">  </span><span class=\"c1\">-- Fails</span>\n</code></pre></div>\n<p>Presumably the problem is that <code>apply</code> (and thus the apply machinery inside aesop on which bound is built) do not know to infer the function from the RHS of the equality goal first, before looking at the LHS. I initially tried to fix this with <code>no_index</code>, but with hindsight it is unsurprising that this has no effect given that <code>apply</code> also fails.</p>\n<p>Is there a way to write the <code>Finset.le_univ_sup</code> lemma such that the bare apply and the bound work?</p>",
        "id": 494913961,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1737407500
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Do you know how to make this kind of thing infer?</p>",
        "id": 496055249,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1737964505
    },
    {
        "content": "<p>If you replace the <code>≤</code> by a <code>≥</code> and swap the two arguments, it will work.</p>\n<p>The reason is that unifying the <code>Finset.univ.sup fun x =&gt; f x</code> (or just <code>Finset.univ.sup f</code>) instantiates the <code>f</code>. But if it first tries to unify the <code>f x</code>, unification doesn't know what to do and does an incorrect instantiation. So the problem is the order in which the subexpressions are unified.</p>",
        "id": 496204848,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1738009057
    },
    {
        "content": "<p>A mechanism to steer the unification order without writing the inequality backwards would be nice here, but maybe one doesn't exist</p>",
        "id": 496205216,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738009205
    },
    {
        "content": "<p>Yes, I don't think this exists.</p>",
        "id": 496205329,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1738009257
    },
    {
        "content": "<p>Writing the equality backwards only helps if it is backwards in both the lemma and the goal, because otherwise <code>≥</code>gets unfolded to <code>≤</code>, so that isn't really a useful solution here.</p>",
        "id": 496206301,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1738009666
    },
    {
        "content": "<p>If we can't mess with the order, is there a way to make the LHS <code>f</code> not unifiable at all, so that it looks like a black box until the RHS <code>f</code> infers and only then unfolds?</p>",
        "id": 496209454,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1738010964
    },
    {
        "content": "<p>I think you're suggesting the same as Eric: a way to tell lean do unification in a different order.</p>",
        "id": 496210394,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1738011383
    }
]