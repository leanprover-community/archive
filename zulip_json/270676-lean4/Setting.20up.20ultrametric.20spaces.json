[
    {
        "content": "<p>With some colleagues, we are trying to formalize the theory of ultrametric spaces in Lean4, where the ultrametric distance is allowed to take values in any linear order (with a <code>Bot</code> acting as 0). My first idea was to take <code>Mathlib.Topology.MetricSpace.Basic</code> and adapt it, and also to put a <code>MetricSpace</code> instance on an ultrametric space whose distance takes values in nonnegative reals. I quickly ran into problems when I tried to put a <code>UniformSpace</code> instance on a pseudo ultrametric space. Here is a (somewhat M)WE, where I ignore the bornology:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Positivity</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Algebra.Order.Compact</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.MetricSpace.EMetricSpace</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Bornology.Constructions</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.MetricSpace.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Filter.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.UniformSpace.Basic</span>\n\n\n<span class=\"kn\">open</span> <span class=\"n\">Set</span> <span class=\"n\">Filter</span> <span class=\"n\">TopologicalSpace</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">BigOperators</span> <span class=\"n\">Uniformity</span> <span class=\"n\">Topology</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span>\n\n\n<span class=\"sd\">/-- Define a `UniformSpace` using a \"ultradistance\" function. The function can be, e.g., the</span>\n<span class=\"sd\">distance in an ultrametric space or a nonarchimedean norm. -/</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">UniformSpace.ofUltrafun</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">WithZero</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">triangle</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"bp\">‚â§</span> <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">UniformSpace</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span>\n<span class=\"bp\">.</span><span class=\"n\">ofCore</span>\n  <span class=\"o\">{</span> <span class=\"n\">uniformity</span> <span class=\"o\">:=</span> <span class=\"bp\">‚®Ö</span> <span class=\"n\">r</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">ùìü</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">d</span> <span class=\"n\">x.1</span> <span class=\"n\">x.2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">r</span> <span class=\"o\">}</span>\n    <span class=\"n\">refl</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">gt_iff_lt</span><span class=\"o\">,</span> <span class=\"n\">not_lt</span><span class=\"o\">,</span> <span class=\"n\">le_iInf_iff</span><span class=\"o\">,</span> <span class=\"n\">le_principal_iff</span><span class=\"o\">,</span> <span class=\"n\">mem_principal</span><span class=\"o\">,</span> <span class=\"n\">idRel_subset</span><span class=\"o\">,</span> <span class=\"n\">mem_setOf_eq</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">hpos</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">refl</span> <span class=\"n\">a</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">hpos</span>\n    <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">gt_iff_lt</span><span class=\"o\">,</span> <span class=\"n\">not_lt</span><span class=\"o\">,</span> <span class=\"n\">tendsto_iInf</span><span class=\"o\">,</span> <span class=\"n\">tendsto_principal</span><span class=\"o\">,</span> <span class=\"n\">mem_setOf_eq</span><span class=\"o\">,</span> <span class=\"n\">Prod.fst_swap</span><span class=\"o\">,</span> <span class=\"n\">Prod.snd_swap</span><span class=\"o\">]</span>\n               <span class=\"n\">intro</span> <span class=\"n\">i</span> <span class=\"n\">hpos</span>\n               <span class=\"n\">unfold</span> <span class=\"n\">Filter.Eventually</span>\n               <span class=\"n\">simp</span> <span class=\"n\">only</span>\n               <span class=\"n\">apply</span> <span class=\"n\">Filter.mem_iInf_of_mem</span> <span class=\"n\">i</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">Filter.mem_iInf_of_mem</span>\n               <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_principal</span><span class=\"o\">,</span> <span class=\"n\">setOf_subset_setOf</span><span class=\"o\">,</span> <span class=\"n\">Prod.forall</span><span class=\"o\">]</span>\n               <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hab</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">symm</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">hab</span>\n               <span class=\"n\">exact</span> <span class=\"n\">hpos</span>\n    <span class=\"n\">comp</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">gt_iff_lt</span><span class=\"o\">,</span> <span class=\"n\">not_lt</span><span class=\"o\">,</span> <span class=\"n\">le_iInf_iff</span><span class=\"o\">,</span> <span class=\"n\">le_principal_iff</span><span class=\"o\">]</span>\n               <span class=\"n\">intro</span> <span class=\"n\">i</span> <span class=\"n\">hpos</span>\n               <span class=\"n\">unfold</span> <span class=\"n\">Filter.lift'</span>\n               <span class=\"n\">unfold</span> <span class=\"n\">Filter.lift</span>\n               <span class=\"n\">apply</span> <span class=\"n\">Filter.mem_iInf_of_mem</span> <span class=\"o\">({</span> <span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">d</span> <span class=\"n\">x.1</span> <span class=\"n\">x.2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span><span class=\"o\">})</span>\n               <span class=\"n\">apply</span> <span class=\"n\">Filter.mem_iInf_of_mem</span>\n               <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Function.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">mem_principal</span><span class=\"o\">]</span>\n               <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.subset_def</span><span class=\"o\">]</span>\n               <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_setOf_eq</span><span class=\"o\">,</span> <span class=\"n\">Prod.forall</span><span class=\"o\">,</span> <span class=\"n\">mem_compRel</span><span class=\"o\">,</span> <span class=\"n\">forall_exists_index</span><span class=\"o\">,</span> <span class=\"n\">and_imp</span><span class=\"o\">]</span>\n               <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"n\">hax</span> <span class=\"n\">hxb</span>\n               <span class=\"n\">apply</span> <span class=\"n\">lt_of_le_of_lt</span> <span class=\"o\">(</span><span class=\"n\">triangle</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n               <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ge_iff_le</span><span class=\"o\">,</span> <span class=\"n\">max_lt_iff</span><span class=\"o\">]</span>\n               <span class=\"n\">exact</span> <span class=\"o\">‚ü®</span><span class=\"n\">hax</span><span class=\"o\">,</span> <span class=\"n\">hxb</span><span class=\"o\">‚ü©</span>\n               <span class=\"n\">apply</span> <span class=\"n\">Filter.mem_iInf_of_mem</span> <span class=\"n\">i</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">Filter.mem_iInf_of_mem</span>\n               <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_principal</span><span class=\"o\">,</span> <span class=\"n\">setOf_subset_setOf</span><span class=\"o\">,</span> <span class=\"n\">imp_self</span><span class=\"o\">,</span> <span class=\"n\">Prod.forall</span><span class=\"o\">,</span> <span class=\"n\">implies_true</span><span class=\"o\">]</span>\n               <span class=\"n\">exact</span> <span class=\"n\">hpos</span>\n               <span class=\"o\">}</span>\n\n\n<span class=\"sd\">/-- Construct a uniform structure from an ultradistance function and ultrametric space axioms -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">UniformSpace.ofUltradist</span> <span class=\"o\">(</span><span class=\"n\">udist</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">WithZero</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">udist_self</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">udist</span> <span class=\"n\">x</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">udist_comm</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">udist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">udist</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">udist_strong_triangle</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">udist</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"bp\">‚â§</span> <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">udist</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">udist</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">UniformSpace</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">.</span><span class=\"n\">ofUltrafun</span> <span class=\"n\">udist</span> <span class=\"n\">udist_self</span> <span class=\"n\">udist_comm</span> <span class=\"n\">udist_strong_triangle</span>\n\n\n\n<span class=\"sd\">/-- The ultradistance function (given an ambient ultrametric space on `Œ±`), which returns</span>\n<span class=\"sd\">  an element of WithZero Œ≤ `udist x y` given `x y : Œ±`. -/</span>\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">class</span> <span class=\"n\">Ultradist</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">udist</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">WithZero</span> <span class=\"n\">Œ≤</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">Ultradist</span> <span class=\"o\">(</span><span class=\"n\">udist</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Pseudo ultrametric spaces-/</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">PseudoUltrametricSpace</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">Ultradist</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">udist_self</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">udist</span> <span class=\"n\">x</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">udist_comm</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">udist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">udist</span> <span class=\"n\">y</span> <span class=\"n\">x</span>\n  <span class=\"n\">udist_strong_triangle</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">udist</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"bp\">‚â§</span> <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">udist</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">udist</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n  <span class=\"n\">toUniformSpace</span> <span class=\"o\">:</span> <span class=\"n\">UniformSpace</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">ofUltradist</span> <span class=\"n\">udist</span> <span class=\"n\">udist_self</span> <span class=\"n\">udist_comm</span> <span class=\"n\">udist_strong_triangle</span>\n  <span class=\"n\">uniformity_udist</span> <span class=\"o\">:</span> <span class=\"bp\">ùì§</span> <span class=\"n\">Œ±</span> <span class=\"bp\">=</span> <span class=\"bp\">‚®Ö</span> <span class=\"n\">Œµ</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">ùìü</span> <span class=\"o\">{</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">√ó</span> <span class=\"n\">Œ±</span> <span class=\"bp\">|</span> <span class=\"n\">udist</span> <span class=\"n\">p.1</span> <span class=\"n\">p.2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Œµ</span> <span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">PseudoUltrametricSpace</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">PseudoUltrametricSpace.toUniformSpace</span> <span class=\"c1\">--  cannot find synthesization order for instance @PseudoUltrametricSpace.toUniformSpace with type</span>\n  <span class=\"c1\">--{Œ± : Type u} ‚Üí (Œ≤ : Type v) ‚Üí [inst : LinearOrder Œ≤] ‚Üí [self : PseudoUltrametricSpace Œ± Œ≤] ‚Üí UniformSpace Œ± all remaining arguments have metavariables:</span>\n  <span class=\"c1\">-- LinearOrder ?Œ≤ @PseudoUltrametricSpace Œ± ?Œ≤ ?inst‚úù</span>\n</code></pre></div>\n<p>Is the problem that the pseudo ultrametric space depends on the parameters <code>Œ±</code> and <code>Œ≤</code>, while only <code>Œ± </code> explicitly appears in the the uniform space ?</p>",
        "id": 358668746,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684228963
    },
    {
        "content": "<p>Also, more generally, I wonder if this is the right way to proceed or if it will cause trouble in the future. For example:<br>\n(1) While it cause trouble for ultrametric spaces with real-valued distance function to a have a <code>MetricSpace</code> instance ? They would then get <code>UniformSpace</code> instances from the ultrametric space and the metric space structures.<br>\n(2) What about spaces with two \"natural\" ultrametric distances, for example a finite extension of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> with either its normalization valuation, or the unique extension of the normalized valuation of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> ? It would also get two <code>UniformSpace</code> instances from that. Is there a better way to proceed that would avoid this problem, or are we doomed to pain one way or another ?</p>",
        "id": 358669943,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684229213
    },
    {
        "content": "<p>In the latter example, I think we should define both ultrametrics, but we shouldn't mark them as <code>instance</code> globally. Then people can choose which one the want to use on a local level.</p>",
        "id": 358674910,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1684230412
    },
    {
        "content": "<p>Can't explain much more right now, but you're basically hitting the same problem that made us specialise <code>metric_space</code> to <code>real</code> in the first place. In the case of ultrametric spaces, have you tried making them a non-class structure? that is, work with the type of ultrametrics, rather than with a canonical ultrametric space?</p>",
        "id": 358677217,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1684230968
    },
    {
        "content": "<p>yes, the alternative that we see is to mimic the Valuation/Valued design, do you recommend it?</p>",
        "id": 358682556,
        "sender_full_name": "Olivier Ta√Øbi",
        "timestamp": 1684232334
    },
    {
        "content": "<p>Yes, I believe it will spare you a lot of pain, at the cost of making some steps (eg translation from and to a metric space)</p>",
        "id": 358689302,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1684234150
    },
    {
        "content": "<p>I don't know the details, but in the measure theory library there is a solution to have a \"default measure\" on a space, but still it is quite convenient to integrate against a different measure if needed. Maybe a similar thing can be done for ultrametrics?</p>",
        "id": 358814824,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1684260944
    },
    {
        "content": "<p>Bienvenue Olivier !</p>",
        "id": 358823333,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1684263361
    },
    {
        "content": "<p>Sophie, you immediate issue can be solved by marking <code>Œ≤</code> as <code>outParam</code>. For instance <code>class Ultradist (Œ± : Type _) (Œ≤ : outParam $ Type _) [LinearOrder Œ≤]</code>. This tells the type class resolution system to look for <code>Œ≤</code> later.</p>",
        "id": 358823939,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1684263528
    },
    {
        "content": "<p>And then indeed you can probably take inspiration from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Valued#doc\">docs4#Valued</a>.</p>",
        "id": 358824132,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1684263593
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/stream/270676-lean4/topic/Setting.20up.20ultrametric.20spaces/near/358677217\">said</a>:</p>\n<blockquote>\n<p>Can't explain much more right now, but you're basically hitting the same problem that made us specialise <code>metric_space</code> to <code>real</code> in the first place. In the case of ultrametric spaces, have you tried making them a non-class structure? that is, work with the type of ultrametrics, rather than with a canonical ultrametric space?</p>\n</blockquote>\n<p>I'm afraid I don't know enough to apply that suggestion, sorry. I don't know what exactly a <code>class</code> is except the name of certain types of structures in mathlib... I clearly need to spend some more time thinking about this.</p>",
        "id": 358828853,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684264978
    },
    {
        "content": "<p>I'm also not sure what Yael means there. I think that decision was before my time, but I suspect it was done that way just because no one needed the generalization</p>",
        "id": 358830386,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684265482
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/inner_product_space\">docs#inner_product_space</a> is an example of a similar typeclass design that doesn't limit the output type to <code>real</code></p>",
        "id": 358830489,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684265511
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/Setting.20up.20ultrametric.20spaces/near/358823939\">said</a>:</p>\n<blockquote>\n<p>Sophie, you immediate issue can be solved by marking <code>Œ≤</code> as <code>outParam</code>. For instance <code>class Ultradist (Œ± : Type _) (Œ≤ : outParam $ Type _) [LinearOrder Œ≤]</code>. This tells the type class resolution system to look for <code>Œ≤</code> later.</p>\n</blockquote>\n<p>Thanks Patrick ! Your suggestion worked, for now, and though we'll probably have to rewrite the file entirely I learned something useful. Now I just want universes problems to pop up too so that I can use the tricks I learned in the other thread. <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>\n<p>So it seems that it might be better to make <code>UltrametricSpace</code> a class that extends <code>UniformSpace</code> ? (And probably <code>Bornology</code> as well.)</p>",
        "id": 358830615,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684265536
    },
    {
        "content": "<p>Is there a reason you're using <code>[LinearOrder Œ≤]</code> and <code>WithZero Œ≤</code> instead of <code>[OrderBot Œ≤] [LinearOrder Œ≤]</code> and <code>Œ≤</code>?</p>",
        "id": 358831061,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684265688
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Setting.20up.20ultrametric.20spaces/near/358830489\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/inner_product_space\">docs#inner_product_space</a> is an example of a similar typeclass design that doesn't limit the output type to <code>real</code></p>\n</blockquote>\n<p>Interesting, thank you for the reference ! <br>\nWe had the \"real versus more general value groups\" discussion, and decided that we didn't want to restrict to reals, as valuations of rank greater than 1 are becoming more and more important in p-adic geometry.</p>",
        "id": 358831195,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684265743
    },
    {
        "content": "<p>I think the target of your ultradist should be a <code>LinearOrderedCommMonoidWithZero</code>, similar to how it's done in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Valuation#doc\">docs4#Valuation</a></p>",
        "id": 358832943,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1684266329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Setting.20up.20ultrametric.20spaces/near/358831061\">said</a>:</p>\n<blockquote>\n<p>Is there a reason you're using <code>[LinearOrder Œ≤]</code> and <code>WithZero Œ≤</code> instead of <code>[OrderBot Œ≤] [LinearOrder Œ≤]</code> and <code>Œ≤</code>?</p>\n</blockquote>\n<p>Well, it was because, except for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">R</mi><mrow><mo>‚â•</mo><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}_{\\geq 0}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9341em;vertical-align:-0.2452em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">‚â•</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2452em;\"><span></span></span></span></span></span></span></span></span></span>, all the other value groups that I have met do arise as linearly ordered commutative groups with a smallest element added, so it seemed like a natural thing to do. But later I also thought about using <code>[Zero Œ≤] [LinearOrder Œ≤]</code> instead, and it certainly seems as if it would make the comparison with metric spaces easier. So it's up for debate.</p>\n<p>If you have any wisdom on that subject (for example, if you can see that one of the solutions would lead to much more pain down the road), then I would be glad to listen to it.</p>",
        "id": 358832956,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684266336
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/270676-lean4/topic/Setting.20up.20ultrametric.20spaces/near/358832943\">said</a>:</p>\n<blockquote>\n<p>I think the target of your ultradist should be a <code>LinearOrderedCommMonoidWithZero</code>, similar to how it's done in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Valuation#doc\">docs4#Valuation</a></p>\n</blockquote>\n<p>Hi Adam, to make sense of the definition of an ultrametric we don't even need an addition, just an order with a smallest element and a notion of the max of two elements, i.e. a <code>SemilatticeSup</code> with a <code>Bot</code>. Even the <code>LinearOrder</code> is too much and I have been feeling a bit guilty about using it. For later I agree that we should not jump into ordered groups too quickly and stick with ordered monoids as long as possible.</p>",
        "id": 358833525,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684266535
    },
    {
        "content": "<p>Oh, I see okay. In that case, I do agree with Eric</p>",
        "id": 358833657,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1684266587
    },
    {
        "content": "<p>Have you tried using <code>SemilatticeSup</code>?</p>",
        "id": 358833843,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1684266637
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/270676-lean4/topic/Setting.20up.20ultrametric.20spaces/near/358833843\">said</a>:</p>\n<blockquote>\n<p>Have you tried using <code>SemilatticeSup</code>?</p>\n</blockquote>\n<p>In the next version I probably will try !</p>",
        "id": 358833937,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684266679
    },
    {
        "content": "<p>(Although I am not alone in this, so maybe I will be overruled by my more reasonable colleagues.)</p>",
        "id": 358834011,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684266704
    },
    {
        "content": "<p><code>[Zero Œ≤] [LinearOrder Œ≤]</code> is not the same as <code>[LinearOrder Œ≤] [OrderBot Œ≤]</code>, as the former does not require that <code>0</code> be the lowest element</p>",
        "id": 358834303,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684266801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Setting.20up.20ultrametric.20spaces/near/358834303\">said</a>:</p>\n<blockquote>\n<p><code>[Zero Œ≤] [LinearOrder Œ≤]</code> is not the same as <code>[OrderBot Œ≤] [LinearOrder Œ≤]</code>, as the former does not require that <code>0</code> be the lowest element</p>\n</blockquote>\n<p>Ah, thank ! Then I definitely want the second and not the first.</p>",
        "id": 358834440,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684266851
    },
    {
        "content": "<p>But as Adam says, you might only need <code>[SemiLatticeSup Œ≤] [OrderBot Œ≤]</code></p>",
        "id": 358834516,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684266881
    },
    {
        "content": "<p>The annoying thing is that if and when you do want to relate this to some valuation, it may be annoying to go back and forth between <code>\\bot</code> and <code>0</code>.</p>",
        "id": 358834598,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1684266914
    },
    {
        "content": "<p>Right, it's very believable that all this generality is useless and <code>LinearOrderedCommMonoidWithZero</code> is enough (as you said above)</p>",
        "id": 358834804,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684266983
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Setting.20up.20ultrametric.20spaces/near/358834804\">said</a>:</p>\n<blockquote>\n<p>Right, it's very believable that all this generality is useless and <code>LinearOrderedCommMonoidWithZero</code> is enough (as you said above)</p>\n</blockquote>\n<p>I thought that one of the principles of Lean was that you don't put conditions on stuff before you actually need them.</p>",
        "id": 358834901,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684267020
    },
    {
        "content": "<p>Within reason :)</p>",
        "id": 358834926,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1684267031
    },
    {
        "content": "<p>The addition is totally irrelevant to the definition of an ultrametric and only appears when you define a valuation on something that has a multiplication.</p>",
        "id": 358835049,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684267075
    },
    {
        "content": "<p>For a counterexample, see <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module\">docs#module</a>; that doesn't \"need\" <code>add_comm_monoid</code>, <code>has_add</code> and <code>has_zero</code> would suffice; but no one cares about that generality</p>",
        "id": 358835063,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684267080
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/LinearOrderedCommMonoidWithZero\">docs#LinearOrderedCommMonoidWithZero</a> has no addition though?</p>",
        "id": 358835138,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684267088
    },
    {
        "content": "<p>It's multiplication. Mathlib's valuations have multipicative value groups</p>",
        "id": 358835187,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1684267115
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Setting.20up.20ultrametric.20spaces/near/358835138\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/LinearOrderedCommMonoidWithZero\">docs#LinearOrderedCommMonoidWithZero</a> has no addition though?</p>\n</blockquote>\n<p>It has a commutative binary operation, which I was calling \"addition\".</p>",
        "id": 358835338,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684267134
    },
    {
        "content": "<p>To define an ultrametric, you only to know what the max of two elements is. This is a purely order-theoretic thing.</p>",
        "id": 358835472,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684267156
    },
    {
        "content": "<p>If you're going to call the binary operation \"+\", then you'll need to call the unit \"0\", and so now the zero you added is called \"bot\" after all</p>",
        "id": 358835845,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684267208
    },
    {
        "content": "<p>Though it is not my field, I know that there are people who study ultrametric spaces unconnected to any valued ring. If I can set up a theory that would be useful to them without making my life too complicated, then I think this is a valuable thing to do.</p>",
        "id": 358835896,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684267226
    },
    {
        "content": "<p>(I should probably mention that I know very little about ultrametric spaces, only about mathlib's order and algebra)</p>",
        "id": 358836295,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684267288
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Setting.20up.20ultrametric.20spaces/near/358835845\">said</a>:</p>\n<blockquote>\n<p>If you're going to call the binary operation \"+\", then you'll need to call the unit \"0\", and so now the zero you added is called \"bot\" after all</p>\n</blockquote>\n<p>When I start using it in Lean, I'll call it whatever mathlib calls it. But in my non-Lean life, I call the operation +, the unit element 0 and the smallest element <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>‚àí</mo><mi mathvariant=\"normal\">‚àû</mi></mrow><annotation encoding=\"application/x-tex\">-\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">‚àí</span><span class=\"mord\">‚àû</span></span></span></span>, so it bled over into this discussion. Sorry for the confusion.</p>",
        "id": 358836488,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684267317
    },
    {
        "content": "<p>But even that's backwards, isn't it? I'm used to valuations taking values in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚à™</mo><mo stretchy=\"false\">{</mo><mi mathvariant=\"normal\">‚àû</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\Gamma \\cup \\{\\infty\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚à™</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">‚àû</span><span class=\"mclose\">}</span></span></span></span> and taking <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>exp</mi><mo>‚Å°</mo><mo stretchy=\"false\">(</mo><mo>‚àí</mo><mi>v</mi><mo stretchy=\"false\">(</mo><mo>‚àí</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\exp(-v(-))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">exp</span><span class=\"mopen\">(</span><span class=\"mord\">‚àí</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord\">‚àí</span><span class=\"mclose\">))</span></span></span></span> for the absolute value in the rank 1 case.</p>",
        "id": 358836899,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1684267377
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddValuation#doc\">docs4#AddValuation</a></p>",
        "id": 358837090,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1684267410
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/270676-lean4/topic/Setting.20up.20ultrametric.20spaces/near/358836899\">said</a>:</p>\n<blockquote>\n<p>But even that's backwards, isn't it? I'm used to valuations taking values in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚à™</mo><mo stretchy=\"false\">{</mo><mi mathvariant=\"normal\">‚àû</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\Gamma \\cup \\{\\infty\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚à™</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">‚àû</span><span class=\"mclose\">}</span></span></span></span> and taking <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>exp</mi><mo>‚Å°</mo><mo stretchy=\"false\">(</mo><mo>‚àí</mo><mi>v</mi><mo stretchy=\"false\">(</mo><mo>‚àí</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\exp(-v(-))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">exp</span><span class=\"mopen\">(</span><span class=\"mord\">‚àí</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord\">‚àí</span><span class=\"mclose\">))</span></span></span></span> for the absolute value in the rank 1 case.</p>\n</blockquote>\n<p>From what I've seen, both definitions are used, with the same name ! It's all very confusing. And some people use \"absolute value\" sometimes, to add to the confusion.</p>",
        "id": 358837137,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684267438
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/270676-lean4/topic/Setting.20up.20ultrametric.20spaces/near/358836899\">said</a>:</p>\n<blockquote>\n<p>But even that's backwards, isn't it? I'm used to valuations taking values in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚à™</mo><mo stretchy=\"false\">{</mo><mi mathvariant=\"normal\">‚àû</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\Gamma \\cup \\{\\infty\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚à™</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">‚àû</span><span class=\"mclose\">}</span></span></span></span> and taking <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>exp</mi><mo>‚Å°</mo><mo stretchy=\"false\">(</mo><mo>‚àí</mo><mi>v</mi><mo stretchy=\"false\">(</mo><mo>‚àí</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\exp(-v(-))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">exp</span><span class=\"mopen\">(</span><span class=\"mord\">‚àí</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord\">‚àí</span><span class=\"mclose\">))</span></span></span></span> for the absolute value in the rank 1 case.</p>\n</blockquote>\n<p>Yeah, \"additive valuations\" and \"multiplicative valuations\"... I remember the day I realized they were the same up to reversing the order on the value group and changing the name of the binary operation, and that day I cursed the people who had invented the terminology. <br>\nSince mathlib made a choice in the definition of <code>Valued</code>, I'm quite willing to stick with it.</p>",
        "id": 358837514,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684267577
    },
    {
        "content": "<p>lean+mathlib has actually convinced me that the multiplicative variant is the \"right\" choice.</p>",
        "id": 358837859,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1684267697
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/270676-lean4/topic/Setting.20up.20ultrametric.20spaces/near/358837859\">said</a>:</p>\n<blockquote>\n<p>lean+mathlib has actually convinced me that the multiplicative variant is the \"right\" choice.</p>\n</blockquote>\n<p>I'm not that far along, I don't think there's a right choice. You'll still get people who complain that with your definition the \"p-adic valuation\" is not a valuation (to which I'd reply, \"just take minus the p-adic valuation and imagine that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> multiplicative\". <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span>)<br>\nBut I think it's useful to make a choice and stop confusing people.</p>",
        "id": 358838316,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1684267899
    },
    {
        "content": "<p>many thanks for the advices</p>",
        "id": 358904377,
        "sender_full_name": "Olivier Ta√Øbi",
        "timestamp": 1684305779
    }
]