[
    {
        "content": "<p>In some languages like Scala and TypeScript,  one can express more complex types using \"type/set operations\", e.g.  <code>x : Int | String</code> (and also intersection and even negation).  Those languages (incl. Haskell) also support the idea of \"singleton types\", e.g. <code>x : 1 := 1</code>.</p>\n<p>Is this in some way fundamentally incompatible with Lean's type system/DTT?</p>\n<p>I think I could \"simulate\" this functionality by using a type class (which would indicate the answer is \"no\"):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Numeric</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Numeric</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Numeric</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"c1\">--- ... etc</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Numeric</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HAdd</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>Hence I'm curious if there's another reason why it's not supported \"natively\" - the above just seems verbose.  <br>\nIt also forces the function to be \"fully generic\" rather than to work for a closed set of types, which, depending on your PoV, may or may not be a good thing.</p>\n<p>With singleton types, I think I could write something like </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">NatS</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">NatS</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">10</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatS</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- This is also a bit awkward</span>\n</code></pre></div>\n<p>But again, that feels a bit obtuse/backward.</p>\n<p>I would appreciate any insights!</p>",
        "id": 473825842,
        "sender_full_name": "Tom",
        "timestamp": 1727722375
    },
    {
        "content": "<p>There is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sum#doc\">docs#Sum</a> for union types</p>",
        "id": 473826119,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727722459
    },
    {
        "content": "<p>For singleton types I don't think there's something better than <code>{x : α // x = y}</code>, but what do you want it for? You can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Unique#doc\">docs#Unique</a> to claim that a type is a singleton</p>",
        "id": 473826388,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727722550
    },
    {
        "content": "<p>Thanks for reminding me about <code>Sum</code>.  However, would <code>Sum</code> not force me to match on its constructors <code>.inl</code>/<code>.inr</code>. before I'm able to use the contained types:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Numeric</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">Float</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test2</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HAdd</span><span class=\"w\"> </span><span class=\"n\">Numeric</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Numeric</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Numeric</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Numeric</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"c1\">-- this will not work</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">test2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"mf\">2.0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Numeric</span><span class=\"o\">)</span>\n</code></pre></div>\n<ol>\n<li>The type class specification of <code>HAdd</code> doesn't work, does it?</li>\n<li>The call becomes more \"involved\"</li>\n</ol>",
        "id": 473829104,
        "sender_full_name": "Tom",
        "timestamp": 1727723288
    },
    {
        "content": "<p>As for singleton types, they can be useful esp in e.g. API interfaces.  For example, if you have a function which can only take a specific set of values.  E.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">car</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Car</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">gear</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"c1\">-- or</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">serialize</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">format</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"json\"</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"s2\">\"yaml\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>\n<p>I know these are contrived but hopefully it illustrates the point.  These \"one off types\" can be expressed very easily and therefore people use them to express these invariants.</p>",
        "id": 473830040,
        "sender_full_name": "Tom",
        "timestamp": 1727723552
    },
    {
        "content": "<p>You could quite easily write custom notation for this which expands to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Format</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">json</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">yaml</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">serialize</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">format</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Format</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>\n<p>or you can use</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">serialize</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">format</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"s2\">\"json\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"yaml\"</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>\n<p>if you really want to use strings under the hood</p>",
        "id": 473830395,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727723667
    },
    {
        "content": "<p>For the singleton types, and in the examples I showed, I agree.  And thanks for the <code>Set</code> example - TIL!  Very interesting discovering such tidbits, I appreciate you sharing that!  I still think it's a bit more typing than necessary <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n<p>Having said that, I am more interested in the union type part of my question.  Any thoughts on that? (And the \"singleton\" types were another convenient way of showing a union type)</p>",
        "id": 473831529,
        "sender_full_name": "Tom",
        "timestamp": 1727723975
    },
    {
        "content": "<p>And since we're taking about types, I would also be curious if structural types/row types are something that's feasible in DTT/Lean.</p>",
        "id": 473832309,
        "sender_full_name": "Tom",
        "timestamp": 1727724155
    }
]