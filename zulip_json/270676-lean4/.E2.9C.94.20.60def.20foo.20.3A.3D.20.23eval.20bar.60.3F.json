[
    {
        "content": "<p>Is there an equivalent of Coq's <code>Definition foo := Eval compute in bar.</code>?</p>",
        "id": 509328068,
        "sender_full_name": "Jason Gross",
        "timestamp": 1743466446
    },
    {
        "content": "<p>We have <code>by_elab</code></p>",
        "id": 509328217,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743466528
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Eval</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">eval</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">bar</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">def foo : ℕ :=</span>\n<span class=\"cm\">2</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 509329383,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743467053
    },
    {
        "content": "<p>Ah, nice, that is exactly what I was looking for, thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> !</p>",
        "id": 509329498,
        "sender_full_name": "Jason Gross",
        "timestamp": 1743467133
    },
    {
        "content": "<p>(Incidentally, when I asked Gemini 2.5 to give me an implementation based on by_elab, it told me by_elab was the wrong tool for the job and wrote me</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"n\">Term</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">This command attempts to mimic Coq's `Definition foo := Eval cbv in bar.`</span>\n<span class=\"cm\">It defines `foo` to be the result of reducing `bar` using `Lean.Meta.reduce`.</span>\n<span class=\"cm\">NOTE: `Lean.Meta.reduce` provides strong reduction, but might not be *identical*</span>\n<span class=\"cm\">      to Coq's `cbv` in all subtle aspects.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"eval_def \"</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"s2\">\" := \"</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Ensure we are in a context where we can elaborate terms and add declarations</span>\n<span class=\"w\">  </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Elaborate the user-provided term syntax into an expression</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">termExpr</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"c1\">-- `none` asks Lean to infer the type</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Ensure the term is fully elaborated (e.g., resolve metavariables)</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">termExpr</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span><span class=\"w\"> </span><span class=\"n\">termExpr</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Infer the type of the expression</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">termType</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferType</span><span class=\"w\"> </span><span class=\"n\">termExpr</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">termType</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span><span class=\"w\"> </span><span class=\"n\">termType</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Reduce the expression using Lean's strong reduction</span>\n<span class=\"w\">    </span><span class=\"c1\">-- We configure it to unfold most things (`TransparencyMode.all`)</span>\n<span class=\"w\">    </span><span class=\"c1\">-- and reduce inside types/proofs if desired (here false for simplicity,</span>\n<span class=\"w\">    </span><span class=\"c1\">-- matching `#reduce` defaults more closely perhaps)</span>\n<span class=\"w\">    </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"Reducing: {termExpr}\"</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">reducedExpr</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">termExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">skipTypes</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">skipProofs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mode</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">TransparencyMode</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"Reduced to: {reducedExpr}\"</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Ensure the reduced expression still has the same type (sanity check)</span>\n<span class=\"w\">    </span><span class=\"c1\">-- let reducedType ← inferType reducedExpr -- Optional check</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Create the new definition</span>\n<span class=\"w\">    </span><span class=\"c1\">-- We use `DefinitionSafety.safe` assuming the original term was safe.</span>\n<span class=\"w\">    </span><span class=\"c1\">-- `ReducibilityHints.abbrev` makes `foo` easily unfoldable to its reduced value.</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Declaration</span><span class=\"bp\">.</span><span class=\"n\">defnDecl</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">        </span><span class=\"n\">name</span><span class=\"w\">        </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"bp\">.</span><span class=\"n\">getId</span>\n<span class=\"w\">        </span><span class=\"n\">levelParams</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"c1\">-- Simplification: assuming no universe polymorphism</span>\n<span class=\"w\">        </span><span class=\"n\">type</span><span class=\"w\">        </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">termType</span>\n<span class=\"w\">        </span><span class=\"n\">value</span><span class=\"w\">       </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">reducedExpr</span>\n<span class=\"w\">        </span><span class=\"n\">hints</span><span class=\"w\">       </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ReducibilityHints</span><span class=\"bp\">.</span><span class=\"kn\">abbrev</span>\n<span class=\"w\">        </span><span class=\"n\">safety</span><span class=\"w\">      </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">DefinitionSafety</span><span class=\"bp\">.</span><span class=\"n\">safe</span>\n<span class=\"w\">    </span><span class=\"o\">}</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Add the declaration to the environment</span>\n<span class=\"w\">    </span><span class=\"n\">addDecl</span><span class=\"w\"> </span><span class=\"n\">decl</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Make the definition available for use (e.g., for `#check`, `#print`)</span>\n<span class=\"w\">    </span><span class=\"c1\">-- and compilation (needed for `#eval`).</span>\n<span class=\"w\">    </span><span class=\"n\">compileDecl</span><span class=\"w\"> </span><span class=\"n\">decl</span>\n\n<span class=\"c1\">-- Example Usage</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">my_factorial</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">my_factorial</span><span class=\"w\"> </span><span class=\"n\">k</span>\n\n<span class=\"c1\">-- Define `fact_4_val` as the *computed value* of `my_factorial 4`</span>\n<span class=\"n\">eval_def</span><span class=\"w\"> </span><span class=\"n\">fact_4_val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">my_factorial</span><span class=\"w\"> </span><span class=\"mi\">4</span>\n\n<span class=\"c1\">-- Now, fact_4_val *is* definitionally 24</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">fact_4_val</span>\n<span class=\"c1\">-- Expected output (approximately): def fact_4_val : Nat := 24</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">fact_4_val</span><span class=\"w\"> </span><span class=\"c1\">-- Nat</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">fact_4_val</span><span class=\"w\"> </span><span class=\"c1\">-- 24</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fact_4_val</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">24</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- This works because fact_4_val's definition *is* 24</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">complex_term</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">my_factorial</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span>\n<span class=\"n\">eval_def</span><span class=\"w\"> </span><span class=\"n\">simplified_term</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">complex_term</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">simplified_term</span><span class=\"w\"> </span><span class=\"c1\">-- def simplified_term : Nat := 21</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">simplified_term</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">21</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>which very nearly works)</p>",
        "id": 509329613,
        "sender_full_name": "Jason Gross",
        "timestamp": 1743467188
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"241007\">Jason Gross</span> has marked this topic as resolved.</p>",
        "id": 509329627,
        "sender_full_name": "Notification Bot",
        "timestamp": 1743467195
    }
]