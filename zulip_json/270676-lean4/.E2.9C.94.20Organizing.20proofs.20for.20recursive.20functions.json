[
    {
        "content": "<p>Hi. I have been reading \"Functional Programming in Lean\", which is really great. I'm currently working on an exercise in <a href=\"https://leanprover.github.io/functional_programming_in_lean/programs-proofs/insertion-sort.html#exercises\">Chapter 10.6</a> that involves implementing a non-copy quicksort with a termination proof. I have a question about how to structure proofs for recursive functions. You can find the full MWE <a href=\"https://github.com/pandaman64/QuickSortInLean/blob/03c4cc1ea017add9e37fad0a251558fd09100912/QuickSortInLean/mwe.lean\">here</a>.</p>\n<p>Let's assume we have the following function that partitions a subarray into the two. It takes two Prop argumets to prove that the array operations are in-bounds in the actual implementation.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Partitions array[first : last + 1] into two parts.</span>\n<span class=\"c1\">-- It returns the index of the pivot element in the resulting array along with the array.</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">partition</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ord</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">arr</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"n\">last</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">jl</span> <span class=\"o\">:</span> <span class=\"n\">first</span> <span class=\"bp\">≤</span> <span class=\"n\">last</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">la</span> <span class=\"o\">:</span> <span class=\"n\">last</span> <span class=\"bp\">&lt;</span> <span class=\"n\">arr.size</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Then we can write a simple quicksort function as follows. Let's ignore the Prop arguments and termination proofs for now.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">quickSort'</span> <span class=\"o\">[</span><span class=\"n\">Ord</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">arr1</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"n\">last</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">lt</span> <span class=\"o\">:</span> <span class=\"n\">first</span> <span class=\"bp\">&lt;</span> <span class=\"n\">last</span> <span class=\"k\">then</span>\n    <span class=\"k\">match</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">partition</span> <span class=\"n\">arr1</span> <span class=\"n\">first</span> <span class=\"n\">last</span> <span class=\"o\">(</span><span class=\"gr\">sorry</span> <span class=\"o\">:</span> <span class=\"n\">first</span> <span class=\"bp\">≤</span> <span class=\"n\">last</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"gr\">sorry</span> <span class=\"o\">:</span> <span class=\"n\">last</span> <span class=\"bp\">&lt;</span> <span class=\"n\">arr1.size</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">mid</span><span class=\"o\">,</span> <span class=\"n\">arr2</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">arr3</span> <span class=\"o\">:=</span> <span class=\"n\">quickSort'</span> <span class=\"n\">arr2</span> <span class=\"n\">first</span> <span class=\"o\">(</span><span class=\"n\">mid</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n      <span class=\"n\">quickSort'</span> <span class=\"n\">arr3</span> <span class=\"o\">(</span><span class=\"n\">mid</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">last</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">arr1</span>\n</code></pre></div>\n<p>The <code>first ≤ last</code> condition can be proved easily, but we don't know actually <code>last &lt; arr1.size</code> holds. We can add a <code>last &lt; arr1.size</code> argument to <code>quickSort'</code>, but this means that we need to construct the proof for the recursive calls. In particular, we need to show that the first recursive call of <code>quickSort'</code> preserves the array size.</p>\n<p>My first instinct was to use mutual definition like this, but it's rejected by Lean due to <code>invalid mutually recursive definitions, cannot mix theorems and definitions</code> error.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n<span class=\"kd\">def</span> <span class=\"n\">quickSort</span> <span class=\"o\">[</span><span class=\"n\">Ord</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">arr1</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"n\">last</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">la</span> <span class=\"o\">:</span> <span class=\"n\">last</span> <span class=\"bp\">&lt;</span> <span class=\"n\">arr1.size</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">lt</span> <span class=\"o\">:</span> <span class=\"n\">first</span> <span class=\"bp\">&lt;</span> <span class=\"n\">last</span> <span class=\"k\">then</span>\n    <span class=\"k\">match</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">partition</span> <span class=\"n\">arr1</span> <span class=\"n\">first</span> <span class=\"n\">last</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_of_lt</span> <span class=\"n\">lt</span><span class=\"o\">)</span> <span class=\"n\">la</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">mid</span><span class=\"o\">,</span> <span class=\"n\">arr2</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">arr3</span> <span class=\"o\">:=</span> <span class=\"n\">quickSort</span> <span class=\"n\">arr2</span> <span class=\"n\">first</span> <span class=\"o\">(</span><span class=\"n\">mid</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">la</span>\n      <span class=\"k\">have</span> <span class=\"n\">la'</span> <span class=\"o\">:</span> <span class=\"n\">last</span> <span class=\"bp\">&lt;</span> <span class=\"n\">arr3.size</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"c1\">-- Call mutually recursive theorem</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">arr3.size</span> <span class=\"bp\">=</span> <span class=\"n\">arr1.size</span> <span class=\"o\">:=</span> <span class=\"n\">quickSort_size</span> <span class=\"n\">arr2</span> <span class=\"n\">first</span> <span class=\"o\">(</span><span class=\"n\">mid</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">la</span>\n        <span class=\"gr\">sorry</span>\n      <span class=\"n\">quickSort</span> <span class=\"n\">arr3</span> <span class=\"o\">(</span><span class=\"n\">mid</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">last</span> <span class=\"n\">la'</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">arr1</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">quickSort_size</span> <span class=\"o\">[</span><span class=\"n\">Ord</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">arr1</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"n\">last</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">la</span> <span class=\"o\">:</span> <span class=\"n\">last</span> <span class=\"bp\">&lt;</span> <span class=\"n\">arr1.size</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">quickSort</span> <span class=\"n\">arr1</span> <span class=\"n\">first</span> <span class=\"n\">last</span> <span class=\"n\">la</span> <span class=\"bp\">=</span> <span class=\"n\">arr2</span> <span class=\"bp\">→</span> <span class=\"n\">arr2.size</span> <span class=\"bp\">=</span> <span class=\"n\">arr1.size</span> <span class=\"o\">:=</span>\n  <span class=\"c1\">-- Will unfold quickSort and prove it via recursion</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I could work around this by returning a subtype <code>{ arr' : Array α  // arr'.size = arr1.size }</code>, but that cluttered the code a lot because I needed to inline the proofs and pack/unpack the property. When I added the termination proof, it got even worse. You can see the complete version <a href=\"https://github.com/pandaman64/QuickSortInLean/blob/main/QuickSortInLean/QuickSort.lean#L148\">here</a>.</p>\n<p>I'm wondering if there is a better way to structure the proof. Any advice would be appreciated. Thanks!</p>",
        "id": 402971330,
        "sender_full_name": "pandaman",
        "timestamp": 1700376620
    },
    {
        "content": "<p>I think the subtype approach is most likely to work, although you can make it a little less painful by taking and returning arrays of fixed size <code>n</code></p>",
        "id": 402971702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700376862
    },
    {
        "content": "<p>(BTW <code>axiom partition</code> won't compile in <code>quickSort'</code> because it is noncomputable; a trick to make it work is <code>def ... := sorry</code> instead)</p>",
        "id": 402971819,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700376953
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">partition</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ord</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">arr</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">arr</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">arr.size</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"n\">last</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">jl</span> <span class=\"o\">:</span> <span class=\"n\">first</span> <span class=\"bp\">≤</span> <span class=\"n\">last</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">la</span> <span class=\"o\">:</span> <span class=\"n\">last</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">{</span><span class=\"n\">mid</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">//</span> <span class=\"n\">first</span> <span class=\"bp\">≤</span> <span class=\"n\">mid</span> <span class=\"bp\">∧</span> <span class=\"n\">mid</span> <span class=\"bp\">≤</span> <span class=\"n\">last</span><span class=\"o\">}</span> <span class=\"bp\">×</span>\n    <span class=\"o\">{</span><span class=\"n\">arr</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">arr.size</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">quickSort'</span> <span class=\"o\">[</span><span class=\"n\">Ord</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">arr1</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">arr</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">arr.size</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">})</span>\n    <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"n\">last</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hlast</span> <span class=\"o\">:</span> <span class=\"n\">last</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">{</span><span class=\"n\">arr</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">arr.size</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">lt</span> <span class=\"o\">:</span> <span class=\"n\">first</span> <span class=\"bp\">&lt;</span> <span class=\"n\">last</span> <span class=\"k\">then</span>\n    <span class=\"k\">match</span> <span class=\"n\">partition</span> <span class=\"n\">arr1</span> <span class=\"n\">first</span> <span class=\"n\">last</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_of_lt</span> <span class=\"n\">lt</span><span class=\"o\">)</span> <span class=\"n\">hlast</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(⟨</span><span class=\"n\">mid</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hmid₂</span><span class=\"o\">⟩,</span> <span class=\"n\">arr2</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">mid</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">first</span> <span class=\"bp\">&lt;</span> <span class=\"n\">last</span> <span class=\"bp\">-</span> <span class=\"n\">first</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">mid</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.lt_of_le_of_lt</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_trans</span> <span class=\"o\">(</span><span class=\"n\">Nat.sub_le</span> <span class=\"bp\">..</span><span class=\"o\">)</span> <span class=\"n\">hmid₂</span><span class=\"o\">)</span> <span class=\"n\">hlast</span>\n      <span class=\"k\">let</span> <span class=\"n\">arr3</span> <span class=\"o\">:=</span> <span class=\"n\">quickSort'</span> <span class=\"n\">arr2</span> <span class=\"n\">first</span> <span class=\"o\">(</span><span class=\"n\">mid</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">this</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">last</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">mid</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">last</span> <span class=\"bp\">-</span> <span class=\"n\">first</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n      <span class=\"n\">quickSort'</span> <span class=\"n\">arr3</span> <span class=\"o\">(</span><span class=\"n\">mid</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">last</span> <span class=\"n\">hlast</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">arr1</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">last</span> <span class=\"bp\">-</span> <span class=\"n\">first</span>\n</code></pre></div>",
        "id": 402972448,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700377344
    },
    {
        "content": "<p>Thank you for the suggestion! I'll try if this version is easier to work with.</p>",
        "id": 402974126,
        "sender_full_name": "pandaman",
        "timestamp": 1700378214
    },
    {
        "content": "<p>BTW, what <code>..</code> in <code>Nat.sub_le ..</code> means?</p>",
        "id": 402974978,
        "sender_full_name": "pandaman",
        "timestamp": 1700378675
    },
    {
        "content": "<p>as many <code>_</code> as needed</p>",
        "id": 402975000,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700378688
    },
    {
        "content": "<p>But greedily so sometimes too many! Don't use <code>..</code> when the conclusion is negated.</p>",
        "id": 403038750,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1700417876
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395416\">pandaman</span> has marked this topic as resolved.</p>",
        "id": 403375081,
        "sender_full_name": "Notification Bot",
        "timestamp": 1700571290
    },
    {
        "content": "<p>yeah, \"as many as possible\" is probably more correct than \"as many as needed\"</p>",
        "id": 403426939,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700586483
    }
]