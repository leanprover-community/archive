[
    {
        "content": "<p>What is the easiest way to derive <code>LinearOrder</code> for some structure whose fields all have <code>LinearOrder</code> instances?<br>\nE.g. I have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Time</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n<span class=\"n\">deriving</span> <span class=\"n\">LinearOrder</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Tag</span> <span class=\"n\">where</span>\n  <span class=\"n\">time</span> <span class=\"o\">:</span> <span class=\"n\">Time</span>\n  <span class=\"n\">microstep</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n</code></pre></div>\n<p>... and would like to derive:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">Tag</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>... with <code>&lt;</code> being the lexicographical ordering.<br>\nI tried <code>deriving LinearOrder</code> on <code>Tag</code>, but that gives:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">default</span> <span class=\"n\">handlers</span> <span class=\"k\">have</span> <span class=\"n\">not</span> <span class=\"n\">been</span> <span class=\"n\">implemented</span> <span class=\"n\">yet</span><span class=\"o\">,</span> <span class=\"kd\">class</span><span class=\"o\">:</span> <span class=\"bp\">'</span><span class=\"n\">LinearOrder'</span> <span class=\"n\">types</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">Tag</span><span class=\"o\">]</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>Also, I've seen <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sum.Lex#doc\">docs4#Sum.Lex</a> which seems like it might be relevant. But I don't understand how to use it.</p>",
        "id": 346579920,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1680531032
    },
    {
        "content": "<p><code>sum.lex</code> won't make a linear order. You probably want <code>psigma.lex</code> instead since all structures can be written as nested sigma types.</p>",
        "id": 346582555,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1680531512
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> regarding <a href=\"https://github.com/leanprover-community/mathlib4/pull/3215\">!4#3215</a> which constructs an equivalence to <code>Sum</code>/<code>Sigma</code> types</p>",
        "id": 346590532,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680532824
    },
    {
        "content": "<p>I hadn't expected <a href=\"#narrow/stream/287929-mathlib4/topic/derive_fintype/near/346054500\">my suggestion</a> there to be needed by someone so quickly!</p>",
        "id": 346590605,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680532843
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/3198\">mathlib4#3198</a> I've refactored it to reconfigure how the proxy type is generated. </p>\n<p>I think you would just need to make your own <code>mkCtorProxyType</code> by  starting with <code>defaultMkCtorProxyType</code>, and make your own term elaborator with this configuration to construct an equivalence.</p>",
        "id": 346646128,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680545617
    },
    {
        "content": "<p>What's the function to pull a <code>LinearOrder</code> across an <code>Equiv</code>?</p>",
        "id": 346646246,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680545645
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearOrder.lift'#doc\">docs4#LinearOrder.lift'</a></p>",
        "id": 346646314,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680545670
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.ProxyType</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Sigma.Order</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Mathlib.ProxyType</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">lexMkCtorProxyType</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Expr</span> <span class=\"bp\">×</span> <span class=\"n\">Name</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"o\">(</span><span class=\"n\">Expr</span> <span class=\"bp\">×</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">xs</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Unit</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"bp\">|</span> <span class=\"o\">()))</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">xty</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">x</span>\n    <span class=\"k\">if</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.isProp</span> <span class=\"n\">xty</span> <span class=\"k\">then</span>\n      <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">PLift</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">xty</span><span class=\"o\">],</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"n\">a</span><span class=\"o\">)⟩))</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">xty</span><span class=\"o\">,</span> <span class=\"n\">mkIdent</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">xsty</span><span class=\"o\">,</span> <span class=\"n\">patt</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">defaultMkCtorProxyType</span> <span class=\"n\">xs</span>\n    <span class=\"k\">let</span> <span class=\"n\">xty</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">x</span>\n    <span class=\"k\">if</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.isProp</span> <span class=\"n\">xty</span> <span class=\"k\">then</span>\n      <span class=\"n\">withLocalDeclD</span> <span class=\"bp\">`</span><span class=\"n\">x'</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">PLift</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">xty</span><span class=\"o\">])</span> <span class=\"k\">fun</span> <span class=\"n\">x'</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">xsty'</span> <span class=\"o\">:=</span> <span class=\"n\">xsty.replaceFVar</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">PLift.down</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">x'</span><span class=\"o\">])</span>\n        <span class=\"k\">let</span> <span class=\"n\">ty</span> <span class=\"bp\">←</span> <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">Lex</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">Sigma</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">mkLambdaFVars</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">x'</span><span class=\"o\">]</span> <span class=\"n\">xsty'</span><span class=\"o\">]]</span>\n        <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">ty</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"bp\">|</span> <span class=\"o\">⟨⟨</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"n\">a</span><span class=\"o\">)⟩,</span> <span class=\"bp\">$</span><span class=\"n\">patt</span><span class=\"o\">⟩))</span>\n    <span class=\"k\">else</span>\n      <span class=\"k\">let</span> <span class=\"n\">ty</span> <span class=\"bp\">←</span> <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">Lex</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">Sigma</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">mkLambdaFVars</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"n\">xsty</span><span class=\"o\">]]</span>\n      <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">ty</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"bp\">$</span><span class=\"n\">patt</span><span class=\"o\">⟩))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ProxyEquivConfig.lexDefault</span> <span class=\"o\">(</span><span class=\"n\">indVal</span> <span class=\"o\">:</span> <span class=\"n\">InductiveVal</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ProxyEquivConfig</span> <span class=\"n\">where</span>\n  <span class=\"n\">proxyName</span> <span class=\"o\">:=</span> <span class=\"n\">indVal.name.mkStr</span> <span class=\"s2\">\"proxyLexType\"</span>\n  <span class=\"n\">proxyEquivName</span> <span class=\"o\">:=</span> <span class=\"n\">indVal.name.mkStr</span> <span class=\"s2\">\"proxyLexTypeEquiv\"</span>\n  <span class=\"n\">mkCtorProxyType</span> <span class=\"o\">:=</span> <span class=\"n\">lexMkCtorProxyType</span>\n  <span class=\"n\">mkProxyType</span> <span class=\"o\">:=</span> <span class=\"n\">defaultMkProxyType</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"proxy_lex_equiv% \"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">expectedType</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">indVal</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">elabProxyEquiv</span> <span class=\"n\">t</span> <span class=\"n\">expectedType</span>\n  <span class=\"k\">let</span> <span class=\"n\">config</span> <span class=\"o\">:</span> <span class=\"n\">ProxyEquivConfig</span> <span class=\"o\">:=</span> <span class=\"n\">ProxyEquivConfig.lexDefault</span> <span class=\"n\">indVal</span>\n  <span class=\"n\">ensureProxyEquiv</span> <span class=\"n\">config</span> <span class=\"n\">indVal</span>\n  <span class=\"n\">mkAppOptM</span> <span class=\"n\">config.proxyEquivName</span> <span class=\"o\">(</span><span class=\"n\">type.getAppArgs.map</span> <span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Mathlib.ProxyType</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Time</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n<span class=\"n\">deriving</span> <span class=\"n\">LinearOrder</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Tag</span> <span class=\"n\">where</span>\n  <span class=\"n\">time</span> <span class=\"o\">:</span> <span class=\"n\">Time</span>\n  <span class=\"n\">microstep</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">Tag</span> <span class=\"o\">:=</span>\n  <span class=\"n\">LinearOrder.lift'</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Equiv.injective</span> <span class=\"o\">(</span><span class=\"n\">Equiv.symm</span> <span class=\"o\">(</span><span class=\"n\">proxy_lex_equiv</span><span class=\"bp\">%</span> <span class=\"n\">Tag</span><span class=\"o\">)))</span>\n</code></pre></div>",
        "id": 346647707,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680546054
    },
    {
        "content": "<p>I guess this also needs an implementation of <code>mkProxyType</code> to turn <code>Sum a b</code> into <code>Lex (Sum a b)</code> for multi-constructor inductive types. What's the rationale for <code>Sum</code> not having a LinearOrder by default?</p>",
        "id": 346648915,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680546369
    },
    {
        "content": "<p>With some more tweaking, this is what it looks like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.ProxyType</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Sigma.Order</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Sum.Order</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Mathlib.ProxyType</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ProxyEquivConfig.lexDefault</span> <span class=\"o\">(</span><span class=\"n\">indVal</span> <span class=\"o\">:</span> <span class=\"n\">InductiveVal</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ProxyEquivConfig</span> <span class=\"n\">where</span>\n  <span class=\"n\">proxyName</span> <span class=\"o\">:=</span> <span class=\"n\">indVal.name.mkStr</span> <span class=\"s2\">\"proxyLexType\"</span>\n  <span class=\"n\">proxyEquivName</span> <span class=\"o\">:=</span> <span class=\"n\">indVal.name.mkStr</span> <span class=\"s2\">\"proxyLexTypeEquiv\"</span>\n  <span class=\"n\">mkCtorProxyType</span> <span class=\"o\">:=</span> <span class=\"n\">defaultMkCtorProxyType</span> <span class=\"o\">(</span><span class=\"n\">decorateSigma</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">Lex</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">])</span>\n  <span class=\"n\">mkProxyType</span> <span class=\"o\">:=</span> <span class=\"n\">defaultMkProxyType</span> <span class=\"o\">(</span><span class=\"n\">decorateSum</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">Lex</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">])</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">proxy_lex_equiv</span><span class=\"o\">)</span> <span class=\"s2\">\"proxy_lex_equiv% \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kd\">@[term_elab proxy_lex_equiv]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elab_proxy_lex_equiv</span> <span class=\"o\">:</span> <span class=\"n\">Elab.Term.TermElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">match</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">proxy_lex_equiv</span><span class=\"bp\">%</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">indVal</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">elabProxyEquiv</span> <span class=\"n\">t</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n    <span class=\"k\">let</span> <span class=\"n\">config</span> <span class=\"o\">:</span> <span class=\"n\">ProxyEquivConfig</span> <span class=\"o\">:=</span> <span class=\"n\">ProxyEquivConfig.lexDefault</span> <span class=\"n\">indVal</span>\n    <span class=\"n\">ensureProxyEquiv</span> <span class=\"n\">config</span> <span class=\"n\">indVal</span>\n    <span class=\"n\">mkAppOptM</span> <span class=\"n\">config.proxyEquivName</span> <span class=\"o\">(</span><span class=\"n\">type.getAppArgs.map</span> <span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Mathlib.ProxyType</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Time</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n<span class=\"n\">deriving</span> <span class=\"n\">LinearOrder</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Tag</span> <span class=\"n\">where</span>\n  <span class=\"n\">time</span> <span class=\"o\">:</span> <span class=\"n\">Time</span>\n  <span class=\"n\">microstep</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">Tag</span> <span class=\"o\">:=</span>\n  <span class=\"n\">LinearOrder.lift'</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">proxy_lex_equiv</span><span class=\"bp\">%</span> <span class=\"n\">Tag</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm.injective</span>\n</code></pre></div>",
        "id": 346653924,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680547980
    },
    {
        "content": "<p>It uses <code>Lex (Sum _ _)</code> for multi-constructor types:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">X</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">X</span>\n  <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n  <span class=\"n\">LinearOrder.lift'</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">proxy_lex_equiv</span><span class=\"bp\">%</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm.injective</span>\n</code></pre></div>\n<p>The type it generates here is <code>Lex (Lex ((_ : ℕ) × ℕ) ⊕ ℕ)</code></p>",
        "id": 346654135,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680548053
    },
    {
        "content": "<p>I pushed <a href=\"https://github.com/leanprover-community/mathlib4/pull/3251\">mathlib4#3251</a> for this simple <code>LinearOrder</code> derive handler.</p>\n<p>Example usage:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.DeriveLinearOrder</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Time</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n<span class=\"n\">deriving</span> <span class=\"n\">LinearOrder</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Tag</span> <span class=\"n\">where</span>\n  <span class=\"n\">time</span> <span class=\"o\">:</span> <span class=\"n\">Time</span>\n  <span class=\"n\">microstep</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">LinearOrder</span>\n</code></pre></div>",
        "id": 346668557,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680552891
    },
    {
        "content": "<p>It supports types more complicated than structures, but not recursive ones or ones with indices.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"n\">α</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">LinearOrder</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">instLinearOrderX</span>\n<span class=\"c1\">-- instLinearOrderX {α✝ : Type} [inst✝ : LinearOrder α✝] : LinearOrder (X α✝)</span>\n</code></pre></div>",
        "id": 346668690,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680552946
    }
]