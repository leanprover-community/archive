[
    {
        "content": "<p>The following code works</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">--import Mathlib.Logic.Relator</span>\n\n<span class=\"kn\">notation</span><span class=\"o\">:</span><span class=\"mi\">25</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">high</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"mi\">26</span><span class=\"w\"> </span><span class=\"s2\">\" ⇒ \"</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"mi\">25</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\">  </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">⇒</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\">  </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">⇒</span><span class=\"w\"> </span><span class=\"n\">Q</span>\n</code></pre></div>\n<p>Uncommenting the first line brings the cursed global notation from <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Logic/Relator.lean#L35\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Logic/Relator.lean#L35</a> and the <em>second</em> check fails. The thing I don’t understand is why the high priority is enough the avoid the cursed notation in the first check but not in the second one.</p>",
        "id": 502256850,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1740654651
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> this is one more example where being able to simply kill an upstream notation would be a life saver.</p>",
        "id": 502257287,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1740654803
    },
    {
        "content": "<p>I believe your use of <code>:25</code>/<code>:26</code> are overriding <code>priority := high</code>. Changing them to :50/:51, or getting rid of them and letting <code>priority := high</code> take control both work for me.</p>",
        "id": 502269890,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1740658989
    },
    {
        "content": "<p>If core won't let us kill an upstream notation then I guess here at least we can fix it in mathlib by scoping the <code>infixr:40 \" ⇒ \" =&gt; LiftFun</code> notation in <code>Mathlib.Logic.Relator</code>. It does seem a bit weird that a symbol which all mathematicians know the meaning of is globally stolen to mean something completely different.</p>",
        "id": 502270791,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740659260
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/270676-lean4/topic/Weird.20notation.20conflict.20handling/near/502257287\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> this is one more example where being able to simply kill an upstream notation would be a life saver.</p>\n</blockquote>\n<p>Would something like <code>attribute [-term_parser] term_⇒_</code> be acceptable, under the extra limitation that the tokens stay registered (i.e. you can use them in a new notation, but you cannot undo <code>notation \"pi\"</code> removing that identifier)? If yes, then that is a bit more feasible, could you open an issue?</p>",
        "id": 502272804,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1740659845
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"761203\">Vlad Tsyrklevich</span> <a href=\"#narrow/channel/270676-lean4/topic/Weird.20notation.20conflict.20handling/near/502269890\">said</a>:</p>\n<blockquote>\n<p>I believe your use of <code>:25</code>/<code>:26</code> are overriding <code>priority := high</code>. Changing them to :50/:51, or getting rid of them and letting <code>priority := high</code> take control both work for me.</p>\n</blockquote>\n<p>I would guess this is because you can't override the same notation with different precedence?</p>",
        "id": 502275100,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740660492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/270676-lean4/topic/Weird.20notation.20conflict.20handling/near/502270791\">said</a>:</p>\n<blockquote>\n<p>If core won't let us kill an upstream notation then I guess here at least we can fix it in mathlib by scoping the <code>infixr:40 \" ⇒ \" =&gt; LiftFun</code> notation in <code>Mathlib.Logic.Relator</code>. It does seem a bit weird that a symbol which all mathematicians know the meaning of is globally stolen to mean something completely different.</p>\n</blockquote>\n<p>Sure, I will also PR a fix to Mathlib. But for teaching I’m stuck with an old Mathlib until next year.</p>",
        "id": 502303684,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1740667886
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/channel/270676-lean4/topic/Weird.20notation.20conflict.20handling/near/502272804\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/270676-lean4/topic/Weird.20notation.20conflict.20handling/near/502257287\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> this is one more example where being able to simply kill an upstream notation would be a life saver.</p>\n</blockquote>\n<p>Would something like <code>attribute [-term_parser] term_⇒_</code> be acceptable, under the extra limitation that the tokens stay registered (i.e. you can use them in a new notation, but you cannot undo <code>notation \"pi\"</code> removing that identifier)? If yes, then that is a bit more feasible, could you open an issue?</p>\n</blockquote>\n<p>Yes, that would already be much better.</p>",
        "id": 502303737,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1740667900
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"761203\">Vlad Tsyrklevich</span> <a href=\"#narrow/channel/270676-lean4/topic/Weird.20notation.20conflict.20handling/near/502269890\">said</a>:</p>\n<blockquote>\n<p>I believe your use of <code>:25</code>/<code>:26</code> are overriding <code>priority := high</code>. Changing them to :50/:51, or getting rid of them and letting <code>priority := high</code> take control both work for me.</p>\n</blockquote>\n<p>Thanks, I’ll try those. But I am a bit worried this will break other things. And it doesn’t really explain the mystery.</p>",
        "id": 502303931,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1740667946
    },
    {
        "content": "<p>I am also curious to understand why it fails. I tried to look through Elab traces and read through the language reference manual, but I didn't figure it out</p>",
        "id": 502330278,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1740674552
    },
    {
        "content": "<p>Because with the Relator notation, it is parsed as <code>¬ (P ⇒ Q)</code> while without it, it is parsed as <code>(¬ P) ⇒ Q</code>, so priority  does not come into play as there is no choice between the two notations at a single location. The former parse is preferred by the \"local longest parse\" rule: once we're parsing inside the Not, we prefer parsing there as much as possible before ascending.</p>",
        "id": 502389683,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1740693244
    },
    {
        "content": "<blockquote>\n<p>chore: scope ⇒ notation to Relator <a href=\"https://github.com/leanprover-community/mathlib4/pull/22419\">#22419</a></p>\n</blockquote>",
        "id": 502693767,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1740791235
    }
]