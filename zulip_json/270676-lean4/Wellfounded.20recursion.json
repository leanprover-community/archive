[
    {
        "content": "<p>What is the recommended way of doing wellfounded recursion  in Lean4?</p>\n<p>I have been trying to use <code>WellFounded.fix</code> with a proper well-founded relationship, and it all type-checks, but I run into the following message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">compile</span> <span class=\"kd\">definition</span><span class=\"o\">,</span> <span class=\"n\">consider</span> <span class=\"n\">marking</span> <span class=\"n\">it</span> <span class=\"n\">as</span> <span class=\"bp\">'</span><span class=\"kd\">noncomputable</span><span class=\"bp\">'</span> <span class=\"n\">because</span> <span class=\"n\">it</span> <span class=\"n\">depends</span> <span class=\"n\">on</span> <span class=\"bp\">'</span><span class=\"n\">WellFounded.fix'</span><span class=\"o\">,</span> <span class=\"n\">and</span> <span class=\"n\">it</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"k\">have</span> <span class=\"n\">executable</span> <span class=\"n\">code</span>\n</code></pre></div>\n<p>It turns out that you get this message even with the simplest possible such code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">dumbNatRec</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">WellFounded.fix</span> <span class=\"n\">Nat.ltWf</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I have noticed that the WellFounded module uses <code>set_option codegen false</code> which makes the error go away, but I'm not sure I understand the consequences of this option. It seems like this code is fully defined and ought to be runnable/compilable.</p>\n<p>Am I using the wrong tool? Am I using the tool wrong?<br>\nThanks for you help!</p>",
        "id": 251155570,
        "sender_full_name": "Valentin Robert",
        "timestamp": 1630268504
    },
    {
        "content": "<p>I too am curious to understand this more.</p>\n<p>It seems that mathlib4 uses <code>unsafe</code> as a workaround: <a href=\"https://github.com/leanprover-community/mathlib4/blob/7ac569847b94980d3d668ae6079131f5cd2fe559/Mathlib/Logic/Basic.lean#L50-L55\">https://github.com/leanprover-community/mathlib4/blob/7ac569847b94980d3d668ae6079131f5cd2fe559/Mathlib/Logic/Basic.lean#L50-L55</a></p>",
        "id": 251158414,
        "sender_full_name": "David Renshaw",
        "timestamp": 1630271652
    },
    {
        "content": "<p>My understanding is WF recursion is not implemented in the compiler yet, so it will type check but won’t compute. Just need to wait for it to be fully implemented. See <a href=\"https://github.com/leanprover/lean4/issues/176\">https://github.com/leanprover/lean4/issues/176</a></p>",
        "id": 251165458,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1630279293
    },
    {
        "content": "<p>In the meantime if you just want to be able to write recursive functions, you can use the <code>partial</code> prefix.</p>",
        "id": 251166219,
        "sender_full_name": "Chris B",
        "timestamp": 1630280057
    },
    {
        "content": "<p>If you want to write a function by well founded recursion that computes and also has provable properties, use <code>WellFounded.fix'</code> (linked above). That's what it's there for. (You might argue that the <code>implementedBy</code> is a cheat, but keep in mind that this is exactly what the compiler will do once <a href=\"https://github.com/leanprover/lean4/issues/176\">leanprover/lean4#176</a> is addressed.)</p>",
        "id": 251166788,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630280509
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> has marked this topic as unresolved.</p>",
        "id": 526295269,
        "sender_full_name": "Notification Bot",
        "timestamp": 1751231206
    },
    {
        "content": "<p>So, I understand that this is probably a nofix, but I find the WellFounded.recursion stuff unusable because they're missing the <code>@[elab_as_elim]</code> attributes:<br>\n<a href=\"https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/WF.lean#L91-L92\">https://github.com/leanprover/lean4/blob/6741444a63eec253a7eae7a83f1beb3de015023d/src/Init/WF.lean#L91-L92</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">recursion</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">hwf</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"w\"> </span><span class=\"n\">ih</span>\n\n<span class=\"n\">include</span><span class=\"w\"> </span><span class=\"n\">hwf</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">recursion</span><span class=\"w\"> </span><span class=\"n\">hwf</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fixF</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Acc</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"w\"> </span><span class=\"n\">ih</span>\n</code></pre></div>",
        "id": 526295318,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751231250
    },
    {
        "content": "<p>(edit: the tactic <code>by induction</code> still works for this)</p>",
        "id": 526295932,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751232022
    }
]