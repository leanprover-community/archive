[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/270676-lean4/topic/inductive.20variable.20bindings/near/272378486\">said</a>:</p>\n<blockquote>\n<p>This info should be in the readme in the Aesop repo. But it's a bit unfriendly right now, mixing implementation and usage, and doesn't have good examples. I'll write a better readme today or early next week. (I'm currently changing a part of the UI as well, so I'd like to wait for that.)</p>\n</blockquote>\n<p>This took longer than I thought (nothing ever doesn't), but Aesop now has a more friendly README in case you'd like to try it.</p>",
        "id": 273518777,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1646066963
    },
    {
        "content": "<p><a href=\"https://github.com/JLimperg/aesop/blob/master/README.md\">https://github.com/JLimperg/aesop/blob/master/README.md</a></p>",
        "id": 273520904,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1646067722
    },
    {
        "content": "<p>Jannis, did you try to make tests comparing aesop to more specialized tactics like <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#continuity\">tactic#continuity</a>? This continuity tactic is potentially very useful but it is so slow that it is not used in practice. I guess it wouldn't take too much patience to build a fake topology library and test aesop here. Maybe with mathport oleans you could even test it on the real lemmas (adding aesop tags and some test in a Lean 4 file importing mathlib oleans).</p>",
        "id": 273522768,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1646068553
    },
    {
        "content": "<p>I don't know how to properly use the linkifier here. I meant <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#continuity%20/%20continuity\">https://leanprover-community.github.io/mathlib_docs/tactics.html#continuity%20/%20continuity</a>', which sounds to do a specialized subset of what aesop is meant to do.</p>",
        "id": 273523035,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1646068683
    },
    {
        "content": "<p>I haven't done it yet but this is definitely planned. Aesop should indeed be able to replace these tactics with relatively little additional effort.</p>",
        "id": 273523386,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1646068833
    },
    {
        "content": "<p>Do you expect better performance? Or is aesop meant to be an expensive tactic (maybe also outputting a faster tactic call to be replaced with)?</p>",
        "id": 273524454,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1646069328
    },
    {
        "content": "<p>With <code>continuity</code>, I'd expect good performance because afaict there is not much choice (i.e. for each goal there tends to be at most one lemma that applies), so the search shouldn't branch much. I have a test that proves <code>Even 1000</code> by counting down in increments of 2 and that takes about 1s. Of course there the rule set is very small and entirely deterministic, so not sure how this will translate.</p>\n<p>In general, I'm not sure how Aesop will be used. I'd like to try whether it can be used to solve complex goals with big rule sets as well, and I'll implement a <code>squeeze_simp</code>-like mode to enable this. But maybe it'll turn out that the algorithm is too weak and the tactic always fails on complex goals, in which case it might get relegated to automating <code>continuity</code>-style problems.</p>",
        "id": 273526657,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1646070203
    },
    {
        "content": "<p>Do you see any fundamental reasons for why it might be (much) less effective or practical than <code>auto</code> in Isabelle?</p>",
        "id": 273527181,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1646070413
    },
    {
        "content": "<p>By the way, I'm planning to take a closer look at it next semester for the second edition our Lean 4 lab with <span class=\"user-mention\" data-user-id=\"110789\">@Jakob von Raumer</span>, especially whether it might help students with the final projects</p>",
        "id": 273527427,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1646070531
    },
    {
        "content": "<p>No, <code>auto</code> level should be doable. It's a bit hard to tell what exactly <code>auto</code> does because there's no documentation and I've never seriously used Isabelle, but from what I can tell, the basic approach is very similar. Aesop will just need a ton of work setting up all the lemmas (and I'll need to fix a lot of bugs).</p>\n<p>I'd be very curious whether you find it useful for teaching! Though whether it'll help the students or whether they'll be bug-hunting guinea pigs remains to be seen.</p>",
        "id": 273528501,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1646070950
    },
    {
        "content": "<p>I can at least tell you that the Isabelle example solution is completely dependent on <code>auto</code> (and a few similar ones like <code>blast</code>) :) . <code>simp</code> only gets you so far in program verification, you really want to do some forward reasoning steps etc. in between.</p>",
        "id": 273528956,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1646071126
    },
    {
        "content": "<p>This might already be the case for Aesop, but I should mention that perhaps <code>auto</code>'s best feature is that despite its heuristics, it reports sensible intermediate goals on failure that usually give you a pretty good idea on what lemma to prove &amp; include next</p>",
        "id": 273529264,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1646071220
    },
    {
        "content": "<p>Ah, interesting. Do you know whether it does anything smarter than dumping the unsolved goals? Right now I don't have any debugging beyond trace messages, which is not great. (I really need a good MSc student to visualise the traces and the final search tree. I think this could be really nice but I don't want to do it. :P)</p>",
        "id": 273529994,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1646071476
    },
    {
        "content": "<p>It might be reporting the furthest safe goal, but I'm not really sure to be honest</p>",
        "id": 273531153,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1646071954
    },
    {
        "content": "<p>Ah okay, makes some sense. That I can do as well.</p>",
        "id": 273531769,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1646072250
    },
    {
        "content": "<p>I don't know if that's relevant but I have a prototype of Coq-style auto I've been working on, using discrimination tree to index lemmas and combining forward and backward reasoning. I'd be happy to polish it off if that helps</p>",
        "id": 273583180,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1646101621
    },
    {
        "content": "<p>Do publish please! I'm interested in your integration of forward reasoning in particular.</p>",
        "id": 273614583,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1646128502
    },
    {
        "content": "<p>I'm curious about all this mystery surrounding Isabelle's <code>auto</code>. I understand there is no paper about it.  Is this closed source? Or is it simply very hard to read the code and we don't have access to the author?</p>",
        "id": 273616219,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1646129319
    },
    {
        "content": "<p>Source code is here: <a href=\"https://github.com/seL4/isabelle/blob/master/src/Provers/clasimp.ML\">https://github.com/seL4/isabelle/blob/master/src/Provers/clasimp.ML</a></p>\n<p>I'm unsure about too many parts of the notation to really understand what's going on. But maybe I should do some more forensic work.</p>\n<p>Btw <span class=\"user-mention\" data-user-id=\"461231\">@Jad Ghalayini</span> sorry about hijacking your thread, it's gone quite far from your original question.</p>",
        "id": 273619783,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1646131014
    },
    {
        "content": "<p>No more hijacking <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 273620655,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1646131403
    },
    {
        "content": "<p>I think it would really make sense for you to invest time into reading that source code.</p>",
        "id": 273620692,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1646131439
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> May I summon you regarding your experience with Isabelle &amp; Coq automation, and what directions we should explore with Lean 4? And did you ever get into Isabelle metaprogramming apart from that While language parser for the lab course? :)</p>",
        "id": 273628310,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1646135509
    },
    {
        "content": "<p>My meta-programming experience was thinking “hey, wouldn’t it be nice to have <em>open</em> inductive predicates and types”, finding a master student to play around with that, and now <em>he’s</em> a fan of SML, but I haven't learned much more :-)</p>",
        "id": 273658131,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1646148651
    },
    {
        "content": "<p>But <code>auto</code> is pretty good indeed, with the automatic application of intro and elim rules in addition to <code>simp</code>, which is <em>itself</em> already pretty good compared to Lean’s <code>simp</code> (as far as I can tell), with the ability to do rewriting with congruences. I am not sure whether my comments can be <em>actually</em> useful though :-)</p>",
        "id": 273658360,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1646148732
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> So I gave Aesop a try on a non-trivial proof from our lab course today and it got further than I expected! <a href=\"https://gist.github.com/Kha/5babc9f0ac38d4f8f6094fb5cf3a69d9#file-exercise5-lean-L55\">https://gist.github.com/Kha/5babc9f0ac38d4f8f6094fb5cf3a69d9#file-exercise5-lean-L55</a><br>\nI had to help it out a bit with the <code>filter</code> case analysis, without the extra <code>simp_all</code> the conditional <code>filter_cons_true/false</code> simp theorems didn't seem to get applied. I also tried to apply a custom elim/split theorem <code>elem_filterE</code>, but I don't think that's quite the shape Aesop expects right now (see commented invocation). If it did, it would seem feasible to contract the entire proof to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">induction</span> <span class=\"n\">as</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">aesop</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 282613089,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1652779700
    },
    {
        "content": "<blockquote>\n<p>but I don't think that's quite the shape Aesop expects right now</p>\n</blockquote>\n<p>Ah, I suppose I confused your <code>elim</code> rules (transformation of a hypothesis, called <code>destruct</code> in Isabelle) with what Isabelle calls <code>elim</code> (transformation of the goal triggered by a hypothesis)</p>",
        "id": 282619949,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1652783824
    },
    {
        "content": "<p>Indeed that's what it is. Maybe I should rename the builder for consistency with Isabelle.</p>\n<p>I have a collaborator visiting this week, so might not have time to look into this, but I'll get to it next week at the latest. I recently weakened the builtin <code>simp</code> to the equivalent of <code>simp at *</code>, which allows me to cache across goals. But this doesn't seem to do very much (surprisingly), so maybe I'll go back to <code>simp_all</code>. In any case, I'm very happy to hear that you found the tactic (close to) useful.</p>",
        "id": 282696865,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1652816788
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/Aesop.20update/near/273529264\">said</a>:</p>\n<blockquote>\n<p>This might already be the case for Aesop, but I should mention that perhaps <code>auto</code>'s best feature is that despite its heuristics, it reports sensible intermediate goals on failure that usually give you a pretty good idea on what lemma to prove &amp; include next</p>\n</blockquote>\n<p>I've continued experimenting with Aesop by throwing it at the same lab course final project that was previously golfed to death in Isabelle, and I'm really excited about how close we can already get to the <code>auto</code> proofs in some cases. However, I realized that in the quote above I only told half the story: in reality, <code>auto</code> does not error on an unclosed proof at all but returns the unrpoved goal(s), much like <code>simp</code>. Both of them should only be used in terminal position in a clean proof of course, but for experimentation it is in fact crucial that you can continue after half-solving a proof with <code>auto</code>, then try a few manual steps, and finally reintegrate them back into the <code>auto</code> call. Afaict this is the only reliable way of composing a proof from multiple \"unsafe\" steps, as neither <code>auto</code> nor <code>aesop</code> will (or should) show you the remaining goals after heuristically applying unsafe steps without delving into their enormous traces.</p>",
        "id": 285695249,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1654876327
    },
    {
        "content": "<p>Okay, I can add this as well. Should (tm) be a relatively small modification to the proof extraction procedure.</p>",
        "id": 285714424,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1654885336
    },
    {
        "content": "<p>I should say that one of the features I like a lot with <code>auto</code> in Isabelle is that you can tell it to perform some unsafe steps. For instance, <code>auto intro: foo</code> will try to apply <code>foo</code> if it leads to completion, but <code>auto intro!: foo</code> will apply <code>foo</code> even if it does not lead to a complete proof. This may make the goal unsolvable, but when you know it's the way to go then it is very efficient. For instance, it is possible that a function <code>f + g</code> is continuous without <code>f</code> and <code>g</code> being continuous, but in most cases it is the way to go to try to prove the continuity of both <code>f</code> and <code>g</code>. Then <code>auto intro!: continuous_add</code> would leave you with the two goals that <code>f</code> and <code>g</code> are continuous.</p>",
        "id": 285716423,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1654886319
    },
    {
        "content": "<p>Aesop can already do this: if you call it with <code>aesop (add safe foo)</code>, it'll use <code>foo</code> as a 'safe' rule that is applied without backtracking. The unsolved goals which Aesop reports to the user are exactly those which are left after all safe rules have been applied (as often as possible).</p>\n<p>Aesop does not currently remove an unsafe <code>foo</code> rule if one is already registered, but that hopefully doesn't make much of a difference.</p>",
        "id": 285717790,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1654887028
    },
    {
        "content": "<p>Demo of Aesop already doing a job as least as good/slightly better than CoqHammer's internal solver (i.e. the non-hammer part): <a href=\"https://gist.github.com/Kha/96d67c8b947b48f8786aea90857fbb5c\">https://gist.github.com/Kha/96d67c8b947b48f8786aea90857fbb5c</a></p>",
        "id": 286638372,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1655540145
    },
    {
        "content": "<p>That's incredible. How fast is aesop on that example?</p>",
        "id": 286663594,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1655575840
    },
    {
        "content": "<p>also, is it possible yet for aesop to emit the tactic steps it finds, sorta like <code>simp?</code> behavior?</p>",
        "id": 286663653,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1655575949
    },
    {
        "content": "<p>I'll have to do a more thorough benchmark when I'm back at that machine, but there was no noticeable delay in the editor at all</p>",
        "id": 286665370,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1655578491
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/Aesop.20update/near/286663653\">said</a>:</p>\n<blockquote>\n<p>also, is it possible yet for aesop to emit the tactic steps it finds, sorta like <code>simp?</code> behavior?</p>\n</blockquote>\n<p>Not yet and this requires a fair bit of engineering. (Basically, successful rules will have to construct a <code>Syntax</code> representing the corresponding tactic.) But I want to add this at some point.</p>\n<p>For benchmarking, you can use <code>set_option trace.aesop.profile true</code>. This also gives some details about which rules were slow etc.</p>",
        "id": 286769333,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1655716868
    },
    {
        "content": "<p>Quick performance comparison before/after changing most of the proofs in our theorem lab's final project to Aesop one-liners:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">cumulative</span> <span class=\"n\">profiling</span> <span class=\"n\">times</span><span class=\"o\">:</span>\n    <span class=\"n\">compilation</span> <span class=\"mi\">61</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"n\">ms</span>\n    <span class=\"n\">elaboration</span> <span class=\"mi\">789</span><span class=\"n\">ms</span>\n    <span class=\"kn\">import</span> <span class=\"mi\">15</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"n\">ms</span>\n    <span class=\"n\">initialization</span> <span class=\"mi\">17</span><span class=\"bp\">.</span><span class=\"mi\">9</span><span class=\"n\">ms</span>\n    <span class=\"n\">interpretation</span> <span class=\"mi\">12</span><span class=\"bp\">.</span><span class=\"mi\">4</span><span class=\"n\">ms</span>\n    <span class=\"n\">parsing</span> <span class=\"mi\">8</span><span class=\"bp\">.</span><span class=\"mi\">61</span><span class=\"n\">ms</span>\n    <span class=\"n\">simp</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">04</span><span class=\"n\">s</span>\n    <span class=\"n\">typeclass</span> <span class=\"n\">inference</span> <span class=\"mi\">78</span><span class=\"bp\">.</span><span class=\"mi\">3</span><span class=\"n\">ms</span>\n<span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">15</span><span class=\"n\">user</span> <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">04</span><span class=\"n\">system</span> <span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"mi\">02</span><span class=\"bp\">.</span><span class=\"mi\">20</span><span class=\"n\">elapsed</span> <span class=\"mi\">100</span><span class=\"bp\">%</span><span class=\"n\">CPU</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"n\">avgtext</span><span class=\"bp\">+</span><span class=\"mi\">0</span><span class=\"n\">avgdata</span> <span class=\"mi\">226124</span><span class=\"n\">maxresident</span><span class=\"o\">)</span><span class=\"n\">k</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">cumulative</span> <span class=\"n\">profiling</span> <span class=\"n\">times</span><span class=\"o\">:</span>\n    <span class=\"n\">compilation</span> <span class=\"mi\">65</span><span class=\"n\">ms</span>\n    <span class=\"n\">elaboration</span> <span class=\"mi\">581</span><span class=\"n\">ms</span>\n    <span class=\"kn\">import</span> <span class=\"mi\">116</span><span class=\"n\">ms</span>\n    <span class=\"n\">initialization</span> <span class=\"mi\">17</span><span class=\"bp\">.</span><span class=\"mi\">7</span><span class=\"n\">ms</span>\n    <span class=\"n\">interpretation</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"n\">s</span>\n    <span class=\"n\">parsing</span> <span class=\"mi\">10</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"n\">ms</span>\n    <span class=\"n\">simp</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">81</span><span class=\"n\">s</span>\n    <span class=\"n\">typeclass</span> <span class=\"n\">inference</span> <span class=\"mi\">92</span><span class=\"bp\">.</span><span class=\"mi\">8</span><span class=\"n\">ms</span>\n<span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">91</span><span class=\"n\">user</span> <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">06</span><span class=\"n\">system</span> <span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"mi\">03</span><span class=\"bp\">.</span><span class=\"mi\">98</span><span class=\"n\">elapsed</span> <span class=\"mi\">100</span><span class=\"bp\">%</span><span class=\"n\">CPU</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"n\">avgtext</span><span class=\"bp\">+</span><span class=\"mi\">0</span><span class=\"n\">avgdata</span> <span class=\"mi\">445548</span><span class=\"n\">maxresident</span><span class=\"o\">)</span><span class=\"n\">k</span>\n</code></pre></div>",
        "id": 287038651,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1655896985
    },
    {
        "content": "<p>Mind you, this is using my simplistic <a href=\"https://github.com/IPDSnelting/tba-2022/blob/d8c2761a1d6fc942cdc015514da2c43bb876bf86/TBA/Util/AesopExts.lean#L32-L38\"><code>simpAll</code></a> rule. I'm sure <span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> can come up with a much more performant implementation.</p>",
        "id": 287039262,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1655897310
    },
    {
        "content": "<p>I presented Aesop to the students of our Lean 4 lab course yesterday. We'll see if they find it helpful for the final project (which has already started), but here are my slides if anyone else is interested: <a href=\"https://github.com/IPDSnelting/tba-2022/blob/master/slides/lecture9.pdf\">https://github.com/IPDSnelting/tba-2022/blob/master/slides/lecture9.pdf</a></p>",
        "id": 287054898,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1655905178
    },
    {
        "content": "<p>Once more, with <del>feeling</del> <code>--load-dynlib</code> to eliminate the interpretation overhead in Aesop:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">cumulative</span> <span class=\"n\">profiling</span> <span class=\"n\">times</span><span class=\"o\">:</span>\n    <span class=\"n\">compilation</span> <span class=\"mi\">64</span><span class=\"bp\">.</span><span class=\"mi\">4</span><span class=\"n\">ms</span>\n    <span class=\"n\">elaboration</span> <span class=\"mi\">897</span><span class=\"n\">ms</span>\n    <span class=\"kn\">import</span> <span class=\"mi\">119</span><span class=\"n\">ms</span>\n    <span class=\"n\">initialization</span> <span class=\"mi\">17</span><span class=\"bp\">.</span><span class=\"mi\">5</span><span class=\"n\">ms</span>\n    <span class=\"n\">interpretation</span> <span class=\"mi\">184</span><span class=\"n\">ms</span>\n    <span class=\"n\">parsing</span> <span class=\"mi\">10</span><span class=\"bp\">.</span><span class=\"mi\">6</span><span class=\"n\">ms</span>\n    <span class=\"n\">simp</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">81</span><span class=\"n\">s</span>\n    <span class=\"n\">typeclass</span> <span class=\"n\">inference</span> <span class=\"mi\">93</span><span class=\"bp\">.</span><span class=\"mi\">6</span><span class=\"n\">ms</span>\n<span class=\"n\">Command</span> <span class=\"n\">exited</span> <span class=\"k\">with</span> <span class=\"n\">non</span><span class=\"bp\">-</span><span class=\"n\">zero</span> <span class=\"n\">status</span> <span class=\"mi\">1</span>\n<span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">36</span><span class=\"n\">user</span> <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">08</span><span class=\"n\">system</span> <span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"mi\">03</span><span class=\"bp\">.</span><span class=\"mi\">44</span><span class=\"n\">elapsed</span> <span class=\"mi\">100</span><span class=\"bp\">%</span><span class=\"n\">CPU</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"n\">avgtext</span><span class=\"bp\">+</span><span class=\"mi\">0</span><span class=\"n\">avgdata</span> <span class=\"mi\">444632</span><span class=\"n\">maxresident</span><span class=\"o\">)</span><span class=\"n\">k</span>\n</code></pre></div>\n<p>That's not bad.</p>",
        "id": 287159561,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1655973350
    },
    {
        "content": "<p><code>Command exited with non-zero status 1</code> is usually bad, right?</p>",
        "id": 287164951,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1655976876
    },
    {
        "content": "<p>Yes, UNIX systems have a thing called an exit code, 0 means fine, everything \\neq 0 means, something bad happened. If the program is sticking to established standards it will return one of the so called <code>errno</code> (<a href=\"https://www.man7.org/linux/man-pages/man3/errno.3.html\">https://www.man7.org/linux/man-pages/man3/errno.3.html</a>) constants. You can translate a number back to a name from this manpage with <code>errno &lt;number&gt;</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">λ</span> <span class=\"n\">errno</span> <span class=\"mi\">1</span>\n<span class=\"n\">EPERM</span> <span class=\"mi\">1</span> <span class=\"n\">Operation</span> <span class=\"n\">not</span> <span class=\"n\">permitted</span>\n</code></pre></div>",
        "id": 287165303,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1655977096
    },
    {
        "content": "<p>Hah, forgot to edit that out... it's from a proof that <em>should</em> be finished with <code>simpAll</code>, but my current implementation of it fails if the goal did not change (to prevent looping), only the local context did</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">unprovable</span><span class=\"o\">)</span>\n<span class=\"bp\">...</span>\n<span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">Γ</span> <span class=\"n\">x</span><span class=\"bp\">¹</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">τ</span>\n<span class=\"n\">fwd</span> <span class=\"o\">:</span> <span class=\"bp\">Γ</span> <span class=\"n\">x</span><span class=\"bp\">¹</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">Val.ty</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">const</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">τ</span>\n</code></pre></div>\n<p>Since I'm convinced I have \"morally\" completed the proof, I'm simply waiting for Aesop to get better instead of finding a different proof <span aria-label=\"halo\" class=\"emoji emoji-1f607\" role=\"img\" title=\"halo\">:halo:</span> .</p>",
        "id": 287165614,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1655977336
    },
    {
        "content": "<p>\"Proof by morality\"</p>",
        "id": 287165653,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1655977372
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> I've now added most of your extensions as builtin rules: <code>simp_all</code> during normalisation, automatic splitting of the target and of hypotheses, automatic substitution of equations whose LHS or RHS is a variable. (My test suite actually got faster, presumably because more goals now get solved by <code>simp</code>.)</p>\n<blockquote>\n<p>Once more, with --load-dynlib to eliminate the interpretation overhead in Aesop:</p>\n</blockquote>\n<p>Which incantation did you use to test this?</p>\n<p>Regarding performance in general: while I've been careful not to introduce unnecessary overhead, I haven't looked into any bigger optimisations yet. Aesop tends to call rules many times on similar goals, so there are certainly caching opportunities.</p>",
        "id": 287186170,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1655989457
    },
    {
        "content": "<p>Awesome, I'll give it a try!</p>\n<blockquote>\n<p>Which incantation did you use to test this?</p>\n</blockquote>\n<p>It was something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">cd</span> <span class=\"n\">lean_packages</span><span class=\"bp\">/</span><span class=\"n\">aesop</span><span class=\"bp\">;</span> <span class=\"n\">lake</span> <span class=\"n\">build</span> <span class=\"o\">:</span><span class=\"n\">sharedLib</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">lake</span> <span class=\"n\">env</span> <span class=\"n\">lean</span> <span class=\"n\">Foo.lean</span> <span class=\"c1\">--profile --load-dynlib=./lean_packages/aesop/build/lib/Aesop.so</span>\n</code></pre></div>",
        "id": 287193994,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1655992681
    },
    {
        "content": "<p>Thanks! I'll add this to the testsuite.</p>",
        "id": 287194499,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1655992847
    },
    {
        "content": "<p>Hmm, when I run these commands (with a <code>lake clean</code> thrown in for good measure), I get <code>Error: index out of bounds</code> for every file. But the unused variable linter still complains, so the files seem to get typechecked.</p>",
        "id": 287198941,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1655994751
    },
    {
        "content": "<p>Yes, I didn't investigate that yet</p>",
        "id": 287199382,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1655994931
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/Aesop.20update/near/287193994\">said</a>:</p>\n<blockquote>\n<p>It was something like</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">cd</span> <span class=\"n\">lean_packages</span><span class=\"bp\">/</span><span class=\"n\">aesop</span><span class=\"bp\">;</span> <span class=\"n\">lake</span> <span class=\"n\">build</span> <span class=\"o\">:</span><span class=\"n\">sharedLib</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Fyi,  <code>lake build Aesop:sharedLib</code> should work as well. <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span> (If it doesn't, that's a bug).</p>",
        "id": 287391734,
        "sender_full_name": "Mac",
        "timestamp": 1656109178
    },
    {
        "content": "<p>I also tested accelerating Aesop using <code>precompileModules := true</code> in its lakefile.lean with Lake master, and performance seems to be equal to the manually loaded single shared lib above. <span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> This might be worth a Lake bump in lean4 if you're not already planning one?</p>",
        "id": 287722002,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656425776
    },
    {
        "content": "<p>For what it's worth, we are already at 2905 bytes of <code>--load-dynlib</code> flags <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 287722089,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1656425826
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/Aesop.20update/near/287722002\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> This might be worth a Lake bump in lean4 if you're not already planning one?</p>\n</blockquote>\n<p>My plan is to have a bump by the end of the week. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 287747014,
        "sender_full_name": "Mac",
        "timestamp": 1656436133
    }
]