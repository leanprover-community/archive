[
    {
        "content": "<p>Hello ! I'm building some terms in <code>Expr</code>, and in particular I would like to define a recursive function. I'm having a hard time using recursors (<code>.rec</code>, <code>.recOn</code>, etc).</p>\n<ol>\n<li>What is the complete list of recursors which are automatically defined for an inductive ?</li>\n<li>Is there a way to do this with a higher-level API than recursors ?</li>\n</ol>",
        "id": 474807316,
        "sender_full_name": "Mathis Bouverot-Dupuis",
        "timestamp": 1728043058
    },
    {
        "content": "<p>You can write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">proj</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"c1\">-- etc</span>\n</code></pre></div>",
        "id": 474812463,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728044923
    },
    {
        "content": "<p>I think Mathis means generating an <code>Expr</code> that represents a recursive function</p>",
        "id": 474812571,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1728044971
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/Recursive.20definition.20in.20.60Expr.60/near/474812571\">said</a>:</p>\n<blockquote>\n<p>I think Mathis means generating an <code>Expr</code> that represents a recursive function</p>\n</blockquote>\n<p>Yes exactly.</p>",
        "id": 474812725,
        "sender_full_name": "Mathis Bouverot-Dupuis",
        "timestamp": 1728045024
    },
    {
        "content": "<p>I guess my suggeston then becomes \"can you emit <code>Syntax</code> and elaborate it, rather than building an <code>Expr</code>\"?</p>",
        "id": 474813458,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728045297
    },
    {
        "content": "<p>I would prefer not as I use some <code>Expr</code>-related machinery to build my terms, such as unification or local declarations. Is there a way to stay in <code>Expr</code> ?</p>",
        "id": 474813876,
        "sender_full_name": "Mathis Bouverot-Dupuis",
        "timestamp": 1728045456
    },
    {
        "content": "<p>By <code>Expr</code>-related, do you mean <code>TermElabM</code>-related?</p>",
        "id": 474821288,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728047763
    },
    {
        "content": "<p>You can jump back and forth between <code>Expr</code> and <code>Syntax</code> using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr.toSyntax#doc\">docs#Lean.Expr.toSyntax</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Term.elabTerm#doc\">docs#Lean.Elab.Term.elabTerm</a></p>",
        "id": 474821371,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728047789
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Recursive.20definition.20in.20.60Expr.60/near/474821288\">said</a>:</p>\n<blockquote>\n<p>By <code>Expr</code>-related, do you mean <code>TermElabM</code>-related?</p>\n</blockquote>\n<p>Yes, I'm using <code>TermElabM</code> and <code>MetaM</code>.</p>",
        "id": 474825193,
        "sender_full_name": "Mathis Bouverot-Dupuis",
        "timestamp": 1728048967
    },
    {
        "content": "<p>I see, so how would I use <code>Syntax</code> to build a <del>match expression ?</del> EDIT : a recursive definition (I was thinking about fixpoints)</p>",
        "id": 474825385,
        "sender_full_name": "Mathis Bouverot-Dupuis",
        "timestamp": 1728049043
    },
    {
        "content": "<p>Can you give an example of the kind of expression you want to build?</p>",
        "id": 474827124,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728049559
    },
    {
        "content": "<p>I would like to build something like this :</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myListMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">myListMap</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n</code></pre></div>",
        "id": 474827812,
        "sender_full_name": "Mathis Bouverot-Dupuis",
        "timestamp": 1728049781
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\">  </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Term</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TermElabM</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"bp\">|</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">myListMap</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">myListMap</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n<span class=\"w\">    </span><span class=\"n\">myListMap</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"n\">none</span>\n</code></pre></div>",
        "id": 474828895,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728050105
    },
    {
        "content": "<p>With your definition <code>foo</code>, I tried inspecting the resulting term :</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span><span class=\"w\"> </span><span class=\"bp\">=&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n<span class=\"w\">  </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">println</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{ ← ppExpr e }\"</span>\n</code></pre></div>\n<p>And I get <code>(fun myListMap ↦ myListMap) ?m.16</code>. How come the result has unassigned metavars ?</p>",
        "id": 474831725,
        "sender_full_name": "Mathis Bouverot-Dupuis",
        "timestamp": 1728050907
    },
    {
        "content": "<p>I think that metavariable is one satisfying <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Term.isLetRecAuxMVar#doc\">docs#Lean.Elab.Term.isLetRecAuxMVar</a></p>",
        "id": 474839853,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728053434
    },
    {
        "content": "<p>I think the idea is that once you finally add the declaration to the environment, the <code>let rec</code> is added at the same time and the metavariable resolved; but I've not tried using <code>let rec</code>s in meta code before</p>",
        "id": 474840808,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728053747
    }
]