[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"c1\">-- def Proxy.foo : ℕ → ℕ :=</span>\n<span class=\"c1\">-- fun x =&gt;</span>\n<span class=\"c1\">--   Nat.brecOn x fun x f =&gt;</span>\n<span class=\"c1\">--     (match (motive := (x : ℕ) → Nat.below x → ℕ) x with</span>\n<span class=\"c1\">--       | 0 =&gt; fun x =&gt; 0</span>\n<span class=\"c1\">--       | n.succ =&gt; fun x =&gt; n + 1 + x.1)</span>\n<span class=\"c1\">--       f</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">eq_1</span><span class=\"w\"> </span><span class=\"c1\">-- theorem Proxy.foo.eq_1 : foo 0 = 0 := Eq.refl (foo 0)</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">eq_2</span><span class=\"w\"> </span><span class=\"c1\">-- theorem Proxy.foo.eq_2 : ∀ (n : ℕ), foo n.succ = n + 1 + foo n := fun n =&gt; Eq.refl (foo n.succ)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">canUse</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">eq_1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">eq_2</span><span class=\"o\">]</span>\n\n<span class=\"c1\">------- so far ok, but now</span>\n\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">foo2</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">foo2</span><span class=\"w\"> </span><span class=\"c1\">-- opaque Proxy.foo2 : ℕ → ℕ</span>\n<span class=\"c1\">-- #print foo2.eq_1 -- why not create theorem Proxy.foo2.eq_1 : foo n = n + foo2 n := ???</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo2</span><span class=\"bp\">.</span><span class=\"n\">canUse</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo2</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">foo2</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">foo2</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- I want to prove this, but cannot</span>\n<span class=\"c1\">-- type mismatch</span>\n<span class=\"c1\">--   Eq.refl (foo2 n)</span>\n<span class=\"c1\">-- has type</span>\n<span class=\"c1\">--   foo2 n = foo2 n : Prop</span>\n<span class=\"c1\">-- but is expected to have type</span>\n<span class=\"c1\">--   foo2 n = n + foo2 n : Prop</span>\n</code></pre></div>\n<p>why I need this? I want to prove <a href=\"https://github.com/srghma2/lean-pipes/blob/3afeb2d9d134cb588125cb8212ae17360a730e8b/Pipes/CoreLaws.lean#L251\">PushCategory</a>  but I need to prove first <a href=\"https://github.com/srghma2/lean-pipes/blob/3afeb2d9d134cb588125cb8212ae17360a730e8b/Pipes/CoreLaws.lean#L207\"><code>Proxy.Unbounded.push x &gt;&gt;~ Proxy.Unbounded.push = Proxy.Unbounded.push x</code></a></p>",
        "id": 526308570,
        "sender_full_name": "Serhii Khoma (srghma)",
        "timestamp": 1751248200
    },
    {
        "content": "<p>Why do you think this should be provable?</p>",
        "id": 526308737,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751248340
    },
    {
        "content": "<p>In fact, I can prove that it is false</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">foo2</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo2</span><span class=\"bp\">.</span><span class=\"n\">cannot_use</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">foo2</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">foo2</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">specialize</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">omega</span>\n</code></pre></div>",
        "id": 526308886,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751248483
    },
    {
        "content": "<p>But can you do the same with </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">foo2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(aka the triangular numbers) <br>\nI think in that case the corresponding theorem is true but rfl wouldn't be able to prove it, which is what OP is asking about.<br>\nI think the problem is that partial functions are opaque to avoid soundness issues.</p>",
        "id": 526315551,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1751255756
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"933054\">@Snir</span> Why must <code>foo2 0 = 0</code> with your definition? It appears to me that it's underconstrained and <code>foo2 0</code> could be anything.</p>",
        "id": 526320420,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751260000
    },
    {
        "content": "<p>Huh that's a good point, so I guess they're the triangular numbers plus C <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span><br>\nBut still OP's theorem (the recurrence relation) holds</p>",
        "id": 526320599,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1751260150
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"813382\">Serhii Khoma (srghma)</span> has marked this topic as resolved.</p>",
        "id": 526725075,
        "sender_full_name": "Notification Bot",
        "timestamp": 1751436100
    }
]