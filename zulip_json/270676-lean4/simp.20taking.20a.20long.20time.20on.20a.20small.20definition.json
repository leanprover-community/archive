[
    {
        "content": "<p>In the following example, simp takes a very long time to finish, which is proportional to the number I put in the bound for the <code>for ...</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Id.run</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"c1\">-- We need to have two mutable variables</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"mi\">256</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"c1\">-- We need the upper bound to be high</span>\n<span class=\"w\">    </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- takes seconds to finish</span>\n</code></pre></div>\n<p>Does someone have an idea about what is going on? In the case above it only takes a few seconds, but I have a development for which this issue makes one of my definitions completely unusable.</p>\n<p>Note that I tried introducing an intermediate, irreducible definition for the upper bound, but it has no effect:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">irreducible</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">LEN</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">256</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Id.run</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"c1\">-- We need to have two mutable variables</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">LEN</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"c1\">-- We need the upper bound to be high</span>\n<span class=\"w\">    </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- takes seconds to finish</span>\n</code></pre></div>",
        "id": 495050322,
        "sender_full_name": "Son Ho",
        "timestamp": 1737466638
    },
    {
        "content": "<p>The problem is not the <code>simp</code>, which is very fast, but the kernel typechecking the definition, and the kernel ignores transparency. I couldn't find any good kernel trace options, but the problem might be the for-loop, since the implementation for for-loops was defined using well-founded recursion.</p>",
        "id": 495087138,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737474506
    },
    {
        "content": "<p>Thanks! What is the problem with using well-founded recursion ? Is it that the kernel doesn't have a simple criteria to use to stop unfolding recursive definitions ?</p>",
        "id": 495091476,
        "sender_full_name": "Son Ho",
        "timestamp": 1737475567
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/270676-lean4/topic/.60deep.20recursion.20detected.60.20with.2016-bit.20bitvec's/near/494903814\">said</a>:</p>\n<blockquote>\n<p>I think David Renshaw has a <a href=\"https://www.youtube.com/watch?v=FOt-GsiNJmU\">good video</a> explaining the problem with reduction of well-founded recursion.<br>\nBasically, when you use well founded recursion on <code>Nat</code> to go from <code>n₁</code> down to <code>n₂</code>, this takes time proportional to <code>n₂ * (n₁ - n₂)</code> to reduce, and this happens again when you go from <code>n₂</code> to <code>n₃</code>, and <code>n₃</code> to <code>n₄</code>, and this ends up taking a very long time, which is why you can time out trying to reduce terms such as <code>Nat.log2 1000</code>.</p>\n</blockquote>\n<p>In this case, probably something is causing the kernel to think that unfolding the for loop is a good idea, and it gets stuck trying that for a long time.</p>",
        "id": 495111548,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737481253
    },
    {
        "content": "<p>Thanks! This is extremely useful. <del>But from that I don't see any good workaround put aside completely reworking my definition...</del></p>",
        "id": 495235595,
        "sender_full_name": "Son Ho",
        "timestamp": 1737538276
    },
    {
        "content": "<p>I managed to get away by introducing an alternative definition for <code>Std.Range</code> so that I could write my own instance of <code>ForIn'</code>, which is equivalent to the instance of <code>Std.Range</code> but under the hood uses a fuel parameter (it's easy to find an upper bound on the fuel). This and an appropriate notation for <code>[x:y]</code> allowed me to circumvent the issue.</p>",
        "id": 495240683,
        "sender_full_name": "Son Ho",
        "timestamp": 1737539816
    },
    {
        "content": "<p>I essentially copy-pasted this to add a fuel:<br>\n<a href=\"https://github.com/leanprover/lean4/blob/b6db90a31601866d58a07e86aba3720991aa73c8/src/Init/Data/Range/Basic.lean#L28\">https://github.com/leanprover/lean4/blob/b6db90a31601866d58a07e86aba3720991aa73c8/src/Init/Data/Range/Basic.lean#L28</a></p>",
        "id": 495240917,
        "sender_full_name": "Son Ho",
        "timestamp": 1737539887
    }
]