[
    {
        "content": "<p>I am trying to create some combinators. I have one working, but a more complicated form is not:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"s2\">\" â†¦ \"</span> <span class=\"n\">v</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">kestrel</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">â†¦</span> <span class=\"n\">_y</span> <span class=\"bp\">â†¦</span> <span class=\"n\">x</span>\n<span class=\"c1\">-- Works!! ðŸŽ‰</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">kestrel</span> <span class=\"n\">A</span> <span class=\"n\">B</span>\n\n<span class=\"c1\">-- Get a type error here :(</span>\n<span class=\"kd\">def</span> <span class=\"n\">thrush</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">â†¦</span> <span class=\"n\">b</span> <span class=\"bp\">â†¦</span> <span class=\"n\">b</span> <span class=\"n\">a</span>\n\n<span class=\"c1\">-- Expecting to get B -&gt; A</span>\n<span class=\"c1\">-- #reduce thrush A B</span>\n</code></pre></div>\n<p>the problem is that <code>Type -&gt; Type</code> is not assignable <code>Type</code></p>\n<p>Maybe this is a problem with universes?</p>",
        "id": 390502685,
        "sender_full_name": "Ben",
        "timestamp": 1694519631
    },
    {
        "content": "<p>it's a problem with types</p>",
        "id": 390503238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694519812
    },
    {
        "content": "<p>your macro declares every variable to have type <code>Type -&gt; Type</code>, so you can't apply one to another</p>",
        "id": 390503312,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694519839
    },
    {
        "content": "<p>For <code>b a</code> to typecheck, <code>a</code> and <code>b</code> need to have different types, specifically <code>b</code> should have the type <code>A -&gt; B</code> and <code>a</code> should have type <code>A</code>, for some <code>A</code> and <code>B</code></p>",
        "id": 390503489,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694519891
    },
    {
        "content": "<p>hmm yes. and it would be nice not to have to annotate the parameters but at the moment Lean can't infer it</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"s2\">\" â†¦ \"</span> <span class=\"n\">v</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 390505042,
        "sender_full_name": "Ben",
        "timestamp": 1694520398
    },
    {
        "content": "<p>maybe I have to go more into the meta</p>",
        "id": 390505137,
        "sender_full_name": "Ben",
        "timestamp": 1694520431
    },
    {
        "content": "<p>If I'm understanding this correctly, a language like Haskell can work out the type of expressions like these because its type system has only one universe of types - this means that for such expressions there is a \"most generic type\" which Haskell can synthesise.</p>",
        "id": 390511904,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1694522617
    },
    {
        "content": "<p>Lean's type theory is much more complex than Haskell's, so it can't do that.</p>",
        "id": 390511959,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1694522637
    },
    {
        "content": "<p>in particular, lean will not infer from <code>b a</code> and <code>b</code> having a metavariable type that <code>b</code> is a function, it instead requires that <code>b</code> is a function and gives an error if it can't determine this by other means</p>",
        "id": 390512198,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694522712
    },
    {
        "content": "<p>since the only evidence that <code>b</code> is a function here is the application, lean refuses to play ball</p>",
        "id": 390512252,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694522730
    },
    {
        "content": "<p>though if you wanted, you could implement Hindley-Milner inference on a subset of the Lean syntax as a macro :,)</p>",
        "id": 390512821,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694522927
    },
    {
        "content": "<p>I think it wouldn't even be that hard, since all the hard work is already done with metavariables and unification</p>",
        "id": 390513070,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694523015
    },
    {
        "content": "<p>that's a very good point actually</p>",
        "id": 390513171,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694523060
    },
    {
        "content": "<p>I made a half-baked Hindley-Milner-like generalization algorithm recently: <a href=\"https://gist.github.com/kmill/8da3433bf4097f79bf5913d861adbd6b\">https://gist.github.com/kmill/8da3433bf4097f79bf5913d861adbd6b</a></p>\n<p>For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">hm</span><span class=\"bp\">%</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">â†’</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n<span class=\"k\">#print</span> <span class=\"n\">f</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">def f.{u_1, u_2} : {x : Sort u_1} â†’ {x_1 : Sort u_2} â†’ (x_1 â†’ x) â†’ x_1 â†’ x :=</span>\n<span class=\"cm\">fun {x} {x_1} x y â†¦ x y</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>You need to give that type hint for <code>x</code> to avoid \"function expected\"</p>\n<p>It tends to overgeneralize though when it comes to typeclasses. For example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">hm</span><span class=\"bp\">%</span> <span class=\"k\">fun</span> <span class=\"n\">Î±</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">default</span> <span class=\"o\">:</span> <span class=\"n\">Î±</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">... : [(Î± : Sort u_1) â†’ Inhabited Î±] â†’ (Î± : Sort u_1) â†’ Î±</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>That's not wrong, but it would be more useful if it just assumed <code>Î±</code> was inhabited rather than assuming <em>all</em> types are inhabited! The algorithm only knows how to put new arguments before all existing arguments.</p>\n<p>This one is more of a success:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">hm</span><span class=\"bp\">%</span> <span class=\"o\">(</span><span class=\"n\">default</span><span class=\"o\">,</span> <span class=\"n\">default</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">... : {x : Type u_1} â†’ [Inhabited x] â†’ {x_2 : Type u_2} â†’ [Inhabited x_2] â†’ x Ã— x_2</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>(That's going against the \"monomorphism restriction\" in Haskell by the way, since it will non-obviously re-evaluate at each invocation if you weren't aware that <code>hm%</code> was introducing implicit arguments.)</p>",
        "id": 390521777,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1694525727
    },
    {
        "content": "<p>It might be fun to make a <code>let</code>-like syntax that inserts <code>hm%</code>, like <code>let! f x := v; w</code> for <code>let f := hm% fun x =&gt; v; w</code>, to give you a Haskell-like <code>let</code>.</p>",
        "id": 390522617,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1694526019
    },
    {
        "content": "<p>embedding a Hindley-Milner system seems interesting. If I could get it to compile without that complexity though it would be great</p>",
        "id": 390524190,
        "sender_full_name": "Ben",
        "timestamp": 1694526505
    },
    {
        "content": "<p>I think the problem is <code>Type 1 â†’ Type 1</code> is not a member of <code>Type 1</code>, it has to be higher e.g. <code>#check (Type 1 â†’ Type 1 : Type 2)</code>. Could I get the above working by adding universe annotations to the parameter? Would problems arise with composition? Maybe I will try later</p>",
        "id": 390524621,
        "sender_full_name": "Ben",
        "timestamp": 1694526655
    },
    {
        "content": "<p>no, the problem is that <code>Type 1 -&gt; Type 1</code> is not literally the same as <code>Type 1</code>. What you need here is a (definitional) equality of types, not a membership relation</p>",
        "id": 390525766,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694527023
    },
    {
        "content": "<p>that is, if <code>b : Type 1 -&gt; Type 1</code> and <code>a : Type 2</code> neither <code>b a</code> nor <code>a b</code> typechecks</p>",
        "id": 390525967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694527079
    },
    {
        "content": "<p>Note that <code>a : Type</code> doesn't mean \"<code>a</code> is a value of any type\", it means that \"<code>a</code> is a type\". Similarly, <code>a : Type -&gt; Type</code> doesn't mean \"<code>a</code> is a function (between objects whose types lie in <code>Type</code>)\", it means \"<code>a</code> is a function taking a type and returning a type\".</p>",
        "id": 390532751,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1694529148
    },
    {
        "content": "<p>The point is that all of the variables you use in your combinators really are different types (they can't all be <code>Type -&gt; Type</code>, for example), and Lean can't deduce them automatically.</p>",
        "id": 390534385,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1694529641
    },
    {
        "content": "<p>Attempting this again. Looks like I might have to create a custom structure rather than using Lean's functions. <strong>But one last check before I go down that route</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mockingbird</span> <span class=\"o\">{</span> <span class=\"n\">T</span> <span class=\"n\">U</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">t</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>Am I correcting in thinking this is impossible in Lean's type system. There isn't a combination of <code>mutual</code> or <code>class</code> that could make it possible. The following definition is impossible, right?</p>",
        "id": 391019448,
        "sender_full_name": "Ben",
        "timestamp": 1694726250
    },
    {
        "content": "<p>Hm, what type do you want <code>mockingbird</code> to have?<br>\n<code>{T U : Type} -&gt; ((T -&gt; U) -&gt; U) -&gt; U</code> is unsound &amp; can't be defined in Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">((</span><span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Empty</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">())</span>\n  <span class=\"n\">nomatch</span> <span class=\"n\">this</span>\n</code></pre></div>",
        "id": 391022723,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694727938
    },
    {
        "content": "<p>Yes lean won't let you prove <code>False</code>, that's kind of the point</p>",
        "id": 391022803,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694727971
    },
    {
        "content": "<p>(if you try implementing it, you need to build an infinite stack of calls to the <code>t</code> function, which you're not allowed to do in Lean -- all functions must terminate, because otherwise you can prove <code>False</code> <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>)</p>",
        "id": 391022840,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694727994
    },
    {
        "content": "<p>James meant: you can define this type but you will never be able to construct a term of this type since it would allow to prove false.</p>",
        "id": 391022875,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694728014
    },
    {
        "content": "<p>this is the core of the proof that lambda calculus is turing complete but simply typed lambda calculus is strongly normalizing</p>",
        "id": 391022946,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694728048
    },
    {
        "content": "<p>You can make a term of the type if you make it whatever the lean 4 version of <code>meta</code> is (apparently it's <code>unsafe</code>)</p>",
        "id": 391022962,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694728056
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> that won't help it typecheck though</p>",
        "id": 391023123,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694728131
    },
    {
        "content": "<p>here's a setup so you can play with untyped lambda calculus:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unsafe</span> <span class=\"kd\">inductive</span> <span class=\"n\">D</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lam</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"bp\">â†’</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"bp\">â†’</span> <span class=\"n\">D</span>\n\n<span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">â†’</span> <span class=\"n\">D</span> <span class=\"bp\">â†’</span> <span class=\"n\">D</span> <span class=\"bp\">|</span> <span class=\"o\">âŸ¨</span><span class=\"n\">f</span><span class=\"o\">âŸ©</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span>\n\n<span class=\"n\">unsafe</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CoeFun</span> <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">D</span> <span class=\"bp\">â†’</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">âŸ¨</span><span class=\"n\">app</span><span class=\"o\">âŸ©</span>\n\n<span class=\"n\">unsafe</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"bp\">â†’</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"o\">âŸ¨</span><span class=\"n\">D.lam</span><span class=\"o\">âŸ©</span>\n\n<span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">mockingbird</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 391023545,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694728376
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> this is incredible and very useful.</p>\n<p>However I am stuck on a new cyclic type issue. Trying</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">bluebird</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">bluebird</span> <span class=\"n\">bluebird</span>\n</code></pre></div>\n<p><code>bluebird</code> cannot be called with <code>bluebird</code></p>\n<p>I think this is from</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- This is great</span>\n<span class=\"n\">unsafe</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"bp\">â†’</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"o\">âŸ¨</span><span class=\"n\">D.lam</span><span class=\"o\">âŸ©</span>\n<span class=\"c1\">-- But additionally need !</span>\n<span class=\"n\">unsafe</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"bp\">â†’</span> <span class=\"n\">D</span> <span class=\"bp\">â†’</span> <span class=\"n\">D</span> <span class=\"bp\">â†’</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"o\">âŸ¨</span><span class=\"gr\">sorry</span><span class=\"o\">âŸ©</span>\n</code></pre></div>\n<p>For what I am trying I should need any higher arity, so hopefully just a second instance rather than anything more complex</p>",
        "id": 391149143,
        "sender_full_name": "Ben",
        "timestamp": 1694778879
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unsafe</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"bp\">â†’</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"o\">âŸ¨</span><span class=\"n\">D.lam</span><span class=\"o\">âŸ©</span>\n<span class=\"n\">unsafe</span> <span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Coe</span> <span class=\"n\">A</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"bp\">â†’</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"o\">âŸ¨</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">Â·</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">â†’</span> <span class=\"n\">D</span><span class=\"o\">)âŸ©</span>\n\n<span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">bluebird</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">bluebird</span> <span class=\"n\">bluebird</span>\n</code></pre></div>",
        "id": 391149884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694779088
    },
    {
        "content": "<p>Nice!!! I didn't even know if the one I need was possible, let alone a <em>generic</em> version!</p>",
        "id": 391154571,
        "sender_full_name": "Ben",
        "timestamp": 1694780311
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 391155351,
        "sender_full_name": "Ben",
        "timestamp": 1694780436
    },
    {
        "content": "<p>While the function application works. I am now stuck with this. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">Coe.coe</span> <span class=\"n\">bluebird</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">â†’</span> <span class=\"n\">D</span> <span class=\"bp\">â†’</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Seems like it should work with the <code>Coe</code> instance but it fails at the check with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"kd\">instance</span>\n  <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"bp\">â†’</span> <span class=\"n\">D</span> <span class=\"bp\">â†’</span> <span class=\"n\">D</span> <span class=\"bp\">â†’</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"bp\">â†’</span> <span class=\"n\">D</span> <span class=\"bp\">â†’</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which means I can't do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">identity</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n<span class=\"n\">unsafe</span> <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">identity</span> <span class=\"bp\">â‰ </span> <span class=\"n\">bluebird</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 391179063,
        "sender_full_name": "Ben",
        "timestamp": 1694786731
    },
    {
        "content": "<p><code>rfl</code> proves goals of the form <code>X = X</code> so it won't prove the example.</p>",
        "id": 391225521,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694798447
    },
    {
        "content": "<p>also, I think the unsafe-ness and coercions were moreso to demonstrate the point that you can get something that looks like untyped lambda calculus -- all of the proving-tools in Lean become sorta moot once you're able to prove <code>False</code></p>",
        "id": 391228138,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694799338
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"457144\">@Ben</span> The point about <em>untyped</em> lambda calculus is that you shouldn't be using types: everything should have type <code>D</code>, and the coercions are just a convenience to make it easier to write such things. <code>bluebird</code> should have type <code>D</code> too, and a better way to write it to ensure this is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">bluebird</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>You should never be type ascribing something as having a function type</p>",
        "id": 391251659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694807542
    },
    {
        "content": "<p>As james says, you are not going to be able to prove any equality theorems (or rather, you will be far too effective at proving equality theorems) because this model of lambda calculus proves false</p>",
        "id": 391251872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694807631
    },
    {
        "content": "<p>you also can't use <code>rfl</code> to prove disequality goals</p>",
        "id": 391251964,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694807654
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"457144\">Ben</span> has marked this topic as resolved.</p>",
        "id": 391483735,
        "sender_full_name": "Notification Bot",
        "timestamp": 1694947701
    }
]