[
    {
        "content": "<p>I had seen this problem before, but it popped up twice recently again in <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Coercion.20triggers.20timeout/with/517177117\">#mathlib4 &gt; Coercion triggers timeout</a>  and <a href=\"#narrow/channel/287929-mathlib4/topic/simp.20timeout.20at.20.60whnf.60\">#mathlib4 &gt; simp timeout at &#96;whnf&#96;</a>, so I decided to investigate further.</p>\n<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> of exponential blowup in type class search:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"mi\">15</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">profiler</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"mi\">15</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">test</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>The problem arises for unification goals of the form <code>f a‚ÇÅ .. a‚Çô =?= f b‚ÇÅ .. b‚Çô</code> which contain at least one metavariable. There are two main approaches to solve this:</p>\n<ol>\n<li>Unify the arguments pairwise: <code>a‚ÇÅ =?= b‚ÇÅ</code>, .. <code>a‚Çô =?= b‚Çô</code>.</li>\n<li>Unfold <code>f</code> on both sides</li>\n</ol>\n<p>It is important to start with (1), e.g. for goals of the form <code>f a =?= f ?m</code>, so that we can immediately assign <code>?m := a</code>.</p>\n<p>When applying (2), we often end up with many of the same arguments <code>a‚ÇÅ .. a‚Çô</code> and <code>b‚ÇÅ .. b‚Çô</code> on both sides. This means that applying (1) to that leads to many of the same unification goals <code>a‚ÇÅ =?= b‚ÇÅ</code>, .. <code>a‚Çô =?= b‚Çô</code>. The problem is that the transient cache (that is the cache for unification with metavariables) is not available, meaning that the same unification is tried multiple times. If this pattern repeats, then it leads to an exponential blowup.</p>\n<p>I'm attempting to make a fix for this at <a href=\"https://github.com/leanprover/lean4/pull/8294\">lean#8294</a>, and one test showed 1% <a href=\"https://github.com/leanprover-community/mathlib4/pull/24808#issuecomment-2872413682\">speedup</a> in Mathlib.</p>\n<p>In the PR I am running into some mysterious build problems with segfaults in the PR, does anyone understand that? It seems to show up with some probability, but since there are multiple builds, usually at least one is affected.</p>",
        "id": 518025608,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1747217823
    },
    {
        "content": "<p>My proposed solution is to change where the transient cache is being reset. Instead of resetting it at each <code>checkpointDefEq</code>, it should be reset at the start of <code>isDefEq</code>, and stay unreset as long as no metavariables are assigned. To make sure the cache stays valid, we keep track of the number of metavariable assignments in the metavariable context. If this number has increased w.r.t. the transient cache, then it isn't valid anymore. Whenever we revert the metavariable context (which we do in <code>checkpointDefEq</code>), if the number of metavariable assignments decreases, we also reset the transient cache.</p>",
        "id": 518029849,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1747219215
    },
    {
        "content": "<p>I assume that this fix will improve performance also in the situation described in <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/Coercion.20and.20unification/near/517382951\">#lean4 &gt; Coercion and unification @ üí¨</a> (I noticed quite a bit of repetition there), but will not prevent the fruitless unification attempt altogether. Would it be possible to also test my proposal (that the term <code>‚Üë ...</code> gets re-elaborated [if this is the correct term] as soon as its type metavariable gets assigned)? This may involve additional bookkeeping, so may not be entirely trivial. (Unfortunately, I know essentially nothing about metaprogramming or how the unification algorithm works...)</p>",
        "id": 518038931,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1747221926
    },
    {
        "content": "<p>Yes, I tried your mathlib free example on the lean version of my PR, and there it is quadratically slow instead of exponentially. with <code>p := 50</code>, it's still under a second.</p>",
        "id": 518045418,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1747223837
    },
    {
        "content": "<p>Any change specific to coercions would be a completely separate fix. Presumably that'll require a change on the elaboration side of things, instead of unification.</p>",
        "id": 518052519,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1747225758
    },
    {
        "content": "<p>It would likely fix <a href=\"https://github.com/leanprover/lean4/pull/2831\">lean4#2831</a> as well, though.</p>",
        "id": 518063095,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1747228481
    },
    {
        "content": "<p>Indeed, that seems to require an optimization to how coercions are elaborated.</p>",
        "id": 518091346,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1747235038
    },
    {
        "content": "<p>I got back to <a href=\"https://github.com/leanprover/lean4/pull/8294\">lean#8294</a>, with an improved approach, and I fixed some confusing mathlib failures. There is now a speedup of </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">build</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mf\">5127.32</span><span class=\"bp\">‚¨ù</span><span class=\"mi\">10</span><span class=\"bp\">‚Åπ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mf\">3.25</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"bp\">|</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">lint</span><span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mf\">524.117</span><span class=\"bp\">‚¨ù</span><span class=\"mi\">10</span><span class=\"bp\">‚Åπ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mf\">7.11</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"bp\">|</span>\n</code></pre></div>\n<p>In my new version, I fully reset the transient cache at the start of an <code>isDefEq</code> call as usual.</p>\n<ul>\n<li>The cache also stores the total number of metavariable assignments at the time the cache is made.</li>\n<li>When this number increases, the old cache is invalidated.</li>\n<li>When this number decreases (which can happen while reverting the metavariable context if a sub goal failed to unify) we revert the cache to the previous version.</li>\n<li>When this number stays the same, we keep using the same cache.</li>\n</ul>",
        "id": 522169518,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1748968277
    },
    {
        "content": "<p>I made some more improvements, and tested it on a newer mathlib version (in particular one including the recent <code>simp</code> improvements), and the speedup is now</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">build</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mf\">5685.57</span><span class=\"bp\">‚¨ù</span><span class=\"mi\">10</span><span class=\"bp\">‚Åπ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mf\">3.77</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"bp\">|</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">lint</span><span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mf\">593.369</span><span class=\"bp\">‚¨ù</span><span class=\"mi\">10</span><span class=\"bp\">‚Åπ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mf\">8.44</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"bp\">|</span>\n</code></pre></div>\n<p>It's now at the new PR <a href=\"https://github.com/leanprover/lean4/pull/8883\">lean#8883</a>, and I've marked it as ready for review. Hopefully the core team will find time to review this at some point.</p>\n<p>Edit: the speedup can be seen <a href=\"https://github.com/leanprover-community/mathlib4/pull/26163#issuecomment-2989785397\">here</a></p>",
        "id": 525152073,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750503657
    }
]