[
    {
        "content": "<p>I'm trying to define <a href=\"https://en.wikipedia.org/wiki/Linear_temporal_logic\">LTL</a>. I've defined the syntax:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- The syntax of LTL.</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Proposition</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">true</span>\n  <span class=\"bp\">|</span> <span class=\"n\">var</span>   <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">not</span>   <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Proposition</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">and</span>   <span class=\"o\">(</span><span class=\"n\">lhs</span> <span class=\"n\">rhs</span> <span class=\"o\">:</span> <span class=\"n\">Proposition</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">next</span>  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Proposition</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">until</span> <span class=\"o\">(</span><span class=\"n\">lhs</span> <span class=\"n\">rhs</span> <span class=\"o\">:</span> <span class=\"n\">Proposition</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">Proposition</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">var</span>\n\n<span class=\"kd\">notation</span> <span class=\"s2\">\"⊤\"</span>          <span class=\"bp\">=&gt;</span> <span class=\"n\">Proposition.true</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"¬\"</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"mi\">40</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Proposition.not</span> <span class=\"n\">p</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"◯\"</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"mi\">40</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Proposition.next</span> <span class=\"n\">p</span>\n<span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">35</span> <span class=\"s2\">\" ∧ \"</span>       <span class=\"bp\">=&gt;</span> <span class=\"n\">Proposition.and</span>\n<span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">30</span> <span class=\"s2\">\" U \"</span>       <span class=\"bp\">=&gt;</span> <span class=\"n\">Proposition.until</span>\n</code></pre></div>\n</div></div>\n<p>Now I'd like to define the satisfaction relation as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Assignment</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span>\n<span class=\"kd\">def</span> <span class=\"n\">Trace</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Assignment</span> <span class=\"n\">V</span>\n\n<span class=\"c1\">-- ERROR: (kernel) arg #5 of 'LTL.Proposition.Sat.not' has a non positive occurrence of the datatypes being declared</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Proposition.Sat</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">Trace</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Proposition</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">true</span>  <span class=\"o\">:</span>                                                                    <span class=\"n\">Sat</span> <span class=\"n\">σ</span> <span class=\"n\">i</span> <span class=\"bp\">⊤</span>\n  <span class=\"bp\">|</span> <span class=\"n\">var</span>   <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">i</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">Bool.true</span><span class=\"o\">)</span>                                              <span class=\"bp\">→</span> <span class=\"n\">Sat</span> <span class=\"n\">σ</span> <span class=\"n\">i</span> <span class=\"n\">v</span>\n  <span class=\"bp\">|</span> <span class=\"n\">not</span>   <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"n\">Sat</span> <span class=\"n\">σ</span> <span class=\"n\">i</span> <span class=\"n\">p</span><span class=\"o\">)</span>                                                    <span class=\"bp\">→</span> <span class=\"n\">Sat</span> <span class=\"n\">σ</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">not</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">and</span>   <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Sat</span> <span class=\"n\">σ</span> <span class=\"n\">i</span> <span class=\"n\">lhs</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Sat</span> <span class=\"n\">σ</span> <span class=\"n\">i</span> <span class=\"n\">rhs</span><span class=\"o\">)</span>                                    <span class=\"bp\">→</span> <span class=\"n\">Sat</span> <span class=\"n\">σ</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">lhs</span> <span class=\"bp\">∧</span> <span class=\"n\">rhs</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">next</span>  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Sat</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">p</span><span class=\"o\">)</span>                                                <span class=\"bp\">→</span> <span class=\"n\">Sat</span> <span class=\"n\">σ</span> <span class=\"n\">i</span> <span class=\"bp\">◯</span><span class=\"n\">p</span>\n  <span class=\"bp\">|</span> <span class=\"n\">until</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Sat</span> <span class=\"n\">σ</span> <span class=\"n\">j</span> <span class=\"n\">rhs</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">&lt;</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Sat</span> <span class=\"n\">σ</span> <span class=\"n\">k</span> <span class=\"n\">lhs</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Sat</span> <span class=\"n\">σ</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">lhs</span> <span class=\"n\">U</span> <span class=\"n\">rhs</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>As you can see, this produces an error because the <code>not</code> constructor has a non-positive occurrence of <code>Proposition.Sat</code> by virtue of the negation. Is there any way to circumvent this issue by restructuring <code>Proposition.Sat</code>?</p>\n<p>Of course, going for a plain definition is always an option:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Proposition.Sat</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">Trace</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Proposition</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">true</span>            <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n  <span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"n\">v</span>           <span class=\"bp\">=&gt;</span> <span class=\"n\">σ</span> <span class=\"n\">i</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">Bool.true</span>\n  <span class=\"bp\">|</span> <span class=\"n\">not</span> <span class=\"n\">p</span>           <span class=\"bp\">=&gt;</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">Sat</span> <span class=\"n\">σ</span> <span class=\"n\">i</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">and</span> <span class=\"n\">lhs</span> <span class=\"n\">rhs</span>     <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Sat</span> <span class=\"n\">σ</span> <span class=\"n\">i</span> <span class=\"n\">lhs</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Sat</span> <span class=\"n\">σ</span> <span class=\"n\">i</span> <span class=\"n\">rhs</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">next</span> <span class=\"n\">p</span>          <span class=\"bp\">=&gt;</span> <span class=\"n\">Sat</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">p</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">«</span><span class=\"n\">until</span><span class=\"bp\">»</span> <span class=\"n\">lhs</span> <span class=\"n\">rhs</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∃</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Sat</span> <span class=\"n\">σ</span> <span class=\"n\">j</span> <span class=\"n\">rhs</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">&lt;</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Sat</span> <span class=\"n\">σ</span> <span class=\"n\">k</span> <span class=\"n\">lhs</span><span class=\"o\">)</span>\n</code></pre></div>\n</div></div>\n<p>... but I find it tends to be nicer to work with the relations defined as an inductive type.</p>",
        "id": 388836539,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1693754497
    },
    {
        "content": "<p>I would advise you to use the definition version of your predicate here. There isn't really a way to circumvent this kind of strict positivity issue, and fixpoints generally behave better than inductive definitions in Prop (for example, you can get large-elimination out of your <code>def</code> here, but not out of the <code>inductive</code> equivalent, even if it was strictly positive)</p>",
        "id": 388840803,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1693757727
    },
    {
        "content": "<p>That's reassuring, thanks!</p>",
        "id": 388970197,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1693827465
    }
]