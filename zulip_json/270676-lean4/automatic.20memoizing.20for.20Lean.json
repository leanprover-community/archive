[
    {
        "content": "<p>Python's <code>lru_cache</code> is useful for turning simple (but slow) recursive definitions into efficient ones. Is there, or could there reasonably be, a similar tool for Lean? With Lean's powerful metaprogramming I hope so.</p>\n<p>For instance,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">stupidFib</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">stupidFib</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">stupidFib</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>ends up defined by well-founded recursion on a Nat (and all of the other arguments (i.e. none of them) are equal), so this is the simplest case to handle. Any such function could generally be re-written in a form like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">stupidFib</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">auxList</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">auxList</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">auxList</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">::</span><span class=\"n\">l</span>\n</code></pre></div>\n<p>which will take linear memory but only linear time (instead of exponential time). (Recognizing that it could be done with just O(1) memory instead of linear is nice too, but I'm thinking about the general case first, and I'd want to be able to handle things like <code>def notFib (x : ℕ) : ℕ := if x ≤ 1 then x else notFib (x-1) + notFib (x/2)</code>.)</p>\n<p>Is there anything like a 'decorator' or attribute that could be added to enable this translation automatically?</p>",
        "id": 495527677,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1737646564
    },
    {
        "content": "<p>I remember <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> experimenting with this at some point.</p>",
        "id": 495528222,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737646716
    },
    {
        "content": "<p>Amusingly, the Lean kernel auto-memoizes, so there's nothing to be done if you just care about reduction. I needed to modify your definition to use structural recursion though to get it to work for large values:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">stupidFib'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">stupidFib'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">stupidFib'</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">stupidFib'</span><span class=\"w\"> </span><span class=\"mi\">150</span>\n<span class=\"c1\">-- 9969216677189303386214405760200</span>\n</code></pre></div>",
        "id": 495528954,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737646901
    },
    {
        "content": "<p>Alright, in that sense I suppose I had a bad example. :) I'm more interested in cases like <code>notFib</code> that aren't so easily amenable to structural recursion</p>",
        "id": 495530318,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1737647237
    },
    {
        "content": "<p>Plus, the compiled code won't be memoized. I was just taking advantage of the kernel's cache here.</p>",
        "id": 495532264,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737647748
    },
    {
        "content": "<p>Here are my experiments back then, but I beware, I didn’t really  understand lean that much back then:<br>\n<a href=\"https://github.com/nomeata/lean4-memo-nat\">https://github.com/nomeata/lean4-memo-nat</a><br>\n(Demo at <a href=\"https://github.com/nomeata/lean4-memo-nat/blob/master/MemoNat/Demo.lean\">https://github.com/nomeata/lean4-memo-nat/blob/master/MemoNat/Demo.lean</a>)</p>",
        "id": 495535367,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1737648515
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> </p>\n<p>Nice!!! Why not continue development of this repository? <code>[memo]</code> attribute is so attractive...</p>",
        "id": 495718138,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1737726407
    },
    {
        "content": "<p>Hmm, not sure . No urgent need on my side? Also it only works for functions taking<code>Nat</code>and it will precompute it for every smaller parameter , not just the used ones. But yes, in principle such tools that generate <code>csimp</code>-optimizations are quite plausible</p>",
        "id": 495867312,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1737808506
    }
]