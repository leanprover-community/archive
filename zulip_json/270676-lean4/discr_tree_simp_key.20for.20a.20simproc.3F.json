[
    {
        "content": "<p>I'm trying to debug why a simproc is not being applied while a manual look at the goal state seems to suggest a match. For a regular simp-lemma I would try to either <code>rw</code> it or look at <code>#discr_tree_simp_key</code> to eliminate bad discrimination tree keys as the cause, but I wonder how I would do so for a simproc? Obviously, <code>rw</code> won't know what to do with a simproc, but even <code>#discr_tree_simp_key</code> doesn't actually show me the key for the simproc, see for (a non-minimal) example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">dsimproc</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">simp_denote</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">reduceArgsToLLVM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">argsToLLVM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tys</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">no_index</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span>\n<span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">no_index</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">no_index</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">no_index</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">no_index</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">reduceArgsToLLVMAux</span>\n\n<span class=\"bp\">#</span><span class=\"n\">discr_tree_simp_key</span><span class=\"w\"> </span><span class=\"n\">reduceArgsToLLVM</span>\n<span class=\"c\">/-</span><span class=\"cm\"> ^^ This outputs:</span>\n<span class=\"cm\">ReaderT</span>\n<span class=\"cm\">  Lean.Meta.Simp.MethodsRef</span>\n<span class=\"cm\">  (ReaderT</span>\n<span class=\"cm\">     Lean.Meta.Simp.Context</span>\n<span class=\"cm\">     (StateRefT'</span>\n<span class=\"cm\">        IO.RealWorld</span>\n<span class=\"cm\">        Lean.Meta.Simp.State</span>\n<span class=\"cm\">        (ReaderT</span>\n<span class=\"cm\">           Lean.Meta.Context</span>\n<span class=\"cm\">           (StateRefT'</span>\n<span class=\"cm\">              IO.RealWorld</span>\n<span class=\"cm\">              Lean.Meta.State</span>\n<span class=\"cm\">              (ReaderT Lean.Core.Context (StateRefT' IO.RealWorld Lean.Core.State (EIO Lean.Exception)))))))</span>\n<span class=\"cm\">  Lean.TransformStep</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>I've resorted to copying the pattern to a regular lemma, and looking at the <code>#discr_tree_simp_key</code> output of that, as in:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⟦</span><span class=\"n\">Ty</span><span class=\"bp\">.</span><span class=\"n\">arith</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">⟧</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HVector</span><span class=\"w\"> </span><span class=\"n\">toType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ty</span><span class=\"bp\">.</span><span class=\"n\">arith</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">argsToLLVM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tys</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">no_index</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span>\n<span class=\"w\">      </span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">no_index</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">no_index</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">no_index</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ty</span><span class=\"bp\">.</span><span class=\"n\">arith</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">no_index</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ty</span><span class=\"bp\">.</span><span class=\"n\">arith</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">zs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n<span class=\"bp\">#</span><span class=\"n\">discr_tree_simp_key</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n</code></pre></div>\n<p>Is there a better way to debug simproc discrimination tree keys?</p>",
        "id": 537302239,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1756824216
    },
    {
        "content": "<p>Something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"n\">DiscrTree</span><span class=\"w\"> </span><span class=\"n\">Simp</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"#discr_tree_simproc_key \"</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">simprocDeclExt</span><span class=\"bp\">.</span><span class=\"n\">getState</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"bp\">.</span><span class=\"n\">builtin</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"bp\">.</span><span class=\"n\">getId</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">keysAsPattern</span><span class=\"w\"> </span><span class=\"n\">keys</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">realizeGlobalConstNoOverloadWithInfo</span><span class=\"w\"> </span><span class=\"n\">k</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"bp\">.</span><span class=\"n\">newEntries</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">keysAsPattern</span><span class=\"w\"> </span><span class=\"n\">keys</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">throwErrorAt</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"s2\">\"not a simproc: {k}\"</span>\n\n<span class=\"bp\">#</span><span class=\"n\">discr_tree_simproc_key</span><span class=\"w\"> </span><span class=\"n\">reduceDIte</span>\n</code></pre></div>\n<p>should do the trick</p>",
        "id": 537306068,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1756825316
    },
    {
        "content": "<p>Thanks! This is specifically looking for built-in simprocs, right? </p>\n<p>For anybody else also debugging a custom simproc, the command can be tweaked like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"n\">DiscrTree</span><span class=\"w\"> </span><span class=\"n\">Simp</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"#discr_tree_simproc_key \"</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">simprocDeclExt</span><span class=\"bp\">.</span><span class=\"n\">getState</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">keys</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"bp\">.</span><span class=\"n\">newEntries</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"bp\">.</span><span class=\"n\">getId</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">keysAsPattern</span><span class=\"w\"> </span><span class=\"n\">keys</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">realizeGlobalConstNoOverloadWithInfo</span><span class=\"w\"> </span><span class=\"n\">k</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">keys</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"bp\">.</span><span class=\"n\">newEntries</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">keysAsPattern</span><span class=\"w\"> </span><span class=\"n\">keys</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">throwErrorAt</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"s2\">\"not a simproc: {k}\"</span>\n</code></pre></div>",
        "id": 537316276,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1756828134
    },
    {
        "content": "<p>Interestingly, this does not in fact give the same discr-tree key as the transcription into a theorem. Thanks, this gives me a potential lead to investigate!</p>",
        "id": 537316526,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1756828194
    }
]