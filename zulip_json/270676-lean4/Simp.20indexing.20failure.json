[
    {
        "content": "<p>The following example was minimized by <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> from code in the <code>rpow_simp</code>tactic.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bla</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">default</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">bla</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">no_index</span> <span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">bla</span> <span class=\"n\">a</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span> <span class=\"c1\">-- simp made no progress</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">bar</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">no_index</span> <span class=\"o\">(</span><span class=\"n\">bla</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">bla</span> <span class=\"n\">a</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">bar</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 401852877,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699913092
    },
    {
        "content": "<p>Basically <code>simp</code> isn't able to use this lemma until we tell it to give up on any kind of discrimination. Is this a known issue?</p>",
        "id": 401852948,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699913125
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/2867\">lean4#2867</a>?</p>",
        "id": 401855965,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699914626
    },
    {
        "content": "<p>You're missing parentheses around <code>OfNat.ofNat n</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bla</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">default</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">bla</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">no_index</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">bla</span> <span class=\"n\">a</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span> <span class=\"c1\">-- success</span>\n</code></pre></div>",
        "id": 401857726,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1699915486
    },
    {
        "content": "<p>It looks like <code>no_index</code> has no effect on the discrimination tree keys when applied to the head of a function application</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- DiscrTree keys:</span>\n\n<span class=\"c1\">-- [Eq, Nat, bla, *, OfNat.ofNat, Nat, *, *, Inhabited.default, Nat, *]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">bla</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">no_index</span> <span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"c1\">-- [Eq, Nat, bla, *, OfNat.ofNat, Nat, *, *, Inhabited.default, Nat, *]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">foo'</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">bla</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"c1\">-- [Eq, Nat, bla, *, *, Inhabited.default, Nat, *]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">foo''</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">bla</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">no_index</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"c1\">-- [Eq, Nat, bla, *, 2, Inhabited.default, Nat, *]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">foo_two</span> <span class=\"o\">:</span> <span class=\"n\">bla</span> <span class=\"n\">a</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">foo''</span><span class=\"o\">]</span>\n<span class=\"c1\">-- [Eq, Nat, *, Inhabited.default, Nat, *]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">bar</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">no_index</span> <span class=\"o\">(</span><span class=\"n\">bla</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 401858101,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1699915690
    },
    {
        "content": "<p>How do you get access to those keys?</p>",
        "id": 401860931,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699917166
    },
    {
        "content": "<p>Here is my hacky tactic to get the discr tree keys since I don't know how else to run <code>MetaM</code> (reposted from <a href=\"#narrow/stream/287929-mathlib4/topic/writing.20lemmas.20about.20.60ofNat.60/near/401857275\">\"writing lemmas about <code>ofNat</code>\"</a>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.LibrarySearch</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bla</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">default</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">bla</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">no_index</span> <span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">defnName</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"s2\">\"foo\"</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"dbg_discr_key\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">cinfo</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"bp\">←</span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"bp\">?</span> <span class=\"n\">defnName</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"bp\">!</span>\n  <span class=\"k\">let</span> <span class=\"n\">processed</span> <span class=\"bp\">←</span> <span class=\"n\">Mathlib.Tactic.LibrarySearch.processLemma</span> <span class=\"n\">defnName</span> <span class=\"n\">cinfo</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{processed}\"</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span><span class=\"kd\">by</span>\n  <span class=\"n\">dbg_discr_key</span>\n<span class=\"c1\">-- [Eq, Nat, bla, *, OfNat.ofNat, Nat, *, *, Inhabited.default, Nat, *]</span>\n  <span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 401862399,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1699918025
    },
    {
        "content": "<p>Thanks! It would be nice to have an official way of accessing this information.</p>",
        "id": 401864609,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699919262
    },
    {
        "content": "<p>Here is a simple command <code>#discr_tree_key foo</code> that prints out the key of a simp theorem.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">discrKey</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">DiscrTree.Key</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">type</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">withReducible</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">forallMetaTelescopeReducing</span> <span class=\"n\">e</span>\n  <span class=\"k\">let</span> <span class=\"n\">type</span> <span class=\"bp\">←</span> <span class=\"n\">whnfR</span> <span class=\"n\">type</span>\n  <span class=\"k\">match</span> <span class=\"n\">type.eq</span><span class=\"bp\">?</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">lhs</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">DiscrTree.mkPath</span> <span class=\"n\">lhs</span> <span class=\"n\">simpDtConfig</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"unexpected kind of 'simp' theorem{indentExpr type}\"</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"#discr_tree_key\"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">Command.liftTermElabM</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">t</span> <span class=\"n\">none</span>\n    <span class=\"n\">IO.println</span> <span class=\"o\">((</span><span class=\"bp\">←</span> <span class=\"n\">discrKey</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"k\">fun</span> <span class=\"n\">key</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">key.format</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"#discr_tree_key\"</span> <span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">Command.liftTermElabM</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">info</span> <span class=\"bp\">←</span> <span class=\"n\">getConstInfo</span> <span class=\"n\">id.getId</span>\n    <span class=\"n\">IO.println</span> <span class=\"o\">((</span><span class=\"bp\">←</span> <span class=\"n\">discrKey</span> <span class=\"n\">info.type</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"k\">fun</span> <span class=\"n\">key</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">key.format</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">bla</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">default</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">bla</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">no_index</span> <span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">foo'</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">bla</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">no_index</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n\n<span class=\"c1\">-- #[bla, *, OfNat.ofNat, Nat, *, *]</span>\n<span class=\"bp\">#</span><span class=\"n\">discr_tree_key</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">},</span> <span class=\"n\">bla</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">default</span><span class=\"o\">)</span>\n<span class=\"c1\">-- #[bla, *, OfNat.ofNat, Nat, *, *]</span>\n<span class=\"bp\">#</span><span class=\"n\">discr_tree_key</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">},</span> <span class=\"n\">bla</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">no_index</span> <span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">default</span><span class=\"o\">)</span>\n<span class=\"c1\">-- #[bla, *, *]</span>\n<span class=\"bp\">#</span><span class=\"n\">discr_tree_key</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">},</span> <span class=\"n\">bla</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">no_index</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">default</span><span class=\"o\">)</span>\n<span class=\"c1\">-- #[bla, *, OfNat.ofNat, Nat, *, *]</span>\n<span class=\"bp\">#</span><span class=\"n\">discr_tree_key</span> <span class=\"n\">foo</span>\n<span class=\"c1\">-- #[bla, *, *]</span>\n<span class=\"bp\">#</span><span class=\"n\">discr_tree_key</span> <span class=\"n\">foo'</span>\n</code></pre></div>",
        "id": 402007322,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1699974817
    },
    {
        "content": "<p>Thanks! Can you explain how the simplifier uses those arrays?</p>",
        "id": 402007722,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699974943
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"500038\">Timo Carlin-Burns</span> <a href=\"#narrow/stream/270676-lean4/topic/Simp.20indexing.20failure/near/401862399\">said</a>:</p>\n<blockquote>\n<p>Here is my hacky tactic to get the discr tree keys since I don't know how else to run <code>MetaM</code> (reposted from <a href=\"#narrow/stream/287929-mathlib4/topic/writing.20lemmas.20about.20.60ofNat.60/near/401857275\">\"writing lemmas about <code>ofNat</code>\"</a>)</p>\n</blockquote>\n<p>You can write <code>#eval show MetaM Unit from do ...</code> as in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span>\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">MetaM</span> <span class=\"n\">Unit</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"n\">Expr.const</span> <span class=\"bp\">``</span><span class=\"n\">id</span> <span class=\"o\">[</span><span class=\"n\">levelOne</span><span class=\"o\">]</span>\n  <span class=\"n\">IO.println</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">ppExpr</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">id</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Just note that the mysterious <code>show α from a</code> is just a sugar for <code>(a : α)</code> i.e. telling elaborator that <code>a</code> should have the type <code>α</code>.</p>\n<p>This way you can also eval monads <code>IO</code>, <code>TermElabM</code>, <code>CommandElabM</code> and <code>CoreM</code>.</p>",
        "id": 402008619,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1699975210
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/Simp.20indexing.20failure/near/402007722\">said</a>:</p>\n<blockquote>\n<p>Thanks! Can you explain how the simplifier uses those arrays?</p>\n</blockquote>\n<p>It would be better if someone with better understanding of <code>DiscrTree</code> explains this. This array is just an implementation detail of <code>DiscrTree</code> and plays a similar role of a key as in a hash map. Just in discriminatory trees these keys allow for some form of fast pattern matching.</p>",
        "id": 402010656,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1699975797
    },
    {
        "content": "<p>I believe it is a preorder traversal of the expression tree, with <code>*</code> replacing subterms that are supposed to be ignored by the indexing</p>",
        "id": 402024731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699979736
    },
    {
        "content": "<p>the important part is that when you see a constant name, it will only match things with that constant at the head (after reducible whnf), and when you see <code>*</code> it will match anything</p>",
        "id": 402025118,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699979853
    },
    {
        "content": "<p>This is used as a filter on matching lemmas: only lemmas which match in the discrimination tree will have unification attempted, so if you put <code>no_index</code> on the LHS head then the key is just <code>#[*]</code> which matches every expression and then simp will try to unify this lemma against every subterm, which is slow but avoids false negatives</p>",
        "id": 402025367,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699979919
    }
]