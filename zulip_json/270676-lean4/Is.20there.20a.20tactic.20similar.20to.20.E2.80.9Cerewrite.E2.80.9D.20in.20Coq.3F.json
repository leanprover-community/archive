[
    {
        "content": "<p>For theorems and lemmas with uninstantiated variables that are universally quantified, <code>rw</code> will give an error</p>\n<blockquote>\n<p>tactic 'rewrite' failed, pattern is a metavariable</p>\n</blockquote>\n<p>whereas in Coq it would go through with <code>erewrite</code>.</p>\n<p>For example , when I have a lemma that has the following type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">mult_subst_bool</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">exp.tt</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">exp.ff</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">mult_subst</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>\n<p>where <code>γ</code> is a substitution that is invariant on boolean types, and if I do <code>rw [mult_subst_bool]</code> with a goal in the form of <code>... γ exp.tt ...</code>, lean will give an error:</p>\n<blockquote>\n<p>tactic 'rewrite' failed, pattern is a metavariable</p>\n</blockquote>\n<p>It is possible to always instantiate the lemma fully and then do the rewrite, such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">mult_subst_abs</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>but allowing some temporary binding and later resolving them would be quite helpful. I am wondering if lean has anything similar to Coq's erewrite that would allow leaving holes in the goal or hypothesis.</p>",
        "id": 495803102,
        "sender_full_name": "David Deng",
        "timestamp": 1737757519
    },
    {
        "content": "<p>Do you have a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ?</p>",
        "id": 495806196,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1737759271
    },
    {
        "content": "<p>The code for the <code>rw</code> tactic uses key-matching. This means, when you are searching for the pattern <code>f a₁ a₂ ...</code> in the goal <code>g b₁ b₂ ...</code>, only test <code>f a₁ a₂ ... =?= g b₁ b₂ ...</code> if <code>f</code> is syntactically equal to <code>g</code>. Otherwise, repeat for each child of <code>g b₁ b₂ ...</code>. This is probably done for performance reasons.</p>\n<p>When you get the error</p>\n<blockquote>\n<p>tactic 'rewrite' failed, pattern is a metavariable</p>\n</blockquote>\n<p>that means the expression you are searching to replace is a metavariable <code>?a</code> (for example, from the equation <code>?a = ?a + 0</code>). This cannot be used in key-matching, since there is no information to go off of except for the type. The solution is to write in your arguments explicitly, but any proof obligations can (usually) still be delayed.</p>\n<p>If you are interested in reading more, the implementation of the rewrite tactic is at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.rewrite#doc\">docs#Lean.MVarId.rewrite</a>, and replacing <code>lhs</code> by <code>rhs</code> is done at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.kabstract#doc\">docs#Lean.Meta.kabstract</a>.</p>",
        "id": 495808017,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737760307
    },
    {
        "content": "<p>Can you maybe imitate what's done for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=map_add#doc\">docs#map_add</a>, using something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DFunLike.coe#doc\">docs#DFunLike.coe</a> as head?</p>",
        "id": 495809526,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1737761235
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/270676-lean4/topic/Is.20there.20a.20tactic.20similar.20to.20.E2.80.9Cerewrite.E2.80.9D.20in.20Coq.3F/near/495808017\">said</a>:</p>\n<blockquote>\n<p>The code for the <code>rw</code> tactic uses key-matching. This means, when you are searching for the pattern <code>f a₁ a₂ ...</code> in the goal <code>g b₁ b₂ ...</code>, only test <code>f a₁ a₂ ... =?= g b₁ b₂ ...</code> if <code>f</code> is syntactically equal to <code>g</code>. Otherwise, repeat for each child of <code>g b₁ b₂ ...</code>. This is probably done for performance reasons.</p>\n</blockquote>\n<p>Thanks for the explanation and the pointer! It kind of makes sense that for performance reason, Lean wouldn't \"attempt\" to instantiate any metavariables. And that might be a difference between Coq and Lean. But where should I go if I want to learn more about key-matching? Is this rewriting process documented somewhere that might be easier to understand than its source code?</p>",
        "id": 496008172,
        "sender_full_name": "David Deng",
        "timestamp": 1737930827
    },
    {
        "content": "<p>I learned this just by reading and modifying the source code, and I don't know anywhere else to learn more. Sorry I couldn't be of any help.</p>",
        "id": 496009004,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737931513
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/channel/270676-lean4/topic/Is.20there.20a.20tactic.20similar.20to.20.E2.80.9Cerewrite.E2.80.9D.20in.20Coq.3F/near/495806196\">said</a>:</p>\n<blockquote>\n<p>Do you have a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ?</p>\n</blockquote>\n<p>For example, it would seem intuitive to have lean match <code>¬b</code> with <code>¬ true</code> in my goal, since it is the only possible occurrence, but it seems that <code>rw</code> is not able to do that. I am just wondering if there is a more \"aggressive\" rewrite tactic, or how to accomplish something similar.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">ne_false_of_eq_true</span>\n<span class=\"c1\">-- ne_false_of_eq_true {b : Bool} : b = true → ¬b = false</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ne_false_of_eq_true</span><span class=\"o\">]</span>\n<span class=\"c1\">-- tactic 'rewrite' failed, equality or iff proof expected</span>\n</code></pre></div>",
        "id": 496011655,
        "sender_full_name": "David Deng",
        "timestamp": 1737933803
    },
    {
        "content": "<p>The issue is that <code>ne_false_of_eq_true</code> is <code>¬(b = false)</code>, not an equality. The result of a rw lemma needs to be an equality or an iff</p>",
        "id": 496012240,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737934357
    },
    {
        "content": "<p>Regarding <code>mult_subst_bool</code>, there's a deeper reason it doesn't apply, and that's that the rewrite (with metavariables) is <code>`?γ ?e ==&gt; ?e</code>, and matching <code>?γ ?e</code> requires higher-order unification. It would be asking rw to take the approximate solution <code>?γ := γ</code> rather than more exotic solutions such as <code>?γ := (fun x : Nat =&gt; γ) 22</code>.</p>\n<p>It's possible to configure things so that it would choose the approximate solution, but it's worth pointing out.</p>\n<p>This does mean that you shouldn't need to supply <code>e</code> as well. I'd expect <code> rw [@mult_subst_abs γ]</code> to suffice (or <code> rw [mult_subst_abs (γ := γ)]</code>)</p>",
        "id": 496012552,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737934652
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Is.20there.20a.20tactic.20similar.20to.20.E2.80.9Cerewrite.E2.80.9D.20in.20Coq.3F/near/496012552\">said</a>:</p>\n<blockquote>\n<p>This does mean that you shouldn't need to supply <code>e</code> as well. I'd expect <code>rw [@mult_subst_abs γ]</code> to suffice (or <code>rw [mult_subst_abs (γ := γ)]</code>)</p>\n</blockquote>\n<p>Thanks for your insightful response.</p>\n<ol>\n<li>I misread the notation in <code>ne_false_of_eq_true</code>, and that is not a good example -- let me try to figure out a better example.</li>\n<li>You are also indeed correct that the <code>e</code> is not necessary.</li>\n</ol>\n<blockquote>\n<p>It's possible to configure things so that it would choose the approximate solution, but it's worth pointing out.</p>\n</blockquote>\n<p>It sounds like a quite useful feature that Coq allows to some extent by adding lemmas to its hint database. I am wondering what is particularly challenging about higher-order unification? And is it possible to do that in Lean?</p>",
        "id": 496024546,
        "sender_full_name": "David Deng",
        "timestamp": 1737944695
    },
    {
        "content": "<p>The problem with higher-order unification is the non-uniqueness of solutions — unification tries to find <em>the</em> solution, not <em>a</em> solution (unless certain approximation modes are enabled; <code>apply</code> notably enables the approximation). If you've been exposed to <code>@[elab_as_elim]</code> yet, that's another example of Lean using an approximation for higher-order unification (it's an attribute that causes the application elaborator to process the expected type in a certain way to solve for the \"motive\" argument).</p>\n<p>I don't know the research on higher-order unification. I've been told of systems that enumerate all possible solutions and take the first that works. This is hard to predict — Lean 4 takes a conservative approach, usually opting to fail instead of doing things that are not human predictable.</p>",
        "id": 496030487,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737949066
    }
]