[
    {
        "content": "<p>In programming languages, it is common to “abort execution and return an error.”<br>\nIn many languages, including Haskell, dividing by zero causes a runtime error.<br>\nHowever, in Lean, division by zero does <strong>not</strong> cause an error (at least when using <code>Nat.div</code>).</p>\n<p>I’ve read Kevin’s excellent article on why this happens.<br>\nIt was very clear. As I understand it, the article argues that since functions in Lean are used both as programs and as proofs, it’s better to avoid partial functions.<br>\nI’ve been trying to come up with my own way to explain this idea.</p>\n<p>I thought of the following explanation:<br>\nA function that “crashes midway without returning a value” is, in the sense that it doesn’t return a value, equivalent to a function that loops forever.<br>\nTherefore, such a function should be disallowed from the perspective of soundness.<br>\nIs this explanation correct?<br>\nIf it is, would it be possible to actually demonstrate a contradiction by allowing “functions that crash midway without returning a value” using something like the <code>unsafe</code> modifier—just as we can with functions that loop forever when <code>unsafe</code> is allowed?</p>",
        "id": 548161549,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1761918565
    },
    {
        "content": "<p>not sure if I understand you correctly, but I don't think there's any soundness bug here, since <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=panic#doc\">docs#panic</a> requires the type to be inhabited</p>\n<p>and also I'm not sure if we have a common understanding of how panic works, and how proofs work, because in the alternative universe where division by zero is panic (which is bad for other reasons), it doesn't actually do anything when you're proving theorems, because when you prove theorems you don't usually evaluate the functions inside. For example, notice how the following code does not panic:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">panic</span><span class=\"w\"> </span><span class=\"s2\">\"asdf\"</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>it doesn't even panic when you unfold f! in fact it just unfolds to <code>panic</code>, saying the action is different from doing  the action</p>\n<p>so actually the only to make it panic is by eval-ing it, and the only way to do that is to do native_decide, i.e.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">panic!</span><span class=\"w\"> </span><span class=\"s2\">\"asdf\"</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">native</span>\n</code></pre></div>",
        "id": 548162959,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761918936
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> </p>\n<blockquote>\n<p>I don't think there's any soundness bug here, since <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=panic#doc\">docs#panic</a> requires the type to be inhabited</p>\n</blockquote>\n<p>Indeed, if we use Lean’s <code>panic</code> function, then it’s safe.<br>\nEven if we don’t use <code>panic</code>, since <code>Nat</code> itself is <code>Inhabited</code>, a function of type <code>Nat → Nat → Nat</code> that crashes midway would still not lead to a contradiction.</p>\n<p>I see, that makes sense to me now. Thank you.</p>",
        "id": 548166535,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1761919909
    },
    {
        "content": "<p>Lean is very close to mathematical language, and in my opinion this makes things much more clear (the following is surely not 100% accurate): in mathematics there is no such a thing as \"crashing\" or \"being undefined\", and in Lean it is the same, a function must have a value. You can use tricks to simulate crashing, like using a default value, but there must is a value. You can of course also change the domain, and this is in theory perfectly doable, but annoying in practice.</p>",
        "id": 548174231,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761921597
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"626349\">@Asei Inoue</span> note that the standard way to represent \"crashing\" is to add Option to the return type,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">div?</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"mi\">11</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">div?</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 548175483,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761921881
    },
    {
        "content": "<p>but <em>please</em> don't do it in mathlib</p>",
        "id": 548175597,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761921905
    },
    {
        "content": "<p>BTW, I think that writing a library on top of Mathlib that use <code>Option</code> or <code>Part</code>/<code>PFun</code> to provide semantics that's closer to the pen&amp;paper math would be a nice project, but I don't have time for it. E.g., this will allow us to express the semantic of \"if the RHS is defined, then the LHS is defined and is equal to RHS\" or \"both sides of an equation are defined and they're equal\" (common understanding of equations with square roots etc in high school).</p>",
        "id": 548185615,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1761924082
    },
    {
        "content": "<p>we'll need to <code>bind</code> everything in statements then? we'll end up with monads everywhere</p>",
        "id": 548185821,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761924130
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">sqrt?</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">none</span>\n\n<span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"s2\">\"√?\"</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">sqrt?</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"bp\">√?</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">√?</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 548186508,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761924322
    },
    {
        "content": "<p>the <code>&lt;</code> instance also needs to be changed</p>",
        "id": 548186697,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761924372
    },
    {
        "content": "<p>I don't know what's the best way to make it useful/readable. I think that we should convert inputs to <code>Part _</code> and stay there, but I don't want to spend my time on this. Also, this library should come with a tactic that converts the goal to a <code>Part</code>-free version that can be proved using Mathlib.</p>",
        "id": 548188080,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1761924702
    },
    {
        "content": "<p>While I think that this would be a nice project for someone relatively new to Lean (probably, under a supervision of someone more experienced), I think that almost any project aiming to formalize a nice theorem is more important.</p>",
        "id": 548198843,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1761927601
    },
    {
        "content": "<p>In particular, is Lean able to non-tautologically state the theorem \"The square root of x/(x-1) is defined on the subset (-inf, 0] union (1, +inf)\"? What would be a nice way to formalize this kind of statements?</p>",
        "id": 548264171,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1761959257
    },
    {
        "content": "<p>if you follow the above suggestion to use Option, then the statement would say that this expression is Option.IsSome</p>",
        "id": 548264226,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761959315
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"404479\">@Trebor Huang</span> </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">Part</span>\n\n<span class=\"c1\">-- TODO: the two functions below could be made computable</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simps!</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">sqrt?</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Part</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"n\">x</span><span class=\"bp\">⟩</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simps!</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">div?</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Part</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"s2\">\"√?\"</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">sqrt?</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"s2\">\" /? \"</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">div?</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"bp\">√?</span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">/?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">Dom</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">div_nonneg_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sub_eq_zero</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 548264903,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761960124
    },
    {
        "content": "<p>I love <code>grind</code></p>",
        "id": 548265077,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761960358
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/270676-lean4/topic/Lean.20does.20not.20panic.20when.20division.20by.20zero/near/548174231\">said</a>:</p>\n<blockquote>\n<p>in mathematics there is no such a thing as \"crashing\" or \"being undefined\",</p>\n</blockquote>\n<p>Where are you getting the idea that in mathematics there is no such thing as \"being undefined\"? Mathematicians use the concept of an undefined quantity literally all the time (such as when discussing division by zero or limits that don't converge).</p>",
        "id": 567243952,
        "sender_full_name": "James E Hanson",
        "timestamp": 1767985291
    },
    {
        "content": "<p>I just mean that <code>f x</code> is defined for every <code>x</code> in the domain of <code>f</code>.</p>",
        "id": 567250198,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767987517
    },
    {
        "content": "<p>I just find it strange to be justifying the fact that Lean can't handle 1/0 in a way that resembles standard mathematical practice on the basis of claiming that in mathematics there is no such thing as something \"being undefined\".</p>\n<p>It feels like equating \"mathematics\" with \"mathematics that is easily formalized in type theory\".</p>",
        "id": 567254436,
        "sender_full_name": "James E Hanson",
        "timestamp": 1767989200
    },
    {
        "content": "<p>At least, standard mathematics does not have a quantity called <code>undefined</code>; when something is undefined it is actually undefined. If <code>1 / 0</code> were to crash but we could still manipulate it in proofs, then it would essentially be an explicit <code>undefined ∈ ℕ</code> which represents a crash or diverging computation, and in standard math you can't write \"Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">x \\in \\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> be the diverging computation\".</p>",
        "id": 567272823,
        "sender_full_name": "Niels Voss",
        "timestamp": 1767998266
    },
    {
        "content": "<p>That's not really a justification for why <code>1 / 0 = 0</code> though. In my opinion the real justification is that theorem proving is not technologically advanced enough to deal with partial functions in an ergonomic way, and <code>1 / 0 = 0</code> is an acceptable trade-off.</p>",
        "id": 567273103,
        "sender_full_name": "Niels Voss",
        "timestamp": 1767998443
    },
    {
        "content": "<p>I agree with most of what you're saying. I just don't think that it's reasonable to summarize it as 'in mathematics there is no such thing as being undefined'. If you ask an average mathematician whether there's no such thing as being undefined in mathematics, they will not agree that this is an accurate statement.</p>",
        "id": 567296360,
        "sender_full_name": "James E Hanson",
        "timestamp": 1768024832
    },
    {
        "content": "<p>It simply isn't an accurate representation of the standard terminological conventions used in mainstream mathematics.</p>",
        "id": 567296482,
        "sender_full_name": "James E Hanson",
        "timestamp": 1768024938
    }
]