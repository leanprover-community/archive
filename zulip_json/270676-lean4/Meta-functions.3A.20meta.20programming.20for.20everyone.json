[
    {
        "content": "<p>I have developed a mechanism to write \"functions\" that depend on the syntactic structure of their arguments. I'm curious if others would find this useful and what additional applications could be explored.</p>\n<p>Here are a few examples:</p>\n<h3><strong>1. Finding Concrete Bounds for a Function</strong></h3>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- 224</span>\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">getNaiveBoundOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This \"function\" computes the following:<br>\n<code>|(x + 3)*(x - 4)*x| ≤ |x + 3|*|x - 4|*|x| ≤ (4 + 3)*(4 + 4)*4 = 224</code>.</p>\n<h3><strong>2. Left-Associating Elements of a Product</strong></h3>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- (1, 2, 3)</span>\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lassoc</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(),</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">))</span>\n</code></pre></div>\n<h3><strong>3. Lifting Elements of a Ring</strong></h3>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- \"((#0 * #1) + ((#0 * #0) * #1))\"</span>\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">ringToString</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This is useful as the first step in writing other tactics like <code>ring</code>, <code>module</code>, or <code>polyrith</code>, where you need to transform an element (e.g., from a ring) into a form that other tactics can process.</p>\n<h3><strong>4. Computing Derivatives</strong></h3>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- (1 * x + x * 1) * x + x * x * 1 + (0 * x + 3 * 1) + (1 * x + x * 1)</span>\n<span class=\"bp\">#</span><span class=\"n\">eval_meta_fun</span><span class=\"w\"> </span><span class=\"n\">derivAt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<hr>\n<p>All these functions evaluate so-called <em>meta-functions</em> during elaboration. For example, <code>getNaiveBoundOn</code> is defined as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">getNaiveBoundOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NaiveBoundOn</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">data_synth</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>Here, <code>NaiveBoundOn</code> is the <em>meta-function</em>, and <code>data_synth</code> is the new tactic that solves goals like <code>NaiveBoundOn f s ?n</code>, i.e., it finds <code>n</code> and demonstrates that it bounds <code>f</code> on <code>s</code>. All this is motivated by solving <code>HasFDerivAt f ?f' x</code> as I want to compute derivatives.</p>\n<p>I’ve created two new commands, <code>meta_fun_decl</code> and <code>meta_fun_def</code>, to help define these new <em>meta-functions</em>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">meta_fun_decl</span><span class=\"w\"> </span><span class=\"n\">naiveBoundOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span>\n<span class=\"n\">satisfying</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">naiveBoundOn</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This declares a \"function\" <code>NaiveBoundOn : (ℤ → ℤ) → Set ℤ → ℤ → Prop</code>. In reality, <code>NaiveBoundOn f s n</code> is just a <code>Prop</code> structure with a single field <code>∀ x ∈ s, |f x| ≤ n</code>.</p>\n<p>With <code>meta_fun_def</code>, you can define its \"values\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">meta_fun_def</span><span class=\"w\"> </span><span class=\"n\">naiveBoundOnIdentity</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">naiveBoundOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"n\">b</span><span class=\"bp\">|</span>\n<span class=\"n\">satisfied_by</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>This can be recursively \"called\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">meta_fun_def</span><span class=\"w\"> </span><span class=\"n\">naiveBoundOnAdd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">naiveBoundOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">bf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">naiveBoundOn</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">bg</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">naiveBoundOn</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">bf</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">bg</span>\n<span class=\"n\">satisfied_by</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>This definition translates to the theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">data_synth</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">naiveBoundOnAdd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NaiveBoundOn</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NaiveBoundOn</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NaiveBoundOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bf</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">bg</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>Whether you prefer writing theorems like this or using the <code>meta_fun_def</code> macro is a matter of taste.</p>\n<h3><strong>Another Example: Left Associating Product Types</strong></h3>\n<p>This <em>meta-function</em> returns a type along with an equivalence:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">meta_fun_decl</span><span class=\"w\"> </span><span class=\"n\">prodAssoc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">satisfying</span>\n<span class=\"w\">  </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">prodAssoc</span>\n</code></pre></div>\n<p>When reassociating <code>((X × Y) × Z)</code>, we call <code>prodAssoc</code> on itself:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">meta_fun_def</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">high</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">prodReassocMain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">prodAssoc</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">prodAssoc</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">prodAssoc</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">)</span>\n<span class=\"n\">satisfied_by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">XYZ'</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Equiv.prodAssoc</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span>\n<span class=\"w\">    </span><span class=\"bp\">|&gt;.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Equiv.prodCongr</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Equiv.refl</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"bp\">|&gt;.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Traditionally, this kind of function is implemented using a typeclass and a collection of instances. Similarly to instances, we can control which \"evaluation\" rule is applied using priorities.</p>\n<p>You can find more details on how other <em>meta-functions</em> are defined in this <a href=\"https://github.com/lecopivo/SciLean/blob/blas/Test/basic_meta_fun.lean\">file</a>.</p>\n<hr>\n<p><strong>Naming Help</strong>: I currently use the term <em>meta-function</em> and the tactic <code>data_synth</code>, but neither term is perfect. I could rename the tactic to <code>meta_fun_eval</code>, but \"meta-function\" already refers to a function that operates on <code>Lean.Expr</code>. Suggestions are welcome.</p>",
        "id": 507571823,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1742741265
    },
    {
        "content": "<p>I don't see how this is any different from writing meta-functions that act on <code>Lean.Expr</code>.</p>",
        "id": 507574736,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742743412
    },
    {
        "content": "<p>The point is user extensibility, imagine changing <code>simp</code>'s code each time you add a new theorem.</p>",
        "id": 507574972,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1742743576
    },
    {
        "content": "<p>I feel like that can be done the same way <code>simp</code> did it - with attributes. No need for a type class and fake function that don't respect equality.</p>",
        "id": 507575182,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742743691
    },
    {
        "content": "<p>Anything that makes it easier to build such tactics seem very useful to me.</p>",
        "id": 507575599,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1742743983
    },
    {
        "content": "<p>Side-note: the tests in that file again tell us we should really fix that <code>max</code> delaboration issue…</p>",
        "id": 507575633,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1742744012
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/270676-lean4/topic/Meta-functions.3A.20meta.20programming.20for.20everyone/near/507575182\">said</a>:</p>\n<blockquote>\n<p>I feel like that can be done the same way <code>simp</code> did it - with attributes. No need for a type class and fake function that don't respect equality.</p>\n</blockquote>\n<p>The whole thing is based on the tactic <code>data_synth</code> I wrote. You can directly write theorems like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">data_synth</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">naiveBoundOnAdd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NaiveBoundOn</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NaiveBoundOn</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NaiveBoundOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bf</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">bg</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>In a way, these theorems are defining a function on <code>Lean.Expr</code> so the <code>meta_fun_decl</code> and <code>meta_fun_def</code>make it more explicit and a lot easier to use for people not familiar writing meta level code.</p>",
        "id": 507575779,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1742744109
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/270676-lean4/topic/Meta-functions.3A.20meta.20programming.20for.20everyone/near/507575633\">said</a>:</p>\n<blockquote>\n<p>Side-note: the tests in that file again tell us we should really fix that <code>max</code> delaboration issue…</p>\n</blockquote>\n<p>Huh? What are you talking about? I'm not aware of this.</p>",
        "id": 507575880,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1742744175
    },
    {
        "content": "<p>max is being printed as <code>\\sqcup</code> in the tests</p>",
        "id": 507575903,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742744201
    },
    {
        "content": "<p>This is really creative and neat! It's not every day that you see a new (meta)programming idiom</p>",
        "id": 507575951,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742744252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/channel/270676-lean4/topic/Meta-functions.3A.20meta.20programming.20for.20everyone/near/507571823\">said</a>:</p>\n<blockquote>\n<p><strong>Naming Help</strong>: I currently use the term <em>meta-function</em> and the tactic <code>data_synth</code>, but neither term is perfect. I could rename the tactic to <code>meta_fun_eval</code>, but \"meta-function\" already refers to a function that operates on <code>Lean.Expr</code>. Suggestions are welcome.</p>\n</blockquote>\n<p>I think I would call this a (bounded) nondeterministic function instead of a meta-function</p>",
        "id": 507576107,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742744354
    },
    {
        "content": "<p>Yeah that would be more technically correct but is a bit of a mouthful.</p>",
        "id": 507577216,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1742745121
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/channel/270676-lean4/topic/Meta-functions.3A.20meta.20programming.20for.20everyone/near/507575779\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/270676-lean4/topic/Meta-functions.3A.20meta.20programming.20for.20everyone/near/507575182\">said</a>:</p>\n<blockquote>\n<p>I feel like that can be done the same way <code>simp</code> did it - with attributes. No need for a type class and fake function that don't respect equality.</p>\n</blockquote>\n<p>The whole thing is based on the tactic <code>data_synth</code> I wrote. You can directly write theorems like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">data_synth</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">naiveBoundOnAdd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NaiveBoundOn</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NaiveBoundOn</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NaiveBoundOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bf</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">bg</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>In a way, these theorems are defining a function on <code>Lean.Expr</code> so the <code>meta_fun_decl</code> and <code>meta_fun_def</code>make it more explicit and a lot easier to use for people not familiar writing meta level code.</p>\n</blockquote>\n<p>I'm still against <code>getNativeBoundOn</code> and <code>ringToString</code>, because this goes against my model of how typeclasses are meant to be used.</p>",
        "id": 507609958,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742767034
    },
    {
        "content": "<p>very nice!!!</p>",
        "id": 507624753,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1742778169
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Meta-functions.3A.20meta.20programming.20for.20everyone/near/507575951\">said</a>:</p>\n<blockquote>\n<p>It's not every day that you see a new (meta)programming idiom</p>\n</blockquote>\n<p>Isn't the \"abuse a default argument to fill a metavariable\" an old idiom? It's how we wrote <code>reassoc_of</code> and the matrix \"simprocs\" in Lean 3.</p>",
        "id": 507628025,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742780136
    }
]