[
    {
        "content": "<p>I encounter the following problem</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyNat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">My_zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">My_succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MyNat</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">MyNat</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MyNat_add</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">My_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">My_succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">My_succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MyNat_add</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MyNatAdd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AddZero</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">      </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">MyNat_add</span>\n<span class=\"w\">      </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">My_zero</span><span class=\"w\"> </span><span class=\"c1\">-- all good up to here</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MyRec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddZero</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">My_zero</span>\n<span class=\"w\">    </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">            </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">My_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">            </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">My_succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">My_succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MyRec</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"c1\">-- error, failed to show termination</span>\n</code></pre></div>\n<p>So, if I unbundle the two fields, there is no termination requirement, but if I try to bundle the two in a structure this fails; and I do not know how to provide a <code>termination_by</code> clause since there are no <code>MyNat</code> parameters to the <code>MyRec</code> structure (I tried the <code>termination_by structural n =&gt; n</code> at the end of <code>MyRec</code> but this, expectedly, fails).</p>",
        "id": 568296500,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1768505638
    },
    {
        "content": "<p>I think the issue is that in your mind you are defining addition, but technically you are defining a term of type <code>AddZero MyNat</code>, that, being a structure, is an inductive type with one constructor, and Lean is trying to do recursion on that thing somehow.</p>",
        "id": 568306695,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1768509391
    },
    {
        "content": "<p>Sure, I agree. My question is whether there is a way to make it understand that only some of the fields of this structure are functions that I'm trying to define recursively; or, better, to insert the termination clause in the construction of the corresponding field.</p>",
        "id": 568307140,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1768509501
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyNat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">My_zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">My_succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MyNat</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">MyNat</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MyNat_add</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">My_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">My_succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">My_succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MyNat_add</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MyNatAdd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AddZero</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">      </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">MyNat_add</span>\n<span class=\"w\">      </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">My_zero</span><span class=\"w\"> </span><span class=\"c1\">-- all good up to here</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MyRec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddZero</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">My_zero</span>\n<span class=\"w\">    </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">My_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">My_succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">My_succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MyNat_add</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">foo</span>\n<span class=\"w\">      </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>this works.</p>",
        "id": 568307236,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1768509525
    },
    {
        "content": "<p>Yes, that I had also tried, but you use <code>MyNat_add</code> inside <code>MyRec</code>, if you try to use <code>foo</code> you can't.</p>",
        "id": 568307421,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1768509599
    },
    {
        "content": "<p>(my whole point here is to understand the flexibility of the <code>termination_by</code> syntax, not so much to play with Addition, just in case you wonder)</p>",
        "id": 568307525,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1768509631
    },
    {
        "content": "<p>I am not sure I understand what you want, <code>MyRec</code> is not a function.</p>",
        "id": 568308181,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1768509884
    },
    {
        "content": "<p>I think Riccardo meant</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MyRec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddZero</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">My_zero</span>\n<span class=\"w\">    </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">My_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">My_succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">My_succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">foo</span>\n<span class=\"w\">      </span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 568309868,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1768510491
    },
    {
        "content": "<p>Oh sorry, of course.</p>",
        "id": 568310802,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1768510833
    },
    {
        "content": "<p>Oh great! But then I'm even more interested in understanding why this <code>let</code> call makes Lean try, and succeed, to find termination for this function <code>foo</code> whereas without the <code>let</code> this does not fire.</p>",
        "id": 568311286,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1768510991
    },
    {
        "content": "<p>Ah, it's a <code>let rec</code>, not a let!</p>",
        "id": 568311531,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1768511073
    },
    {
        "content": "<p>So my question becomes whether this behaviour is related to mutual inductive types as described in 4.4.5 of the reference manual or it is unrelated.</p>",
        "id": 568314312,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1768512389
    },
    {
        "content": "<p>If you want to define something recursively, you need to give it a name. That's the only syntax available. A field projection is not a name.</p>",
        "id": 568316681,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1768513495
    },
    {
        "content": "<p><code>MyRec.add</code> means you're calling <code>MyRec</code> recursively and then you take the field <code>.add</code> of <code>MyRec</code>. You can't show that this recursive call to <code>MyRec</code> terminates, because <code>MyRec</code> doesn't even have any arguments.</p>",
        "id": 568419491,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768565368
    },
    {
        "content": "<p>But being able to define recursive functions as fields of structures would be nice feature. Every time I have to do this I'm forced to define such functions as a separate definition (let rec is a bit ugly). Would be nice if that worked:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MyRec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddZero</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">My_zero</span>\n<span class=\"w\">  </span><span class=\"n\">add</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">My_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">My_succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">My_succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 568420283,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768565656
    },
    {
        "content": "<p>Yes, this is what I had in mind, but I'd like to understand <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> 's answer better: when you say that \"a field projection is not a name\", I'm  not sure to understand in which sense something \"is\" or \"is not\" a name. I though that the fact that in</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>\n<p>I can check that <code>Foo.a : Foo -&gt; Nat</code> meant that <code>Foo.a</code> exists as well-typed and well-named term (of the relative function type).</p>",
        "id": 568454023,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1768575530
    },
    {
        "content": "<p>What you tried to do recursion on was <code>MyRec.add</code>, which looks like a name but is actually a function application. So you need to extract and name this part separately to use recursion.</p>",
        "id": 568460182,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1768577150
    },
    {
        "content": "<p>Are you using \"name\" as in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Lean.Name\">Lean.Name</a> and \"function application\" as in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.Expr\">Lean.Expr</a>?</p>",
        "id": 568461203,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1768577408
    }
]