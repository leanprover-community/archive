[
    {
        "content": "<p>Hey folks. I was wondering if a contribution for supporting Ninja as the generator would be accepted. Currently, only the Unix Makefiles generator is supported. (Related question: I noticed files under <code>stage0/</code> being marked as auto-generated, and they largely seem to be the same as the files under <code>src/</code> -- how do I trigger that generation?)</p>",
        "id": 262407547,
        "sender_full_name": "Varun Gandhi",
        "timestamp": 1637636783
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459441\">@Varun Gandhi</span> The Lean devs are very pragmatic, so an additional generator is only likely to be accepted if the benefit of adding it outweighs the burden of code review and build breakage and maintenance. What would the benefit of Ninja be? Note that Lean already builds on all supported platforms (with MinGW on Windows).</p>\n<p>For updating <code>stage0/</code>, you can use <code>scripts/update-stage0</code>. Lean 4 is a self-compiling compiler, and the <code>stage0/</code> files serve to <a href=\"https://en.wikipedia.org/wiki/Bootstrapping_(compilers)\">bootstrap</a> it.</p>",
        "id": 262408615,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1637638132
    },
    {
        "content": "<p>The benefits of Ninja are (1) faster incremental builds, especially when working on leaf-y files, (2) <code>ninjatracing</code> (<a href=\"https://github.com/nico/ninjatracing\">https://github.com/nico/ninjatracing</a>) to profile builds and (3) built-in functionality to query targets via different subtools.</p>\n<p>As an example, I did some preliminary measurements with Clang (files recompiled/total files), since that is a project I'm familiar with:</p>\n<ul>\n<li>When changing a leafy file (e.g. 20/4300): 3.7s (Ninja) vs 7.0s (Make) -- To me, this is the most compelling point.</li>\n<li>When changing a file much deeper (600/4300), or doing a full build (4300/4300): They're about the same with Ninja being 1~2% faster. This is not a big deal IMO: the key bit is Ninja is not slower.<br>\nWhen I worked on Swiftc, we did not support make at all, because ninja is ~better along nearly all dimensions, with the incremental builds being the biggest win.</li>\n</ul>\n<p>That said, I haven't actually implemented the change for Lean (I wanted to ask first), so I don't know how much the incremental build benefits will carry over.</p>\n<p>Thanks for the pointer in the code.</p>",
        "id": 262415891,
        "sender_full_name": "Varun Gandhi",
        "timestamp": 1637646627
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459441\">@Varun Gandhi</span> the problem with this idea  is that primary bottleneck for the Lean dev build is not the CMake build but the rather the bootstrap Lean build which would be unaffected by the change in the CMake generator.</p>",
        "id": 262418821,
        "sender_full_name": "Mac",
        "timestamp": 1637650335
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span>   : Just to make sure I'm correctly understanding what you're saying, the slow part of incremental builds is due to <code>src/lean.mk.in</code>, is that right?</p>",
        "id": 262538726,
        "sender_full_name": "Varun Gandhi",
        "timestamp": 1637719372
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459441\">@Varun Gandhi</span> yes, though it is more due to the inefficiency of Lean builds (due to transitive import dependencies) than the Makefile / make itself</p>",
        "id": 262548954,
        "sender_full_name": "Mac",
        "timestamp": 1637733126
    }
]