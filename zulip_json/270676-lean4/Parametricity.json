[
    {
        "content": "<p>Parametricity has been discussed here on-and-off (<a href=\"#narrow/stream/113488-general/topic/Fighting.20with.20type.20universing/near/325367916\">here</a> or <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Parametricity.20and.20Lean.204.3F/near/287482021\">here</a>) , and I read hat parametricity is false in the presence of <code>classical.choice</code>.</p>\n<p>But if I have a concrete definition and check that it does not depend on that axiom (or other axioms), can I then reason by parametricity? Is every axiom-free lean definition <code>f : (Î± : Type) â†’ Î± â†’ Î±</code> equal to the identity?</p>",
        "id": 451748466,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1721133196
    },
    {
        "content": "<p>Canâ€™t you check if the type is <code>Bool</code> and do not if so? Ah, I guess that requires choice?</p>",
        "id": 451749463,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1721133565
    },
    {
        "content": "<p>Isnâ€™t that precisely the thing that needs classical choice?</p>",
        "id": 451749527,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1721133593
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/Parametricity/near/451748466\">said</a>:</p>\n<blockquote>\n<p>Parametricity has been discussed here on-and-off (<a href=\"#narrow/stream/113488-general/topic/Fighting.20with.20type.20universing/near/325367916\">here</a> or <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Parametricity.20and.20Lean.204.3F/near/287482021\">here</a>) , and I read hat parametricity is false in the presence of <code>classical.choice</code>.</p>\n<p>But if I have a concrete definition and check that it does not depend on that axiom (or other axioms), can I then reason by parametricity? Is every axiom-free lean definition <code>f : (Î± : Type) â†’ Î± â†’ Î±</code> equal to the identity?</p>\n</blockquote>\n<p>One issue with this approach is that such a restricted parametricity lemma cannot be stated internally (since 'depends on this or that axiom' is not expressible in the type theory). But maybe you could have a metaprogram that generates proofs of equal-to-identity for _specific_ terms of type <code>(Î± : Type) â†’ Î± â†’ Î±</code> by inspecting the term (this should always succeed assuming that parametricity does hold for the axiom-free fragment of Lean, a statement that I don't know to be true or false).</p>",
        "id": 451753448,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1721134917
    },
    {
        "content": "<p>My thoughts keep coming back to this. Having parametricity theorems for (axiom-free) definition could be a very convenient proof tool! So I understand that parametricity does not hold internally, and could not hold externally for definitions using choice.</p>\n<p>But for everything else, how plausible would it be to have a tactic or command that derives the â€œfree theoremâ€ when possible? Did anyone work on this before?</p>\n<p>And is there prior part in other systems to check out? Superficial searching found <a href=\"https://github.com/coq-community/paramcoq\">https://github.com/coq-community/paramcoq</a>.</p>",
        "id": 486518475,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733492684
    },
    {
        "content": "<p>I'm not certain of the usefulness of generating \"free theorems\" for axiom-free terms, knowing how much <code>Quot.sound</code>, <code>propext</code> and <code>Classical.choice</code> are propagated in Lean in practice. However, Lean could very certainly benefit from implementing <a href=\"https://hal.science/hal-04177913v5/document\">Trocq's parametricity translation</a>, and from using it to do proof-transfer IMO.</p>",
        "id": 486537609,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733498632
    },
    {
        "content": "<p>I'm supervising an MSc project on porting Trocq to Lean.</p>",
        "id": 486537895,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1733498719
    },
    {
        "content": "<p>Nice!</p>",
        "id": 486538444,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733498894
    },
    {
        "content": "<p>But from skimming that reference, transfer seems to be a less powerful gadget than parametricity results.</p>\n<p>Consider, as an application, that I have a  monad were some property <code>P</code> holds for <code>bind a f</code> if it holds for <code>a</code> and for all <code>f x</code>. Now it is â€obviousâ€ that similar statements can be shown for all kinds of monad combinators, like <code>mapM</code> etc, and it seems that parametricity is a tool to get these statements. Is that too optimistic?</p>",
        "id": 486538893,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733499045
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110193\">@Cyril Cohen</span> I see you are one of the authors of <a href=\"https://github.com/coq-community/paramcoq\">https://github.com/coq-community/paramcoq</a>. What is your take here?</p>\n<p>Also, from reading the paper <a href=\"https://hal.archives-ouvertes.fr/hal-00730913/\">Parametricity in an Impredicative Sort</a> it seems that you had to introduce a variant of the CIC logic (in the theory, not the plugin) because of the cumulative universes. Does that mean that parametricity is actually easier in Lean than in Coq?</p>",
        "id": 486550276,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733502306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/270676-lean4/topic/Parametricity/near/486550276\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110193\">Cyril Cohen</span> I see you are one of the authors of <a href=\"https://github.com/coq-community/paramcoq\">https://github.com/coq-community/paramcoq</a>. What is your take here?</p>\n<p>Also, from reading the paper <a href=\"https://hal.archives-ouvertes.fr/hal-00730913/\">Parametricity in an Impredicative Sort</a> it seems that you had to introduce a variant of the CIC logic (in the theory, not the plugin) because of the cumulative universes. Does that mean that parametricity is actually easier in Lean than in Coq?</p>\n</blockquote>\n<p>I merely ported some pieces of code once, but I'm a co-author of Trocq.<br>\nTrocq is a generalisation of paramcoq, you get way more powerful results out of it.</p>",
        "id": 486565460,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1733506964
    },
    {
        "content": "<p>Also, I tried to write a parametricity plugin for Lean3, and go stuck because of missing bits of API, I guess this wouldn't happen today in Lean4</p>",
        "id": 486565695,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1733507051
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"432410\">Arthur Adjedj</span> <a href=\"#narrow/channel/270676-lean4/topic/Parametricity/near/486537609\">said</a>:</p>\n<blockquote>\n<p>I'm not certain of the usefulness of generating \"free theorems\" for axiom-free terms, knowing how much <code>Quot.sound</code>, <code>propext</code> and <code>Classical.choice</code> are propagated in Lean in practice. However, Lean could very certainly benefit from implementing <a href=\"https://hal.science/hal-04177913v5/document\">Trocq's parametricity translation</a>, and from using it to do proof-transfer IMO.</p>\n</blockquote>\n<p>Quot.sound and propext should behave well, not choice indeed, but problems arise only when statements rely on them.</p>",
        "id": 486566037,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1733507154
    },
    {
        "content": "<p>Also, for application of parametricity techniques to get free theorems, you can take a look at <a href=\"https://inria.hal.science/hal-01113453/document\">https://inria.hal.science/hal-01113453/document</a>, there <a href=\"https://inria.hal.science/hal-00734505/document\">https://inria.hal.science/hal-00734505/document</a> with some Coq code here <a href=\"https://github.com/coq-community/coqeal/\">https://github.com/coq-community/coqeal/</a>.</p>\n<p>There is another kind of application in <a href=\"https://pastel.hal.science/pastel-00649586v1/document\">https://pastel.hal.science/pastel-00649586v1/document</a> Section 3.4.</p>",
        "id": 486566945,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1733507498
    },
    {
        "content": "<p>Thanks for the context, and in particular pointing out that Trcoq is more general. In that case I'll just wait for Johann's student to port it to lean and come back here then :-)</p>",
        "id": 486601605,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733522652
    }
]