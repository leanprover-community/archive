[
    {
        "content": "<p>In Lean 3 we had a feature to pretty print function applications <code>f x</code> using the <code>x.f</code> field notation (\"dot notation\"), not just structure projections. When <code>pp.generalizedFieldNotation</code> was set to <code>true</code>, then it would try to use field notation unless the function was marked with the <code>@[pp_nodot]</code> attribute.</p>\n<p>What the feature did was check that the first explicit argument to the function could be used for field notation, and it did so with a relatively strict check (that the actual type of the first argument matched the namespace of the function, rather than with any unfolding).</p>\n<p>While the feature was well-appreciated, it could be rather over-eager. Mathlib3 was full of <code>@[pp_nodot]</code> declarations turning it off for things like <code>Real.sin</code>, to prevent seeing <code>x.sin</code> for example. It also leads to terms like <code>2.succ</code> rather than <code>Nat.succ 2</code> and <code>2.add</code> rather than <code>Nat.add 2</code>.</p>\n<p>I'm wondering: What would be a relatively conservative heuristic that would instead let many definitions that we want to see using field notation automatically use field notation? one that would take relatively few <code>@[pp_nodot]</code>s or <code>@[pp_dot]</code>s to correct?</p>",
        "id": 425856054,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710145322
    },
    {
        "content": "<p>These were some rough ideas I had for heuristics for what would use field notation by default:</p>\n<ul>\n<li>Require that the first explicit argument be usable for field notation again. This is more restrictive than necessary, since Lean 4 allows implicit arguments to be used for field notation too, but it seems confusing to have implicit arguments unexpectedly pretty print.</li>\n<li>Require that the function be a definition or theorem, rather than an inductive type, a constructor, a recursor, etc. That excludes <code>2.succ</code> for example.</li>\n<li>Require that the application be fully applied, for some notion of \"fully applied\", to prevent oddities like <code>2.add</code></li>\n<li>(Maybe) Require that there be more than one explicit argument. That excludes cases like <code>x.sin</code>, but it also excludes many reasonable other case, where the definition is meant to be like a projection.</li>\n<li>(Maybe) Require that the type be a structure rather than any other kind of inductive type.</li>\n</ul>\n<p>Are there any other ideas for restrictions?</p>",
        "id": 425858275,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710145885
    },
    {
        "content": "<p>Or, are we happy enough with needing to add <code>@[pp_dot]</code>?</p>",
        "id": 425858320,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710145905
    },
    {
        "content": "<p>I have an unpolished branch that's gotten the delaborator into a state where \"what is the heuristic, if any?\" is the remaining question. Well, that and whether <code>@[pp_dot]</code> should be part of the interface.</p>\n<p>This might take an RFC, so the discussion here is to begin collecting thoughts about the pretty printer making use of dot notation.</p>",
        "id": 425859057,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710146196
    },
    {
        "content": "<p>The type having an <code>OfNat</code> instance seems like it would exclude some of the unwanted situations as well: I rarely would want to write <code>2.something</code> (except possibly for <code>succ</code>, but I see that you already excluded that! <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> )</p>",
        "id": 425873411,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710151133
    },
    {
        "content": "<p>it's not about the type having an OfNat instance, it's about the value itself being a numeric literal</p>",
        "id": 425876206,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710152159
    },
    {
        "content": "<p>I don't like the rules based on whether it is a constructor or not or whether the type is an inductive or not. Ideally this should not make a difference, and it makes things annoying when you have a function wrapping a constructor and it doesn't behave like the constructor in some obscure way even though the type is exactly the same</p>",
        "id": 425876922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710152427
    },
    {
        "content": "<p>I don't think you will find a heuristic that doesn't think <code>x.sin</code> is a good idea. Or rather, I think you should set up the heuristic to make it so and make <code>sin x</code> an exception, because this is a math style thing</p>",
        "id": 425877551,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710152697
    },
    {
        "content": "<p>I really don’t mind having to put <code>@[pp_nodot]</code>. I think that using dot notation is a better default behavior than not using it.</p>",
        "id": 425929970,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1710169669
    },
    {
        "content": "<p>Personally I find <code>x.sin</code> better than <code>Real.sin x</code>, but I know this is an unpopular opinion.</p>",
        "id": 425930555,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1710169805
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/.60pp.2EgeneralizedFieldNotation.60/near/425856054\">said</a>:</p>\n<blockquote>\n<p>It also leads to terms like <code>2.succ</code> rather than <code>Nat.succ 2</code></p>\n</blockquote>\n<p>Is this bad? A lot of theorems in core (and even ones in Std and Mathlib)  use dot notation for <code>Nat.succ</code>. Thus, I can't imagine it using dot notation would be a significant problem (if anything, it might be desirable).</p>",
        "id": 426002640,
        "sender_full_name": "Mac Malone",
        "timestamp": 1710188717
    },
    {
        "content": "<p>At least <code>2.succ</code> is bad since it parses as <code>2.</code> the float and then tries parsing <code>succ</code> as an identifier!</p>\n<p>We could make it so OfNat and raw nat literals don't use dot notation when pretty printed.</p>",
        "id": 426002837,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710188788
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/.60pp.2EgeneralizedFieldNotation.60/near/426002837\">said</a>:</p>\n<blockquote>\n<p>At least <code>2.succ</code> is bad since it parses as <code>2.</code> the float and then tries parsing <code>succ</code> as an identifier!</p>\n</blockquote>\n<p>Couldn't we disambiguate that in the parser (i.e., parse <code>2.succ</code> as <code>2</code> and <code>.succ</code> instead)? I know the current behavior has tripped be up before at least.</p>",
        "id": 426003159,
        "sender_full_name": "Mac Malone",
        "timestamp": 1710188909
    },
    {
        "content": "<p>(i.e., that behavior strikes me as a parser bug, I can't imagine anyone who writes <code>2.something</code> wants it to be parsed the way it currently is.)</p>",
        "id": 426003586,
        "sender_full_name": "Mac Malone",
        "timestamp": 1710189051
    },
    {
        "content": "<p>Still, suppose you see <code>4.sqrt</code>: is this referring to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.sqrt#doc\">docs#Nat.sqrt</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Real.sqrt#doc\">docs#Real.sqrt</a> ?</p>",
        "id": 426014631,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710193852
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> True, that is a point of confusion, but one that is already inherit to dot notation and Lean more generally. The same applies to e.g. <code>1/2</code> and <code>(2).something</code></p>",
        "id": 426016136,
        "sender_full_name": "Mac Malone",
        "timestamp": 1710194544
    },
    {
        "content": "<p>It seems like the underlying idea the heuristic should be trying to implement is that this sort of notation should occur any time a function or property makes more sense on a specific instance of a class, rather than being part of the class itself; from an object-oriented perspective we might call the former 'instance methods' and the latter 'static methods'.</p>\n<p>In that case, it seems like we could derive this information from a class/type definition as follows:</p>\n<ul>\n<li>Register the class's data fields in a way that makes it accessible to the parser and pretty-printer. (I believe this already happens, since the parser needs to know e.g. what things are allowed to be <code>Prop</code> and what projections <code>initialize_simps_projections</code> should provide.)</li>\n<li>If a method references a class's data fields, mark it as <code>@[pp_dot_by_default]</code></li>\n<li>The attribute <code>@[pp_dot_by_default]</code> is contagious: a method that references a <code>[pp_dot_by_default]</code> function is also <code>@[pp_dot_by_default]</code></li>\n<li>Override by a manual <code>@[pp_dot]</code>/<code>@[pp_nodot]</code> if provided, and reserve those attributes for manual use by the user.<br>\n    * <code>@[pp_dot]</code> also implies <code>@[pp_dot_by_default]</code>  on calling methods<br>\n    * A method that only references data fields through <code>@[pp_nodot]</code> methods is not <code>@[pp_dot_by_default]</code></li>\n</ul>",
        "id": 426217735,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710279949
    },
    {
        "content": "<p>I would also suggest that the reason <code>2.succ</code> feels weird is intuition from other languages, where <code>2</code> is an atomic literal and not a module, namespace, or object and so cannot have methods. (Though Python will let you write e.g. <code>\"\".split()</code>, so...)</p>",
        "id": 426218158,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710280141
    },
    {
        "content": "<p>Generalized field notation is now the default setting as of <a href=\"https://github.com/leanprover/lean4/pull/3744\">lean4#3744</a></p>\n<p>For this first version, here is how it works:</p>\n<ul>\n<li>The <code>pp.fieldNotation.generalized</code> option can turn it off.</li>\n<li>It looks for function applications where the argument that could be used for field notation is the first explicit argument.</li>\n<li>It turns itself off if the object of the field notation is a numeric literal, at least until we decide to fix the parser.</li>\n<li>It turns itself off if the function has an argument named <code>motive</code>. This is a bit of a hack, but it keeps functions that either are recursors or want to be recursors from using field notation, since it tends to cause elaboration issues. We could have something more sophisticated, but this seemed like a fine first approximation.</li>\n<li>It also turns itself off if the declaration has <code>@[pp_nodot]</code>.</li>\n</ul>\n<p>Other than that, there are no heuristics.</p>",
        "id": 428439091,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711164528
    },
    {
        "content": "<p>It can be a bit weird, for example <code>Nat.add_comm m n</code> pretty prints as <code>m.add_comm n</code>. This could have a negative impact on <code>exact?</code> and friends. Perhaps terms that are proofs shouldn't use it either?</p>",
        "id": 428439092,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711164530
    },
    {
        "content": "<p>Do we really pretty-print <code>Nat.add_comm m n</code> all that much?</p>",
        "id": 429061107,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711181520
    },
    {
        "content": "<p>We pretty print proofs frequently because of tactics like <code>exact?</code> and <code>apply?</code></p>",
        "id": 429061298,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711181755
    },
    {
        "content": "<p>I still don't use those tactics all that much <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span></p>",
        "id": 429061448,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711181900
    },
    {
        "content": "<p>I think it's pretty handy to have dot notation appear in proofs for things like <code>Continuity</code></p>",
        "id": 429072912,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711193343
    },
    {
        "content": "<p>For now, it pretty prints proofs without dot notation, but if there's demand we could add a <code>@[pp_dot]</code> attribute to override the default behavior.</p>",
        "id": 429114358,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711226968
    },
    {
        "content": "<p>Maybe the heuristic is \"Use dot notation on <a href=\"http://Foo.bar\">Foo.bar</a> in proofs only if Foo is a Proposition\"?</p>",
        "id": 429221290,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711295147
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/.60pp.2EgeneralizedFieldNotation.60/near/428439092\">said</a>:</p>\n<blockquote>\n<p>It can be a bit weird, for example <code>Nat.add_comm m n</code> pretty prints as <code>m.add_comm n</code>. This could have a negative impact on <code>exact?</code> and friends. Perhaps terms that are proofs shouldn't use it either?</p>\n</blockquote>\n<p>I don't see why this is undesirable, this is how I would write this (well, assuming I didn't have mathlib's <code>add_comm</code> at hand)</p>",
        "id": 429222974,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1711296395
    },
    {
        "content": "<p>Field notation has a larger probability of failing to elaborate, and I'd rather avoid breaking tactics like <code>exact?</code> over making the occasional proof that actually pretty prints in the infoview look nicer (<code>pp.proofs</code> is false by default, so you generally don't see them anyway).</p>\n<p>It's an artificial example, but consider <code>fun m n =&gt; n.add_comm m</code>.</p>",
        "id": 429237888,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711307349
    },
    {
        "content": "<p>Please be on the lookout for examples that you would want to pretty print differently once this feature lands in the next release. It'd be good to rely on concrete examples to motivate further refinements.</p>",
        "id": 429238163,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711307609
    },
    {
        "content": "<p>Has pp.analyze already been considered for library search tactics' output?</p>",
        "id": 429244766,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1711312483
    },
    {
        "content": "<p>I was wondering that too. At least for proofs, I saw some examples of <code>pp.analyze</code> not adding binder types for functions. At least, there's a bug right now in the interaction between dot notation and function binders. In <code>fun m n =&gt; n.add_comm m</code>, the function thinks the types of <code>n</code> and <code>m</code> are accounted for from <code>Nat.add_comm</code>, but <code>Nat.add_comm</code> thinks that the type of <code>n</code> is accounted for from the binders (that's my understanding so far).</p>\n<p>This interaction was part of the motivation for disabling field notation for recursors, since the <code>motive</code> sometimes would use dot notation and yet have a <code>fun</code> without binder types.</p>",
        "id": 429246277,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711313268
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.ProjectionNotation</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n  <span class=\"n\">_a</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">B</span> <span class=\"n\">where</span>\n  <span class=\"n\">_b</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">C</span> <span class=\"n\">where</span>\n  <span class=\"n\">_c</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span>\n\n<span class=\"c1\">--@[pp_dot]</span>\n<span class=\"kd\">def</span> <span class=\"n\">A.toB</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">--@[pp_dot]</span>\n<span class=\"kd\">def</span> <span class=\"n\">B.toC</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x.toB.toC</span> <span class=\"bp\">=</span> <span class=\"n\">x.toB.toC</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- used to show `x.toC = x.toC` with the old `pp_dot`</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I guess the issue<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/issues/11252\">https://github.com/leanprover-community/mathlib4/issues/11252</a><br>\nhas been solved!</p>\n<p>Can I close it now?</p>",
        "id": 438791498,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715776458
    },
    {
        "content": "<p>However, it does not work here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Funktion</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Function.toFunktion</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Funktion</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f.toFunktion</span> <span class=\"bp\">=</span> <span class=\"n\">f.toFunktion</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>What did I do wrong?</p>",
        "id": 438792691,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715776858
    },
    {
        "content": "<p>Note that this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.ProjectionNotation</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Funktion</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">pp_dot</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Function.toFunktion</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Funktion</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f.toFunktion</span> <span class=\"bp\">=</span> <span class=\"n\">f.toFunktion</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Unfortunately, keeping it in my code results in the generic warning:</p>\n<p>\"The @[pp_dot] attribute is deprecated now that dot notation is the default with the introduction of <code>pp.fieldNotation.generalized</code> in Lean v4.8.0.\"</p>",
        "id": 438793189,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715777034
    },
    {
        "content": "<p>How can I suppress the warning for this particular <code>@[pp_dot]</code> (not for the whole project) please?</p>",
        "id": 438797302,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715778327
    },
    {
        "content": "<p>I can't test, but the deprecation of <code>pp_dot</code> preempts a change that should come in 4.8.0rc2</p>",
        "id": 438815784,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1715783181
    },
    {
        "content": "<p>So it is not yet current, but might be so soon.</p>",
        "id": 438815885,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1715783206
    },
    {
        "content": "<p>This means that you should get the new behaviour with the deprecation for a few days and in a few days, you can remove the deprecated attribute and the pp behaviour should be what you want.  Hopefully!</p>",
        "id": 438816451,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1715783342
    },
    {
        "content": "<p>I guess I should wait a few days before I release a stable version of my project.</p>",
        "id": 438816750,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715783407
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/270676-lean4/topic/.60pp.2EgeneralizedFieldNotation.60/near/438792691\">said</a>:</p>\n<blockquote>\n<p>However, it does not work here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Funktion</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Function.toFunktion</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Funktion</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f.toFunktion</span> <span class=\"bp\">=</span> <span class=\"n\">f.toFunktion</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>What did I do wrong?</p>\n</blockquote>\n<p>You think the above code will show <code>f.toFunktion = f.toFunktion</code> in the Infoview once we upgrade to <code>4.8.0rc2</code> ?</p>",
        "id": 438817236,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715783524
    },
    {
        "content": "<p>No need to guess: You can try!</p>",
        "id": 438817423,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715783562
    },
    {
        "content": "<p>Should I compile <code>master</code> from <a href=\"https://github.com/leanprover/lean4\">https://github.com/leanprover/lean4</a> and test locally?</p>",
        "id": 438817760,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715783633
    },
    {
        "content": "<p>No, you can use branch <code>nightly-testing</code> of mathlib</p>",
        "id": 438818280,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715783753
    },
    {
        "content": "<p>Please don't commit, though!</p>",
        "id": 438818365,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715783767
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/270676-lean4/topic/.60pp.2EgeneralizedFieldNotation.60/near/438815784\">said</a>:</p>\n<blockquote>\n<p>I can't test, but the deprecation of <code>pp_dot</code> preempts a change that should come in 4.8.0rc2</p>\n</blockquote>\n<p>Sorry to say that there are no changes in rc2 that will help Martin. The issue that rc2 will fix with dot notation is just that dot notation would inhibit other notations.</p>",
        "id": 438819568,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715784046
    },
    {
        "content": "<p>I am confused. Is it a bug or a feature that <code>Function.something</code> does not trigger the dot notation automatically?</p>",
        "id": 438819944,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715784138
    },
    {
        "content": "<p>The deprecation of <code>pp_dot</code> is simply that rc1 introduced pretty printing with generalized field notation, so there's no use in having it anymore.</p>",
        "id": 438820105,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715784165
    },
    {
        "content": "<p>You <em>might</em> be able to select this on the online server?</p>",
        "id": 438820570,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1715784281
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/270676-lean4/topic/.60pp.2EgeneralizedFieldNotation.60/near/438820570\">said</a>:</p>\n<blockquote>\n<p>You <em>might</em> be able to select this on the online server?</p>\n</blockquote>\n<p>This message was delayed by my internet connection: I posted it before Kyle's comment.</p>",
        "id": 438820819,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1715784346
    },
    {
        "content": "<p><code>pp.fieldNotation.generalized</code> doesn't (yet?) support the Function namespace since dot notation support for functions has always been a bit limited.</p>\n<p>If you want this to work, I suggest you write your own app unexpander for the situation.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Funktion</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Function.toFunktion</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Funktion</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">app_unexpander</span> <span class=\"n\">Function.toFunktion</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Function.toFunktion.unexpand</span> <span class=\"o\">:</span> <span class=\"n\">Lean.PrettyPrinter.Unexpander</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">_</span> <span class=\"bp\">$</span><span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.$</span><span class=\"o\">(</span><span class=\"n\">Lean.mkIdent</span> <span class=\"bp\">`</span><span class=\"n\">toFunktion</span><span class=\"o\">))</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">()</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f.toFunktion</span> <span class=\"bp\">=</span> <span class=\"n\">f.toFunktion</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- ⊢ f.toFunktion = f.toFunktion</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 438821026,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715784399
    },
    {
        "content": "<p>Why is <code>@[pp_dot]</code> worse than having my own unexpander? I have done something similar before, but it was for cases where <code>@[pp_dot]</code>didn't apply.</p>",
        "id": 438821286,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715784478
    },
    {
        "content": "<p>Having <code>pp_dot</code> around invites people to use it, and it now only has limited utility, probably only for definitions on the <code>Function</code> namespace. Plus, there were a nontrivial number of cases of it being misapplied</p>\n<p>If I didn't deprecate it, I'd have to go through mathlib periodically and delete all uses of it until people forgot about it.</p>\n<p>You may copy the <code>pp_dot</code> code into your own project and delete the warning if you find it valuable.</p>",
        "id": 438822066,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715784682
    },
    {
        "content": "<p>Thanks for explanation! I will add the <code>unexpander</code> you wrote.</p>",
        "id": 438822290,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715784745
    }
]