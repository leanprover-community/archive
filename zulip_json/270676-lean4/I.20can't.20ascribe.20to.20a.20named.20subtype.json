[
    {
        "content": "<p>In this MWE, I gave the subtype <code>{n : ℕ // n % 2 == 0}</code> the name <code>NatEven</code>. I can create a member of this type inline, by writing <code>(⟨4, by decide⟩ : NatEven)</code>, but when I print out its type, Lean displays <code>{n : ℕ // n % 2 == 0}</code> instead of <code>NatEven</code>. Is this only graphical, and the term really does have type <code>NatEven</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NatEven</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- The following term does not have type NatEven</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatEven</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 564776893,
        "sender_full_name": "C7X",
        "timestamp": 1766179124
    },
    {
        "content": "<p>no, this is just how it works</p>",
        "id": 564777110,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766179259
    },
    {
        "content": "<p>a type ascription does not mark the term as having that type</p>",
        "id": 564777134,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766179275
    },
    {
        "content": "<p>so inferring the type could give you something different (but still defeq)</p>",
        "id": 564777186,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766179311
    },
    {
        "content": "<p>use <code>show NatEven from ...</code> to get it to have type <code>NatEven</code>.</p>",
        "id": 564777251,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1766179335
    },
    {
        "content": "<p>Thanks! One more question, is <code>{n : ℕ // n % 2 == 0}</code> definitionally equal to <code>NatEven</code>?</p>",
        "id": 564777437,
        "sender_full_name": "C7X",
        "timestamp": 1766179459
    },
    {
        "content": "<p>yes, it is</p>",
        "id": 564777610,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766179559
    },
    {
        "content": "<p>definitions are (usually) defeq to their contents</p>",
        "id": 564777648,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766179579
    },
    {
        "content": "<p>exceptions for example when you use well-founded recursion</p>",
        "id": 564777709,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766179614
    },
    {
        "content": "<p>Usually we would write <code>n % 2 = 0</code> here I guess</p>",
        "id": 564796618,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1766197618
    }
]