[
    {
        "content": "<p>I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sum.bnot_isLeft#doc\">docs#Sum.bnot_isLeft</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sum.bnot_isRight#doc\">docs#Sum.bnot_isRight</a> are badly-formed. It looks to me that there's a coercion going wrong somewhere - I think instead of <code>!x.isLeft = x.isRight</code> we should have <code>(!x.isLeft) = x.isRight</code> - that is a much more useful simp lemma. The problem seems to be the priority of the ! operator - it's binding to the whole expression <code>x.isLeft = x.isRight</code>, but I think this cannot be what is intended, surely.</p>",
        "id": 525937693,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750953866
    },
    {
        "content": "<p>If people agree I guess I'll submit a <code>lean4</code> PR to fix this... am I just missing something as to why this is useful in its current form?</p>",
        "id": 525937938,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750953939
    },
    {
        "content": "<p>These are definitely malformed, they should say <code>(!x.isLeft) = x.isRight</code> not <code>(!decide (x.isLeft = x.isRight)) = true</code></p>",
        "id": 525938095,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750953981
    },
    {
        "content": "<p>Separately, maybe the precedence of <code>!</code> is wrong?</p>",
        "id": 525938158,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750954003
    },
    {
        "content": "<p>Aye, or shifted at some point and that's why this happened (after all, you probably wouldn't notice if these simp lemmas aren't actually used anywhere currently).</p>",
        "id": 525938275,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750954039
    },
    {
        "content": "<p><code>@[inherit_doc] notation:max \"!\" b:40 =&gt; not b</code>- This is where the notation for <code>!</code> is defined.</p>",
        "id": 525938504,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750954140
    },
    {
        "content": "<p>I wonder if the <code>decide</code> coercion should be considered harmful</p>",
        "id": 525938573,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750954167
    },
    {
        "content": "<p>I know <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> was annoyed in the past about the bidirectional coercions between <code>Fin</code> and <code>Nat</code>; presumably the bidirectional coercions between <code>Bool</code> and <code>Prop</code> are similarly problematic?</p>",
        "id": 525938664,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750954208
    },
    {
        "content": "<p>I don't much like it. We were discussing earlier that <code>isLeft</code> and <code>isRight</code> are a pain to use and this is one reason for that I think.</p>",
        "id": 525938685,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750954218
    },
    {
        "content": "<p>Either way, I think you should just go ahead and fix the statements right now with the current precedence / coercions</p>",
        "id": 525938765,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750954249
    },
    {
        "content": "<p>OK. Always somewhat more of a pain with core to run up a quick PR but I'll do it.</p>",
        "id": 525938874,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750954281
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Bool.not_eq_iff#doc\">docs#Bool.not_eq_iff</a> and nearby lemmas are also affected</p>",
        "id": 525939168,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750954393
    },
    {
        "content": "<p>Huh weird. It... may already be fixed? At least, I just synced to the most recent version of core, and that is different.</p>",
        "id": 525939310,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750954448
    },
    {
        "content": "<p>Indeed, <code>#check Sum.bnot_isRight</code> looks ok in the nightly web editor</p>",
        "id": 525939436,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750954494
    },
    {
        "content": "<p>Looks like <a href=\"https://github.com/leanprover/lean4/pull/8849\">lean4#8849</a> fixed this on the way past adding grind annotations.</p>",
        "id": 525939582,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750954546
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/270676-lean4/topic/Sum.2Ebnot_isLeft.20and.20Sum.2Ebnot_isRight/near/525939168\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Bool.not_eq_iff#doc\">docs#Bool.not_eq_iff</a> and nearby lemmas are also affected</p>\n</blockquote>\n<p>These ones are still broken though</p>",
        "id": 525939722,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750954601
    },
    {
        "content": "<p>Aye</p>",
        "id": 525939804,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750954635
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> The <code>Nat</code> &lt;-&gt; <code>Fin</code> bidirectional coercions are actively harmful, since they can cause silent truncation due to the way arithmetic is elaborated depending on small changes in elaboration order. (As a matter of principle, I think coercions ought to never have data loss. <code>Nat -&gt; Fin</code> should be explicit.)</p>\n<p>Going back and forth between <code>Prop</code> and <code>Bool</code> doesn't have the same sort of issue but still, it's not good to have coercion loops. This loss of definitional equality is annoying:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c1\">-- rfl fails</span>\n</code></pre></div>",
        "id": 525939910,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750954675
    },
    {
        "content": "<p>Sometimes you have things like, for instance, Sum.isLeft and Sum.isRight which are kind of used like propositions or conclusions. But I would argue it would be better if these were propositions, and then they just had a Decidable instance for when you need to turn them into Bool! They are in core though so maybe that would be an issue.</p>",
        "id": 525940164,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750954763
    },
    {
        "content": "<p>But I do basically feel like <code>Bool</code> should always look like data and a Bool that is used like a proposition is often a code smell.</p>",
        "id": 525940243,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750954793
    },
    {
        "content": "<p>I think the \"just make things (decidable) propositions\" ship has largely sailed</p>",
        "id": 525940257,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750954800
    },
    {
        "content": "<p>Alas, alack.</p>",
        "id": 525940313,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750954816
    },
    {
        "content": "<p>Like if we had (a == b) hypotheses in a theorem that would smell bad to me.</p>",
        "id": 525940427,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750954859
    },
    {
        "content": "<p>Maybe there should be a linter that bans prop / bool coercions in theorem statements</p>",
        "id": 525940615,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750954937
    },
    {
        "content": "<p>Since they tend to be accidental, or hiding that the statement is much messier than intended</p>",
        "id": 525940674,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750954958
    },
    {
        "content": "<p>Oh <em>no</em>, I've just learned we also use <code>!</code> for factorial. I mean it's fine, ish, it just makes trying to find more of these errors a bit harder</p>",
        "id": 525940883,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750955036
    },
    {
        "content": "<p><code>n ! = 1 ↔ n ≤ 1</code> - this statement does NOT mean what I thought it meant.</p>",
        "id": 525940972,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750955065
    },
    {
        "content": "<p>I already did such a search and believe that the ones I mentioned above are exhaustive (at least for mathlib)</p>",
        "id": 525940992,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750955072
    },
    {
        "content": "<p>Great! Thought I would double check. I make three such issues.</p>",
        "id": 525941123,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750955122
    },
    {
        "content": "<p>Also some of the names here are iffy (they should be <code>bnot</code>) but that is out of scope.</p>",
        "id": 525941169,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750955138
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> Recently in a code review you suggested that I change <code>f x (!y) z</code> to <code>f x !y z</code>, but the precedence causes that to be parsed as <code>f x !(y z)</code>. Do we find this to be surprising that <code>!</code> has such low precedence?</p>\n<p>It's hard to imagine changing <code>!</code> and reviewing all uses of it in the ecosystem, to make sure programs don't suddenly start having different behavior, but also it would be much harder to make such a change later. I think in practice though we see uses of <code>!f x y z</code>, so I'm not sure it would ever make sense for <code>f x !y z</code> to mean <code>f x (!y) z</code>, but at least it could be bumped up to a precedence right before function application.</p>",
        "id": 525941377,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750955217
    },
    {
        "content": "<p>What <em>should</em> the statement of <code>not_eq_iff</code> be?</p>",
        "id": 525941414,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750955226
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330967\">@Wrenna Robson</span> Make sure you check issues/PRs about <code>!</code>. I think I have a few experiments in there about it, to try to help address factorial problems.</p>",
        "id": 525941482,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750955251
    },
    {
        "content": "<p>(That's assuming the issues would be about <code>!</code>)</p>",
        "id": 525941538,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750955267
    },
    {
        "content": "<p>A little hard to search but I will try.</p>",
        "id": 525941558,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750955274
    },
    {
        "content": "<p>Found them <span class=\"user-mention\" data-user-id=\"330967\">@Wrenna Robson</span>: <a href=\"https://github.com/leanprover-community/mathlib4/pull/5824\">#5824</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/5826\">#5826</a></p>",
        "id": 525941752,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750955333
    },
    {
        "content": "<p>Thank you</p>",
        "id": 525941784,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750955340
    },
    {
        "content": "<p>Are those in lean4?</p>",
        "id": 525941888,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750955370
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/5824\">lean4#5824</a>, <a href=\"https://github.com/leanprover/lean4/pull/5826\">lean4#5826</a></p>",
        "id": 525941935,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750955386
    },
    {
        "content": "<p>Ah, I gotta go home and then I am on leave for a couple days, so I might not get a fix to those Mathlib lemmas in. I'm glad that the main issue I noticed is fixed in nightly. Having looked at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Bool.not_eq_iff#doc\">docs#Bool.not_eq_iff</a> for a while I am not actually sure what it is meant to be...</p>",
        "id": 525942258,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750955482
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Sum.2Ebnot_isLeft.20and.20Sum.2Ebnot_isRight/near/525939910\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> The <code>Nat</code> &lt;-&gt; <code>Fin</code> bidirectional coercions are actively harmful, since they can cause silent truncation due to the way arithmetic is elaborated depending on small changes in elaboration order. (As a matter of principle, I think coercions ought to never have data loss. <code>Nat -&gt; Fin</code> should be explicit.)</p>\n<p>Going back and forth between <code>Prop</code> and <code>Bool</code> doesn't have the same sort of issue but still, it's not good to have coercion loops. This loss of definitional equality is annoying:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c1\">-- rfl fails</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>If you think coercions should never have data loss, does that mean you are also opposed to, for instance, FunLike-style coercions?</p>",
        "id": 525942406,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750955538
    },
    {
        "content": "<p>Good question <span class=\"user-mention\" data-user-id=\"330967\">@Wrenna Robson</span>, and clearly my rule needs refinement. I'm thinking of this from the perspective of Coe as a way to fix defeq failures.</p>\n<p>CoeFun is different, since it's more like an interface types can implement to participate in function applications. I don't believe it's ever used to transform individual values, but only in the context of making <code>f x</code> make sense.</p>",
        "id": 525942898,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750955716
    },
    {
        "content": "<p>Yes, a world without it would be a much more annoying world, certainly.</p>",
        "id": 525943179,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750955812
    },
    {
        "content": "<p>The mystery of <code>not_eq_iff</code> seems solvable by looking at it in context.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">eq_not_iff</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">not_eq_iff</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n</code></pre></div>\n<p>Based on <code>eq_not_iff</code>, I'd guess it should be <code>(!a) = b)</code>.</p>",
        "id": 525943187,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750955815
    },
    {
        "content": "<p>Oh of course it is. It's obvious now you say it.</p>",
        "id": 525943252,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750955840
    },
    {
        "content": "<p>Still I suppose this is what the poor parser has to cope with.</p>",
        "id": 525943304,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750955859
    },
    {
        "content": "<p>There's some sense to having <code>!</code> parse similarly to <code>\\not</code>, but somehow for <code>Bool</code> it's really confusing, since <code>!</code> seems like it should have high precedence for some reason.</p>",
        "id": 525943436,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750955915
    },
    {
        "content": "<p>To me I think ! for Boolean negation binds far too greedily, yeah.</p>",
        "id": 525943464,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750955927
    },
    {
        "content": "<p>It wants to work more like - I think?</p>",
        "id": 525943544,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750955956
    },
    {
        "content": "<p>Yeah, booleans have boolean algebra.</p>\n<p>There's also a big tradition of being able to negate atoms easily (e.g. conjunctive normal form)</p>",
        "id": 525943688,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750956005
    },
    {
        "content": "<p>Whereas with propositions you often want to negate quite a complex proposition built out of longer statements.</p>",
        "id": 525943972,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750956122
    },
    {
        "content": "<p>Yeah, and definitely it should have lower precedence than any arithmetical operators</p>",
        "id": 525944100,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750956165
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/270676-lean4/topic/Sum.2Ebnot_isLeft.20and.20Sum.2Ebnot_isRight/near/525943179\">said</a>:</p>\n<blockquote>\n<p>Yes, a world without it would be a much more annoying world, certainly.</p>\n</blockquote>\n<p>Just to be clear, I don't think that <code>CoeFun</code> is an exception to the rule for sake of convenience, but rather that \"coe\" happens to be in the name and it's not the same kind of thing as <code>Coe</code>. It's more like we could imagine that whenever you do <code>f x</code>, the elaborator <em>always</em> asks <code>CoeFun</code> how to resolve it (like Python's <code>__call__</code>). Similarly, <code>CoeSort</code> is an interface for letting terms be on the RHS of <code>:</code>. The <code>Coe</code> system is something different from these, used to patch type mismatches in general.</p>",
        "id": 525944639,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750956373
    },
    {
        "content": "<p>Hmm, but sometimes we do coerce the whole function - consider Function.Injective e, where e is an Equiv, or a MulHom.</p>",
        "id": 525944852,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750956447
    },
    {
        "content": "<p>And that I think is a Coe.</p>",
        "id": 525944951,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750956481
    },
    {
        "content": "<p>Ok, then I give up :-)</p>",
        "id": 525944975,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750956487
    },
    {
        "content": "<p>Oh, wait, isn't the data in a FunLike generally the underlying function? The coercion to a function doesn't lose data then, only some proofs.</p>",
        "id": 525945080,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750956532
    },
    {
        "content": "<p>I do basically agree with your rule though. Like we should coerce Nat to Int, not Int to Nat, for the same reason. I suppose that is <em>genuinely</em> throwing away data whereas in theory because the coercion in FunLike is injective, you aren't actually losing anything.</p>",
        "id": 525945227,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750956584
    },
    {
        "content": "<p>Ah we had the same thought I think.</p>",
        "id": 525945270,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750956597
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Sum.2Ebnot_isLeft.20and.20Sum.2Ebnot_isRight/near/525945080\">said</a>:</p>\n<blockquote>\n<p>Oh, wait, isn't the data in a FunLike generally the underlying function? The coercion to a function doesn't lose data then, only some proofs.</p>\n</blockquote>\n<p>Sometimes you are losing data, like the <code>symm</code> of an <code>Equiv</code></p>",
        "id": 525945366,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750956627
    },
    {
        "content": "<p>It could be reconstructed in theory though.</p>",
        "id": 525945410,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750956644
    },
    {
        "content": "<p>Like you could define an equiv as a function equipped with a proof that it is bijective.</p>",
        "id": 525945566,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750956694
    },
    {
        "content": "<p>You shouldn't. But you could!</p>",
        "id": 525945632,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750956712
    },
    {
        "content": "<p>Yeah <code>FunLike</code> comes with a proof of injectivity iirc so you will never lose data (at least in the noncomputable sense)</p>",
        "id": 525945891,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750956800
    },
    {
        "content": "<p>The argument I guess is that <em>all</em> coercions should be injective.</p>",
        "id": 525946090,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750956868
    },
    {
        "content": "<p>The coercion from naturals to integers mod n isn't injective</p>",
        "id": 525946514,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750957011
    },
    {
        "content": "<p>Or at least injective on the value being coerced (in the case of Fin (n + 1), say, I don't actually have an issue with the Nat 0 being coerced... but partial injectivity feels messy in other ways).</p>",
        "id": 525946518,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750957013
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/Sum.2Ebnot_isLeft.20and.20Sum.2Ebnot_isRight/near/525946514\">said</a>:</p>\n<blockquote>\n<p>The coercion from naturals to integers mod n isn't injective</p>\n</blockquote>\n<p>Yes - I think Kyle's maximalist position would be that it should therefore be barred.</p>",
        "id": 525946611,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750957048
    },
    {
        "content": "<p>At least Mathlib doesn't have a <code>ZMod n -&gt; Nat</code> coercion, otherwise that would induce a lot more chaos.</p>",
        "id": 525947759,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750957459
    },
    {
        "content": "<p>Lean is missing a way to cast values using a uniform system, casting in the sense of C++.</p>\n<p>There's no coercion from <code>Nat</code> to <code>Fin n</code> for example (thankfully not, because there's a coercion <code>Fin n -&gt; Nat</code>), but you have to guess the function to use to lossily turn a <code>Nat</code> into <code>Fin n</code>.</p>\n<p>Type ascriptions aren't casts; they indicate the type that you intend a term to have. This could all be done with an extra typeclass and writing terms like <code>cast_to (Fin 2) n</code>. There could be type-ascription-like syntax for this such as <code>(n as Fin 2)</code> (though maybe not stealing <code>as</code> as a keyword).</p>",
        "id": 525949321,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750958064
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Sum.2Ebnot_isLeft.20and.20Sum.2Ebnot_isRight/near/525949321\">said</a>:</p>\n<blockquote>\n<p>There's no coercion from <code>Nat</code> to <code>Fin n</code> for example (thankfully not, because there's a coercion <code>Fin n -&gt; Nat</code>)</p>\n</blockquote>\n<p>... although <em>that</em> is a very recent development</p>",
        "id": 525949407,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750958097
    },
    {
        "content": "<p>Is it?</p>",
        "id": 525949591,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750958169
    },
    {
        "content": "<p>Yes, I'm very happy about this development :-)</p>\n<p>Now <code>(3 : Nat) = (3 : Fin 2)</code> and <code>(3 : Fin 2) = (3 : Nat)</code> <em>both</em> evaluate to <code>false</code></p>",
        "id": 525949609,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750958175
    },
    {
        "content": "<p>Oh, the no coercion.</p>",
        "id": 525949713,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750958213
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Sum.2Ebnot_isLeft.20and.20Sum.2Ebnot_isRight/near/525941377\">schrieb</a>:</p>\n<blockquote>\n<p>Recently in a code review you suggested that I change <code>f x (!y) z</code> to <code>f x !y z</code>, but the precedence causes that to be parsed as <code>f x !(y z)</code>. Do we find this to be surprising that <code>!</code> has such low precedence?</p>\n</blockquote>\n<p>I am certainly surprised :-)</p>",
        "id": 525950251,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1750958440
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/270676-lean4/topic/Sum.2Ebnot_isLeft.20and.20Sum.2Ebnot_isRight/near/525939582\">said</a>:</p>\n<blockquote>\n<p>Looks like <a href=\"https://github.com/leanprover/lean4/pull/8849\">lean4#8849</a> fixed this on the way past adding grind annotations.</p>\n</blockquote>\n<p>It's ok, we have 6 more of these: <a href=\"https://github.com/leanprover/lean4/blob/2c13d145dc05899f8ac5928253787d8a495f6c2b/src/Init/Data/Ord.lean#L250-L255\">https://github.com/leanprover/lean4/blob/2c13d145dc05899f8ac5928253787d8a495f6c2b/src/Init/Data/Ord.lean#L250-L255</a></p>",
        "id": 526628645,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1751382000
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> !(decide (_ = _))</p>",
        "id": 526628905,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1751382064
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Nat/Bitwise/Lemmas.html#Nat.not_decide_mod_two_eq_one\">Nat.not_decide_mod_two_eq_one</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Ord.html#Ordering.not_isEq_eq_isNe\">Ordering.not_isEq_eq_isNe</a>, and <a href=\"https://loogle.lean-lang.org/?q=%21%28decide%20%28_%20%3D%20_%29%29\">10 more</a></p>",
        "id": 526628924,
        "sender_full_name": "loogle",
        "timestamp": 1751382067
    },
    {
        "content": "<p>Is a good way to find them</p>",
        "id": 526628940,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1751382070
    },
    {
        "content": "<p>Cool. I am focusing on a grant application this week but I'm happy to review a PR if you get there first.</p>",
        "id": 526629033,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1751382093
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/9129\">lean4#9129</a></p>",
        "id": 526635225,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1751383871
    }
]