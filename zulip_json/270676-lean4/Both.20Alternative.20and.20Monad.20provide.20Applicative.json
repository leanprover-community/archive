[
    {
        "content": "<p>There are some declarations that take in a <code>Monad m</code> and an <code>Alternative m</code>. However, both <code>Monad</code> and <code>Alternative</code> extend <code>Applicative</code>, so we wind up with two potentially different data-carrying <code>Applicative</code> instances in context, which often just so happen to be the same. (Context: I'm experimenting with the upcoming overlapping instances linter <span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> and I are working on; you can see warnings produced in mathlib in <a href=\"https://github.com/leanprover-community/mathlib4/pull/34955\">#34955</a>, and this is among them. Disclaimer that there are still some bugs.)</p>\n<p>Is there an alternative (no pun intended) design for such declarations here? Has this been discussed before? (I couldn't find a thread.)</p>",
        "id": 572573200,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1770505818
    },
    {
        "content": "<p>Well, there is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlternativeMonad#doc\">docs#AlternativeMonad</a> (which comes from <a href=\"https://github.com/leanprover-community/batteries/pull/1152\">batteries#1152</a>) for this purpose (see also <a href=\"#narrow/channel/270676-lean4/topic/Functor.2Emap.20instance.20with.20.60Alternative.60\">#lean4 &gt; Functor.map instance with &#96;Alternative&#96;</a>)</p>",
        "id": 572574989,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1770507802
    },
    {
        "content": "<p>Aha, that’s exactly what I was looking for. Thanks! :)</p>",
        "id": 572575371,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1770508331
    },
    {
        "content": "<p>Indeed. But in core lean they are having the exact same problem as in mathlib, but they don't have <code>AlternativeMonad</code>. What would be a good design to fix this in lean core? Should <code>AlternativeMonad</code> be upstreamed?</p>",
        "id": 572614105,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1770550295
    },
    {
        "content": "<p>Well, I don't see how duplicate instance requirements would produce problems? The generic functions will most likely anyways eventually be instantiated with compatible instances. The only real problem that occurs with <code>[Monad m] [Alternative m]</code> is in proofs, e.g. in proving <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=failure_bind#doc\">docs#failure_bind</a>, and we only have those starting in batteries.</p>",
        "id": 572615400,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1770551909
    },
    {
        "content": "<p>The only way I could see it causing non-proof issues (in this case, unexpected behavior) in practice is if one or the other instance was defined “all at once” and inlined a behaviorally different applicative instance. I agree this would be very unlikely to happen, especially in core, but also because there usually aren’t terribly many options for <code>Applicative</code> instances.</p>\n<p>These interfaces are exposed for downstream use, though…maybe that’s a point in favor of good practice.</p>\n<p>I think a reasonable design would be to unbundle <code>Alternative</code> to take in an <code>Applicative</code> instance argument instead of extending it, and that this wouldn’t cause too many breaking changes.</p>",
        "id": 572632672,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1770568113
    }
]