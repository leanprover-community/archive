[
    {
        "content": "<p>Reduced to this Mathlib-free version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Struct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Struct</span><span class=\"bp\">.</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Struct</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Extend</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Struct</span><span class=\"w\"> </span><span class=\"n\">m</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">fact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Extend</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Extend</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fact</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">[Meta.Tactic.simp.discharge] fact discharge ❌️</span>\n<span class=\"cm\">      Extend m</span>\n<span class=\"cm\">[Meta.Tactic.simp.unify] eq_self.{u_1}:1000, failed to unify</span>\n<span class=\"cm\">      @Eq.{?u.151} ?α ?a ?a</span>\n<span class=\"cm\">    with</span>\n<span class=\"cm\">      @Eq.{1} Nat (@Struct.data m (@Extend.toStruct m h)) m</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 565376619,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1766674946
    },
    {
        "content": "<p>I don't understand why <code>simp</code> can't prove the example</p>",
        "id": 565376725,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1766675044
    },
    {
        "content": "<p>I would expect because simp doesn't fill in propositional arguments on its own in this situation so you need to do <code> simp only [fact, h]</code>.</p>",
        "id": 565376948,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766675262
    },
    {
        "content": "<p>hm, that's frustrating<br>\nI lifted (what I've reduced to) <code>Struct</code> to <code>Prop</code> to avoid DTT hell, but apparently that breaks <code>simp</code>!<br>\nI understand why it doesn't fill in <code>Prop</code>-valued hypotheses, but why can't it fill in <code>Prop</code>-valued holes in the LHS it's matching on?</p>",
        "id": 565380089,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1766679153
    },
    {
        "content": "<p>I'm not quite sure,  I believe<code>isDefEq</code> should assign the mvar that <code>h</code> becomes on the left but it does not AFAICT.  For some reason this defeq query:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Struct</span><span class=\"bp\">.</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Extend</span><span class=\"bp\">.</span><span class=\"n\">toStruct</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Struct</span><span class=\"bp\">.</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Extend</span><span class=\"bp\">.</span><span class=\"n\">toStruct</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>only assigns <code>?m</code> and not <code>?h</code>.</p>",
        "id": 565381094,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766680953
    },
    {
        "content": "<p>I think it is at least worth opening an issue in core over, make sure to point out the defeq issue, that is the reason it doesn't work.</p>",
        "id": 565381254,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766681236
    },
    {
        "content": "<p>Is it because <code>Extend.toStruct</code> is a theorem</p>",
        "id": 565382935,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766683655
    },
    {
        "content": "<p>Ah that would make sense yes, but it still feels to me like the simp part should morally work.</p>",
        "id": 565383490,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766684527
    },
    {
        "content": "<p>I don't really understand the issue still. Does it only break for structure extensions, or for anything of this form?</p>",
        "id": 565383643,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1766684705
    },
    {
        "content": "<p>OK it breaks for anything. Reduced it further:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">imp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">fact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">imp</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">imp</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fact</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">[Meta.Tactic.simp.discharge] fact discharge ❌️</span>\n<span class=\"cm\">      p2</span>\n<span class=\"cm\">[Meta.Tactic.simp.unify] eq_self.{u_1}:1000, failed to unify</span>\n<span class=\"cm\">      @Eq.{?u.116} ?α ?a ?a</span>\n<span class=\"cm\">    with</span>\n<span class=\"cm\">      @Eq.{1} Nat (data (imp h)) (@OfNat.ofNat.{0} Nat (nat_lit 0) (instOfNatNat (nat_lit 0)))</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 565383952,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1766685145
    },
    {
        "content": "<p>I don't understand what you mean by <code>IsDefEq</code> being an issue. Does that appear somewhere in some trace I can print?</p>",
        "id": 565384005,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1766685211
    },
    {
        "content": "<p>You can inspect the defeq trace with <code>trace.Meta.isDefEq</code>. When <code>simp</code>'s term index suggests a theorem to try [ in this case fact] simp will take the LHS of that theorem with all of its parameters replaced with meta variables. It then uses <code>isDefEq</code> to unify the theorem pattern with the term it is trying to rewrite. During this unfication process it only assigns <code>?m</code> but not <code>?h</code>. This in turn causes the <code>h</code> hypothesis to remain open which is why <code>simp</code> wants it to be filled by additional reasoning.</p>",
        "id": 565384141,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766685436
    },
    {
        "content": "<p>Thanks! But I can't seem to find this in the <code>IsDefEq</code> trace.</p>",
        "id": 565384457,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1766685724
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/270676-lean4/topic/Bizarre.20.60simp.60.20error/near/565381094\">said</a>:</p>\n<blockquote>\n<p>I'm not quite sure,  I believe<code>isDefEq</code> should assign the mvar that <code>h</code> becomes on the left but it does not AFAICT.  For some reason this defeq query:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Struct</span><span class=\"bp\">.</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Extend</span><span class=\"bp\">.</span><span class=\"n\">toStruct</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Struct</span><span class=\"bp\">.</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Extend</span><span class=\"bp\">.</span><span class=\"n\">toStruct</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>only assigns <code>?m</code> and not <code>?h</code>.</p>\n</blockquote>\n<p>This query from above is from the defeq trace</p>",
        "id": 565384541,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766685775
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/si5wcSoD0edXwVTUY2ydX41B/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/si5wcSoD0edXwVTUY2ydX41B/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"715x688\" src=\"/user_uploads/thumbnail/3121/si5wcSoD0edXwVTUY2ydX41B/image.png/840x560.webp\"></a></div>",
        "id": 565384575,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766685811
    },
    {
        "content": "<p>Oh OK!<br>\nIn my simplified version I see<br>\n<code>[Meta.isDefEq] ✅️ data (imp ?h) =?= data (imp h)</code><br>\nwith no dropdown</p>",
        "id": 565384622,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1766685877
    },
    {
        "content": "<p>Yeah because no meta variable is being assigned</p>",
        "id": 565384635,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766685900
    },
    {
        "content": "<p>I'm really sorry I think this is a bit beyond me. I understood that line as saying <code>?h</code> is being assigned to <code>h</code>?</p>",
        "id": 565384671,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1766685977
    },
    {
        "content": "<p>No, that line is asking the unification problem </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">imp</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">imp</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>the unifier (<code>isDefEq</code>) can then attempt to use a first order heuristic whereby if you have a problem of the shape</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>\n<p>and <code>f =?= g</code> and <code>x =?= y</code> it's solved (if this fails it would try a bit harder with higher order approaches). So in this situation it identifies okay <code>data =?= data</code> and then it ries to solve <code>(imp ?h) =?= (imp h)</code>. </p>\n<p>Now the way that defeq presumably solves this problem is that because <code>imp h</code> is a proof, it is guaranteed to be equal to any other proof of the same fact. So defeq can conclude without traversing into the terms further that they are equal (after all they have the same type) and close the problem.</p>\n<p>Because of this behavior the meta variable <code>?h</code> does not end up getting assigned (the unifier never even sees it). Not traversing into proof terms is an (important) performance optimization that should certainly remain active in the general case. Regardless I still think it makes sense to at least keep this issue in our issue tracker in case someone finds a nice solution or even just to make it easier for other users to discover what is going wrong.</p>",
        "id": 565384843,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766686285
    },
    {
        "content": "<p>Right I see. I will confess I'm not really sure what exactly to say in the issue so I will leave that to others if they would like to. But this seems like something that isn't changing anytime soon?</p>",
        "id": 565384938,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1766686390
    },
    {
        "content": "<p>Thanks for your patience with the explanations!</p>",
        "id": 565384945,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1766686402
    },
    {
        "content": "<blockquote>\n<p>But this seems like something that isn't changing anytime soon?</p>\n</blockquote>\n<p>Yes</p>",
        "id": 565385031,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766686574
    },
    {
        "content": "<p>I suppose this is actually really easy to work around. By proof irrelevance, any proof of <code>(h : p2) → data (imp h) = 0</code> is a proof of <code>(h' : p1) → data h' = 0</code>.</p>",
        "id": 565385378,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1766687186
    },
    {
        "content": "<p>So really it's a question of me writing a not-general-enough <code>simp</code> lemma.</p>",
        "id": 565385397,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1766687213
    },
    {
        "content": "<p>That's true yes, it would still be nice if we could make it work or at least have simp throw an error when you mark the theorem.</p>",
        "id": 565385584,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766687579
    },
    {
        "content": "<p>Yeah, please create an issue — it might be worth special casing projections.</p>\n<p>If writing a more general simp lemma works for you, then great.</p>\n<p>Other workarounds:</p>\n<ol>\n<li>You might also consider using a <code>Type</code>-valued structure anyway and relying on eta-for-structures, which should reduce DTT issues (structures with only proof fields should be defeq, even if the structure is in <code>Type</code>).</li>\n<li>You might have the same field re-defined on substructures, to avoid this nested projection issue from preventing unification.</li>\n</ol>",
        "id": 565385606,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1766687627
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/issues/11798\">https://github.com/leanprover/lean4/issues/11798</a></p>",
        "id": 565385698,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1766687790
    },
    {
        "content": "<p>Thanks so much!</p>",
        "id": 565385940,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1766688256
    }
]