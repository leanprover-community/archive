[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> I have a quick question about <code>fun_prop</code>: am I right in thinking that this is a bad <code>fun_prop</code> lemma?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">fun_prop</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ContinuousOn</span><span class=\"bp\">.</span><span class=\"n\">comp''</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ≥</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContinuousOn</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContinuousOn</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">MapsTo</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContinuousOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">ContinuousOn</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>My understanding is that since <code>t</code> doesn't appear in <code>ContinuousOn (fun x =&gt; g (f x)) s</code>, fun_prop will never be able to figure out what <code>t</code> should be, and so this will never work.</p>",
        "id": 455807750,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1722567474
    },
    {
        "content": "<p><code>fun_prop</code> is smart enough to sometimes delay theorem arguments and infer them from assumptions in the context. Thus <code>ContinuousOn.comp''</code> is definitely a valid <code>fun_prop</code> theorem but I'm unsure of its usefulness as I'm not sure if there is a good tactic to discharge the subgoal <code>Set.MapsTo f s t</code>.</p>\n<p>Here are few examples of when <code>fun_prop</code> fills in metavariables and when it fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fun_prop</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">ContDiff</span><span class=\"bp\">.</span><span class=\"n\">differentiable</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">fun_prop</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"c1\">-- My main motivation for filling in metavariables was something like this:</span>\n<span class=\"c1\">-- `fun_prop` applies `ContDiff.differentiable` with subgoal `ContDiff ‚Ñù ?n f` and `?n` is later filled in by  unifying with `hf`</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContDiff</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Differentiable</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=</span><span class=\"n\">decide</span><span class=\"o\">)</span>\n\n\n<span class=\"c1\">-- If there are two different hypothesis that can fill in the metavariable then `fun_prop` can't recover from incorrectly assigning it.</span>\n<span class=\"c1\">-- In this example `hf'` is used first, `?n` is assigned `0` and `decide` fails to prove `1 ‚â§ 0`. `fun_prop` then fails to use `hf` because `?n` has already been assigned to `0`.</span>\n<span class=\"c1\">-- I'm aware where the problem is but I'm still thinking how to fix it. My main concern is that I don't know how expensive is to store and recover `MetaM` state and I'm worried about performance.</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContDiff</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContDiff</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Differentiable</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=</span><span class=\"n\">decide</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- this works because `hf` is used first</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContDiff</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContDiff</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Differentiable</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=</span><span class=\"n\">decide</span><span class=\"o\">)</span>\n\n\n<span class=\"c1\">-- Here `fun_prop` fails applying `Differentiable.continuous` fails because the type class argument can't be infered `NontriviallyNormedField ?ùïú`</span>\n<span class=\"c1\">-- current implementation of `fun_prop` requires that typeclass arguments are infered immediatelly</span>\n<span class=\"c1\">-- This should not be too hard to fix.</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContDiff</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span>\n\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fun_prop</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">ContinuousOn</span><span class=\"bp\">.</span><span class=\"n\">comp''</span>\n\n<span class=\"c1\">-- Looks like that `ContinuousOn.comp''` can be used if all the assumptions align.</span>\n<span class=\"c1\">-- However I'm unsure if there is any good tactic able to discharge subgoals like `Set.MapsTo f {1}·∂ú {0}·∂ú` in more complicated scenarios.</span>\n<span class=\"kn\">example</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContinuousOn</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"bp\">·∂ú</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContinuousOn</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">·∂ú</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">MapsTo</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"bp\">·∂ú</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">·∂ú</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">ContinuousOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"bp\">·∂ú</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=</span><span class=\"n\">assumption</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 456029759,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1722627969
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span>  Here is a concrete example of what I describe <a href=\"https://github.com/leanprover-community/mathlib4/blob/f8a90e413be2e8d8c6c0e1873337729aa803af7b/Mathlib/Tactic/FunProp/Core.lean#L156\">here</a> and you expressed concern about it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContDiff</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContDiff</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Differentiable</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=</span><span class=\"n\">decide</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- fails as `?n` is assigned with `0`and `fun_prop` can't recover from it</span>\n</code></pre></div>\n<p>I'm still unsure what is the best way to address it.</p>",
        "id": 456030517,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1722628369
    },
    {
        "content": "<p>I see, thanks for the explanation!</p>",
        "id": 456031550,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1722628858
    },
    {
        "content": "<p>Yeah, I would expect the point of <code>ContinuousOn.comp''</code> is exactly what you suggest. Someone writes a <code>have</code> statement and uses it with a discharger that can utilize it.</p>",
        "id": 456041367,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1722632471
    }
]