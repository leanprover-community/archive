[
    {
        "content": "<p>I just defined a function <code>Nat → Nat</code> via recursion that calls itself on many smaller values (like fibonacci), and of course it gets very slow very quickly. In Haskell I’d define a lazy list to speed this up using memoize. What’s the usual way to do that in Lean? Is there maybe already an efficient</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">memo</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>somewhere, and if not, what would be the best way to implement it (in a way that I can prove it equal to the naive version)?</p>",
        "id": 357186213,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683703459
    },
    {
        "content": "<p>I think you're looking for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=memoFix#doc\">docs4#memoFix</a></p>",
        "id": 357216693,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1683710054
    },
    {
        "content": "<p>Oh, but you cannot prove this one equal to the naive version...</p>",
        "id": 357216965,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1683710132
    },
    {
        "content": "<p>This is what I came up with so far, which already helps a bit:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">memoVec</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Vector</span> <span class=\"n\">a</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Vector</span> <span class=\"n\">a</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Vector.nil</span>\n <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span>\n   <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">memoVec</span> <span class=\"n\">f</span> <span class=\"n\">n</span>\n   <span class=\"n\">Vector.cons</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">memo</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">have</span> <span class=\"n\">f'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Vector</span> <span class=\"n\">a</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Vector.get</span> <span class=\"n\">v</span> <span class=\"o\">⟨</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">succ</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n      <span class=\"n\">Nat.sub_lt_self</span> <span class=\"o\">(</span><span class=\"n\">Nat.zero_lt_succ</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ_le_of_lt</span> <span class=\"n\">hi</span><span class=\"o\">)</span>\n    <span class=\"o\">⟩)</span>\n  <span class=\"n\">Vector.get</span> <span class=\"o\">(</span><span class=\"n\">memoVec</span> <span class=\"n\">f'</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>Is using <code>#eval</code> the fastest way to evaluate code, is or is there something “better”?<br>\nWill this execute natural numbers efficiently by default, or is it still using the unary representation?<br>\n(My code does arithmetic with <code>Nat</code> and <code>Rat</code> and the numbers get large.)</p>",
        "id": 357249346,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683717146
    },
    {
        "content": "<p>Afaik <code>#eval</code> uses bignums for <code>Nat</code> and is the fastest available interpreter. But if you package your code as a program and compile it, you should get an additional (big?) speedup.</p>",
        "id": 357254631,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1683718033
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> Maybe this version would interest you. It uses an <code>Array</code> instead, which is a bit more efficient since it's a contiguous block of memory rather than a linked list, and also it makes the indexing calculations simpler since you can efficiently push to the end.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fin.Basic</span>\n\n<span class=\"sd\">/-- Arrays of a given size. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">SArray</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">a.size</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">SArray</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">push</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">SArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">SArray</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">a.1.push</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Array.size_push</span><span class=\"o\">,</span> <span class=\"n\">a.2</span><span class=\"o\">]⟩</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">get</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">SArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">a.1.get</span> <span class=\"o\">(</span><span class=\"n\">a.2.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">SArray</span> <span class=\"n\">α</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Array.empty</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">SArray</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">memoVec</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">SArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">SArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">empty</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">memoVec</span> <span class=\"n\">f</span> <span class=\"n\">n</span>\n    <span class=\"n\">v.push</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">memo</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">f'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">SArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"n\">v.get</span>\n  <span class=\"o\">(</span><span class=\"n\">memoVec</span> <span class=\"n\">f'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fib</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">memo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"k\">fun</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">fib</span> <span class=\"mi\">100</span>\n<span class=\"c1\">-- 573147844013817084101</span>\n<span class=\"k\">#eval</span> <span class=\"n\">fib</span> <span class=\"mi\">1000</span>\n<span class=\"c1\">-- 70330367711422815821...5245323403501</span>\n</code></pre></div>",
        "id": 357281516,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683723478
    },
    {
        "content": "<p>Thanks, that would have been my next question; better data structures. Very nice. Is Vector-push better than linear, or still linear?</p>",
        "id": 357295141,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683726041
    },
    {
        "content": "<p>Both <code>SArray.push</code> and <code>Vector.push</code> are (amortized) constant time (so long as there's no sharing of the <code>SArray</code>; if there's sharing, it's linear time to make a copy).</p>",
        "id": 357295590,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683726123
    },
    {
        "content": "<p><code>SArray.push</code> is only amortized constant time unless you pre-allocate an array using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.mkEmpty#doc\">docs4#Array.mkEmpty</a> to get enough capacity to never need to re-allocate.</p>",
        "id": 357296079,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683726231
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 357296268,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683726268
    },
    {
        "content": "<p>If you want to incorporate that, what you could do is switch <code>SArray.empty</code> to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">empty</span> <span class=\"o\">(</span><span class=\"n\">capacity</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">SArray</span> <span class=\"n\">α</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Array.mkEmpty</span> <span class=\"n\">capacity</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>and then pass in a capacity:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">memoVec</span> <span class=\"o\">(</span><span class=\"n\">capacity</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">SArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">SArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">empty</span> <span class=\"n\">capacity</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">memoVec</span> <span class=\"n\">capacity</span> <span class=\"n\">f</span> <span class=\"n\">n</span>\n    <span class=\"n\">v.push</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">memo</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">f'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">SArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"n\">v.get</span>\n  <span class=\"o\">(</span><span class=\"n\">memoVec</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">f'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 357297158,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683726419
    },
    {
        "content": "<p>It may be a bit faster, but something is still slower than it ought to be (I think, maybe I am just expecting too much), if I use the <code>memo</code> like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">vf</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> all tails -/</span>\n  <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">-</span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">r</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">safe</span> <span class=\"n\">Nat.sub_lt</span><span class=\"o\">,</span> <span class=\"n\">safe</span> <span class=\"n\">Nat.zero_lt_of_ne_zero</span><span class=\"o\">)⟩</span> <span class=\"bp\">+</span>\n  <span class=\"bp\">∑</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> j &lt; n tails, so n-j heads -/</span>\n    <span class=\"n\">Nat.choose</span> <span class=\"n\">n</span> <span class=\"n\">j</span> <span class=\"bp\">*</span> <span class=\"n\">p</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">-</span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">*</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> Pick best next step -/</span>\n    <span class=\"n\">Finset.sup'</span> <span class=\"o\">(</span><span class=\"n\">Finset.range</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"n\">j</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">r</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">safe</span> <span class=\"n\">Nat.sub_lt</span><span class=\"o\">,</span> <span class=\"n\">safe</span> <span class=\"n\">Nat.zero_lt_of_ne_zero</span><span class=\"o\">)⟩)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fast_v</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">memo</span> <span class=\"o\">(</span><span class=\"n\">vf</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">fast_v</span> <span class=\"mi\">15</span> <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">5</span>\n</code></pre></div>\n<p>If I increase the 15, to, say, 20, it quickly gets much slower.</p>",
        "id": 357297778,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683726533
    },
    {
        "content": "<p>I wouldn't be surprised if <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.choose#doc\">docs4#Nat.choose</a> were slow (take a look at how it's defined)</p>",
        "id": 357298523,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683726693
    },
    {
        "content": "<p>It'd be worth replacing <code>Nat.choose n j</code> with <code>1</code> to see if things speed up</p>",
        "id": 357298821,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683726743
    },
    {
        "content": "<p>We could csimp optimize that I guess?</p>",
        "id": 357298866,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1683726751
    },
    {
        "content": "<p>Is <code>csimp</code> a mechanism to tell the system to use a different, faster implementation for a given function? <br>\n(If so then you just answered the question I’d have once I have succesfully defined the faster version of the plain recursive <code>v</code> function :-))</p>",
        "id": 357299625,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683726911
    },
    {
        "content": "<p>Yes</p>",
        "id": 357299667,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1683726921
    },
    {
        "content": "<p>Cool :-)</p>",
        "id": 357299798,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683726949
    },
    {
        "content": "<p>Yes; but it requires the signature of the two functions to be identical</p>",
        "id": 357299829,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683726954
    },
    {
        "content": "<p>which is fine here (Eric is probably referencing for example that more complicated functions only have more efficient implementations with additional typeclass assumptions)</p>",
        "id": 357300121,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683727005
    },
    {
        "content": "<p>Indeed, these three magic lines greatly speed it up:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fast_choose</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.descFactorial</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">/</span> <span class=\"n\">Nat.factorial</span> <span class=\"n\">k</span>\n<span class=\"kd\">@[csimp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">choose_eq_fast_choose</span> <span class=\"o\">:</span> <span class=\"n\">Nat.choose</span> <span class=\"bp\">=</span> <span class=\"n\">fast_choose</span> <span class=\"o\">:=</span>\n  <span class=\"n\">funext</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">funext</span> <span class=\"n\">Nat.choose_eq_descFactorial_div_factorial</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 357301638,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683727278
    },
    {
        "content": "<p>A bit better of an algorithm is probably</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Nat.fast_choose</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n    <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"n\">return</span> <span class=\"n\">r</span>\n</code></pre></div>\n<p>since it involves smaller intermediate values, though your <code>fast_choose</code> is great since it involves not having to prove anything new <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 357302531,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683727440
    },
    {
        "content": "<p>I don't actually know if it's better though, since it's possible that doing a single division with large numbers is better than doing <code>k</code> divisions <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 357302830,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683727497
    },
    {
        "content": "<p>I don't know a thing about algorithms, but I had naively thought that doing the recursive (but memoized!) version of <code>choose</code> would be faster than all those multiplications and divisions.</p>",
        "id": 357304210,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1683727733
    },
    {
        "content": "<p>But I guess <code>O(n * k)</code> additions can also become pretty slow pretty fast.</p>",
        "id": 357304804,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1683727807
    },
    {
        "content": "<p>Another thing to consider is that the more that can be offloaded to individual nat operations, the more is being handled by some optimized C code from the GMP library</p>",
        "id": 357305629,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683727933
    },
    {
        "content": "<p>And I guess the same is true for <code>Int</code> operations, but not for <code>Rat</code>, maybe?</p>",
        "id": 357305850,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1683727976
    },
    {
        "content": "<p>It is not necessarily the additions. Each function call carries an inherent overhead with it unless it is possible to perform tail recursion (which is not the case in the naive version of the Nat.choose function and also not if you memoize it) so calling a function does not only perform an addition it also performs:</p>\n<ol>\n<li>Some bookkeeping of CPU state in memory</li>\n<li>A lookup in memory for whether an input pair has been memoized yet</li>\n<li>the actual computation</li>\n<li>More recursive calls</li>\n<li>once all those recursive calls have finished we restore the part of the CPU state that we book kept in memory before</li>\n<li>now we can actually return</li>\n</ol>\n<p>And on the other hand the for loop should I think be optimized into basically precisely a loop via tail recursion elimination and inlining such that it can for the most part omit step 1 2 4 5 and 6 and just compute.</p>\n<p>Now I can of course not tell (without further profiling) if this is <em>the</em> reason that it is slower but it certainly plays a part.</p>",
        "id": 357306141,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1683728025
    },
    {
        "content": "<p>Thanks! That's helpful.</p>",
        "id": 357307558,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1683728235
    },
    {
        "content": "<p>My lean has become very rusty… <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> , can you maybe give me a hint about how to prove a lemma like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Arrays of a given size, H'T Kyle Miller -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">SArray</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">a.size</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">SArray</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">push</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">SArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">SArray</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">a.1.push</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Array.size_push</span><span class=\"o\">,</span> <span class=\"n\">a.2</span><span class=\"o\">]⟩</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">get</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">SArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">a.1.get</span> <span class=\"o\">(</span><span class=\"n\">a.2.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">get_push</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">SArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">a.push</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"o\">(⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">a.get</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"k\">else</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases'</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">v</span> <span class=\"n\">hv</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">SArray.get</span><span class=\"o\">,</span> <span class=\"n\">SArray.push</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Array.get_push</span><span class=\"o\">]</span>\n  <span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"c1\">-- doesn’t work</span>\n</code></pre></div>\n<p>Or, more generally, if I have a dependent <code>if h : p then … else … </code> in the goal, how do I do case analysis on that?</p>",
        "id": 357332670,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683732661
    },
    {
        "content": "<p>Does  <code>by_cases</code> instead of <code>cases</code> work?</p>",
        "id": 357333968,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1683732956
    },
    {
        "content": "<p>Lean 4's <code>split</code> tactic does case analysis on an <code>if</code></p>",
        "id": 357333985,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683732960
    },
    {
        "content": "<p>That rw I put into <code>get</code> that rewrites <code>i</code> itself makes things a little tricky. Here's an alternative:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">get</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">SArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">a.1.get</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a.2.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">i.2</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">get_push</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">SArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">a.push</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"o\">(⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">a.get</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"k\">else</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">SArray.get</span><span class=\"o\">,</span> <span class=\"n\">SArray.push</span><span class=\"o\">,</span> <span class=\"n\">Array.get_push</span><span class=\"o\">,</span> <span class=\"n\">a.2</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 357334829,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683733145
    },
    {
        "content": "<p>Very nice:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[csimp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">v_fast_v</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">fast_v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">funext</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">n</span>\n  <span class=\"n\">apply</span> <span class=\"n\">funext</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">p</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">fast_v</span><span class=\"o\">,</span> <span class=\"n\">memo_spec</span><span class=\"o\">,</span> <span class=\"n\">v_fix_vf</span><span class=\"o\">]</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">v</span> <span class=\"mi\">50</span> <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">5</span>\n</code></pre></div>\n<p>(It seems I can’t use <code>ext n p</code> here because <code>ext</code> seems to overshoot and applies <code>Rat.ext</code> or something like that.)</p>",
        "id": 357394035,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683749083
    },
    {
        "content": "<p>you can probably use <code>funext n p</code></p>",
        "id": 357394713,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683749294
    },
    {
        "content": "<p>also <code>ext</code> has a <code>: 2</code> argument you can add if it goes too far</p>",
        "id": 357398152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683750391
    },
    {
        "content": "<p>Ah, that's good to know. I was trying <code>ext 2</code>. I thought I read the tooltip; if it's not there I'll maybe PR a doc improvement.</p>",
        "id": 357462371,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683781898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/memoziation.20of.20strong.20recursion.20on.20nat/near/357334829\">said</a>:</p>\n<blockquote>\n<p>That rw I put into <code>get</code> that rewrites <code>i</code> itself makes things a little tricky. Here's an alternative:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">get</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">SArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">a.1.get</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a.2.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">i.2</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">get_push</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">SArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">a.push</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"o\">(⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">a.get</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"k\">else</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">SArray.get</span><span class=\"o\">,</span> <span class=\"n\">SArray.push</span><span class=\"o\">,</span> <span class=\"n\">Array.get_push</span><span class=\"o\">,</span> <span class=\"n\">a.2</span><span class=\"o\">]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This proof is surprisingly brittle. If I remove the unrelated looking <code>import Mathlib.Data.Nat.Factorial.Basic</code> it breaks. Too bad there is no <code>squeeze_simp</code> in lean4 yet; staring at the proof term didn’t yet tell me which lemma is lost.</p>\n<p>Maybe it’s not some lemma, but some other simp-affecting setting that disappears when not importing that file?</p>",
        "id": 357480515,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683787715
    },
    {
        "content": "<p>There is <code>simp?</code> as an alternative.</p>",
        "id": 357481262,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683787923
    },
    {
        "content": "<p>Ah, using trial and error with <code>import</code> I learned that<br>\n<code> import Std.Data.Array.Lemmas</code>  is needed; <code>import Std.Data.Array.Init.Lemmas</code> is not enough.</p>\n<p>Thanks, TIL <code>simp?</code>! This shows that the missing lemma is <code>Array.get_eq_getElem</code> from that module. All izz well.</p>",
        "id": 357482190,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683788148
    },
    {
        "content": "<p>also FYI if you hover on <code>Array.get_eq_getElem</code> it should mention that it is defined in <code>Std.Data.Array.Lemmas</code></p>",
        "id": 357488509,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683789681
    },
    {
        "content": "<p>Right, but (without <code>simp?</code>) I didn’t even know which lemma <code>simp</code> was picking up. So <code>simp?</code> is very useful here, thanks!</p>",
        "id": 357492693,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683790636
    },
    {
        "content": "<p>I’ve made the NatMemo code independent of mathlib (only std4), and with an example it looks like this:<br>\n<a href=\"https://gist.github.com/nomeata/b0929f2503fcab4d35717e92b5ba5e58\">https://gist.github.com/nomeata/b0929f2503fcab4d35717e92b5ba5e58</a><br>\nIs this something worth contributing to std4?</p>",
        "id": 357493017,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683790696
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/memoziation.20of.20strong.20recursion.20on.20nat/near/357301638\">said</a>:</p>\n<blockquote>\n<p>Indeed, these three magic lines greatly speed it up:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fast_choose</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.descFactorial</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">/</span> <span class=\"n\">Nat.factorial</span> <span class=\"n\">k</span>\n<span class=\"kd\">@[csimp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">choose_eq_fast_choose</span> <span class=\"o\">:</span> <span class=\"n\">Nat.choose</span> <span class=\"bp\">=</span> <span class=\"n\">fast_choose</span> <span class=\"o\">:=</span>\n  <span class=\"n\">funext</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">funext</span> <span class=\"n\">Nat.choose_eq_descFactorial_div_factorial</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>PR’ed in <a href=\"https://github.com/leanprover-community/mathlib4/pull/3915\">https://github.com/leanprover-community/mathlib4/pull/3915</a>; not sure if such <code>csimp</code> tweaks should be in mathlib though.</p>",
        "id": 357497488,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683791721
    },
    {
        "content": "<p>A function that’s defined recursively with strong recursion on <code>nat</code> gets elaborated to a call to <code>WellFounded.fix</code> with suitable parameters, one of which is the <code>F</code> which we can also pass to the <code>memo</code> function above.</p>\n<p>So I think it should be possible to automate the process of extracting that “functorial”, defining the <code>_fast</code> variant using memo, and prove the <code>csimp</code> lemma, so in the end instead of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">slow</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">List.foldl</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">i</span><span class=\"bp\">&lt;</span><span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">slow</span> <span class=\"n\">i</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">List.range</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fast</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">NatMemo.memo</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">List.foldl</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span><span class=\"bp\">&lt;</span><span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">r</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">List.range</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"o\">)</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">@[csimp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">slow_is_fast</span><span class=\"o\">:</span> <span class=\"n\">slow</span> <span class=\"bp\">=</span> <span class=\"n\">fast</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">NatMemo.memo_spec</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">slow</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>one can just write </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">memo_csimp</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">slow</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">List.foldl</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">i</span><span class=\"bp\">&lt;</span><span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">slow</span> <span class=\"n\">i</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">List.range</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I started coding this, and got the definition’s  RHS via <code>getConstInfoDefn</code> and <code>.value</code> of type <code>Expr</code>. But getting hold of the 5th argument by just manual pattern matching with <code>Expr.app</code> is quite tedious. Is there a better way to implement “I expect a term of the following shape”? Like we can do on <code>Syntax</code> very nicely using the <code> `(…) </code><br>\n feature?</p>",
        "id": 357911075,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683905343
    },
    {
        "content": "<p>Ah, <code>Lean.Expr.getAppFn</code> may help</p>",
        "id": 357913746,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683905851
    },
    {
        "content": "<p>It works! </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[memo]</span>\n<span class=\"kd\">def</span> <span class=\"n\">slow2</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">List.foldl</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">i</span><span class=\"bp\">&lt;</span><span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">slow2</span> <span class=\"n\">i</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">List.range</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>does all the things automatically! At least in this very particular case…</p>",
        "id": 357939988,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683911522
    },
    {
        "content": "<p>Or here is another obvious example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[memo]</span>\n<span class=\"kd\">def</span> <span class=\"n\">fib</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">fib</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">fib</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">fib</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">fib</span> <span class=\"mi\">100</span> <span class=\"c1\">--fast</span>\n</code></pre></div>",
        "id": 357940093,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683911541
    },
    {
        "content": "<p>Is there a dependent version of <code>Array</code> around somewhere? (With value types depending on the indices?)</p>",
        "id": 358041129,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683958471
    },
    {
        "content": "<p>I have put the <code>NatMemo</code> code as a lakeified library on <a href=\"https://github.com/nomeata/lean4-memo-nat\">https://github.com/nomeata/lean4-memo-nat</a><br>\nthere is example code at <a href=\"https://github.com/nomeata/lean4-memo-nat/blob/master/MemoNat/Demo.lean\">https://github.com/nomeata/lean4-memo-nat/blob/master/MemoNat/Demo.lean</a><br>\nThe (probably usable) main memo code is at <a href=\"https://github.com/nomeata/lean4-memo-nat/blob/master/MemoNat.lean\">https://github.com/nomeata/lean4-memo-nat/blob/master/MemoNat.lean</a><br>\nAnd the (certainly experimental) attribute is in <a href=\"https://github.com/nomeata/lean4-memo-nat/blob/master/MemoNat/Attr.lean\">https://github.com/nomeata/lean4-memo-nat/blob/master/MemoNat/Attr.lean</a></p>\n<p>I’d love to get some critical feedback of the attribute code; this is my first and probably very naive excursion into Lean metaprogramming :-)</p>",
        "id": 358051591,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683963794
    },
    {
        "content": "<p>Also, is there a repository or at least list of lean4 libraries somewhere, for better discoverability?<br>\nAnd is there a “best practice” github repo setup that I can cargo cult, with CI and documentation pushing to github pages?</p>",
        "id": 358051644,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1683963822
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/memoziation.20of.20strong.20recursion.20on.20nat/near/358041129\">said</a>:</p>\n<blockquote>\n<p>Is there a dependent version of <code>Array</code> around somewhere? (With value types depending on the indices?)</p>\n</blockquote>\n<p>Not that I know of. Back when I was making alternative <code>Array</code> primitives, I had played around with an implementation that was modeled by a dependent function from the indices. But I threw it out because I didn't have a use case and it was a pain to work with <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 359040766,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1684344445
    },
    {
        "content": "<p>I only have an indirect usecase: I had a non-dependent recursive function, which I sped up using memoization using <code>Array</code>, and the technique applies to any use of <code>WellFounded.fix</code>, and that allows dependent functions, so I had an inclination to generalize my memoization library as well… but since _that_ generalization has no use case yet, it’s not at all pressing.</p>",
        "id": 359044041,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1684345338
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> A quick hack is to use something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Any.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Any</span>\n\n<span class=\"kn\">protected</span> <span class=\"n\">abbrev</span> <span class=\"n\">Any.Sort</span> <span class=\"o\">:</span> <span class=\"n\">Any</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span>\n<span class=\"bp\">|</span> <span class=\"bp\">@</span><span class=\"n\">mk</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">protected</span> <span class=\"n\">abbrev</span> <span class=\"n\">Any.val</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Any</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a.Sort</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Any</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"s2\">\"Hello\"</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">true</span><span class=\"o\">]</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">test</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"c1\">-- 1</span>\n<span class=\"k\">#eval</span> <span class=\"n\">test</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"c1\">-- \"Hello\"</span>\n<span class=\"k\">#eval</span> <span class=\"n\">test</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"c1\">-- true</span>\n</code></pre></div>",
        "id": 359813990,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1684563164
    },
    {
        "content": "<p>That seems to lose the type information, though, so probably can’t be (safely) used to memoize a function of dependent type <code>∀ n, C n</code></p>",
        "id": 359932305,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1684603047
    },
    {
        "content": "<p>The type info is still there, as the three evals at the end show. For a specific dependent type, it's simpler to just wrap your function values in a Sigma type.</p>",
        "id": 360079628,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1684683447
    },
    {
        "content": "<p>Ah, I think I  now get it. I can put values of <code>Any</code> into the Vectors, and separately keep around the information that <code>a[n].Sort = C i</code> for some <code>C : Nat → Sort _</code>!</p>\n<p>This indeed allows me to define</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">DArray</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">push</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">DArray</span> <span class=\"n\">n</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DArray</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">a.1.push</span> <span class=\"o\">(</span><span class=\"n\">Any.mk</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"kd\">by</span>  <span class=\"bp\">…</span>   <span class=\"o\">⟩</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">get</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">DArray</span> <span class=\"n\">n</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n  <span class=\"n\">a.2</span> <span class=\"n\">i</span> <span class=\"bp\">▸</span> <span class=\"o\">(</span><span class=\"n\">a.1.get</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">theorem</span> <span class=\"n\">get_push</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">DArray</span> <span class=\"n\">n</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">a.push</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span>\n      <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span>\n      <span class=\"k\">then</span> <span class=\"n\">a.get</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n      <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_of_lt_succ</span> <span class=\"n\">hi</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_of_not_lt</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">▸</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"bp\">…</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">empty</span> <span class=\"o\">{</span><span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">cap</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DArray</span> <span class=\"mi\">0</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">SArray.empty</span> <span class=\"n\">cap</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Fin.elim0</span> <span class=\"n\">i</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">DArray</span>\n</code></pre></div>\n<p>and then generalize the memo code at <a href=\"https://github.com/nomeata/lean4-memo-nat/blob/master/MemoNat.lean\">https://github.com/nomeata/lean4-memo-nat/blob/master/MemoNat.lean</a> to dependent recursion.</p>\n<p>(I didn’t manage to conclude the proof of <code>get_push</code> because the <code>▸</code> get in the way, unfortunately, so I’ll park it at <a href=\"https://github.com/nomeata/lean4-memo-nat/pull/2\">https://github.com/nomeata/lean4-memo-nat/pull/2</a> for now,  until someone actually needs this.)</p>",
        "id": 360315614,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1684771412
    },
    {
        "content": "<p>Tried some further. It seems I am hitting universe level issues: Playing around with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Any.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Any</span>\n\n<span class=\"kn\">protected</span> <span class=\"n\">abbrev</span> <span class=\"n\">Any.Sort</span> <span class=\"o\">:</span> <span class=\"n\">Any</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span>\n<span class=\"bp\">|</span> <span class=\"bp\">@</span><span class=\"n\">mk</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">protected</span> <span class=\"n\">abbrev</span> <span class=\"n\">Any.val</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Any</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a.Sort</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">DArray.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">):=</span>\n  <span class=\"n\">arr</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Any.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span>\n  <span class=\"n\">size_eq</span> <span class=\"o\">:</span> <span class=\"n\">arr.size</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n  <span class=\"n\">types</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">arr.size</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">arr.get</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kt\">Sort</span> <span class=\"bp\">=</span> <span class=\"n\">C</span> <span class=\"n\">i</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">get.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">DArray</span> <span class=\"n\">n</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">types</span><span class=\"o\">⟩</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">types</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">▸</span> <span class=\"n\">a.get</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>I get </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">Array.get</span> <span class=\"n\">a</span> <span class=\"n\">i</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">Any</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">Any.Sort</span> <span class=\"o\">(</span><span class=\"n\">Array.get</span> <span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n</code></pre></div>\n<p>Is this approach, using a subtype, doomed to fail or is there a way?</p>",
        "id": 363525599,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1685894212
    },
    {
        "content": "<p>(The explicit universe levels in the <code>structure DArray</code> are  the inferred ones.)</p>",
        "id": 363526050,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1685894362
    },
    {
        "content": "<p>Oh, here is some random staring lean down that worked:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">get.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">DArray</span> <span class=\"n\">n</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">types</span><span class=\"o\">⟩</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">types</span> <span class=\"n\">i</span>\n  <span class=\"n\">revert</span> <span class=\"n\">h</span>\n  <span class=\"n\">generalize</span> <span class=\"n\">Array.get</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n  <span class=\"n\">cases</span> <span class=\"n\">x</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">exact</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>So it works, and can maybe be made pretty (because in the current form proving things about it will be quite ugly)</p>",
        "id": 363527682,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1685894907
    },
    {
        "content": "<p>it still has a universe bump problem though</p>",
        "id": 363527736,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685894930
    },
    {
        "content": "<p>You mean the definition of <code>DArray</code>? Is that an avoidable one?</p>",
        "id": 363527960,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1685895022
    },
    {
        "content": "<p>here's one way to do it without a universe bump, although it wastes some memory unless lean gets support for <code>Erased</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">DArray</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n  <span class=\"n\">arr</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n  <span class=\"n\">size_eq</span> <span class=\"o\">:</span> <span class=\"n\">arr.size</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n  <span class=\"n\">types</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">arr.size</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">arr.get</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">i</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">DArray.get</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">DArray</span> <span class=\"n\">n</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">i.1</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">▸</span> <span class=\"o\">(</span><span class=\"n\">a.arr.get</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">a</span><span class=\"o\">⟩)</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n  <span class=\"n\">case</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">a.2.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">i.2</span>\n  <span class=\"n\">case</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">a.3</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">a</span><span class=\"o\">⟩)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">▸</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 363528920,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685895378
    },
    {
        "content": "<p>Thanks! I was thinking about that variant earlier, but it’s a bit disappointing with the extra (unerased) field. <br>\nBut maybe I’ll play some more with this, thanks!</p>",
        "id": 363564756,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1685909501
    },
    {
        "content": "<p>I ran into something I need DArray for, so I put together an implementation to PR to Std: <a href=\"https://github.com/leanprover/std4/pull/166\">https://github.com/leanprover/std4/pull/166</a></p>\n<p>It relies on a <code>TypeErased</code> type for values whose type is noncomputable. Unsure if the interface is sound, would appreciate a second set of eyes on it.</p>\n<p>Both the interface and the implementations are deep in cast hell, so suggestions are highly appreciated, but I think most of the casting cannot be avoided.</p>",
        "id": 369603483,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687767587
    },
    {
        "content": "<p>(The <code>TypeErased</code> is essentially equivalent to the <code>Any</code> and <code>Σ i, C i</code> types above, but has no runtime overhead because it is implemented with unsafeCasts)</p>",
        "id": 369603824,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687767662
    },
    {
        "content": "<p>Small update: I finished support for memoizing functions recursing on nat also when they have a dependent result type, and the <code>@[memo]</code> attribute now also works when the function is elaborated to use <code>Nat.brecOn</code> (not just <code>WellFounded.fix</code>):</p>\n<p>Here an example from <a href=\"https://github.com/nomeata/lean4-memo-nat/blob/master/MemoNat/Demo.lean\"><code>Demo.lean</code></a> that calculates Pascal’s triangle, and gets much faster with <code>@[memo]</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">memo</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">pascal</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">SArray</span> <span class=\"n\">Nat</span> <span class=\"n\">i</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">SArray.empty</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">SArray.ofFn</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">pad_left</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">pascal</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">pad_right</span> <span class=\"o\">(</span><span class=\"n\">pascal</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>(It would also get much faster if I had used a <code>let</code> there, but that’s not the point :-)).</p>\n<p>I am using the variant of dependent arrays using the <a href=\"https://github.com/nomeata/lean4-memo-nat/blob/master/MemoNat/Any.lean\"><code>Any</code></a> type that Kyle suggested, and am living with the universe bump (<a href=\"https://github.com/nomeata/lean4-memo-nat/blob/master/MemoNat/DArray.lean\"><code>DArray</code></a>); would be interesting to know if this can be avoided (with the same efficient representation).</p>\n<p>On top of that, I also have dependent arrays with the length as an index (<a href=\"https://github.com/nomeata/lean4-memo-nat/blob/master/MemoNat/DSArray.lean\"><code>DSArray</code></a>), which incidentally is isomorphic to <code>Nat.below</code>. I need this conversion when replacing <code>Nat.brecEq</code> with my memo combinator, although I fear that this is rather expensive. Maybe I should just use the <code>Nat.below</code> data structure directly in these cases.</p>\n<p>I doubt that this very useful, but it is a useful learning exercise for me…</p>",
        "id": 397948793,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1697985212
    }
]