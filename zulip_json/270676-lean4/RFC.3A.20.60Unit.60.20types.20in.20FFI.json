[
    {
        "content": "<p>At the moment, inductive types like <code>Unit</code> that have a single constructor with no (relevant) fields are represented as a boxed scalar <code>0</code>, including in the FFI. It would be more efficient to not represent these types at runtime (either as function arguments, return values, or in structure fields). Is there any reason that this might be a bad idea?</p>\n<p>Just to be clear, I'm not talking about changing how <code>Unit</code> (and other relevant types) suffice for preserving data dependencies, e.g. for implementing <code>IO</code>. However, at the C language level (and the Lean <code>IR</code> level), pure data dependencies don't really buy you much, and I don't see how this would be useful for enforcing any desirable properties at this level of abstraction.</p>",
        "id": 529954425,
        "sender_full_name": "Cameron Zwarich",
        "timestamp": 1753126495
    },
    {
        "content": "<p>Proofs are also represented as <code>0</code> I think</p>",
        "id": 529954612,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753126599
    },
    {
        "content": "<p><del>i seem to recall this is sometimes done to delay certain computations?</del> i see you already adressed that</p>",
        "id": 529956896,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1753127759
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/270676-lean4/topic/RFC.3A.20.60Unit.60.20types.20in.20FFI/near/529954612\">said</a>:</p>\n<blockquote>\n<p>Proofs are also represented as <code>0</code> I think</p>\n</blockquote>\n<p><code>Prop</code> and type-formers are represented as <code>0</code> (when they are required to be represented). The compiler goes out of its way to extract <code>_redArg</code> versions of Lean functions that omit the irrelevant/unused parameters, and then replaces the original function with a call to the <code>_redArg</code> one, so in most situations they are effectively eliminated.</p>\n<p>For <code>extern</code> functions, they are entirely eliminated. For <code>export</code> functions defined in Lean, they are not eliminated (just like for other Lean functions).</p>",
        "id": 529957172,
        "sender_full_name": "Cameron Zwarich",
        "timestamp": 1753127897
    },
    {
        "content": "<p>I think such a change might be quite disruptive to existing FFI users. Is there any hope of <a href=\"https://github.com/leanprover/lean4/pull/5829\">lean4#5829</a> happening first, so that such ABI changes become API build failure instead of mysterious crashes?</p>",
        "id": 529966716,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753132551
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> The likely disruption is my main hesitation. I did cause some minor ABI breakage in some followup changes to the new compiler switch just by fixing bugs/asymmetries (which would have likely caused some future correctness problems if they weren't fixed), but this would be a different level.</p>\n<p>I was unaware of that issue you filed, so thanks for pointing it out. I'm not sure if it would be sufficient mitigation for the fallout of this change, but I think it would definitely be necessary.</p>",
        "id": 529967567,
        "sender_full_name": "Cameron Zwarich",
        "timestamp": 1753132917
    }
]