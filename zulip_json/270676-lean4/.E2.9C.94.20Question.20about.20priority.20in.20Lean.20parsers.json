[
    {
        "content": "<p>I thought I understood how Lean's parser priority works, but on a complex example, it crumbled. Here is a MWE where it doesn't behave as I would expect it to do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">liftTermElabM</span><span class=\"o\">)</span>\n\n<span class=\"n\">declare_syntax_cat</span><span class=\"w\"> </span><span class=\"n\">expr</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"#demo \"</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span>\n<span class=\"kn\">syntax</span><span class=\"o\">:</span><span class=\"mi\">90</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">expr</span>\n<span class=\"kn\">syntax</span><span class=\"o\">:</span><span class=\"mi\">60</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"o\">:</span><span class=\"mi\">61</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">expr</span>\n\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">elab_expr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">`expr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">CoreM</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">$_</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">()</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">$_</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">args</span><span class=\"o\">:</span><span class=\"n\">expr</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">arg</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"n\">elab_expr</span><span class=\"w\"> </span><span class=\"n\">arg</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwErrorAt</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{repr s}\"</span>\n\n<span class=\"n\">elab_rules</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">demo</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">elab_expr</span><span class=\"w\"> </span><span class=\"n\">expr</span>\n\n<span class=\"bp\">#</span><span class=\"n\">demo</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>Basically, I have a functional programming language-like very simple expression syntax. I've simplified the syntax to a very basic core, where an expression is either a variable, or the application if a variable to any number of arguments.  In my original language, if I wrote <code>f x y</code>, this should be parsed as <code>f</code> applied to <code>x</code> and <code>y</code>, not as <code>f</code> applied to {<code>x</code> applied to <code>y</code>} (I'll use braces to highlight the parsing handles).  To resolve this ambiguity, I've set a higher priority score to the arguments of application than to the application rule itself. So, as far as I understand it, the parse tree <code>{f {x y}}</code> is impossible, because <code>x y : 60</code>, but the rule <code>ident expr:61* → expr:60</code>, the arguments must have at least priority <code>61</code>.  Hence, the only correct parse tree should be <code>{f x y}</code>.</p>\n<p>Yet, in my example, it just doesn't work.  The catchall case in my <code>elab_expr</code> function is reached, and produces</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">raw</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Syntax</span><span class=\"bp\">.</span><span class=\"n\">node</span>\n<span class=\"w\">           </span><span class=\"o\">(</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">SourceInfo</span><span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"o\">)</span>\n<span class=\"w\">           </span><span class=\"ss\">`expr_</span>\n<span class=\"w\">           </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Syntax</span><span class=\"bp\">.</span><span class=\"n\">ident</span>\n<span class=\"w\">               </span><span class=\"o\">(</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">SourceInfo</span><span class=\"bp\">.</span><span class=\"n\">original</span><span class=\"w\"> </span><span class=\"s2\">\"\"</span><span class=\"bp\">.</span><span class=\"n\">toSubstring</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">byteIdx</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">497</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"bp\">.</span><span class=\"n\">toSubstring</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">byteIdx</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">498</span><span class=\"w\"> </span><span class=\"o\">})</span>\n<span class=\"w\">               </span><span class=\"s2\">\"x\"</span><span class=\"bp\">.</span><span class=\"n\">toSubstring</span>\n<span class=\"w\">               </span><span class=\"ss\">`x</span>\n<span class=\"w\">               </span><span class=\"o\">[]]</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>If I remove the <code>:61</code> priority annotation in the function application rule (ie. <code>syntax:60 ident expr:* : expr</code>), then it Just Works™.  I am very much confused by this behavior.</p>",
        "id": 482786216,
        "sender_full_name": "jthulhu",
        "timestamp": 1731776713
    },
    {
        "content": "<p>Part of my misunderstand comes from the fact that <code>#demo f x</code> is actually syntactically correct, so <em>some</em> parse tree must be produced by Lean's parser. Furthermore, I have the impression that I cover all the cases in my exploration of that parse tree, in my <code>elab_expr</code> function.  So it seems strange that the catchall case can be reached at all.</p>",
        "id": 482786573,
        "sender_full_name": "jthulhu",
        "timestamp": 1731777018
    },
    {
        "content": "<p>Your grammar is ambiguous, the first match pattern likely tries to match nullary applications. Try <code>expr:61+</code>?</p>",
        "id": 482787137,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1731777487
    },
    {
        "content": "<p>Indeed, that was it, thanks!  Incidentally, would it be possible for Lean's parser to produce a warning if there is such an ambiguity?</p>",
        "id": 482787321,
        "sender_full_name": "jthulhu",
        "timestamp": 1731777660
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"674423\">jthulhu</span> has marked this topic as resolved.</p>",
        "id": 482787337,
        "sender_full_name": "Notification Bot",
        "timestamp": 1731777667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"674423\">jthulhu</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Question.20about.20priority.20in.20Lean.20parsers/near/482787321\">said</a>:</p>\n<blockquote>\n<p>Indeed, that was it, thanks!  Incidentally, would it be possible for Lean's parser to produce a warning if there is such an ambiguity?</p>\n</blockquote>\n<p>The quotation ideally should do that, yes. Could you please open an issue?</p>",
        "id": 482787493,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1731777800
    },
    {
        "content": "<p>Sure.  Edit: <a href=\"https://github.com/leanprover/lean4/issues/6101\">here it is</a>.</p>",
        "id": 482787513,
        "sender_full_name": "jthulhu",
        "timestamp": 1731777823
    }
]