[
    {
        "content": "<p>Consider a setup like the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"c1\">-- To make sure we have nontrivial equalities</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>\n<p>In other words, <code>B</code> is stronger than <code>A</code> and <code>D</code> is stronger than <code>C</code>, except <code>C</code> is equivalent to <code>D</code> when <code>B</code> holds. In Mathlib we have for example <code>A = Monoid</code>, <code>B = Group</code>, <code>C = IsOrderedMonoid</code> and <code>D = IsOrderedCancelMonoid</code>.</p>\n<p>Now, take a type <code>α</code> for which <code>B α</code> holds but on which <code>C</code> <strong>does not</strong> hold. In the Mathlib example, <code>α = Fin n</code>. Searching for an instance of <code>C α</code> checks if there is a <code>D α</code>, and since we have <code>B α</code>, it loops back to <code>C α</code>. Now tabled instance synthesis correctly realizes that <code>C α</code> is already being searched for, and does not loop forever. This is all expected so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span>\n\n<span class=\"c1\">-- Defining a single instance</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">synthInstance</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">[Meta.synthInstance] ❌️ C (Fin 1) ▼</span>\n<span class=\"cm\">  [] new goal C (Fin 1) ▶</span>\n<span class=\"cm\">  [] ✅️ apply @D.toC to C (Fin 1) ▶</span>\n<span class=\"cm\">  [] ✅️ apply instDOfC to D (Fin 1) ▶</span>\n<span class=\"cm\">  [] result &lt;not-available&gt;</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>But now we have a complication: the instance of <code>B α</code> is built in two steps. First we show <code>A α</code> and then <code>B α</code>. Suddenly the search loops once:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span>\n\n<span class=\"c1\">-- Defining two separate instances</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"c1\">-- Make sure the two instances are equal, modulo instance transparency.</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">toA</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">instAFinOfNatNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">fail_if_success</span><span class=\"w\"> </span><span class=\"n\">with_reducible</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">with_reducible_and_instances</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">synthInstance</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">[Meta.synthInstance] ❌️ C (Fin 2) ▼</span>\n<span class=\"cm\">  [] new goal C (Fin 2) ▶</span>\n<span class=\"cm\">  [] ✅️ apply @D.toC to C (Fin 2) ▶</span>\n<span class=\"cm\">  [] ✅️ apply instDOfC to D (Fin 2) ▶</span>\n<span class=\"cm\">  [] ✅️ apply @D.toC to C (Fin 2) ▶</span>\n<span class=\"cm\">  [] ✅️ apply instDOfC to D (Fin 2) ▶</span>\n<span class=\"cm\">  [] result &lt;not-available&gt;</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>It turns out the first goal <code>C (Fin 2)</code> is more precisely <code>@C (Fin 2) instAFinOfNatNat : Prop</code> and the second goal <code>C (Fin 2)</code> is <code>@C (Fin 2) instBFinOfNatNat_1.toA : Prop</code>. These are apparently considered different by the tabled algorithm, explaining why we loop once.</p>\n<p>The same happens if we are careful to make our instances reducibly defeq:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span>\n\n<span class=\"c1\">-- Defining the instance and a shortcut (as an abbrev)</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">instance</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">instAFinThree</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n\n<span class=\"c1\">-- Now they are really reducibly defeq!</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">toA</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">instAFinThree</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">with_reducible</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">synthInstance</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">[Meta.synthInstance] ❌️ C (Fin 3) ▼</span>\n<span class=\"cm\">  [] new goal C (Fin 3) ▶</span>\n<span class=\"cm\">  [] ✅️ apply @D.toC to C (Fin 3) ▶</span>\n<span class=\"cm\">  [] ✅️ apply instDOfC to D (Fin 3) ▶</span>\n<span class=\"cm\">  [] ✅️ apply @D.toC to C (Fin 3) ▶</span>\n<span class=\"cm\">  [] ✅️ apply instDOfC to D (Fin 3) ▶</span>\n<span class=\"cm\">  [] result &lt;not-available&gt;</span>\n\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>Oops, we still loop!</p>\n<p>This turns out to cause actual performance regressions in Mathlib, for example <a href=\"https://github.com/leanprover-community/mathlib4/pull/32828\">#32828</a> where <code>grind</code> and <code>lia</code> on a goal including <code>Fin</code> take 50% longer, since the PR adds a new instance that makes Lean traverse the <code>AddCancelMonoid</code> hierarchy three times instead of twice(!).</p>",
        "id": 569493182,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1769089468
    },
    {
        "content": "<p>Two questions:</p>\n<ol>\n<li>Is it intentional that tabled typeclass resolution does not look at definitional equalities to prevent loops?</li>\n<li>Does this behaviour mean \"shortcut\" instances (like <code>@[instance] abbrev instAFinThree : A (Fin 3) := inferInstance</code> in the example) are actually an anti-pattern?</li>\n</ol>",
        "id": 569493699,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1769089610
    },
    {
        "content": "<p>The table in tabled type class resolution is a <code>Std.HashMap</code>, which means that looking up in it cannot do any unification. It would be a lot less efficient to use pairwise <code>isDefEq</code> as a lookup mechanism.</p>\n<p>I could imagine a mechanism where the parts of the key that are instances are removed, so that that we can match <code>C (Fin 3)</code> with <code>C (Fin 3)</code> even if the argument instances are the same, and then there would need to be an <code>isDefEq</code> check to verify that the instances are indeed defEq. But I don't know how badly this would affect performance with the extra <code>isDefEq</code>.</p>",
        "id": 569501425,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1769091525
    },
    {
        "content": "<p>Wouldn't it make sense to not even put the <code>isDefEq</code> check because the standing assumption is that instances are unique -- and if in the end it builds an instance which is not correct then error out?</p>",
        "id": 569504261,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1769092210
    },
    {
        "content": "<p>It just so happens to be the case for other reasons that <code>Meta.check</code> is always run on the output of type class search, so with that approach it will be easy to catch type-incorrect terms.</p>",
        "id": 569511589,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1769093891
    },
    {
        "content": "<p>I am also seeing some isDefEq checks on <a href=\"https://github.com/leanprover-community/mathlib4/pull/31603\">#31603</a> that make things slower compared to master:<br>\n<a href=\"/user_uploads/3121/947Sjy1kATHLnR5dl-KilMe2/image.png\">image.png</a><br>\nand adding an shortcut instance doesn't help.<br>\nOn master <code>✅️ Algebra K[X] (RatFunc K)</code> takes 49392 rather than 266803.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/947Sjy1kATHLnR5dl-KilMe2/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1336x902\" src=\"/user_uploads/thumbnail/3121/947Sjy1kATHLnR5dl-KilMe2/image.png/840x560.webp\"></a></div>",
        "id": 569602192,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1769121785
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span>, I think that's not directly related to the problem at hand (and it is to be expected that type class search and/or unification can get slower if you make things reducible).</p>",
        "id": 569603195,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1769122353
    },
    {
        "content": "<p>I remember a long time ago noticing that Lean's type class search can loop forever even though it has this loop protection. Here is an example that I came up with now:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">B'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B'</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">B'</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"c1\">-- (deterministic) timeout</span>\n</code></pre></div>",
        "id": 569603291,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1769122410
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/270676-lean4/topic/Instance.20synth.20cache.20does.20not.20use.20reducible.20defeqs/near/569602192\">said</a>:</p>\n<blockquote>\n<p>On master <code>✅️ Algebra K[X] (RatFunc K)</code> takes 49392 rather than 266803.</p>\n</blockquote>\n<p>(I get <code>[231930.000000] #synth Algebra K[X] (RatFunc K)</code> on master but we should take this elsewhere)</p>",
        "id": 569604563,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769123085
    },
    {
        "content": "<p>266803-231930 is the slight speedup from adding <code>priority := high</code> to all these <a href=\"https://github.com/alreadydone/mathlib4/blob/c3c4dd2bc13e0711723f507b24e7bf97e21f527f/Mathlib/FieldTheory/RatFunc/Basic.lean#L66-L76\">shortcut instances</a>.</p>",
        "id": 569605915,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1769123807
    },
    {
        "content": "<p>I'm just echoing Sébastien's question whether we can delay these defeq checks until the kernel checks the fully elaborated term; they seem to be the main reason for the slowdown.</p>",
        "id": 569606113,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1769123919
    },
    {
        "content": "<p>I tried out Jovan's suggestion of erasing instances from the keys, with mixed results: <a href=\"https://radar.lean-lang.org/repos/mathlib4-nightly-testing/commits/5927bc4a620e2fb2a216c0cc39b0798ce7b1b587?reference=580d15da0f736f4db6eb7d7b6266f02e524d99f7&amp;s=^build/module.*//instructions\">https://radar.lean-lang.org/repos/mathlib4-nightly-testing/commits/5927bc4a620e2fb2a216c0cc39b0798ce7b1b587?reference=580d15da0f736f4db6eb7d7b6266f02e524d99f7&amp;s=^build/module.*//instructions</a></p>\n<p>We get about 0.1% slowdown over all of Mathlib, with some files noticeably slower and other files noticeably faster. Typeclass inference overall slows down by 1.1%, but on the other hand, <code>grind</code> typeclass inference speeds up by 3.6%. I'll try and think about different ways to modify the keys that may be more performant. Otherwise the fix would be redesigning some parts of the hierarchy in Mathlib.</p>",
        "id": 570532751,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1769599973
    }
]