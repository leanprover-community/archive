[
    {
        "content": "<p>I was looking into Lean's core definitions, and I noticed that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.ConstantInfo#doc\">docs#Lean.ConstantInfo</a> had different constructors for definitions and theorems. In particular, definitions were allowed to be annotated with <code>unsafe</code>, <code>partial</code>, <code>opaque</code>, <code>abbrev</code>, and \"definitional heights\", while theorems are not. This was a bit surprising to me, since I previously had thought that <code>theorem</code> was just short for <code>@[irreducible] noncomputable def</code> with the extra caveat that what was after the <code>:=</code> could not influence the type of the theorem.</p>\n<p>What's the reason that we have separate constant kinds for theorems and definitions, rather just banning <code>unsafe theorem</code> and <code>partial theorem</code> at the user interface level? Is the distinction between a theorem and a def used anywhere else?</p>\n<p>As a side question, I noticed there was an option for <code>QuotVal</code>. Is <code>QuotVal</code> basically only used for 4 terms (<code>Quot</code>, <code>Quot.mk</code>, <code>Quot.lift</code>, and <code>Quot.ind</code>), and not supposed to be extended ever?</p>",
        "id": 517232701,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746861050
    },
    {
        "content": "<p><code>theorem</code> is actually more like <code>opaque</code> than <code>def</code></p>",
        "id": 517234735,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746862688
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/270676-lean4/topic/def.20vs.20theorem.20in.20Lean.2EConstantInfo/near/517232701\">said</a>:</p>\n<blockquote>\n<p>As a side question, I noticed there was an option for <code>QuotVal</code>. Is <code>QuotVal</code> basically only used for 4 terms (<code>Quot</code>, <code>Quot.mk</code>, <code>Quot.lift</code>, and <code>Quot.ind</code>), and not supposed to be extended ever?</p>\n</blockquote>\n<p>yes</p>",
        "id": 517234773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746862726
    },
    {
        "content": "<p>Between <code>irreducible_def</code>, <code>@[irreducible] def</code>, <code>opaque</code>, and <code>theorem</code>, which of them are allowed to be unfolded by the elaborator, and which of them can be unfolded by the kernel?</p>",
        "id": 517234926,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746862859
    },
    {
        "content": "<p>only <code>@[irreducible] def</code> can be unfolded by the kernel. <code>irreducible_def</code> can technically also be unfolded but only because it's a thin wrapper around an <code>opaque</code> and the wrapper can be unwrapped</p>",
        "id": 517235021,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746862923
    },
    {
        "content": "<p>the elaborator can unfold strictly less than the kernel, and will not unfold irreducible defs unless you ask really strongly</p>",
        "id": 517235067,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746862957
    },
    {
        "content": "<p>so, once you define a <code>theorem</code>, like <code>theorem x : Nat := 2</code>, it's completely impossible to use the actual value  <code>2</code> in any way?</p>",
        "id": 517235258,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746863111
    },
    {
        "content": "<p><code>irreducible_def foo : Nat := 1</code> is a macro that elaborates to roughly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">core</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">core</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">def_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">core</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n</code></pre></div>\n<p>and it has the same unfolding semantics as this would imply</p>",
        "id": 517235268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746863120
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/270676-lean4/topic/def.20vs.20theorem.20in.20Lean.2EConstantInfo/near/517235258\">said</a>:</p>\n<blockquote>\n<p>so, once you define a <code>theorem</code>, like <code>theorem x : Nat := 2</code>, it's completely impossible to use the actual value  <code>2</code> in any way?</p>\n</blockquote>\n<p>The kernel also checks that a theorem has a type whose type is <code>Prop</code>, so this is not allowed</p>",
        "id": 517235307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746863158
    },
    {
        "content": "<p>but you can use proofs in positions where they would otherwise be unfolded and observe that in those cases <code>theorem</code> will block unfolding</p>",
        "id": 517235440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746863260
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/def.20vs.20theorem.20in.20Lean.2EConstantInfo/near/517235268\">said</a>:</p>\n<blockquote>\n<p><code>irreducible_def foo : Nat := 1</code> is a macro that elaborates to roughly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">core</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">core</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">def_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">core</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n</code></pre></div>\n<p>and it has the same unfolding semantics as this would imply</p>\n</blockquote>\n<p>That makes a lot of sense, thanks. For the longest time I thought that <code>irreducible_def</code> was the same as <code>@[irreducible] def</code> but it seems that's not the case. Which of them does <code>unseal</code> work with again? And is <code>abbrev</code> different from <code>@[reducible] def</code>?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/def.20vs.20theorem.20in.20Lean.2EConstantInfo/near/517235307\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/270676-lean4/topic/def.20vs.20theorem.20in.20Lean.2EConstantInfo/near/517235258\">said</a>:</p>\n<blockquote>\n<p>so, once you define a <code>theorem</code>, like <code>theorem x : Nat := 2</code>, it's completely impossible to use the actual value  <code>2</code> in any way?</p>\n</blockquote>\n<p>The kernel also checks that a theorem has a type whose type is <code>Prop</code>, so this is not allowed</p>\n</blockquote>\n<p>I probably should have checked that, but yeah, that makes sense.</p>",
        "id": 517235500,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746863285
    },
    {
        "content": "<p>So, is <code>theorem</code> basically the same as <code>noncomputable opaque def</code>, and if so, why do we still need a separate <code>TheoremVal</code> in <code>ConstantInfo</code>?</p>",
        "id": 517235580,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746863364
    },
    {
        "content": "<p>There are a few cases of theorems which are deliberately defs like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=InvImage.accessible#doc\">docs#InvImage.accessible</a> to allow them to unfold (mathlib has a linter that would warn on these)</p>",
        "id": 517235590,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746863374
    },
    {
        "content": "<p><code>unseal</code> locally suppresses the <code>@[irreducible]</code> annotation effect</p>",
        "id": 517235661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746863425
    },
    {
        "content": "<p><code>opaque</code> is ironclad, there is no way you can undo this later</p>",
        "id": 517235690,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746863448
    },
    {
        "content": "<p>although you can use <code>native_decide</code> to prove things about an opaque definition by evaluating it on closed terms</p>",
        "id": 517235727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746863469
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/270676-lean4/topic/def.20vs.20theorem.20in.20Lean.2EConstantInfo/near/517235500\">said</a>:</p>\n<blockquote>\n<p>And is <code>abbrev</code> different from <code>@[reducible] def</code>?</p>\n</blockquote>\n<p>IIRC <code>abbrev</code> is <code>@[reducible, inline] def</code></p>",
        "id": 517235817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746863528
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/def.20vs.20theorem.20in.20Lean.2EConstantInfo/near/517235817\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/270676-lean4/topic/def.20vs.20theorem.20in.20Lean.2EConstantInfo/near/517235500\">said</a>:</p>\n<blockquote>\n<p>And is <code>abbrev</code> different from <code>@[reducible] def</code>?</p>\n</blockquote>\n<p>IIRC <code>abbrev</code> is <code>@[reducible, inline] def</code></p>\n</blockquote>\n<p>That's interesting, because the definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.ReducibilityHints#doc\">docs#Lean.ReducibilityHints</a> is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">ReducibilityHints</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">opaque</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ReducibilityHints</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">abbrev</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ReducibilityHints</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">regular</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt32</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ReducibilityHints</span>\n</code></pre></div>",
        "id": 517235855,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746863580
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/270676-lean4/topic/def.20vs.20theorem.20in.20Lean.2EConstantInfo/near/517235580\">said</a>:</p>\n<blockquote>\n<p>So, is <code>theorem</code> basically the same as <code>noncomputable opaque def</code>, and if so, why do we still need a separate <code>TheoremVal</code> in <code>ConstantInfo</code>?</p>\n</blockquote>\n<p>Well as I mentioned there is a single extra check, but yeah it's a bit redundant; this distinction has been around since the beginning and I don't think there is a strong argument for it</p>",
        "id": 517235893,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746863615
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/270676-lean4/topic/def.20vs.20theorem.20in.20Lean.2EConstantInfo/near/517235855\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/def.20vs.20theorem.20in.20Lean.2EConstantInfo/near/517235817\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/270676-lean4/topic/def.20vs.20theorem.20in.20Lean.2EConstantInfo/near/517235500\">said</a>:</p>\n<blockquote>\n<p>And is <code>abbrev</code> different from <code>@[reducible] def</code>?</p>\n</blockquote>\n<p>IIRC <code>abbrev</code> is <code>@[reducible, inline] def</code></p>\n</blockquote>\n<p>That's interesting, because the definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.ReducibilityHints#doc\">docs#Lean.ReducibilityHints</a> is</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">ReducibilityHints</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">opaque</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ReducibilityHints</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">abbrev</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ReducibilityHints</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">regular</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt32</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ReducibilityHints</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>not to be confused with those!</p>",
        "id": 517235910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746863631
    },
    {
        "content": "<p><code>@[reducible]</code> the annotation and <code>.abbrev</code> the reducibility hint are entirely unrelated</p>",
        "id": 517235967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746863651
    },
    {
        "content": "<p>It's confusing, I know</p>",
        "id": 517235979,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746863669
    },
    {
        "content": "<p>Users mainly interact with the annotations. The reducibility hints impact the kernel's heuristic on how to unfold definitions in defeq problems and I don't think there is a particularly clear specification on how the porcelain commands decide to assign those hints</p>",
        "id": 517236102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746863772
    },
    {
        "content": "<p>Wait, so if you do <code>@[irreducible] def</code>, that gives it an annotation which the elaborator can use whenever it feels like and doesn't affect the kernel, and doesn't mess with Reducibility Hints, right? And if you do <code>opaque def</code> or <code>opaque</code> (which are the same thing?) then it actually sets the reducibility hint to <code>opaque</code>?</p>\n<p>But doing <code>abbrev</code> sets an annotation and doesn't affect the reducibility hint?</p>",
        "id": 517236116,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746863787
    },
    {
        "content": "<p>Ah, actually now that I say that I think one of the effects of the <code>@[reducible]</code> annotation is to set the reducibility hint to <code>.abbrev</code></p>",
        "id": 517236142,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746863827
    },
    {
        "content": "<p>and ditto for <code>@[irreducible]</code> using <code>.opaque</code></p>",
        "id": 517236159,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746863843
    },
    {
        "content": "<p>wait, so reducibility hints are different from annotations which are different from whether or not a definition is opaque?</p>",
        "id": 517236176,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746863859
    },
    {
        "content": "<p>yes <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 517236181,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746863869
    },
    {
        "content": "<p>oh right I see now that <code>opaque</code> has its own constantinfo type</p>",
        "id": 517236185,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746863875
    },
    {
        "content": "<p>this is significantly more confusing than I thought it was</p>",
        "id": 517236235,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746863889
    },
    {
        "content": "<p>I don't know why I thought I understood all this earlier</p>",
        "id": 517236252,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746863898
    },
    {
        "content": "<p>opaques simply can't be unfolded at all, defs have the annotation for controlling elaborator unfolding and the reducibility hint for controlling kernel unfolding</p>",
        "id": 517236335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746863926
    },
    {
        "content": "<p>and you will notice the <code>.regular n</code> hint comes with another voodoo number, the \"definition depth\", which is something like the max of the depths of all definitions in the body + 1</p>",
        "id": 517236458,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746864008
    },
    {
        "content": "<p>and is <code>opaque def</code> the same as <code>opaque</code>?</p>",
        "id": 517236489,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746864028
    },
    {
        "content": "<p>is that a thing?</p>",
        "id": 517236506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746864040
    },
    {
        "content": "<p>I think it's just <code>opaque</code></p>",
        "id": 517236511,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746864050
    },
    {
        "content": "<p>yeah you're right. I guess I used to think of <code>opaque</code> as a modifier, and that's why I got confused</p>",
        "id": 517236554,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746864089
    },
    {
        "content": "<p>I think of <code>opaque</code> as a mashup of <code>axiom</code> and <code>def</code></p>",
        "id": 517236577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746864118
    },
    {
        "content": "<p>it's a <code>def</code> at the definition site and an <code>axiom</code> from the perspective of everything that comes after</p>",
        "id": 517236624,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746864138
    },
    {
        "content": "<p>how do you set the reducibility hint of a <code>def</code> to <code>opaque</code>?</p>",
        "id": 517236684,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746864187
    },
    {
        "content": "<p><code>@[irreducible]</code> should do that</p>",
        "id": 517236695,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746864207
    },
    {
        "content": "<p>but you can also decide to set the hint to whatever you want if you are making a tactic that creates a definition</p>",
        "id": 517236812,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746864267
    },
    {
        "content": "<p>so, <code>@[irreducible]</code> is used to control the elaborator, but setting it modifies the reducibility hint as well</p>",
        "id": 517236819,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746864271
    },
    {
        "content": "<p>ah, just read the code. Neither <code>@[reducible]</code> nor <code>@[irreducible]</code> affects the reducibility hint, however <code>abbrev</code> (the command) sets the reducibility hint to <code>.abbrev</code> and <code>def</code> (regardless of attributes) uses <code>.regular</code></p>",
        "id": 517237366,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746864691
    },
    {
        "content": "<p>So here's my understanding right now: There are three different controls for \"level of reducibility\", the ironclad ConstantKind, the reducibility hint for kernel unfolding control, and annotations for elaborator unfolding control.</p>\n<p>Whether you use <code>def</code>, <code>theorem</code>, or <code>opaque</code> determines the ConstantKind. In contrast, <code>abbrev</code> is <em>not</em> a ConstantKind. The kernel will never unfold <code>opaque</code> no matter how hard you try. <code>theorem</code> is like <code>opaque</code> except it can't be unsafe and the kernel will check to make sure its type has type <code>Prop</code>.</p>\n<p><del>All three of <code>def</code>, <code>theorem</code>, and <code>opaque</code> can have <code>@[reducible]</code> and <code>@[irreducible]</code> annotations, although in practice they only matter for <code>def</code></del>. Only <code>def</code> can have the elaborator unfolding annotations <code>@[reducible]</code>, <code>@[semireducible]</code>, <code>@[irreducible]</code>. Setting these annotations provides a strong suggestion to the elaborator (and by extension, tactics) to unfold or not unfold these terms when checking defeq.</p>\n<p>Only <code>def</code> supports reducibility hints. These are named <code>.opaque</code> and <code>.abbrev</code>, but don't have anything to do with <code>opaque</code> (they do have something to do with <code>abbrev</code> though). These control the <em>performance</em> of the kernel, but ultimately won't affect whether or not the kernel succeeds.</p>\n<p>Commands:</p>\n<ul>\n<li><code>abbrev</code> is like <code>def</code> but gives it both a <code>@[reducible, inline]</code> annotation and a <code>.abbrev</code> reducibility hint</li>\n<li><code>irreducible_def</code> is a mathlib-specific command that uses <code>opaque</code> behind the scenes, but does so using a subtype so that the original definition is still accessible with a theorem.</li>\n</ul>",
        "id": 517237737,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746864965
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/270676-lean4/topic/def.20vs.20theorem.20in.20Lean.2EConstantInfo/near/517237737\">said</a>:</p>\n<blockquote>\n<p>All three of <code>def</code>, <code>theorem</code>, and <code>opaque</code> can have <code>@[reducible]</code> and <code>@[irreducible]</code> annotations, although in practice they only matter for <code>def</code>.</p>\n</blockquote>\n<p>Actually <code>@[reducible] theorem</code> is rejected and ditto for the other nonsensical combinations</p>",
        "id": 517238146,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746865243
    },
    {
        "content": "<p>is <code>@[irreducible] theorem</code> rejected, or is this automatic? what about <code>@[irreducible] opaque</code>?</p>",
        "id": 517238199,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746865296
    },
    {
        "content": "<p>both are rejected</p>",
        "id": 517238228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746865318
    },
    {
        "content": "<p>the error message says these only work on definitions</p>",
        "id": 517238276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746865330
    },
    {
        "content": "<p>I see</p>",
        "id": 517238283,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746865340
    },
    {
        "content": "<p><code>@[reducible] abbrev</code>, <code>@[semireducible] abbrev</code>, <code>@[irreducible] abbrev</code> also fail for different reasons</p>",
        "id": 517238298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746865357
    },
    {
        "content": "<p>this one looks more like a bug, the error message suggests it did not expect to be in this situation</p>",
        "id": 517238327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746865387
    },
    {
        "content": "<p>how much of this is supposed to be considered an implementation detail? I might submit a request for some of this to be documented in the reference manual</p>",
        "id": 517238438,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746865479
    },
    {
        "content": "<p>My impression is that the stuff about reducibility hints is mostly impl details</p>",
        "id": 517238465,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746865516
    },
    {
        "content": "<p>the rest is user facing</p>",
        "id": 517238479,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746865525
    },
    {
        "content": "<p>The current reference manual at <a href=\"https://lean-lang.org/doc/reference/latest//Definitions/Definitions/#The-Lean-Language-Reference--Definitions--Definitions\">https://lean-lang.org/doc/reference/latest//Definitions/Definitions/#The-Lean-Language-Reference--Definitions--Definitions</a> seems to suggest that <code>abbrev</code> is a definition kind on the same level as <code>theorem</code>, <code>def</code>, and <code>opaque</code>. Is this misleading or the intended interpretation?</p>",
        "id": 517238571,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746865590
    },
    {
        "content": "<p>I think that's a reasonable user-level description, it is a top level command after all</p>",
        "id": 517238622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746865638
    },
    {
        "content": "<p>the variants of <code>ConstantInfo</code> are also kind of impl detail</p>",
        "id": 517238647,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746865676
    },
    {
        "content": "<p>I guess maybe the documentation is alright after all</p>",
        "id": 517238672,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746865683
    },
    {
        "content": "<p>these details are important if you are working at the metaprogramming layer, but not the user layer</p>",
        "id": 517238719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746865716
    },
    {
        "content": "<p>Maybe i'll file an issue on the metaprogramming book repository linking back to this thread</p>",
        "id": 517238762,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746865771
    },
    {
        "content": "<p>Thank you for the explanations!</p>",
        "id": 517238903,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746865870
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> has marked this topic as resolved.</p>",
        "id": 517239390,
        "sender_full_name": "Notification Bot",
        "timestamp": 1746866283
    }
]