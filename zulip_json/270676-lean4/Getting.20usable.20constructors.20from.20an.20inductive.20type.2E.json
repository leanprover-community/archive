[
    {
        "content": "<p>Say I have the following inductive datatype</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>how can I, from say CommandElabM, get a list of constructors whose return type unifies with <code>Vec a n</code> for some a n.</p>\n<p>For example <code>Vec Nat 0</code> can't unify with <code>Vec a (n+1)</code>, so using <code>cons</code> is impossible. I believe lean should already do this internally for exhaustiveness checking.</p>\n<p>Ultimately I want to calculate the number of bits to encode an inductive datatype, but a naive approach doesn't account for dependent inductive types, i.e <code>Vec Bool 3</code> requires more bits then <code>Bool × Bool × Bool</code> when done naively.</p>",
        "id": 453643121,
        "sender_full_name": "ohhaimark",
        "timestamp": 1721813119
    }
]