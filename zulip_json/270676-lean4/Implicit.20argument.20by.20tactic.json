[
    {
        "content": "<p>How might one define a notation where an argument is filled at use-time by a tactic execution?</p>",
        "id": 471597023,
        "sender_full_name": "Cody Roux",
        "timestamp": 1726801867
    },
    {
        "content": "<p>Is this what you're describing? <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Implicit.20evidences.20with.20simp.20proofs/near/462600813\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/.E2.9C.94.20Implicit.20evidences.20with.20simp.20proofs/near/462600813</a></p>",
        "id": 471599158,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1726802625
    },
    {
        "content": "<p>Yep, coolio. Don't understand the evaluation semantics of default args though. Are they all lazy like this?</p>",
        "id": 471762948,
        "sender_full_name": "Cody Roux",
        "timestamp": 1726846352
    },
    {
        "content": "<p>I believe that <code>(h : T := t)</code> and <code>(h : T := by tac)</code> are treated quite/completely differently by Lean.</p>",
        "id": 471764396,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1726846807
    },
    {
        "content": "<p>If you write <code>(h : T := t)</code>, then <code>t</code> has to make sense and have a correct type at the moment of declaration of your lemma/def. If you write <code>(h : T := by tac)</code>, then it is stored as a <code>Syntax</code>, then executed whenever you <code>apply</code> your lemma.</p>",
        "id": 471783460,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1726851992
    }
]