[
    {
        "content": "<p>I decided on <code>Finset.sort</code> which broke in the recent Lean 4.19 update. This is an MRE of the issue:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">([</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mergeSort</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">mergeSort</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">kernel</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">tactic 'decide' failed for proposition</span>\n<span class=\"cm\">  ([1].mergeSort fun x1 x2 =&gt; decide (x1 ≤ x2)) = [1]</span>\n<span class=\"cm\">since its 'Decidable' instance</span>\n<span class=\"cm\">  instDecidableEqList ([1].mergeSort fun x1 x2 =&gt; decide (x1 ≤ x2)) [1]</span>\n<span class=\"cm\">did not reduce to 'isTrue' or 'isFalse'.</span>\n\n<span class=\"cm\">Reduction got stuck at the 'Decidable' instance</span>\n<span class=\"cm\">  ([1].mergeSort fun x1 x2 =&gt; decide (x1 ≤ x2)).hasDecEq [1]</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">([</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mergeSort</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">kernel</span>\n</code></pre></div>",
        "id": 511848356,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1744495520
    },
    {
        "content": "<p>In the past I think the suggestion was to keep these functions defined in a way that <em>is</em> reducible, and then use <code>csimp</code> to link them to their irreducible optimized versions.</p>",
        "id": 511849987,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744497207
    },
    {
        "content": "<p>I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.mergeSort#src\">src#List.mergeSort</a> hasn't changed, but the rules for reducibility have</p>",
        "id": 511850163,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744497373
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/270676-lean4/topic/opaque.20recursion.20definitions.20break.20mergeSort.20decidability/near/511849987\">said</a>:</p>\n<blockquote>\n<p>In the past I think the suggestion was to keep these functions defined in a way that <em>is</em> reducible, and then use <code>csimp</code> to link them to their irreducible optimized versions.</p>\n</blockquote>\n<p>I do believe that <a href=\"https://github.com/leanprover/lean4/blob/fafd381c90598fe9969f3cb8f1df9b3d1b87a219/src/Init/Data/List/Sort/Impl.lean#L234-L236\">mergeSort already has a irreducible optimized version linked by <code>csimp</code></a></p>",
        "id": 511857963,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1744504892
    },
    {
        "content": "<p>I believe the rules for reducibility changed (which broke this well-founded definition of List.mergeSort) changed in <a href=\"https://github.com/leanprover/lean4/pull/5182\">#5182</a>.</p>",
        "id": 511858212,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1744505076
    },
    {
        "content": "<p>I don't know much of anything regarding reducibility with <code>csimp</code>, but given that <code>List.mergeSort</code> already has a <code>csimp</code>-linked tail-recursive definition, would it make sense to mark it as semireducible?</p>",
        "id": 511858507,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1744505314
    },
    {
        "content": "<p>Actually, should <code>decide</code> follow <code>csimp</code> marked theorems?</p>",
        "id": 511891563,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1744536421
    },
    {
        "content": "<p>I don't think that would be useful, the runtime-optimal version is less likely to reduce well</p>",
        "id": 511899036,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744542880
    },
    {
        "content": "<p>And following them in reverse would also not be very useful, because the runtime version should never appear in any theorem statements</p>",
        "id": 511899052,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744542902
    },
    {
        "content": "<p>Copying from a discussion with <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> right now</p>\n<blockquote>\n<p>Oof, is there really no way of making it temporarily semireducible after the fact for decide?</p>\n</blockquote>\n<p>Yes, and after having tiptoed around this issue for a while I believe that reducing proofs in the kernel (as it necessary for well-founded recursion) is just too big of a footgun to be allowed. It may have worked ok in a number of cases so far, but every so often it goes horribly wrong (kernel heartbeat timeout, hard to debug). <br>\nAlso with the upcoming module system we really want proofs to be irrelevant, so that they can be omitted from interface files, maybe even omitted from downloaded olean etc. <br>\nSo the conclusion is that well-founded recursion should only be used when you really only care about the  classical existence of a function with that specification, and never when you want to get any kind of useful defeqs.</p>\n<p>So conversely, if you have a function that you want to have useful defeqs, then don't use well-founded recursion. One way is to use a helper definition that is built to reduce nicely, e.g. using fuel, like I did here: <a href=\"https://github.com/leanprover/lean4/pull/7558\">https://github.com/leanprover/lean4/pull/7558</a></p>\n<p>This should be possible for any function that's currently defined by wf recursion with a single  Nat measure.</p>\n<p>We could even consider having a termination_by fuel … variant that uses that construction internally. </p>\n<p>(I don’t know how well this fares when reducing larger inputs, because I assume that although it won’t reduce proofs, the kernel will still construct a large proof for the fuel argument, so it may not scale to large number of recursions either.)</p>\n<p>Another alternative is not to use decide, but rewriting, when doing the proof. But I understand that our rewriting tractics (simp, rw) are not great for the use case of “do cbv normalization by rewriting” yet. I did some steps in that direction in <a href=\"https://github.com/leanprover/lean4/pull/5977\">https://github.com/leanprover/lean4/pull/5977</a>, but it wasn't quite convincing yet.</p>\n<p>I agree that this is all a bit unsatisfactory until we are weaned off reducing wf proofs…</p>\n<blockquote>\n<p>This is orthogonal, but I don't actually understand why reducing defs which use wfrec needs reduction of proofs at all?</p>\n</blockquote>\n<p>Defs using well-founded recursion use <code>WellFounded.fix</code> which is essentially structural recursion on the <code>Acc</code> predicate, and to reduce these definitions by more than one step, the proof of <code>Acc x y</code> needs to be reduce to the <code>Acc.intro</code> constructor. Depending how your well-founded definition is defined, this may involve reducing <code>Nat.le</code> or stuff like that, and can be very expensive, exponential even.</p>\n<p>You can kick the can down the road by identifying all affected functions, define them as <code>semireducible</code>, and then right afterwards use <code>attribute [irreducible] foo</code>. This gives you the old behavior and you don’t need to fix all at once.</p>\n<p>It works sometimes (for example, for technical reasons one unfolding is actually free), and when it works it’s annoyingly useful. But it shot a few legs, so we’d really like to pretend it never worked at all :-)</p>",
        "id": 511916502,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1744557519
    },
    {
        "content": "<p>If we really actually make Acc reduction not work, maybe we can finally actually fix the core reason why lean has undecidable typechecking and rip this out of the kernel?</p>",
        "id": 511932694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744570382
    },
    {
        "content": "<p><del>(what is Acc reduction?)</del> i should read <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span></p>",
        "id": 511933894,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744571351
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/opaque.20recursion.20definitions.20break.20mergeSort.20decidability/near/511932694\">said</a>:</p>\n<blockquote>\n<p>If we really actually make Acc reduction not work, maybe we can finally actually fix the core reason why lean has undecidable typechecking and rip this out of the kernel?</p>\n</blockquote>\n<p><del>Why</del></p>",
        "id": 511959921,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744592222
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/opaque.20recursion.20definitions.20break.20mergeSort.20decidability/near/511932694\">said</a>:</p>\n<blockquote>\n<p>If we really actually make Acc reduction not work, maybe we can finally actually fix the core reason why lean has undecidable typechecking and rip this out of the kernel?</p>\n</blockquote>\n<p>Just to avoid confusion, what precisely is “this”? </p>\n<p>(I can’t answer your question, but maybe we can at least make it an option by eventually removing all uses of reducible wf rec.)</p>",
        "id": 512037088,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1744624733
    },
    {
        "content": "<p>I'm thinking to change the inductive schema so that types like Acc do not have an iota rule, but possibly give you an iota axiom instead</p>",
        "id": 512049364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744628734
    },
    {
        "content": "<p>which is hopefully enough to prove <code>WellFounded.fix</code></p>",
        "id": 512049601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744628790
    },
    {
        "content": "<p>While we are at it: What do you think of <a href=\"https://github.com/leanprover/lean4/issues/5234\">https://github.com/leanprover/lean4/issues/5234</a>, <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> ? <br>\nSummary: When the measure of wf-recursion is just one <code>Nat</code> (not lexicographic, not a different order), use a Nat-specific  fix-point operator that is a drop-in replacement for <code>WellFounded.fix</code>, but implemented by using <code>Nat.rec</code> on fuel that’s initialized by the measure.</p>\n<p>It seems that this would be simple to implement, would let <code>decide</code> work for many (but not all) wf-rec function, and would avoid most (bot not all) “reduction bombs” because for neutral arguments, the intial fuel is neutral and reduction gets stuck, as it should.</p>",
        "id": 512097028,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1744641533
    },
    {
        "content": "<p>I don't see why to specialize on Nat here, you can do the same thing for any inductive type</p>",
        "id": 512098427,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744641844
    },
    {
        "content": "<p>I'm sad about the general direction, it's making well founded recursion turn into a big bugaboo and discouraging people from using it</p>",
        "id": 512098763,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744641931
    },
    {
        "content": "<p>I’m not particularly happy either (besides that this will make proofs even more irrelevant, which is great for the upcoming module system, smaller <code>olean</code>, less recompilation, and that we hopefully get rid of this sometimes hard-to-debug “reduction bombs”)</p>",
        "id": 512112960,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1744645165
    },
    {
        "content": "<p>I definitely think proofs should be irrelevant but I don't see why that means wf recursion has to suck</p>",
        "id": 512113060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744645199
    },
    {
        "content": "<p>this should never have been implemented by reducing proofs in the first place</p>",
        "id": 512113184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744645222
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/opaque.20recursion.20definitions.20break.20mergeSort.20decidability/near/512098427\">said</a>:</p>\n<blockquote>\n<p>I don't see why to specialize on Nat here, you can do the same thing for any inductive type</p>\n</blockquote>\n<p>Can you? Maybe with an inductive type where the <code>&lt;</code> relation that’s picked up by <code>WellFoundedRelation</code> contains the subterm-relation, unless I am missing something. Do you have concrete examples in mind?</p>",
        "id": 512113609,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1744645354
    },
    {
        "content": "<p>I was thinking you would not use a well founded relation at all, you would just use the subterm relation on an inductive type</p>",
        "id": 512113714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744645393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/opaque.20recursion.20definitions.20break.20mergeSort.20decidability/near/512113184\">said</a>:</p>\n<blockquote>\n<p>this should never have been implemented by reducing proofs in the first place</p>\n</blockquote>\n<p>What are the alternatives? We once discussed a world where <code>Acc.rec</code> reduces always, without looking at the<code>Acc</code> proof, but doesn’t that make the problem of the kernel reducing things ad infinitum even worse?</p>",
        "id": 512114055,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1744645496
    },
    {
        "content": "<p>you could reduce only closed terms</p>",
        "id": 512114390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744645586
    },
    {
        "content": "<p>I think we should kind of set <code>Acc</code> aside, because we actually care more about <code>WellFounded</code> (they are equivalent in strength) and <code>WellFounded</code> doesn't have the issue of a monotonically increasing proof term during reduction</p>",
        "id": 512114918,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744645745
    },
    {
        "content": "<p>I think we're just reinventing fix + match here, we should just check what Rocq does</p>",
        "id": 512115085,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744645797
    },
    {
        "content": "<p>Rocq has an in-kernel termination checker (the “guardedness checker”), AFAIR</p>",
        "id": 512115693,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1744645960
    },
    {
        "content": "<p>yeah but that's sort of separate from this</p>",
        "id": 512115746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744645982
    },
    {
        "content": "<p>the question is more about when reduction happens</p>",
        "id": 512115780,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744645995
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/opaque.20recursion.20definitions.20break.20mergeSort.20decidability/near/512114918\">said</a>:</p>\n<blockquote>\n<p>I think we should kind of set <code>Acc</code> aside, because we actually care more about <code>WellFounded</code> (they are equivalent in strength) and <code>WellFounded</code> doesn't have the issue of a monotonically increasing proof term during reduction</p>\n</blockquote>\n<p>I’m sorry, but I think you have to spell this out some more for me. Is there another definition of <code>WellFounded</code> that doesn’t go through <code>Acc</code> and allows for recursion somehow?</p>",
        "id": 512116452,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1744646201
    },
    {
        "content": "<p>I think the definition of <code>WellFounded</code> is an implementation detail, it could be built in axiomatic</p>",
        "id": 512116569,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744646232
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/opaque.20recursion.20definitions.20break.20mergeSort.20decidability/near/512116569\">said</a>:</p>\n<blockquote>\n<p>I think the definition of <code>WellFounded</code> is an implementation detail, it could be built in axiomatic</p>\n</blockquote>\n<p>How?</p>",
        "id": 512116827,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744646289
    },
    {
        "content": "<p>That is, <code>WellFounded</code> is a primitive axiomatic constructor and so is <code>WellFounded.fix</code> and it has magic computation rules provided by the kernel. Whether it gets these computation rules because it's built in or because it has a definition that works out that way doesn't really matter for things built on top</p>",
        "id": 512133584,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744650608
    },
    {
        "content": "<p>My point is that <code>WellFounded.fix</code> has better definitional reduction rules than <code>Acc.rec</code> does because <code>Acc</code> needs to manipulate a proof term in every step of the recursion</p>",
        "id": 512133755,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744650675
    },
    {
        "content": "<p>ok, but then will we be able to create instances for <code>WellFounded</code>?</p>",
        "id": 512133998,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744650752
    },
    {
        "content": "<p>sure, it can have a constructor that looks like <code>WellFounded.mk</code> too</p>",
        "id": 512134054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744650773
    },
    {
        "content": "<p>I'm saying to separate the API from the implementation</p>",
        "id": 512134119,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744650797
    },
    {
        "content": "<p>i guess that makes sense</p>",
        "id": 512134358,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744650863
    },
    {
        "content": "<p>the API of <code>WellFounded</code> includes <code>WellFounded.mk</code> and <code>WellFounded.fix</code> and possibly a defeq that looks like <code>WellFounded.fix_eq</code>, so it's worth talking about what kind of API here and what kind of restrictions on <code>fix_eq</code> give desirable behaviors for things on top</p>",
        "id": 512134392,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744650875
    },
    {
        "content": "<p>and if at the end of that it turns out it can be defined in terms of something more basic, great, but if not, it can still be a built in primitive supplied by the kernel</p>",
        "id": 512134469,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744650903
    },
    {
        "content": "<p><code>Acc</code> is already super special and complicates the inductive schema for a case which has essentially only one practical application</p>",
        "id": 512134603,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744650953
    },
    {
        "content": "<p>I would definitely trade having a simpler schema in exchange for needing another magic special type like <code>Quot</code></p>",
        "id": 512134718,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744650984
    },
    {
        "content": "<p>does making WellFounded internal/axiomatic let us make sure something like <code>Acc</code>  can't be created, though?</p>",
        "id": 512134745,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744650993
    },
    {
        "content": "<p>yeah, we would ban types like it and/or make them have crappy defeqs</p>",
        "id": 512134817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744651022
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/270676-lean4/topic/opaque.20recursion.20definitions.20break.20mergeSort.20decidability/near/512134745\">said</a>:</p>\n<blockquote>\n<p>does making WellFounded internal/axiomatic let us make sure something like <code>Acc</code>  can't be created, though?</p>\n</blockquote>\n<p>You can do something like saying the subtype of stuff less than <code>x</code> is well-founded</p>",
        "id": 512134912,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744651053
    },
    {
        "content": "<p>if it wasn't for <code>Acc</code> -&gt; <code>WellFounded</code> -&gt; every wf rec definition ever, we wouldn't care about <code>Acc</code> at all</p>",
        "id": 512134943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744651067
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/opaque.20recursion.20definitions.20break.20mergeSort.20decidability/near/512134943\">said</a>:</p>\n<blockquote>\n<p>if it wasn't for <code>Acc</code> -&gt; <code>WellFounded</code> -&gt; every wf rec definition ever, we wouldn't care about <code>Acc</code> at all</p>\n</blockquote>\n<p>We have this one file <a href=\"https://tqft.net/mathlib4files/SetTheory/Ordinal/Rank\">file#SetTheory/Ordinal/Rank</a></p>",
        "id": 512135347,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744651184
    },
    {
        "content": "<p>Also, keep in mind that \"<code>Acc</code> in <code>Type</code>\" is one way of neutering <code>Acc</code> by making it act like a regular inductive</p>",
        "id": 512135466,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744651217
    },
    {
        "content": "<p>and in the presence of the axiom of choice you can go back and forth with something that has the type of the current <code>Acc</code></p>",
        "id": 512135549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744651247
    },
    {
        "content": "<p>so I think that rank file would be fine</p>",
        "id": 512135568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744651253
    },
    {
        "content": "<p>what is special about current <code>Acc</code>? as far as i can tell it's really just a normal inductive, so i don't get how you would even begin to ban \"inductives like it\"</p>",
        "id": 512136205,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744651443
    },
    {
        "content": "<p>It's a large eliminating subsingleton type</p>",
        "id": 512136247,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744651462
    },
    {
        "content": "<p>it's large eliminating!?</p>",
        "id": 512136304,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744651481
    },
    {
        "content": "<p>it's the only large eliminating <em>recursive</em> inductive type in lean</p>",
        "id": 512136372,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744651505
    },
    {
        "content": "<p>ah, i missed that bit</p>",
        "id": 512136382,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744651511
    },
    {
        "content": "<p>so you don't even get to define something like <code>Acc</code> in lean as-is? that clears it up a bunch</p>",
        "id": 512136475,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744651559
    },
    {
        "content": "<p>Equality is also a large eliminating inductive, but it's not recursive</p>",
        "id": 512136534,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744651566
    },
    {
        "content": "<p>No, you can define something like Acc</p>",
        "id": 512136600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744651585
    },
    {
        "content": "<p>because it's not actually special cased</p>",
        "id": 512136636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744651595
    },
    {
        "content": "<p>but there is an additional clause in the inductive schema which allows \"Acc and things like it\" but in practice that means just Acc</p>",
        "id": 512136739,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744651634
    },
    {
        "content": "<p>in fact, there is a proof in <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> that Acc is universal for such types</p>",
        "id": 512136882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744651681
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/270676-lean4/topic/opaque.20recursion.20definitions.20break.20mergeSort.20decidability/near/512136304\">said</a>:</p>\n<blockquote>\n<p>it's large eliminating!?</p>\n</blockquote>\n<p>It has to be large eliminating or else one can't define functions by well founded recursion, only prove theorems by well founded induction</p>",
        "id": 512137130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744651752
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/opaque.20recursion.20definitions.20break.20mergeSort.20decidability/near/512136534\">said</a>:</p>\n<blockquote>\n<p>Equality is also a large eliminating inductive, but it's not recursive</p>\n</blockquote>\n<p>Any interesting large eliminating inductives besides these two? Or put differently: If we didn’t need <code>Acc</code>, could <code>Eq</code> be the only large eliminating inductive?</p>",
        "id": 512137399,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1744651849
    },
    {
        "content": "<p><code>And</code> is also large eliminating</p>",
        "id": 512137483,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744651867
    },
    {
        "content": "<p>but it's not interesting</p>",
        "id": 512137498,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744651873
    },
    {
        "content": "<p><code>True</code> and <code>False</code> too</p>",
        "id": 512137522,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744651881
    },
    {
        "content": "<p>only recursive large eliminating types are really problematic though</p>",
        "id": 512137598,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744651906
    },
    {
        "content": "<p>Eq is semi-problematic :)</p>",
        "id": 512137618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744651914
    },
    {
        "content": "<p><code>False</code>, <code>Eq</code>, and <code>Acc</code> are interesting</p>",
        "id": 512137780,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744651968
    },
    {
        "content": "<p>With <code>True</code> you can't do anything with its large elimination and with <code>And</code> you can just use the projections</p>",
        "id": 512138024,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744652047
    },
    {
        "content": "<p><code>False</code>'s large elimination is quite important but it usually is harmless from a type theory perspective because it has no iota rule (since it has no constructors to have iota rules for)</p>",
        "id": 512138254,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744652132
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/opaque.20recursion.20definitions.20break.20mergeSort.20decidability/near/512138254\">said</a>:</p>\n<blockquote>\n<p><code>False</code>'s large elimination is quite important but it usually is harmless from a type theory perspective because it has no iota rule (since it has no constructors to have iota rules for)</p>\n</blockquote>\n<p>What does iota rule do (why is not having one harmless)?</p>",
        "id": 512139055,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744652397
    },
    {
        "content": "<p><code>T.rec F (T.constructor x) = F x</code></p>",
        "id": 512139176,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744652422
    },
    {
        "content": "<p>you have one of those for every constructor of an inductive type, so for False there are no rules</p>",
        "id": 512139309,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744652468
    },
    {
        "content": "<p>Is having these \"harmful\" then?</p>",
        "id": 512139717,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744652608
    },
    {
        "content": "<p>it's what makes the theory interesting</p>",
        "id": 512139758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744652625
    },
    {
        "content": "<p>where \"interesting\" may go as far as \"soundness is an open question\"</p>",
        "id": 512139866,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744652651
    },
    {
        "content": "<p>but it's not like we don't want to be able to make definitions by recursion on Nat</p>",
        "id": 512139957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744652680
    },
    {
        "content": "<p>Here's a proof (using AC) that it is possible to construct <code>WellFounded.fix</code> using a small-eliminating Acc:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Logic</span><span class=\"bp\">.</span><span class=\"n\">Unique</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">SmallAcc</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">SmallAcc</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">SmallAcc</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">WellFounded'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">SmallAcc</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">FixOut</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">FixOut</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">FixOut</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SmallAcc</span><span class=\"bp\">.</span><span class=\"n\">fix_exists</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hwf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SmallAcc</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">FixOut</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">hwf</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">IH</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"bp\">⟨</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IH</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IH</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"bp\">⟩⟩</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">WellFounded'</span><span class=\"bp\">.</span><span class=\"n\">fix</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hwf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WellFounded'</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">SmallAcc</span><span class=\"bp\">.</span><span class=\"n\">fix_exists</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hwf</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">WellFounded'</span><span class=\"bp\">.</span><span class=\"n\">fix_eq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hwf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WellFounded'</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">fix</span><span class=\"w\"> </span><span class=\"n\">hwf</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">fix</span><span class=\"w\"> </span><span class=\"n\">hwf</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">suffices</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">y'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">FixOut</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">FixOut</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y'</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y'</span><span class=\"w\"> </span><span class=\"k\">from</span>\n<span class=\"w\">    </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SmallAcc</span><span class=\"bp\">.</span><span class=\"n\">fix_exists</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hwf</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n<span class=\"w\">      </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SmallAcc</span><span class=\"bp\">.</span><span class=\"n\">fix_exists</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hwf</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">y'</span><span class=\"w\"> </span><span class=\"n\">H1</span><span class=\"w\"> </span><span class=\"n\">H2</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">H1</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">IH</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">H2</span>\n<span class=\"w\">    </span><span class=\"n\">congr</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">IH</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 512143634,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744653913
    },
    {
        "content": "<p>No computation makes it slightly disappointing</p>",
        "id": 512144049,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744654047
    },
    {
        "content": "<p>the point is that if one is willing to give up computation then we don't need this kind of inductive at all</p>",
        "id": 512144187,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744654084
    },
    {
        "content": "<p>plus the compiler can of course support computation of this function anyway</p>",
        "id": 512144267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744654115
    },
    {
        "content": "<p>I don't think it's possible to get a version that computes in the kernel without kernel magic (either Acc-like types or primitive <code>WellFounded.fix</code>)</p>",
        "id": 512144400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744654175
    },
    {
        "content": "<p>What would be the consequences of using a type-valued <code>Acc</code>?</p>",
        "id": 512144915,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744654333
    },
    {
        "content": "<p>You would be able to define <code>fix</code> easily, but <code>WellFounded</code> would no longer be a Prop, and also the proof of well foundedness would not be erased</p>",
        "id": 512146099,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744654767
    },
    {
        "content": "<p>If you make <code>WellFounded</code> a prop using <code>Nonempty</code> then you need the axiom of choice to define <code>fix</code> and you end up with something similar to the above</p>",
        "id": 512146251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744654812
    },
    {
        "content": "<p>It's possible you could make it work if we had erasure annotations and used them on well foundedness arguments</p>",
        "id": 512146465,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744654897
    },
    {
        "content": "<p>which TBH sounds less scary than the alternatives that involve kernel magic</p>",
        "id": 512146616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744654940
    },
    {
        "content": "<p>so if i understand correctly, you're proposing to get rid of this rule:<br>\n<a href=\"/user_uploads/3121/Zq6C-eiAOz8U7HZFmbW-_Jtl/image.png\">image.png</a><br>\nand make <code>WellFounded</code> a built-in exception?</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Zq6C-eiAOz8U7HZFmbW-_Jtl/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1198x387\" src=\"/user_uploads/thumbnail/3121/Zq6C-eiAOz8U7HZFmbW-_Jtl/image.png/840x560.webp\"></a></div>",
        "id": 512147058,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744655099
    },
    {
        "content": "<p>(the image is from <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> , i added the box)</p>",
        "id": 512147272,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744655180
    },
    {
        "content": "<p><code>WellFounded</code> isn't exactly an exception to this rule, since it's not an inductive type of this kind at all (it's a structure wrapping <code>Acc</code>)</p>",
        "id": 512147322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744655200
    },
    {
        "content": "<p>ah, that's fair</p>",
        "id": 512147356,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744655213
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/opaque.20recursion.20definitions.20break.20mergeSort.20decidability/near/512146099\">said</a>:</p>\n<blockquote>\n<p>the proof of well foundedness would not be erased</p>\n</blockquote>\n<p>Does that matter? At least if you refer to erasure in compiled code, because the compiler works on the recursive PreDefinition and doesn’t even see the kernel-facing construction we are discussing here. And the kernel doesn’t erase proofs, does it?</p>",
        "id": 512148177,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1744655509
    },
    {
        "content": "<p>Ah, I suppose that's true</p>",
        "id": 512148388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744655570
    },
    {
        "content": "<p>hm... let's try it and see what breaks?</p>",
        "id": 512148470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744655606
    },
    {
        "content": "<p>Making <code>Acc</code> a <code>Type</code> would allow simplifying the type theory, but not help with the other issues (slow reduction of <code>Acc</code> terms, for example), would it?</p>",
        "id": 512149065,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1744655812
    },
    {
        "content": "<p>it might force users to write better-reducing \"proofs\" though</p>",
        "id": 512149181,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744655855
    },
    {
        "content": "<p>i.e. not use tactics</p>",
        "id": 512149226,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744655870
    },
    {
        "content": "<p>I think it would mean that defeq would work reliably</p>",
        "id": 512149316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744655891
    },
    {
        "content": "<p>well foundedness proofs would have a similar status to Decidable proofs, you would want to avoid using <code>rw</code> except in the proof arguments</p>",
        "id": 512149544,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744655963
    },
    {
        "content": "<p>I see – are saying we need WF proofs to be more carefully crafted, and that’s more likely to happen in <code>Type</code></p>",
        "id": 512149764,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1744656032
    },
    {
        "content": "<p>Note that a (Type-valued) proof of well foundedness still contains a lot of proofs in it because the <code>r</code> argument is still a prop</p>",
        "id": 512149793,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744656043
    },
    {
        "content": "<p>and unlike \"reducing proofs\", we can clearly separate out the spine of the WF proof from the side proofs showing individual relations hold</p>",
        "id": 512149917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744656087
    },
    {
        "content": "<p>Right, that’s my worry still</p>",
        "id": 512149918,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1744656087
    },
    {
        "content": "<p>you would not need to do anything special to tell lean to reduce the WF argument but not the side proofs</p>",
        "id": 512150154,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744656170
    },
    {
        "content": "<p>I think it makes a difference in this setting whether you are doing well founded recursion over a relation or its transitive closure. Doing recursion on the transitive closure should be more efficient</p>",
        "id": 512150821,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744656384
    },
    {
        "content": "<p>I'm trying it out now, and there is an issue: <code>Acc</code> in Type is a subsingleton but not definitionally so (because we don't have eta for \"recursive structures\" and that sounds scary), which means that <code>fix_eq</code> is not a defeq because it uses two different derivations for the well foundedness proof on each side of the equality</p>",
        "id": 512151981,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744656823
    },
    {
        "content": "<p>What if we add a rule that elements of a structurally subsingleton type are definitional equal?</p>",
        "id": 512152109,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744656870
    },
    {
        "content": "<p>Structural eta already does a lot of this, recursive types like <code>Acc</code> are sort of an exception now</p>",
        "id": 512152209,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744656917
    },
    {
        "content": "<p>it could work</p>",
        "id": 512152312,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744656952
    },
    {
        "content": "<p>I think it reintroduces the issue that makes Acc bad though</p>",
        "id": 512152432,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744656989
    },
    {
        "content": "<p>you can use definitional equality to swap out constructors in an inconsistent context and so typing is undecidable</p>",
        "id": 512152515,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744657023
    },
    {
        "content": "<p>I guess that's the whole point, <code>WellFounded.fix_eq</code> (which ignores its proof argument) can't be a defeq without implicating undecidability of typechecking</p>",
        "id": 512152667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744657085
    },
    {
        "content": "<p>note that <code>Acc.fixF</code> works just fine</p>",
        "id": 512152841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744657160
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Acc.fixF#doc\">docs#Acc.fixF</a> <span aria-label=\"looking\" class=\"emoji emoji-1f440\" role=\"img\" title=\"looking\">:looking:</span></p>",
        "id": 512153293,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744657313
    },
    {
        "content": "<p><span aria-label=\"man shrugging\" class=\"emoji emoji-1f937-200d-2642\" role=\"img\" title=\"man shrugging\">:man_shrugging:</span></p>",
        "id": 512153361,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744657328
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFounded.fixF#doc\">docs#WellFounded.fixF</a></p>",
        "id": 512153400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744657342
    },
    {
        "content": "<p>But actually, I think it doesn't matter that <code>fix_eq</code> isn't a defeq. It's already not a defeq. The question is whether it computes on closed terms, and I believe it should</p>",
        "id": 512154279,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744657659
    },
    {
        "content": "<blockquote>\n<p>So conversely, if you have a function that you want to have useful defeqs, then don't use well-founded recursion</p>\n</blockquote>\n<p>I have made this change for <code>Nat.xgcd</code> here: <a href=\"https://github.com/leanprover-community/mathlib4/pull/24514\">#24514</a></p>",
        "id": 515518454,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1746110611
    },
    {
        "content": "<p>Should we make everything come with fuel?</p>",
        "id": 515535587,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746115863
    },
    {
        "content": "<p>That's my conclusion from Joachim's message</p>",
        "id": 515542357,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1746118436
    }
]