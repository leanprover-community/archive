[
    {
        "content": "<p>Hello there!</p>\n<p>I am relatively new to programming and theorem proving in Lean.</p>\n<p>Currently, I am exploring the world of metaprogramming. My goal is to create a custom elaboration term that returns an instance of this inductive type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">T_Map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulBEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">T_Map</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">put</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T_Map</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T_Map</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span>\n</code></pre></div>\n<p>which can look like this:</p>\n<p><code>def empty = @T_Map.empty Nat _ _ Nat 0</code></p>\n<p>As you can see, this <code>T_Map</code> type expects instances of the type classes <code>BEq</code> and <code>LawfulBEq</code> for the parameter <code>α</code>. Now I am wondering, how can I pass such a \"proof\" for the existence of the instances for the type classes <code>BEq</code> and <code>LawfulBEq</code> in expressions so I can return an empty <code>T_Map</code> like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Nat</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">`Nat.zero</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"abc\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">mkAppN</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``T_Map.empty</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">proof1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">proof2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 451169859,
        "sender_full_name": "Marx",
        "timestamp": 1720875963
    },
    {
        "content": "<p>You should use <code>mkAppM ``T_Map.empty #[nat,zero]</code>. <code>mkAppM</code> expects only explicit arguments and the rest is infected automatically.</p>",
        "id": 451368830,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1720977116
    },
    {
        "content": "<p>If you really want to you can get those instances with <code>synthesizeInstance (&lt;- mkAppM ``BEq #[nat])</code></p>",
        "id": 451368994,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1720977278
    },
    {
        "content": "<p>Or you could use</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"c1\">-- ...</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"abc\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T_Map</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 451369144,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720977436
    },
    {
        "content": "<p>Also working with <code>Expr.const</code> is hard unless you have precise control over the universes. Most of the time I use <code>mkConstWithFreshMVarLevels</code></p>",
        "id": 451369166,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1720977476
    },
    {
        "content": "<p>I would remove the instances from <code>T_Map</code> since they're not used by the constructors</p>",
        "id": 451370069,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720978449
    },
    {
        "content": "<p>Thanks, everyone! That already helped a lot. I tried to work with <code>mkAppM</code>, but I ran into another problem.</p>\n<p>My ultimate goal is to do something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">declare_syntax_cat</span><span class=\"w\"> </span><span class=\"n\">abc_syntax</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"(\"</span><span class=\"w\"> </span><span class=\"n\">num</span><span class=\"w\"> </span><span class=\"s2\">\", \"</span><span class=\"w\"> </span><span class=\"n\">num</span><span class=\"w\"> </span><span class=\"s2\">\")\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">abc_syntax</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"abc\"</span><span class=\"w\"> </span><span class=\"n\">syn</span><span class=\"o\">:</span><span class=\"n\">abc_syntax</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"s2\">\"xyz\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">try</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``T_Map.empty</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">entry</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">syn</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">entry</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">abc_syntax</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">num</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"bp\">$</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">num</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">        </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``T_Map.put</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">mkNatLit</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">getNat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mkNatLit</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">getNat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- / this won't work because the parameters must be `Expr`</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">unreachable!</span>\n\n<span class=\"w\">    </span><span class=\"n\">map</span>\n<span class=\"w\">  </span><span class=\"n\">catch</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"fail\"</span>\n</code></pre></div>\n<p>This code fails because the parameters of mkAppM must be Expr, and I didn't find a reliable way to convert <code>map : MetaM Expr</code> to <code>Expr</code>.</p>\n<p>Unfortunately, I can't just remove the type classes because they are required to prove that this type is working properly.</p>",
        "id": 451866660,
        "sender_full_name": "Marx",
        "timestamp": 1721165410
    },
    {
        "content": "<p>When you have monadic values (like <code>MetaM Expr</code>) you need to \"evaluate\" them. In <code>do</code> syntax, you can use arrow notation like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``T_Map.empty</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 451880416,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721169361
    },
    {
        "content": "<p>(if you want more help, please give a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>)</p>",
        "id": 451880502,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721169382
    },
    {
        "content": "<p>Okay, thank you for the arrow advice. Unfortuneatly, this does not solve my problem :/ </p>\n<p>Here the mwe: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Meta</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">T_Map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulBEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">T_Map</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">put</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T_Map</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T_Map</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"n\">declare_syntax_cat</span><span class=\"w\"> </span><span class=\"n\">abc_syntax</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"(\"</span><span class=\"w\"> </span><span class=\"n\">num</span><span class=\"w\"> </span><span class=\"s2\">\", \"</span><span class=\"w\"> </span><span class=\"n\">num</span><span class=\"w\"> </span><span class=\"s2\">\")\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">abc_syntax</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">`Nat</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">`Nat.zero</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"abc\"</span><span class=\"w\"> </span><span class=\"n\">syn</span><span class=\"o\">:</span><span class=\"n\">abc_syntax</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"s2\">\"xyz\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">try</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">`T_Map.empty</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">entry</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">syn</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">entry</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">abc_syntax</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">num</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">num</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">        </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``T_Map.put</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">mkNatLit</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">getNat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mkNatLit</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">getNat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">unreachable!</span>\n\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">map</span>\n\n<span class=\"w\">  </span><span class=\"n\">catch</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"fail\"</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">abc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">xyz</span>\n<span class=\"c1\">--fail</span>\n</code></pre></div>",
        "id": 451889142,
        "sender_full_name": "Marx",
        "timestamp": 1721171820
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Meta</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">T_Map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulBEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">T_Map</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">put</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T_Map</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T_Map</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"n\">abc_syntax</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"(\"</span><span class=\"w\"> </span><span class=\"n\">num</span><span class=\"w\"> </span><span class=\"s2\">\", \"</span><span class=\"w\"> </span><span class=\"n\">num</span><span class=\"w\"> </span><span class=\"s2\">\")\"</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">`Nat</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">`Nat.zero</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"abc\"</span><span class=\"w\"> </span><span class=\"n\">syn</span><span class=\"o\">:</span><span class=\"n\">abc_syntax</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"s2\">\"xyz\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppOptM</span><span class=\"w\"> </span><span class=\"ss\">``T_Map.empty</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">entry</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">syn</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">entry</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">abc_syntax</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">num</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">num</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``T_Map.put</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">mkNatLit</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">getNat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mkNatLit</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">getNat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">throwUnsupportedSyntax</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">map</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">abc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">xyz</span>\n<span class=\"c1\">-- T_Map.put 3 4 (T_Map.put 1 2 (T_Map.empty 0))</span>\n</code></pre></div>\n<p>One thing that might have helped you is to not have the <code>try</code>/<code>catch</code> — all that does is consume useful information to help you debug.</p>\n<p>For the first <code>mkAppM</code>, you're providing implicit arguments, so you can use <code>mkAppOptM</code> for that.</p>\n<p>Do you want <code>abc_syntax</code> to be extensible? If so, keep it as a syntax category, if not, then follow what I did.</p>\n<p>Make sure not to use <code>unreachable!</code> unless it truly is unreachable. I switched that to <code>throwUnsupportedSyntax</code>.</p>",
        "id": 451916631,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721183249
    },
    {
        "content": "<p>Also: are you sure you want <code>BEq</code> and <code>LawfulBEq</code> in the <code>T_Map</code> type itself? I mentioned removing those before since the type doesn't need them. Usually it is better to put those in the theorems or definitions that need them. Is there some sort of optimization you're going for here?</p>",
        "id": 451916759,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721183306
    },
    {
        "content": "<p>One more thing: this works better as a macro than an elaborator:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"abc\"</span><span class=\"w\"> </span><span class=\"n\">syn</span><span class=\"o\">:</span><span class=\"n\">abc_syntax</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"s2\">\"xyz\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">T_Map</span><span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">entry</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">syn</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">entry</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">abc_syntax</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">num</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">num</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"n\">T_Map</span><span class=\"bp\">.</span><span class=\"n\">put</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">map</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Macro</span><span class=\"bp\">.</span><span class=\"n\">throwUnsupported</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">map</span>\n</code></pre></div>\n<p>The elaborator is fine, but it's easily implemented as a source-to-source transformation. It doesn't make use of any type information.</p>",
        "id": 451916977,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721183405
    },
    {
        "content": "<p>Thank you so much!<br>\nYou are right actually, I can omit the type classes in the <code>T_Map</code> type. I didn't even consider the fact that it could work without.</p>",
        "id": 452089727,
        "sender_full_name": "Marx",
        "timestamp": 1721226263
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"735860\">Marx</span> has marked this topic as resolved.</p>",
        "id": 452089758,
        "sender_full_name": "Notification Bot",
        "timestamp": 1721226268
    }
]