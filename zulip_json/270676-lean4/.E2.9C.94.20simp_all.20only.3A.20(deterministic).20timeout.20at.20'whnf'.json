[
    {
        "content": "<p>I'm trying to convert the following verbose <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> to a more succinct proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Filter.Basic</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Set.mem_iff</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">sets</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">Set.Finite</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span><span class=\"o\">}</span>\n  <span class=\"n\">univ_sets</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_iff</span><span class=\"o\">,</span> <span class=\"n\">Set.compl_univ</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Set.finite_empty</span>\n  <span class=\"n\">sets_of_superset</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"bp\">«</span><span class=\"n\">s</span><span class=\"bp\">ᶜ</span> <span class=\"n\">is</span> <span class=\"n\">finite</span><span class=\"bp\">»</span> <span class=\"bp\">«</span><span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span><span class=\"bp\">»</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">«</span><span class=\"n\">s</span><span class=\"bp\">ᶜ</span> <span class=\"n\">is</span> <span class=\"n\">finite</span><span class=\"bp\">»</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_iff</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">&lt;-</span><span class=\"n\">Set.compl_subset_compl</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">«</span><span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span><span class=\"bp\">»</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Set.Finite.subset</span> <span class=\"bp\">«</span><span class=\"n\">s</span><span class=\"bp\">ᶜ</span> <span class=\"n\">is</span> <span class=\"n\">finite</span><span class=\"bp\">»</span> <span class=\"bp\">«</span><span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span><span class=\"bp\">»</span>\n  <span class=\"n\">inter_sets</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"bp\">«</span><span class=\"n\">s</span><span class=\"bp\">ᶜ</span> <span class=\"n\">is</span> <span class=\"n\">finite</span><span class=\"bp\">»</span> <span class=\"bp\">«</span><span class=\"n\">t</span><span class=\"bp\">ᶜ</span> <span class=\"n\">is</span> <span class=\"n\">finite</span><span class=\"bp\">»</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">«</span><span class=\"n\">s</span><span class=\"bp\">ᶜ</span> <span class=\"n\">is</span> <span class=\"n\">finite</span><span class=\"bp\">»</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">«</span><span class=\"n\">t</span><span class=\"bp\">ᶜ</span> <span class=\"n\">is</span> <span class=\"n\">finite</span><span class=\"bp\">»</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_iff</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.compl_inter</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Set.Finite.union</span> <span class=\"bp\">«</span><span class=\"n\">s</span><span class=\"bp\">ᶜ</span> <span class=\"n\">is</span> <span class=\"n\">finite</span><span class=\"bp\">»</span> <span class=\"bp\">«</span><span class=\"n\">t</span><span class=\"bp\">ᶜ</span> <span class=\"n\">is</span> <span class=\"n\">finite</span><span class=\"bp\">»</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 391879114,
        "sender_full_name": "Utensil Song",
        "timestamp": 1695118492
    },
    {
        "content": "<p>So far I got this <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> , what's left is <code>sets_of_superset</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Filter.Basic</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Set.mem_iff</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">sets</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">Set.Finite</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span><span class=\"o\">}</span>\n  <span class=\"n\">univ_sets</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_iff</span><span class=\"o\">,</span> <span class=\"n\">Set.compl_univ</span><span class=\"o\">,</span> <span class=\"n\">Set.finite_empty</span><span class=\"o\">]</span>\n    <span class=\"c1\">-- ok</span>\n  <span class=\"n\">sets_of_superset</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_iff</span><span class=\"o\">]</span>\n    <span class=\"n\">intros</span> <span class=\"n\">s</span> <span class=\"n\">t</span>\n    <span class=\"n\">intros</span>\n    <span class=\"n\">simp_all</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">&lt;-</span><span class=\"n\">Set.compl_subset_compl</span><span class=\"o\">,</span> <span class=\"n\">Set.Finite.subset</span><span class=\"o\">]</span>\n    <span class=\"c1\">-- error: (deterministic) timeout at 'whnf', maximum number of heartbeats (200000) has been reached (use 'set_option maxHeartbeats &lt;num&gt;' to set the limit)</span>\n  <span class=\"n\">inter_sets</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp_all</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_iff</span><span class=\"o\">,</span> <span class=\"n\">Set.compl_inter</span><span class=\"o\">,</span> <span class=\"n\">Set.Finite.union</span><span class=\"o\">]</span>\n    <span class=\"c1\">-- ok</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>Question: is this expected behavior? Or is it some kind of regression?</p>",
        "id": 391879223,
        "sender_full_name": "Utensil Song",
        "timestamp": 1695118528
    },
    {
        "content": "<p>It's not safe to use <code>simp</code> with <code>&lt;-Set.compl_subset_compl</code> since that means it's free to add arbitrarily many complements to both sides. I imagine this is the path it's going down when it times out.</p>",
        "id": 391879466,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1695118597
    },
    {
        "content": "<p>Thanks for the hint! So this is expected, as I recall the same <code>&lt;-</code> issue from lean 3.</p>\n<p>Yet I still can't figure out how to shorten the proof to be without explicit <code>intro</code> naming and <code>rw</code>s.</p>",
        "id": 391890770,
        "sender_full_name": "Utensil Song",
        "timestamp": 1695122672
    },
    {
        "content": "<p>Surely we already have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.cofinite#doc\">docs#Filter.cofinite</a> somewhere?</p>",
        "id": 391952041,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695141117
    },
    {
        "content": "<p>The <a href=\"https://github.com/leanprover-community/mathlib4/blob/957593fb268c7762c3c2c34fd4bfe4f7e709178f/Mathlib/Order/Filter/Cofinite.lean#L32-L36\">source</a> has a short construction.</p>",
        "id": 391952172,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695141156
    },
    {
        "content": "<p>Thanks! I don't know we can supply  parameters to <code>sets_of_superset</code>nor the <code>using</code> clause below</p>",
        "id": 392129199,
        "sender_full_name": "Utensil Song",
        "timestamp": 1695219898
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.mem_iff#doc\">docs#Set.mem_iff</a> doesn't exist, I assume you meant <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.mem_setOf#doc\">docs#Set.mem_setOf</a> ?</p>",
        "id": 392144833,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695224515
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/simp_all.20only.3A.20.28deterministic.29.20timeout.20at.20'whnf'/near/392144833\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.mem_iff#doc\">docs#Set.mem_iff</a> doesn't exist, I assume you meant <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.mem_setOf#doc\">docs#Set.mem_setOf</a> ?</p>\n</blockquote>\n<p>Sorry, fixed in <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> . I've edited it too many times and lost part of it. </p>\n<p>EDIT: And yes, using mathlib it should be <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.mem_setOf#doc\">docs#Set.mem_setOf</a> . I ported the MWE from <a href=\"https://github.com/bridgekat/filter-game\">filter game</a> where everything is built from the ground up and the naming is different.</p>",
        "id": 392231534,
        "sender_full_name": "Utensil Song",
        "timestamp": 1695262321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> has marked this topic as resolved.</p>",
        "id": 392502134,
        "sender_full_name": "Notification Bot",
        "timestamp": 1695383652
    }
]