[
    {
        "content": "<p>Hey everyone! I was playing around with a few different ways to manipulate lists of numbers in a generic way. The approach I took this morning was to look at using a Sum type since I haven't used the Sum type much. I was very surprised to find out that Lean can't infer that a value whose type is a member of a Sum type is itself an element of that Sum type. For example, this was not allowed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">List.sum</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Sum</span> <span class=\"n\">Nat</span> <span class=\"n\">Int</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Sum</span> <span class=\"n\">Nat</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">]</span>\n<span class=\"k\">#eval</span> <span class=\"n\">List.sum</span> <span class=\"n\">l</span>\n</code></pre></div>\n<p>I apologize if some of that is a bit off. I was using the unicode symbols in my editor. I do have a working implementation of List.sum that I can post if need be. Anyway, I had to change it to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">Sum.inl</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">Sum.inl</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">Sum.inl</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">Sum.inl</span> <span class=\"mi\">4</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I did try other permutations and explicit types. All resulted in the same thing. Is there anyway that I can have lean infer that 1 : Nat is a valid element when the input type is Sum Nat Int?</p>",
        "id": 397965268,
        "sender_full_name": "Ian Riley",
        "timestamp": 1698001172
    },
    {
        "content": "<p>You can use coercions for that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">Sum</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Sum.inl</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Coe</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x.map</span> <span class=\"n\">Coe.coe</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">List.sum</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Sum</span> <span class=\"n\">Nat</span> <span class=\"n\">Int</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Sum</span> <span class=\"n\">Nat</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">]</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">List.sum</span> <span class=\"n\">l</span> <span class=\"c1\">--no type error</span>\n</code></pre></div>",
        "id": 397966497,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1698002523
    },
    {
        "content": "<p>Nice! Thank you. It doesn't work for literals, but I was able to follow the same pattern to get literals working.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"n\">Sum</span> <span class=\"n\">Nat</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">where</span>\n<span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"n\">Sum.inl</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>However, I can't seem to get negative literals to work.</p>",
        "id": 397969876,
        "sender_full_name": "Ian Riley",
        "timestamp": 1698006042
    },
    {
        "content": "<p>It also seems counter intuitive to have literals work differently in this context than definitions, especially since there’s very little visibility when using check. I think people would naturally expect that if I check [1,2,3,4] and it comes back as List Nat and if I define list := [1,2,3,4], which also checks as a List Nat, that if the latter works under type coercion, then the former would too. But that’s not the case.</p>",
        "id": 397971961,
        "sender_full_name": "Ian Riley",
        "timestamp": 1698008506
    },
    {
        "content": "<p>Got it! I was trying to use Neg like Nat or like OfNat. Then it dawned on me that it might work more like Coe. Sure enough, this works.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Neg</span> <span class=\"o\">(</span><span class=\"n\">Sum</span> <span class=\"n\">Nat</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n<span class=\"n\">neg</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">Sum.inl</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Sum.inr</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Sum.inr</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Sum.inr</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I do appreciate all the help! I also want to say that any criticisms I may add are only because I want Lean to do really well.</p>",
        "id": 397974376,
        "sender_full_name": "Ian Riley",
        "timestamp": 1698011582
    }
]