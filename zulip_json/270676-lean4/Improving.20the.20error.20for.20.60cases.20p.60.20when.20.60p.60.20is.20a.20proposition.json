[
    {
        "content": "<p>Yesterday on a project, someone I was working with accidentally did <code>cases p</code> instead of <code>by_cases p</code> and was puzzled by the cryptic message</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">cases'</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">major</span><span class=\"w\"> </span><span class=\"n\">premise</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>and we thought \"there's got to be a way to improve this, right?\" The PR <a href=\"https://github.com/leanprover/lean4/pull/6378\">lean4#6378</a> has some possible improvements, and I'd appreciate feedback. (Side note: thinking a bit laterally, I wondered \"couldn't <code>cases p</code> <em>just work</em>?\" but <code>cases</code> and <code>by_cases</code> are sufficiently different that it might be too confusing.)</p>\n<p><strong>Added explanation when the type is <code>Prop</code>:</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">error: tactic 'cases' failed, major premise type is not an inductive type</span>\n<span class=\"cm\">  Prop</span>\n\n<span class=\"cm\">Explanation: the 'cases' tactic is for constructor-based reasoning, with cases exhausting every way</span>\n<span class=\"cm\">in which a term could have been constructed. The 'Prop' universe is not an inductive type however,</span>\n<span class=\"cm\">so 'cases' does not apply. Consider using the 'by_cases' tactic, which enables true/false reasoning.</span>\n<span class=\"cm\">p : Prop</span>\n<span class=\"cm\">⊢ True</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p><strong>Added explanation when the type is a type universe:</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">error: tactic 'cases' failed, major premise type is not an inductive type</span>\n<span class=\"cm\">  Type</span>\n\n<span class=\"cm\">Explanation: the 'cases' tactic is for constructor-based reasoning, with cases exhausting every way</span>\n<span class=\"cm\">in which a term could have been constructed. Type universes are not inductive types however, so such</span>\n<span class=\"cm\">case-based reasoning is not possible. This is a strong limitation. According to Lean's underlying</span>\n<span class=\"cm\">theory, the only distinguishing feature of types is their cardinalities.</span>\n<span class=\"cm\">α : Type</span>\n<span class=\"cm\">⊢ True</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p><strong>Added explanation for other types:</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">error: tactic 'cases' failed, major premise type is not an inductive type</span>\n<span class=\"cm\">  Bool → Bool</span>\n\n<span class=\"cm\">Explanation: the 'cases' tactic is for constructor-based reasoning, with cases exhausting every way</span>\n<span class=\"cm\">in which a term could have been constructed. It can sometimes be helpful defining an equivalent</span>\n<span class=\"cm\">auxiliary inductive type to apply 'cases' to instead.</span>\n<span class=\"cm\">f : Bool → Bool</span>\n<span class=\"cm\">⊢ True</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 488882682,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734108943
    },
    {
        "content": "<p>This looks really helpful!</p>",
        "id": 488982366,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1734172493
    },
    {
        "content": "<p>Should we also have something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">error: tactic 'cases' failed, major premise type is not an inductive type</span>\n<span class=\"cm\">  Type</span>\n\n<span class=\"cm\">Explanation: the 'cases' tactic is for constructor-based reasoning, with cases exhausting every way</span>\n<span class=\"cm\">in which a term could have been constructed. `Fin 3` is not a inductive type however,</span>\n<span class=\"cm\">so 'cases' does not apply. Consider using the 'fin_cases' tactic, ...</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 488982509,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1734172613
    },
    {
        "content": "<p>The third explanation is definitely the weakest of the three. Do you have any idea how to phrase suggesting that there are other tactics that might be available in other projects? A problem with referring to <code>fin_cases</code> is that it's only in mathlib.</p>",
        "id": 489017687,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734202391
    },
    {
        "content": "<p>also you didn't do <code>cases i</code> there, of course that won't work</p>",
        "id": 489018885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734203439
    },
    {
        "content": "<p>but more problematic for your suggestion <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> is that <code>cases i</code> <em>does</em> work already, because <code>Fin 3</code> is an inductive type</p>",
        "id": 489018919,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734203467
    },
    {
        "content": "<p>so it's difficult to give a suggestion without breaking the cases where this is being done on purpose</p>",
        "id": 489018944,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734203496
    },
    {
        "content": "<p>That's all true <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, but a bit beside the point — we should be assuming we're in a situation where <code>cases</code> fails, and changing <code>cases</code> to fail on purpose for inductive types is out of the question.</p>\n<p>In my third example that's something enumerating a Fintype would work for, but it's hard to come up with any generic advice.</p>",
        "id": 489019178,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734203739
    },
    {
        "content": "<p>isn't that what I said?</p>",
        "id": 489019235,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734203770
    },
    {
        "content": "<p>are you saying that <code>fin_cases i</code> works in situations where <code>i</code> is not an inductive type?</p>",
        "id": 489019273,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734203811
    },
    {
        "content": "<p>Yes, can't it work for something like all functions <code>Bool -&gt; Bool</code>?</p>",
        "id": 489019283,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734203826
    },
    {
        "content": "<p>oh because it works on <code>A : Type</code> such that <code>Fintype A</code></p>",
        "id": 489019292,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734203847
    },
    {
        "content": "<p>One way to do this would be to give <code>cases</code> an extensible hook for error reporting</p>",
        "id": 489019360,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734203895
    },
    {
        "content": "<p>and <code>fin_cases</code> can try itself on failed <code>cases</code> applications and suggest itself if successful</p>",
        "id": 489019383,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734203926
    },
    {
        "content": "<p>That's crossed my mind, but I worry it's a lot of engineering for something that happens really infrequently. Almost all the time the term is going to be for an inductive type.</p>",
        "id": 489019415,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734203964
    },
    {
        "content": "<p>although I worry about getting too fancy here because tactic failure is something that can also happen on purpose and running slow things on tactic failure causes problems for <code>try cases</code></p>",
        "id": 489019491,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734204007
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/Improving.20the.20error.20for.20.60cases.20p.60.20when.20.60p.60.20is.20a.20proposition/near/489019360\">said</a>:</p>\n<blockquote>\n<p>One way to do this would be to give <code>cases</code> an extensible hook for error reporting</p>\n</blockquote>\n<p>Could this be implemented today with a linter inspecting the infotree?</p>",
        "id": 489019503,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734204016
    },
    {
        "content": "<p>it would be better to put such smarts in a linter</p>",
        "id": 489019513,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734204024
    },
    {
        "content": "<p>We have a trick for this already, which is inserting the additional friendly diagnostics into lazy messages.</p>",
        "id": 489019529,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734204041
    },
    {
        "content": "<p>That's how <code>decide</code> works for example</p>",
        "id": 489019534,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734204048
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Improving.20the.20error.20for.20.60cases.20p.60.20when.20.60p.60.20is.20a.20proposition/near/489019415\">said</a>:</p>\n<blockquote>\n<p>That's crossed my mind, but I worry it's a lot of engineering for something that happens really infrequently. Almost all the time the term is going to be for an inductive type.</p>\n</blockquote>\n<p>I think that's a bit of a silly argument, errors happen infrequently only if you don't make mistakes</p>",
        "id": 489019582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734204096
    },
    {
        "content": "<p>Language error messages are usually make or break for the user experience</p>",
        "id": 489019661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734204156
    },
    {
        "content": "<p>Would you mind trying to \"yes and\" here? You can see this thread is about trying to improve the error messages to improve the user experience, right?</p>",
        "id": 489019700,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734204194
    },
    {
        "content": "<p>right, so I'm not sure what your argument is</p>",
        "id": 489019728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734204223
    },
    {
        "content": "<p>Having a hook is a way to solve the problem (which TBH I wish didn't exist) that \"lean doesn't want to ever recommend things in mathlib even if there is good reason to\"</p>",
        "id": 489019811,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734204280
    },
    {
        "content": "<p>I'm worrying that this is an engineering investment (making an extensible framework just to add mentioning <code>fin_cases</code> to the error message for <code>cases</code>) and it's very rare that someone will be doing <code>cases</code> on a function type. Even doing <code>fin_cases</code> on a function type seems to be very rare.</p>",
        "id": 489019840,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734204310
    },
    {
        "content": "<p>So why suggest doing something that no one really does?</p>",
        "id": 489019852,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734204325
    },
    {
        "content": "<p>There does not have to be a lot of work to make something extensible. The barest version is you stick it in an IO ref and use it</p>",
        "id": 489019864,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734204343
    },
    {
        "content": "<p>I do something like this to make <code>ring</code> suggest <code>ring_nf</code></p>",
        "id": 489019879,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734204356
    },
    {
        "content": "<p>even though <code>ring_nf</code> is defined after <code>ring</code></p>",
        "id": 489019924,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734204370
    },
    {
        "content": "<p>Look, I get that and know how to implement it. This is code that needs to be maintained, so thinking about the added complexity is necessary as part of the engineering.</p>",
        "id": 489019944,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734204406
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/8fe8834dbbef8a87e09d0ba3ef2854a643b60521/Mathlib/Tactic/Ring/Basic.lean#L1192-L1225\">https://github.com/leanprover-community/mathlib4/blob/8fe8834dbbef8a87e09d0ba3ef2854a643b60521/Mathlib/Tactic/Ring/Basic.lean#L1192-L1225</a></p>",
        "id": 489019983,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734204438
    },
    {
        "content": "<p>The question that needs to be exhausted first is \"would a blurb be enough\"? Or \"can we suggest that there might be type-specific tactics that may or may not help\"? And also \"is this a place where we <em>can</em> break the rule and refer to a mathlib tactic\"?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">error: tactic 'cases' failed, major premise type is not an inductive type</span>\n<span class=\"cm\">  Bool → Bool</span>\n\n<span class=\"cm\">Explanation: the 'cases' tactic is for constructor-based reasoning, with cases exhausting every way</span>\n<span class=\"cm\">in which a term could have been constructed. It can sometimes be helpful defining an equivalent</span>\n<span class=\"cm\">auxiliary inductive type to apply 'cases' to instead.</span>\n<span class=\"cm\">f : Bool → Bool</span>\n<span class=\"cm\">⊢ True</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 489020100,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734204514
    },
    {
        "content": "<p>it doesn't need to be a huge deal or require maintenance any more than any other kind of code</p>",
        "id": 489020102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734204514
    },
    {
        "content": "<p>A basic blurb you could add which doesn't try to do too much analysis is \"You may have confused this tactic with 'by_cases' or 'fin_cases' (in mathlib)\"</p>",
        "id": 489020154,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734204594
    },
    {
        "content": "<p>made better if you can make those links to HTML doc pages of some kind</p>",
        "id": 489020283,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734204665
    },
    {
        "content": "<p>I respectfully disagree that adding a hook to extend error messages that is intended to be used by downstream projects doesn't need much thought. I'd like to avoid this if possible, since I don't want to guarantee anything about support or stability (rather, I don't want to do the design work to be able to guarantee this). The <code>ring</code>/<code>ring_nf</code> example is different since it's all under the purview of mathlib in the end.</p>\n<p>Thanks for the \"you may have confused ...\" suggestion. I'll keep it in mind, and something like that might work.</p>",
        "id": 489020444,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734204833
    },
    {
        "content": "<p>if you don't want to guarantee support or stability, then put that in the docstring, just like anything else</p>",
        "id": 489020507,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734204875
    },
    {
        "content": "<p>lean core already has many many public functions with every possible stance on support or stability</p>",
        "id": 489020544,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1734204919
    },
    {
        "content": "<p>I'd then ask mathlib not to use it, and then it wouldn't be used for its raison d'être, mentioning <code>fin_cases</code>.</p>",
        "id": 489020558,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734204942
    }
]