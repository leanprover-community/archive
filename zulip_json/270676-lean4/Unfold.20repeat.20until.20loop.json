[
    {
        "content": "<p>I have a <code>repeat ... until</code> loop that only runs for one iteration. Is it possible to sort of \"unfold\" the monadic  action that represents the loop so that I can prove the result of its execution?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">StateT</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Except</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">repeat_example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">final_loop_state</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">loop_state</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">false</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">repeat</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">loop_state</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">get</span>\n<span class=\"w\">      </span><span class=\"n\">loop_state</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">until</span><span class=\"w\"> </span><span class=\"n\">loop_state</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n<span class=\"w\">    </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">loop_state</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n<span class=\"w\">  </span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">final_loop_state</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">unfold_repeat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">repeat_example</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I know this might not be idiomatic Lean, but this code is machine-generated so I can't really change it.</p>",
        "id": 531952398,
        "sender_full_name": "Gavin Zhao",
        "timestamp": 1753919654
    },
    {
        "content": "<p><code>repeat</code> is opaque</p>",
        "id": 531953035,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753920081
    },
    {
        "content": "<p><code>repeat .. until</code> is also opaque</p>",
        "id": 531953163,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753920146
    },
    {
        "content": "<p>that means you're not allowed to unfold it</p>",
        "id": 531953178,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753920154
    },
    {
        "content": "<p>Hmm so what would be alternatives that are not <code>opaque</code> but still represent loops? Maybe <code>while</code>?</p>",
        "id": 531953195,
        "sender_full_name": "Gavin Zhao",
        "timestamp": 1753920163
    },
    {
        "content": "<p><code>while</code> is also opaque</p>",
        "id": 531953269,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753920205
    },
    {
        "content": "<p>anything that lets you represent an infinite loop will usually be opaque</p>",
        "id": 531953301,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753920220
    },
    {
        "content": "<blockquote>\n<p><code>repeat</code> is opaque</p>\n</blockquote>\n<p>I'm surprised the <a href=\"https://lean-lang.org/doc/reference/4.22.0-rc4//Functors___-Monads-and--do--Notation/Syntax/#Lean___Parser___Term___doSeqItem-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next-next\">reference manual</a> doesn't mention it.</p>",
        "id": 531953320,
        "sender_full_name": "Gavin Zhao",
        "timestamp": 1753920228
    },
    {
        "content": "<blockquote>\n<p>anything that lets you represent an infinite loop will usually be opaque</p>\n</blockquote>\n<p>That makes sense. Thank you for the info! I'll have to think of other representations.</p>",
        "id": 531953531,
        "sender_full_name": "Gavin Zhao",
        "timestamp": 1753920348
    },
    {
        "content": "<p><code>for</code> loops unfold into <code>List.forIn</code> if you know the looping is bounded</p>",
        "id": 531963611,
        "sender_full_name": "Devon Tuma",
        "timestamp": 1753927063
    },
    {
        "content": "<p>Or at least loops over lists do</p>",
        "id": 531963633,
        "sender_full_name": "Devon Tuma",
        "timestamp": 1753927082
    },
    {
        "content": "<p>Yeah, but unfortunately this one uses a boolean variable as the termination variable (i.e. <code>repeat ... until</code>) so that pattern doesn't hold.</p>",
        "id": 531963754,
        "sender_full_name": "Gavin Zhao",
        "timestamp": 1753927154
    },
    {
        "content": "<p>As you mentioned, for <code>for</code> loops over lists I did find that it can unfold it.</p>",
        "id": 531963894,
        "sender_full_name": "Gavin Zhao",
        "timestamp": 1753927223
    }
]