[
    {
        "content": "<p>My understanding of Idris 2 is that it uses QTT because it's hard to decide what type information can be discarded at runtime.  I am trying to write some \"non-toy\" code and would like a better understanding of the \"abstraction penalties\" involved.</p>\n<p>(Please LMK if the below is described/documented somewhere!)</p>\n<p>How does Lean handle the decision what information it can remove without e.g. using something like QTT?</p>\n<p>Should I worry about using <code>Nat</code> in my \"performance\" code?  Is <code>Nat</code> efficient in the sense that it uses the native types and only switches to an unlimited precision representation if it needs to? </p>\n<p>How does Lean represent e.g. something like <code>Fin n</code> at runtime?  Does it erase the <code>n</code>, or does each <code>Fin</code> carry two \"fields\"?</p>\n<p>Suppose <code>Fin n</code> is such that e.g. <code>n &lt; UInt64.size</code>.  Is Lean smart enough to use a <code>uint64_t</code> as the runtime representation?</p>\n<p>How about <code>Array (Fin n)</code>?  Would Lean keep an array of unboxed values?</p>\n<p>If I use an inductive type with a single constructor, or a structure with just one member, would the compiler treat it as a \"NewType\", i.e. treat it as the contained member?</p>\n<p>What if I add a \"proof\" requirement to my structure, like e.g. like the <code>isLT</code> member of <code>Fin n</code>?</p>\n<p>Thank you for your help!</p>",
        "id": 473374096,
        "sender_full_name": "Tom",
        "timestamp": 1727549351
    },
    {
        "content": "<blockquote>\n<p>How does Lean handle the decision what information it can remove without e.g. using something like QTT?</p>\n</blockquote>\n<p>Everything in <code>Prop</code> is provably irrelevant and can be dropped without consideration. Beyond that there is <a href=\"https://lean-lang.org/lean4/doc/dev/ffi.html\">https://lean-lang.org/lean4/doc/dev/ffi.html</a> to describe how Lean lays out data at runtime and how it arrives at layouts based on type declarations.</p>\n<blockquote>\n<p>Should I worry about using Nat in my \"performance\" code? Is Nat efficient in the sense that it uses the native types and only switches to an unlimited precision representation if it needs to?</p>\n</blockquote>\n<p><code>Nat</code> is unboxed up to 63 bit, beyond that it uses GMP-style bignums</p>\n<blockquote>\n<p>How does Lean represent e.g. something like <code>Fin n</code> at runtime? Does it erase the <code>n</code>, or does each <code>Fin</code> carry two \"fields\"?</p>\n</blockquote>\n<p>The representation of <code>Fin n</code> is the same as <code>Nat</code> since it's a one element struct. The <code>n</code> however will not be erased. After all every function that takes a <code>Fin n</code>has to take a (possibly implicit) argument <code>n : Nat</code> already. If that argument remains unused however it can indeed be optimized away.</p>\n<blockquote>\n<p>How about <code>Array (Fin n)</code>? Would Lean keep an array of unboxed values?</p>\n</blockquote>\n<p>Unfortunatley not, that's why we have special <code>Array</code>s like <code>ByteArray</code> and <code>FloatArray</code>. This is potentially subject to change with the new compiler.</p>\n<blockquote>\n<p>If I use an inductive type with a single constructor, or a structure with just one member, would the compiler treat it as a \"NewType\", i.e. treat it as the contained member?</p>\n</blockquote>\n<p>See the FFI docs.</p>\n<blockquote>\n<p>What if I add a \"proof\" requirement to my structure, like e.g. like the <code>isLT</code> member of <code>Fin n</code>?</p>\n</blockquote>\n<p>See FFI docs but the answer is: It's in <code>Prop</code> so it gets removed.</p>",
        "id": 473374900,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1727549667
    },
    {
        "content": "<p>Thanks a lot <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span>   for all that info!</p>\n<p>Is there some place I can read more about the \"new compiler\"/goals etc?</p>\n<p>Also, since you brought up GMP:  I think I saw some mention of GMP being removed, but then perhaps being put back in?  So when you say \"GMP-style\" I am not sure if you literally mean \"GMP\" or some kind of \"GMP reimplementation\".  (I think I read this in a thread about olean incompatibility).  Just out of curiosity, what's the plan here and why?</p>",
        "id": 473376499,
        "sender_full_name": "Tom",
        "timestamp": 1727550111
    },
    {
        "content": "<blockquote>\n<p>Is there some place I can read more about the \"new compiler\"/goals etc?</p>\n</blockquote>\n<p>There is a tiny bit on the FRO roadmap but no specifics</p>\n<blockquote>\n<p>Also, since you brought up GMP: I think I saw some mention of GMP being removed, but then perhaps being put back in? So when you say \"GMP-style\" I am not sure if you literally mean \"GMP\" or some kind of \"GMP reimplementation\". (I think I read this in a thread about olean incompatibility). Just out of curiosity, what's the plan here and why?</p>\n</blockquote>\n<p>Lean can link against GNU GMP but it does have its own GMP implementation which is the current default. There is currently a PR open to make GNU GMP the default again.</p>",
        "id": 473378252,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1727551467
    },
    {
        "content": "<blockquote>\n<p>There is a tiny bit on the FRO roadmap but no specifics</p>\n</blockquote>\n<p>Interesting.  Is that still based around some of the LLVM work that Siddharth (IIRC?) was doing a two/three years back?  (Sorry for the questions, I'm really OoTL.  I tried to get involved back then but my work took a completely different direction and so I'm only just trying to re-enter the ecosystem).</p>\n<blockquote>\n<p>There is currently a PR open to make GNU GMP the default again.</p>\n</blockquote>\n<p>Interesting, I think I found the PR and linked thread is the same one I mentioned above.  Unfortunately, the reasoning for going back remained partially unanswered there.</p>",
        "id": 473378828,
        "sender_full_name": "Tom",
        "timestamp": 1727551976
    },
    {
        "content": "<p>The LLVM work is entirely unrelated, that one is merged and cooperates with the old compiler. The new compiler was also started a few years back but interrupted when Leo got busy. Unfortuantely we have not yet had the cycles to finish it.</p>",
        "id": 473378884,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1727552033
    },
    {
        "content": "<p>Thank you, I really appreciate you taking the time to answer.</p>",
        "id": 473380014,
        "sender_full_name": "Tom",
        "timestamp": 1727552867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515083\">Tom</span> has marked this topic as resolved.</p>",
        "id": 473380016,
        "sender_full_name": "Notification Bot",
        "timestamp": 1727552871
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Type.20erasure.2Fcompilation.20questions/near/473374900\">said</a>:</p>\n<blockquote>\n<p>The representation of <code>Fin n</code> is the same as <code>Nat</code> since it's a one element struct. The <code>n</code> however will not be erased. After all every function that takes a <code>Fin n</code>has to take a (possibly implicit) argument <code>n : Nat</code> already. If that argument remains unused however it can indeed be optimized away.</p>\n</blockquote>\n<p>As far as I am aware this is not the case, it is not optimized away by lean and C compilers usually can't do anything about it because it's a public function</p>",
        "id": 473380404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727553205
    },
    {
        "content": "<p>There is a <code>_rarg</code> version generated by the compiler that does this optimization but <code>_rarg</code> is indeed not always used</p>",
        "id": 473380488,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1727553272
    },
    {
        "content": "<p>(and of course when inlining is applied as well(</p>",
        "id": 473380665,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1727553391
    },
    {
        "content": "<p>Confirmed that this happens in simple cases:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"n\">LEAN_EXPORT</span><span class=\"w\"> </span><span class=\"n\">lean_object</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">l_foo___rarg</span><span class=\"p\">(</span><span class=\"n\">lean_object</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">x_1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"nl\">_start</span><span class=\"p\">:</span>\n<span class=\"p\">{</span>\n<span class=\"n\">lean_object</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">x_2</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">lean_object</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">x_3</span><span class=\"p\">;</span>\n<span class=\"n\">x_2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lean_unsigned_to_nat</span><span class=\"p\">(</span><span class=\"mi\">1u</span><span class=\"p\">);</span>\n<span class=\"n\">x_3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lean_nat_sub</span><span class=\"p\">(</span><span class=\"n\">x_1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x_2</span><span class=\"p\">);</span>\n<span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">x_3</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Unfortunately slightly more complicated examples foil the optimization:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"n\">LEAN_EXPORT</span><span class=\"w\"> </span><span class=\"n\">lean_object</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">l_bar</span><span class=\"p\">(</span><span class=\"n\">lean_object</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">x_1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">lean_object</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">x_2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"nl\">_start</span><span class=\"p\">:</span>\n<span class=\"p\">{</span>\n<span class=\"kt\">size_t</span><span class=\"w\"> </span><span class=\"n\">x_3</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"kt\">size_t</span><span class=\"w\"> </span><span class=\"n\">x_4</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">lean_object</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">x_5</span><span class=\"p\">;</span>\n<span class=\"n\">x_3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lean_array_size</span><span class=\"p\">(</span><span class=\"n\">x_2</span><span class=\"p\">);</span>\n<span class=\"n\">x_4</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"n\">x_5</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">l_Array_mapMUnsafe_map___at_bar___spec__1</span><span class=\"p\">(</span><span class=\"n\">x_1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x_3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x_4</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x_2</span><span class=\"p\">);</span>\n<span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">x_5</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>(here <code>l_Array_mapMUnsafe_map___at_bar___spec__1</code> has an implementation that does not use the first argument <code>x_1</code>)</p>",
        "id": 473381144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727553807
    }
]