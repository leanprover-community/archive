[
    {
        "content": "<p>I was working on MIL and one of the proofs used <code>Nat.recOn</code>. I'm used to working with <code>match</code> statements so I reformatted the definition to use <code>let rec f := ...</code> but then found out that <code>f</code> doesn't show up in the tactic state. And even more odd,  the variable <code>f</code> is still useable (but not unfoldable). See below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- f is not defined in the tactic state</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">four</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\">  </span><span class=\"c1\">-- but I can still use it</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">four</span><span class=\"w\">  </span><span class=\"c1\">-- Tactic `unfold` failed: Local variable `f` has no definition</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 541911237,
        "sender_full_name": "Luna",
        "timestamp": 1759085029
    },
    {
        "content": "<p>this is expected</p>",
        "id": 541913330,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759087475
    },
    {
        "content": "<p>though I think the documentation could be better at explaining this</p>",
        "id": 541913380,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759087519
    },
    {
        "content": "<p>It elaborates into a mutual block, i.e.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">mutual</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- f is not defined in the tactic state</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">four</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">example</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\">  </span><span class=\"c1\">-- but I can still use it</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">example</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">four</span><span class=\"w\">  </span><span class=\"c1\">-- Tactic `unfold` failed: Local variable `f` has no definition</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">example</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">example</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>and you can't refer to the definition of something else in the same mutual block</p>",
        "id": 541913387,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1759087525
    },
    {
        "content": "<p>So if I want to be able to unfold the let definition, do I have to use <code>Nat.recOn</code>?</p>",
        "id": 541916503,
        "sender_full_name": "Luna",
        "timestamp": 1759091011
    },
    {
        "content": "<p>Yeah, or write an auxiliary definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">four</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">four</span><span class=\"w\"> </span><span class=\"c1\">-- \"\"works\"\" (unfold doesn't rewrite let values)</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 541917574,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1759092194
    },
    {
        "content": "<p>In my situation, <code>test.f</code> uses variables defined in <code>test</code> (but never recurses on <code>test</code>). So it will be much harder to pull out the definition. I'll most likely just continue with the <code>Net.recOn</code> option.</p>\n<p>And I'm confused because <code>unfold</code> rewrites the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 541917794,
        "sender_full_name": "Luna",
        "timestamp": 1759092475
    },
    {
        "content": "<p><code>let rec</code> doesn't behave all that similarly to <code>let</code>, if anything it's closer to <code>have</code></p>",
        "id": 541917921,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1759092644
    },
    {
        "content": "<p>There's an informal proposal to make the <code>let rec</code> tactic add the auxiliary definition to the environment. It's at the cost of not being able to do mutual recursion between the <code>let rec</code> definition and the theorem, but (1) you can use the <code>let rec</code> term or a <code>where</code> clause if you want the current behavior and (2) people ask about <code>let rec</code> not being unfoldable inside theorems all the time (which is reasonable, since the common case for defining a recursive definition with a tactic proof is to want to use its definition).</p>\n<p>One other justification for having the <code>let rec</code> tactic diverge from the behavior of the <code>let rec</code> term is that doing mutual recursion through the terms produced by tactics is somewhat brittle (it's always surprising to me when recursion from within an <code>induction</code> actually works), so given the benefit (being able to unfold definitions), it's not only an acceptable compromise, but arguably promoting writing more stable proofs.</p>",
        "id": 541991196,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1759139724
    },
    {
        "content": "<p>I assume that a proposal to give a new <code>have rec</code> the current opaque semantics and give <code>let rec</code> the ones you explained (without variation between tactic and term mode) would not be well-received?</p>",
        "id": 542001787,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1759142690
    },
    {
        "content": "<p>Tactic mode is special since there's a strict order for elaboration, which makes it clear how the proposed <code>let rec</code> tactic could work.</p>\n<p>Your suggestion is worth considering, and a complete RFC ought to evaluate the idea. (With that idea, <code>where</code> clauses would be sugar for <code>have rec</code> instead.) It's a rather large breaking change, and my feeling is that inside of definitions the need for knowing the definition is small.</p>\n<p>Maybe it's possible to generate equation lemmas for <code>let rec</code>s on demand (probably a big project). If that were to happen, then in that future we could keep the <code>let rec</code> tactic being the <code>let rec</code> term. Perhaps that's reason enough to not pursue <code>have rec</code>?</p>",
        "id": 542009744,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1759144825
    },
    {
        "content": "<p>I guess there's a related weaker proposal that is \"make <code>have</code> permit the same syntax as <code>let</code>\" (both <code>rec</code> and pattern matching), and leave dividing the semantics to a separate RFC</p>",
        "id": 542125778,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1759174760
    }
]