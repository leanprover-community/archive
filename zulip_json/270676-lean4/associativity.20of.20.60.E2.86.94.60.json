[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"c1\">-- error</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">P ↔ P : Prop</span>\n<span class=\"cm\">expected command</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>Because I still don't understand how to check binding power of notation I can't figure out whether <code>↔</code> is supposed to be left or right associative, but the parser doesn't seem to fancy either choice here; it consumes <code>P ↔ P</code> and then decides it's all over.</p>",
        "id": 236758486,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619736144
    },
    {
        "content": "<p><code>infix:20 \" ↔ \"   =&gt; Iff</code></p>",
        "id": 236759112,
        "sender_full_name": "Julian Berman",
        "timestamp": 1619736575
    },
    {
        "content": "<p>(from <a href=\"https://github.com/leanprover/lean4/blob/292bab5a11dc05e019068a579a42eac251bf587f/src/Init/Core.lean#L45\">https://github.com/leanprover/lean4/blob/292bab5a11dc05e019068a579a42eac251bf587f/src/Init/Core.lean#L45</a> )</p>",
        "id": 236759134,
        "sender_full_name": "Julian Berman",
        "timestamp": 1619736591
    },
    {
        "content": "<p>Incidentally, <code>↔</code> is associative, although that's a classical theorem, not intuitionistic</p>",
        "id": 236759983,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737072
    },
    {
        "content": "<p>It appears that lean 4 has a new command <code>infix</code> which means non-associative (in lean 3 this is a synonym for <code>infixl</code> meaning left-associative)</p>",
        "id": 236760269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737213
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- fine</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- unknown identifier `P`</span>\n</code></pre></div>\n<p>I think it's specific to <code>P</code>!</p>",
        "id": 236760394,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619737269
    },
    {
        "content": "<p>I can't replicate</p>",
        "id": 236760682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737416
    },
    {
        "content": "<p>I'm on today's nightly.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- compiles</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">A</span> <span class=\"bp\">↔</span> <span class=\"n\">A</span> <span class=\"bp\">↔</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- fails on third A</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- compiles?!</span>\n</code></pre></div>",
        "id": 236760712,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619737436
    },
    {
        "content": "<p>although this yields a very surprising result for me</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n<span class=\"n\">_</span> <span class=\"c1\">-- (∀ (P : Prop), P ↔ P) ↔ P</span>\n</code></pre></div>",
        "id": 236760792,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737474
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>buzzard@ebony:~/lean-projects/mathlib4_experiments$ lean --version\nLean <span class=\"o\">(</span>version <span class=\"m\">4</span>.0.0-nightly-2021-04-29, commit 40b17bc364dd, Release<span class=\"o\">)</span>\n</code></pre></div>",
        "id": 236760837,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619737510
    },
    {
        "content": "<p>just updated to that, still unchanged</p>",
        "id": 236760981,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737605
    },
    {
        "content": "<p>oh wait it's different in a clean file</p>",
        "id": 236761006,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737629
    },
    {
        "content": "<p>oh I see I had a variable P</p>",
        "id": 236761031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737649
    },
    {
        "content": "<p>this should work for you</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n<span class=\"n\">_</span> <span class=\"c1\">-- (∀ (P : Prop), P ↔ P) ↔ P</span>\n</code></pre></div>",
        "id": 236761047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737663
    },
    {
        "content": "<p>I can replicate <code>(∀ (P : Prop), P ↔ P) ↔ P</code></p>",
        "id": 236761048,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619737664
    },
    {
        "content": "<p>and it makes sense why you would get unknown identifier with that parse</p>",
        "id": 236761115,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737689
    },
    {
        "content": "<p>on the other hand</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>doesn't parse at all, the second <code>↔</code> seems to have ultra low precedence</p>",
        "id": 236761241,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737790
    },
    {
        "content": "<p>I don't think this is non-associativity after all</p>",
        "id": 236761307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619737819
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236760712\">said</a>:</p>\n<blockquote>\n<p>I'm on today's nightly.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- compiles</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">A</span> <span class=\"bp\">↔</span> <span class=\"n\">A</span> <span class=\"bp\">↔</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- fails on third A</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- compiles?!</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This is because it is being parsed as <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span>  showed and then the unbound lowercase latin letters are being auto bound as specified in <a href=\"https://leanprover.github.io/lean4/doc/autobound.html\">https://leanprover.github.io/lean4/doc/autobound.html</a></p>",
        "id": 236761867,
        "sender_full_name": "Mac",
        "timestamp": 1619738166
    },
    {
        "content": "<p>To quote from the page: \"When Lean processes the header of a declaration, any unbound identifier is automatically added as an implicit argument if it is a single lower case or greek letter.\"</p>",
        "id": 236761933,
        "sender_full_name": "Mac",
        "timestamp": 1619738222
    },
    {
        "content": "<p>I can confirm that <code>infix</code> is to blame:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\" # \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Eq</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"bp\">#</span> <span class=\"n\">P</span> <span class=\"bp\">#</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n<span class=\"n\">_</span> <span class=\"c1\">-- (∀ (P : Prop), P ↔ P) ↔ P</span>\n</code></pre></div>\n<p>changing <code>infix</code> for <code>infixl</code> or <code>infixr</code> causes the expected parse</p>",
        "id": 236761942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619738226
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> -- I had remembered the Greek letters but forgotten that it also worked with lower case</p>",
        "id": 236762119,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619738330
    },
    {
        "content": "<p>Probably has to do with the fixity of the universal quantifier</p>",
        "id": 236762120,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1619738331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236761942\">said</a>:</p>\n<blockquote>\n<p>I can confirm that <code>infix</code> is to blame:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\" # \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Eq</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"bp\">#</span> <span class=\"n\">P</span> <span class=\"bp\">#</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n<span class=\"n\">_</span> <span class=\"c1\">-- (∀ (P : Prop), P ↔ P) ↔ P</span>\n</code></pre></div>\n<p>changing <code>infix</code> for <code>infixl</code> or <code>infixr</code> causes the expected parse</p>\n</blockquote>\n<p>Recall that <code>infix:50 \" # \" =&gt; Eq</code> really means <code>notation:50 lhs:51 \" # \" rhs:51 =&gt; Eq lhs rhs</code> (<a href=\"https://leanprover.github.io/lean4/doc/syntax.html\">https://leanprover.github.io/lean4/doc/syntax.html</a>). As both sides have greater (numerical) precedence, neither side can now have <code>a # b</code> at all. So what happens is it falls down the precedence scale until reaches the universal quantifier, but then the precedence level resets inside the binder.</p>",
        "id": 236762444,
        "sender_full_name": "Mac",
        "timestamp": 1619738526
    },
    {
        "content": "<p>Though all this confusion is somewhat expected considering that <code>P ↔ Q ↔ R</code> is not a particularly well-formed statement in intuitionistic logic in the first place (using the binary biconditional). Neither associative approach, i.e. <code>P ↔ (Q ↔ R)</code> or <code>(P ↔ Q) ↔ R</code>, is generally desired. What you might want is a variadic biconditional that expands <code>P ↔ Q ↔ R</code> to <code>P ↔ Q /\\ Q ↔ R</code>, which could be done in a manner similar to the tuple notation.</p>",
        "id": 236762852,
        "sender_full_name": "Mac",
        "timestamp": 1619738846
    },
    {
        "content": "<p>Actually I think a better way to parse non-associative operators is to allow them, say, as left associative, but then throw an explicit error during macro expansion</p>",
        "id": 236763162,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619739072
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236763162\">said</a>:</p>\n<blockquote>\n<p>Actually I think a better way to parse non-associative operators is to allow them, say, as left associative, but then throw an explicit error during macro expansion</p>\n</blockquote>\n<p>That is certainly another option. Though I personally prefer that option that gives it meaning rather than one that deprives it of any. However, I do agree that, in the absence of a variadic version, an error is generally much more preferable than a cryptic parse.</p>",
        "id": 236763560,
        "sender_full_name": "Mac",
        "timestamp": 1619739334
    },
    {
        "content": "<p>The only reason all this started was that I was porting a Lean 3 file which used <code>P \\iff P \\iff true</code></p>",
        "id": 236763569,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619739342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236763569\">said</a>:</p>\n<blockquote>\n<p>The only reason all this started was that I was porting a Lean 3 file which used <code>P \\iff P \\iff true</code></p>\n</blockquote>\n<p>Lol. This is why explicit parentheses are sometimes a very good thing. :)</p>",
        "id": 236763707,
        "sender_full_name": "Mac",
        "timestamp": 1619739480
    },
    {
        "content": "<p>But in lean 3 I just look up the associativity of the operator and then I know how to parse. I still haven't really understood why this isn't going on in lean 4 although I do understand what's happening now you flagged the lower case issue</p>",
        "id": 236763797,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619739566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236763797\">said</a>:</p>\n<blockquote>\n<p>But in lean 3 I just look up the associativity of the operator and then I know how to parse.</p>\n</blockquote>\n<p>As far as I am aware, the same thing is true in Lean 4? Look up the definition of the notation and from there you can tell the precedence (the #) and the associativity, be it left (<code>infixl</code>), right (<code>infixr</code>) or none (<code>infix</code>).</p>",
        "id": 236764516,
        "sender_full_name": "Mac",
        "timestamp": 1619740084
    },
    {
        "content": "<p>My understanding of lean 3 was that you only had two options depending on whether the binding power of the second variable was equal to the first or one less</p>",
        "id": 236764630,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619740174
    },
    {
        "content": "<p>Ah, yeah, Lean 4 has expanded upon that.</p>",
        "id": 236765494,
        "sender_full_name": "Mac",
        "timestamp": 1619740764
    },
    {
        "content": "<p>The point of non-associative operators is to <em>force</em> people to write the parentheses one way or another, exactly for cases like these where it's hard to guess</p>",
        "id": 236766476,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619741355
    },
    {
        "content": "<p>which is why depriving that combination of operators of meaning is exactly the point. It's certainly better than the current behavior which is way outside what anyone would reasonably guess</p>",
        "id": 236766607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619741435
    },
    {
        "content": "<p>True. I was just saying variadic operators would be nice alternative too.</p>",
        "id": 236768502,
        "sender_full_name": "Mac",
        "timestamp": 1619742843
    },
    {
        "content": "<p>Has a conscious choice been made by lean4 to not allow <code>x rel y rel z</code> (eg <code>0 ≤ i ≤ j &lt; n</code>) as a shorthand for <code>x rel y \\and y rel z</code> like python, or is that still something that might be considered in future?</p>",
        "id": 236798289,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619768985
    },
    {
        "content": "<p>Or can such a feature be built easily with a macro?</p>",
        "id": 236798427,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619769067
    },
    {
        "content": "<p>It is definitely not the right semantics for all operators - <code>a \\ne b \\ne c</code> is usually meant to also imply <code>a \\ne c</code>, for example. So I think we will leave such extensions to the community.</p>",
        "id": 236799132,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619769487
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"s2\">\" = \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Eq</span>\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span>\n<span class=\"k\">#check</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span>\n<span class=\"k\">#check</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span>\n</code></pre></div>",
        "id": 236799145,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619769492
    },
    {
        "content": "<p>Personally I get annoyed by people writing <code>a \\ne b \\ne c</code> to also imply <code>a \\ne c</code> because I can't ever understand the logic which is supposed to let me deduce this, but I agree that I've seen this convention used in the wild.</p>",
        "id": 236799435,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619769649
    },
    {
        "content": "<p>I would rather have <code>a = b = c = d</code> expand to <code>tfae [a, b, c, d]</code>. In any case, my point was only for the default handling of <code>infix</code>. For specific operators it is possible to provide an alternative macro interpretation, especially if the normal one is explicitly declaiming responsibility.</p>",
        "id": 236819096,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619781219
    },
    {
        "content": "<p>I think I like this idea that <code>infix</code> and <code>infixl</code> and <code>infixr</code> are three different things. Not everything has to parse, and I have had issues with students being confused when doing group theory from scratch because I state associativity as <code>(a * b) * c = a * (b * c)</code> and Lean prints it as <code>a * b * c = a * (b * c)</code>. I <em>think</em> that in Lean 3 there was no way of making the prettyprinter print the thing which all the maths books would write when explaining associativity, and now one could do this temporarily and then actively switch it off later when you're sick of it, and the students will understand better.</p>",
        "id": 236821947,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619782973
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236821947\">said</a>:</p>\n<blockquote>\n<p>I think I like this idea that <code>infix</code> and <code>infixl</code> and <code>infixr</code> are three different things. Not everything has to parse, and I have had issues with students being confused when doing group theory from scratch because I state associativity as <code>(a * b) * c = a * (b * c)</code> and Lean prints it as <code>a * b * c = a * (b * c)</code>. I <em>think</em> that in Lean 3 there was no way of making the prettyprinter print the thing which all the maths books would write when explaining associativity, and now one could do this temporarily and then actively switch it off later when you're sick of it, and the students will understand better.</p>\n</blockquote>\n<p>This actually precisely why I like the variadic operator approach for things like addition and multiplication. It makes <code>(a * b * c)</code> distinct from <code>(a * b) * c</code> and <code>a * (b * c)</code> so the pretty printer will keep them all separate.</p>",
        "id": 236925373,
        "sender_full_name": "Mac",
        "timestamp": 1619833352
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236799435\">said</a>:</p>\n<blockquote>\n<p>Personally I get annoyed by people writing <code>a \\ne b \\ne c</code> to also imply <code>a \\ne c</code> because I can't ever understand the logic which is supposed to let me deduce this, but I agree that I've seen this convention used in the wild.</p>\n</blockquote>\n<p>Unfortunately, I am in camp <code>a \\ne b \\ne c</code> implies <code>a \\ne c</code>. To me, the variadic <code>\\ne</code> means mutual distinction, just as the variadic <code>=</code> means mutual equality.</p>",
        "id": 236925475,
        "sender_full_name": "Mac",
        "timestamp": 1619833473
    },
    {
        "content": "<p>Variadic <code>ne</code> is just weird. I don't think I've ever seen it in a paper!</p>",
        "id": 236927762,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619835563
    },
    {
        "content": "<p>I am in the camp that says <code>ne</code> is <code>infix</code> and <code>a \\ne b \\ne c</code> is ambiguous and should be avoided</p>",
        "id": 236929397,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619836955
    },
    {
        "content": "<p>I might not have seen it in a paper but I've seen it on a blackboard (and winced)</p>",
        "id": 236949463,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619857444
    },
    {
        "content": "<p>I mentally add an extra <code>\\ne a</code>, for my mental sanity, when I see it...</p>",
        "id": 236950580,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619858558
    },
    {
        "content": "<p><a href=\"https://xkcd.com/859/\">https://xkcd.com/859/</a></p>",
        "id": 236951525,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619859669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236950580\">said</a>:</p>\n<blockquote>\n<p>I mentally add an extra <code>\\ne a</code>, for my mental sanity, when I see it...</p>\n</blockquote>\n<p>That only works for three variables, though. With four variables you can at least still draw a graph with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo mathvariant=\"normal\">≠</mo></mrow><annotation encoding=\"application/x-tex\"> \\neq </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span></span></span></span>-edges on the blackboard, with five variables, that graph isn't planar anymore ;)</p>",
        "id": 237043239,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1619950902
    },
    {
        "content": "<p>Now that's just planar silly</p>",
        "id": 237043394,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1619951065
    },
    {
        "content": "<p>Just do <code>a ≠ b ≠ c ≠ a ≠ d ≠ c ≠ d ≠ b</code>...</p>",
        "id": 237044497,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619952455
    },
    {
        "content": "<p>Any path through the graph covering every edge is fine!</p>",
        "id": 237044601,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619952538
    },
    {
        "content": "<p>You can't do that without repeating yourself somewhere for even n &gt; 2</p>",
        "id": 237046990,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619955471
    },
    {
        "content": "<p>Yeah, I meant that as a joke</p>",
        "id": 237047854,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619956482
    },
    {
        "content": "<p>I tend to write <code>a \\ne b, c</code>, i feel like that's less ambiguous</p>",
        "id": 237051387,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1619960415
    },
    {
        "content": "<p>Unless <code>b \\ne c</code> is also part of it</p>",
        "id": 237051446,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1619960480
    },
    {
        "content": "<p>I've seen profs write <code>a \\ne b \\ne c</code> before and I don't like it</p>",
        "id": 237051464,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1619960508
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237043239\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/236950580\">said</a>:</p>\n<blockquote>\n<p>I mentally add an extra <code>\\ne a</code>, for my mental sanity, when I see it...</p>\n</blockquote>\n<p>That only works for three variables, though. With four variables you can at least still draw a graph with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo mathvariant=\"normal\">≠</mo></mrow><annotation encoding=\"application/x-tex\"> \\neq </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span></span></span></span>-edges on the blackboard, with five variables, that graph isn't planar anymore ;)</p>\n</blockquote>\n<p>This actually why I like this definition of variadic <code>≠</code>, it means that <code>a ≠ b ≠ c ≠ d ≠ e</code> is shorthand for a much longer set of <code>≠</code>s. In fact, if I remember my math right, an <code>≠</code> of arity N is equal to <code>N choose 2</code> manually written <code>≠</code>s, which is some nice space savings. :)</p>",
        "id": 237064760,
        "sender_full_name": "Mac",
        "timestamp": 1619973441
    },
    {
        "content": "<p>Probably you want <code>list.pairwise ne [a,b,c,d]</code> at that point though, or similar</p>",
        "id": 237064831,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619973506
    },
    {
        "content": "<p>Else actually constructing or dissecting the terms would be awful</p>",
        "id": 237064860,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619973558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237064831\">said</a>:</p>\n<blockquote>\n<p>Probably you want <code>list.pairwise ne [a,b,c,d]</code> at that point though, or similar</p>\n</blockquote>\n<p>Well, yeah, that would be the logical expansion, yes. Just like <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  mentioned that <code>a = b = c = d</code> could be expanded to <code>tfae [a,b,c,d]</code>, <code>a ≠ b ≠ c ≠ d</code> could be expanded to <code>list.pairwise ne [a,b,c,d]</code></p>",
        "id": 237065064,
        "sender_full_name": "Mac",
        "timestamp": 1619973776
    },
    {
        "content": "<p>I think the notation itself is problematic though</p>",
        "id": 237065082,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619973806
    },
    {
        "content": "<p>It <em>could</em> be expanded to that, yes. I don't think it's a good idea</p>",
        "id": 237065093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619973821
    },
    {
        "content": "<p>if you want pairwise ne then say so</p>",
        "id": 237065102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619973838
    },
    {
        "content": "<p>When I read <code>a ≠ b ≠ c ≠ d</code> that is what I expect (pairwise ne) and that is also the way I would prefer pairwise ne to be denoted. I guess this just a place where we disagree on style.</p>",
        "id": 237065170,
        "sender_full_name": "Mac",
        "timestamp": 1619973896
    },
    {
        "content": "<p>For one thing, if it is expanded that way, then it won't be obvious that you should be looking in the <code>pairwise</code> namespace for lemmas about <code>a ≠ b ≠ c ≠ d</code></p>",
        "id": 237065183,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619973911
    },
    {
        "content": "<p>unless there are just two things in which case you should look at <code>ne</code></p>",
        "id": 237065211,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619973952
    },
    {
        "content": "<p>that kind of clever expansion seems like it would confuse more than help</p>",
        "id": 237065267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619973979
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237065183\">said</a>:</p>\n<blockquote>\n<p>For one thing, if it is expanded that way, then it won't be obvious that you should be looking in the <code>pairwise</code> namespace for lemmas about <code>a ≠ b ≠ c ≠ d</code></p>\n</blockquote>\n<p>I would probably define something like <code>def mutual_distinction := list.pairwise ne</code> and have it expand to <code>mutual_distinction</code> instead (and have theorems on <code>mutual_distinction</code></p>",
        "id": 237065277,
        "sender_full_name": "Mac",
        "timestamp": 1619973994
    },
    {
        "content": "<p>sure, same difference</p>",
        "id": 237065289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974008
    },
    {
        "content": "<p>the notation doesn't say <code>mutual_distinction</code> so how will you know to look there?</p>",
        "id": 237065305,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974028
    },
    {
        "content": "<p>That's what I would assume <code>a ≠ b ≠ c ≠ d</code> means</p>",
        "id": 237065341,
        "sender_full_name": "Mac",
        "timestamp": 1619974055
    },
    {
        "content": "<p>I mean the words \"mutual distinction\" appear nowhere</p>",
        "id": 237065350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974070
    },
    {
        "content": "<p>In fact I would argue that is also what <code>a ≠ b</code> means</p>",
        "id": 237065353,
        "sender_full_name": "Mac",
        "timestamp": 1619974077
    },
    {
        "content": "<p>this is a non-discoverable bit of magic syntax</p>",
        "id": 237065399,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974098
    },
    {
        "content": "<p>In the same vein: how do I know that <code>≠</code> means <code>ne</code>, where is that written in the notation?</p>",
        "id": 237065422,
        "sender_full_name": "Mac",
        "timestamp": 1619974125
    },
    {
        "content": "<p>If <code>a ≠ b</code> means <code>mutual_distinction [a, b]</code>, then how do you say <code>ne a b</code>?</p>",
        "id": 237065433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974144
    },
    {
        "content": "<p><code>mutual_distinction [a, b]</code> and <code>ne [a, b]</code> are defeq in my book..</p>",
        "id": 237065448,
        "sender_full_name": "Mac",
        "timestamp": 1619974176
    },
    {
        "content": "<p><code>ne</code> is a binary operator defined as <code>a = b -&gt; false</code></p>",
        "id": 237065456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974193
    },
    {
        "content": "<p>which exists regardless of whether <code>mutual_distinction</code> exists</p>",
        "id": 237065510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974215
    },
    {
        "content": "<p>Same thing with <code>eq a b</code>, we can't have everything be n-ary</p>",
        "id": 237065549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974257
    },
    {
        "content": "<p>If you are going by the current Lean Core, yes? This is about alternative definitions (as Lean doesn't currently have a variadic <code>ne</code>)</p>",
        "id": 237065554,
        "sender_full_name": "Mac",
        "timestamp": 1619974266
    },
    {
        "content": "<p>No, I'm talking about what it could/should be</p>",
        "id": 237065571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974294
    },
    {
        "content": "<p>It would be very disruptive if <code>Eq</code> was not a binary operator</p>",
        "id": 237065584,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974318
    },
    {
        "content": "<p>Well then I don't agree that <code>ne</code> should actually always be defined as <code>a = b -&gt; false</code></p>",
        "id": 237065627,
        "sender_full_name": "Mac",
        "timestamp": 1619974332
    },
    {
        "content": "<p>Okay, so when I want <code>a = b -&gt; false</code> what do I write?</p>",
        "id": 237065651,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974353
    },
    {
        "content": "<p>that?</p>",
        "id": 237065666,
        "sender_full_name": "Mac",
        "timestamp": 1619974382
    },
    {
        "content": "<p>I submit that the vast majority of the time when ne is used it is binary and means that</p>",
        "id": 237065686,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974402
    },
    {
        "content": "<p>adding an indirection through <code>mutual_distinction</code> would make things worse for the majority of applications</p>",
        "id": 237065699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974436
    },
    {
        "content": "<p>I disagree, there are entire logics where <code>a = b -&gt; false</code> is not a valid construction (and yet ne exists)</p>",
        "id": 237065700,
        "sender_full_name": "Mac",
        "timestamp": 1619974438
    },
    {
        "content": "<p>?</p>",
        "id": 237065740,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974446
    },
    {
        "content": "<p>We're talking about lean, yes?</p>",
        "id": 237065767,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974466
    },
    {
        "content": "<p>Yes, and you can construct alternative logics in Lean.</p>",
        "id": 237065801,
        "sender_full_name": "Mac",
        "timestamp": 1619974510
    },
    {
        "content": "<p>If you want to make not not mean <code>p -&gt; false</code> that is considerably more disruptive</p>",
        "id": 237065802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974511
    },
    {
        "content": "<p>Yes, true, but sometimes that is desired.</p>",
        "id": 237065830,
        "sender_full_name": "Mac",
        "timestamp": 1619974553
    },
    {
        "content": "<p>Okay but in an alternative logic the notations are not my business</p>",
        "id": 237065833,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974557
    },
    {
        "content": "<p>I'm talking about general mathematics a la mathlib</p>",
        "id": 237065885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974579
    },
    {
        "content": "<p>Well, in my opinion, it is just like <code>+</code>, <code>=</code> and <code>≠</code> should just be defined based on classes that are defined differently for different types</p>",
        "id": 237065907,
        "sender_full_name": "Mac",
        "timestamp": 1619974619
    },
    {
        "content": "<p><code>Eq</code> is a typeclass now? Equality is a core concept of DTT, you can't get away from it and lean isn't really set up for that</p>",
        "id": 237066004,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974730
    },
    {
        "content": "<p>I would define them something like the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Eq</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Ne</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">ne</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">P</span>\n</code></pre></div>\n<p>This definition, afaik, is entirely compatible with the current definition of the two in Lean.</p>",
        "id": 237066008,
        "sender_full_name": "Mac",
        "timestamp": 1619974737
    },
    {
        "content": "<p><code>Eq</code> is heq, no?</p>",
        "id": 237066029,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1619974779
    },
    {
        "content": "<p>No, <code>HEq</code> is heq</p>",
        "id": 237066037,
        "sender_full_name": "Mac",
        "timestamp": 1619974793
    },
    {
        "content": "<p>One issue with that definition is that you can't write <code>h : a = b</code> because <code>a = b</code>  isn't necessarily a type</p>",
        "id": 237066175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974885
    },
    {
        "content": "<p>The Prop instances (their current definitions) would look like the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[defaultInstance low]</span> <span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}:</span> <span class=\"n\">Eq</span> <span class=\"kt\">Prop</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">eq</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span><span class=\"o\">}</span>\n<span class=\"kd\">@[defaultInstance low]</span> <span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}:</span> <span class=\"n\">Ne</span> <span class=\"kt\">Prop</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">ne</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 237066195,
        "sender_full_name": "Mac",
        "timestamp": 1619974921
    },
    {
        "content": "<p>Is <code>P</code> an outparam? I think it needs to be if you don't want lots of inference issues</p>",
        "id": 237066264,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619974969
    },
    {
        "content": "<p>The defaulting will resolve that (afaik)</p>",
        "id": 237066300,
        "sender_full_name": "Mac",
        "timestamp": 1619974991
    },
    {
        "content": "<p>(same reason you don't get all kinds of issues with inference with Nat literals)</p>",
        "id": 237066377,
        "sender_full_name": "Mac",
        "timestamp": 1619975056
    },
    {
        "content": "<p>What is the advantage of doing this? It won't make <code>Eq</code> the inductive type go away</p>",
        "id": 237066379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619975056
    },
    {
        "content": "<p>I makes Lean's core (and the notation) more general, allowing it to be used more easily in alternative use cases (such as mine).</p>",
        "id": 237066398,
        "sender_full_name": "Mac",
        "timestamp": 1619975102
    },
    {
        "content": "<p>This topic was moved by <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> to <a class=\"stream-topic\" data-stream-id=\"236446\" href=\"/#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204\">#Type theory &gt; Metamathematics in lean 4</a></p>",
        "id": 237082713,
        "sender_full_name": "Notification Bot",
        "timestamp": 1619989322
    }
]