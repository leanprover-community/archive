[
    {
        "content": "<p>I have a bunch of theorems which are identities of boolean circuits over a reasonably small number of bits.  For example,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">UInt128</span> <span class=\"n\">where</span>\n  <span class=\"n\">lo</span> <span class=\"o\">:</span> <span class=\"n\">UInt64</span>\n  <span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">UInt64</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">UInt128.toNat</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">UInt128</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">x.hi.toNat</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"mi\">64</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">x.lo.toNat</span>\n\n<span class=\"sd\">/-- Add with carry, producing the `{0,1}` value as an `UInt64` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">addc</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">UInt64</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">UInt64</span> <span class=\"bp\">×</span> <span class=\"n\">UInt64</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span>\n  <span class=\"o\">(</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">z</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Split a `UInt64` into low and high 32-bit values, both represented as `UInt64` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">split</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">UInt64</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">UInt64</span> <span class=\"bp\">×</span> <span class=\"n\">UInt64</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">x.toUInt32.toUInt64</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;&gt;&gt;</span> <span class=\"mi\">32</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- All the bits of two `UInt64`s multiplied together -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">mul128</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">UInt64</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">UInt128</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">x0</span><span class=\"o\">,</span><span class=\"n\">x1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">split</span> <span class=\"n\">x</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">y0</span><span class=\"o\">,</span><span class=\"n\">y1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">split</span> <span class=\"n\">y</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">a1</span><span class=\"o\">,</span><span class=\"n\">a3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">addc</span> <span class=\"o\">(</span><span class=\"n\">x1</span> <span class=\"bp\">*</span> <span class=\"n\">y0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x0</span> <span class=\"bp\">*</span> <span class=\"n\">y1</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">b1</span><span class=\"o\">,</span><span class=\"n\">b2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">split</span> <span class=\"n\">a1</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">c0</span><span class=\"o\">,</span><span class=\"n\">c2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">addc</span> <span class=\"o\">(</span><span class=\"n\">x0</span> <span class=\"bp\">*</span> <span class=\"n\">y0</span><span class=\"o\">)</span> <span class=\"n\">b1</span>\n  <span class=\"o\">⟨</span><span class=\"n\">c0</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a3</span> <span class=\"bp\">&lt;&lt;&lt;</span> <span class=\"mi\">32</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">x1</span> <span class=\"bp\">*</span> <span class=\"n\">y1</span> <span class=\"bp\">+</span> <span class=\"n\">b2</span> <span class=\"bp\">+</span> <span class=\"n\">c2</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">toNat_mul128</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">UInt64</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">mul128</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNat</span> <span class=\"bp\">=</span> <span class=\"n\">x.toNat</span> <span class=\"bp\">*</span> <span class=\"n\">y.toNat</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Do we have tactic machinery that can prove this kind of theorem automatically, with the only work being converting the theorem into the underlying Boolean circuit identity?  If I were doing normal programming, I'd write a randomized unit test and \"prove\" it with the Schwartz-Zippel lemma.  If it was available, presumably Z3  could do it (after some mechanical translation work), proving a trace that Lean could then check.  Is that Z3 setup available yet?</p>\n<p>(Caveat: Quite possibly that <code>mul128</code> implementation is buggy, since I haven't filled in the <code>sorry</code> yet.)</p>",
        "id": 398772017,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1698356751
    },
    {
        "content": "<p>Maybe the way to handle this is to go back and forth with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.BitVec#doc\">docs#Std.BitVec</a>, and show that the analogous result is true for some arbitrary number of bits</p>",
        "id": 398772959,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698357319
    },
    {
        "content": "<p>Though you'll likely have a bad time until we finish merging it with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Bitvec#doc\">docs#Bitvec</a></p>",
        "id": 398772995,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698357352
    },
    {
        "content": "<p>I've already proven a variety of other theorems that way, but it would be nice if I could get them for free from SAT/SMT solvers given that they really are fundamentally fixed size (I'm working up towards some numerical computations).  <a href=\"https://github.com/ufmg-smite/lean-smt\">https://github.com/ufmg-smite/lean-smt</a> seems to be one attempt in this direction, but it says \"This project is in its early design/development phase and is not recommended for use.\"</p>",
        "id": 398773173,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1698357450
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"514145\">@Geoffrey Irving</span>, this sort of application is considered very high priority by the FRO, but ... there's nothing production ready for you. :-)</p>",
        "id": 398782123,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1698362699
    }
]