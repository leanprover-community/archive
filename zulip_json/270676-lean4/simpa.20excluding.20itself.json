[
    {
        "content": "<p>A minor wish of mine for <code>simpa</code>:</p>\n<p>Sometimes I know that, after simplification, the resulting goal will be equivalent to a theorem <code>foo</code>. I could type <code>simp; exact foo</code>. But I prefer to type <code>simpa using foo</code>.</p>\n<p>But then, sometimes it happens that <code>foo</code> is a <code>@[simp]</code> theorem itself. So then actually what happens if I type <code>simpa using foo</code> is that after simplification, the conclusion is just <code>True</code>, and it fails. So I have to do <code>simpa [-foo] using foo</code>, which feels a little silly.</p>\n<p>How hard would it be to have simpa check if the closing argument is a term whose head is a simp theorem and, if it is, exclude it from the simp set by default? Or, maybe even more usefully, just exclude it from the simp set when simplifying the RHS (but not the current goal)?</p>",
        "id": 515763472,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1746206920
    },
    {
        "content": "<p>This is basically <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/lean.234290.20Closed.20simp.20tries.20using.20the.20forward.20version.20of.20use/with/511817034\">#lean4 &gt; lean#4290 Closed simp tries using the forward version of use</a> (I had your complaint in mind when I wrote it, but thought I would raise the more obviously egregious behavior first)</p>",
        "id": 515764020,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1746207116
    },
    {
        "content": "<p>For a little illustrative example, I have a goal something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">&lt;</span><span class=\"n\">stuff</span><span class=\"bp\">&gt;</span>\n<span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyStruct</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">nodes</span><span class=\"w\"> </span><span class=\"bp\">⟨↑</span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">depth</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">depth</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">depth</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⋯⟩</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span>\n</code></pre></div>\n<p>I have a simp theorem reading</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">MyStruct</span><span class=\"bp\">.</span><span class=\"n\">nodes_last</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">inp</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyStruct</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">inp</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"bp\">.</span><span class=\"n\">nodes</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"bp\">.</span><span class=\"n\">depth</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">out</span>\n</code></pre></div>\n<p>so now if I call <code>simp</code>, I get the goal</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">nodes</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">depth</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⋯⟩</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span>\n</code></pre></div>\n<p>which is defeq to the fact <code>g.nodes_last</code>, which has type <code>g.nodes (Fin.last g.depth) = out</code>. But simp doesn't apply <code>g.nodes_last</code> because it doesn't recognize that the <code>Fin.last g.depth</code> is the same as <code>⟨g.depth, ⋯⟩</code>.</p>\n<p>If I run <code>simpa using g.nodes_last</code>, then I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">term</span>\n<span class=\"w\">  </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">nodes_last</span>\n<span class=\"n\">after</span><span class=\"w\"> </span><span class=\"n\">simplification</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">nodes</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">depth</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⋯⟩</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>so I have to use</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">MyStruct</span><span class=\"bp\">.</span><span class=\"n\">nodes_last</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">nodes_last</span>\n</code></pre></div>\n<p>instead.</p>",
        "id": 515764109,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1746207129
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/270676-lean4/topic/simpa.20excluding.20itself/near/515764020\">said</a>:</p>\n<blockquote>\n<p>This is basically <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/lean.234290.20Closed.20simp.20tries.20using.20the.20forward.20version.20of.20use/with/511817034\">#lean4 &gt; lean#4290 Closed simp tries using the forward version of use</a></p>\n</blockquote>\n<p>Oh, taking a look now, thanks</p>",
        "id": 515764266,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1746207190
    },
    {
        "content": "<p>Mm, that seems like a similar principle, but I think the mechanics of the simp there are pretty separate (this seems like a <code>simpa</code>-specific behavior)</p>",
        "id": 515765626,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1746207610
    },
    {
        "content": "<blockquote>\n<p>So I have to do <code>simpa [-foo] using foo</code>, which feels a little silly.</p>\n</blockquote>\n<p>This is nice trick; it makes the following work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">id'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">id</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">id'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">eq_self</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"c1\">-- avoids non-terminal simp as in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">id'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"c1\">-- even though such non-terminal simp is practically allowed.</span>\n<span class=\"c1\">-- In Lean 3 `simpa` simply worked.</span>\n</code></pre></div>",
        "id": 515801277,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1746221239
    }
]