[
    {
        "content": "<p>Adding the following syntax declaration leads to an infinite loop in parsing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"test\"</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span>\n\n<span class=\"n\">a</span>\n</code></pre></div>\n<p>As does using <code>many</code> instead of <code>sepBy</code>.</p>\n<p>The reason is that the added syntax declaration is the best parser to run. So it runs it and then creates an error. But since it is optional to have a \"test\", it restores the state (i.e. removes the error and resets the position). Therefore, the result of attempting to parse a command is the same starting position with no error message. And so it loops.</p>\n<p>There is already a check in <code>parseCommand</code> to prevent looping by consuming input if the position hasn't changed and there is an error. It seems to me that a reasonable fix would be to move this check to also occur in the case where this no error.</p>",
        "id": 566296597,
        "sender_full_name": "Eric Paul",
        "timestamp": 1767601474
    },
    {
        "content": "<p>Essentially the same issue can cause an infinite loop in parsing in other syntax categories, meaning that the fix I'd mentioned above is not actually sufficient. (Really the change is not that it is in a different syntax category but that the infinite loop happens in a different place.)</p>\n<p>For example, the following also gets stuck in an infinite loop:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">declare_syntax_cat</span><span class=\"w\"> </span><span class=\"n\">testing</span>\n\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"n\">testing</span><span class=\"w\"> </span><span class=\"s2\">\"test\"</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">testing</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"lead\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">testing</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"[[\"</span><span class=\"w\"> </span><span class=\"n\">testing</span><span class=\"w\"> </span><span class=\"s2\">\"]]\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span>\n\n<span class=\"o\">[[</span><span class=\"w\"> </span><span class=\"n\">lead</span><span class=\"w\"> </span><span class=\"o\">]]</span>\n</code></pre></div>\n<p>The infinite loop in this example is inside of <code>trailingLoop</code>. The trailing parser involving <code>sepBy</code> is chosen as it is the best choice. As before, it errors and then restores the state. Since there is no longer an error, <code>trailingLoop</code> is called again and repeats.</p>\n<p>Perhaps the <code>trailingLoop</code> should check to see if the successful parse did not consume input and if so, exit the loop.</p>",
        "id": 566447374,
        "sender_full_name": "Eric Paul",
        "timestamp": 1767651524
    },
    {
        "content": "<p>Maybe it would also be reasonable to reject these syntax declaration, i.e. error that <code>\"test\",*</code> accepts the empty string?</p>",
        "id": 566567961,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1767713718
    },
    {
        "content": "<p>After all, <code>\"test\",+</code> works and does what you expect in both examples</p>",
        "id": 566568050,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1767713747
    },
    {
        "content": "<p>That makes sense. I worry that it might be hard to determine if a syntax declaration accepts the empty string in the right sense. For example, <code>syntax \"test\",* lookahead(\"hi\") : command</code> will infinitely loop on the input <code>hi</code> and technically does not accept the empty string.</p>\n<p>I also personally like the idea that anything I can express with <code>syntax</code> is a valid addition.</p>",
        "id": 566848251,
        "sender_full_name": "Eric Paul",
        "timestamp": 1767832656
    }
]