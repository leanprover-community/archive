[
    {
        "content": "<p>Fellow Lean users,</p>\n<p>I am currently developing an iterator framework for the Lean standard library. After three weeks of work, I have a first draft and would be glad to find out how you like it.</p>\n<p>The latest working version can be found in <a href=\"https://github.com/datokrat/lean-iterators\">this repository</a>. It's not part of the <code>lean4</code> repository yet and you should be able to just clone and open the project like any other.</p>\n<h2>What are iterators and why do we need them?</h2>\n<p>Let's answer by example first. Iterators allow you to obtain efficient code from expressions like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">hideEggs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Repeat colors and locations indefinitely</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">colors</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Iter.unfold</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"s2\">\"green\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"red\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"yellow\"</span><span class=\"o\">][</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">locations</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Iter.unfold</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"s2\">\"in a boot\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"underneath a lampshade\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"under the cushion\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"in the lawn\"</span><span class=\"o\">][</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Summon the chickens</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">chickens</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"Clucky\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"Patches\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"Fluffy\"</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">iter</span><span class=\"w\"> </span><span class=\"n\">Id</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Gather, color and hide the eggs</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">eggs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">chickens.flatMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Iter.unfold</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">take</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">|&gt;.</span><span class=\"n\">zip</span><span class=\"w\"> </span><span class=\"n\">colors</span>\n<span class=\"w\">    </span><span class=\"bp\">|&gt;.</span><span class=\"n\">zip</span><span class=\"w\"> </span><span class=\"n\">locations</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Report the results (top secret)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">eggsIO</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">eggs.switchMonad</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- Obtain an IO-monadic iterator</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">eggsIO</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">IO.println</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"s2\">\"{x.1.1} hides a {x.1.2} egg {x.2}.\"</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Alternative : eggsIO.mapM (fun x =&gt; IO.println s!\"{x.1.1} hides a {x.1.2} egg {x.2}.\") |&gt;.drain</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">info: Clucky hides a green egg in a boot.</span>\n<span class=\"sd\">Clucky hides a red egg underneath a lampshade.</span>\n<span class=\"sd\">Clucky hides a yellow egg under the cushion.</span>\n<span class=\"sd\">Patches hides a green egg in the lawn.</span>\n<span class=\"sd\">Patches hides a red egg in a boot.</span>\n<span class=\"sd\">Patches hides a yellow egg underneath a lampshade.</span>\n<span class=\"sd\">Fluffy hides a green egg under the cushion.</span>\n<span class=\"sd\">Fluffy hides a red egg in the lawn.</span>\n<span class=\"sd\">Fluffy hides a yellow egg in a boot.</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">hideEggs</span>\n</code></pre></div>\n<p>It's also possible to manually iterate:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">deepSum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l.iter</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">flatMap</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">l'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">l'.iter</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"kd\">@[</span><span class=\"n\">specialize</span><span class=\"kd\">]</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">it.step</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">yield</span><span class=\"w\"> </span><span class=\"n\">it'</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">it'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">skip</span><span class=\"w\"> </span><span class=\"n\">it'</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">it'</span><span class=\"w\"> </span><span class=\"n\">acc</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">acc</span>\n<span class=\"w\">  </span><span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">it.terminationByFinite</span>\n\n<span class=\"sd\">/-- info: 10 -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">deepSum</span><span class=\"w\"> </span><span class=\"o\">[[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">]]</span>\n</code></pre></div>\n<p>Iterators are objects that allow you to step through a sequence of values, either manually or by calling some predefined consumer. For example, <code>List.iter</code> converts a list into an iterator over its elements. Iterators essentially consist of a single <code>next</code> or <code>step</code> function that potentially provides an output value and a successor iterator. They exist in most programming languages like Java (Streams API), Rust (<code>Iter</code> trait), Python (itertools) or Haskell (streamly package).</p>\n<p>Iterators sometimes help to concisely write down complicated loops. This is especially interesting in Lean where it can be tedious to prove the termination of such a loop. The iterator library automatically keeps track of the termination behavior so that you usually do not need to provide an explicit termination proof.</p>\n<p>Thanks for your time and feedback! Let's make it a really awesome iterator library while we can still work on the fundamentals without a lot of breakage.</p>\n<h2>Objectives of the library</h2>\n<p>It should be fast (comparable to Rust) and easy to use. It should work in a monadic setting and -- if users are ready to accept the additional complexity -- allow changing the monad and even the universe level. Verification should be possible in a reasonable amount of time.</p>\n<p>But most importantly, it should be useful in real-world situations.</p>\n<h2>What I'd like to know from you</h2>\n<p>I'm interested in basically all your thoughts about the current state iterator API!</p>\n<ul>\n<li>Do you wish for some functionality or feature that's still missing?</li>\n<li>Is something more tedious than you'd like?</li>\n<li>Is some part of the API hard to understand? Iterators should be as easy as in other languages (except if you start doing crazy stuff with universes or multiple different monads...).</li>\n<li>Is there something you especially like?</li>\n<li>Do you have a compelling use case that would be valuable for me to keep in mind?</li>\n<li>...</li>\n</ul>\n<h2>What's known to be deficient</h2>\n<ul>\n<li>Lemmas are planned but currently nonexistent except for termination proofs.</li>\n<li>The library has been carefully designed for the possibility of switching monads and universes but we're still missing an iterator combinator that actually allows switching the universe.</li>\n<li>There are still occasionally problems and bad elaborator error messages. Keeping track of the complicated underlying types of the iterators is difficult for Lean right now. Nevertheless, please report such situations to me so I can work on improving the situation.</li>\n<li>It's still a work in progress, so the API can still change heavily in the next weeks.</li>\n<li>There's no string iterator yet. I'm planning to implement one and replace the legacy string iterator in the standard library.</li>\n<li>The iterators aren't producing highly efficient code yet. While there are things I can do in the library, it also partly depends on the compiler, which is undergoing some heavy (positive) changes right now. This is still a work in progress.</li>\n<li>I have heard the wish for <code>groupby</code>, which is a combinator in Python's <a href=\"https://docs.python.org/3/library/itertools.html\">itertools</a>. Unfortunately, I don't really know yet how to make that one in a functional-but-in-place language. I guess it will somehow involve <code>Thunk</code> to avoid duplication. If you, too, would like to see this combinator, feel free to just react with <span aria-label=\"otter\" class=\"emoji emoji-1f9a6\" role=\"img\" title=\"otter\">:otter:</span> .</li>\n</ul>",
        "id": 512835936,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1744898939
    },
    {
        "content": "<p>Thanks! My feedback is that this code is very hard to read for me. I have a very hard time guessing what it’s meant to express. I could not have predicted the outcome of <code>#eval hideEggs</code> from the function names. Maybe there could be macros turning this into code that is easy to understand?</p>",
        "id": 512864316,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1744906202
    },
    {
        "content": "<p>Thanks, Patrick! Do you find both examples hard to read? I'd also be curious about what you think about readability compared to other iterator libraries if you have used one of those before (Rust, Java, Python, ...) or what they might be doing better.</p>\n<p>I'm not sure about the necessity of macros yet. What would you hope macros can do that we can't do without them? I think lot can be achieved with convenience library functions that just don't exist yet. Without macros, just with better library support, the complex example might look as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">hideEggs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Repeat colors and locations indefinitely</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">colors</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"green\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"red\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"yellow\"</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">iter.repeatForever</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">locations</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"in a boot\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"underneath a lampshade\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"under the cushion\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"in the lawn\"</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">iter.repeatForever</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Summon the chickens</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">chickens</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"Clucky\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"Patches\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"Fluffy\"</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">iter</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Gather, color and hide the eggs</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">eggs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Iter.combine</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">chickens.flatMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">chicken</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">chicken</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">iter.repeat</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">colors</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">locations</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Report the results (top secret)</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">chicken</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">color</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">location</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">eggs</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">IO.println</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{chicken} hides a {color} egg {location}.\"</span>\n</code></pre></div>\n<p>(Just a rough sketch, those function names should be consistent with existing ones for <code>List</code> etc.)</p>\n<p>I should say that I basically crammed all of the interesting combinators we currently have into one example, which might not be the best way to produce readable code in the first place. I think I'll add some more real-world examples on Tuesday when I'm back at work.</p>",
        "id": 512915402,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1744923842
    },
    {
        "content": "<p>Nice! I find the code quite readable. A bit confused by <code>Iter.unfold Id 0 (. + 1)</code> but from the comment I got the message that you want to start at zero and progress by adding one. The really confusing part is <code>chickens.flatMap (fun x : String =&gt; Iter.unfold Id x id |&gt;.take 3)</code> in particular the function name <code>take</code>, I would expect <code>repeat</code> or <code>replicate</code>. However, I understand that this is a low level API, the envisioned higher level one is perfectly clear to me.</p>\n<p>(Ohh I get it now, you create an infinite stream of identical strings and you take the first three)</p>\n<p>I'm curious, what is the future of the class <code>Stream</code>. Is it going to be deprecated and subsumed by this? Or is there a place for both?</p>\n<p>These are internal iterators, right? How do they compare performance wise to external iterators like <code>ForIn</code> for <code>Std.Range</code>? I understand that it is not optimized yet, so at least what is the expected performance difference? The last time I tried I had a really hard time getting the internal iterators fast.</p>",
        "id": 512935243,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1744934016
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/channel/270676-lean4/topic/Iterator.20Library.3A.20Request.20for.20Feedback/near/512935243\">said</a>:</p>\n<blockquote>\n<p>These are internal iterators, right? How do they compare performance wise to external iterators like <code>ForIn</code> for <code>Std.Range</code>? I understand that it is not optimized yet, so at least what is the expected performance difference? The last time I tried I had a really hard time getting the internal iterators fast.</p>\n</blockquote>\n<p>Which internal iterators have you tried in the past? As far as I understand the terminology, internal iterators manage the control flow themselves while external iterators allow the user to handle the control flow, so where would the performance penalties of internal iterators occur?</p>\n<p>Fundamentally these iterators are external iterators. The heart of each iterator is its <code>step</code> function so that users can control the control flow themselves if they want. On top of this, there is an API of consumers such as <code>toList</code>, <code>toArray</code>, <code>count</code> etc. that allow you to use the iterators as internal iterators, deferring the control flow to some library function.</p>\n<p>There should be no difference in doing the following things:</p>\n<ul>\n<li>computing the sum of elements of <code>l</code> in a structurally recursive loop</li>\n<li>computing the sum using <code>ForIn</code> to iterate over <code>l</code></li>\n<li>using <code>ForIn</code> to iterate over the iterator <code>l.iter</code></li>\n<li>using some special \"internal iterator\" API function, perhaps <code>fold</code> or even just <code>sum</code>.</li>\n</ul>\n<p>The performance of the iterator library depends primarily on aggressive inlining in order to enable simple optimizations, which is intended to finally produce code that is just a plain loop or tail-recursive function, so there should be no overhead to using iterators here (\"stream fusion\").</p>\n<p>The principle is the same with more complex combinators such as <code>take</code> or <code>flatMap</code>. The idea (aggressive inlining produces efficient code) is the same but the compiler needs to do more to obtain an efficient result, which it currently doesn't. (In the <code>flatMap</code> case, we would naturally write two nested loops. This is obviously impossible when the user manually iterates over the iterator in a single loop, so there might be some performance penalty to that, too.)</p>\n<p>However, I still have the slight feeling that we're using the term \"internal iterator\" in different ways... Please clarify if I missed your point. If you have a concrete example in mind, we can also take a look at that one if you want.</p>",
        "id": 512981206,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1744958374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/channel/270676-lean4/topic/Iterator.20Library.3A.20Request.20for.20Feedback/near/512935243\">said</a>:</p>\n<blockquote>\n<p>I'm curious, what is the future of the class <code>Stream</code>. Is it going to be deprecated and subsumed by this? Or is there a place for both?</p>\n</blockquote>\n<p>I think that the new iterators will be able to do everything the current <code>Stream</code> class can, so I do think they will subsume <code>Stream</code>.</p>",
        "id": 512981858,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1744958783
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/channel/270676-lean4/topic/Iterator.20Library.3A.20Request.20for.20Feedback/near/512935243\">said</a>:</p>\n<blockquote>\n<p>A bit confused by <code>Iter.unfold Id 0 (. + 1)</code> but from the comment I got the message that you want to start at zero and progress by adding one. [...] (Ohh I get it now, you create an infinite stream of identical strings and you take the first three)</p>\n</blockquote>\n<p>Yes, I agree this is very confusing, I should make the naming more clear and create convenience functions. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 512982327,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1744959050
    },
    {
        "content": "<p>Maybe <code>Iter.unfold Id 0 (. + 1)</code> could be abbreviated to <code>[0..]</code> like in Haskell <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>\n<p>Edit: technically, that's notation for an infinite <code>List Nat</code> in Haskell, but this can only be modelled using an iterator in Lean.</p>",
        "id": 512990448,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1744963302
    },
    {
        "content": "<p>My two cents: I found <code>Iter.unfold Id 0 (. + 1)</code> very hard to parse. The version with <code>repeatForever</code> was much nicer and almost immediately clear.</p>",
        "id": 512993973,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1744964930
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"221653\">Paul Reichert</span> <a href=\"#narrow/channel/270676-lean4/topic/Iterator.20Library.3A.20Request.20for.20Feedback/near/512915402\">said</a>:</p>\n<blockquote>\n<p>Thanks, Patrick! Do you find both examples hard to read? I'd also be curious about what you think about readability compared to other iterator libraries if you have used one of those before (Rust, Java, Python, ...) or what they might be doing better.</p>\n</blockquote>\n<p>The new version (with currently non-existing convenience functions) is infinitely easier to read for me. I mentioned macros because I expected that the absence of convenience function meant they were hard to write for some reason, and maybe macros could hep.</p>",
        "id": 513001810,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1744968641
    },
    {
        "content": "<p>Why do many of the initial functions take an explicit monad argument?</p>",
        "id": 513015691,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744975161
    },
    {
        "content": "<p>Is the idea to avoid the map/mapM duplication present elsewhere in Lean? I think for something very programmatic like iterators it would be fine to just <em>always</em> assume a monad context</p>",
        "id": 513016005,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744975335
    },
    {
        "content": "<p><code>Id.run</code> can always be used on the outside to use the API in a pure context</p>",
        "id": 513016051,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744975366
    },
    {
        "content": "<p>The explicit monad argument is a rough edge that I want to smoothen. Actually, it's an autoParam, but for some reason the elaborator takes issue with me not explicitly supplying it (see <a href=\"https://github.com/leanprover/lean4/issues/7960\">this bug</a>).</p>\n<p>I will try out what the elaborator thinks of having it as an implicit argument. Having <code>iter</code> and <code>iterM</code> is definitely something I consider, too.</p>",
        "id": 513022921,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1744978269
    },
    {
        "content": "<p>I think it should just be implicit, and you can probably have only the <code>iterM</code> version (and of course drop the <code>M</code> from the name)</p>",
        "id": 513023220,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744978418
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/270676-lean4/topic/Iterator.20Library.3A.20Request.20for.20Feedback/near/512990448\">said</a>:</p>\n<blockquote>\n<p>Maybe <code>Iter.unfold Id 0 (. + 1)</code> could be abbreviated to <code>[0..]</code> like in Haskell <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>\n<p>Edit: technically, that's notation for an infinite <code>List Nat</code> in Haskell, but this can only be modelled using an iterator in Lean.</p>\n</blockquote>\n<p>We also have <code>Std.Range</code> with some notation in Lean -- making that more polymorphic is another topic I'll take on in a few weeks. It certainly makes sense to integrate it well with the iterator library.</p>",
        "id": 513023350,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1744978467
    },
    {
        "content": "<p>Another issue is the direction in which to loop through an Array. I find it a bit annoying that there is only a ForIn instance for looping from the beginning of an array. The same would apply for the iterator of an Array. Maybe there should be Array.iterr and Array.iterl?</p>\n<p>edit: or maybe the names should be Array.iter and Array.iterRev. Then the same can be used for TreeMap.</p>",
        "id": 513024601,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1744979116
    },
    {
        "content": "<p>Yes, good idea! Speaking of going backwards, I'm still trying to figure out what it would mean for a monadic iterator to go back to a previous step. We certainly can't unwind the effects that have already been caused, but do we expect them to be executed a second time when we step forward again? Or is this up to the iterator?</p>\n<p>The background is that the already-existing <code>String</code> iterator needs a way of going a step back and I'd like to migrate that one to the new framework, too. The cheap version would be to introduce the concept of going back only for <code>Id</code> iterators until we have a good idea for monadic iterators.</p>",
        "id": 513071727,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1744998414
    },
    {
        "content": "<p>Yeah, unless there is a use case for iterators that can go backwards in a monadically interesting way, we can just stick to iterators with pure monadic actions. Are there more examples than String and Array that want to be able to go backwards? I guess any iterator can be forced to remember its results by using a List, and then you could go backwards in that.</p>\n<p>On the topic of monadic effects, my first reaction is that it would be nice for the default to be monad-free (i.e. using Id). Thus also requiring an <code>iterM</code> version.</p>",
        "id": 513086829,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745004729
    },
    {
        "content": "<p><code>for</code> notation only works in a monad, right?</p>",
        "id": 513088068,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1745005359
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"221653\">Paul Reichert</span> <a href=\"#narrow/stream/270676-lean4/topic/Iterator.20Library.3A.20Request.20for.20Feedback/near/513071727\">said</a>:</p>\n<blockquote>\n<p>Yes, good idea! Speaking of going backwards, I'm still trying to figure out what it would mean for a monadic iterator to go back to a previous step.</p>\n</blockquote>\n<p>I think Python handled this by allowing each iterator to specify what it means to be reversed; that could be a typeclass in Lean</p>",
        "id": 513088205,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1745005435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/270676-lean4/topic/Iterator.20Library.3A.20Request.20for.20Feedback/near/513088068\">said</a>:</p>\n<blockquote>\n<p><code>for</code> notation only works in a monad, right?</p>\n</blockquote>\n<p>Yes, I think so -- which message were you reacting to? I'm sorry, I think I'm missing the connection right now. :)</p>",
        "id": 513203824,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1745095453
    },
    {
        "content": "<p>I think Erik might be arguing about the question of whether the iterators should be monadic by default. And since <code>for</code> loops are always monadic, so should the iterators. But I don't quite agree with this, because I think there are many situations where Iterators can be used non-monadically even when working in a monad, because the iteration itself is a non-monadic action. In fact I'm not even convinced we need the monads at all in iterators.</p>",
        "id": 513207939,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745098894
    },
    {
        "content": "<p>Exciting stuff. I'm trying to try this out, but after cloning and opening the examples file to start playing around, I'm getting <code>dsimp made no progress</code> on lines 125 and 128 of <code>Iterator.Basic</code>. Revision is current <code>main</code> (<code>db951c65a5d6fd5d2322d269e8c27adbbd853a75</code>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">error</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">././././</span><span class=\"n\">Iterator</span><span class=\"bp\">/</span><span class=\"n\">Basic</span><span class=\"bp\">.</span><span class=\"n\">lean</span><span class=\"o\">:</span><span class=\"mi\">125</span><span class=\"o\">:</span><span class=\"mi\">6</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"n\">made</span><span class=\"w\"> </span><span class=\"n\">no</span><span class=\"w\"> </span><span class=\"n\">progress</span>\n<span class=\"n\">error</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">././././</span><span class=\"n\">Iterator</span><span class=\"bp\">/</span><span class=\"n\">Basic</span><span class=\"bp\">.</span><span class=\"n\">lean</span><span class=\"o\">:</span><span class=\"mi\">128</span><span class=\"o\">:</span><span class=\"mi\">6</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"n\">made</span><span class=\"w\"> </span><span class=\"n\">no</span><span class=\"w\"> </span><span class=\"n\">progress</span>\n</code></pre></div>",
        "id": 515457008,
        "sender_full_name": "James Sully",
        "timestamp": 1746081784
    },
    {
        "content": "<p>I should have linked to a stable version above. Currently, a fundamental refactoring is underway and <code>main</code> is still broken. I'll update the link in a second. (The refactoring doesn't affect the user-facing API a lot, so the older version should do for now)</p>",
        "id": 515460181,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1746083700
    },
    {
        "content": "<p>last working commit for me is <a href=\"https://github.com/datokrat/lean-iterators/commit/67d43c287c979144ff358def31bb5610c357a053\">67d43c28</a></p>",
        "id": 515460684,
        "sender_full_name": "James Sully",
        "timestamp": 1746083883
    },
    {
        "content": "<p>That one probably works, too. I guess it's time for me to create a branch with a more stable version</p>\n<p>Update: The <code>main</code> branch is the running snapshot now.</p>",
        "id": 515460933,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1746084042
    },
    {
        "content": "<p>My experience with the api is that I'm running into </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">typeclass</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">problem</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">stuck</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">often</span><span class=\"w\"> </span><span class=\"n\">due</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">metavariables</span>\n<span class=\"w\">  </span><span class=\"n\">ComputableSmall</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">48</span>\n</code></pre></div>\n<p>frequently, and I don't know how to resolve it. For example </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- this is fine</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">count</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Iter</span><span class=\"bp\">.</span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"c1\">-- error on the return annotation</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">count2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Iter</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Iter</span><span class=\"bp\">.</span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n</code></pre></div>",
        "id": 515464652,
        "sender_full_name": "James Sully",
        "timestamp": 1746086221
    },
    {
        "content": "<p>Not a solution yet, but here are a few explanations what is happening here. Please forgive the wall of text. I agree that things need to be more reliable when the library is released, so you don't need to think about these internals.</p>\n<ul>\n<li>The iterators have a similar design like in Rust. That means that the compiler will look at the type of an iterator and will, hopefully, generate very efficient code for it. Your iterator in fact has a more complicated type than it seems: <code>Iter Id Nat</code> has an implicit parameter, in your case the type <code>UnfoldIterator Nat.succ</code>. This type can be quite complicated, so I made it implicit. Internally, the iterator wraps an object of that type that encodes its current state. Because of universe complications, we need this state to be \"small\" enough to fit into the monad of the iterator.</li>\n<li>These error messages sometimes hide an other problem that led to Lean not inferring the type. The example you gave needs to work, however.</li>\n<li>In the meantime, I've moved away from <code>ComputableSmall</code>, but the new solution isn't ready yet. This will help with examples like yours. I'll keep you up-to-date when the new design is ready.</li>\n<li>Still, the iterators heavily rely on type inference and typeclass resolution, which is scary but important for efficiency.</li>\n</ul>\n<p>Anyways, thanks for testing! Don't hesitate to report other problems.</p>",
        "id": 515486720,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1746097854
    },
    {
        "content": "<p>Good to know, thanks! I'm looking forward to seeing how this evolves. I'm a big fan of both rust and streamly.</p>",
        "id": 515499859,
        "sender_full_name": "James Sully",
        "timestamp": 1746103946
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"621161\">James Sully</span> <a href=\"#narrow/channel/270676-lean4/topic/Iterator.20Library.3A.20Request.20for.20Feedback/near/515464652\">said</a>:</p>\n<blockquote>\n<p>My experience with the api is that I'm running into </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">typeclass</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">problem</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">stuck</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">often</span><span class=\"w\"> </span><span class=\"n\">due</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">metavariables</span>\n<span class=\"w\">  </span><span class=\"n\">ComputableSmall</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">48</span>\n</code></pre></div>\n<p>frequently, and I don't know how to resolve it. For example </p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- this is fine</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">count</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Iter</span><span class=\"bp\">.</span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"c1\">-- error on the return annotation</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">count2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Iter</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Iter</span><span class=\"bp\">.</span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I merged a new version of the library. While you won't hear from <code>ComputableSmall</code> anymore,  you still get a similar error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">don't</span><span class=\"w\"> </span><span class=\"n\">know</span><span class=\"w\"> </span><span class=\"n\">how</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">synthesize</span><span class=\"w\"> </span><span class=\"n\">implicit</span><span class=\"w\"> </span><span class=\"n\">argument</span><span class=\"w\"> </span><span class=\"sc\">'α'</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">Iter</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"mi\">19666</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"n\">context</span><span class=\"o\">:</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"mi\">19665</span>\n\n<span class=\"n\">When</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">resulting</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">declaration</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">explicitly</span><span class=\"w\"> </span><span class=\"n\">provided</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">holes</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e.g</span><span class=\"bp\">.</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">`_</span><span class=\"bp\">`</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">header</span><span class=\"w\"> </span><span class=\"n\">are</span><span class=\"w\"> </span><span class=\"n\">resolved</span><span class=\"w\"> </span><span class=\"n\">before</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">declaration</span><span class=\"w\"> </span><span class=\"n\">body</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">processed</span>\n</code></pre></div>\n<p>The issue here is that when you declare something and write down a return type, the return type needs to be explicitly specified, without holes that depend on the body. For iterators, I swear that you don't <em>want</em> to explicitly write down the implicit type argument (see explanation above). If you want to ensure that the return type is a <code>Nat</code>-valued iterator, how about this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">count</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Iter.unfold</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">Nat.succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Iter</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>You probably shouldn't have this problem on <code>let</code> expressions, it should be limited to top-level declarations as far as I understand.</p>",
        "id": 517783059,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1747129407
    },
    {
        "content": "<p>Pretty much the only thing I miss in Lean w.r.t. iterators is the easiness of parallelism that we get in Rust (thanks to <a href=\"https://docs.rs/rayon/latest/rayon/\">rayon</a>).</p>\n<p>In particular, here are some APIs I think would greatly improve the usability of Lean for real use cases that involve intensive computations:</p>\n<ul>\n<li><code>Array.parMap</code></li>\n<li><code>Array.parFlatMap</code></li>\n<li><code>Array.parReduce</code></li>\n<li><code>Array.parMapReduce</code></li>\n</ul>\n<p>I mention <code>Array</code> specifically because it supports <code>O(1)</code> data access.</p>",
        "id": 517789143,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1747131200
    },
    {
        "content": "<p>I agree that parallelism support would be very nice. I won't be able to support it in version 1, though -- it's still a long way to make the sequential iterators convenient for programming and verification.</p>",
        "id": 517791191,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1747131832
    },
    {
        "content": "<p>Is there a sense for why you include  a <code>skip</code> result? It seems to me that while it makes <code>filter</code> simpler, implementing <code>fold</code> or <code>map</code> are slightly more verbose because of it. The alternative I'm envisioning is methods like <code>filter</code> iterating internally until they produce a value/terminate, as is done in rust and others.</p>",
        "id": 527668405,
        "sender_full_name": "George Rennie",
        "timestamp": 1751975647
    },
    {
        "content": "<p>The stepper functions need to be non-recursive in order for the compiler to be able to see that it can fuse the entire pipeline into a single loop. The approach is very similar to the one presented in the Haskell stream fusion paper (<a href=\"https://dl.acm.org/doi/10.1145/1291220.1291199\">https://dl.acm.org/doi/10.1145/1291220.1291199</a>).</p>",
        "id": 527672310,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1751976767
    },
    {
        "content": "<p>Can we consider making <a href=\"https://github.com/leanprover/lean4/blob/db292b4c82888d0898826d5da9aea977e74672d6/src/Init/Data/Iterators/Internal/Termination.lean#L24\"><code>FinitenessRelation</code></a> a public API? I'm trying to implement <code>Iterator</code> for regex searches (with preliminary proofs!), but providing a <code>Finite</code> instance is pretty difficult without <code>FinitenessRelation</code>.</p>\n<p><a href=\"https://github.com/pandaman64/lean-regex/compare/iterator#diff-486d8e6d27cba5ca9e66cb51acb6f981a9e3368a978919b081ebca99c2a0b316R102\">https://github.com/pandaman64/lean-regex/compare/iterator#diff-486d8e6d27cba5ca9e66cb51acb6f981a9e3368a978919b081ebca99c2a0b316R102</a></p>",
        "id": 530560620,
        "sender_full_name": "pandaman",
        "timestamp": 1753362706
    },
    {
        "content": "<p>Also, I found that <code>Iter.isPlausibleIndirectOutput_of_mem_toArray</code> is missing (<a href=\"https://github.com/leanprover/lean4/blob/4cbfa485fa3976f7d2d7885a8be9f512cb00cdfa/src/Init/Data/Iterators/Lemmas/Consumers/Collect.lean#L116C14-L116C39\">relevant code</a>). Would you mind if I open a <code>lean4</code> PR?</p>",
        "id": 530561049,
        "sender_full_name": "pandaman",
        "timestamp": 1753362838
    },
    {
        "content": "<p>First of all: The API for the implementation of iterators -- in contrast to the stable usage API of the existing producers, combinators and consumers -- <a href=\"https://leanprover-community.github.io/mathlib4_docs/Std/Data/Iterators.html#Stability\">is experimental</a> because there will most certainly be some changes to the basic definition of iterators in the near future. For example, the iterators are currently a bit inflexible when it comes to universes: The internal state, the monad and the output type all need to be at the same universe level due to language limitations that can't be worked around without questionable <code>implemented_by</code> usage right now. When these things are sorted out, those parts of the library will be made stable.</p>\n<p>So, if you decide to implement your own iterator, keep in mind that things will change in the future in a breaking way. The breakage shouldn't be too hard to resolve, just some additional universe lifting/shrinking operations, but you will need to fix some errors. The safe way to create a custom iterator is to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Iterators.Iter.repeat#doc\">docs#Std.Iterators.Iter.repeat</a>, which creates an infinite stream from a transition function <code>α -&gt; α</code> and combine it with <code>takeWhile</code> and/or <code>filter</code> (although finiteness proofs still need to be done by hand in that setting). I'm generally open for adding more such general-purpose producers to <code>Std</code>.</p>\n<p>Now to <code>FinitenessRelation</code>. Thinking of it, I think that we could make <code>FinitenessRelation</code> stable, but let me think about this a bit...</p>\n<p><span class=\"user-mention silent\" data-user-id=\"395416\">pandaman</span> <a href=\"#narrow/channel/270676-lean4/topic/Iterator.20Library.3A.20Request.20for.20Feedback/near/530561049\">said</a>:</p>\n<blockquote>\n<p>Also, I found that <code>Iter.isPlausibleIndirectOutput_of_mem_toArray</code> is missing (<a href=\"https://github.com/leanprover/lean4/blob/4cbfa485fa3976f7d2d7885a8be9f512cb00cdfa/src/Init/Data/Iterators/Lemmas/Consumers/Collect.lean#L116C14-L116C39\">relevant code</a>). Would you mind if I open a <code>lean4</code> PR?</p>\n</blockquote>\n<p>That would be nice, thanks in advance!</p>",
        "id": 530567667,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1753364737
    },
    {
        "content": "<p>Thank you for the suggestions! Now compling lean4...</p>\n<blockquote>\n<p>The safe way to create a custom iterator is to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Iterators.Iter.repeat#doc\">docs#Std.Iterators.Iter.repeat</a>, which creates an infinite stream from a transition function <code>α -&gt; α</code></p>\n</blockquote>\n<p>My regex iterator is basically built on top of <a href=\"https://github.com/pandaman64/lean-regex/blob/a8c1407ebe168f97f58e1bde2a9a3c8a5ff44208/regex/Regex/Regex/Iterators/Captures.lean#L42\">a function of <code>α → IterStep α β</code></a>, as the iterator wants to emit <code>.skip</code> when there is no match in the rest of the haystack. A producer wrapping the function would be very nice.</p>",
        "id": 530571336,
        "sender_full_name": "pandaman",
        "timestamp": 1753365724
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>Also, I found that <code>Iter.isPlausibleIndirectOutput_of_mem_toArray</code> is missing (<a href=\"https://github.com/leanprover/lean4/blob/4cbfa485fa3976f7d2d7885a8be9f512cb00cdfa/src/Init/Data/Iterators/Lemmas/Consumers/Collect.lean#L116C14-L116C39\">relevant code</a>). Would you mind if I open a <code>lean4</code> PR?</p>\n</blockquote>\n<p>That would be nice, thanks in advance!</p>\n</blockquote>\n<p>Opened! <a href=\"https://github.com/leanprover/lean4/pull/9538\">https://github.com/leanprover/lean4/pull/9538</a></p>",
        "id": 530777578,
        "sender_full_name": "pandaman",
        "timestamp": 1753450931
    }
]