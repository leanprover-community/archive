[
    {
        "content": "<p>In Veil, we use named patterns to be able to destruct structures with fields that might conflict with global names like <code>none</code> (see <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Pattern.20match.20and.20name.20binder.20.60none.60/near/514568614\">this thread</a>). It seems these patterns are not definitionally equal to the actual values, which in our case leads to typeclass inference failing. Here's a MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"n\">x_dec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">this_works</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">x_dec</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">this_fails</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"bp\">@_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">x_dec</span><span class=\"bp\">@_⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"c1\">-- error: failed to synthesize Decidable x</span>\n</code></pre></div>\n<p>I think this might be the same as or closely related to <a href=\"https://github.com/leanprover/lean4/pull/501\">lean4#501</a>.</p>\n<p>Would this be easy to fix? If not, could anyone please suggest a workaround? <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 534948988,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1755522639
    },
    {
        "content": "<p>Leo appears to give a workaround in that issue: <a href=\"https://github.com/leanprover/lean4/issues/501#issuecomment-1015822830\">https://github.com/leanprover/lean4/issues/501#issuecomment-1015822830</a></p>\n<p>It doesn't preserve definitional equality, but it adds an equality hypothesis you can use.</p>",
        "id": 534949726,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755522868
    },
    {
        "content": "<p><del>this is not the same problem I think</del></p>",
        "id": 534949748,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755522873
    },
    {
        "content": "<p><del>you have an instance of <code>Decidable (namedPattern x a✝¹ h✝¹)</code> in the context</del></p>",
        "id": 534949839,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755522894
    },
    {
        "content": "<p><del>it's not reducibly defeq to <code>Decidable x</code></del></p>",
        "id": 534949891,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755522905
    },
    {
        "content": "<p>oh that's not how that works, whoops</p>",
        "id": 534949972,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755522932
    },
    {
        "content": "<p>I'm not sure I fully understand using named patterns. Do you <em>need</em> the variable names to be exactly the same as the field names? I know I gave the workaround in the other thread, but I was assuming this was a hard constraint.</p>\n<p>Adding some sort of prefix or suffix seems easier to deal with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">this_works</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">v_x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v_x_dec</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"n\">v_x</span>\n</code></pre></div>",
        "id": 534951062,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755523247
    },
    {
        "content": "<blockquote>\n<p>Do you <em>need</em> the variable names to be exactly the same as the field names?</p>\n</blockquote>\n<p>Unfortunately, yes. It is a hard constraint. The use-case is we're building a DSL that extends do-notation to \"hide\" the <code>State</code> monad. Here's how it works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Veil</span>\n<span class=\"n\">veil</span><span class=\"w\"> </span><span class=\"n\">module</span><span class=\"w\"> </span><span class=\"n\">Demo</span>\n\n<span class=\"n\">individual</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"bp\">#</span><span class=\"n\">gen_state</span><span class=\"w\"> </span><span class=\"c1\">-- creates a `structure` with a field called `none`</span>\n\n<span class=\"n\">action</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"c1\">-- creates binders for all fields, and `modifyGet`s after every `:=`</span>\n<span class=\"w\">  </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">do</span>\n<span class=\"cm\">  let __do_lift ← get</span>\n<span class=\"cm\">  match __do_lift with</span>\n<span class=\"cm\">    | { none := none@h:a } =&gt; do</span>\n<span class=\"cm\">        let r ← modifyGet fun st =&gt; (True, { none := True })</span>\n<span class=\"cm\">        let none : Prop := r</span>\n<span class=\"cm\">        pure PUnit.unit</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Demo</span>\n</code></pre></div>\n<p>Not having the variable names exactly match the field names makes this very ugly / unusable from an UX perspective.</p>",
        "id": 534952925,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1755523813
    },
    {
        "content": "<blockquote>\n<p>It doesn't preserve definitional equality, but it adds an equality hypothesis you can use.</p>\n</blockquote>\n<p>I'm not sure how to use Leo's workaround to enable typeclass inference in our case.</p>",
        "id": 534954700,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1755524412
    },
    {
        "content": "<p>An approach taken by <code>do</code> notation itself and syntax <code>match</code> is to create \"implementation detail\" local variables.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">this_works</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨__</span><span class=\"n\">f1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">__</span><span class=\"n\">f2</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">__</span><span class=\"n\">f1</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x_dec</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">__</span><span class=\"n\">f2</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  f : Foo</span>\n<span class=\"cm\">  x : Prop := __f1</span>\n<span class=\"cm\">  x_dec : Decidable __f1 := __f2</span>\n<span class=\"cm\">  ⊢ Bool</span>\n<span class=\"cm\">  -/</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>If you know anything about the types while expanding you can make the ugly <code>Decidable __f1</code> be <code>Decidable x</code>.</p>\n<p>With an easy-to-write elaborator, you could rename these variables instead.</p>",
        "id": 534955024,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755524522
    },
    {
        "content": "<p>Or instead of pattern matching, if you know you're working with structures, you could instead make a bunch of <code>let</code> declarations, one per field, instead of using a pattern match:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">this_works</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x_dec</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">x_dec</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  f : Foo</span>\n<span class=\"cm\">  x : Prop := ⋯</span>\n<span class=\"cm\">  ⊢ Bool</span>\n<span class=\"cm\">  -/</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>That has the benefit of preserving defeqs too. The variables know they're projections of <code>f</code>.</p>",
        "id": 534955275,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755524616
    },
    {
        "content": "<p>That makes a lot of sense. Thank you so much, <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>!</p>",
        "id": 534955851,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1755524805
    }
]