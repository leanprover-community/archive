[
    {
        "content": "<p>I need a nested-quotient-inductive type, but Lean does not currently support them.  In the long term, I'd like to build a library to implement them (until they are supported in the kernel, which AFAIK is something currently discussed), but for now I'd like to build one \"by hand\", to understand how to make that work exactly. For that, I have built a type, I have proven a dependent induction principle for it, and I have proven that it computes (up to propositional equality).  Importantly, it does not compute definitionally (this may be relevant), or, at least, not all cases do compute definitionally (some do). It works with tactics like <code>induction</code> and <code>cases</code>, but only by explicitly specifying the recursor to use.  Pattern matching does not work, and neither does the convenient syntax of <code>rcases</code>. I'd like to know how much I can \"convince\" the elaborator that this type is inductive, that is, by poking enough in Lean's internals, to register it as an inductive data type so that it works \"natively\" as an inductive type.  I know that the current code is probably not able to derive some of the lemmas, functions, types and instances for it (like the <code>SizeOf</code> instance), so would it be enough for me to just implement them all by hand?  If so, I'd like to have an exhaustive list of stuff I have to implement by hand (like <code>below</code>, <code>recOn</code>, <code>casesOn</code>, <code>noConfusion</code>, ...) because I'm not sure where to find the documentation for this.  If not, what do I need to do? Is there some data structure used by the elaborator where metadata about inductive types is registered? </p>\n<p>Also, broadly speaking, I'm not sure where to find documentation for this kind of stuff.  I have already written a library that offered \"custom\" inductive types, but it was kind of a pain to implement, I had to read part of the elaboration pipeline, and to figure out stuff from the code.  If there is a better way to learn the exposed API, or how things are implemented, I'd be glad to hear about it.</p>\n<p>Thanks in advance</p>",
        "id": 568759504,
        "sender_full_name": "jthulhu",
        "timestamp": 1768816117
    },
    {
        "content": "<p>You can mark the dependent induction principle as <code>@[induction_eliminator, cases_eliminator]</code> and it will be the default eliminator for <code>induction</code> and <code>cases</code>. afaik there's no simple way to just \"register\" it as an inductive type and therefore you can't get it to work with <code>rcases</code> or <code>match</code>.</p>",
        "id": 568816811,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768833403
    },
    {
        "content": "<p>About implementing by hand, I did a hack where I have separate inductive I match on, and actual structure is defined as <code>def</code>. But this was because the native definition would not terminate, so not sure if it applies to your case.<br>\n<a class=\"message-link\" href=\"/#narrow/channel/113489-new-members/topic/Stuck.20on.20ManyT.20in.20.22Functional.20Programming.20in.20Lean.22/near/561484446\">#new members &gt; Stuck on ManyT in \"Functional Programming in Lean\" @ ðŸ’¬</a> </p>\n<p>If you post <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> maybe someone could try to help.</p>",
        "id": 568846510,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768842164
    },
    {
        "content": "<p>After having discussed with <span class=\"user-mention\" data-user-id=\"432410\">@Arthur Adjedj</span> about how inductive types are looked up, it seems that there is no decent low-cost solution, the reason being that the elaborator apparently asks the kernel whether a given constant is an inductive type or not, so the only \"simple\" solution would be to hook into that and lie to the elaborator about the nature of the type, but it's a shaky solution.</p>",
        "id": 568849504,
        "sender_full_name": "jthulhu",
        "timestamp": 1768843259
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/270676-lean4/topic/How.20to.20convince.20Lean.20a.20type.20is.20inductive.3F/near/568846510\">said</a>:</p>\n<blockquote>\n<p>If you post <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> maybe someone could try to help.</p>\n</blockquote>\n<p>Sure, a minimal request would be: make the following code work.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- you can assume anything reasonable about this type</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"bp\">.</span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î©</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"bp\">.</span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î©</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î©</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î©</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"bp\">.</span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î©</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î©</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">â†’</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"bp\">.</span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">â†’</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">â†’</span>\n<span class=\"w\">  </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">o</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">rec_true</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"bp\">.</span><span class=\"n\">true</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">...</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î©</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"o\">)</span><span class=\"w\">   </span><span class=\"c1\">-- or whatever that is compatible with the recursor</span>\n</code></pre></div>",
        "id": 568851297,
        "sender_full_name": "jthulhu",
        "timestamp": 1768843873
    },
    {
        "content": "<p>One solution would be to have implement version of <code>Finset</code> that works with recursive inductive. You could e.g. use sorted list (i.e. List, and a proof that it is sorted). You can prove that it is equivalent to <code>Finset</code> for easier proofs. See <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/extensional.20finite.20map.20inside.20inductive.20definition/with/565318367\">#Is there code for X? &gt; extensional finite map inside inductive definition</a>  about similar problem. Another solution is to extract the quotient outside, i.e. you would define inductive <code>Î©</code> with List, and then define Setoid on <code>Î©</code> that divides this List by permutations (that's how <code>Finset</code> is implemented). But this approach is tedious and I wouldn't recommend it. For example of this, see the mentioned topic.</p>",
        "id": 568853324,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768844693
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133339\">@Mirek OlÅ¡Ã¡k</span> Sorry for pinging you. You recently gave a great explanation here: <a class=\"message-link\" href=\"/#narrow/channel/113489-new-members/topic/Idiomatically.20working.20with.20mutual.20inductive.20types/near/568658725\">#new members &gt; Idiomatically working with mutual inductive types @ ðŸ’¬</a>, so you might also be able to explain things here.<br>\nGiven your set-counting argument I'm wondering why Quot/Quotient doesn't work with recursive inductive types. Quot is always not-greater than its underlying type, and the underlying type of <code>Finset</code> is <code>List</code>, so in theory, it should be possible? Is this also the case that no one worked on extending Lean to work with Quot, or is there some inherent problem with e.g. the fact that Quot is axiomatized?</p>",
        "id": 568860081,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768847267
    },
    {
        "content": "<p>Similarly as with that other case, the issue is not that using Quot would be mathematically invalid but that using Quot is complicated. It is not that you are allowed to repeat your type anywhere with a few exceptions, rather that there is a limited set of positions where your type can recursively occur.</p>\n<p>If we ignore mutual inductives and nested inductives (like <code>List Foo</code>), the rule is: you can only put your inductive <code>Foo</code> as the output type of an argument of a constructor. To be honest, I don't know exactly the details for mutual &amp; nested inductives. However, <code>Quot</code> is super-tricky because you have to provide a relation <code>Foo -&gt; Foo -&gt; Prop</code>, so suddenly the type will occur at least as an argument type of a function before it was declared.</p>\n<p>If you want to quotient inside an inductive type, you should first build an unquotiented type, and then build another type that does the quotient. As an example, look how <code>ZFSet</code> is the quotient of <code>PSet</code>.</p>",
        "id": 568864705,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1768849025
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/270676-lean4/topic/How.20to.20convince.20Lean.20a.20type.20is.20inductive.3F/near/568853324\">said</a>:</p>\n<blockquote>\n<p>One solution would be to have implement version of <code>Finset</code> that works with recursive inductive. You could e.g. use sorted list (i.e. List, and a proof that it is sorted). You can prove that it is equivalent to <code>Finset</code> for easier proofs</p>\n</blockquote>\n<p>That would require inductive-inductive or recursive-inductives, and AFAIK Lean does not support them.  Ie</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Sorted</span><span class=\"w\"> </span><span class=\"n\">Le</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Nodup</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î©</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Le</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">   </span><span class=\"bp\">...</span>\n<span class=\"c1\">-- or</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Le</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>both fail.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/270676-lean4/topic/How.20to.20convince.20Lean.20a.20type.20is.20inductive.3F/near/568853324\">said</a>:</p>\n<blockquote>\n<p>See <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/extensional.20finite.20map.20inside.20inductive.20definition/with/565318367\">#Is there code for X? &gt; extensional finite map inside inductive definition</a>  about similar problem. Another solution is to extract the quotient outside, i.e. you would define inductive <code>Î©</code> with List, and then define Setoid on <code>Î©</code> that divides this List by permutations (that's how <code>Finset</code> is implemented). But this approach is tedious and I wouldn't recommend it. For example of this, see the mentioned topic.</p>\n</blockquote>\n<p>This is precisely what I have done, and indeed, this is extremely tedious.  This is why I get an inductive-like type (ie. constructors + a recursor) but which is not an inductive type.</p>",
        "id": 569034024,
        "sender_full_name": "jthulhu",
        "timestamp": 1768917826
    },
    {
        "content": "<p>You can do that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">PreÎ©</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î©</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"bp\">.</span><span class=\"n\">WF</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Pairwise</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Â·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">Â·</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>And then either use <code>PreÎ©</code> and <code>PreÎ©.WF</code> unbundled, or bundled as <code>def Î© := { x : PreÎ© // x.WF }</code>. In this case I think the latter will be better.</p>",
        "id": 569161946,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768963287
    },
    {
        "content": "<p>From the computational perspective quotient approach doesn't require you to sort the list. But I think that working with sorted lists is easier than working with quotient of list by permutations. At least it was for me in a different setting.</p>",
        "id": 569162489,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768963702
    },
    {
        "content": "<p>this only works when your type is orderable :(</p>",
        "id": 569162698,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768963904
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 569163110,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768964250
    },
    {
        "content": "<p>You could also not have <code>s.Pairwise (Â· &lt; Â·)</code> at all, if you don't care about equality being extensional.</p>",
        "id": 569163239,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768964361
    },
    {
        "content": "<p>then I can't prove extensionality :(</p>",
        "id": 569165712,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768966450
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/270676-lean4/topic/How.20to.20convince.20Lean.20a.20type.20is.20inductive.3F/near/569161946\">said</a>:</p>\n<blockquote>\n<p>You can do that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">PreÎ©</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î©</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"bp\">.</span><span class=\"n\">WF</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î©</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Pairwise</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Â·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">Â·</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>And then either use <code>PreÎ©</code> and <code>PreÎ©.WF</code> unbundled, or bundled as <code>def Î© := { x : PreÎ© // x.WF }</code>. In this case I think the latter will be better.</p>\n</blockquote>\n<p>Oh!  This is a solution I didn't think of.  Indeed, I think it is better than using quotients, and in my case, PreÎ© is not a large inductive so it can be ordered.</p>",
        "id": 569860415,
        "sender_full_name": "jthulhu",
        "timestamp": 1769256011
    }
]