[
    {
        "content": "<p>I'm wondering how one does conditional compilation in lake for different platforms? In particular, if one wants something like rust's <a href=\"https://github.com/rust-windowing/winit\">winit</a> to setup platform specific APIs for opening a window ?</p>",
        "id": 479371079,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1730155013
    },
    {
        "content": "<p>I think the current strategy for this is to write some custom logic in a <code>lakefile.lean</code> making use of <code>System.Platform</code> primitives. LeanCopilot's <a href=\"https://github.com/lean-dojo/LeanCopilot/blob/main/lakefile.lean\"><code>lakefile.lean</code></a> is a popular example of this (though prehaps not the most concise or modern example).</p>\n<p>One of my focus areas for this quarter is FFI papercuts, so I am hoping to improve the experience around here. I would be interest in any ideas or concerns you might have.</p>",
        "id": 479586167,
        "sender_full_name": "Mac Malone",
        "timestamp": 1730247551
    },
    {
        "content": "<p>I've been looking at writing low-level libraries for graphics programming, so the bottom of stack involves:</p>\n<ul>\n<li>platform dependent code for creating windows, ala <a href=\"https://github.com/rust-windowing/winit\">winit</a>, where it would be really nice to have rust-like platform-ifdefs and includes for the builds as well as individual definitions.</li>\n<li>openGL binders ala <a href=\"https://www.khronos.org/opengl/wiki/OpenGL_Loading_Library#GLEW_(OpenGL_Extension_Wrangler)\">glew</a>, where it would be nice if Lean learnt how to open shared objects / DLLs. I would imagine that having support for something like <code>pkg-config</code> on Linux is far too out of scope, though. I'm not sure how Rust libraries do this to be honest.</li>\n</ul>",
        "id": 479586672,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1730247890
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130575\">@Siddharth Bhat</span> To your two points:</p>\n<ul>\n<li>ifdefs can generally be implemented in Lean via some mixture of metaprogramming, plain conditionals, ifdefs in FFI shims, and opaque definitions.</li>\n<li>There is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.loadDynlib#doc\">docs#Lean.loadDynlib</a>, but there is no way to execute a foreign symbol without a compiled <code>@[extern]</code> decalaration.</li>\n</ul>",
        "id": 479707601,
        "sender_full_name": "Mac Malone",
        "timestamp": 1730301864
    },
    {
        "content": "<blockquote>\n<ul>\n<li>ifdefs can generally be implemented in Lean via some mixture of metaprogramming, plain conditionals, ifdefs in FFI shims, and opaque definitions.</li>\n</ul>\n</blockquote>\n<p>Thanks for the thoughts, and I agree. </p>\n<p>I do wonder if having a lower-barrier attribute like <code>@[platform(\"windows\")]</code> (and also possibly <code>@[triple(\"x86-64-unknown-linux\")</code>) would be benificial, to expose the metaprogramming necessary behind a stable API interface. Essentially, some form for <a href=\"https://doc.rust-lang.org/reference/conditional-compilation.html\">conditional compilation</a> that is negotiated between Lake and Lean.</p>",
        "id": 479711923,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1730302980
    }
]