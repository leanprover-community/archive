[
    {
        "content": "<p>The Lean 4 compiler (say,  03-20-2023 nightly) very promptly fails with stack overflow on large structures at compile time, say:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">largeThing</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"bp\">...</span><span class=\"o\">,</span> <span class=\"mi\">50000</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I understand it's possible to use <code>ulimit -s unlimited</code> and try this way (with <code>set_option maxHeartbeats &lt;big number&gt;</code>), but this is insufficient for my use case. I have furthermore found that a common workaround is to load this data at runtime, which works just fine normally, except I need to reason about these big structures, so I need the information available 'at compile time', so to speak.</p>\n<p>I have also tried some desperado attempts, none of which have worked for various stack-overflowy and other reasons, <br>\ne.g.  I would turn <code>#[1, 2, 3, ..., k]</code> into <code>def foo (n : Nat) : Option Nat := if n == 0 then .some 1 else ... else .none</code>, or I'd try  this with <code>match</code> as well, etc. To no good effect.</p>\n<p>Anyone can give me some pointers?</p>",
        "id": 344230453,
        "sender_full_name": "Franti코ek Silv치코i 游불",
        "timestamp": 1679656417
    },
    {
        "content": "<p>Is this data your are reasoning about real data which is random and messy, or data which is easily described like the range list you gave above.  If the former, how do you expect to \"reason\" about it?  If the later, I think there should be a way around this.  For example one could describe a theorem about the list <code>largeThing</code> as a list which is range list from 1 to 50000.  You could even prove there is only one such list without computing it.  I'm sure you could also work with other data structures like streams (which are lazy lists that don't compute the full list).</p>",
        "id": 344251123,
        "sender_full_name": "Jason Rute",
        "timestamp": 1679661514
    },
    {
        "content": "<p>I guess another option which would work on data loaded at run time is to have two things:  You could describe your data by a type which says that this data is of some form, e.g. the type <code>Vector 50000</code> which especially says it is a list of 50000 elements (see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Vector#doc\">docs4#Vector</a>).  Then at run time you load your data as a <code>List</code>.  The trick is that you need to convert it to a <code>Vector 50000</code>.  But you can write a function <code>import foo (rawList: List) : Option (Vector 50000)</code> which returns <code>some v</code> where <code>v : Vector 50000</code> if the list is of the right size.   Of course, you can replace <code>Vector </code>with your own custom type asserting whatever properties you need about your data.  As long as they are decidable properties that can be checked at run time, then you know this approach will work.</p>",
        "id": 344255138,
        "sender_full_name": "Jason Rute",
        "timestamp": 1679662367
    },
    {
        "content": "<p>Also, even for the case were your data is well structured, you can also load it at runtime.  For example, you can write a function <code>foo (length: Nat)</code> which returns the list <code>#[1, ..., length]</code>without ever computing it out at compile time.  You can prove that <code>(foo 50000).length = 50000</code> and all sort of other properties you need.</p>",
        "id": 344256263,
        "sender_full_name": "Jason Rute",
        "timestamp": 1679662636
    },
    {
        "content": "<p>The data in question is a huge set of polynomial constraints that can not be expressed any better than enumerating them. I want to reason about when these (and/or their subsets) are satisfied. I'll need to think about your answer, thank you kindly!</p>\n<p>In some sense, one could view this data as a big sequence of instructions forming a program, about whose semantics I want to reason.</p>",
        "id": 344260511,
        "sender_full_name": "Franti코ek Silv치코i 游불",
        "timestamp": 1679663596
    },
    {
        "content": "<p>Note that large lists/arrays are a particularly bad case for the compiler. You can still represent large data as long as you break it up into smaller chunks and sub-definitions</p>",
        "id": 344262772,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679664090
    },
    {
        "content": "<p>Even just using a macro to generate the expression under the hood can help, because the <code>#[x1, .., xn]</code> macro creates a lot of extra temporaries when n is large (&gt; 32 or so)</p>",
        "id": 344263227,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679664181
    },
    {
        "content": "<p>I will give all these approach a try; if something succeeds, I'll make sure to report on this; thanks everyone.</p>",
        "id": 344263859,
        "sender_full_name": "Franti코ek Silv치코i 游불",
        "timestamp": 1679664337
    },
    {
        "content": "<p>is this also potentially an application of native_decide?</p>",
        "id": 344553011,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1679777317
    }
]