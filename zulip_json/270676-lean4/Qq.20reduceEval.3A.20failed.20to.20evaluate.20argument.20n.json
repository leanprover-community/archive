[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mkLiteralQ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">enlit</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkRawNatLit</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">enlit</span><span class=\"o\">)</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"check_nat%\"</span><span class=\"w\"> </span><span class=\"n\">nStx</span><span class=\"o\">:</span><span class=\"n\">num</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">nStx</span><span class=\"bp\">.</span><span class=\"n\">getNat</span><span class=\"bp\">.</span><span class=\"n\">mkLiteralQ</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">check_nat</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">check_nat</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"mi\">37</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">check_nat</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">37</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"sd\">/-- Given `en : Q(Nat)`, return optionally a natural number `n` and a witness that `en` is defeq</span>\n<span class=\"sd\">to `OfNat.ofNat (natlit $n)`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">natQ?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">mkLiteralQ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">en</span><span class=\"bp\">.</span><span class=\"n\">nat?</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨⟩⟩</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">rawOnError</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"sd\">/-- Interpret a given `e : Expr` as a vector `v : Fin n → Nat`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferTypeQ</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"Invalid input: cannot decompose into Fin n → Nat\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">natQ?</span><span class=\"w\"> </span><span class=\"n\">en</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"The length of the vector is not determined\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">en'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">mkLiteralQ</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">en'</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 533823664,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754928008
    },
    {
        "content": "<p>I find it slightly difficult to work with Qq, because sometimes the expected type window just stops loading, and I get strange error messages</p>",
        "id": 533823769,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754928035
    },
    {
        "content": "<p>e.g. in the code above, on Line 23 the expected type window just fails with error \"Error updating: Error fetching goals: Rpc error: InternalError: failed. Try again.\"</p>\n<p>on Line 33 I see the same error, and then Line 34 just stops compiling. What did I do wrong?</p>",
        "id": 533824038,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754928110
    },
    {
        "content": "<p>Qq is very picky about what you <code>let</code> and what you <code>have</code></p>",
        "id": 533824089,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754928121
    },
    {
        "content": "<p>Only <code>let</code> something Qq if Qq can recognize the contents</p>",
        "id": 533824175,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754928148
    },
    {
        "content": "<p>changing those lets to haves or vice versa doesn't solve anything</p>",
        "id": 533824218,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754928162
    },
    {
        "content": "<p>oh btw <code>#check natQ?</code> on L24 is also error</p>",
        "id": 533824315,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754928199
    },
    {
        "content": "<p>How should I fix this?</p>",
        "id": 533824352,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754928218
    },
    {
        "content": "<p>The problem is the type of <code>natQ?</code></p>",
        "id": 533824573,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754928302
    },
    {
        "content": "<p>Qq can't recognize <code>Nat.mkLiteralQ</code></p>",
        "id": 533824675,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754928343
    },
    {
        "content": "<p>or maybe it can't do the <code>n</code> in the subtype formula, based on the error message</p>",
        "id": 533825898,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754928749
    },
    {
        "content": "<p>you will have better luck doing</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">natQ?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">mkLiteralQ</span>\n<span class=\"w\">      </span><span class=\"bp\">$</span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 533825929,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754928759
    },
    {
        "content": "<p>yeah but then i can't use it afterwards anyway</p>",
        "id": 533826286,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754928883
    },
    {
        "content": "<p>like it seems like <code>q($n)</code> is just bad</p>",
        "id": 533826296,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754928889
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mkLiteralQ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">enlit</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkRawNatLit</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">enlit</span><span class=\"o\">)</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"check_nat%\"</span><span class=\"w\"> </span><span class=\"n\">nStx</span><span class=\"o\">:</span><span class=\"n\">num</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">nStx</span><span class=\"bp\">.</span><span class=\"n\">getNat</span><span class=\"bp\">.</span><span class=\"n\">mkLiteralQ</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">check_nat</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">check_nat</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"mi\">37</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">check_nat</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">37</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"sd\">/-- Given `en : Q(Nat)`, return optionally a natural number `n` and a witness that `en` is defeq</span>\n<span class=\"sd\">to `OfNat.ofNat (natlit $n)`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">natQ?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">en'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">mkLiteralQ</span>\n<span class=\"w\">    </span><span class=\"bp\">$</span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">en'</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">en</span><span class=\"bp\">.</span><span class=\"n\">nat?</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨⟩⟩</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">rawOnError</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"sd\">/-- Interpret a given `e : Expr` as a vector `v : Fin n → Nat`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferTypeQ</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"Invalid input: cannot decompose into Fin n → Nat\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">natQ?</span><span class=\"w\"> </span><span class=\"n\">en</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"The length of the vector is not determined\"</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">en'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">mkLiteralQ</span>\n<span class=\"w\">  </span><span class=\"c1\">-- have v' : Q(Fin $en' → Nat) := q($v)</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 533827056,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754929168
    },
    {
        "content": "<p>This still errors</p>",
        "id": 533827067,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754929170
    },
    {
        "content": "<p>is there a better way to use Nat in Qq?</p>",
        "id": 533827774,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754929447
    },
    {
        "content": "<p>just do <code>$n</code> maybe</p>",
        "id": 533827853,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754929476
    },
    {
        "content": "<p>Don't know if that will work though</p>",
        "id": 533827870,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754929484
    },
    {
        "content": "<p><code>$n</code> also causes errors</p>",
        "id": 533827922,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754929503
    },
    {
        "content": "<p>sometimes</p>",
        "id": 533827949,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754929510
    },
    {
        "content": "<p>it's very unpredictable (for a noob like me)</p>",
        "id": 533827965,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754929517
    },
    {
        "content": "<p>it's unpredictable for me too</p>",
        "id": 533828182,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754929594
    },
    {
        "content": "<p>mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"sd\">/-- Interpret a given `e : Expr` as a vector `v : Fin n → Nat`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferTypeQ</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"Invalid input: cannot decompose into Fin n → Nat\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">en</span><span class=\"bp\">.</span><span class=\"n\">nat?</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"The length of the vector is not determined\"</span>\n<span class=\"w\">  </span><span class=\"c1\">-- have : $en =Q $n := ⟨⟩</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 533828502,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754929697
    },
    {
        "content": "<p>Note that the code errors at <code>$v</code> (L12), and if you look at the context you'll see that it's missing the line L11 commented out above, and if you remove the comment then you get another error</p>",
        "id": 533828581,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754929734
    },
    {
        "content": "<p>the longer code is when i tried to provide API for <code>nat?</code></p>",
        "id": 533828872,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754929833
    },
    {
        "content": "<p>working with Qq and Nat literals can be tricky... or avoiding <code>q($n)</code> where possible could help.</p>\n<p>Also, you might find related tricks in LeanFinder (<a href=\"http://www.leanfinder.org/\">www.leanfinder.org</a>).</p>",
        "id": 533829442,
        "sender_full_name": "Wuyang",
        "timestamp": 1754930059
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"946339\">@leanfinder</span> How to correctly quote and unquote Nat values in Lean 4 Qq without type errors when using mkLiteralQ, nat?, and subtype witnesses inside macros or MetaM functions</p>",
        "id": 533829477,
        "sender_full_name": "Wuyang",
        "timestamp": 1754930074
    },
    {
        "content": "<p>Here’s what I found:</p>\n<ul>\n<li>\n<p>[definition Mathlib.Meta.NormNum.mkOfNat(α : Q(Type u)) (_sα : Q(AddMonoidWithOne $α)) (lit : Q(ℕ)) :<br>\n    MetaM ((a' : Q($α)) × Q($lit = $a')) := do<br>\n  if α.isConstOf <code>Nat then\n    let a' : Q(ℕ) := q(OfNat.ofNat $lit : ℕ)\n    pure ⟨a', (q(Eq.refl $a') : Expr)⟩\n  else if α.isConstOf </code>Int then<br>\n    let a' : Q(ℤ) := q(OfNat.ofNat $lit : ℤ)<br>\n    pure ⟨a', (q(Eq.refl $a') : Expr)⟩<br>\n  else if α.isConstOf <code>`Rat then\n    let a' : Q(ℚ) := q(OfNat.ofNat $lit : ℚ)\n    pure ⟨a', (q(Eq.refl $a') : Expr)⟩\n  else\n    let some n := lit.rawNatLit? | failure\n    match n with\n    | 0 =&gt; pure ⟨q(0 : $α), (q(Nat.cast_zero (R := $α)) : Expr)⟩\n    | 1 =&gt; pure ⟨q(1 : $α), (q(Nat.cast_one (R := $α)) : Expr)⟩\n    | k+2 =&gt;\n      let k : Q(ℕ) := mkRawNatLit k\n      let _x : Q(Nat.AtLeastTwo $lit) :=\n        (q(instNatAtLeastTwo (n := $k)) : Expr)\n      let a' : Q($α) := q(OfNat.ofNat $lit)\n      pure ⟨a', (q(Eq.refl $a') : Expr)⟩](https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Meta.NormNum.mkOfNat#doc) \"Given a type $$\\alpha$$ with an </code>AddMonoidWithOne<code> instance and a natural number literal </code>lit<code>, this function constructs an expression </code>a'<code> of type $$\\alpha$$ representing the canonical interpretation of </code>lit<code> in $$\\alpha$$, along with a proof that </code>lit<code> equals </code>a'<code>. The function handles special cases for $$\\alpha$$ being </code>Nat<code>, </code>Int<code>, or </code>Rat<code> directly for efficiency, and falls back to general </code>Nat.cast` for other types.\"  (score: 0.700)</p>\n</li>\n<li>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Tactic.AtomM.addAtomQ#doc\">definition Mathlib.Tactic.AtomM.addAtomQ{u : Level} {α : Q(Type u)} (e : Q($α)) :\n    AtomM (Nat × {e' : Q($α) // $e =Q $e'}) := do\n  let (n, e') ← AtomM.addAtom e\n  return (n, ⟨e', ⟨⟩⟩)</a> \"Given an atomic expression <code>e</code> of type <code>α</code>, this function checks if <code>e</code> has been previously encountered (up to definitional equality at the specified transparency level). If it has, it returns the index of the stored version and the stored expression (which is definitionally equal to <code>e</code>). If not, it stores <code>e</code> in the list of atoms and returns its new index along with <code>e</code> itself. The returned expression should be considered the normal form in a normalizing tactic.</p>\n</li>\n</ul>\n<p>This is a strongly-typed version using <code>Qq</code> (quoted expressions) that ensures type safety by maintaining a proof that the returned expression <code>e'</code> is definitionally equal to the input <code>e</code>.\"  (score: 0.695)</p>\n<ul>\n<li>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Meta.NormNum.mkRawIntLit#doc\">definition Mathlib.Meta.NormNum.mkRawIntLit (n : ℤ) : Q(ℤ) :=\n  let lit : Q(ℕ) := mkRawNatLit n.natAbs\n  if 0 ≤ n then q(.ofNat $lit) else q(.negOfNat $lit)</a> \"Given an integer <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, this function constructs a typed expression representing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> in Lean's meta-programming environment, using a raw literal representation (<code>.lit (.natVal n)</code>) rather than the standard <code>OfNat.ofNat</code> form. The function handles both non-negative integers (using <code>ofNat</code>) and negative integers (using <code>negOfNat</code>).\"  (score: 0.686)</p>\n</li>\n<li>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Notation3.natLitMatcher#doc\">definition Mathlib.Notation3.natLitMatcher (n : Nat) : Matcher := fun s =&gt; do\n  guard &lt;| (← getExpr).rawNatLit? == n\n  return s</a> \"The function <code>natLitMatcher</code> creates a matcher for raw natural number literals in the <code>notation3</code> system. Given a natural number <code>n</code>, it checks whether the current expression in the match state is a raw natural number literal equal to <code>n</code>, and if so, returns the unchanged match state.\"  (score: 0.684)</p>\n</li>\n<li>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Meta.NormNum.mkRawRatLit#doc\">definition Mathlib.Meta.NormNum.mkRawRatLit (q : ℚ) : Q(ℚ) :=\n  let nlit : Q(ℤ) := mkRawIntLit q.num\n  let dlit : Q(ℕ) := mkRawNatLit q.den\n  q(mkRat $nlit $dlit)</a> \"Given a rational number \\( q \\), this function constructs a typed expression representing \\( q \\) in Lean's meta-programming environment, using raw literal representations for both the numerator (as an integer) and denominator (as a natural number). The construction combines these raw literals via the <code>mkRat</code> function to form the final rational number expression.\"  (score: 0.684)</p>\n</li>\n<li>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Tactic.Ring.ExProd.mkNat#doc\">definition Mathlib.Tactic.Ring.ExProd.mkNat (n : ℕ) : (e : Q($α)) × ExProd sα e :=\n  let lit : Q(ℕ) := mkRawNatLit n\n  ⟨q(($lit).rawCast : $α), .const n none⟩</a> \"Given a natural number <code>n</code>, constructs the expression representing the constant <code>n</code> in the semiring <code>α</code>, along with its representation in the <code>ExProd</code> type (used for normalizing ring expressions). The resulting expression is obtained by casting the natural number literal to the semiring type <code>α</code>.\"  (score: 0.684)</p>\n</li>\n<li>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Meta.NormNum.rawIntLitNatAbs#doc\">definition Mathlib.Meta.NormNum.rawIntLitNatAbs (n : Q(ℤ)) : (m : Q(ℕ)) × Q(Int.natAbs $n = $m) :=\n  if n.isAppOfArity <code>Int.ofNat 1 then\n    have m : Q(ℕ) := n.appArg!\n    ⟨m, show Q(Int.natAbs (Int.ofNat $m) = $m) from q(Int.natAbs_ofNat $m)⟩\n  else if n.isAppOfArity </code>Int.negOfNat 1 then\n    have m : Q(ℕ) := n.appArg!\n    ⟨m, show Q(Int.natAbs (Int.negOfNat $m) = $m) from q(Int.natAbs_neg $m)⟩\n  else\n    panic! \"not a raw integer literal\"</a> \"Given a quoted integer expression <code>n : Q(ℤ)</code>, this function returns a pair consisting of:</p>\n</li>\n</ul>\n<ol>\n<li>A quoted natural number expression <code>m : Q(ℕ)</code> representing the absolute value of <code>n</code></li>\n<li>A proof that the integer absolute value of <code>n</code> equals <code>m</code> (i.e., <code>Q(Int.natAbs $$n = $$m)</code>)</li>\n</ol>\n<p>The function handles both positive integers (constructed via <code>Int.ofNat</code>) and negative integers (constructed via <code>Int.negOfNat</code>), returning their absolute values with corresponding proofs.\"  (score: 0.677)</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Meta.NormNum.Result.ofRawNat#doc\">definition Mathlib.Meta.NormNum.Result.ofRawNat {α : Q(Type u)} (e : Q($α)) : Result e := Id.run do\n  let .app (.app _ (sα : Q(AddMonoidWithOne $α))) (lit : Q(ℕ)) := e | panic! \"not a raw nat cast\"\n  .isNat sα lit (q(IsNat.of_raw $α $lit) : Expr)</a> \"Given a typed expression <code>e</code> of type <code>α</code> that is a raw natural number cast (i.e., of the form <code>Nat.cast n</code>), this constructs a <code>Result e</code> containing:</li>\n</ul>\n<ol>\n<li>The natural number literal <code>lit</code> being cast</li>\n<li>A proof that <code>e</code> is equal to the coercion of <code>lit</code> into <code>α</code> (i.e., <code>IsNat e lit</code> holds)\"  (score: 0.676)</li>\n</ol>\n<ul>\n<li>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Qq.ofNatQ#doc\">definition Qq.ofNatQ (α : Q(Type $u)) (_ : Q(Semiring $α)) (n : ℕ) : Q($α) :=\n  match n with\n  | 0 =&gt; q(0 : $α)\n  | 1 =&gt; q(1 : $α)\n  | k+2 =&gt;\n    have lit : Q(ℕ) := mkRawNatLit n\n    have k : Q(ℕ) := mkRawNatLit k\n    haveI : $lit =Q $k + 2 := ⟨⟩\n    q(OfNat.ofNat $lit)</a> \"The function converts a natural number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> into a term of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> (represented as a quoted expression <code>Q($$α)</code>), where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> is a type with a semiring structure. For <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">n = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n = 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>, it directly returns the corresponding zero and one elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span>. For <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n \\geq 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>, it constructs the term using the <code>OfNat.ofNat</code> operation with the appropriate numeral.\"  (score: 0.674)</p>\n</li>\n<li>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Meta.Nat.unifyZeroOrSucc#doc\">definition Mathlib.Meta.Nat.unifyZeroOrSucc (n : Q(ℕ)) : MetaM (Nat.UnifyZeroOrSuccResult n) := do\n  match ← isDefEqQ n q(0) with\n  | .defEq pf =&gt; return .zero pf\n  | .notDefEq =&gt; do\n    let n' : Q(ℕ) ← mkFreshExprMVar q(ℕ)\n    let ⟨(_pf : $n =Q Nat.succ $n')⟩ ← assertDefEqQ n q(Nat.succ $n')\n    let (.some (n'_val : Q(ℕ))) ← getExprMVarAssignment? n'.mvarId! |\n      throwError \"could not figure out value of <code>?n</code> from <code>{n} =?= Nat.succ ?n</code>\"\n    pure (.succ n'_val ⟨⟩)</a> \"Given a natural number expression <code>n</code>, this function determines whether <code>n</code> is definitionally equal to <code>0</code> or can be expressed as <code>Nat.succ k</code> for some natural number <code>k</code>. The function returns a result indicating either that <code>n</code> is zero (with a proof of definitional equality) or that <code>n</code> is a successor (providing the predecessor <code>k</code>).\"  (score: 0.671)</p>\n</li>\n</ul>",
        "id": 533829483,
        "sender_full_name": "leanfinder",
        "timestamp": 1754930076
    },
    {
        "content": "<p>I'm not sure if any of these results are relevant</p>",
        "id": 533830534,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754930416
    },
    {
        "content": "<p>Yeah, hopefully <span class=\"user-mention\" data-user-id=\"768397\">@Wuyang</span> has learnt that this was really spammy and unhelpful to summon LeanFinder in so many places. :-(</p>",
        "id": 533894649,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1754964888
    }
]