[
    {
        "content": "<p>I've seen that sometimes people prefer not to use <code>abbrev</code> (e.g. <a href=\"#narrow/stream/287929-mathlib4/topic/!4.233082/near/348696573\">here</a>) and instead prefer copy-pasting definitions, e.g. when specializing a definition for a concrete type (monomorphizing). I thought <code>abbrev</code> had <a href=\"#narrow/stream/270676-lean4/topic/abbrev.20vs.20reducible/near/258080828\">extra hints</a> to the kernel and such. Is there some cases where <code>abbrev</code> not reduce things enough, or is this primarily for performance? (and how much of a difference does it have on  performance)?</p>",
        "id": 364646906,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1686248884
    },
    {
        "content": "<p>Note that, instead of copy-pasting definitions, you can use metaprogramming. See, for example, the <code>elab_inline</code> tool I used <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Need.20help.20proving.20termination.20of.20cata/near/364413259\">in this thread</a>.</p>",
        "id": 364650416,
        "sender_full_name": "Mac Malone",
        "timestamp": 1686249948
    },
    {
        "content": "<p>I guess my main question is why someone would not want to use <code>abbrev</code>; If there's  concrete examples where one would expect abbrev to be reduced/unfolded and it doesn't, or where using <code>abbrev</code> makes things noticeably slower?</p>",
        "id": 364746550,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1686293045
    },
    {
        "content": "<p>Maybe the reason is that <code>abbreviation</code> in Lean 3 meant the same as <code>@[reducible, inline] def</code> + \"Whoops, I forgot to generate the equation lemmas\", which made it very irritating to use.</p>",
        "id": 364750008,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1686294047
    },
    {
        "content": "<p>so it might be more of a remnant of Lean 3 that is less the case with Lean 4's <code>abbrev</code>?</p>",
        "id": 364807376,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1686307013
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315434\">Andrés Goens</span> <a href=\"#narrow/stream/270676-lean4/topic/drawbacs.20of.20abbrev/near/364746550\">said</a>:</p>\n<blockquote>\n<p>I guess my main question is why someone would not want to use <code>abbrev</code>; If there's  concrete examples where one would expect abbrev to be reduced/unfolded and it doesn't, or where using <code>abbrev</code> makes things noticeably slower?</p>\n</blockquote>\n<p>I use abbrev because defining a proxy (or a more descriptive name) for a type using <code>def</code> means I get none of the typeclass instances of the actual type.</p>",
        "id": 364810314,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686307666
    },
    {
        "content": "<p>If I define <code>def distance := \\Q</code> I don't get all the ring, field, and arithmetic related instances. For something as simple as adding two objects of the distance type, the compiler complains about HAdd instances for distance.  If I instead use <code>abbrev distance := \\Q</code>, I get all the instances of <code>\\Q</code> automatically for distance</p>",
        "id": 364811151,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686307842
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span>  but then you are arguing in favor of using <code>abbrev</code>, right? I was trying to understand the reasons not to use it. Or do you mean you <em>don't</em> want those instances because you want to define your own?</p>",
        "id": 364813116,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1686308242
    },
    {
        "content": "<p>(but then you wouldn't copy-paste the definitions)</p>",
        "id": 364813170,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1686308260
    },
    {
        "content": "<p>Yes indeed I am arguing in favour of your point</p>",
        "id": 364813198,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686308269
    },
    {
        "content": "<p>I guess this is a good example by <span class=\"user-mention\" data-user-id=\"130575\">@Siddharth Bhat</span> <a href=\"#narrow/stream/270676-lean4/topic/Ergonomics.3A.20linarith.20does.20not.20work.20on.20Nat.20alias\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Ergonomics.3A.20linarith.20does.20not.20work.20on.20Nat.20alias</a></p>",
        "id": 365764839,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1686640721
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315434\">Andrés Goens</span> <a href=\"#narrow/stream/270676-lean4/topic/drawbacks.20of.20abbrev/near/365764839\">said</a>:</p>\n<blockquote>\n<p>I guess this is a good example by <span class=\"user-mention silent\" data-user-id=\"130575\">Siddharth Bhat</span> <a href=\"#narrow/stream/270676-lean4/topic/Ergonomics.3A.20linarith.20does.20not.20work.20on.20Nat.20alias\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Ergonomics.3A.20linarith.20does.20not.20work.20on.20Nat.20alias</a></p>\n</blockquote>\n<p>That looks like a bug. Besides, the use of abbrev is still important there, because if you replace it with <code>def</code> then <code>H : a &lt; b</code> is an error since the relevant typeclasses are not defined for the type <code>Index</code>.</p>",
        "id": 365798448,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686647968
    },
    {
        "content": "<p>If you look closely at the example : The step <code>simp [Index] at *</code> is transforming <code>@LT.lt Index instLTNat a b : Prop</code> to <code>@LT.lt ℕ instLTNat a b : Prop</code>, implying that an instance of <code>LT</code> was inferred for <code>Index</code>. Why <code>linarith</code> failed to use it without this step is beyond me. But this instance only exists when one uses <code>abbrev</code></p>",
        "id": 365799923,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686648290
    },
    {
        "content": "<p>linarith presumably fails there because at some point it asks \"is this type syntactically Nat\"</p>",
        "id": 365801768,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686648685
    },
    {
        "content": "<p>Can that be replaced by a check for \"is it definitionally equal to Nat\"?</p>",
        "id": 365808901,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686650231
    },
    {
        "content": "<p>Yes, presumably a slight tweak to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Linarith.isNatProp#src\">src4#Linarith.isNatProp</a></p>",
        "id": 365809264,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686650329
    },
    {
        "content": "<p>Arguably that check is wrong anyway; it shouldn't be checking that the type is nat, but that the instance unifies with the nat one</p>",
        "id": 365810174,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686650497
    },
    {
        "content": "<p>Otherwise it will create an invalid proof if we put the dual order on nat, rather than crashing</p>",
        "id": 365810422,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686650543
    }
]