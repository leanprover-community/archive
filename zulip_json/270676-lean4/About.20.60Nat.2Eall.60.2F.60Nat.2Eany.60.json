[
    {
        "content": "<p>The following came about in a budding side project for <a href=\"https://github.com/fgdorais/lean4-unicode-basic\">UnicodeBasic</a> that aims to prove/verify relationships between Unicode properties. Since the Unicode standard is basically just a bunch of tables, these properties can only be checked by exhaustion. There are over 1.1 million code points to check so this is not a trivial task!</p>\n<p>My plan is that for user-facing code I will replace these exhaustive tests by a custom axiom <code>Unicode.checked</code> that works like <code>sorry</code>. I still need to run the actual checks on a regular basis to justify the claims made by this axiom. This is where <code>Nat.all</code>/<code>Nat.any</code> come into play and I ran into some issues and questions along the way...</p>\n<h3>1. Reduction</h3>\n<p>The kernel currently reduces <code>Nat.all</code>/<code>Nat.any</code>. This is fine for <code>Nat.all 17 _</code>, say, but it inevitably leads to deep recursion for <code>Nat.all 1114112 _</code>. In proofs, this makes it impossible to use some tactics that attempt to reduce such hypotheses.</p>\n<p>My current workaround is to use <code>Nat.all_eq_finRange_all</code>/<code>Nat.any_eq_finRange_any</code> as early as possible but that doesn't resolve all the deep recursion issues. Locally marking <code>Nat.all</code>/<code>Nat.any</code> as irreducible helps a bit but doesn't fully solve the problem.</p>\n<blockquote>\n<p>Should <code>Nat.all</code>/<code>Nat.any</code> be marked irreducible? Perhaps with a simproc to only reduce reasonably small cases? Or is there a better workaround?</p>\n</blockquote>\n<h3>2. Definition</h3>\n<p>The current definition for <a href=\"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Data/Nat/Fold.lean#L102\"><code>Nat.all</code></a> is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">specialize</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\">      </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This is not tail recursive but in the same file there is a tail recursive <code>Nat.allTR</code> which is csimp for <code>Nat.all</code>. </p>\n<p>However, this tiny variant is already tail recursive:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">specialize</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">allRev</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\">      </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">allRev</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>The explanation is that while <code>&amp;&amp;</code> is propositionally commutative, it is not definitionally commutative. The two definitions are provably equal but not definitionally equal.</p>\n<blockquote>\n<p>Should <code>Nat.all</code> be replaced by <code>Nat.allRev</code> to avoid the csimp? </p>\n</blockquote>\n<p>(The same holds for <code>Nat.any</code> with <code>&amp;&amp;</code> replaced by <code>||</code> and so on...)</p>\n<h3>3. Compilation</h3>\n<p>While <code>Nat.all</code> and <code>Nat.allRev</code> from above are provably equal, they compile differently. </p>\n<p>For example: <code>Nat.all 4 p</code> compiles essentially the same way as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(((</span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n</code></pre></div>\n<p>But <code>Nat.allRev p</code> compiles essentially the same way as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>These are different. If <code>p 0 = true</code>, <code>p 1 = false</code>, <code>p 2 = false</code>, <code>p 3 = true</code> then:</p>\n<ul>\n<li><code>Nat.all 4 p</code> evaluates <code>p 0</code> and <code>p 1</code> but doesn't evaluate <code>p 2</code> and <code>p 3</code>.</li>\n<li><code>Nat.allRev 4 p</code> evaluates <code>p 3</code> and <code>p 2</code> but doesn't evaluate <code>p 0</code> and <code>p 1</code>.</li>\n</ul>\n<p>This is not a serious concern unless <code>p</code> is not really pure. For example, if  <code>p</code> is partial and <code>p 3</code> is undefined but <code>p 0</code>, <code>p 1</code>, <code>p 2</code> are all defined as above,  then <code>Nat.all 4 p</code> is defined but <code>Nat.allRev 4 p</code> is undefined. (Same for <code>Nat.any</code> with <code>&amp;&amp;</code> replaced by <code>||</code> and so on...)</p>\n<blockquote>\n<p>Does any code out there rely on the order of evaluation for <code>Nat.all</code>/<code>Nat.any</code>? A quick check suggests that all code in core doesn't depend on evaluation order for <code>Nat.all</code>/<code>Nat.any</code>.</p>\n</blockquote>",
        "id": 530415936,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753297786
    },
    {
        "content": "<p>I would be happy to have <code>Nat.allRev</code> and <code>anyRev</code> in addition, but I think the runtime behaviours shouldn't be changed.</p>",
        "id": 530684240,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1753413616
    },
    {
        "content": "<p>What about using <code>Nat.allRev</code> / <code>Nat.anyRev</code> for kernel behavior and then <code>csimp</code>ing to something with the current runtime behavior?</p>",
        "id": 530717047,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1753430839
    },
    {
        "content": "<p>That seems very confusing. Just let people specify what behaviour they want by calling the relevant function.</p>",
        "id": 530721221,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1753432175
    },
    {
        "content": "<p>Hmm yeah it seems like the kernel can't really handle either of <code>Nat.all</code> / <code>Nat.allRev</code> well for large numbers and the performance is also not significantly different so I guess there is no point in changing anything.</p>",
        "id": 530743403,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1753439344
    },
    {
        "content": "<p>Those are fair assessments: the <code>*Rev</code> versions are just barely more efficient than the <code>*TR</code> versions. It's not really worth adding them without a specific need.</p>\n<p>That resolves 2 and 3, but not 1. Is there a smart way to prevent deep recursion with <code>Nat.all</code>/<code>Nat.any</code>?</p>",
        "id": 530804168,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753459124
    },
    {
        "content": "<p>How quickly do you get into such a situation? Can you provide an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 530817370,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1753464001
    },
    {
        "content": "<p>Not quite a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> but this is a real life example (with no imports required) extracted from <a href=\"https://github.com/leanprover-community/batteries/pull/1344\">batteries#1344</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Returns `true` if `p` returns true for every `Char`. -/</span>\n<span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Char</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Char</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"mi\">1114112</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">55296</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Char</span><span class=\"bp\">.</span><span class=\"n\">ofNatAux</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">h₁</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">57343</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Char</span><span class=\"bp\">.</span><span class=\"n\">ofNatAux</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">h₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">true</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Char</span><span class=\"bp\">.</span><span class=\"n\">exists_eq_false_of_all_eq_false</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Char</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Char</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">all_eq_finRange_all</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">all_eq_false</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">eq_false_iff</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">ofNatAux</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩;</span><span class=\"w\"> </span><span class=\"n\">assumption</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">ofNatAux</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"bp\">⟨?_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"bp\">⟩</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩;</span><span class=\"w\"> </span><span class=\"n\">assumption</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>This better illustrates my workarounds than the actual problem. </p>\n<p>A quick example is on the last line, <code>h: ¬true = true</code> so <code>contradiction</code> was my go-to but it hangs (this is probably an issue with <code>contradiction</code> itself since <code>simp_all</code> does a lot better). </p>\n<p>Before finding this working proof, I ran into other deep recursion issues until I realized that <code>Nat.all_eq_finRange_all</code> really helps. I'd have to go back in time to figure out what issues I ran into before then.</p>",
        "id": 530842782,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753474759
    }
]