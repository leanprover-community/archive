[
    {
        "content": "<p>Per our <code>variable</code> inclusion rules, it seems to me that <code>B</code> should not be included. But if you look at the trace, you'll see <code>Add B</code> is mentioned. This seems like a bug to me. Am I wrong, if so, why?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">profiler</span><span class=\"bp\">.</span><span class=\"n\">useHeartbeats</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">profiler</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a₁</span><span class=\"w\"> </span><span class=\"n\">a₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a₁</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a₂</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a₁</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a₂</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 512164602,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744661384
    },
    {
        "content": "<p>I think you are still in the statement at that point</p>",
        "id": 512164732,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744661423
    },
    {
        "content": "<p>(Note: <code>B</code> is not included in the declaration added to the environment, but I don't understand why <code>Add B</code> appears in the trace <em>at all</em>.)</p>",
        "id": 512164735,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744661425
    },
    {
        "content": "<p>yes, so?</p>",
        "id": 512164798,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744661448
    },
    {
        "content": "<p>All the variables are included when elaborating the statement, and then only relevant ones are included when elaborating the proof</p>",
        "id": 512164843,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744661470
    },
    {
        "content": "<p>Otherwise you wouldn't be able to refer to <code>A</code></p>",
        "id": 512164866,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744661483
    },
    {
        "content": "<p>The local context at <code>rfl</code> is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"n\">a₁</span><span class=\"w\"> </span><span class=\"n\">a₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">a₁</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a₂</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a₁</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a₂</span>\n</code></pre></div>\n<p>which looks right.</p>",
        "id": 512164960,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744661515
    },
    {
        "content": "<p>aha, so here's a footgun I just realized we have. Including <code>variable</code> headers, especially with lots of type class hypotheses, at the top of a file leads to potentially expensive elaboration of every declaration in the file.</p>",
        "id": 512165223,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744661614
    },
    {
        "content": "<p>Also, don't we have asynchronous elaboration of the statement and the proof? or is it asynchronicity of elaboration and kernel checking?</p>",
        "id": 512165349,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744661656
    },
    {
        "content": "<p>The statement is still synchronous</p>",
        "id": 512165752,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1744661802
    },
    {
        "content": "<p>How would you begin elaborating the proof if you don't know the statement yet? Therefore the statement must be synchronous.</p>",
        "id": 512165806,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744661815
    },
    {
        "content": "<p>Aaron, you can infer the type of the statement from the proof, if it's provided in term mode, so that's one way. But yes, I understand your point.</p>",
        "id": 512166006,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744661892
    },
    {
        "content": "<p>If it's in term mode and the term doesn't need an expected type (many proof terms rely heavily on the expected type!)</p>",
        "id": 512166385,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744662043
    },
    {
        "content": "<p>yes, I understand.</p>",
        "id": 512166424,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744662057
    },
    {
        "content": "<p>By the way, the reason I came across this footgun is that it actually came up in practice in <a href=\"https://github.com/leanprover-community/mathlib4/pull/24013\">#24013</a></p>",
        "id": 512166616,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744662123
    },
    {
        "content": "<p>I think Sebastian is saying that the statement headers are synchronous by the way. There's a synchronization point between the statement header and the theorem body more specifically, and the bodies are asynchronous. (Sebastian can correct me if I'm wrong. I'm just going by what I've seen what the orange bars do on heavy files.)</p>\n<p>One could imagine a much more complicated statement header elaborator that is asynchronous, where headers can figure out what they're defining and then later headers can wait if the type is needed.</p>",
        "id": 512166942,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744662255
    },
    {
        "content": "<p>What's the footgun <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span>?</p>",
        "id": 512167053,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744662302
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/270676-lean4/topic/Bug.20in.20elaboration.3F/near/512165223\">said</a>:</p>\n<blockquote>\n<p>aha, so here's a footgun I just realized we have. Including <code>variable</code> headers, especially with lots of type class hypotheses, at the top of a file leads to potentially expensive elaboration of every declaration in the file.</p>\n</blockquote>",
        "id": 512167082,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744662315
    },
    {
        "content": "<p>If I understand correctly, the reason that variables are re-elaborated at every declaration is because auto-implicits are placed before all other binders. (Autoimplicits have quadratic behavior: every time a binder has a new autoimplicit, all the binders before it are elaborated again.)</p>\n<p>For an example of this \"before all other binders\" behavior, on <code>y</code> there is a <code>type mismatch y has type ?m.43 : Sort ?u.42 but is expected to have type α : Type</code> error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">baz</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n</code></pre></div>\n<p>If this restriction were relaxed (perhaps each <code>variables</code> block could be its own autoimplicits checkpoint, and binder lists could be checkpoints as well), then I think it would be possible to elaborate a <code>variables</code> block just once.</p>\n<p>Complexities:</p>\n<ul>\n<li>It's possible people have depended on autoimplicits appearing at the front.</li>\n<li>Variable lists can have metavariables, so we'd need to save the metavariable context. (The alternative is to turn metavariables into free variables, which is the Lean 3 behavior. I expect that would break things. Side note: Mathlib's <code>Type*</code> is mimicking the Lean 3 <code>Type*</code> when it appeared in a <code>variable</code> list. Lean 3 <code>Type*</code> is actually <code>Type _</code>, but the metavariable was turned into a new universe level variable at the end of <code>variable</code>.)</li>\n<li><code>addAutoBoundImplicits</code> would need to be aware that autoimplicits can appear elsewhere in a parameter list, not just the front.</li>\n</ul>\n<p>A benefit is that once a <code>variable</code> list elaborates, it's known good. Currently it's possible to break a previously elaborating <code>variable</code> list.</p>",
        "id": 512170154,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744663515
    }
]