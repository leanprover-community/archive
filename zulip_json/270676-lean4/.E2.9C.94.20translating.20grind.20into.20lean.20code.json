[
    {
        "content": "<p>Hello,<br>\ni just discovered that there is a tactic called <code>grind</code> in lean. It is possible to replace the <code>grind</code> call with <code>grind?</code> which yields a <code>grind only [...]</code> call showing what stuff got used. </p>\n<p>This then looks something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">contains_map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">usr</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">map_subset</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">nodup_iff_count</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">=_</span>\n<span class=\"w\">          </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">flatMap_def</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">map_flatten</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">contains_flatten</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">mem_map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">=_</span>\n<span class=\"w\">          </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">map_map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">=_</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">contains_iff_mem</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">any_flatten</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">contains_eq_mem</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">          </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">any_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">any_beq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">nodup_iff_pairwise_ne</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">flatMap_def</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">          </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">subset_def</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">contains_flatMap</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">mem_flatMap</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">any_flatMap</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">          </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">eq_nil_of_map_eq_nil</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">map_map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">pairwise_iff_forall_sublist</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">eager</span>\n<span class=\"w\">          </span><span class=\"n\">Subtype</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Is there a way to reasonably translate this into 'pure' lean code (like by just using rw, apply, etc.) from the information given by <code>grind?</code></p>",
        "id": 528542750,
        "sender_full_name": "HenrikT",
        "timestamp": 1752426037
    },
    {
        "content": "<p>You could in principle figure out that translation yourself by hand but no such thing is available built-in</p>",
        "id": 528542899,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1752426168
    },
    {
        "content": "<p>You can use options like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">grind</span><span class=\"bp\">.</span><span class=\"n\">ematch</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">grind</span><span class=\"bp\">.</span><span class=\"n\">eqc</span><span class=\"w\"> </span><span class=\"n\">true</span>\n</code></pre></div>\n<p>to get a better understanding of how <code>grind</code> solved the problem</p>",
        "id": 528542985,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1752426250
    },
    {
        "content": "<p>Ok, that yields a very very long output. How do you read the <code>grind only [...]</code> example i posted above ? <br>\nFor example what do the <code>=_</code> and <code>=</code> mean before each entry ?</p>",
        "id": 528543221,
        "sender_full_name": "HenrikT",
        "timestamp": 1752426449
    },
    {
        "content": "<p>Is there some documentation for it somewhere ?</p>",
        "id": 528543239,
        "sender_full_name": "HenrikT",
        "timestamp": 1752426469
    },
    {
        "content": "<p><a href=\"https://lean-lang.org/doc/reference/latest/The--grind--tactic/#grind\">https://lean-lang.org/doc/reference/latest/The--grind--tactic/#grind</a>, in particular 17.8</p>",
        "id": 528543308,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1752426523
    },
    {
        "content": "<p>Thanks, i will have a look <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 528543414,
        "sender_full_name": "HenrikT",
        "timestamp": 1752426605
    },
    {
        "content": "<p>Translating <code>grind</code> into \"pure\" Lean code isn't easy. <code>grind</code> has <code>linarith</code>, <code>ring</code> and a new presburger arithmetic solver <code>cutsat</code>. We all know the output of <code>linarith</code> when translating into \"pure\" Lean isn't very pleasant to look at, I imagine <code>cutsat</code> is even worse.</p>",
        "id": 528543644,
        "sender_full_name": "(deleted)",
        "timestamp": 1752426816
    },
    {
        "content": "<p>cutsat is not a presburger arithmetic solver at all, refer to the manual above for what it is</p>",
        "id": 528543685,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1752426850
    },
    {
        "content": "<p><a href=\"https://math.stackexchange.com/questions/4092631/presburger-arithmetic-vs-linear-integer-arithmetic\">https://math.stackexchange.com/questions/4092631/presburger-arithmetic-vs-linear-integer-arithmetic</a></p>\n<p>My understanding is cutsat is roughly <code>lia</code> in Rocq and <code>lia</code> is widely described as a Presburger arithmetic solver. And from reading the manual it says that <code>cutsat</code> solves linear integer arithmetic problems—I think I'm just using different terminology.</p>",
        "id": 528544248,
        "sender_full_name": "(deleted)",
        "timestamp": 1752427448
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"621592\">HenrikT</span> has marked this topic as resolved.</p>",
        "id": 528544992,
        "sender_full_name": "Notification Bot",
        "timestamp": 1752428297
    }
]