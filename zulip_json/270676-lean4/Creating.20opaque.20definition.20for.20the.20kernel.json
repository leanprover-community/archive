[
    {
        "content": "<p>We are using dependent types which may be quite expensive if they are ever unfolded.  We found that even just elaborating an identifier of that type would mean the type would be <a href=\"https://github.com/leanprover/lean4/blob/5d2c7fc1d92a1049f04bba1b16c0a1cfae845e00/src/Lean/Elab/App.lean#L215\">normalised to find out if it is a function type or not</a>, regardless of if it is being applied or not.  To work around this, we then just wanted to make the definition of our type <code>irreducible</code> so that this check wouldn't start reducing our term.</p>\n<p>However, it seems like some tactics use <a href=\"https://github.com/leanprover/lean4/blob/5d2c7fc1d92a1049f04bba1b16c0a1cfae845e00/src/Lean/Meta/Check.lean#L202\"><code>isTypeCorrect</code></a> to do type checking at the Meta level. This function sets <code>Transparency.all</code>, meaning the definition will be reducible again, and we then get timeouts again during <code>whnf</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"w\"> </span><span class=\"c1\">-- needed for whnf tactic</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">type'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">type'</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"n\">seal</span><span class=\"w\"> </span><span class=\"n\">type'</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">type'</span><span class=\"w\"> </span><span class=\"mi\">1000</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"bp\">?</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"c1\">-- simulating a call to `isTypeCorrect` which times out.</span>\n<span class=\"w\">  </span><span class=\"n\">with_unfolding_all</span><span class=\"w\"> </span><span class=\"n\">whnf</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>In the above, I would like <code>whnf</code> to not do anything, because I would like <code>type'</code> to stay sealed.  Is this something that is possible?  I guess the definition should also be opaque to the kernel when it is doing type-checking as well to avoid reduction there as well.</p>",
        "id": 472470908,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1727177675
    },
    {
        "content": "<p>You can use <code>opaque</code> instead of <code>def</code> to make something that is truly not unfoldable</p>",
        "id": 472474802,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1727178894
    },
    {
        "content": "<p>Oh cool, is there a way to make it <code>semireducible</code> in certain scenarios?  For certain specific inputs we would like to be able to reduce them (in a separate theorem maybe) but in general (in the final proof) we know we don't even want to try to reduce them.</p>",
        "id": 472475375,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1727179033
    },
    {
        "content": "<p><code>opaque</code> means truly untouchable, you can't do anything to it under any circumstances</p>",
        "id": 472475460,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1727179062
    },
    {
        "content": "<p>Hmm, so you can't prove any properties about it then either I guess.</p>",
        "id": 472475622,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1727179099
    },
    {
        "content": "<p>You can prove lot's of properties about them, just not any properties that concern their definition. But e.g. if you have an <code>opaque Foo : Fin 10</code> you will still be able to show that it is less than <code>10</code> and so on.</p>",
        "id": 472476139,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1727179231
    },
    {
        "content": "<p>It's not really easy to tell what exactly you are looking for based on your example though</p>",
        "id": 472476205,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1727179246
    },
    {
        "content": "<p>Ah yes, that's true.  In our case the interesting properties are more computational and you get them out when you reduce the type.  However, due to the normalisation during elaboration and <code>isTypeCorrect</code> checks we want to avoid doing that in most proofs, so that we limit where we actually reduce them.  </p>\n<p>For example, we might build up a type like the following, and prove a property about it in <code>example</code>.  However, in the final theorem we would like <code>comp_type</code> to be completely opaque to avoid any expensive reduction.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Batteries</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">comp_type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(((</span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">RBMap</span><span class=\"bp\">.</span><span class=\"n\">ofList</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"bp\">.</span><span class=\"n\">compare</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mergeWith</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">          </span><span class=\"o\">(</span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">RBMap</span><span class=\"bp\">.</span><span class=\"n\">ofList</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"bp\">.</span><span class=\"n\">compare</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">comp_type</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"n\">seal</span><span class=\"w\"> </span><span class=\"n\">comp_type</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">:(</span><span class=\"n\">comp_type</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n</code></pre></div>\n<p>Note that the <code>rfl</code> proof already takes 7 seconds but kernel type-checking is near instant, and it's mainly due to this that we get performance issue with Meta level reduction on our types.</p>",
        "id": 472478155,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1727179781
    },
    {
        "content": "<p>We discuss this a bit in <a href=\"#narrow/stream/270676-lean4/topic/Reduction.20of.20terms.20with.20free.20variables.20is.20expensive/near/469077847\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Reduction.20of.20terms.20with.20free.20variables.20is.20expensive/near/469077847</a> as well, and are now using kernel reduction at the Meta level like <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> had suggested.</p>\n<p>However, maybe this is just the wrong approach, and we should rethink how our types are generated and represented.</p>",
        "id": 472478613,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1727179910
    },
    {
        "content": "<p>One way you can avoid unfolding in types is to make <code>structure</code> newtype wrappers around those types. The resulting type is isomorphic to the original but not defeq, and it is opaque and will not reduce in any way (but you can use the projection/constructor to get at the contained value)</p>",
        "id": 472479860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727180282
    },
    {
        "content": "<p>Interesting, thank you both for the insights, I'll try that out!</p>",
        "id": 472480251,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1727180414
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">comp_type</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n</code></pre></div>",
        "id": 472480456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727180487
    },
    {
        "content": "<p>Thanks, I think this will work quite well for us in practice too, it avoids the inherent reduction nicely.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">is_t</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">comp_type</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">comp_type</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">is_t</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">get</span>\n</code></pre></div>",
        "id": 472482328,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1727181061
    },
    {
        "content": "<p>I've continued to run into reduction issues actually, even when the type is <code>Wrapped</code>.  In the following (<a href=\"https://live.lean-lang.org/#codez=CYUwZgBALgngDiA5BAXBAcgQyhQSYQQBV4QAoCCAHwgAYIBeAPg2zMogDsBqARnqdgTJ2JEgGcoAJwCuAYyhSJICAHUJmOAgkQAFAVSFiEAPoBKCAHcAFiEWsA5iBxoCJUBICWAN3fs7EAEogcBIANBAAkuyWmABG7lAgwGEAEpii0TEANiBhACIgMu7AsdkAogCOYQDyEkkQAEIVIpgAHu4A9gC2EAAKEADeAIIAvvqDeL0S7XAkrR3dPchoAkgQ3NQbtPg9UzNikrLyihCxMjqDZmg70xbWtuSY+oAARDrs+qrqmhAXYX3sAHQOKAiAC0IIg+UysXaaigMIgohAIE6omg7QgNimWnaUhwmDACS0AAMZO12OJpHIYUT/uRwjhEcjUXDoBIYCd2MAIIpgLIlESVogiWFOpgYDElFYQG94hj2KSpOxCaiiQCgUSAPwkMEIkCYTLQYjIHwkEAtTCdODZfSnHSCtabaiXOgQGIwVik8kHKkSVg+STo5Kg8GqwGOIkYqExGHYDpvKDuTogVE4qBhCUyTBSREQWWSdzJtHcxJ8iACo1E7XgxH6w2CXPCCmHBRKU5LSY3KX3E7PV7vNQaGwQAA8VHt602Jl+QjDwKAA\">Link to web version</a>), I would ideally like to define a <code>Prop</code> similar to <code>abc</code>, which also should be safe and avoid reducing <code>type'</code>, but I now run into a the <em>delaborator</em> trying to show the goal created by <code>constructor</code>, meaning it tries to reduce <code>type'</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">abc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">get</span>\n\n<span class=\"c1\">-- Delaborator seems to error out after `constructor`.  It seems to try and reduce `type'`,</span>\n<span class=\"c1\">-- maybe when it encounters `n.get`?</span>\n<span class=\"c1\">-- seal type' in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">abc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">type'</span><span class=\"w\"> </span><span class=\"mi\">10000</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">H</span>\n</code></pre></div>\n<p>Instead, defining the structure explicitly runs into the same issue as before I think.  Because I use n.get, it will try and reduce <code>type'</code> to figure out if it is a function or not (which is why I preferred the previous solution).</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">P'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">type'</span><span class=\"w\"> </span><span class=\"mi\">10000</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"c1\">-- `n.get` elaboration times out, because it tries to reduce `type'`</span>\n<span class=\"c1\">-- seal type' in</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">abc'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">type'</span><span class=\"w\"> </span><span class=\"mi\">10000</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">P'</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">get</span>\n</code></pre></div>\n<p>It seems like in both cases I need to <code>seal type'</code> <em>as well as</em> wrap it to try and avoid all the implicit reduction that goes on when elaborating and delaborating terms.  Is there any way we could avoid doing this?  Is it uncommon in Lean to want to compute types in this way? We are essentially building a map of types by recursively merging them, but it seems like we have to tread extremely carefully when we have such a type anywhere, because Lean might try to reduce it.</p>",
        "id": 472946660,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1727372855
    },
    {
        "content": "<p>Interesting, this tries to reduce <code>type'</code>, causing a \"max recursion depth\" error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">type'</span><span class=\"w\"> </span><span class=\"mi\">10000</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>Tip for dealing with delaborator failures: you can do <code>set_option pp.raw true</code> to turn it off, and it prints some representation of the raw expressions.</p>",
        "id": 472947930,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727373351
    },
    {
        "content": "<p><del>Ah yes, I did have that locally (doesn't seem to work in the online version), but I thought I couldn't continue with the proof, but it seems to be possible, but as expected quite hard to read.</del> Ah sorry I had <code>pp.rawOnError</code>, I didn't know <code>pp.raw</code> turned off the delaborator, that's helpful, thanks!</p>\n<p>And yeah I guess I don't understand exactly why <code>type'</code> is reduced in your example.</p>",
        "id": 472948447,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1727373542
    },
    {
        "content": "<p>(I'm not sure if it's possible, but maybe <code>rawOnError</code> should be able to catch runtime errors too.)</p>",
        "id": 472949431,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727373897
    },
    {
        "content": "<p>I've tried looking through <code>set_option trace.Meta.isDefEq true</code>, but I'm not seeing where <code>type'</code> would be unfolded, but <code>set_option diagnostics true</code> shows it definitely is.</p>\n<p>My current guess is that isDefEq's check that the type is a forall is causing it to unfold. I think there is a lot of code that assumes reducing types is relatively cheap.</p>",
        "id": 472951382,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727374659
    },
    {
        "content": "<p>Yeah I knew this check happened during elaboration of identifiers, but I was hoping it wouldn't get triggered here.  It seems like isDefEq shouldn't have to unfold anything, as the types should be structurally equal.  But yeah somewhere it is probably reducing the type to check for a forall again.  Tracing <code>trace.Meta.whnf</code> shows that too like the diagnostics.  In some of these cases it seems like this check is unnecessary, but you may be right that too much code assumes types can be reduced.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">maxHeartbeats</span><span class=\"w\"> </span><span class=\"mi\">100</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">whnf</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">type'</span><span class=\"w\"> </span><span class=\"mi\">10000</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>We may have to try a different representation then to avoid creating types that are performing too much computation.</p>",
        "id": 472961746,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1727379180
    },
    {
        "content": "<p>Oh right, more likely are the pervasive telescope calculations, which are used to analyze the parameters to functions.</p>\n<p>For example, the delaboration issue is probably from <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/PrettyPrinter/Delaborator/Builtins.lean#L160-L180\">this calculation</a>, which is also looking for the types of parameters <em>after</em> all the supplied arguments, because that is used to analyze how to pretty print applications.</p>",
        "id": 472968226,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727382221
    },
    {
        "content": "<p>Yeah thanks, it does make sense that assuming types will be cheap to reduce could lead to better user experiences.  I think  ideally using <code>seal</code> to completely hide the implementation of our types so it is never reduced would work well for us.  We unfortunately still seem to hit some cases where reduction is forced with <code>withTransparency .all</code>, which I'm assuming is coming from <a href=\"https://github.com/leanprover/lean4/blob/5d2c7fc1d92a1049f04bba1b16c0a1cfae845e00/src/Lean/Meta/Check.lean#L202\"><code>isTypeCorrect</code></a>, and I'm not sure I understand exactly why it's needed, although removing it breaks everything.</p>",
        "id": 473053275,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1727427406
    }
]