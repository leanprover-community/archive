[
    {
        "content": "<p>Is there any way to direve DecidableEq across lists of  self DecidableEqs?</p>\n<p>In particular, I am trying to achieve the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">List</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">String</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Term</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Term</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"c1\">--, DecidableEq</span>\n</code></pre></div>\n<p>DecidableEq is commented because it fails (due to the List of Terms in the app constructor). I am halfway towards creating the instance by hand (which will be very painfully as in our project we have many more constructors, and it will create n^2 comparisons, and I am still stuck in trying to use list1 = list2 in a dite, which also fails (for the same reason). </p>\n<p>I have dealt with a similar problem by encoding the list as part of the term (with a boolean type parameter to separate the list from the actual term), but I also wanted to avoid going that route.</p>\n<p>Is there any useful info that I am missing?</p>\n<p>Thanks in advance!</p>",
        "id": 449271459,
        "sender_full_name": "Alcides Fonseca",
        "timestamp": 1720173124
    },
    {
        "content": "<p>The derive handler for <code>DecidableEq</code> doesn't yet support nested inductive types, hence the error when trying to derive that instance. I need to get around to making that work at some point... in the meantime, here's a working instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Term</span>\n\n<span class=\"kd\">mutual</span>\n<span class=\"w\">  </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">decEqTerm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">Term</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">isFalse</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">injection</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"n\">s₁</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"n\">s₂</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s₁</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s₂</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">isTrue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">isFalse</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">injection</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">contradiction</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">s₁</span><span class=\"w\"> </span><span class=\"n\">l₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">s₂</span><span class=\"w\"> </span><span class=\"n\">l₂</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s₁</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s₂</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">         </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">decEqListTerm</span><span class=\"w\"> </span><span class=\"n\">l₁</span><span class=\"w\"> </span><span class=\"n\">l₂</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">          </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">isTrue</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">isTrue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span>\n<span class=\"w\">          </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">isFalse</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">isFalse</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">injection</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">contradiction</span>\n<span class=\"w\">      </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">isFalse</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">injection</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">contradiction</span>\n\n<span class=\"w\">  </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">decEqListTerm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">isTrue</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">::</span><span class=\"n\">t</span><span class=\"o\">,[]</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">::</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">isFalse</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">injection</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"o\">::</span><span class=\"n\">t₁</span><span class=\"o\">,</span><span class=\"n\">h₂</span><span class=\"o\">::</span><span class=\"n\">t₂</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">decEqTerm</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">isTrue</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">decEqListTerm</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">          </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">isTrue</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">isTrue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span>\n<span class=\"w\">          </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">isFalse</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">isFalse</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">injection</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">contradiction</span>\n<span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">isFalse</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">isFalse</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">injection</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">contradiction</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">decEqTerm</span>\n</code></pre></div>",
        "id": 449273468,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1720173814
    },
    {
        "content": "<p>I was completely missing the mutual definition! That makes total sense! </p>\n<p>I wish I needn't need to considerate all pairs in the first case of decEqTerm, but I'll wait eagerly for the nested inductive types! </p>\n<p>Thank you so much for the help, Arthur!</p>",
        "id": 449273936,
        "sender_full_name": "Alcides Fonseca",
        "timestamp": 1720173972
    },
    {
        "content": "<p>Arthur, I was just looking at that module to see what's missing for decidable equality for nested inductives. I hope to have mutual structural recursion over nested inductives soonish. Once that's there, the deriving code can be adjusted, I assume. Is that something you'd be want to implement then?</p>",
        "id": 449284136,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1720177254
    },
    {
        "content": "<p>And I guess for mutual non-nested inductive it's already possible (on my branch there)</p>",
        "id": 449284371,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1720177292
    },
    {
        "content": "<p>Hi Joachim,<br>\nDeriving <code>DecidableEq</code> for mutual inductive types has already been supported since <a href=\"https://github.com/leanprover/lean4/pull/2591\">lean4#2591</a>, although it uses wellfounded recursion and is, thus, quite slow. It might be interesting to see whether the definitions generated by the derive handler could be generated in a structural manner once your PR lands.</p>\n<p>I have an old PR which aims to support deriving DecidableEq for nested inductive types (<a href=\"https://github.com/leanprover/lean4/pull/3160\">lean4#3160</a>), but it still requires a bit of work. Examples such as the one in this thread should already work, but things get harder once you start nesting your inductive inside more complex inductive types. For example, if this <code>Term</code> definition was to nest inside an array instead of a List, you would need to not only make a definition to derive DecidableEq for <code>Array Term</code>, but also one for <code>List Term</code> since it appears in the instantiated definition of <code>Array</code>. Managing such cases is the last building block missing fom my PR.</p>",
        "id": 449285644,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1720177605
    },
    {
        "content": "<p>Nice! It seems to be in good hands. Let me know if you face issues using structural recursion, should you try. (I guess for decidable equality it doesn't really matter how it is implemented, as one doesn't need the DefEqs?)</p>",
        "id": 449287196,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1720178156
    },
    {
        "content": "<p>Having the better reduction behaviour from structural recursion would make <code>decide</code> much more usable when working with mutual/nested types.</p>",
        "id": 449288309,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1720178612
    }
]