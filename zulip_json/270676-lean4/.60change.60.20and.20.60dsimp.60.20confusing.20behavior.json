[
    {
        "content": "<p>I have the following strange behavior:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">Normed</span><span class=\"bp\">.</span><span class=\"n\">Ring</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo_prop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- dsimp [foo]</span>\n<span class=\"w\">  </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- error, \"not definitionally equal\"</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo_prop'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- works fine, gives warning that `change` does nothing</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fooQ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">fooQ_prop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">fooQ</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- dsimp [fooQ]</span>\n<span class=\"w\">  </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- if we change Real to Rat then it unifies fine</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I have two expressions <code>expr1</code> and <code>expr2</code>. Calling <code>dsimp [foo]</code>, where <code>foo</code> is a def with default reducibility, turns expr1 into expr2. If I call <code>change</code> (with some underscores), then it fails, saying they're not definitionally equal. I don't understand why <code>change</code> can't unify this (pretty simple, to me?) pair of expressions.</p>\n<p>If I fill in all the underscores, it works, but I would like to not have to do that ... I would also like to get a better understanding of _why_ it does or doesn't work so I can diagnose this better in the future. Changing the reducibility on <code>foo</code> doesn't seem to affect anything.</p>\n<p>But what's _really_ weird is that if I change the type <code>Real</code> in the expressions to <code>Rat</code>, then <code>change</code> does work suddenly. My expectation is that these are \"just\" types equipped with commutative rings, so as far as everything else in this problem is concerned, they should be 100% equivalent. So I'm very surprised that this affects anything.</p>",
        "id": 507472142,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742664993
    },
    {
        "content": "<p>At the very least, to me (who doesn't <em>properly, deeply</em> understand how unification works), the docstrings on <code>dsimp</code> and <code>change</code> seem very inconsistent with this behavior, since <code>dsimp</code> says it gives a definitionally equal experssion, but <code>change</code> complains that it \"is not definitionally equal\" to the goal. I know that definitional equality isn't transitive, but I don't think that's the thing happening here? I'm sure the docstrings _are_ correct, but then, I'm kind of being misled by them. Is there a clearer way to explain things, maybe?</p>",
        "id": 507472222,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742665060
    },
    {
        "content": "<p>If you set <code>set_option trace.Meta.isDefEq true</code> and look at</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">isDefEq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">❌️</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">365</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">366</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n</code></pre></div>\n<p>you can see it's going down this long path where it's trying to unfold <code>Finset.sum</code> to discover the defeq. I haven't gotten to the end of it yet, but obviously that's not what you'd expect to be unfolded.</p>",
        "id": 507472849,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742665469
    },
    {
        "content": "<p>Finally got to the end of it. It sees this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Quot</span><span class=\"bp\">.</span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">foldr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⋯</span>\n<span class=\"w\">                                                  </span><span class=\"o\">(</span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">366</span>\n<span class=\"w\">                                                    </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n<span class=\"w\">                                                      </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">365</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"w\">            </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">foldr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[]))</span>\n</code></pre></div>\n<p>and can't see how to unify them. It reports that <code>?m.365</code> is a stuck mvar.</p>",
        "id": 507473107,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742665632
    },
    {
        "content": "<p>Doing <code>dsimp only [foo]</code> before <code>change</code> helps prevent it going down this wrong path, since it eliminates the projection. I don't know why defeq checking prefers to not unfold the projection in this case.</p>",
        "id": 507473278,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742665753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/.60change.60.20and.20.60dsimp.60.20confusing.20behavior/near/507473107\">said</a>:</p>\n<blockquote>\n<p>Finally got to the end of it. It sees this ... and can't see how to unify them. It reports that <code>?m.365</code> is a stuck mvar.</p>\n</blockquote>\n<p>I believe that's what is happening (and thanks for the <code>set_option</code> pointer), but that doesn't really clarify me on why it's happening. In my head, I picture things going something like</p>\n<p><code>r ≤ foo.snd</code> matches <code>r ≤ (Finset.sum _ _ : ℝ)</code> up to the <code>LE.le</code> head and the <code>r</code> argument, so now it becomes <code>foo.snd =?= (Finset.sum _ _ : ℝ)</code></p>\n<p>and then <code>foo.snd</code> becomes <code>⟨0, ∑ i ∈ Finset.range 1, (7 ^ i)⟩.snd</code> becomes <code>∑ i ∈ Finset.range 1, (7 ^ i)</code>, and that matches directly with <code>Finset.sum _ _</code>.</p>",
        "id": 507473516,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742665920
    },
    {
        "content": "<p>Oh, so it's not doing the projection, so it's not doing the \"<code>⟨0, ∑ i ∈ Finset.range 1, (7 ^ i)⟩.snd</code> becomes <code>∑ i ∈ Finset.range 1, (7 ^ i)</code>\" step?</p>",
        "id": 507473571,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742665938
    },
    {
        "content": "<p>My guess with why changing Real to Rat everywhere seems to fix this is that it unfolds <code>Rat.add</code> (<code>Real.add</code> is irreducible) and it eventually manages to see how things line up. That's very deep unfolding, and it's not something we'd want anything to rely on.</p>",
        "id": 507473596,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742665955
    },
    {
        "content": "<p>Ahhhh. Okay, hm. I guess that explains why it's relevant then</p>",
        "id": 507473633,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742665980
    },
    {
        "content": "<p>So I'm understanding this as, <code>change</code> kind of has freedom to unfold wherever it wants to try to prove things are defeq, and it chose a wrong path; but <code>dsimp</code> is restricted to only certain things (reducible definitions, projections, and definitions I pass it - or something like that?) and took a better path?</p>",
        "id": 507473705,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742666035
    },
    {
        "content": "<p>With <code>dsimp only [foo]</code> you're saying \"unfold foo and do basic reductions\". There's not really any defeq checking involved here.</p>",
        "id": 507473825,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742666100
    },
    {
        "content": "<p>It happens to cause <code>change</code> to succeed with its defeq check</p>",
        "id": 507473871,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742666125
    },
    {
        "content": "<p>Correction: there is some defeq checking because of <code>dsimp</code>, but that's done by the kernel. Maybe the kernel is needing to unfold a whole lot to see that what <code>dsimp</code> is doing is correct.</p>",
        "id": 507473997,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742666188
    },
    {
        "content": "<blockquote>\n<p>There's not really any defeq checking involved here.</p>\n</blockquote>\n<p>Okay, the docstring for dsimp says \"the result is guaranteed to be definitionally equal to the input\". I realize that is not exactly the same as defeq _checking_ but it sure suggests that it's something like it, no?</p>",
        "id": 507474010,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742666196
    },
    {
        "content": "<p>(I think I addressed this with the message I sent a moment before yours)</p>",
        "id": 507474061,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742666230
    },
    {
        "content": "<p>(The kernel is happy to unfold irreducible definitions — it doesn't know about irreducibility.)</p>",
        "id": 507474597,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742666505
    },
    {
        "content": "<p>Okay, I think I get the picture. Is this an accurate depiction of definitional equality and what's going on here:</p>\n<ul>\n<li>There is a notion of definitional equality in Lean. It's not a transitive relation.</li>\n<li>There is a <em>procedure</em> that's part of the Lean language called \"definitional equality checking\". Definitional equality is pretty much just defined as \"equalities that are proved by this procedure\". It is implemented in the kernel.</li>\n<li>The <code>dsimp</code> tactic does particular unfoldings and reductions, and proves a strict subset of definitional equalities.</li>\n<li>The <code>change</code> tactic also does particular unfoldings and reductions, and proves a different strict subset of definitional equalities.</li>\n<li>While <code>dsimp</code> lets you specify which definitions to unfold, <code>change</code> lets you specify what the RHS of your definitional equality is shaped like, which lets you guide it in a different way. Both of them produce definitional equalities that are ultimately verified by \"definitional equality checking\" in the kernel.</li>\n</ul>\n<p>and, I'm not sure on this point: </p>\n<ul>\n<li>if all definitions were reducible, and we passed all definitions as arguments to <code>dsimp</code>, then <code>change</code> and <code>dsimp</code> would be a complete implementation of definitional equality checking? Or no?</li>\n</ul>",
        "id": 507475229,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742666854
    },
    {
        "content": "<p>I might have written the first two bullet points wrong, maybe it's:</p>\n<ul>\n<li>There is a <em>procedure</em> that's part of the Lean language called \"definitional equality checking\". It is implemented in the kernel.</li>\n<li>The transitive closure of definitional equality checks forms the definitional equality relation.</li>\n</ul>\n<p>I'm unsure because definitely some places in the Lean language docs describe defeq as transitive, and some them do not.</p>",
        "id": 507475858,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742667231
    },
    {
        "content": "<p>Sorry, there are some inaccuracies here.</p>\n<ul>\n<li>The elaborator and kernel each have their own definitional equality checking.</li>\n<li>The kernel's is purely for checking whether two expressions are definitionally equal.</li>\n<li>The elaborator's does unification too. It tries to solve for metavariables. It assigns values to metavariables that are uniquely determined by definitional equality. For expressions without metavariables, the elaborator aims to match what the kernel does. However: the elaborator has a concept of definition transparency (reducible, semireducible, irreducible) that it respects, and it also has other configurations. More accurately, it aims to be at least as conservative as the kernel when deciding definitional equality.</li>\n<li>The <code>dsimp</code> procedure replaces parts of expressions with definitionally equal parts. It does not check definitional equality at all when doing this. It knows what should be definitionally equal to what. For example, replacing a constant with its definition is delta reduction, and it knows the kernel knows about this. It does not use the elaborator's definitional equality checker. Of course, everything is checked by the kernel in the end.</li>\n<li>The <code>change e</code> tactic elaborates <code>e</code> and then asks the elaborator's definitional equality checker to unify <code>e</code> with the expected type. The only special feature of <code>change</code> is that it does a couple of things to try to elaborate <code>e</code>. Other than that, it just uses the standard elaborator definitional equality unifier that most tactics use. (The <code>isDefEq</code> function.)</li>\n</ul>\n<p>The trickiest thing here is that you have metavariables. Definitional equality is not transitive, but it's <em>even more</em> not transitive when there are metavariables. I'm not sure unfolding every definition is enough to make it any better.</p>",
        "id": 507476556,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742667660
    },
    {
        "content": "<p>There are is one place where <code>dsimp</code> uses definitional equality checking: If <code>dsimp</code> reduces a goal to <code>LHS = RHS</code>, it checks <code>isDefEq LHS RHS</code>, and if that succeeds, it closes the goal with <code>Eq.refl</code>.</p>",
        "id": 507477131,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742668029
    },
    {
        "content": "<p>Thank you very much for the explanation! I think this clears thing up pretty well for me...</p>\n<p>So, <code>change</code> relies mostly on the <code>isDefEq</code> function, which is the elaborator definitional equality checker. And that function does a sort of best-effort attempt at unification+defeq in the same go.</p>\n<p>It has the important constraint that it can't produce things that are _not_ defeq-as-recognized-by-the-kernel, because then the kernel couldn't verify it. So when there aren't metavariables, it will pretty much just try to match the kernel exactly, because it's not allowed to do anything more, and so it might as well just match ther kernel.</p>\n<p>But when there are metavariables, <code>isDefEq</code> has some flexibility, and this is where the best-effort part comes in. In this case above, it made an executive decision to unfold <code>Finset.sum</code> before unfolding a projection, which is why it had gotten stuck. This kind of decision is something that could, presumably, be changed in a minor-version update to the Lean language? Without touching the kernel or anything, I mean.</p>",
        "id": 507477524,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742668288
    },
    {
        "content": "<p>If that's accurate, could I suggest that the error message from <code>change</code> change from it's current</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">'</span><span class=\"n\">change'</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pattern</span>\n<span class=\"w\">  </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">353</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">354</span>\n<span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">definitionally</span><span class=\"w\"> </span><span class=\"n\">equal</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">target</span>\n<span class=\"w\">  </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n</code></pre></div>\n<p>to something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">'</span><span class=\"n\">change'</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">unable</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">fill</span><span class=\"w\"> </span><span class=\"n\">metavariables</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">pattern</span>\n<span class=\"w\">  </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">353</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">354</span>\n<span class=\"n\">so</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">definitionally</span><span class=\"w\"> </span><span class=\"n\">equal</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">target</span>\n<span class=\"w\">  </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n</code></pre></div>\n<p>?</p>\n<p>I guess, leaving the message unchanged (<code>is not definitionally equal</code>) if there are no metavariables to unify. You could say this is a minor quibble, but it left me very confused here as you can see.</p>",
        "id": 507477785,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742668467
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/270676-lean4/topic/.60change.60.20and.20.60dsimp.60.20confusing.20behavior/near/507477524\">said</a>:</p>\n<blockquote>\n<p>This kind of decision is something that could, presumably, be changed</p>\n</blockquote>\n<p>It can be changed, but only if we understand the issue completely and can come up with a better heuristic that can be proved to work. Every change to these heuristics helps some things and hurts others.</p>",
        "id": 507478052,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742668624
    },
    {
        "content": "<p>Right, for sure, I would expect it to break a ton of stuff. I'm not asking for it to be changed, just sort of confirming my understanding of how these layers are separated</p>",
        "id": 507478097,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742668669
    },
    {
        "content": "<p>Also, and maybe this is kind of orthogonal, the Lean Language reference <a href=\"https://lean-lang.org/doc/reference/latest//The-Type-System/#--tech-term-definitional-equality\">says that</a> that definitional equality is \"a congruence.\" Every definition of \"congruence\" I can find says that it must be transitive.</p>\n<p>Unless there it means \"the transitive closure of definitional equality\". Really, I feel as though maybe there should be two separate terms X and Y, where X means \"the notion of definitional equality checked by the kernel\", and Y means \"the transitive closure of X\"? Because I think people use <code>defeq</code> to mean both?</p>",
        "id": 507478157,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742668692
    },
    {
        "content": "<p>Clarification about best effort: yes, it makes a best effort, but it doesn't approximate. For example, if it sees <code>f ?m1 =?= f x</code>, it won't assign <code>?m1 := x</code> unless it can know for sure that the definition of <code>f</code> requires this. There are some approximation modes that can be enabled in the elaborator. The <code>apply</code> tactic uses it for approximate higher-order unification, which normally fails.</p>",
        "id": 507478266,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742668786
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/270676-lean4/topic/.60change.60.20and.20.60dsimp.60.20confusing.20behavior/near/507477524\">said</a>:</p>\n<blockquote>\n<p>So when there aren't metavariables, it will pretty much just try to match the kernel exactly</p>\n</blockquote>\n<p>No, it's an important point that the elaborator has definitional transparency — the elaborator will say things aren't defeq even if the kernel says they are. The aim is for the opposite to never happen; that'd be a bug.</p>",
        "id": 507478429,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742668885
    },
    {
        "content": "<p>Oh, right, yeah</p>",
        "id": 507478467,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742668914
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/270676-lean4/topic/.60change.60.20and.20.60dsimp.60.20confusing.20behavior/near/507478157\">said</a>:</p>\n<blockquote>\n<p>Also, and maybe this is kind of orthogonal, the Lean Language reference <a href=\"https://lean-lang.org/doc/reference/latest//The-Type-System/#--tech-term-definitional-equality\">says that</a> that definitional equality is \"a congruence.\" Every definition of \"congruence\" I can find says that it must be transitive.</p>\n<p>Unless there it means \"the transitive closure of definitional equality\". Really, I feel as though maybe there should be two separate terms X and Y, where X means \"the notion of definitional equality checked by the kernel\", and Y means \"the transitive closure of X\"? Because I think people use <code>defeq</code> to mean both?</p>\n</blockquote>\n<p>i think people usually don't differentiate between <code>defeq</code> and its transitive closure because (afaik) in most cases you come across, the algorithms checks <em>are</em> transitive</p>",
        "id": 507478607,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1742668996
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/270676-lean4/topic/.60change.60.20and.20.60dsimp.60.20confusing.20behavior/near/507478157\">said</a>:</p>\n<blockquote>\n<p>the Lean Language reference <a href=\"https://lean-lang.org/doc/reference/latest//The-Type-System/#--tech-term-definitional-equality\">says that</a> that definitional equality is \"a congruence.\"</p>\n</blockquote>\n<p>I'm not sure what it means for a relation to be a congruence...</p>",
        "id": 507478628,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742669016
    },
    {
        "content": "<p>I've interpreted it as another way to say equivalence relation. (For example see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddCon#doc\">docs#AddCon</a>)</p>",
        "id": 507478733,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742669080
    },
    {
        "content": "<p>Mario's thesis <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> distinguishes between the defeq algorithm and the transitive closure of the algorithm.</p>",
        "id": 507478800,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742669125
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> I've never seen 'congruence' used this way — is your interpretation more than an educated guess?</p>",
        "id": 507478854,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742669161
    },
    {
        "content": "<p>In that example, the key thing is that it's a relation that \"distributes\" over an operation. That makes sense as a meaning for 'congruence'</p>",
        "id": 507479002,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742669239
    },
    {
        "content": "<p>The <a href=\"https://en.wikipedia.org/wiki/Congruence_relation\">wikipedia article</a> says it's an equivalence relation (that somehow is generally compatible with other operations).</p>\n<p>ETA: <a href=\"https://ncatlab.org/nlab/show/congruence\">ncatlab</a> also says equivalence relation</p>",
        "id": 507479046,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742669277
    },
    {
        "content": "<p>In the context of Lean, I would interpret that as meaning, like, if A ~ B and C ~ D, and A is a function that accepts C and B is a function that accepts D, then <code>A C</code> ~ <code>B D</code>. As one example of an operation to respect. And so on, for any way to create expressions</p>",
        "id": 507479156,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742669329
    },
    {
        "content": "<p>For example, if <code>x =?= x'</code> and <code>y =?= y</code>, then <code>f x y =?= f x' y'</code> is true for defeq. (Or at least should be. Maybe the algorithm might fail still, I don't know...)</p>\n<p>However, as we know, defeq is not transitive. Maybe there's another convention that doesn't require a full equivalence relation?</p>",
        "id": 507479170,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742669339
    },
    {
        "content": "<p>You wouldn't say \"reflexive, symmetric, and a congruence\" if \"congruence\" implies it's an equivalence relation, since the first two would be implied.</p>",
        "id": 507479320,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742669428
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"354934\">@David Thrane Christiansen</span> Question about <a href=\"https://lean-lang.org/doc/reference/latest//The-Type-System/#--tech-term-definitional-equality\">this section</a>, specifically saying that defeq is \"reflexive, symmetric, and a congruence.\" Did you mean for this to imply that defeq was transitive? A number of readers are getting this impression.)</p>",
        "id": 507479438,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742669511
    },
    {
        "content": "<p>A bit of google and checking my favorite model theory textbooks suggests there isn't really an established term for that, and further reinforces my impression that \"congruence\" implies an equivalence relation. By my gut before hand, I would have suggested just calling it \"compatible with function application\". During my Google I found a similar use, <a href=\"https://imi.kyushu-u.ac.jp/~daniel/model-theory/slides/mt3.pdf\">here</a>, that identifies the relevant property as \"compatible with the function symbols \\Sigma\".</p>",
        "id": 507479913,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742669785
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/.60change.60.20and.20.60dsimp.60.20confusing.20behavior/near/507478800\">said</a>:</p>\n<blockquote>\n<p>Mario's thesis <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> distinguishes between the defeq algorithm and the transitive closure of the algorithm.</p>\n</blockquote>\n<p>Afaict he distinguishes the defeq algorithm from an idealized, mathematically natural notion of defeq. Is it true that the latter is the transitive closure of the former? At least it doesn't seem to be stated there. Maybe <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> can weigh in?</p>",
        "id": 507480716,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742670291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/.60change.60.20and.20.60dsimp.60.20confusing.20behavior/near/507473596\">said</a>:</p>\n<blockquote>\n<p>My guess with why changing Real to Rat everywhere seems to fix this is that it unfolds <code>Rat.add</code> (<code>Real.add</code> is irreducible) and it eventually manages to see how things line up. That's very deep unfolding, and it's not something we'd want anything to rely on.</p>\n</blockquote>\n<p><code>Rat.add</code> is also irreducible</p>",
        "id": 507480931,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742670429
    },
    {
        "content": "<p>In that thesis (and in most of my informal discussion of LeanTT),  I use the term \"defeq\" to refer to the thing that is transitive and not decidable</p>",
        "id": 507481403,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742670768
    },
    {
        "content": "<p>the kernel computes an underapproximation of defeq</p>",
        "id": 507481416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742670785
    },
    {
        "content": "<blockquote>\n<p>Is it true that the latter is the transitive closure of the former?</p>\n</blockquote>\n<p>Yes</p>",
        "id": 507481521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742670849
    },
    {
        "content": "<p>I think it's not completely obvious, but it follows from some of the stronger theorems in <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a></p>",
        "id": 507481571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742670900
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/.60change.60.20and.20.60dsimp.60.20confusing.20behavior/near/507480931\">said</a>:</p>\n<blockquote>\n<p><code>Rat.add</code> is also irreducible</p>\n</blockquote>\n<p>Looking at the traces, it seems it actually comes down to <code>Real.instLE</code> being irreducible and <code>Rat.instLE</code> not. In the <code>Rat</code> case it actually unfolds it into</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>spoiled unfolding</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>if (∑ i ∈ Finset.range 1, 7 ^ i).num = 0 then decide (0 &lt; r.num)\n              else\n                if (decide (0 &lt; (∑ i ∈ Finset.range 1, 7 ^ i).num) &amp;&amp; decide (r.num ≤ 0)) = true then false\n                else\n                  decide\n                    ((∑ i ∈ Finset.range 1, 7 ^ i).num * ↑r.den &lt;\n                      r.num *\n                        ↑(∑ i ∈ Finset.range 1,\n                              7 ^\n                                i).den) =?= if fooQ.2.num = 0 then decide (0 &lt; r.num)\n              else\n                if (decide (0 &lt; fooQ.2.num) &amp;&amp; decide (r.num ≤ 0)) = true then false\n                else decide (fooQ.2.num * ↑r.den &lt; r.num * ↑fooQ.2.den)\n</code></pre></div>\n</div></div>\n<p>but in the Real case it gets stuck at <code>Real.le✝</code>.</p>",
        "id": 507482448,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742671347
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/.60change.60.20and.20.60dsimp.60.20confusing.20behavior/near/507479438\">said</a>:</p>\n<blockquote>\n<p>(<span class=\"user-mention silent\" data-user-id=\"354934\">David Thrane Christiansen</span> Question about <a href=\"https://lean-lang.org/doc/reference/latest//The-Type-System/#--tech-term-definitional-equality\">this section</a>, specifically saying that defeq is \"reflexive, symmetric, and a congruence.\" Did you mean for this to imply that defeq was transitive? A number of readers are getting this impression.)</p>\n</blockquote>\n<p>That was certainly not intended. I'll rephrase it!</p>",
        "id": 507740552,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1742818164
    },
    {
        "content": "<p>The rephrased version is now up - please let me know if it's still confusing!</p>",
        "id": 507878430,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1742851242
    }
]