[
    {
        "content": "<p>What I find remarkable in Lean4 is that when a recursive function is written, some proof of termination is required. In this sense, the programmer is required to have a code terminate in order to have it compile! In this way, does Lean 4 avoid the Halting Problem alltogether or is there any false claims above?</p>",
        "id": 421237991,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1707828843
    },
    {
        "content": "<p>Almost: <em>You</em> have to prove the halting problem. At least if you want to be able to write <em>any</em> terminating function :-)</p>",
        "id": 421238189,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1707828907
    },
    {
        "content": "<p>You can also get around this restriction by using a <code>partial def</code>which is still sound in the type theory due to the tricks involved but can be a non terminating function internally.</p>",
        "id": 421239261,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1707829269
    },
    {
        "content": "<p>Interesting. Another question that comes to mind is whether any termination is provable, or if the proof system will not accept any proof for some programs that arguably terminate. In any sense, the little extent of which i l loooked at termination_by and decreasing_by arguably cover only some \"happy cases\" which have simpler termination proofs</p>",
        "id": 421240862,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1707829891
    },
    {
        "content": "<p>I expect that there are terminating programs for which no proof of termination can be expressed within lean. Maybe Gödel can tell us more.</p>",
        "id": 421242380,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1707830500
    },
    {
        "content": "<p>I think there's some also fundamental limitations to what can be proved to be terminating in Lean, iirc</p>",
        "id": 421243567,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1707830899
    },
    {
        "content": "<p>There's a chance that the Collatz conjecture is true but not provable -- Conway proved that a certain generalisation had this property. So this would give us a function which is impossible to define without sorries or <code>partial</code> / <code>unsafe</code>.</p>",
        "id": 421245185,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707831479
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/Lean.204.20solves.20the.20Halting.20Problem.20.28.3F.29/near/421242380\">said</a>:</p>\n<blockquote>\n<p>I expect that there are terminating programs for which no proof of termination can be expressed within lean. Maybe Gödel can tell us more.</p>\n</blockquote>\n<p>The classic example is the lean typechecker, but that doesn't really work since the typechecker actually doesn't halt under some circumstances. I think the Coq typechecker would work as an example here (i.e. Lean can't prove that the Coq typechecker halts, even though it is believed to halt with suitable large cardinal assumptions)</p>",
        "id": 421245396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707831546
    },
    {
        "content": "<p>However lean's termination checker is \"complete\" in the sense that if you can prove a function terminates, then you can prove it in a <code>termination_by</code> statement</p>",
        "id": 421246769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707832052
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/Lean.204.20solves.20the.20Halting.20Problem.20.28.3F.29/near/421242380\">said</a>:</p>\n<blockquote>\n<p>I expect that there are terminating programs for which no proof of termination can be expressed within lean. Maybe Gödel can tell us more.</p>\n</blockquote>\n<p>You can't enumerate a set of programs which cover all total computable functions from Nat to Nat (follows from Rice's theorem) but you can enumerate all provably terminating functions in Lean from Nat to Nat (just go through all Lean files and all amounts of time you are willing to wait for the type checker) so there must be total functions which terminate but Lean can't prove.  (Also, it isn't hard to see that terminating is the only issue.  <code>partial def</code> is Turing complete in that you can express all partial computable functions from Nat to Nat.)</p>",
        "id": 421284567,
        "sender_full_name": "Jason Rute",
        "timestamp": 1707842907
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/Lean.204.20solves.20the.20Halting.20Problem.20.28.3F.29/near/421245185\">said</a>:</p>\n<blockquote>\n<p>There's a chance that the Collatz conjecture is true but not provable</p>\n</blockquote>\n<p>True in the standard model of natural numbers but unprovable in Peano arithmetic?</p>",
        "id": 421299780,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1707848387
    },
    {
        "content": "<p>It looks like the termination of any turing machine can be converted to asking whether or not some generalized Collatz function reaches 1 on a specific input, so Collatz could theoretically be independent of ZFC.</p>",
        "id": 421310565,
        "sender_full_name": "Nir Paz",
        "timestamp": 1707852192
    },
    {
        "content": "<p>ZF+C+CH+CC (collatz conjecture)</p>",
        "id": 421335841,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707863241
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"565854\">Nir Paz</span> <a href=\"#narrow/stream/270676-lean4/topic/Lean.204.20solves.20the.20Halting.20Problem.20.28.3F.29/near/421310565\">said</a>:</p>\n<blockquote>\n<p>It looks like the termination of any turing machine can be converted to asking whether or not some generalized Collatz function reaches 1 on a specific input, so Collatz could theoretically be independent of ZFC.</p>\n</blockquote>\n<p>Do you have details on this? I haven't heard of \"generalized Collatz\" being turing complete</p>",
        "id": 421369846,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707885876
    },
    {
        "content": "<p>(depending on how much you want to generalize...)</p>",
        "id": 421369886,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707885912
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/FRACTRAN\">FRACTRAN</a> is the most similar turing complete language I'm aware of</p>",
        "id": 421369922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707885940
    },
    {
        "content": "<p>By a generalized Collatz function I mean a function <code>g(n)=n⬝a_(n mod p)+b_(n mod p)</code> where  <code>aᵢ, bᵢ</code> are rationals chosen so that the output is always an integer (the usual function is <code>p=2, a₀=0.5, a₁=3, b₁=1</code>). But for the undecidability we can even let the <code>b</code>'s be <code>0</code>.</p>\n<p>I found the original paper referenced on wikipedia (Unpredictable Iterations, Conway 1972) in a book and went over it, and the proof basically shows that if <code>g</code> is the \"next step function\" of a fractran program, then it's also a collatz function. The proof is surprisingly simple, so modulo the undecidability of fractran it's very short:</p>\n<p>If <code>a₁ / b₁,..., aₙ / bₙ</code> are the rational numbers describing a fractran program, define <code>g(n) = n ⬝ aᵢ / bᵢ</code> for the minimal <code>i</code> such that this is an integer. The completeness of fractran says that the termination of <code>g</code> on a particular input is undecidable (I think?).</p>\n<p>Now look at <code>g(n) / n</code>. This function is periodic, with period some divisor of the lcd of all denominators on the list (I don't see why this is true, but it sounds like pretty simple number theory). So if we name the period <code>P</code>, we get that <code>g(Pk+r)/(Pk+r)=g(r)/r</code>, or <code>g(Pk+r)=g(r)/r⬝(Pk+r)</code>. So <code>g</code> is actually a generalized collatz function!</p>",
        "id": 421496540,
        "sender_full_name": "Nir Paz",
        "timestamp": 1707931844
    },
    {
        "content": "<p>Well I just realized this just shows the undecidability of the question of, given a finite list of rationals, whether a Collatz function reaches a value that doesn't multiply to an integer with of them is, rather than whether it reaches <code>1</code>. If someone is interested they can go look at the paper, it's a bit too much for me.</p>",
        "id": 421497998,
        "sender_full_name": "Nir Paz",
        "timestamp": 1707932378
    },
    {
        "content": "<p>I have a newbie question about the halting problem:</p>\n<p>I came across <a href=\"http://www.cs.toronto.edu/~hehner/halting.html\">Univ of Toronto's CS prof Eric Hehner's views on the halting problem</a>. He argues that the Halting problem is not a limitation of computability but an inconsistency of specification.</p>\n<p>His views have been <a href=\"https://link.springer.com/chapter/10.1007/978-3-642-16690-7_11\">challenged</a>. Some even <a href=\"http://recursed.blogspot.com/2013/10/eric-hehner-replies.html\">called him a crank</a>.<br>\nOthers have <a href=\"https://arxiv.org/abs/1501.03018\">found some support</a> for his claims.</p>\n<p>Can Lean be used to shed light on and settle this argument? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 454731226,
        "sender_full_name": "Nilesh",
        "timestamp": 1722233257
    },
    {
        "content": "<p>I'd certainly say so, although I do think his views are Definitely wrong.</p>",
        "id": 454740085,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1722236547
    },
    {
        "content": "<p>Or at least those expressed in the video of his homepage</p>",
        "id": 454740178,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1722236583
    },
    {
        "content": "<p>When reading <a href=\"https://www.cs.utoronto.ca/~hehner/RHP.pdf\">https://www.cs.utoronto.ca/~hehner/RHP.pdf</a>, on page 2 it's very wrong to say that D is \"completely innocent\". The issue is that D is referring to H. How is this H resolved? There's no assumption about computability of H, so the function H has no textual program that can be pasted in at that position. This is the moment where the usual assumption that H is computable is tacitly assumed.</p>\n<p>If somehow it's up to H to be able to resolve the primitive H to its own specification, then, yes, that would be an inconsistent specification, and that's sort of the point of the halting problem.</p>",
        "id": 454748600,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1722238790
    },
    {
        "content": "<p>indeed, i found it hard to understand what to interpret \"inconsistent specification\" as, other than \"there is no program that fits these specifications\", which is precisely the point.</p>",
        "id": 454751300,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1722239498
    },
    {
        "content": "<p>\"Specification\" is referring to an axiomatic description of the function H, and \"inconsistent specification\" means the set of functions satisfying that description is empty. That part is fine I think — it's pure functions rather than programs that implement the functions.</p>",
        "id": 454751591,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1722239569
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"565854\">Nir Paz</span> <a href=\"#narrow/stream/270676-lean4/topic/Lean.204.20solves.20the.20Halting.20Problem.20.28.3F.29/near/421310565\">said</a>:</p>\n<blockquote>\n<p>It looks like the termination of any turing machine can be converted to asking whether or not some generalized Collatz function reaches 1 on a specific input, so Collatz could theoretically be independent of ZFC.</p>\n</blockquote>\n<p>Since this thread was revived: I'm pretty sure this is wrong. It can't be independent of ZFC. That would mean that there is a model of ZFC where iterating your function f on the input n reaches 1 after some number of steps k. And if that's true, then you have a proof of that by just directly evaluating that, so it doesn't use any extra axioms; so it would be true in any model of ZFC.</p>\n<p>In general, any \"computationally verifiable\" (or computationally falsifiable) statement like this can't be independent of ZFC. So the same goes for the Goldbach conjecture, Riemann hypothesis, P=NP... etc.</p>\n<p>Now, these problems might be <em>unprovable</em> in ZFC. And generalized Collatz problems are indeed unprovable in ZFC. That is: there is a generalized Collatz function f which always reaches 1 on any input, but this is unprovable; you get this by encoding \"Does input x constitute a valid disproof of the consistency of ZFC\" into f, and having f go to infinity if it finds an inconsistency.</p>\n<p>But being logically independent vs being unprovable are very different, and somehow end up conflated with one another very frequently!</p>",
        "id": 454774534,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1722245161
    },
    {
        "content": "<p>To be clear on definitions, when I say \"independent of ZFC\" I mean \"cannot be proven from ZFC\", or equivalently (by the completeness theorem) \"is true in some model of ZFC and false in some other\".</p>\n<p>Statements like Collatz can be independent even if true because even if for every natural <code>n</code>, that is a number of the form <code>1+1+...+1</code>, you have a proof that it terminates on Collatz, and thus is terminates in every model of ZFC, that does not mean that every model satisfies \"for every natural <code>n</code>, Collatz terminates on <code>n</code>\". Some models of ZFC have nonstandard natural numbers not of the form <code>1+1+...+1</code>, and those might not terminate.<br>\nThese nonstandard naturals are actually never computable, so you couldn't have a proof of the form \"just run Collatz manually\" even for specific nonstandards.</p>\n<p>So <code>∀ n ∈ ℕ, ∀ M : ZFC, M ⊧ n terminates</code> does not imply <code>∀ M : ZFC, M ⊧ ∀ n ∈ ℕ, n terminates</code>, because different models have different ℕ. And when we write <code>M ⊧ n terminates</code> we're abbreviating the statement <code>M ⊧ 1 + 1 + ... + 1 terminates</code>, but not all of the naturals of <code>M</code> can be written like this, only the standard ones.</p>",
        "id": 454780007,
        "sender_full_name": "Nir Paz",
        "timestamp": 1722246739
    }
]