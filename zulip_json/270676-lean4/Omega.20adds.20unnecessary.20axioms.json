[
    {
        "content": "<p>I was trying to define real numbers in lean</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Rat.abs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">num</span><span class=\"o\">:=</span><span class=\"n\">a.num.natAbs</span><span class=\"o\">,</span><span class=\"n\">den</span><span class=\"o\">:=</span><span class=\"n\">a.den</span><span class=\"o\">,</span><span class=\"n\">den_nz</span><span class=\"o\">:=</span><span class=\"n\">a.den_nz</span><span class=\"o\">,</span><span class=\"n\">reduced</span><span class=\"o\">:=</span><span class=\"n\">a.reduced</span><span class=\"o\">}</span>\n\n<span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kd\">notation</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"s2\">\"⁻¹\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Rat.inv</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Rat</span>\n<span class=\"w\">  </span><span class=\"n\">reg</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">⁻¹</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">⁻¹</span>\n</code></pre></div>\n<p>then I found out my definition depends on <code>Classical.choice</code>.<br>\nI traced down the problem and finally found out that some theorems in Lean are proved by omega tactic, which adds unnecessary axioms!<br>\nOne of those theorems is <code>Nat.add_eq_right</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- 'Nat.add_eq_right' depends on axioms: [propext, Classical.choice, Quot.sound]</span>\n<span class=\"k\">#print</span><span class=\"w\"> </span><span class=\"kd\">axioms</span><span class=\"w\"> </span><span class=\"n\">Nat.add_eq_right</span>\n\n<span class=\"c1\">-- 'add_eq_right' depends on axioms: [propext]</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">add_eq_right</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">rewrite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">occs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat.zero_add</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Eq.symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat.add_right_cancel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Eq.symm</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)))</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat.zero_add</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"c1\">-- 'add_eq_right0' depends on axioms: [propext, Quot.sound]</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">add_eq_right0</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span><span class=\"bp\">;</span><span class=\"n\">omega</span><span class=\"bp\">;</span><span class=\"n\">omega</span>\n</code></pre></div>\n<p>As you can see , this theorem could be easily proved without <code>Classical.choice</code>(and even <code>Quot.sound</code>). I guess the omega tactic had an option called <code>useClassical</code> but couldn't find this option in lean 4.20. Anyways, IMO, there are two ways to solve this problem: <br>\n1- Change the code of the omega tactic <br>\n2- Write the proofs in Lean without omega (or at least use a constructor tactic before the omega to avoid <code>Classical.choice</code>)<br>\nShould I create an issue for this?</p>",
        "id": 526187554,
        "sender_full_name": "Arshak Parsa",
        "timestamp": 1751097946
    },
    {
        "content": "<p>This is not considered a problem by the core team of Lean, there have been previous attempts at reducing the axioms used by proofs in core and the answer is usually that it's not worth the time to make sure certain parts of the library stay axiom free or to change certain tactics such that they do not use some axiom.</p>",
        "id": 526187829,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1751098334
    },
    {
        "content": "<p>I'll note that while the number of people who care about avoiding the use of <code>Classical.choice</code> in a proof is rather small, I suspect that a far smaller group care about <code>propext</code> or <code>Quot.sound</code></p>",
        "id": 526192483,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1751103769
    }
]