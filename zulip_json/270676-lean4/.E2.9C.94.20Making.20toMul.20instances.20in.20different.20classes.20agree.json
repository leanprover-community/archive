[
    {
        "content": "<p>I am trying to prove that my definition of Groups is equivalent to the one in mathlib as an excercise. However,  <code>canonical_comm_group_matches</code> does not compile.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Group.Defs</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Group.MinimalAxioms</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">NapkinGroup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Mul</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">Inv</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">One</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">MulOneClass</span> <span class=\"n\">G</span> <span class=\"n\">where</span>\n  <span class=\"kn\">protected</span> <span class=\"n\">mul_assoc</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"kn\">protected</span> <span class=\"n\">mul_left_inv</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">NapkinAbelianGroup</span> <span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">NapkinGroup</span> <span class=\"n\">G</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul_comm</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">canonical_group_matches</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">NapkinGroup</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">MulOneClass.one_mul</span><span class=\"o\">,</span> <span class=\"n\">MulOneClass.mul_one</span><span class=\"o\">,</span> <span class=\"n\">Semigroup.mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">Group.mul_left_inv</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">canonical_comm_group_matches</span> <span class=\"o\">[</span><span class=\"n\">CommGroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">NapkinAbelianGroup</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">NapkinGroup</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">canonical_group_matches</span> <span class=\"n\">G</span>\n  <span class=\"n\">apply</span> <span class=\"n\">NapkinAbelianGroup.mk</span> <span class=\"o\">(</span><span class=\"n\">CommSemigroup.mul_comm</span> <span class=\"bp\">·</span> <span class=\"bp\">·</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The main problem here is that <code>CommSemigroup.mul_comm</code> uses <code>Semigroup.toMul</code>, but <code>NapkinAbelianGroup G</code> above wants it to use <code>NapkinGroup.toMul</code>. Since they are <code>extend</code>ed separately in <code>NapkinGroup</code> and <code>Semigroup</code>, I don't know of a way to make the two <code>toMul</code> instances agree. How would I go about proving this?</p>",
        "id": 403183651,
        "sender_full_name": "SaNoy SaKnoi",
        "timestamp": 1700491094
    },
    {
        "content": "<p><code>theorem</code> and <code>have</code> forget the data they are given, they just record existence of something. Could you try with <code>def</code> and <code>let</code> instead, that remember the data?</p>",
        "id": 403185536,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1700491663
    },
    {
        "content": "<p>Making the <code>canonical_group_matches</code> a <code>theorem</code> and <code>k</code> <code>let</code> worked, thank you!</p>\n<p>For future reference, the difference between the different keywords:<br>\nFrom <a href=\"https://proofassistants.stackexchange.com/questions/1575/what-are-the-differences-between-theorem-example-def-etc\">https://proofassistants.stackexchange.com/questions/1575/what-are-the-differences-between-theorem-example-def-etc</a>:</p>\n<blockquote>\n<p>A <code>def</code> is the primary way to define a named function / value in Lean.<br>\nA <code>theorem</code> is essentially a <code>noncomputable def</code>.</p>\n</blockquote>\n<p>From <a href=\"https://lean-lang.org/theorem_proving_in_lean4/tactics.html\">https://lean-lang.org/theorem_proving_in_lean4/tactics.html</a>:</p>\n<blockquote>\n<p>The difference between <code>let</code> and <code>have</code> is that let introduces a local definition in the context, so that the definition of the local declaration can be unfolded in the proof.</p>\n</blockquote>",
        "id": 403191933,
        "sender_full_name": "SaNoy SaKnoi",
        "timestamp": 1700493525
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"667038\">SaNoy SaKnoi</span> has marked this topic as resolved.</p>",
        "id": 403192008,
        "sender_full_name": "Notification Bot",
        "timestamp": 1700493548
    }
]