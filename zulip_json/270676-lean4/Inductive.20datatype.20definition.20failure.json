[
    {
        "content": "<p>Hi, I'm trying to port some existing work from agda by someone else, as an exercise. I'm currently bumping into an issue with an inductive datatype definition that I believe should pass but does not (maybe I'm wrong?). It can be boiled down to this following example, where Foo1 and Foo2 pass, but Foo3 does not.    </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo1</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">bar1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">Foo1</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">×</span> <span class=\"n\">Foo1</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Foo1</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Foo2</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">bar2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">Foo2</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">×</span> <span class=\"n\">Foo2</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Foo2</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"c1\">-- The following fails with:</span>\n<span class=\"c1\">-- (kernel) invalid nested inductive datatype 'Prod', nested inductive datatypes parameters cannot contain local variables.</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Foo3</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">bar3</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">Foo3</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"bp\">×</span> <span class=\"n\">Foo3</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Foo3</span> <span class=\"n\">a</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>Perhaps I am doing something trivially wrong and should not expect this to be accepted?</p>\n<p>I posted an <a href=\"https://github.com/leanprover/lean4/issues/1964\">issue</a></p>",
        "id": 357348015,
        "sender_full_name": "bblaxill",
        "timestamp": 1683735926
    },
    {
        "content": "<p>why do you need this to be a product? if you write it as an arrow it seems to work (i.e. this works for me):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo3</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">bar3</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"n\">Foo3</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Foo3</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Foo3</span> <span class=\"n\">a</span> <span class=\"n\">c</span>\n</code></pre></div>",
        "id": 357419116,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1683760104
    },
    {
        "content": "<p>Unpacking is not possible in my real use case, the type is completely abstract.<br>\nHere is an example closer to my use case </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">implication</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">P</span> <span class=\"o\">,</span> <span class=\"n\">Q</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span> <span class=\"n\">x</span>\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\" ⇒ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">implication</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Ty</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">unit</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span>\n<span class=\"bp\">|</span> <span class=\"n\">lollipop</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Ty</span>\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\" ⊸ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Ty.lollipop</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ternaryRelate</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Ty</span><span class=\"o\">):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">++</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">a</span> <span class=\"s2\">\" • \"</span> <span class=\"n\">b</span> <span class=\"s2\">\" ≃ \"</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ternaryRelate</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">ProofRelevantSeparation</span>\n    <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Ty</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">al</span> <span class=\"o\">:</span> <span class=\"n\">A</span>\n  <span class=\"n\">ar</span> <span class=\"o\">:</span> <span class=\"n\">A</span>\n  <span class=\"n\">px</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">a</span>\n  <span class=\"n\">qx</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">a</span>\n  <span class=\"n\">proof</span> <span class=\"o\">:</span> <span class=\"n\">al</span> <span class=\"bp\">•</span> <span class=\"n\">ar</span> <span class=\"bp\">≃</span> <span class=\"n\">a</span>\n<span class=\"kd\">notation</span> <span class=\"n\">a</span> <span class=\"s2\">\" ★ \"</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ProofRelevantSeparation</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"c1\">-- The following fails with:</span>\n<span class=\"c1\">-- (kernel) invalid nested inductive datatype 'ProofRelevantSeparation', nested inductive datatypes parameters cannot contain local variables.</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Exp</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">List</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">Exp</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⊸</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">★</span> <span class=\"n\">Exp</span> <span class=\"n\">a</span> <span class=\"bp\">⇒</span> <span class=\"n\">Exp</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Exp</span> <span class=\"n\">b</span> <span class=\"n\">ctx</span>\n</code></pre></div>\n<p>Here <code>ProofRelevantSeparation</code> is quantified over with 'x' and so cannot be unpacked (even if it could, my actual use case is more abstract)</p>",
        "id": 364889513,
        "sender_full_name": "bblaxill",
        "timestamp": 1686323869
    },
    {
        "content": "<p>Lean only accepts nested inductives if it is sufficiently concrete that it could be unfolded, and it does the unfolding behind the scenes because it needs to use it to generate the recursor. Using an abstract type is definitely not allowed, and is also inconsistent in some cases</p>",
        "id": 364909194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686327990
    },
    {
        "content": "<p>I think there is a typo in your definition, <code>A</code> in the types of <code>al</code> and <code>ar</code> is not defined, maybe you meant <code>List Ty</code>?</p>",
        "id": 364910424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686328280
    },
    {
        "content": "<p>Even after inlining everything, I get this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Exp</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Ty</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">al</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Ty</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">ar</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Ty</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">proof</span> <span class=\"o\">:</span> <span class=\"n\">al</span> <span class=\"bp\">•</span> <span class=\"n\">ar</span> <span class=\"bp\">≃</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">px</span> <span class=\"o\">:</span> <span class=\"n\">Exp</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⊸</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">qx</span> <span class=\"o\">:</span> <span class=\"n\">Exp</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">Exp</span> <span class=\"n\">b</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"n\">Exp</span> <span class=\"n\">b</span> <span class=\"n\">ctx</span>\n</code></pre></div>\n<p>which is also invalid because <code>Exp</code> is not used strictly positively</p>",
        "id": 364910913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686328396
    },
    {
        "content": "<p>Thanks for the response. </p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Inductive.20datatype.20definition.20failure/near/364910424\">said</a>:</p>\n<blockquote>\n<p>I think there is a typo in your definition, <code>A</code> in the types of <code>al</code> and <code>ar</code> is not defined, maybe you meant <code>List Ty</code>?</p>\n</blockquote>\n<p>Yes you are right that is a typo, but the error is the same.</p>",
        "id": 364911284,
        "sender_full_name": "bblaxill",
        "timestamp": 1686328487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Inductive.20datatype.20definition.20failure/near/364910913\">said</a>:</p>\n<blockquote>\n<p>Even after inlining everything, I get this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Exp</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Ty</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">al</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Ty</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">ar</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Ty</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">proof</span> <span class=\"o\">:</span> <span class=\"n\">al</span> <span class=\"bp\">•</span> <span class=\"n\">ar</span> <span class=\"bp\">≃</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">px</span> <span class=\"o\">:</span> <span class=\"n\">Exp</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⊸</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">qx</span> <span class=\"o\">:</span> <span class=\"n\">Exp</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">Exp</span> <span class=\"n\">b</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"n\">Exp</span> <span class=\"n\">b</span> <span class=\"n\">ctx</span>\n</code></pre></div>\n<p>which is also invalid because <code>Exp</code> is not used strictly positively</p>\n</blockquote>\n<p>Ah you're right, although perhaps a separate issue. I'm trying to port some Agda code, do you know if Agda has greater leniency regarding  nested inductives? I've seen Agda code being more lenient when constructing fixpoint of inductives even when they are not strictly positive.</p>",
        "id": 364913432,
        "sender_full_name": "bblaxill",
        "timestamp": 1686328992
    },
    {
        "content": "<p>Violating strict positivity is definitely a no-no. Currently you can prove that <code>Exp</code> is empty, but if you added enough constructors such that it could be proved to have at least two elements:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Exp</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Ty</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">px</span> <span class=\"o\">:</span> <span class=\"n\">Exp</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⊸</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">qx</span> <span class=\"o\">:</span> <span class=\"n\">Exp</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">Exp</span> <span class=\"n\">b</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"n\">Exp</span> <span class=\"n\">b</span> <span class=\"n\">ctx</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">Exp</span> <span class=\"n\">a</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">Exp</span> <span class=\"n\">a</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>you get something which is definitely inconsistent, because (T -&gt; T) injects into T</p>",
        "id": 364914742,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686329296
    },
    {
        "content": "<p>I'm not sure that inlining is correct, or perhaps my notation is incorrect. The <code>ProofRelevantSeparation</code> should be  on <code>Exp (a ⊸ b)</code> and <code>Exp a x</code> , <code>Exp b x</code> being after the implication arrow</p>",
        "id": 364916183,
        "sender_full_name": "bblaxill",
        "timestamp": 1686329620
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Logic.Function.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Classical</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">implication</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">P</span> <span class=\"o\">,</span> <span class=\"n\">Q</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span> <span class=\"n\">x</span>\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\" ⇒ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">implication</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Ty</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">unit</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span>\n<span class=\"bp\">|</span> <span class=\"n\">lollipop</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Ty</span>\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\" ⊸ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Ty.lollipop</span>\n\n<span class=\"n\">unsafe</span> <span class=\"kd\">inductive</span> <span class=\"n\">Exp</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Ty</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">px</span> <span class=\"o\">:</span> <span class=\"n\">Exp</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⊸</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">qx</span> <span class=\"o\">:</span> <span class=\"n\">Exp</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">Exp</span> <span class=\"n\">b</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"n\">Exp</span> <span class=\"n\">b</span> <span class=\"n\">ctx</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">Exp</span> <span class=\"n\">a</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">Exp</span> <span class=\"n\">a</span> <span class=\"n\">x</span>\n\n<span class=\"n\">unsafe</span> <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">classical</span>\n  <span class=\"k\">let</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Exp</span> <span class=\"n\">Ty.unit</span> <span class=\"o\">[]</span> <span class=\"bp\">→</span> <span class=\"n\">Exp</span> <span class=\"n\">Ty.unit</span> <span class=\"o\">[])</span> <span class=\"o\">:</span> <span class=\"n\">Exp</span> <span class=\"n\">Ty.unit</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">_</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"n\">f</span>\n  <span class=\"k\">have</span> <span class=\"n\">F_inj</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">F</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n  <span class=\"k\">let</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Exp</span> <span class=\"n\">Ty.unit</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">p</span> <span class=\"k\">then</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"k\">else</span> <span class=\"bp\">.</span><span class=\"n\">one</span>\n  <span class=\"k\">have</span> <span class=\"n\">G_inj</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">G</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp_all</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Function.cantor_injective</span> <span class=\"k\">fun</span> <span class=\"n\">P</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">∘</span> <span class=\"n\">P</span><span class=\"o\">)</span>\n  <span class=\"n\">intro</span> <span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">funext</span> <span class=\"n\">a</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">G_inj</span> <span class=\"o\">(</span><span class=\"n\">congrFun</span> <span class=\"o\">(</span><span class=\"n\">F_inj</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 364916473,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686329685
    },
    {
        "content": "<p>I'm fairly sure the inlining is correct, but it's possible there were issues in the original statement?</p>",
        "id": 364916856,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686329773
    },
    {
        "content": "<p>I think maybe you might have meant</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Exp</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">List</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">Exp</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⊸</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">★</span> <span class=\"n\">Exp</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Exp</span> <span class=\"n\">b</span> <span class=\"n\">ctx</span>\n</code></pre></div>\n<p>if the intent is to act like function application</p>",
        "id": 364917054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686329824
    },
    {
        "content": "<p>If I make that modification I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Exp</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Ty</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">al</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Ty</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">ar</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Ty</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">proof</span> <span class=\"o\">:</span> <span class=\"n\">al</span> <span class=\"bp\">•</span> <span class=\"n\">ar</span> <span class=\"bp\">≃</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">px</span> <span class=\"o\">:</span> <span class=\"n\">Exp</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⊸</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">qx</span> <span class=\"o\">:</span> <span class=\"n\">Exp</span> <span class=\"n\">a</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"n\">Exp</span> <span class=\"n\">b</span> <span class=\"n\">ctx</span>\n</code></pre></div>\n<p>for the inlined form, and this does satisfy strict positivity and is accepted by lean</p>",
        "id": 364917299,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686329892
    },
    {
        "content": "<p>(it still looks wrong because the <code>ctx</code> at the end is not used anywhere else, but possibly this is an artifact of minimizing)</p>",
        "id": 364917856,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686330047
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Inductive.20datatype.20definition.20failure/near/364917054\">said</a>:</p>\n<blockquote>\n<p>I think maybe you might have meant</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Exp</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">List</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">Exp</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⊸</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">★</span> <span class=\"n\">Exp</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Exp</span> <span class=\"n\">b</span> <span class=\"n\">ctx</span>\n</code></pre></div>\n<p>if the intent is to act like function application</p>\n</blockquote>\n<p>Thanks, I think you have solved my problem. My translation from the Agda was not correct.</p>\n<p>I'm curious about the original <code>Foo3</code> tuple example- I would have expected <code>Foo2</code> to also fail, but I admit I have no intuition for what is happening.</p>",
        "id": 364920401,
        "sender_full_name": "bblaxill",
        "timestamp": 1686330687
    },
    {
        "content": "<p>I'm guessing Foo3 should probably succeed, but the nested inductive compiler is a bit conservative there for simplicity.</p>",
        "id": 364948133,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1686337858
    },
    {
        "content": "<p>It's unfortunate that </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Exp</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">List</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">Exp</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⊸</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">★</span> <span class=\"n\">Exp</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Exp</span> <span class=\"n\">b</span> <span class=\"n\">ctx</span>\n</code></pre></div>\n<p>is not accepted but the inlined version is. If I learn how to extend the elaborator would it be possible to enable this without inlining for my specific case? Or perhaps it is not possible because the check is in the kernel and there is no way to enable this without inlining. It's a syntactic issue of course but I'd very much prefer to avoid extra (un)packing even if it requires me to do additional work with e.g. the elaborator. Thanks!</p>",
        "id": 365010479,
        "sender_full_name": "bblaxill",
        "timestamp": 1686367458
    },
    {
        "content": "<p>it is the latter, any extensions here have to be performed in the kernel and complicate any metatheory or soundness proofs for the system</p>",
        "id": 365011006,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686367745
    },
    {
        "content": "<p>also, have you thought about what the <code>Exp.rec</code> function would even look like?</p>",
        "id": 365011282,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686367893
    },
    {
        "content": "<p>I hadn't thought about it, but yes I can see there is an issue there. So is it correct to say Agda accepts these definitions because Agda pattern matching is a primitive of the language and doesnt elaborate pattern matching based on induction principles? I have come to theorem proving via non-academic route and am still trying to understand various fundamental concepts. thanks</p>",
        "id": 365094296,
        "sender_full_name": "bblaxill",
        "timestamp": 1686396841
    },
    {
        "content": "<p>I'm not sure I would say that is an intentional consequence of the design decision, but it is certainly easier to accidentally allow unsound things when you have no conservative core language and just check everything directly in the frontend</p>",
        "id": 365122625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686403857
    }
]