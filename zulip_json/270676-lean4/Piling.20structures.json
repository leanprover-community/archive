[
    {
        "content": "<p>When introducing a structure of type S that extends another structure of type S', if I already have a structure of type S', how do I tell Lean that I want to use it for the structure of type S ? Here is a toy example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">U</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">test1</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">arbitrary</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">𝕜</span><span class=\"o\">],</span> <span class=\"bp\">𝕜</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">arbitrary_nonzero</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">𝕜</span><span class=\"o\">],</span> <span class=\"n\">arbitrary</span> <span class=\"bp\">𝕜</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">test1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test2</span> <span class=\"o\">(</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">𝕜</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">𝕜</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">test1.arbitrary</span> <span class=\"n\">t</span> <span class=\"bp\">𝕜</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">test1.arbitrary</span> <span class=\"n\">t</span> <span class=\"bp\">𝕜</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">mul_eq_zero</span><span class=\"o\">]</span>\n  <span class=\"n\">push_neg</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">test1.arbitrary_nonzero</span> <span class=\"n\">t</span> <span class=\"bp\">𝕜</span> <span class=\"n\">p</span>    <span class=\"c1\">-- type mismatch</span>\n  <span class=\"bp\">.</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Full error message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">test1.arbitrary_nonzero</span> <span class=\"n\">t</span> <span class=\"bp\">𝕜</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">test1.arbitrary</span> <span class=\"n\">t</span> <span class=\"bp\">𝕜</span> <span class=\"bp\">≠</span>\n    <span class=\"bp\">@</span><span class=\"n\">OfNat.ofNat</span> <span class=\"bp\">𝕜</span> <span class=\"mi\">0</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Zero.toOfNat0</span> <span class=\"bp\">𝕜</span>\n        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ExteriorAlgebra.instZero</span> <span class=\"bp\">𝕜</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">NonUnitalNonAssocSemiring.toMulZeroClass</span> <span class=\"bp\">𝕜</span>\n            <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring</span> <span class=\"bp\">𝕜</span>\n              <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">NonAssocRing.toNonUnitalNonAssocRing</span> <span class=\"bp\">𝕜</span>\n                <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Ring.toNonAssocRing</span> <span class=\"bp\">𝕜</span>\n                  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">NormedRing.toRing</span> <span class=\"bp\">𝕜</span>\n                    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">NormedCommRing.toNormedRing</span> <span class=\"bp\">𝕜</span>\n                      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">NormedField.toNormedCommRing</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">NontriviallyNormedField.toNormedField</span> <span class=\"bp\">𝕜</span> <span class=\"n\">p</span><span class=\"o\">))))))))))</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">test1.arbitrary</span> <span class=\"n\">t</span> <span class=\"bp\">𝕜</span> <span class=\"bp\">≠</span>\n    <span class=\"bp\">@</span><span class=\"n\">OfNat.ofNat</span> <span class=\"bp\">𝕜</span> <span class=\"mi\">0</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Zero.toOfNat0</span> <span class=\"bp\">𝕜</span>\n        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">MulZeroClass.toZero</span> <span class=\"bp\">𝕜</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">NonUnitalNonAssocSemiring.toMulZeroClass</span> <span class=\"bp\">𝕜</span>\n            <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring</span> <span class=\"bp\">𝕜</span>\n              <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">NonAssocRing.toNonUnitalNonAssocRing</span> <span class=\"bp\">𝕜</span>\n                <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Ring.toNonAssocRing</span> <span class=\"bp\">𝕜</span>\n                  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">NormedRing.toRing</span> <span class=\"bp\">𝕜</span>\n                    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">NormedCommRing.toNormedRing</span> <span class=\"bp\">𝕜</span>\n                      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">NormedField.toNormedCommRing</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">NontriviallyNormedField.toNormedField</span> <span class=\"bp\">𝕜</span> <span class=\"n\">q</span><span class=\"o\">))))))))))</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>Here the variable <code>t</code> of type <code>test1</code> is supposed to pick a nonzero element in every nontrivially normed field. (Auxiliary question: is  putting instance arguments in the fields of a structure a Bad Idea ?)</p>\n<p>Then I am playing around with a type <code>𝕜</code> that has two structures of nontrivially normed field called <code>p</code> and <code>q</code>, and I want to prove that the product of the nonzero elements is nonzero. Of course this should not work, because I have not told Lean that the two underlying field structures are the same, and my problem is that I don't know how to do that; I mean, I can probably tell Lean that <code>p.toField = q.toField</code> or something like that, but it seems like it would force me to do a huge amount of rewrites later; much better if <code>p</code> and <code>q</code> were just known to extend the same <code>Field</code> structure on <code>𝕜</code>.<br>\nYou can see how I tried by putting a <code>Field</code> instance on <code>𝕜</code> first, but it didn't work and Lean is using the field structure coming from <code>q</code> to in the <code>simp</code> step, if I am following well, and doesn't know that it has the same <code>0</code> as the other field structure. (Why there is an <code>ExteriorAlgebra</code> in the middle of all this, I am not sure.)</p>",
        "id": 379829400,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1690644073
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> has marked this topic as resolved.</p>",
        "id": 379829531,
        "sender_full_name": "Notification Bot",
        "timestamp": 1690644106
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> has marked this topic as unresolved.</p>",
        "id": 379829561,
        "sender_full_name": "Notification Bot",
        "timestamp": 1690644110
    },
    {
        "content": "<p>I think having a hypothesis that they are equal might be the only reasonable approach here? but i'm not sure how that would interact with typeclass inference -- if you name the two instances and deconstruct them (to eliminate the field equality hypothesis) I don't know whether typeclass inference still knows that there's a NontriviallyNormedField there</p>",
        "id": 379838605,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1690646321
    },
    {
        "content": "<p>is there a non-toy example where this is coming up? seems vaguely like abuse of typeclasses, but I don't know enough to say this is a bad idea &gt;_&lt;</p>",
        "id": 379839011,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1690646437
    },
    {
        "content": "<p>Sophie, your issue is that in the statement it isn't clear what zero means since you have two completely unrelated field structures on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">k</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">k</span></span></span></span>.</p>",
        "id": 379851275,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1690649959
    },
    {
        "content": "<p>Probably Lean picks one and then half of your goals become unprovable.</p>",
        "id": 379851332,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1690649984
    },
    {
        "content": "<p>And see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mul_ne_zero#doc\">docs#mul_ne_zero</a></p>",
        "id": 379851403,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1690650004
    },
    {
        "content": "<p>but the question is whether there is a clean way to say \"i have two different <code>NontriviallyNormedField</code>s that are extensions of the same <code>Field</code> structure\" (which might be an XY problem)</p>",
        "id": 379851701,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1690650099
    },
    {
        "content": "<p>Oh, I actually didn't read Sophie's message at all. I saw she had a question, I copy-pasted the code and tried to guess the question...</p>",
        "id": 379852015,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1690650206
    },
    {
        "content": "<p>I don't think there is any nice way to do that with those type class. You should probably try to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsAbsoluteValue#doc\">docs#IsAbsoluteValue</a>.</p>",
        "id": 379853407,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1690650610
    },
    {
        "content": "<p><del>I would consider two <code>NontriviallyNormedField</code>s with a <code>RingEquiv</code> between them.</del> Answering wrong question too.</p>",
        "id": 379934096,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1690691021
    },
    {
        "content": "<p>There is no way to say that you have 2 structures and their projections to a substructure agree. More precisely, you can create a new typeclass that extends both, then ask for it.</p>",
        "id": 379934177,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1690691116
    },
    {
        "content": "<p>What do you actually want to do?</p>",
        "id": 379934200,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1690691155
    },
    {
        "content": "<p>This is a problem <span class=\"user-mention\" data-user-id=\"406490\">@María Inés de Frutos Fernández</span> and I encountered. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normed_ring\">docs3#normed_ring</a> is not quite the type of normed structures on a <br>\n ring since it includes the <code>ring</code> part, so instead we defined <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_norm\">docs3#ring_norm</a></p>",
        "id": 380050479,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1690727648
    },
    {
        "content": "<p>Thanks for all your answers. In the non-toy example, I want to talk about several semi-norms (and the associated topologies, which might be different) on a fixed vector space. I tried using the <code>NormedSpace</code> structure and ran into the problem that the vector space structures had no reason to be equal.</p>",
        "id": 380110682,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1690742940
    },
    {
        "content": "<p>I might have to do something similar to what <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> mentioned, since I don't just want to have the semi-norms, I also need the induced topologies (probably uniform structures, actually) and all the stuff that comes with it. Yay...</p>",
        "id": 380111074,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1690743079
    },
    {
        "content": "<p>(Another solution would be to have two <code>NormedSpace</code> structures with an isomorphism of vector fields between them. It might be easier in this case, I need to think about it.)</p>",
        "id": 380111555,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1690743256
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Seminorm#doc\">docs#Seminorm</a></p>",
        "id": 380132187,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1690750628
    },
    {
        "content": "<p>Thanks! So this is another possibility. Does there also exist a way to make a space with a <code>Seminorm</code> into a <code>NormedSpace</code> ? (I am trying to use constructions that I can only find for <code>NormedSpace</code>.) If not, I guess I could write it myself, in case my other approach does not work well.</p>",
        "id": 380473058,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1690832326
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddGroupSeminorm.toSeminormedAddGroup#doc\">docs#AddGroupSeminorm.toSeminormedAddGroup</a><br>\nNot sure about a <code>NormedSpace</code> version.</p>",
        "id": 380517825,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1690846875
    },
    {
        "content": "<p>Thanks! This is most of the way to <code>NormedSpace</code> already.</p>",
        "id": 380632566,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1690884275
    },
    {
        "content": "<p>Well, I ended up writing a <code>Seminorm.toNormedSpace</code> definition, and I have to mix it with <code>NormedSpace</code> instances to make stuff work. Thanks again to everybody who helped!</p>\n<p>Also, I needed a corollary of Hahn-Banach that was lightly more general than <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/NormedSpace/HahnBanach/Extension.html#exists_dual_vector\" title=\"\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/NormedSpace/HahnBanach/Extension.html#exists_dual_vector</a>, because my space only had a semi-norm, so I had a <code>SeminormedAddCommGroup</code> instance and that result requires a <code>NormedAddCommGroup</code> instance. More precisely, the result was this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">exists_dual_vector''_sn.</span><span class=\"o\">{</span><span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"n\">IsROrC</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"bp\">✝¹</span> <span class=\"o\">:</span> <span class=\"n\">SeminormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"bp\">✝²</span> <span class=\"o\">:</span> <span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"bp\">‖</span><span class=\"n\">g</span><span class=\"bp\">‖</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"bp\">↑</span><span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">↑‖</span><span class=\"n\">x</span><span class=\"bp\">‖</span>\n</code></pre></div>\n<p>which I deduced from this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">exists_dual_vector_sn.</span><span class=\"o\">{</span><span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"n\">IsROrC</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"bp\">✝¹</span> <span class=\"o\">:</span> <span class=\"n\">SeminormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"bp\">✝²</span> <span class=\"o\">:</span> <span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">‖</span><span class=\"n\">x</span><span class=\"bp\">‖</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"bp\">‖</span><span class=\"n\">g</span><span class=\"bp\">‖</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"bp\">↑</span><span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">↑‖</span><span class=\"n\">x</span><span class=\"bp\">‖</span>\n</code></pre></div>\n<p>I proved it by very slightly generalizing a bunch of results like <code>ContinuousLinearEquiv.coord</code> from <code>NormedAddCommGroup</code>s to <code>SeminormedAddCommGroup</code>s by replacing conditions like <code>x ≠ 0</code> with <code>‖x‖ ≠ 0</code>, which was not hard but a bit longuish. A more natural approach for a mathematician would be to go through the quotient of the space by the kernel of the semi-norm, but I don't know if that's in mathlib. So my question:</p>\n<p>(1) Is the construction of a normed space (or module/group/etc) from a seminormed one by taking the quotient by the kernel of the seminorm in mathlib ?</p>\n<p>(2) Would it be worth having the slightly more general Hahn-Banach corollary in mathlib ?</p>",
        "id": 382400328,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1691339024
    },
    {
        "content": "<p>For (2) -- if you needed it, that's evidence that it should be in the library, and mathlib4 is now open for business!</p>",
        "id": 382401809,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1691339505
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  But then I also need to answer (1), so I can decide what the \"best\" proof is. (I found <code>Mathlib.Analysis.Normed.Group.Quotient</code> so seminorms on quotients exist, but I did not find the norm on the separation yet.)</p>",
        "id": 382404149,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1691340339
    }
]