[
    {
        "content": "<p>Is anyone willing to do me a code review?</p>\n<p>I decided to verify FFT in order to improve my skills. I thought it would be a good goal because it is a nontrivial task but small.<br>\nFirst I needed to implement FFT (which is the part I have done).<br>\nI ended up programming FFT for NTT instead of FFT for DFT (which had been a bad idea anyway).</p>\n<p>The main function is here:<br>\n<a href=\"https://github.com/madvorak/lean-fft/blob/81fa0e4b2a55b06a8473401cc65d43f059ef686e/NumberTheoreticTransform.lean#L53\">https://github.com/madvorak/lean-fft/blob/81fa0e4b2a55b06a8473401cc65d43f059ef686e/NumberTheoreticTransform.lean#L53</a></p>\n<p>One problem I see right now is efficiency:<br>\nIf I were to evaluate the result into an array, it would take Θ(n^2) time instead of Θ(n*log(n)) time.<br>\nTo achieve Θ(n*log(n)) time (which FFT should have), I would have to reuse the values <code>ω^j</code> for the next index.<br>\nI don't know how to do it in Lean. Any idea?</p>\n<p>Apart from that, do you see any other problems with my code?</p>",
        "id": 349062270,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681380370
    },
    {
        "content": "<p>The obvious review comment is that writing <code>dite</code> instead of <code>if</code> is a bit like writing <code>HAdd.hAdd</code> instead of <code>+</code></p>",
        "id": 349065604,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681381350
    },
    {
        "content": "<p>Replacing the outer <code>dite (t = 0)</code> with a pattern match would probably make all your proofs easier too, as all the <code>t-1</code>s would disappear</p>",
        "id": 349065968,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681381456
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/FFT.20.28code.20review.29/near/349065604\">said</a>:</p>\n<blockquote>\n<p>The obvious review comment is that writing <code>dite</code> instead of <code>if</code> is a bit like writing <code>HAdd.hAdd</code> instead of <code>+</code></p>\n</blockquote>\n<p>I use <code>if then else</code> instead of <code>ite</code> as everybody does. However, I don't know how to write <code>dite</code> as something more readable.</p>",
        "id": 349067636,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681381914
    },
    {
        "content": "<p><code>if h : ... then ... else</code></p>",
        "id": 349067754,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1681381942
    },
    {
        "content": "<p>Thank you for your help!<br>\nI applied both pieces of your advice.<br>\n<a href=\"https://github.com/madvorak/lean-fft/blob/7c118b4bbf666cb46a13480d464ddf9a311b4af0/NumberTheoreticTransform.lean#L46\">https://github.com/madvorak/lean-fft/blob/7c118b4bbf666cb46a13480d464ddf9a311b4af0/NumberTheoreticTransform.lean#L46</a><br>\nIs there anything you would suggest when seeing the new version?</p>",
        "id": 349080564,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681385475
    },
    {
        "content": "<p><code>splitter</code> should follow from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finProdFinEquiv#doc\">docs4#finProdFinEquiv</a></p>",
        "id": 349085262,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681386654
    },
    {
        "content": "<p>Especially if you can get your goal into the form <code>Fin (2 ^ t + 2 ^ t)</code> instead of <code>Fin (2 ^ t.succ)</code>, which you can do with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.cast#doc\">docs4#Fin.cast</a></p>",
        "id": 349085723,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681386771
    },
    {
        "content": "<p>Once you have that goal, you can also use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.append#doc\">docs4#Fin.append</a> instead of one of your <code>if</code>s</p>",
        "id": 349085783,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681386792
    },
    {
        "content": "<p>Perhaps try the <code>splitter</code> change last, it's probably the least useful</p>",
        "id": 349086525,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681386982
    },
    {
        "content": "<p>You might find it easiest to define an auxiliary</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">FFT_index</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">FFT_index</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">FFT_index</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>and use <code>FFT_index t</code> instead of <code>2^t.succ</code>; this will save you from needing <code>fin.cast</code> at all.</p>",
        "id": 349087945,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681387348
    },
    {
        "content": "<p>(I think this will make your proof easier)</p>",
        "id": 349088104,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681387387
    },
    {
        "content": "<p>I think to get <code>n * log n</code> complexity you have to replace <code>Fin (2^t) → ZMod M</code> with <code> {a : Array ZMod M // a.size = 2^t}</code>.</p>\n<p>Working with this subtype is probably not very pleasant. Not sure if mathlib or std has something for it. In SciLean I have bunch of interface for it. Even a special array type which for example compactifies array of eight <code>Fin 4</code> into two bytes. Using this might give you even more performance as <code>Array</code> is contiguous but every value is still boxed.</p>",
        "id": 349102348,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1681390733
    },
    {
        "content": "<p>Maybe even better. The output of <code>transform_fast</code> should be an array but the input can be lazy/mathlib-style vector.</p>",
        "id": 349103298,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1681390917
    },
    {
        "content": "<p>Or you can convert <code>a</code> and <code>b</code> into an array on line 58 and 59. Then on lines 65 and 78 refer to those arrays instead of <code>a</code> and <code>b</code>.</p>",
        "id": 349106502,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1681391609
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/FFT.20.28code.20review.29/near/349088104\">said</a>:</p>\n<blockquote>\n<p>(I think this will make your proof easier)</p>\n</blockquote>\n<p>Thanks a lot! It made the definition of FFT much easier!<br>\n<a href=\"https://github.com/madvorak/lean-fft/blob/cdc40f9d90b9b57e28b67115914b9301e76b9895/NumberTheoreticTransform.lean#L42\">https://github.com/madvorak/lean-fft/blob/cdc40f9d90b9b57e28b67115914b9301e76b9895/NumberTheoreticTransform.lean#L42</a><br>\nThat said, proving what my function computes will still be challenging.</p>",
        "id": 349164142,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681404903
    },
    {
        "content": "<p>Note that <code>splitter</code> can now be written as simply composing with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.natAdd#doc\">docs4#Fin.natAdd</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.castAdd#doc\">docs4#Fin.castAdd</a></p>",
        "id": 349164603,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681405020
    },
    {
        "content": "<p>(so you might not need it at all)</p>",
        "id": 349164801,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681405076
    },
    {
        "content": "<p>I should try how those two things work. They were already appearing in the proof of the inductive case and I didn't know how to work with them.</p>",
        "id": 349165510,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681405235
    },
    {
        "content": "<p>You will want to use <code>induction _ using Fin.addCases</code> at some point in your proof</p>",
        "id": 349166317,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681405438
    },
    {
        "content": "<p>I am down to a single <code>sorry</code> here:<br>\n<a href=\"https://github.com/madvorak/lean-fft/blob/fa84fda7049459ff9bc24f5bfb81dfb359ea7e0a/NumberTheoreticTransform.lean#L74\">https://github.com/madvorak/lean-fft/blob/fa84fda7049459ff9bc24f5bfb81dfb359ea7e0a/NumberTheoreticTransform.lean#L74</a></p>\n<p>The goals is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">List.sum</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">List.finRange</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">level</span> <span class=\"n\">n</span><span class=\"o\">)))</span> <span class=\"bp\">=</span>\n<span class=\"n\">List.sum</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"n\">for_eve</span> <span class=\"o\">(</span><span class=\"n\">List.finRange</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">++</span> <span class=\"n\">List.map</span> <span class=\"n\">for_odd</span> <span class=\"o\">(</span><span class=\"n\">List.finRange</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">n</span><span class=\"o\">))))</span>\n</code></pre></div>\n<p>My plan is to show that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">List.finRange</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">level</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>is a permutation of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">List.map</span> <span class=\"n\">for_eve</span> <span class=\"o\">(</span><span class=\"n\">List.finRange</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">++</span> <span class=\"n\">List.map</span> <span class=\"n\">for_odd</span> <span class=\"o\">(</span><span class=\"n\">List.finRange</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>and then using <code>foo ~ bar</code> conclude</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">List.sum</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"n\">f</span> <span class=\"n\">foo</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">List.sum</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"n\">f</span> <span class=\"n\">bar</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>because <code>List.map f foo</code> and <code>List.map f bar</code> represent the same multiset.</p>\n<p>I don't know how to express this idea in Lean. Can you please give me a hint?</p>",
        "id": 350027409,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681498966
    },
    {
        "content": "<p>I don't see much about <code>List.sum</code>, maybe you want to start with <code>rw [&lt;- Multiset.coe_sum]</code>?</p>",
        "id": 350029093,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1681499539
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span> , do you already have a proof that <code>List.finRange (level n + level n) ~ List.map for_eve (List.finRange (level n)) ++ List.map for_odd (List.finRange (level n)))</code>?</p>",
        "id": 350029895,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1681499828
    },
    {
        "content": "<p>It might not be that easy</p>",
        "id": 350029972,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1681499853
    },
    {
        "content": "<p>No, I don't. Thanks for pointing out how to write the statement in Lean!</p>\n<p>That said, if I add it to a context, then <code>library_search</code> still doesn't succeed.</p>",
        "id": 350031645,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681500503
    },
    {
        "content": "<p>As <span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> suggests, I think you would do better to stay away from <code>List</code> if you can</p>",
        "id": 350032860,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681500968
    },
    {
        "content": "<p>Does your implementation actually sum over lists?</p>",
        "id": 350032870,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681500976
    },
    {
        "content": "<p>I found something!<br>\n<code>congrArg Multiset.sum</code><br>\nI will express the property as an equality of multisets and continue from there.</p>",
        "id": 350032882,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681500979
    },
    {
        "content": "<p><code>unfold dotProduct Finset.univ Fintype.elems Fin.fintype</code> looks like a very questionable thing to do</p>",
        "id": 350032991,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681501039
    },
    {
        "content": "<p>(<code>dotProduct</code> is probably ok to unfold, but the rest are a bad idea)</p>",
        "id": 350033058,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681501070
    },
    {
        "content": "<p>I am looking at the same line right now!</p>",
        "id": 350033061,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681501072
    },
    {
        "content": "<p>In principle \"unfold all the sums to list and work from there\" is an ok strategy, but in practice:</p>\n<ul>\n<li>We have more lemmas for <code>Finset.sum</code></li>\n<li>The notation is easier to read for <code>Finset.sum</code></li>\n<li>Equalities over <code>Multiset</code> and <code>Finset</code> are easier to work with than permutation relations over list, because <code>=</code> is more powerful</li>\n</ul>",
        "id": 350033368,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681501198
    },
    {
        "content": "<p>If we weren't mid-port I'd encourage you to open a PR to add any missing list.sum lemmas for which it seems we only have finset.sum versions</p>",
        "id": 350033495,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681501234
    },
    {
        "content": "<p>But only because it's nice for mathlib to have them; they're a distraction for your FFT implementation</p>",
        "id": 350033542,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681501259
    },
    {
        "content": "<p>The one other thing to note is that <code>Finset.sum</code> does not work on floats, but <code>List.sum</code> does; but I wouldn't worry about that for now</p>",
        "id": 350033627,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681501299
    },
    {
        "content": "<p>Proving stuff about floats is hopeless anyways; I will stick to NTT (Fourier transform over <code>ZMod</code>).</p>",
        "id": 350033801,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681501368
    },
    {
        "content": "<p>We have <code>finset.noncomm_sum</code> where you can sorry the commutativity proof</p>",
        "id": 350034530,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1681501645
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span>, I don't see how that helps with floats, or is relevant to FFTs</p>",
        "id": 350035413,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681501976
    },
    {
        "content": "<p>(though I do appreciate the definition existing, I needed it for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/exp_sum_of_commute\">docs#exp_sum_of_commute</a>)</p>",
        "id": 350035447,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681501990
    },
    {
        "content": "<blockquote>\n<p>Finset.sum does not work on floats</p>\n</blockquote>\n<p>I thought you meant commutativity, but I guess associativity is out of the window too</p>",
        "id": 350035516,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1681502029
    },
    {
        "content": "<p>I think floats actually are commutative? As you say though, they're certainly not associative</p>",
        "id": 350035598,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681502050
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> has marked this topic as resolved.</p>",
        "id": 350059212,
        "sender_full_name": "Notification Bot",
        "timestamp": 1681512437
    },
    {
        "content": "<blockquote>\n<p>I think floats actually are commutative?</p>\n</blockquote>\n<p>Doesn't nan (as usual) screw with everything? (37.0 + nan) != (nan + 37.0) no?</p>",
        "id": 350085476,
        "sender_full_name": "Julian Berman",
        "timestamp": 1681528924
    },
    {
        "content": "<p>Isn't it very important to use arrays and not functions  for implementing FFT?</p>",
        "id": 350089423,
        "sender_full_name": "Reid Barton",
        "timestamp": 1681532780
    },
    {
        "content": "<p>The point is to reuse and not repeat subcomputations</p>",
        "id": 350089434,
        "sender_full_name": "Reid Barton",
        "timestamp": 1681532817
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321696\">@Julian Berman</span> Since floats shouldn't make sense, you're both correct and incorrect <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> Floats have two different relations that can be called equality. The first is the more basic one, which not every programming language gives you access to: do the floats have the same underlying representation? Assuming everything is configured to produce a canonical NaN (since of course 64-bit IEEE-754 floats have 9007199254740990 different NaNs...) then addition is commutative with respect to this equality. But, IEEE-754 has a separate relation called \"equality\" that tends to use the \"=\" symbol, despite not being an equivalence relation, and with respect to this relation addition is not commutative.</p>\n<p>The first one is Lean <code>Eq</code> and the second is the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instBEqFloat#doc\">docs4#instBEqFloat</a> <code>BEq</code> instance.</p>",
        "id": 350104888,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681545012
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20FFT.20.28code.20review.29/near/350089423\">said</a>:</p>\n<blockquote>\n<p>Isn't it very important to use arrays and not functions  for implementing FFT?</p>\n</blockquote>\n<p>Yeah; I realized that too late.</p>",
        "id": 350107115,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681545941
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20FFT.20.28code.20review.29/near/350104888\">said</a>:</p>\n<blockquote>\n<p>The first one is Lean <code>Eq</code> and the second is the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instBEqFloat#doc\">docs4#instBEqFloat</a> <code>BEq</code> instance.</p>\n</blockquote>\n<p>OT: What is the notation in Lean 4? I suppose <code>==</code> denotes <code>BEq</code>. How do you write  <code>Eq</code>?</p>",
        "id": 350108532,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681546434
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span> To solve the array/function problem, you just need a function</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Fin.memoize</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>that saves the values of <code>f</code> to an array and returns a function that indexes into that array. Then you insert these at each level of the FFT.</p>",
        "id": 350108665,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681546477
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20FFT.20.28code.20review.29/near/350108532\">said</a>:</p>\n<blockquote>\n<p>How do you write  <code>Eq</code>?</p>\n</blockquote>\n<p><code>=</code></p>",
        "id": 350108752,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681546509
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20FFT.20.28code.20review.29/near/350108665\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> To solve the array/function problem, you just need a function</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Fin.memoize</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>that saves the values of <code>f</code> to an array and returns a function that indexes into that array. Then you insert these at each level of the FFT.</p>\n</blockquote>\n<p>My implementation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">vektor_memoize</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">Array.mk</span> <span class=\"o\">(</span><span class=\"n\">List.ofFn</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.get</span> <span class=\"o\">(</span><span class=\"n\">Fin.cast</span> <span class=\"o\">(</span><span class=\"n\">List.length_ofFn</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 350110677,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681547379
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20FFT.20.28code.20review.29/near/350108752\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20FFT.20.28code.20review.29/near/350108532\">said</a>:</p>\n<blockquote>\n<p>How do you write  <code>Eq</code>?</p>\n</blockquote>\n<p><code>=</code></p>\n</blockquote>\n<p>Oh! The identity on representations is not decidable?</p>",
        "id": 350111726,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681547800
    },
    {
        "content": "<p><code>Float</code> should have <code>DecidableEq</code>, but it looks like it's not implemented (and since it's an opaque type we can't implement it ourselves without changing core).</p>",
        "id": 350112819,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681548326
    },
    {
        "content": "<p>I was discussing the thing about equality on floats here:<br>\n<a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Boolean.20.60.3C.60/near/328448753\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/.E2.9C.94.20Boolean.20.60.3C.60/near/328448753</a></p>",
        "id": 350113244,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681548497
    },
    {
        "content": "<p>Equality of floats is a bit fraught though (and not just for the obvious reasons). Specifically, I don't think it would be safe to expose bitwise equality as <code>=</code>, because compilers can do funny things to NaNs. I actually made a <a href=\"https://github.com/leanprover/lean4/pull/1459\">PR</a> a while ago to core to try to ensure that lean only sees the level 3 representation of floats: there is only one NaN.</p>",
        "id": 350114501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681549016
    },
    {
        "content": "<p>So would that make NaN = NaN?</p>",
        "id": 350115049,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1681549265
    },
    {
        "content": "<p>of course</p>",
        "id": 350115087,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681549287
    },
    {
        "content": "<p>we have a little thing called <code>rfl</code> that would be in trouble if not</p>",
        "id": 350115123,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681549320
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20FFT.20.28code.20review.29/near/350114501\">said</a>:</p>\n<blockquote>\n<p>Equality of floats is a bit fraught though (and not just for the obvious reasons). Specifically, I don't think it would be safe to expose bitwise equality as <code>=</code>, because compilers can do funny things to NaNs. I actually made a <a href=\"https://github.com/leanprover/lean4/pull/1459\">PR</a> a while ago to core to try to ensure that lean only sees the level 3 representation of floats: there is only one NaN.</p>\n</blockquote>\n<p>Would it be reasonable to have <code>RawFloat</code> that had the full nan semantics, and have <code>Float</code> be the quotient by the \"all nans are the same\" relation?</p>",
        "id": 350115478,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681549469
    },
    {
        "content": "<p>Is <code>RawFloat</code> a software float implementation? Because if not you will be hard-pressed to make sure you get bit-equal results across platforms</p>",
        "id": 350115694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681549554
    },
    {
        "content": "<p>Maybe it's useful for formalizing things about NaN-boxing? Some VM implementations embed non-float values into the NaNs.</p>",
        "id": 350115879,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681549613
    },
    {
        "content": "<p>You can have a type of 32-bit values without any float ops, that's just <code>UInt32</code></p>",
        "id": 350116039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681549682
    },
    {
        "content": "<p>you can even have <code>toBits</code> and <code>fromBits</code> functions to take you from <code>Float</code> to <code>UInt32</code> and back</p>",
        "id": 350116190,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681549733
    },
    {
        "content": "<p>but the <code>toBits</code> function needs to live in a quotient unless it canonicalizes NaNs</p>",
        "id": 350116259,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681549753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20FFT.20.28code.20review.29/near/350110677\">said</a>:</p>\n<blockquote>\n<p>My implementation:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">vektor_memoize</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">Array.mk</span> <span class=\"o\">(</span><span class=\"n\">List.ofFn</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.get</span> <span class=\"o\">(</span><span class=\"n\">Fin.cast</span> <span class=\"o\">(</span><span class=\"n\">List.length_ofFn</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>That seems fine, though if you care about constant factors for your running time, you can avoid allocating that <code>List</code>, which is a linked list.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Array.finRange</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">loop</span> <span class=\"o\">(</span><span class=\"n\">Array.mkEmpty</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"mi\">0</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">loop</span> <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"k\">then</span>\n      <span class=\"n\">loop</span> <span class=\"o\">(</span><span class=\"n\">res.push</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">res</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Nat.self_le_sub_iff</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases'</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">cases</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.sub_lt_succ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Array.size_finRange_loop</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">Array.finRange.loop</span> <span class=\"n\">n</span> <span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">i</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">size</span> <span class=\"bp\">=</span> <span class=\"n\">res.size</span> <span class=\"bp\">+</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">i</span> <span class=\"n\">generalizing</span> <span class=\"n\">res</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finRange.loop</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">i</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finRange.loop</span><span class=\"o\">]</span>\n    <span class=\"n\">split</span>\n    <span class=\"n\">next</span> <span class=\"n\">h'</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Nat.add_sub_assoc</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">Nat.succ_sub_succ</span><span class=\"o\">]</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">ih</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">le_of_lt</span> <span class=\"n\">h</span><span class=\"o\">),</span> <span class=\"n\">Nat.succ_eq_add_one</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">ring</span>\n    <span class=\"n\">next</span> <span class=\"n\">h'</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">exfalso</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">Nat.self_le_sub_iff</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h'</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Array.size_finRange</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Array.finRange</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">size</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">finRange</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">Array.size_finRange_loop</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">mkEmpty</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"n\">le_rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Fin.memoize</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">vals</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Array.finRange</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">vals.size</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Array.size_map</span><span class=\"o\">,</span> <span class=\"n\">Array.size_finRange</span><span class=\"o\">]</span>\n  <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">vals.get</span> <span class=\"o\">(</span><span class=\"n\">Fin.cast</span> <span class=\"n\">h</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 350116260,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681549754
    },
    {
        "content": "<p>You also need the theorem that <code>Fin.memoize f = f</code> if you want to prove anything.</p>",
        "id": 350116745,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681549955
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20FFT.20.28code.20review.29/near/350116260\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20FFT.20.28code.20review.29/near/350110677\">said</a>:</p>\n<blockquote>\n<p>My implementation:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">vektor_memoize</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">Array.mk</span> <span class=\"o\">(</span><span class=\"n\">List.ofFn</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.get</span> <span class=\"o\">(</span><span class=\"n\">Fin.cast</span> <span class=\"o\">(</span><span class=\"n\">List.length_ofFn</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>That seems fine, though if you care about constant factors for your running time, you can avoid allocating that <code>List</code>, which is a linked list.</p>\n</blockquote>\n<p>Would this do?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">vektor_memoize</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">Array.ofFn</span> <span class=\"n\">f</span>\n<span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.get</span> <span class=\"o\">(</span><span class=\"n\">Fin.cast</span> <span class=\"o\">(</span><span class=\"n\">Array.size_ofFn</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The function <code>Array.ofFn</code> is implemented in Std as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ofFn</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">go</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">mkEmpty</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- Auxiliary for `ofFn`. `ofFn.go f i acc = acc ++ #[f i, ..., f(n - 1)]` -/</span>\n  <span class=\"n\">go</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">acc</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n    <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">go</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">acc.push</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩))</span> <span class=\"k\">else</span> <span class=\"n\">acc</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">i</span>\n</code></pre></div>",
        "id": 350117423,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681550260
    },
    {
        "content": "<p>Oh, yeah, <code>Array.ofFn</code> works (and saves a lot of work).</p>",
        "id": 350117873,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681550449
    },
    {
        "content": "<p>This is my FFT now:<br>\n<a href=\"https://github.com/madvorak/lean-fft/blob/a4065b186594411ca754b311714a030a7e56836a/NumberTheoreticTransform.lean#L52\">https://github.com/madvorak/lean-fft/blob/a4065b186594411ca754b311714a030a7e56836a/NumberTheoreticTransform.lean#L52</a></p>\n<p>The outputs are still the same (even the proof of correctness works). However, the performance is terrible. If I run it on a vector of size 16, it takes several minutes to evaluate. What did I do wrong? The performance with <code>List.ofFn</code> was similarly horrible.</p>",
        "id": 350119408,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681551021
    },
    {
        "content": "<p>PS: I know my implementation is inefficient (it still runs in quadratic time). Nevertheless, I don't know what makes the constants so bad.</p>",
        "id": 350119768,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681551189
    },
    {
        "content": "<p>I would be worried about <code>Fin.append</code>, and also about how many times you might be evaluating <code>level</code></p>",
        "id": 350120662,
        "sender_full_name": "Reid Barton",
        "timestamp": 1681551523
    },
    {
        "content": "<p>It looks like the rest of the code should not evaluate <code>level</code></p>",
        "id": 350120801,
        "sender_full_name": "Reid Barton",
        "timestamp": 1681551578
    },
    {
        "content": "<p>I assume \"run it\" means with <code>#eval</code> and not as compiled code?</p>",
        "id": 350120849,
        "sender_full_name": "Reid Barton",
        "timestamp": 1681551600
    },
    {
        "content": "<p>\"Minutes\" still seems like sort of a lot</p>",
        "id": 350120918,
        "sender_full_name": "Reid Barton",
        "timestamp": 1681551619
    },
    {
        "content": "<p>True. I know I did many things very inefficiently; however, I am nevertheless puzzled by why it worsened so harshly after I added the memoization.</p>",
        "id": 350121049,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681551672
    },
    {
        "content": "<p>oh, if you make <code>vektor_memoize</code> into the actual identity function, is it faster?</p>",
        "id": 350121229,
        "sender_full_name": "Reid Barton",
        "timestamp": 1681551739
    },
    {
        "content": "<p>Much faster!</p>",
        "id": 350121319,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681551776
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.ofFn#doc\">docs4#Array.ofFn</a></p>",
        "id": 350121337,
        "sender_full_name": "Reid Barton",
        "timestamp": 1681551787
    },
    {
        "content": "<p>Hopefully Lean is not deciding to float <code>let a := Array.ofFn f</code> into the <code>fun i =&gt; ...</code></p>",
        "id": 350121617,
        "sender_full_name": "Reid Barton",
        "timestamp": 1681551895
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> Unfortunately that's exactly what it's doing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">result</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">vektor_memoize._rarg</span> <span class=\"o\">(</span><span class=\"n\">x_1</span> <span class=\"o\">:</span> <span class=\"bp\">@&amp;</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x_2</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x_3</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_4</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">Array.ofFn._rarg</span> <span class=\"n\">x_1</span> <span class=\"n\">x_2</span><span class=\"bp\">;</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_5</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">Fin.memoize._closed_2</span><span class=\"bp\">;</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_6</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">Equiv.toEmbedding._elambda_1._rarg</span> <span class=\"n\">x_5</span> <span class=\"n\">x_3</span><span class=\"bp\">;</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_7</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">Array.get</span> <span class=\"bp\">◾</span> <span class=\"n\">x_4</span> <span class=\"n\">x_6</span><span class=\"bp\">;</span>\n  <span class=\"n\">dec</span> <span class=\"n\">x_6</span><span class=\"bp\">;</span>\n  <span class=\"n\">dec</span> <span class=\"n\">x_4</span><span class=\"bp\">;</span>\n  <span class=\"n\">ret</span> <span class=\"n\">x_7</span>\n<span class=\"kd\">def</span> <span class=\"n\">vektor_memoize</span> <span class=\"o\">(</span><span class=\"n\">x_1</span> <span class=\"o\">:</span> <span class=\"bp\">◾</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_2</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">pap</span> <span class=\"n\">vektor_memoize._rarg._boxed</span><span class=\"bp\">;</span>\n  <span class=\"n\">ret</span> <span class=\"n\">x_2</span>\n<span class=\"kd\">def</span> <span class=\"n\">vektor_memoize._rarg._boxed</span> <span class=\"o\">(</span><span class=\"n\">x_1</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x_2</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x_3</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_4</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">vektor_memoize._rarg</span> <span class=\"n\">x_1</span> <span class=\"n\">x_2</span> <span class=\"n\">x_3</span><span class=\"bp\">;</span>\n  <span class=\"n\">dec</span> <span class=\"n\">x_1</span><span class=\"bp\">;</span>\n  <span class=\"n\">ret</span> <span class=\"n\">x_4</span>\n</code></pre></div>",
        "id": 350122494,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681552248
    },
    {
        "content": "<p>Man this would be easier to read with type information, but I agree.</p>",
        "id": 350122877,
        "sender_full_name": "Reid Barton",
        "timestamp": 1681552403
    },
    {
        "content": "<p>I'm not sure how reliable it is, but here's a way to get the compiler to compute <code>Array.ofFn</code> just once:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">vektor_memoize'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">Array.ofFn</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.get</span> <span class=\"o\">(</span><span class=\"n\">Fin.cast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">Array.size_ofFn</span><span class=\"o\">])</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">vektor_memoize</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">vektor_memoize'</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">Array.ofFn</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p><strong>Edit:</strong> Just kidding, it seems to have the same problem. It's a bit hard to read this <code>set_option trace.compiler.ir.result true</code> output.</p>",
        "id": 350123807,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681552727
    },
    {
        "content": "<p>Does interpreted vs compiled code make any difference here?</p>",
        "id": 350124430,
        "sender_full_name": "Reid Barton",
        "timestamp": 1681552957
    },
    {
        "content": "<p>I think the IR output we're looking at is used by both the C compiler and the <code>#eval</code> VM.</p>",
        "id": 350124603,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681553020
    },
    {
        "content": "<p>I guess the question is whether it does different optimizations (e.g. arity analysis?) by default</p>",
        "id": 350124991,
        "sender_full_name": "Reid Barton",
        "timestamp": 1681553162
    },
    {
        "content": "<p>My understanding of the pipeline is that a definition gets to this IR stage (which includes all the inc/dec refcount handling), it's saved, and then when you <code>#eval</code> the IR is interpreted, and when you compile, the IR is translated to C. So both the interpreter and the C compiler get the same high-level optimizations.</p>",
        "id": 350125337,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681553324
    },
    {
        "content": "<p>If I'm reading the IR correctly this time, this seems to do the trick:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Box</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">unbox</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">vektor_memoize'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Box</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">Array.ofFn</span> <span class=\"n\">f</span>\n  <span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.get</span> <span class=\"o\">(</span><span class=\"n\">Fin.cast</span> <span class=\"o\">(</span><span class=\"n\">Array.size_ofFn</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">vektor_memoize</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">vektor_memoize'</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">unbox</span>\n</code></pre></div>\n<p><code>Box</code> seems to be keeping the arity analysis from treating <code>Fin n</code> as being an extra argument to <code>vector_memoize'</code>.</p>",
        "id": 350125574,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681553404
    },
    {
        "content": "<p>It's not too important, but I noticed this generates marginally better code than using <code>Fin.cast</code> (probably because of some missing <code>@[inline]</code> attributes):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">vektor_memoize'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Box</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">Array.ofFn</span> <span class=\"n\">f</span>\n  <span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.get</span> <span class=\"o\">(</span><span class=\"n\">Array.size_ofFn</span> <span class=\"n\">f</span> <span class=\"bp\">▸</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 350126407,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681553721
    },
    {
        "content": "<p>The new compiler generates a much easier result to read, but it still has the same bug:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.Array.Basic</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Compiler.result</span> <span class=\"n\">true</span>\n<span class=\"kd\">def</span> <span class=\"n\">vektor_memoize</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">Array.ofFn</span> <span class=\"n\">f</span>\n  <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.get</span> <span class=\"o\">⟨</span><span class=\"n\">i.1</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- [Compiler.result] size: 2</span>\n<span class=\"c1\">--     def vektor_memoize._redArg n f i : lcErased :=</span>\n<span class=\"c1\">--       let a := Array.ofFn._redArg n f;</span>\n<span class=\"c1\">--       let _x.1 := Array.get ◾ a i;</span>\n<span class=\"c1\">--       return _x.1</span>\n\n<span class=\"c1\">-- [Compiler.result] size: 1</span>\n<span class=\"c1\">--     def vektor_memoize α n f i : lcErased :=</span>\n<span class=\"c1\">--       let _x.1 := vektor_memoize._redArg n f i;</span>\n<span class=\"c1\">--       return _x.1</span>\n</code></pre></div>\n<p>I think this should be reported</p>",
        "id": 350129178,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681554726
    },
    {
        "content": "<p>It looks like the <code>Box</code> trick works for the new compiler too.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Compiler.result</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">1</span>\n    <span class=\"kd\">def</span> <span class=\"n\">vektor_memoize'._redArg._lam_0</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">lcErased</span> <span class=\"o\">:=</span>\n      <span class=\"k\">let</span> <span class=\"n\">_x.1</span> <span class=\"o\">:=</span> <span class=\"n\">Array.get</span> <span class=\"bp\">◾</span> <span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"bp\">;</span>\n      <span class=\"n\">return</span> <span class=\"n\">_x.1</span>\n\n<span class=\"o\">[</span><span class=\"n\">Compiler.result</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">2</span>\n    <span class=\"kd\">def</span> <span class=\"n\">vektor_memoize'._redArg</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">lcErased</span> <span class=\"o\">:=</span>\n      <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">Array.ofFn._redArg</span> <span class=\"n\">n</span> <span class=\"n\">f</span><span class=\"bp\">;</span>\n      <span class=\"k\">let</span> <span class=\"n\">_f.1</span> <span class=\"o\">:=</span> <span class=\"n\">vektor_memoize'._redArg._lam_0</span> <span class=\"n\">a</span><span class=\"bp\">;</span>\n      <span class=\"n\">return</span> <span class=\"n\">_f.1</span>\n\n<span class=\"o\">[</span><span class=\"n\">Compiler.result</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">1</span>\n    <span class=\"kd\">def</span> <span class=\"n\">vektor_memoize'</span> <span class=\"n\">n</span> <span class=\"n\">α</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">lcErased</span> <span class=\"o\">:=</span>\n      <span class=\"k\">let</span> <span class=\"n\">_x.1</span> <span class=\"o\">:=</span> <span class=\"n\">vektor_memoize'._redArg</span> <span class=\"n\">n</span> <span class=\"n\">f</span><span class=\"bp\">;</span>\n      <span class=\"n\">return</span> <span class=\"n\">_x.1</span>\n\n<span class=\"o\">[</span><span class=\"n\">Compiler.result</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">1</span>\n    <span class=\"kd\">def</span> <span class=\"n\">vektor_memoize._redArg</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">a.1</span> <span class=\"o\">:</span> <span class=\"n\">lcErased</span> <span class=\"o\">:=</span>\n      <span class=\"k\">let</span> <span class=\"n\">_x.2</span> <span class=\"o\">:=</span> <span class=\"n\">vektor_memoize'._redArg</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">a.1</span><span class=\"bp\">;</span>\n      <span class=\"n\">return</span> <span class=\"n\">_x.2</span>\n\n<span class=\"o\">[</span><span class=\"n\">Compiler.result</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">1</span>\n    <span class=\"kd\">def</span> <span class=\"n\">vektor_memoize</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">a.1</span> <span class=\"o\">:</span> <span class=\"n\">lcErased</span> <span class=\"o\">:=</span>\n      <span class=\"k\">let</span> <span class=\"n\">_x.2</span> <span class=\"o\">:=</span> <span class=\"n\">vektor_memoize'._redArg</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">a.1</span><span class=\"bp\">;</span>\n      <span class=\"n\">return</span> <span class=\"n\">_x.2</span>\n</code></pre></div>",
        "id": 350130022,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681555053
    },
    {
        "content": "<p>Unfortunately, I don't understand the low-level issues at all. I just want to report that the <code>Box</code> trick<br>\n<a href=\"https://github.com/madvorak/lean-fft/blob/e9a3a671be55023ff49786a88e1079dade41b77e/NumberTheoreticTransform.lean#L48\">https://github.com/madvorak/lean-fft/blob/e9a3a671be55023ff49786a88e1079dade41b77e/NumberTheoreticTransform.lean#L48</a><br>\nimproves the performance (from circa 10 minutes to circa 2 minutes on a vector of size 16) but it is still much slower than without memoization.</p>",
        "id": 350132960,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681556027
    },
    {
        "content": "<p>One performance problem seems to be that <code>![...]</code> notation creates really inefficient vectors. I don't have the patience to wait for the first one to complete, but the second is quick:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">vector_memoize</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">9</span><span class=\"o\">]</span>\n<span class=\"k\">#eval</span> <span class=\"n\">vector_memoize</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Array.get</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">9</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 350139485,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681557898
    },
    {
        "content": "<p>It seems like using functions here is just irretrievably bad, because lean doesn't share the sub-computations even with the memoize call. The only thing I changed here is to use an array for the accumulator instead of a function wrapping an array and it is way faster than the original (looks like about 0.5 seconds for all four calls in the <code>#eval</code> block)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Vector'</span> <span class=\"o\">(</span><span class=\"n\">_n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">Array</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">vektor'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">Vector'</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">transform_fast'</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Vector'</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Vector'</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">transform_fast'</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"bp\">*</span> <span class=\"n\">ω</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">ofFn</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.get</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">for_eve</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">transform_fast'</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"bp\">*</span> <span class=\"n\">ω</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">ofFn</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.get</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">for_odd</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"n\">Array.append</span>\n    <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">ofFn</span> <span class=\"k\">fun</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.get</span><span class=\"bp\">!</span> <span class=\"n\">j</span> <span class=\"bp\">+</span> <span class=\"n\">ω</span> <span class=\"bp\">^</span> <span class=\"n\">j.val</span> <span class=\"bp\">*</span> <span class=\"n\">b.get</span><span class=\"bp\">!</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">ofFn</span> <span class=\"k\">fun</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.get</span><span class=\"bp\">!</span> <span class=\"n\">j</span> <span class=\"bp\">-</span> <span class=\"n\">ω</span> <span class=\"bp\">^</span> <span class=\"n\">j.val</span> <span class=\"bp\">*</span> <span class=\"n\">b.get</span><span class=\"bp\">!</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FNTS</span> <span class=\"o\">:</span> <span class=\"n\">vektor'</span> <span class=\"bp\">→</span> <span class=\"n\">vektor'</span> <span class=\"o\">:=</span> <span class=\"n\">transform_fast'</span> <span class=\"n\">e</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">negate'</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">vektor'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">vektor'</span> <span class=\"o\">:=</span>\n<span class=\"n\">Array.ofFn</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">x.get</span><span class=\"bp\">!</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FNTT</span> <span class=\"o\">:</span> <span class=\"n\">vektor'</span> <span class=\"bp\">→</span> <span class=\"n\">vektor'</span> <span class=\"o\">:=</span> <span class=\"n\">negate'</span> <span class=\"bp\">∘</span> <span class=\"n\">transform_fast'</span> <span class=\"n\">e</span> <span class=\"mi\">6</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">FNTS</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">9</span><span class=\"o\">]</span>\n<span class=\"k\">#eval</span> <span class=\"n\">FNTS</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">9</span><span class=\"o\">]</span>\n<span class=\"k\">#eval</span> <span class=\"n\">FNTT</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">6</span><span class=\"o\">,</span> <span class=\"mi\">8</span><span class=\"o\">,</span> <span class=\"mi\">10</span><span class=\"o\">,</span> <span class=\"mi\">16</span><span class=\"o\">,</span> <span class=\"mi\">15</span><span class=\"o\">,</span> <span class=\"mi\">14</span><span class=\"o\">,</span> <span class=\"mi\">6</span><span class=\"o\">,</span> <span class=\"mi\">14</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">14</span><span class=\"o\">,</span> <span class=\"mi\">8</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">12</span><span class=\"o\">]</span>\n<span class=\"k\">#eval</span> <span class=\"n\">FNTT</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">9</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">8</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">10</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">12</span><span class=\"o\">,</span> <span class=\"mi\">6</span><span class=\"o\">,</span> <span class=\"mi\">13</span><span class=\"o\">,</span> <span class=\"mi\">11</span><span class=\"o\">,</span> <span class=\"mi\">11</span><span class=\"o\">,</span> <span class=\"mi\">13</span><span class=\"o\">,</span> <span class=\"mi\">6</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 350142614,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681558899
    },
    {
        "content": "<p>Here's a surprising subproblem I ran into:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">arr</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">9</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">arr_size</span> <span class=\"o\">:</span> <span class=\"n\">arr.size</span> <span class=\"bp\">=</span> <span class=\"mi\">16</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">(deterministic) timeout at 'whnf', maximum number of heartbeats (200000)</span>\n<span class=\"cm\">has been reached (use 'set_option maxHeartbeats &lt;num&gt;' to set the limit)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 350142824,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681558975
    },
    {
        "content": "<p>it should be provable by <code>simp</code></p>",
        "id": 350142963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681559023
    },
    {
        "content": "<p>It's not</p>",
        "id": 350143180,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681559092
    },
    {
        "content": "<p><code>simp only [arr]</code> gets it but it is really heavy</p>",
        "id": 350143249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681559116
    },
    {
        "content": "<p>it must be using <code>decide := true</code></p>",
        "id": 350143278,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681559123
    },
    {
        "content": "<p>If this <code>rfl</code> is failing, how are your <code>FNTS #[4, 4, 4, 1, 1, 5, 5, 5, 5, 7, 7, 7, 7, 0, 0, 9]</code> examples unifying?</p>",
        "id": 350143333,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681559135
    },
    {
        "content": "<p>because I cheated</p>",
        "id": 350143378,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681559146
    },
    {
        "content": "<p>look at the definition of <code>Vector'</code></p>",
        "id": 350143406,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681559155
    },
    {
        "content": "<p>Maybe that cheat is explaining the biggest difference in runtime?</p>",
        "id": 350143522,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681559183
    },
    {
        "content": "<p>The more realistic scenario would use an auto param to prove the subgoal</p>",
        "id": 350143524,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681559183
    },
    {
        "content": "<p>oh, you think the <code>#eval</code> is actually dominated by check time?</p>",
        "id": 350143632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681559220
    },
    {
        "content": "<p>One thing you could do to avoid that issue is to make <code>def foo := FNTS #[4, 4, 4, 1, 1, 5, 5, 5, 5, 7, 7, 7, 7, 0, 0, 9]</code> and then <code>#eval foo</code></p>",
        "id": 350143780,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681559273
    },
    {
        "content": "<p>btw <code>theorem arr_size : arr.size = 16 := by simp (config := {decide := false}) [arr]</code> is fast</p>",
        "id": 350143943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681559319
    },
    {
        "content": "<p>Yeah, check time seems to be it. This isn't in a great state (I've made a number of modifications to poke around, and who knows what was necessary) but this is fast:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.ZMod.Defs</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Matrix.DotProduct</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.LibrarySearch</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Linarith</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Cases</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Data.Array.Basic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Matrix</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Compiler.result</span> <span class=\"n\">true</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Box</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">unbox</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">vektor_memoize'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Box</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">Array.ofFn</span> <span class=\"n\">f</span>\n  <span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.get</span> <span class=\"o\">(</span><span class=\"n\">Array.size_ofFn</span> <span class=\"n\">f</span> <span class=\"bp\">▸</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">vektor_memoize</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">vektor_memoize'</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">unbox</span>\n\n<span class=\"c1\">--  level n = 2 ^ n</span>\n<span class=\"kd\">def</span> <span class=\"n\">level</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>   <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">level</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span>\n<span class=\"kd\">def</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">level</span> <span class=\"n\">e</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"kd\">def</span> <span class=\"n\">vektor</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ZMod</span> <span class=\"n\">M</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">negate</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">vektor</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">vektor</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">index_ok₁</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i.val</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">hi</span> <span class=\"o\">:=</span> <span class=\"n\">Fin.is_lt</span> <span class=\"n\">i</span>\n  <span class=\"n\">linarith</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">index_ok₀</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i.val</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">K</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Nat.lt_of_succ_lt</span> <span class=\"o\">(</span><span class=\"n\">index_ok₁</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">index_ok</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i.val</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">level</span> <span class=\"n\">t.succ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">index_ok₁</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">for_eve</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">n.succ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">k.val</span><span class=\"o\">,</span> <span class=\"n\">Nat.lt_of_succ_lt</span> <span class=\"o\">(</span><span class=\"n\">index_ok</span> <span class=\"n\">k</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">for_odd</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">n.succ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">k.val</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">index_ok</span> <span class=\"n\">k</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Fin.append'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span> <span class=\"k\">then</span>\n      <span class=\"n\">a</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">⟩</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">b</span> <span class=\"o\">⟨</span><span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"gr\">sorry</span> <span class=\"o\">}⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">append</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Box</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Box</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">level</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">level</span> <span class=\"n\">t</span> <span class=\"bp\">+</span> <span class=\"n\">level</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">level</span><span class=\"o\">,</span> <span class=\"n\">two_mul</span><span class=\"o\">]</span>\n  <span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">vektor_memoize</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">this</span> <span class=\"bp\">▸</span> <span class=\"n\">Fin.append'</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.unbox</span> <span class=\"n\">j</span> <span class=\"bp\">+</span> <span class=\"n\">ω</span> <span class=\"bp\">^</span> <span class=\"n\">j.val</span> <span class=\"bp\">*</span> <span class=\"n\">b.unbox</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.unbox</span> <span class=\"n\">j</span> <span class=\"bp\">-</span> <span class=\"n\">ω</span> <span class=\"bp\">^</span> <span class=\"n\">j.val</span> <span class=\"bp\">*</span> <span class=\"n\">b.unbox</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">transform_fast'</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Box</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">dbg_trace</span> <span class=\"s2\">\"transform_fast' {t} {ω.val} {(Array.ofFn x).map (·.val)}\"</span>\n  <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span>   <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">transform_fast'</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"bp\">*</span> <span class=\"n\">ω</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">for_eve</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n    <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">transform_fast'</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"bp\">*</span> <span class=\"n\">ω</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">for_odd</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n    <span class=\"n\">append</span> <span class=\"n\">ω</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">transform_fast</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ZMod</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">transform_fast'</span> <span class=\"n\">t</span> <span class=\"n\">ω</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">unbox</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FNTS</span> <span class=\"o\">:</span> <span class=\"n\">vektor</span> <span class=\"bp\">→</span> <span class=\"n\">vektor</span> <span class=\"o\">:=</span> <span class=\"n\">transform_fast</span> <span class=\"n\">e</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FNTT</span> <span class=\"o\">:</span> <span class=\"n\">vektor</span> <span class=\"bp\">→</span> <span class=\"n\">vektor</span> <span class=\"o\">:=</span> <span class=\"n\">negate</span> <span class=\"bp\">∘</span> <span class=\"n\">transform_fast</span> <span class=\"n\">e</span> <span class=\"mi\">6</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FNTS'</span> <span class=\"o\">(</span><span class=\"n\">arr</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Box</span> <span class=\"n\">vektor</span> <span class=\"o\">:=</span>\n  <span class=\"n\">transform_fast'</span> <span class=\"mi\">4</span> <span class=\"mi\">3</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">arr.get</span><span class=\"bp\">!</span> <span class=\"n\">i</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">FNTS'</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">9</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">unbox</span>\n</code></pre></div>",
        "id": 350144269,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681559414
    },
    {
        "content": "<p>It is really unfortunate that <code>#[...]</code> notation is defined using <code>List.toArray</code>. Std never uses that, it prefers <code>Array.mk</code> (which is propositionally equal and <code>extern</code>-defined to the same thing but is much better for proofs)</p>",
        "id": 350144383,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681559446
    },
    {
        "content": "<p>Since <code>M</code> is positive, this can use a version of your cheat, which is <code>fun i =&gt; arr.get! i</code> to turn the array into a function without doing bounds checking.</p>",
        "id": 350144467,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681559471
    },
    {
        "content": "<p>A quick hack is to write <code>\\&lt;[...]\\&gt;</code> instead of <code>#[...]</code></p>",
        "id": 350144513,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681559485
    },
    {
        "content": "<p>for the formally proved version I would use <code>arr.get \\&lt;i, ...\\&gt;</code></p>",
        "id": 350144663,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681559529
    },
    {
        "content": "<p>The non-cheating version of <code>Vector'</code> is as a subtype of <code>Array</code></p>",
        "id": 350144867,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681559601
    },
    {
        "content": "<p>Yeah, I think right way to implement this is using a subtype of <code>Array</code> along with a stride (I think that's the term: a start index, a delta/step between indices, and the number of indices to use).</p>",
        "id": 350145079,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681559669
    },
    {
        "content": "<p>why do you need a stride?</p>",
        "id": 350145187,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681559707
    },
    {
        "content": "<p>It sounds like you are designing <code>Subarray</code></p>",
        "id": 350145231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681559730
    },
    {
        "content": "<p>Almost, you need the step too. It's so you don't have to copy elements of the list when you do, for example, <code>(.ofFn fun (i : Fin (level n)) =&gt; x.get! (for_eve i))</code></p>",
        "id": 350145402,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681559780
    },
    {
        "content": "<p>oh, well the hardcore version of that code would use swaps</p>",
        "id": 350145500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681559822
    },
    {
        "content": "<p>oh wait, no I misunderstood</p>",
        "id": 350145657,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681559878
    },
    {
        "content": "<p>In this case it seems like the input <code>x</code> is actually unchanged, so you don't even need to modify it like this, you can just pass along a start and stride in the recursive calls</p>",
        "id": 350145805,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681559925
    },
    {
        "content": "<p>Yeah, I was just suggesting that you can package that up as a subarray-with-step-size</p>",
        "id": 350145880,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681559952
    },
    {
        "content": "<p>and it might be useful to have a function to turn a subarray into an array and some theory connecting the two when it comes to proving the FFT is correct</p>",
        "id": 350146184,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681560040
    },
    {
        "content": "<p>once you do theory you probably want to go back to functions</p>",
        "id": 350146249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681560071
    },
    {
        "content": "<p>I just noticed that <code>level n</code> is calculated in a very suboptimal way. I really hope the compiler does good things to that definition</p>",
        "id": 350146549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681560173
    },
    {
        "content": "<p>In my version of <code>level</code> I switched it to recurse on <code>2 * level n</code></p>",
        "id": 350148366,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681560785
    },
    {
        "content": "<p>I think you're right that raw functions are too difficult to use in a reliable way. But, wrapping them up in a <code>Vector</code> structure seems to work fine (and, plus, you can use dot notation). This runs pretty much instantly:</p>",
        "id": 350148652,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681560860
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.ZMod.Defs</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Matrix.DotProduct</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.LibrarySearch</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Linarith</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Cases</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Data.Array.Basic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Matrix</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">elts</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Vector.memoize</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">n</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">Array.ofFn</span> <span class=\"n\">f.elts</span>\n  <span class=\"o\">{</span> <span class=\"n\">elts</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.get</span> <span class=\"o\">(</span><span class=\"n\">Array.size_ofFn</span> <span class=\"n\">f.elts</span> <span class=\"bp\">▸</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Vector.negate</span> <span class=\"o\">[</span><span class=\"n\">Neg</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">n</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">elts</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">-</span> <span class=\"n\">f.elts</span> <span class=\"n\">i</span>\n\n<span class=\"c1\">--  level n = 2 ^ n</span>\n<span class=\"kd\">def</span> <span class=\"n\">level</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>   <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">level</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">index_ok₁</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i.val</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">hi</span> <span class=\"o\">:=</span> <span class=\"n\">Fin.is_lt</span> <span class=\"n\">i</span>\n  <span class=\"n\">linarith</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">index_ok₀</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i.val</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">K</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Nat.lt_of_succ_lt</span> <span class=\"o\">(</span><span class=\"n\">index_ok₁</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">index_ok</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">i.val</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">level</span> <span class=\"n\">t.succ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">index_ok₁</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">for_eve</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">n.succ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">k.val</span><span class=\"o\">,</span> <span class=\"n\">Nat.lt_of_succ_lt</span> <span class=\"o\">(</span><span class=\"n\">index_ok</span> <span class=\"n\">k</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">for_odd</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">n.succ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">k.val</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">index_ok</span> <span class=\"n\">k</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">append</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">level</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">level</span> <span class=\"n\">t</span> <span class=\"bp\">+</span> <span class=\"n\">level</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">level</span><span class=\"o\">,</span> <span class=\"n\">two_mul</span><span class=\"o\">]</span>\n  <span class=\"n\">Vector.memoize</span>\n    <span class=\"o\">{</span> <span class=\"n\">elts</span> <span class=\"o\">:=</span> <span class=\"n\">this</span> <span class=\"bp\">▸</span> <span class=\"n\">Fin.append</span>\n        <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.elts</span> <span class=\"n\">j</span> <span class=\"bp\">+</span> <span class=\"n\">ω</span> <span class=\"bp\">^</span> <span class=\"n\">j.val</span> <span class=\"bp\">*</span> <span class=\"n\">b.elts</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.elts</span> <span class=\"n\">j</span> <span class=\"bp\">-</span> <span class=\"n\">ω</span> <span class=\"bp\">^</span> <span class=\"n\">j.val</span> <span class=\"bp\">*</span> <span class=\"n\">b.elts</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Vector.reindex</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">elts</span> <span class=\"o\">:=</span> <span class=\"n\">f.elts</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">transform_fast</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">transform_fast</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"bp\">*</span> <span class=\"n\">ω</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x.reindex</span> <span class=\"n\">for_eve</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">transform_fast</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"bp\">*</span> <span class=\"n\">ω</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x.reindex</span> <span class=\"n\">for_odd</span><span class=\"o\">)</span>\n    <span class=\"n\">append</span> <span class=\"n\">ω</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span>\n<span class=\"kd\">def</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">level</span> <span class=\"n\">e</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Vector'</span> <span class=\"o\">:=</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">level</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FNTS</span> <span class=\"o\">:</span> <span class=\"n\">Vector'</span> <span class=\"bp\">→</span> <span class=\"n\">Vector'</span> <span class=\"o\">:=</span> <span class=\"n\">transform_fast</span> <span class=\"n\">e</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FNTT</span> <span class=\"o\">:</span> <span class=\"n\">Vector'</span> <span class=\"bp\">→</span> <span class=\"n\">Vector'</span> <span class=\"o\">:=</span> <span class=\"n\">Vector.negate</span> <span class=\"bp\">∘</span> <span class=\"n\">transform_fast</span> <span class=\"n\">e</span> <span class=\"mi\">6</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Vector'.of</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">ZMod</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Vector'</span> <span class=\"n\">where</span>\n  <span class=\"n\">elts</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.get</span><span class=\"bp\">!</span> <span class=\"n\">i</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">FNTS</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Vector'.of</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">9</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">elts</span>\n<span class=\"c1\">-- ![1, 6, 8, 10, 16, 15, 14, 6, 14, 0, 14, 8, 3, 3, 2, 12]</span>\n</code></pre></div>",
        "id": 350148664,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681560863
    },
    {
        "content": "<p>Thank you guys very much for your help! Now, I don't want to take even more of your time than I already did. I suggest we stop the discussion here.</p>",
        "id": 350148722,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681560880
    },
    {
        "content": "<p>Don't worry, I'm looking at this because it revealed accidental performance gotchas and I'm learning something.</p>\n<p>If you're meaning \"I do not want to see any more discussion about this\" then I suppose if there's anything more to say we can create a new topic.</p>",
        "id": 350149823,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681561227
    },
    {
        "content": "<p>I like the discussion. I am just feeling guilty for taking less from it than you put into it.</p>",
        "id": 350149965,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1681561281
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20FFT.20.28code.20review.29/near/350146549\">said</a>:</p>\n<blockquote>\n<p>I just noticed that <code>level n</code> is calculated in a very suboptimal way. I really hope the compiler does good things to that definition</p>\n</blockquote>\n<p>I suggested it be written this way such that the defeq was just right for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.add_cases#doc\">docs4#Fin.add_cases</a> and friends. If you're not going to use that feature you may as well just use <code>2^n</code> again</p>",
        "id": 350164982,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681566251
    },
    {
        "content": "<p>I assume <code>let x := level n; x + x</code> would be as efficient as the <code>2*level n</code> spelling?</p>",
        "id": 350165135,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681566315
    }
]