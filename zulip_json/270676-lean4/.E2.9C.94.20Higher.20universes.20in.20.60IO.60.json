[
    {
        "content": "<p>It seems that <code>IO</code> has the type <code>Type -&gt; Type</code> and not <code>Type u -&gt; Type u</code>. Why is this the case and is there any workaround if I need to store a type of type <code>Type 1</code> inside the <code>IO</code> monad?</p>\n<p>Thanks,<br>\nTage</p>",
        "id": 359724467,
        "sender_full_name": "Tage Johansson",
        "timestamp": 1684516680
    },
    {
        "content": "<p>While in theory you can have monads with other universes, in practice you really need everything in the program to be using the same IO, and this makes it kind of impractical to use IO at higher universes</p>",
        "id": 359725735,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684516983
    },
    {
        "content": "<p>The usual suggestion I would have for embedding higher universe types in IO is to turn back / <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> your problem because I doubt it's really necessary</p>",
        "id": 359725958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684517044
    },
    {
        "content": "<p>You can also use <code>unsafeCast</code> to get around universe issues, although you have to make an opaque wrapper to use it from regular lean code. <code>Dynamic</code> is a more typesafe way to smuggle big types in a small universe, it uses <code>unsafeCast</code> under the hood</p>",
        "id": 359726975,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684517314
    },
    {
        "content": "<p>Why is it the case that you need the whole program to use the same universe of IO?</p>",
        "id": 359730933,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684518266
    },
    {
        "content": "<p>because you can't use <code>bind</code> between an IO.{u} and IO.{v} action</p>",
        "id": 359733529,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684518969
    },
    {
        "content": "<p>so anything transitively reachable from the <code>main</code> function has to use the same <code>IO.{u}</code> as main does</p>",
        "id": 359733618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684518996
    },
    {
        "content": "<p>which... is your whole program</p>",
        "id": 359733676,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684519012
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Higher.20universes.20in.20.60IO.60/near/359733529\">said</a>:</p>\n<blockquote>\n<p>because you can't use <code>bind</code> between an IO.{u} and IO.{v} action</p>\n</blockquote>\n<p>Why not?</p>",
        "id": 359734018,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684519103
    },
    {
        "content": "<p>because <code>Monad</code> does not supply a universe-polymorphic <code>bind</code> function</p>",
        "id": 359734094,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684519129
    },
    {
        "content": "<p>We have universe-polymorphic <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.bind#doc\">docs4#List.bind</a></p>",
        "id": 359734123,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684519143
    },
    {
        "content": "<p>Why not have a universe-polymorphic <code>IO.bind</code>?</p>",
        "id": 359734149,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684519155
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Higher.20universes.20in.20.60IO.60/near/359734094\">said</a>:</p>\n<blockquote>\n<p>because <code>Monad</code> does not supply a universe-polymorphic <code>bind</code> function</p>\n</blockquote>\n<p>I have argued before that this is an oversight, but I guess it's not one that any cares about enough to justify the time investment to fix</p>",
        "id": 359734235,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684519189
    },
    {
        "content": "<p>Because Monad is a class and it can't abstract over a universe-polymorphic thing</p>",
        "id": 359734887,
        "sender_full_name": "Reid Barton",
        "timestamp": 1684519337
    },
    {
        "content": "<p>Not that kind of polymorphism. <code>Monad</code> takes an argument <code>m : Type u -&gt; Type v</code>, and that means that the <code>bind</code> function only operates on elements of <code>Type u</code>. This is weaker than monads in practice, which can often vary the universe between <code>x</code> and <code>f</code>. Compare the signature of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Bind.bind#doc\">docs4#Bind.bind</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.bind#doc\">docs4#List.bind</a></p>",
        "id": 359735082,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684519397
    },
    {
        "content": "<p>You would need a <code>forall {u}</code> quantifier to be able to express the kind of polymorphism you need here</p>",
        "id": 359735329,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684519475
    },
    {
        "content": "<p>specifically, <code>Monad : (forall {u}, Type u -&gt; Type u) -&gt; Type ???</code></p>",
        "id": 359735491,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684519524
    },
    {
        "content": "<p>Not if you redesign the <code>Monad</code> typeclass as discussed <a href=\"#narrow/stream/270676-lean4/topic/universe.20polymorphic.20IO/near/282613597\">here</a>. Universe quantification can be achieved by moving the quantifier into the typeclass parameters.</p>",
        "id": 359737713,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684520226
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Higher.20universes.20in.20.60IO.60/near/359733529\">said</a>:</p>\n<blockquote>\n<p>because you can't use <code>bind</code> between an IO.{u} and IO.{v} action</p>\n</blockquote>\n<p>If you're willing to get your hands dirty on the internals, it's possible:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">PIO</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">StateM</span> <span class=\"o\">(</span><span class=\"n\">ULift</span> <span class=\"n\">IO.RealWorld</span><span class=\"o\">)</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">PIO.changeUniv</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">PIO.</span><span class=\"o\">{</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ULift.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">PIO.</span><span class=\"o\">{</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ULift.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">w</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">k</span> <span class=\"o\">⟨</span><span class=\"n\">w</span><span class=\"o\">⟩</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">w</span><span class=\"o\">⟩⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">w</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">PIO.lift0</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">PIO</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">PIO.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ULift</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">PIO.changeUniv</span> <span class=\"o\">(</span><span class=\"n\">ULift.up</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">PIO.toBaseIO</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">PIO.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">BaseIO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">w</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">k</span> <span class=\"o\">⟨</span><span class=\"n\">w</span><span class=\"o\">⟩</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">w</span><span class=\"o\">⟩⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"o\">⟨⟩</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">MonadLift</span> <span class=\"n\">BaseIO</span> <span class=\"n\">PIO</span> <span class=\"n\">where</span>\n  <span class=\"n\">monadLift</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">w</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">k</span> <span class=\"n\">w</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"n\">a</span> <span class=\"n\">w</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">w</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ex</span> <span class=\"o\">:</span> <span class=\"n\">BaseIO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">PIO.toBaseIO</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">α</span> <span class=\"bp\">←</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"mi\">10</span><span class=\"o\">)</span>\n  <span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">PIO.lift0</span> <span class=\"k\">do</span> <span class=\"o\">(</span><span class=\"n\">IO.println</span> <span class=\"s2\">\"foo\"</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toBaseIO</span>\n  <span class=\"n\">return</span> <span class=\"n\">α</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">ex</span>\n</code></pre></div>",
        "id": 359737891,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1684520286
    },
    {
        "content": "<p>I think this is only marginally better than using <code>unsafeCast</code></p>",
        "id": 359738218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684520403
    },
    {
        "content": "<p>Agreed it doesn't buy you much since you can't prove anything about IO anyhow.  But I'd still suggest using a typesafe wrapper around <code>unsafeCast</code> like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Dynamic#doc\">docs4#Dynamic</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/uchange\">docs#uchange</a></p>",
        "id": 359755844,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1684525998
    },
    {
        "content": "<p>Thanks for the help! <code>Dynamic</code> works fine for me! <code>uchange</code> had been perfect, but it doesn't seems to be ported to mathlib4 yet. Is there a reason for that? Is <code>uchange</code> not possible in Lean 4?</p>",
        "id": 359865182,
        "sender_full_name": "Tage Johansson",
        "timestamp": 1684580976
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"544752\">Tage Johansson</span> has marked this topic as resolved.</p>",
        "id": 359962750,
        "sender_full_name": "Notification Bot",
        "timestamp": 1684619932
    }
]