[
    {
        "content": "<p>Consider this expression:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"k\">#check</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>The type is <code>Type (u + 1)</code>, as expected.</p>\n<p>However, if I were to construct this expression from its building blocks (the use case is expression generation from SMT solvers, etc.) as such:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">metaM</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">bindName</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"a\"</span><span class=\"bp\">.</span><span class=\"n\">toName</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">domain</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Level</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">param</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s2\">\"u\"</span><span class=\"bp\">.</span><span class=\"n\">toName</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">uMVar</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta.mkFreshLevelMVar</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">forallE</span><span class=\"w\"> </span><span class=\"n\">bindName</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">sort</span><span class=\"w\"> </span><span class=\"n\">domain</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">`List</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">uMVar</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">bvar</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">default</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta.inferType</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"n\">println</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"s2\">\"e: {← Meta.ppExpr e}\"</span>\n<span class=\"w\">  </span><span class=\"n\">println</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"s2\">\"t: {← Meta.ppExpr t}\"</span>\n\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Environment</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">importModules</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">imports</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"s2\">\"Init\"</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">module</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">str.toName</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">runtimeOnly</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"o\">}))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">opts</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{})</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">trustLevel</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">coreM</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Meta.MetaM.run'</span><span class=\"w\"> </span><span class=\"n\">metaM</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">coreContext</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lean.Core.Context</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">currNamespace</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"PrintExpr\"</span><span class=\"bp\">.</span><span class=\"n\">toName</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">openDecls</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\">     </span><span class=\"c1\">-- No 'open' directives needed</span>\n<span class=\"w\">    </span><span class=\"n\">fileName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"&lt;stdin&gt;\"</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">fileMap</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">source</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">positions</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"n\">options</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Lean.Options.empty</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">coreM.run'</span><span class=\"w\"> </span><span class=\"n\">coreContext</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">toBaseIO</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"n\">exception</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">IO.println</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{← exception.toMessageData.toString}\"</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\">            </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">IO.println</span><span class=\"w\"> </span><span class=\"s2\">\"Finished\"</span>\n</code></pre></div>\n<p>The resulting type is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"n\">t</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Is there a way for Lean to automatically resolve <code>?u.1</code> during the generation of the call to <code>List</code>?</p>\n<p>I read <code>elabAppFnId</code>, but in this case I don't have the types for the intermediate expression building blocks, so I can't use it.</p>",
        "id": 456375367,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1722798222
    },
    {
        "content": "<p>Functions like <code>Expr.app</code> etc. are very low-level — they're just constructors. You need to use higher-level meta functions such as mkAppM to build expressions while doing unification.</p>",
        "id": 456399100,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1722809985
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Resolve.20all.20level.20mvars/near/456399100\">said</a>:</p>\n<blockquote>\n<p>Functions like <code>Expr.app</code> etc. are very low-level — they're just constructors. You need to use higher-level meta functions such as mkAppM to build expressions while doing unification.</p>\n</blockquote>\n<p>so I should use a function like <code>Meta.withNewLocalInstances</code> to bring every binder in <code>.lambdaE</code> and <code>.forallE</code> into scope and build expressions with free variables only?</p>",
        "id": 456399206,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1722810060
    },
    {
        "content": "<p>Or, rather than using a level metavariable, you compute the level</p>",
        "id": 456399212,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1722810063
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Resolve.20all.20level.20mvars/near/456399212\">said</a>:</p>\n<blockquote>\n<p>Or, rather than using a level metavariable, you compute the level</p>\n</blockquote>\n<p>is there a function to do this</p>",
        "id": 456399229,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1722810078
    },
    {
        "content": "<p>That's not what <code>Meta.withNewLocalInstances</code> does. This function is responsible for updating the instance cache <em>after</em> you've brought every binder into scope using something like forallTelescope</p>",
        "id": 456399317,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1722810164
    },
    {
        "content": "<p>Take a look at the AppBuilder module to see how to create complete expressions. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.mkEq#doc\">docs#Lean.Meta.mkEq</a> is an example</p>",
        "id": 456399356,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1722810226
    },
    {
        "content": "<p>(And as a consistency check, you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.check#doc\">docs#Lean.Meta.check</a> to typecheck completed expressions)</p>",
        "id": 456399441,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1722810293
    },
    {
        "content": "<blockquote>\n<p>I read <code>elabAppFnId</code>, but in this case I don't have the types for the intermediate expression building blocks, so I can't use it.</p>\n</blockquote>\n<p>That's a <code>private</code> function and you're not meant to use it. An alternative to mkAppM/mkAppOptM for the TermElabM monad is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Term.elabAppArgs#doc\">docs#Lean.Elab.Term.elabAppArgs</a>, which is the core algorithm for elaborating function applications. If your terms aren't complicated then there's no need to use it, but it's sometimes helpful in in some contexts.</p>",
        "id": 456399809,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1722810620
    },
    {
        "content": "<p>Is there a way to calculate the level at the invocation point? I already have the entire expression structure but it is just stored in another format. The reason I didn't wnat to use <code>mkAppM</code> is because it would require me to bring the bound variables into scope using some sort of telescope mechanism</p>",
        "id": 456399846,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1722810656
    },
    {
        "content": "<p>Any reason you don't want to bring them into scope?</p>",
        "id": 456399870,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1722810679
    },
    {
        "content": "<p>There's no way to reliably calculate levels or types if your expressions have bvars — if you're working with bvars, you are mostly on your own.</p>",
        "id": 456399941,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1722810727
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Resolve.20all.20level.20mvars/near/456399941\">said</a>:</p>\n<blockquote>\n<p>There's no way to reliably calculate levels or types if your expressions have bvars — if you're working with bvars, you are mostly on your own.</p>\n</blockquote>\n<p>is there not a way to calculate them after the mvars have been created?</p>",
        "id": 456403686,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1722814060
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Resolve.20all.20level.20mvars/near/456399870\">said</a>:</p>\n<blockquote>\n<p>Any reason you don't want to bring them into scope?</p>\n</blockquote>\n<p>this would require me to invoke the AppBuilder module monads from the C side, which requires a lot of state tracking. If there's no way to determine levels or types without using monads I'll use them</p>",
        "id": 456403744,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1722814089
    },
    {
        "content": "<p>Is it out of the question to determine that <code>uMVar</code> is <code>u</code> when you construct your expression?</p>",
        "id": 456404103,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1722814413
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Resolve.20all.20level.20mvars/near/456399317\">said</a>:</p>\n<blockquote>\n<p>That's not what <code>Meta.withNewLocalInstances</code> does. This function is responsible for updating the instance cache <em>after</em> you've brought every binder into scope using something like forallTelescope</p>\n</blockquote>\n<p>Then what function should I use during the construction of a <code>.lam</code> or <code>.forallE</code> that brings into scope the argument and then abstract out the argument into a <code>.bvar</code>?</p>",
        "id": 456404108,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1722814423
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Resolve.20all.20level.20mvars/near/456404103\">said</a>:</p>\n<blockquote>\n<p>Is it out of the question to determine that <code>uMVar</code> is <code>u</code> when you construct your expression?</p>\n</blockquote>\n<p>yes, because the source expression representation in C does not carry universe information</p>",
        "id": 456404183,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1722814445
    },
    {
        "content": "<p>There are a few, for example withLocalDeclD, which then you use mkForallFVars and mkLambdaFVars to create terms rather than raw constructors.</p>",
        "id": 456404266,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1722814531
    },
    {
        "content": "<blockquote>\n<p>yes, because the source expression representation in C does not carry universe information</p>\n</blockquote>\n<p>It must be determinable in <em>some</em> way, otherwise how would Lean be able to solve for it through unification?</p>",
        "id": 456404368,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1722814598
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Resolve.20all.20level.20mvars/near/456404368\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>yes, because the source expression representation in C does not carry universe information</p>\n</blockquote>\n<p>It must be determinable in <em>some</em> way, otherwise how would Lean be able to solve for it through unification?</p>\n</blockquote>\n<p>I know but I don't know what algorithm I can use to determine them from the C side</p>",
        "id": 456404393,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1722814622
    },
    {
        "content": "<p>I'm afraid I can only give this general advice about constructing expressions without knowing a lot more about the concrete details about what you're working on.</p>",
        "id": 456404643,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1722814838
    },
    {
        "content": "<p>I don't have more details either, the representation I have is very general. I think I should just use <code>withLocalDeclD</code> and other functions</p>",
        "id": 456404715,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1722814871
    },
    {
        "content": "<p>A difference here is that you know what that representation is and I can only guess, and I don't know any of the constraints that you're dealing with — What part has to be in C? What part can be done in Lean? What the concrete representation? Can it be changed? If so, can it be changed to make this easier? etc. etc. etc.</p>",
        "id": 456405054,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1722815034
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Resolve.20all.20level.20mvars/near/456405054\">said</a>:</p>\n<blockquote>\n<p>A difference here is that you know what that representation is and I can only guess, and I don't know any of the constraints that you're dealing with — What part has to be in C? What part can be done in Lean? What the concrete representation? Can it be changed? If so, can it be changed to make this easier? etc. etc. etc.</p>\n</blockquote>\n<p>The C representation is the same as Lean's <code>Expr</code> but without the <code>.mdata</code>, <code>.proj</code>, and universe level informations. I cannot change it without major refactoring on the solver side</p>",
        "id": 456405324,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1722815127
    }
]