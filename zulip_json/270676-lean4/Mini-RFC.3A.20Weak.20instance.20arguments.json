[
    {
        "content": "<p>Lemmas meant for rewriting often have instance arguments that can be picked up from either the LHS or the RHS by unification, and the set of such instances can depending on whether the rewriting is in the forwards or backwards direction. For example, in the following lemma the <code>BEq</code> instance can be picked up from the LHS.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">List.erase_cons</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">List.erase</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">==</span> <span class=\"n\">a</span> <span class=\"k\">then</span> <span class=\"n\">xs</span> <span class=\"k\">else</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">List.erase</span> <span class=\"n\">xs</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">List.erase</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Right now, the semantics of <code>[...]</code> arguments are to always do typeclass instance synthesis, even if the instance was picked up via unification (and if it does, it makes sure that unified instance is defeq to the synthesized instance).</p>\n<p>The way to get instance arguments be picked up by unification is to use <code>{...}</code> arguments instead. However, this can entail writing two versions of each rewrite lemma, depending on whether they're meant to be applied in the forward or backward direction.</p>\n<p>There were some experiments we did in mathlib during the port earlier this year, and we found that eagerly synthesizing instance arguments could be very expensive, to the point that some examples deep in the algebraic hierarchy would time out. Switching some key lemmas to use <code>{...}</code> arguments instead would make things go through instantly (both rewrites and <code>apply</code>/<code>refine</code> proofs).</p>",
        "id": 404449998,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701103313
    },
    {
        "content": "<p><strong>Idea:</strong> What if there were a <code>[{...}]</code> binder type that is like <code>{...}</code>, but if it has not been unified with anything, it invokes typeclass instance synthesis?</p>\n<p>If this is workable, it would let us write rewrite lemmas that can be applied both in the forward and backward direction while picking up instances through unification, without needing to write two versions of such lemmas. This would also let us more easily work with overlapping Decidable and Fintype instances, which we tend to run into in mathlib, but which in practice are harmless because they are Subsingleton types.</p>",
        "id": 404450140,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701103349
    },
    {
        "content": "<p>This <code>[{...}]</code> binder type would be similar (or the same as?) the way <code>[...]</code> arguments elaborated in the Lean 3 community edition. The mathlib library is designed with this elaboration strategy in mind.</p>",
        "id": 404450144,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701103352
    },
    {
        "content": "<p><strong>Alternative idea:</strong> <code>rw</code> and <code>simp</code> could know how to analyze rewrite lemmas and change <code>[...]</code> binders to <code>{...}</code> binders if they can be solved by unification. This would be less invasive of a change to the core language, but on the other hand this wouldn't let the feature activate in term proofs.</p>",
        "id": 404450147,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701103353
    },
    {
        "content": "<p>(More ideas are welcome. These <code>[{...}]</code> binders are just something that crossed my mind today as a way to preserve the current meaning of <code>[...]</code>, which is good because it ensures instances are canonical, while letting us selectively weaken that guarantee for performance and applicability reasons.)</p>",
        "id": 404450914,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701103593
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Mini-RFC.3A.20Weak.20instance.20arguments/near/404449998\">said</a>:</p>\n<blockquote>\n<p>Right now, the semantics of <code>[...]</code> arguments are to always do typeclass instance synthesis, even if the instance was picked up via unification (and if it does, it makes sure that unified instance is defeq to the synthesized instance).</p>\n</blockquote>\n<p>Is there a good reason for these semantics? What would break if we took your proposed semantics for <code>[{...}]</code>, but just applied them to <code>[...]</code>?</p>",
        "id": 404451183,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701103684
    },
    {
        "content": "<p>Which is to say; I'm not convinced that<code>[...]</code> is actually meaningfully protecting against non-canonical instances</p>",
        "id": 404451410,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701103769
    },
    {
        "content": "<p>Is the danger that you pick up instances with <code>Eq.mpr</code> terms in?</p>",
        "id": 404451445,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701103784
    },
    {
        "content": "<p>I think ensuring instances are canonical is a good reason, but you're asking \"is resynthesizing instances necessary for this purpose\", right?</p>\n<p>I'm not sure myself what are practical examples of incorrect instances that can pop up. I guess one example might be if you rewrite <code>Multiplicative X = X</code>. Or perhaps there is some rewrite lemma that introduces a noncanonical instance into a term, and you don't want <code>simp</code> (or other automation) to run wild with it.</p>",
        "id": 404452717,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701104190
    },
    {
        "content": "<p>I think my claim is two-fold:</p>\n<ul>\n<li>It's quite rare to get a non-canonical instance in the first place, and almost always when it happens, it was deliberate.</li>\n<li>Canonicity is subjective, and in the presence of instance diamonds <del>(like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi.has_smul%27%27\">docs3#pi.has_smul''</a>)</del> resynthesizing presumably won't save you anyway?</li>\n</ul>",
        "id": 404455325,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701105022
    },
    {
        "content": "<p>I will agree that this resynthesisation behaviour is odd, and possibly not wanted. Is it a small change to remove this from Lean4 core, and try to see whether as a further bonus it would significantly speedup mathlib4 to remove it?</p>",
        "id": 404469316,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1701110253
    },
    {
        "content": "<p>The resynthesization behavior is intentional and wanted by the core developers.</p>\n<p>To turn it off, it might take some work to make sure typeclass synthesis is well-behaved. It eagerly synthesizes instances and only defers them if it can't make progress. In the <code>[{...}]</code> proposal, the synthesis would not be eager, and it would only kick in if it doesn't end up finding an instance through unification.</p>\n<p>Switching to that globally would be a big change in elaboration, and it doesn't seem like a good default to me.</p>",
        "id": 404471276,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701111041
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Mini-RFC.3A.20Weak.20instance.20arguments/near/404455325\">said</a>:</p>\n<blockquote>\n<p>Canonicity is subjective</p>\n</blockquote>\n<p>I think the assumption is that every way of synthesizing a particular instance is supposed to be defeq to one another, and that defeq equivalence class is \"the\" canonical instance. I know some diamonds are particularly stubborn though.</p>\n<p>Of course, we break this rule with Fintype and Decidable in mathlib... and I'd hate to have to resolve these diamonds since we generally don't care which instance was found for these so long as there is one.</p>",
        "id": 404472498,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701111566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Mini-RFC.3A.20Weak.20instance.20arguments/near/404471276\">said</a>:</p>\n<blockquote>\n<p>The resynthesization behavior is intentional and wanted by the core developers.</p>\n<p>To turn it off, it might take some work to make sure typeclass synthesis is well-behaved. It eagerly synthesizes instances and only defers them if it can't make progress. In the <code>[{...}]</code> proposal, the synthesis would not be eager, and it would only kick in if it doesn't end up finding an instance through unification.</p>\n<p>Switching to that globally would be a big change in elaboration, and it doesn't seem like a good default to me.</p>\n</blockquote>\n<p>I understand that it is intentional, sorry. I meant to say that with the context of Mathlib, it may require a big redesign to make it work properly, and I feel like the advantages of the system are probably poorly-understood compared to our current instance design.</p>",
        "id": 404476131,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1701113208
    },
    {
        "content": "<p>I know Lean 3 community edition had changes related to typeclass instance synthesis, which we made use of in mathlib, but I've realized I'm hazy on the details. <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>: I think I remember you made the changes -- did you do anything other than how <code>simp</code> processes instance arguments to simp lemmas?</p>",
        "id": 404482128,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701115694
    },
    {
        "content": "<p>Perhaps there's a compromise here where <code>[...]</code> allows <code>Subsingleton</code> checking (when checking canonicity)</p>",
        "id": 404485130,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701117143
    },
    {
        "content": "<p>That would eliminate issues with <code>Decidable</code> and <code>Fintype</code></p>",
        "id": 404485151,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701117154
    },
    {
        "content": "<p>To make that reliable, I think we need to defer synthesizing these instances until after unification has a chance to fill them in. If we just turn the isDefEq check off, then there might be enough information to solve for a non-defeq instance sooner, or to decide to throw a \"cannot synthesize instance\" error.</p>",
        "id": 404485661,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701117381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Mini-RFC.3A.20Weak.20instance.20arguments/near/404482128\">said</a>:</p>\n<blockquote>\n<p>I know Lean 3 community edition had changes related to typeclass instance synthesis, which we made use of in mathlib, but I've realized I'm hazy on the details. <span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span>: I think I remember you made the changes -- did you do anything other than how <code>simp</code> processes instance arguments to simp lemmas?</p>\n</blockquote>\n<p>The important changes are in <a href=\"https://github.com/leanprover-community/lean/pull/657\">leanprover-community/lean#657</a> and <a href=\"https://github.com/leanprover-community/lean/pull/659\">leanprover-community/lean#659</a>. Previously in certain cases, the elaborator would stop when it could not synthesize an instance because it had metavariables, even though those metavariables can be filled in by <code>out_param</code>s of an instance appearing later. I believe Lean 4 already takes into account these things when determining synthesis order, so it's not so relevant here.</p>",
        "id": 404583429,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1701164752
    },
    {
        "content": "<p>Thanks. I tried porting a couple of the test files to Lean 4, and it does seem that Lean 4 takes these into account, and now I'm confused about what is the difference between Lean 3 and Lean 4.</p>\n<p>I just read through elaborator code from Lean 3 to remind myself how typeclass instance synthesis worked, and it seems to have <em>very</em> similar logic to the Lean 4 version. It even has <a href=\"https://github.com/leanprover-community/lean/blob/master/src/frontends/lean/elaborator.cpp#L3630-L3638\">the defeq check</a>, same as in Lean 4, so we can't say Lean 4 is any different from Lean 3 for resynthesizing instances so often, as least while elaborating.</p>\n<p>I guess we need to find some concrete examples that demonstrate elaboration differences.</p>\n<p>We can also do experiments by writing a term elaborator that transforms lemmas by converting instance implicit arguments to implicit arguments that can be inferred by unification.</p>",
        "id": 404672995,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701189196
    },
    {
        "content": "<p>I thought the difference was as you described in the original post: Lean 3 would not try to synthesize instances found by unification, but indeed I can't easily find in the 3 elaborator where these would be assigned.</p>",
        "id": 404677906,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1701190712
    },
    {
        "content": "<p>I can't quickly come up with an example that shows the difference.</p>",
        "id": 404680875,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1701191639
    },
    {
        "content": "<p>Yeah, but I haven't been able to find where in the elaborator Lean 3 wouldn't resynthesize instances during elaboration. Nothing checks that the metavariable is already assigned, and so long as it's an instance implicit argument, the argument gets synthesized.</p>\n<p>Maybe one feature that gave us a different impression is the new behavior of <code>@</code>, since it doesn't fully switch arguments into being explicit arguments like it did in Lean 3, where in Lean 4 you have to write <code>(_)</code> instead of <code>_</code> to make an instance implicit argument not synthesize.</p>",
        "id": 404686715,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701193914
    },
    {
        "content": "<p>Random thought right before I step into the shower: does the same hold for instances encountered when instance search is already going on? For example, let's say we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">Bar</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">Baz</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Foo</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">Bar</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">P.foo</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">P</span> <span class=\"n\">where</span>\n<span class=\"kd\">instance</span> <span class=\"n\">P.baz</span> <span class=\"o\">:</span> <span class=\"n\">Baz</span> <span class=\"n\">P</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span> <span class=\"c1\">-- Does this look for a `Foo P` instance or use the `Foo` argument to `P.bar`?</span>\n</code></pre></div>",
        "id": 404926491,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1701282354
    },
    {
        "content": "<p>I should really wrap up for today but it feels like we might want to look in this direction. Maybe that also explains why <a href=\"https://github.com/leanprover-community/mathlib4/pull/8386\">#8386</a> seems to cause so many timeouts?</p>",
        "id": 404926643,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1701282405
    },
    {
        "content": "<p>The idea seems correct! In Lean 3:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">Bar</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">Baz</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Foo</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">Bar</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">P.foo</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n<span class=\"kd\">instance</span> <span class=\"n\">P.baz</span> <span class=\"o\">:</span> <span class=\"n\">Baz</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.class_instances</span> <span class=\"n\">true</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">[class_instances]  class-instance resolution trace</span>\n<span class=\"cm\">[class_instances] (0) ?x_0 : Bar P := @Baz.to_Bar ?x_1 ?x_2 ?x_3</span>\n<span class=\"cm\">[class_instances] (1) ?x_3 : @Baz P ?x_2 := P.baz</span>\n<span class=\"cm\">[class_instances] caching instance for @Baz P P.foo</span>\n<span class=\"cm\">P.baz</span>\n<span class=\"cm\">[class_instances] caching instance for Bar P</span>\n<span class=\"cm\">@Baz.to_Bar P P.foo P.baz</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>in Lean 4:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">Bar</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">Baz</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Foo</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">Bar</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">P.foo</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">P</span> <span class=\"n\">where</span>\n<span class=\"kd\">instance</span> <span class=\"n\">P.baz</span> <span class=\"o\">:</span> <span class=\"n\">Baz</span> <span class=\"n\">P</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.synthInstance</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span> <span class=\"c1\">-- Does this look for a `Foo P` instance or use the `Foo` argument to `P.bar`?</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">[Meta.synthInstance] ✅ Bar P ▼</span>\n<span class=\"cm\">  [] new goal Bar P ▶</span>\n<span class=\"cm\">  [] ✅ apply @Baz.toBar to Bar P ▼</span>\n<span class=\"cm\">    [tryResolve] ✅ Bar P ≟ Bar P</span>\n<span class=\"cm\">    [] new goal Foo P ▶</span>\n<span class=\"cm\">  [] ✅ apply P.foo to Foo P ▼</span>\n<span class=\"cm\">    [tryResolve] ✅ Foo P ≟ Foo P</span>\n<span class=\"cm\">  [resume] propagating Foo P to subgoal Foo P of Bar P ▶</span>\n<span class=\"cm\">  [] ✅ apply P.baz to Baz P ▼</span>\n<span class=\"cm\">    [tryResolve] ✅ Baz P ≟ Baz P</span>\n<span class=\"cm\">  [resume] propagating Baz P to subgoal Baz P of Bar P ▶</span>\n<span class=\"cm\">  [] result Baz.toBar</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 405073431,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1701336064
    }
]