[
    {
        "content": "<p>Sometimes it would be nice to able to change Lean's default choices for binder types on typeclass projections. Example from mathlib4:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">CharP</span> <span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">â„•</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">cast_eq_zero_iff'</span> <span class=\"o\">:</span> <span class=\"bp\">âˆ€</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">â„•</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">â†”</span> <span class=\"n\">p</span> <span class=\"bp\">âˆ£</span> <span class=\"n\">x</span>\n\n<span class=\"c1\">-- porting note: the field of the structure had implicit arguments where they were</span>\n<span class=\"c1\">-- explicit in Lean 3</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">CharP.cast_eq_zero_iff</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">â„•</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CharP</span> <span class=\"n\">R</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">â„•</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">â†”</span> <span class=\"n\">p</span> <span class=\"bp\">âˆ£</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n  <span class=\"n\">CharP.cast_eq_zero_iff'</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>Here the binder type for <code>R</code> on <code>CharP.cast_eq_zero_iff'</code> is implicit. But in practice we want an explicit binder type here, and in Lean 4 this necessitates making a \"bogus\" primed field for the <code>CharP</code> class, instantly defining the correct field with the right binder type, and then having to explain to newcomers why, when making new instances of this class, the name of the field has got some weird prime in which never shows up in any code and is not supposed to be used anywhere. In Lean 3c we had the (very counterintuitive IMO) syntax</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">char_p</span> <span class=\"o\">[</span><span class=\"n\">add_monoid_with_one</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">â„•</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">cast_eq_zero_iff</span> <span class=\"o\">[]</span> <span class=\"o\">:</span> <span class=\"bp\">âˆ€</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">â„•</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">â†”</span> <span class=\"n\">p</span> <span class=\"bp\">âˆ£</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>with the <code>[]</code> meaning \"make <code>R</code> have the <code>()</code> binder\", leading to more compact code (no need for an auxiliary definition) and a different kind of user confusion (\"what are those square brackets?\"). I'm no regex guru but searching for <code>\\(.*\\[\\] : </code> in mathlib3 gives me 165 hits, most of which look genuine. </p>\n<p>This just came up in a PR I was making to mathlib4 and it was suggested I open a Lean 4 issue, but reading the instructions there it advised me to bring this up on the Zulip first. Should I open this as an RFC issue on the lean 4 github repo? I think perhaps the most interesting discussion is suggestions of possible syntax; I think the lean 3c <code>[]</code> is not ideal, but IIRC we couldn't have <code>()</code> for some reason.</p>",
        "id": 423072202,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708712986
    },
    {
        "content": "<p>Maybe the syntax could be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">CharP</span> <span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">â„•</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n  <span class=\"n\">cast_eq_zero_iff'</span> <span class=\"o\">:</span> <span class=\"bp\">âˆ€</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">â„•</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">â†”</span> <span class=\"n\">p</span> <span class=\"bp\">âˆ£</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 423073673,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708713605
    },
    {
        "content": "<p>I agree the lean3 syntax was completely incomprehensible</p>",
        "id": 423073725,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708713629
    },
    {
        "content": "<p>One place where this would have been very useful is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.MonoidalCategory.tensorUnit#doc\">docs#CategoryTheory.MonoidalCategory.tensorUnit</a>; for now we <a href=\"https://github.com/leanprover-community/mathlib4/blob/86b84c52880e799449226c39569a69a0483b7646/Mathlib/CategoryTheory/Monoidal/Category.lean#L125-L132\">work around the argument explicitness</a> with a custom notation and elaborator that pretends it is explicit</p>",
        "id": 423074146,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708713810
    },
    {
        "content": "<p>The situation at the moment is worse for data fields (like <code>tensorUnit</code> and <code>HopfAlgebra.antipode</code>) than it is for prop fields, since if you make primed and unprimed versions of your data, you now need to do the same for all the proof fields that mention that data</p>",
        "id": 423075857,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708714508
    },
    {
        "content": "<p>That data issue came up several times during porting. I consider this one area of our \"technical debt\" as discussed at the last meeting.</p>",
        "id": 423098417,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708724170
    },
    {
        "content": "<p>So am I allowed to make an RFC on the Lean repo now?</p>",
        "id": 423498704,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708988069
    },
    {
        "content": "<p>This was removed long ago - <a href=\"#narrow/stream/270676-lean4/topic/Workaround.20for.20.60.7B.7D.60.20annotation.20in.20structures/near/278993577\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Workaround.20for.20.60.7B.7D.60.20annotation.20in.20structures/near/278993577</a></p>",
        "id": 423509429,
        "sender_full_name": "FranÃ§ois G. Dorais",
        "timestamp": 1708993620
    },
    {
        "content": "<p>Well it's used over 100 times in mathlib3 and I've just spent quite a lot of pain creating this horrible workaround <a href=\"https://github.com/leanprover-community/mathlib4/tree/kbuzzard-coalgebra-refactor\">branch#kbuzzard-coalgebra-refactor</a> making a bunch of stuff more ugly (with more to come if I'm to push this through). If I could make R and A explicit in comul and counit it would be a lot less hassle</p>",
        "id": 423512367,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708995230
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/RFC.3A.20adjust.20argument.20explicitness.20on.20typeclass.20projections/near/423498704\">said</a>:</p>\n<blockquote>\n<p>So am I allowed to make an RFC on the Lean repo now?</p>\n</blockquote>\n<p>I think good advice for RFCs is to try to summarise the problem, but that it is better if you have ideas about a preferred solution that these go in comments, rather than the top post. There's no need to have disagreements about the solution get in the way about agreement about the problem.</p>",
        "id": 423523690,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1709002876
    },
    {
        "content": "<p>I thought an RFC is supposed to be an explanation of a design along with an analysis of the current situation and a comparative analysis of multiple alternative solutions. Just summarizing a problem sounds like a standard Issue to me.</p>",
        "id": 423525078,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709003792
    },
    {
        "content": "<p>A good RFC is a design document that, once accepted, is enough to go and implement the design.</p>",
        "id": 423525152,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709003868
    },
    {
        "content": "<p>Yes, you're right, and I said the wrong thing.</p>",
        "id": 423533842,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1709010402
    },
    {
        "content": "<p>I should have expressed it a hope that people writing issues and RFCs avoid writing: \"X is a problem, and should be fixed as Y\".</p>",
        "id": 423533889,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1709010435
    },
    {
        "content": "<p>That is, don't be prescriptive about what you think the solution should be, as then criticism of the proposed solution can implicitly derail the discussion of the existence of the problem.</p>",
        "id": 423533981,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1709010498
    },
    {
        "content": "<p>I'm not complaining about the good RFCs, I'm complaining about the bad ones. :-)</p>",
        "id": 423534011,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1709010528
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/270676-lean4/topic/RFC.3A.20adjust.20argument.20explicitness.20on.20typeclass.20projections/near/423533889\">said</a>:</p>\n<blockquote>\n<p>I should have expressed it a hope that people writing issues and RFCs avoid writing: \"X is a problem, and should be fixed as Y\".</p>\n</blockquote>\n<p>But if an RFC is a design document for a specific solution, won't it take that form? Or are you trying to say that the RFC shouldn't take that form because the problem should already be established by first opening an issue?</p>",
        "id": 423674434,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709059693
    },
    {
        "content": "<p>I tried to open an issue, but I was immediately forced to choose between a bug report and an RFC. I chose RFC and it told me I should discuss on Zulip first. That's how we got here.</p>",
        "id": 423675738,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709060193
    },
    {
        "content": "<p>What are some concrete examples of \"good RFCs\"? Maybe that would help communicate the intention here (which I also find a bit confusingâ€”sometimes there's a somewhat blurry line between a proposed design and a proposed implementation!).</p>",
        "id": 423708843,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1709072414
    },
    {
        "content": "<p>In the interest of not just forgetting this RFC, I think you should make the GitHub issue</p>",
        "id": 424446493,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709414342
    },
    {
        "content": "<p>Sorry for the delay; there was a student coursework deadline for my course this week and it's been quite hectic. <a href=\"https://github.com/leanprover/lean4/pull/3574\">lean4#3574</a> . Please feel free to edit/clarify/add comments; I am certainly not an expert in this area; all I knew was that the combination of having CoalgebraStruct and Coalgebra together with fields with bad binders was quite a mess to fix (and indeed I still haven't managed to get things working; I wouldn't even be doing this if I could choose my binders in the definition).</p>",
        "id": 424451825,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709419498
    },
    {
        "content": "<p>What do we think about solving this not by altering the syntax, but by making the binder list be interpreted with <code>variable</code> binder update rules?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">CharP</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">cast_eq_zero_iff'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">â†”</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">âˆ£</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>For a first version, the rules could be:</p>\n<ol>\n<li>Binder updates must come first. No writing <code>cast_eq_zero_iff' (x : â„•) (R) : (x : R) = 0 â†” p âˆ£ x</code>.</li>\n<li>To prevent confusion, shadowing in structure field binders won't be allowed. For example, <code>foo (p : Int) : ...</code> would not be allowed since it shadows the <code>p</code> parameter.</li>\n<li>The binder updates are applied to the <em>computed</em> projection type. The alternative is updating the binder kinds before adjusting implicitness. While doing it before could result in fewer binders that need updating (since the binder kinds for other parameters could adjust themselves based on what's now explicit/implicit), the results are likely to be hard to predict.</li>\n</ol>\n<p>I have things mostly set up now to be able to implement this.</p>",
        "id": 508584627,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743097788
    },
    {
        "content": "<p>Expanding on point 3, the current algorithm when generating projections includes these steps:</p>\n<ol>\n<li>generate the full type of the projection</li>\n<li>with some exceptions, reset the binder kinds of all the structure type parameters to be explicit</li>\n<li>run an inference procedure that makes explicit structure parameters be implicit if they can be inferred from types of later parameters or the return type</li>\n</ol>\n<p>My proposal here is that user-provided binder kind updates would be a step 4 to override the inferred kinds, rather than a step 2.5 that overrides kinds before the remaining kinds are inferred. As a step 4, all you need to do as a user is look at the type of a projection, decide you don't like some of the arguments, and override just those ones. However, if it were a step 2.5, you would have to iterate this process in trial-and-error, since it's likely no one really knows how to run this algorithm in their head. (It's subtle too, since the results can depend on whether a parameter appears within some instance in some parameter.)</p>",
        "id": 508585613,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743098090
    },
    {
        "content": "<p>I have an implementation of this at <a href=\"https://github.com/leanprover/lean4/pull/7742\">lean4#7742</a>, with some small differences:</p>\n<ul>\n<li>Only parameters in the declaration itself can be overriddenÂ â€” no parameters from <code>variables</code>. This is motivated by the fact that there are a number of cases where variables are clearly not meant to be parameters (see <a href=\"https://github.com/leanprover-community/mathlib4/pull/23469\">mathlib4#23469</a> for cases that needed to be fixed). Key design constraint: we cannot know whether <code>variable</code>s are going to be parameters or not when we have to decide whether a binder is an override. (The <code>variable .. in</code> proposal would avoid this.)</li>\n<li>Only a prefix of the binders are considered for overrides. Multi-identifier binders are allowed for overrides, but if any of the identifiers aren't possible parameters, then the whole binder isn't used for overrides, without any warnings.</li>\n</ul>\n<p>My thinking is that this might not be the finalized design, but we should have the feature in some capacity, and this version would let people get started applying it to mathlib.</p>",
        "id": 509090068,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743388857
    },
    {
        "content": "<p>I've created <a href=\"https://github.com/leanprover/lean4/pull/9072\">lean4#9072</a> with a related RFC for constructor argument explicitness</p>",
        "id": 526235227,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1751155479
    },
    {
        "content": "<p>Pinging this thread with what Eric said here: <a class=\"message-link\" href=\"/#narrow/channel/113488-general/topic/self.20and.20explicitVarsOfIff.20linter/near/547085632\">#general &gt; self and explicitVarsOfIff linter @ ðŸ’¬</a> </p>\n<p>Does allowing control over the explicitness ofÂ <code>self</code> seem like a reasonable continuation of this family of RFCs?</p>",
        "id": 547686780,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761735844
    }
]