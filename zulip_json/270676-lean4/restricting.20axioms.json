[
    {
        "content": "<p>Is there a way to limit the axioms used. For example to prevent the use of law of excluded middle?</p>\n<p>I want to prove decidability of a language: <code>String -&gt; Prop</code> for denotations of my inductive type.<br>\nSo basically I want to show that this is a <code>DecidablePred</code> and make sure via github's CI that I didn't use LEM by accident and make sure that I won't make the mistake in future as I update the code.</p>\n<p>Currently I know how to use <code>#print axioms decidableDenote</code> and this prints the axioms <code>[propext, Quot.sound]</code>. I want to make sure that this list is not expanded upon by accident, by me or my collaborators, which sounds like a job for CI. </p>\n<p>For reference here is my current proof: <a href=\"https://github.com/katydid/proofs/blob/main/Katydid/Regex/SimpleRegex.lean#L262\">https://github.com/katydid/proofs/blob/main/Katydid/Regex/SimpleRegex.lean#L262</a></p>",
        "id": 492983614,
        "sender_full_name": "awalterschulze",
        "timestamp": 1736526313
    },
    {
        "content": "<p>I think someone (<span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> ?) made this for lean 3, but I don't know if it exists for lean 4</p>",
        "id": 492983891,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1736526397
    },
    {
        "content": "<p>you could use <code>#guard_msgs</code> to ensure the message doesn't change?</p>",
        "id": 493008336,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736535382
    },
    {
        "content": "<p>i believe that raises an error when the provided message doesn't match the one it catches?</p>",
        "id": 493008431,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736535433
    },
    {
        "content": "<p>Why do you want to exclude em for this? If you show DecidablePred for something you have to provide an executable algorithm as a decision procedure, unless that one is marked noncomputable its always executable. Whether the proof of correctness for the procedure uses em doesnt matter for being able to execute the procedure.</p>",
        "id": 493015434,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1736538393
    },
    {
        "content": "<p>It should look something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">decidableDenote</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Regex</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decidable_of_iff</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">validate_commutes</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>(Untested of course, but you shouldn't be using tactics to create DecidablePred instances. They tend to have issues with reduction.)</p>",
        "id": 493016922,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1736539128
    },
    {
        "content": "<p>Like Henrik is asking, what's your specific use case for avoiding LEM?</p>",
        "id": 493017239,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1736539264
    },
    {
        "content": "<p>here is a implementation of command which detect classical axiom</p>\n<p><a href=\"https://lean-ja.github.io/lean-by-example/Diagnostic/Print.html#%E8%88%9E%E5%8F%B0%E8%A3%8F\">https://lean-ja.github.io/lean-by-example/Diagnostic/Print.html#%E8%88%9E%E5%8F%B0%E8%A3%8F</a></p>",
        "id": 501727827,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1740467528
    },
    {
        "content": "<p>Since this shows up every once in a while and I wanted to have something similar to grade my module, here is a linter that flags uses of <code>Classical.choice</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Util</span><span class=\"bp\">.</span><span class=\"n\">CollectAxioms</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">DeclarationNames</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">#  The \"detectClassical\" linter</span>\n\n<span class=\"cm\">The \"detectClassical\" linter emits a warning on declarations that depend on the `Classical.choice`</span>\n<span class=\"cm\">axiom.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Linter</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">The \"detectClassical\" linter emits a warning on declarations that depend on the `Classical.choice`</span>\n<span class=\"sd\">axiom.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">register_option</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">detectClassical</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">  </span><span class=\"n\">defValue</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"n\">descr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"enable the detectClassical linter\"</span>\n<span class=\"o\">}</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">The `linter.verbose.detectClassical` option is a flag to make the `detectClassical` linter emit</span>\n<span class=\"sd\">a confirmation on declarations that depend *not* on the `Classical.choice` axiom.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">register_option</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">verbose</span><span class=\"bp\">.</span><span class=\"n\">detectClassical</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">  </span><span class=\"n\">defValue</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"n\">descr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"enable the verbose setting for the detectClassical linter\"</span>\n<span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">DetectClassical</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Linter</span><span class=\"bp\">.</span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">detectClassical</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">detectClassicalLinter</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Linter</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">withSetOptionIn</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"n\">Linter</span><span class=\"bp\">.</span><span class=\"n\">getLinterValue</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">detectClassical</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getOptions</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">return</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">messages</span><span class=\"bp\">.</span><span class=\"n\">hasErrors</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">return</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">nms</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getNamesFrom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">stx</span><span class=\"bp\">.</span><span class=\"n\">getPos?</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"bp\">·.</span><span class=\"n\">getId</span><span class=\"bp\">.</span><span class=\"n\">isInternal</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">verbose?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Linter</span><span class=\"bp\">.</span><span class=\"n\">getLinterValue</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">verbose</span><span class=\"bp\">.</span><span class=\"n\">detectClassical</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getOptions</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">constStx</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">nms</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">constName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">constStx</span><span class=\"bp\">.</span><span class=\"n\">getId</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">collectAxioms</span><span class=\"w\"> </span><span class=\"n\">constName</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">verbose?</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"n\">logInfoAt</span><span class=\"w\"> </span><span class=\"n\">constStx</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"'{constName}' does not depend on any axioms\"</span>\n<span class=\"w\">      </span><span class=\"n\">return</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"n\">axioms</span><span class=\"bp\">.</span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"ss\">`Classical.choice</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">verbose?</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"n\">logInfoAt</span><span class=\"w\"> </span><span class=\"n\">constStx</span>\n<span class=\"w\">          </span><span class=\"n\">m!</span><span class=\"s2\">\"'{constName}' is non-classical and depends on axioms:</span><span class=\"se\">\\n</span><span class=\"s2\">{axioms.toList}\"</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">Linter</span><span class=\"bp\">.</span><span class=\"n\">logLint</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">detectClassical</span><span class=\"w\"> </span><span class=\"n\">constStx</span>\n<span class=\"w\">        </span><span class=\"n\">m!</span><span class=\"s2\">\"'{constName}' depends on 'Classical.choice'.</span><span class=\"se\">\\n\\n</span><span class=\"s2\">All axioms: {axioms.toList}</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span>\n\n<span class=\"n\">initialize</span><span class=\"w\"> </span><span class=\"n\">addLinter</span><span class=\"w\"> </span><span class=\"n\">detectClassicalLinter</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">DetectClassical</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Linter</span>\n</code></pre></div>",
        "id": 501743343,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740473502
    },
    {
        "content": "<p>You can configure it to emit information on <em>all</em> declarations, confirming that they do not depend on any axiom/do not depend on <code>Classical.choice</code>, using <code>set_option linter.verbose.detectClassical true</code>.</p>",
        "id": 501743508,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740473555
    },
    {
        "content": "<p>By default, it will only emit a warning on declarations that depend on <code>Classical.choice</code>.</p>",
        "id": 501743888,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740473695
    },
    {
        "content": "<blockquote>\n<p>Since this shows up every once in a while and I wanted to have something similar to grade my module, here is a linter that flags uses of <code>Classical.choice</code>.</p>\n</blockquote>\n<p>You don't allow AC in your module??</p>",
        "id": 501744967,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740474046
    },
    {
        "content": "<p>I want to know what depends on <code>sorry</code>, but the logic of the linter is very similar!</p>",
        "id": 501745201,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740474117
    },
    {
        "content": "<p>Instead of checking <code>Classical.choice</code>, I use <code>sorryAx</code>.</p>",
        "id": 501745677,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740474259
    },
    {
        "content": "<p>I allow sorrys in my students' projects, but I usually try and either prove or disprove them when I'm marking them; it would be great if you had a linter for figuring out whether they're true or false but this might be quite a tough challenge.</p>",
        "id": 501746703,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740474597
    },
    {
        "content": "<p>I do the same, but, when I cannot prove the sorries, then I want to check the extent of the dependence on them.</p>",
        "id": 501747811,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740474920
    },
    {
        "content": "<p>So, the <code>sorryLinter</code> is not required to be silent on successful projects: it is just a diagnostic that I use to see where some issues might be.</p>",
        "id": 501747986,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740474970
    },
    {
        "content": "<p>With respect to autofiguring out true or false: if the lemmas are in scope for <code>plausible</code>, you could use that.  Of course, in general it is hopeless.</p>",
        "id": 501748138,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740475036
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/channel/270676-lean4/topic/restricting.20axioms/near/501743343\">said</a>:</p>\n<blockquote>\n<p>Since this shows up every once in a while and I wanted to have something similar to grade my module, here is a linter that flags uses of <code>Classical.choice</code>.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Util</span><span class=\"bp\">.</span><span class=\"n\">CollectAxioms</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">DeclarationNames</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">#  The \"detectClassical\" linter</span>\n\n<span class=\"cm\">The \"detectClassical\" linter emits a warning on declarations that depend on the `Classical.choice`</span>\n<span class=\"cm\">axiom.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Linter</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">The \"detectClassical\" linter emits a warning on declarations that depend on the `Classical.choice`</span>\n<span class=\"sd\">axiom.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">register_option</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">detectClassical</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">  </span><span class=\"n\">defValue</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"n\">descr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"enable the detectClassical linter\"</span>\n<span class=\"o\">}</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">The `linter.verbose.detectClassical` option is a flag to make the `detectClassical` linter emit</span>\n<span class=\"sd\">a confirmation on declarations that depend *not* on the `Classical.choice` axiom.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">register_option</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">verbose</span><span class=\"bp\">.</span><span class=\"n\">detectClassical</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">  </span><span class=\"n\">defValue</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"n\">descr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"enable the verbose setting for the detectClassical linter\"</span>\n<span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">DetectClassical</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Linter</span><span class=\"bp\">.</span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">detectClassical</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">detectClassicalLinter</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Linter</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">withSetOptionIn</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"n\">Linter</span><span class=\"bp\">.</span><span class=\"n\">getLinterValue</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">detectClassical</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getOptions</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">return</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">messages</span><span class=\"bp\">.</span><span class=\"n\">hasErrors</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">return</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">nms</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getNamesFrom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">stx</span><span class=\"bp\">.</span><span class=\"n\">getPos?</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"bp\">·.</span><span class=\"n\">getId</span><span class=\"bp\">.</span><span class=\"n\">isInternal</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">verbose?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Linter</span><span class=\"bp\">.</span><span class=\"n\">getLinterValue</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">verbose</span><span class=\"bp\">.</span><span class=\"n\">detectClassical</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getOptions</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">constStx</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">nms</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">constName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">constStx</span><span class=\"bp\">.</span><span class=\"n\">getId</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">collectAxioms</span><span class=\"w\"> </span><span class=\"n\">constName</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">verbose?</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"n\">logInfoAt</span><span class=\"w\"> </span><span class=\"n\">constStx</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"'{constName}' does not depend on any axioms\"</span>\n<span class=\"w\">      </span><span class=\"n\">return</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"n\">axioms</span><span class=\"bp\">.</span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"ss\">`Classical.choice</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">verbose?</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"n\">logInfoAt</span><span class=\"w\"> </span><span class=\"n\">constStx</span>\n<span class=\"w\">          </span><span class=\"n\">m!</span><span class=\"s2\">\"'{constName}' is non-classical and depends on axioms:</span><span class=\"se\">\\n</span><span class=\"s2\">{axioms.toList}\"</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">Linter</span><span class=\"bp\">.</span><span class=\"n\">logLint</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">detectClassical</span><span class=\"w\"> </span><span class=\"n\">constStx</span>\n<span class=\"w\">        </span><span class=\"n\">m!</span><span class=\"s2\">\"'{constName}' depends on 'Classical.choice'.</span><span class=\"se\">\\n\\n</span><span class=\"s2\">All axioms: {axioms.toList}</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span>\n\n<span class=\"n\">initialize</span><span class=\"w\"> </span><span class=\"n\">addLinter</span><span class=\"w\"> </span><span class=\"n\">detectClassicalLinter</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">DetectClassical</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Linter</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thank you, this works quite well:<br>\n<a href=\"https://github.com/katydid/regex-deriv-lean/pull/134\">https://github.com/katydid/regex-deriv-lean/pull/134</a></p>\n<p>It finds uses of Classical.choice<br>\nand there are many more than I thought there would be</p>",
        "id": 504551904,
        "sender_full_name": "awalterschulze",
        "timestamp": 1741606858
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"626349\">Asei Inoue</span> <a href=\"#narrow/channel/270676-lean4/topic/restricting.20axioms/near/501727827\">said</a>:</p>\n<blockquote>\n<p>here is a implementation of command which detect classical axiom</p>\n<p><a href=\"https://lean-ja.github.io/lean-by-example/Diagnostic/Print.html#%E8%88%9E%E5%8F%B0%E8%A3%8F\">https://lean-ja.github.io/lean-by-example/Diagnostic/Print.html#%E8%88%9E%E5%8F%B0%E8%A3%8F</a></p>\n</blockquote>\n<p>I tried this, but <code>Command</code> was an unknown import for some reason</p>",
        "id": 504553595,
        "sender_full_name": "awalterschulze",
        "timestamp": 1741607239
    },
    {
        "content": "<p>Try <code>import Lean</code></p>",
        "id": 504553911,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741607318
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/270676-lean4/topic/restricting.20axioms/near/493008336\">said</a>:</p>\n<blockquote>\n<p>you could use <code>#guard_msgs</code> to ensure the message doesn't change?</p>\n</blockquote>\n<p>I do not know how to use gaurd_msgs with print axioms, an example would be very helpful</p>",
        "id": 504554306,
        "sender_full_name": "awalterschulze",
        "timestamp": 1741607419
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/270676-lean4/topic/restricting.20axioms/near/493015434\">said</a>:</p>\n<blockquote>\n<p>Why do you want to exclude em for this? If you show DecidablePred for something you have to provide an executable algorithm as a decision procedure, unless that one is marked noncomputable its always executable. Whether the proof of correctness for the procedure uses em doesnt matter for being able to execute the procedure.</p>\n</blockquote>\n<p>I was to state in a paper that the property is decidable. Maybe I am a little over perfectionist in this case and it being executable is enough, but I am not sure.</p>",
        "id": 504554791,
        "sender_full_name": "awalterschulze",
        "timestamp": 1741607542
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/restricting.20axioms/near/493016922\">said</a>:</p>\n<blockquote>\n<p>It should look something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">decidableDenote</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Regex</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decidable_of_iff</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">validate_commutes</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>(Untested of course, but you shouldn't be using tactics to create DecidablePred instances. They tend to have issues with reduction.)</p>\n</blockquote>\n<p>I tried it, but unfortunately it doesn't work.<br>\nAlso was wondering about not being allowed to use tactics to create DecidablePred instances.</p>\n<ol>\n<li>Shouldn't I be warned in some way about this?</li>\n<li>Is it okay that validate_commutes uses tactics?</li>\n<li>How is it possible to do this correctly and know that it is correct?</li>\n</ol>",
        "id": 504557345,
        "sender_full_name": "awalterschulze",
        "timestamp": 1741608075
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/restricting.20axioms/near/493017239\">said</a>:</p>\n<blockquote>\n<p>Like Henrik is asking, what's your specific use case for avoiding LEM?</p>\n</blockquote>\n<p>I want to say in a paper that the language has been proven to be decidable. I assume this is the way to do it, but maybe I am wrong?</p>",
        "id": 504557578,
        "sender_full_name": "awalterschulze",
        "timestamp": 1741608124
    },
    {
        "content": "<p>If your proof of a decision procedure is using em you have still shown that the thing you are proving is decidable, there are different combinations possible here:</p>\n<ul>\n<li>derive a decision procedure using em and verify it (with or without em) would not be decidability in the usual sense</li>\n<li>derive a decision procedure without em and verify it without em is decidability and the proof for its correctness is constructive</li>\n<li>derive a decision procedure without em and verify it with em is decidability and the proof for its correctness is non constructive</li>\n</ul>\n<p>Regardless the last case still shows decidability of a predicate.</p>",
        "id": 504561889,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1741609137
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> </p>\n<p>what this line does in your detectClassical linter?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">messages</span><span class=\"bp\">.</span><span class=\"n\">hasErrors</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">return</span>\n</code></pre></div>",
        "id": 505769754,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1741987586
    },
    {
        "content": "<p>It makes sure that the linter says nothing if the declaration contains errors.</p>",
        "id": 505770277,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741987836
    },
    {
        "content": "<p>It is fairly standard for linters to ignore commands that have errors.</p>",
        "id": 505770306,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741987855
    },
    {
        "content": "<p>In particular, in this case, if the declaration contains errors, it likely will not have added anything to the environment, so there would be nothing to check for axioms anyway.</p>",
        "id": 505770359,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741987887
    },
    {
        "content": "<p>thanks!</p>",
        "id": 505771516,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1741988514
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/270676-lean4/topic/restricting.20axioms/near/504561889\">said</a>:</p>\n<blockquote>\n<p>If your prove of a decision procedure is using em you have still shown that the thing you are proving is decidable, there are different combinations possible here:</p>\n<ul>\n<li>derive a decision procedure using em and verify it (with or without em) would not be decidability in the usual sense</li>\n<li>derive a decision procedure without em and verify it without em is decidability and the proof for its correctness is constructive</li>\n<li>derive a decision procedure without em and verify it with em is decidability and the proof for its correctness is non constructive</li>\n</ul>\n<p>Regardless the last case still shows decidability of a predicate.</p>\n</blockquote>\n<p>Thank you this is very helpful<br>\nLet me just do a triple check that I understand correctly.<br>\nHere is a minimal example that I wonder if it is true in general:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Step 1: define some language</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Regex</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Lang</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Regex</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Lang</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"c1\">-- Step 2: define a matching function</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Regex</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"w\">  </span><span class=\"c1\">-- matching r is decidable, since it returns a bool and is computable (does not have noncomputable tag)</span>\n\n<span class=\"c1\">-- Step 3: prove that the matching function is correct</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">commutes</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Regex</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">execute</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- feel free to use EM and tactics</span>\n<span class=\"w\">  </span><span class=\"c1\">-- using EM just means the proof is not constructive, but doesn't affect decidability</span>\n\n<span class=\"c1\">-- decidability of r is proven via match, the next step is really just a formality and not sure if it is really needed.</span>\n\n<span class=\"c1\">-- Step 4: prove decidability</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Regex</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- proven via commutes</span>\n<span class=\"w\">  </span><span class=\"c1\">-- feel free to use more EM and tactics</span>\n\n<span class=\"c1\">-- decidability of r is proven, but the proof is not constructive, which is fine</span>\n</code></pre></div>",
        "id": 506924511,
        "sender_full_name": "awalterschulze",
        "timestamp": 1742464567
    },
    {
        "content": "<p>For step 4, a clarification: you don't prove decidability, you provide a decision procedure. If you do make a mistake and accidentally use EM in a computationally relevant way, you'll notice because Lean will say the definition must be <code>noncomputable</code>. If it's not <code>noncomputable</code>, it's fine.</p>\n<p>Just like any definition, you don't generally want to define it with tactics. Here's how it could be defined, modulo bugs from typing it directly into Zulip:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Regex</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decidable_of_decidable_of_eq</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>This causes <code>execute</code> to be used to evaluate <code>denote</code>.</p>",
        "id": 507008017,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742485063
    },
    {
        "content": "<p>Thank you that worked perfectly <a href=\"https://github.com/katydid/regex-deriv-lean/commit/b8acdfd4ecce5a1c7148b3a53f23a12b7b0c0069\">https://github.com/katydid/regex-deriv-lean/commit/b8acdfd4ecce5a1c7148b3a53f23a12b7b0c0069</a></p>\n<p>So just to conclude and check if I understood correctly: it sounds like it is generally frowned upon to use tactics in definitions, but technically it would not have made the proof that the predicate is decidable invalid, if tactics were used.</p>",
        "id": 515506196,
        "sender_full_name": "awalterschulze",
        "timestamp": 1746106669
    }
]