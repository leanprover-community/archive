[
    {
        "content": "<p>When matching some <code>type : Q(Prop)</code> with <code>$x = $y</code> how can I filter out the case when <code>x</code> and <code>y</code> are <code>Prop</code>s?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Qq</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"print_eqs\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">withMainContext</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">ldecl</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getLCtx</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferTypeQ</span><span class=\"w\"> </span><span class=\"n\">ldecl</span><span class=\"bp\">.</span><span class=\"n\">toExpr</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">continue</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Eq</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"c1\">-- Is it possible to filter only α : Q(Type u) here?</span>\n<span class=\"w\">      </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{x} = {y}\"</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">()</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">print_eqs</span>\n</code></pre></div>\n<p>For example, later I'd like to check whether there is an <code>LE α</code> instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">synthInstanceQ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>but it is impossible because <code>LE</code> expects <code>α : Type u</code>, not <code>α : Sort u</code>.</p>",
        "id": 500015331,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739716384
    },
    {
        "content": "<p>Did you mean to test with <code>trivial = trivial</code> instead?</p>",
        "id": 500020069,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739720526
    },
    {
        "content": "<p>Matching against <code> ~q(@Eq.{_ + 1} $α $x $y) </code> seems to work</p>",
        "id": 500020089,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739720552
    },
    {
        "content": "<p>As does <code> ~q(@Eq ($α : Type _) $x $y) </code></p>",
        "id": 500020111,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739720579
    },
    {
        "content": "<p>Also, maybe don't <code>inferTypeQ</code> here, there is <code>ldecl.type</code> which should also do what you want.</p>",
        "id": 500020160,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739720622
    },
    {
        "content": "<p>Robin, your suggestion does not provide the correct Qq annotations, right?</p>",
        "id": 500020401,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1739720812
    },
    {
        "content": "<p>You're right... but I feel like it's silly to do use an <code>inferType</code> when the information already exists somewhere.</p>",
        "id": 500020581,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739720948
    },
    {
        "content": "<p>Thank you very much, Eric!</p>",
        "id": 500020719,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739721056
    },
    {
        "content": "<p>Note that the <code>let ⟨0, </code> can fail if the universe is a metavariable</p>",
        "id": 500020967,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739721274
    },
    {
        "content": "<p>Ah, I see. Is there a better way than</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferTypeQ</span><span class=\"w\"> </span><span class=\"n\">ldecl</span><span class=\"bp\">.</span><span class=\"n\">toExpr</span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isProp</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"n\">QL</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨⟩</span>\n<span class=\"w\">  </span><span class=\"c1\">-- the rest of the code</span>\n</code></pre></div>\n<p>?</p>",
        "id": 500612671,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739960151
    }
]