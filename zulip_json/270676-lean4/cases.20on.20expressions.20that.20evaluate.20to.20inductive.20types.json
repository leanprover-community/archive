[
    {
        "content": "<p>If I have an inductive type, say</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Formula_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">false_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula_</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">true_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula_</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">atom_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Formula_</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">not_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula_</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Formula_</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">and_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula_</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Formula_</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Formula_</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">or_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula_</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Formula_</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Formula_</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">imp_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula_</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Formula_</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Formula_</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">iff_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula_</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Formula_</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Formula_</span>\n</code></pre></div>\n<p>and I have an expression <code>e</code> that evaluates to a type <code>Formula_</code>,  and a hypothesis <code>h : e = not_ e</code>, is there a tactic that will immediately prove that this is a contradiction? It seems that I need to do something like <code>set F := e</code> before <code>cases h</code> will work.</p>",
        "id": 527321334,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1751775719
    },
    {
        "content": "<p>Canonical can solve this outright, but I've taken the liberty of using <code>induction</code> to handle the absurd cases:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">Formula_</span><span class=\"bp\">.</span><span class=\"n\">not_</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- canonical</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">not_</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">a_ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">a_ih</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Formula_</span><span class=\"bp\">.</span><span class=\"n\">not_</span><span class=\"bp\">.</span><span class=\"n\">injEq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">reduceCtorEq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>",
        "id": 527324796,
        "sender_full_name": "Chase Norman",
        "timestamp": 1751780183
    },
    {
        "content": "<p>Hmm. I think maybe I didn't communicate what I meant very well. I can prove that the hypothesis is a contradiction by using <code>set</code> to replace the expression by a single variable name and then uses <code>cases</code> on the hypothesis, I was just wondering why it is necessary to use <code>set</code> first.</p>",
        "id": 527325689,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1751781454
    },
    {
        "content": "<p>For example, I have the hypothesis <code>contra : replace_atom_all_rec σ phi = replace_atom_all_rec σ phi.not_</code>. If I do <code>set H := replace_atom_all_rec σ phi</code> and then <code>cases contra</code> it solves the goal, but I'm not sure I understand why I need to do the <code>set</code> first and not just use <code>cases contra</code>.</p>",
        "id": 527325756,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1751781577
    },
    {
        "content": "<p>you can do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">he</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">not_</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sizeOf</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">sizeOf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Formula_</span><span class=\"bp\">.</span><span class=\"n\">not_</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"o\">(</span><span class=\"n\">sizeOf</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">he</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n</code></pre></div>",
        "id": 527338326,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1751797684
    },
    {
        "content": "<p>the main idea here is that <code>he</code> leads to an infinite regression, however since values of inductives have a definable \"size\", this would lead to some natural number being its own successor</p>",
        "id": 527338392,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1751797774
    },
    {
        "content": "<p>or even a one-liner proof: <code>simpa using congr(sizeOf $he)</code></p>",
        "id": 527338459,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1751797854
    },
    {
        "content": "<p>you <em>do</em> need <code>Mathlib.Tactic</code> for this, specifically the congr quotation</p>",
        "id": 527338504,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1751797894
    },
    {
        "content": "<p>Use <code>cases he</code>. Under the hood it will do the same thing <span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> recommended</p>",
        "id": 527345168,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1751806109
    },
    {
        "content": "<p>i was under the impression that OP tried that and it didn't work? but indeed, it looks like that also works...</p>",
        "id": 527345238,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1751806216
    },
    {
        "content": "<p>Oh I guess the question is rather <code>&lt;complex expression&gt; = .not_ &lt;complex expression&gt;</code> not working?</p>",
        "id": 527345382,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1751806415
    },
    {
        "content": "<p>Yes, it is that <code>cases h</code> does not work on <code>h: &lt;complex expression&gt; = .not_ &lt;complex expression&gt;</code>. For some reason I have to do something like <code>set F := &lt;complex expression&gt;</code> before <code>cases h</code>.</p>",
        "id": 527391971,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1751857150
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.acyclic#doc\">docs#Lean.MVarId.acyclic</a> is what is responsible for the way <code>cases</code> handles acyclicity, and in <code>Lean.MVarId.isTarget</code> you can see that it looks specifically for a free variable on one side and that free variable appearing in the other side.</p>\n<p>That explains exactly why you need to use <code>set</code> (or <code>generalize</code>) as a first step.</p>\n<p>I imagine the reason it was coded this way is that it's assumed that it's only supposed to support constructor applications, so the other reasoning in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.unifyEq%3F#doc\">docs#Lean.Meta.unifyEq?</a> will reduce to the case of a free variable on one side in that case.</p>\n<p>I wonder how far dependent elimination could get in more cases if instead of an acyclicity prover it was a general sizeOf-based prover. Then, for example, it might be able to make progress on <code>List.append</code> indexes, etc.</p>",
        "id": 527394428,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751859388
    },
    {
        "content": "<p>Hmm. Ok. I might have to come back to trying to understand that in its entirety at a later time. Thank you.</p>",
        "id": 527396034,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1751861010
    }
]