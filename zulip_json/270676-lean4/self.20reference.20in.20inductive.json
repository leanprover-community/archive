[
    {
        "content": "<p>I recall being told at some point in Lean 3 that something like this doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">descendent_list</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LabeledTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>because the type being defined is referenced in another inductive type, the <code>List</code>.  I was wondering if this is still the case. Lean 4 accepted this definition, but I'm not sure what issues I may end up running into.</p>",
        "id": 468986242,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1725944819
    },
    {
        "content": "<p>Also, if I want to refer to the items in the constructor, is this the canonical way to do so?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">descendent_list</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LabeledTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"n\">compile_inductive</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span><span class=\"bp\">.</span><span class=\"n\">root</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">LabeledTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">root</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">root</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span><span class=\"bp\">.</span><span class=\"n\">descendent_list</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">LabeledTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LabeledTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">descendent_list</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">descendent_list</span>\n</code></pre></div>",
        "id": 468989898,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1725946570
    },
    {
        "content": "<p>Or is there another way to make it builtin, like with the dot notation of <code>structure</code>s.</p>",
        "id": 468989980,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1725946594
    },
    {
        "content": "<p>There's no built-in way to generate accessor functions at the moment (though it occurred to me that I have a not-so-tested-one lying around: <a href=\"https://gist.github.com/kmill/f83401e20bc9e36624086c8eceb5b157\">https://gist.github.com/kmill/f83401e20bc9e36624086c8eceb5b157</a>)</p>",
        "id": 468990435,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725946831
    },
    {
        "content": "<p>You shouldn't need <code>compile_inductive%</code> unless you're using <code>LabeledTree.rec</code> directly to make definitions.</p>",
        "id": 468990498,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725946875
    },
    {
        "content": "<p>I see. Thank you.</p>",
        "id": 468990657,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1725946958
    },
    {
        "content": "<p>Is it possible to use the self reference like that now, or is this still to be avoided?</p>",
        "id": 468990732,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1725947009
    },
    {
        "content": "<p>My understanding is that nested inductive types are supported by the kernel now. I haven't noticed any issues with them myself.</p>",
        "id": 468991001,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725947155
    },
    {
        "content": "<p>A case study is that this recursive function on your tree appears to work fine and have reasonable equation lemmas:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">root</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">root</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">root</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">child</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">descendent_list</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">child</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">root</span><span class=\"w\"> </span><span class=\"n\">descendent_list</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">eq_1</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">LabeledTree.sum.eq_1 {α : Type} [Add α] [Zero α] (root : Option α) :</span>\n<span class=\"cm\">  (LabeledTree.mk root []).sum = root.getD 0</span>\n<span class=\"cm\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">eq_2</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">LabeledTree.sum.eq_2 {α : Type} [Add α] [Zero α] (root : Option α)</span>\n<span class=\"cm\">  (child : LabeledTree α) (descendent_list : List (LabeledTree α)) :</span>\n<span class=\"cm\">  (LabeledTree.mk root (child :: descendent_list)).sum = child.sum + (LabeledTree.mk root descendent_list).sum</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 468991650,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725947562
    },
    {
        "content": "<p>What is an equation lemma?</p>",
        "id": 468991856,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1725947704
    },
    {
        "content": "<p>Is this an issue due to the self reference in the <code>List</code>?<br>\n'induction' tactic does not support nested inductive types, the eliminator 'LabeledTree.rec' has multiple motives</p>",
        "id": 468994604,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1725949109
    },
    {
        "content": "<p><code>cases</code> works here, but <code>induction</code> gives the error.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">isLeaf</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LabeledTree</span><span class=\"bp\">.</span><span class=\"n\">isLeaf</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 468994805,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1725949213
    },
    {
        "content": "<p>Or maybe it is because there is only one constructor and no base constructor?</p>",
        "id": 468994940,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1725949291
    },
    {
        "content": "<p>Hmm, no, it doesn't work with this either</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LabeledTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>",
        "id": 468995221,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1725949440
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Kayla Thomas</span> <a href=\"#narrow/stream/270676-lean4/topic/self.20reference.20in.20inductive/near/468994604\">said</a>:</p>\n<blockquote>\n<p>Is this an issue due to the self reference in the <code>List</code>?<br>\n'induction' tactic does not support nested inductive types, the eliminator 'LabeledTree.rec' has multiple motives</p>\n</blockquote>\n<p>Yes. A nested inductive data type will have a recursor with one motive for <code>LabeledTree</code> and one for <code>List LabeledTree</code>. Your options are, I think,</p>\n<ul>\n<li>Define your theorem recursively</li>\n<li>\n<p>Instantiate the second inductive motive explicitly<br>\n<code>\n  induction T using LabeledTree.rec (motive2 := fun TS =&gt; … TS …)\n  </code></p>\n</li>\n<li>\n<p>Don’t use tactics, but write <code>:= LabeledTree.rec (motive1 := …) (motive2  := …) …</code> explicitly.</p>\n</li>\n</ul>\n<p>Probably the first one is simplest.</p>",
        "id": 468995950,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1725949718
    },
    {
        "content": "<p>I see. What goes in the <code>...</code>s?</p>",
        "id": 468997173,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1725950076
    },
    {
        "content": "<ul>\n<li>use <code>match T with </code> &lt;- i recommend this one</li>\n</ul>",
        "id": 468997209,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1725950103
    },
    {
        "content": "<p>possibly use a <code>mutual</code> block</p>",
        "id": 468997348,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1725950162
    },
    {
        "content": "<p>That won't be recursive on the structure of <code>T</code> will it?</p>",
        "id": 468997393,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1725950166
    },
    {
        "content": "<p>it <em>will</em> if you refer to the statement in the statement.</p>",
        "id": 468997427,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1725950184
    },
    {
        "content": "<p>Oh, you are referring to the first one that Joachim listed?</p>",
        "id": 468997505,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1725950231
    },
    {
        "content": "<p>ah, yes. my bad.</p>",
        "id": 468997550,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1725950250
    },
    {
        "content": "<p>I see.</p>",
        "id": 468997569,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1725950261
    },
    {
        "content": "<p>No problem.</p>",
        "id": 468997661,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1725950295
    },
    {
        "content": "<p>Is there any chance it is possible to make this work more simply with the induction tactic at some point in the future?</p>",
        "id": 468997813,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1725950371
    },
    {
        "content": "<p>Note that one thing that doesn't work well with these nested inductive types is to use List-operations in recursive definitions. For example, the following is reasonable to write, but Lean doesn't support it (yet?):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">BigOperators</span><span class=\"bp\">.</span><span class=\"n\">Group</span><span class=\"bp\">.</span><span class=\"n\">List</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">descendents</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LabeledTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">root</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">root</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">root</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">LabeledTree</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">sum</span>\n</code></pre></div>",
        "id": 469020736,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1725955554
    },
    {
        "content": "<p>Would be cool if that would work some day. I have a lot of metaprogramming stuff that's recursive in that way and needs to be made <code>partial</code> right now</p>",
        "id": 469092875,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1725975205
    },
    {
        "content": "<p>You can show that this terminates by mapping on <code>l.attach</code></p>",
        "id": 469102366,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725977115
    }
]