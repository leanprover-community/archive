[
    {
        "content": "<p>In both <a href=\"https://lean-lang.org/papers/thesis-sebastian.pdf#subsection.3.2.1\">https://lean-lang.org/papers/thesis-sebastian.pdf#subsection.3.2.1</a> and <a href=\"https://arxiv.org/abs/2403.14064\">Lean4Lean</a> it is claimed that structure projections are equivalent to recursor applications, but I have found an edge case where this is not true:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">bootstrap</span><span class=\"bp\">.</span><span class=\"n\">inductiveCheckResultingUniverse</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">genSizeOf</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">genInjectivity</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Wrap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">wrap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unwrap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Wrap</span><span class=\"bp\">.</span><span class=\"n\">unwrap</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Wrap</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">info: Wrap.rec.{u} {α : Sort u} {motive : Wrap α → Prop} (wrap : ∀ (unwrap : α), motive (Wrap.wrap unwrap)) (t : Wrap α) :</span>\n<span class=\"sd\">  motive t</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Wrap</span><span class=\"bp\">.</span><span class=\"n\">rec</span>\n</code></pre></div>\n<p>While <code>Wrap</code> has only one constructor, it takes an argument of type <code>α</code>, which is not a <code>Prop</code>, and so it does not have subsingleton elimination (using the terminology from <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a>). Because <code>Wrap</code> lives in <code>Prop</code> when <code>u = 0</code>, it does not have large elimination, and so the recursor only allows eliminating into <code>Prop</code>. This prevents projections from being expressed as recursor applications for <code>u &gt; 0</code>.<br>\nI believe the fix to make projections truly conservative over recursors is to make types like <code>Wrap</code> have subsingleton elimination. The reason the current projection check is correct is that the arguments to the constructor cannot be in a higher universe, because <code>Wrap α</code> is not always a <code>Prop</code>. When <code>u = 0</code> so that <code>Wrap α : Prop</code>, we have <code>α : Prop</code>, and projecting <code>Prop</code>s is always allowed. Thus, when checking that non-recursive arguments to the constructor are in <code>Prop</code>, the subsingleton elimination check only needs to consider the case that the universe of the inductive type (<code>Sort u</code> in the example) is <code>Prop</code>.<br>\nI have an implementation of this change in the kernel at <a href=\"https://github.com/leanprover/lean4/commit/0194f054243f271ed3ec45303b41c96ef03ff307\">https://github.com/leanprover/lean4/commit/0194f054243f271ed3ec45303b41c96ef03ff307</a> and it seems to work, fixing the example above.</p>",
        "id": 507474308,
        "sender_full_name": "Parth Shastri",
        "timestamp": 1742666380
    },
    {
        "content": "<p>It's a known limitation that inductive types in <code>Sort u</code> have overly conservative recursors (hence why you needed to set <code>bootstrap.inductiveCheckResultingUniverse</code> to override the <code>inductive</code> command's error)</p>\n<p>I'm not sure what Lean core would want to do here. It's either</p>\n<ul>\n<li>limit primitive projections to only be able to do what the recursors can do; or</li>\n<li>let recursors be more general, like in your patch.</li>\n</ul>\n<p>Could you please create a Lean issue with the code and the explanation that the projection and recursor diverge for this type?</p>\n<p>I think the first of the two options is the more likely outcome, in the absence of applications. If you have a concrete application that needs general recursors, please include them in the issue.</p>",
        "id": 507481069,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742670531
    },
    {
        "content": "<p>Agreed. This is going to make lean4lean run into an unprovable goal, so I'd be interested to see this fixed, and I agree that the simplest fix is to ban primitive projections on such types.</p>",
        "id": 507481925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742671129
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/issues/7637\">#7637</a></p>",
        "id": 507486111,
        "sender_full_name": "Parth Shastri",
        "timestamp": 1742673106
    }
]