[
    {
        "content": "<p>You don't need the <code>ofReduceBool</code> axiom for weirdness from the real world to affect the logical system:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">IO.getRandomBytes</span> <span class=\"mi\">1</span> <span class=\"o\">()</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"n\">bs</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">bs</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">!</span> <span class=\"bp\">&gt;=</span> <span class=\"mi\">128</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">T1</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"bp\">=</span> <span class=\"n\">Lean.reduceBool</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">T2</span> <span class=\"o\">:</span> <span class=\"n\">Lean.reduceBool</span> <span class=\"n\">foo</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">contradiction</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"n\">nomatch</span> <span class=\"n\">T1.trans</span> <span class=\"n\">T2</span>\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">contradiction</span>\n<span class=\"c1\">-- 'contradiction' does not depend on any axioms</span>\n</code></pre></div>\n<p>(this proof only works with 1/4 probability so rerun it a couple times until both <code>rfl</code> proofs work)</p>",
        "id": 395967589,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1696975930
    },
    {
        "content": "<p>an easy fix is to make <code>reduceBool</code> an <code>axiom</code> instead of an <code>opaque</code> so that it shows up in the <code>#print axioms</code> list</p>",
        "id": 395967812,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1696976097
    },
    {
        "content": "<p>because it's not really an <code>opaque</code>, it has (in this case literally) random reduction rules</p>",
        "id": 395968004,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1696976233
    },
    {
        "content": "<p>(and also, <code>IO.RealWorld</code> is not actually opaque... <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> <code>Lean.reduceBool</code> is allowing multiple real worlds here because the types say you can have as many real worlds as you need!)</p>",
        "id": 395969010,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1696976897
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/2654\">lean4#2654</a> adds an axiom that <code>Lean.reduceBool</code> and <code>Lean.reduceNat</code> depend on.</p>",
        "id": 395979810,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1696983624
    },
    {
        "content": "<p>(We can't quite make <code>reduceBool</code> an axiom itself, because the whole point is that it is computable.)</p>",
        "id": 395979847,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1696983654
    },
    {
        "content": "<p>It should be possible to have a computable <code>axiom</code>, if these axioms are special cased in the compiler</p>",
        "id": 395980376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1696983941
    },
    {
        "content": "<p>resolves <a href=\"https://manifold.markets/tfae/is-the-lean-kernel-unsound\">https://manifold.markets/tfae/is-the-lean-kernel-unsound</a> (?)</p>",
        "id": 395981147,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1696984337
    },
    {
        "content": "<p>Does this reproduce with <code>leanchecker</code>?</p>",
        "id": 395982316,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1696984972
    },
    {
        "content": "<p>No.</p>",
        "id": 395985923,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1696986758
    },
    {
        "content": "<p>I've just pushed a new commit to <a href=\"https://github.com/leanprover/lean4checker\">https://github.com/leanprover/lean4checker</a> that includes this example in the test suite.</p>",
        "id": 395986099,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1696986848
    },
    {
        "content": "<p>(This was slightly awkward, as Mario's code is non-deterministic, so I have to build the example in a loop until it compiles, and then check that. It's all fast enough that this is fine.)</p>",
        "id": 395986464,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1696987056
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/395979810\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover/lean4/pull/2654\">lean4#2654</a> adds an axiom that <code>Lean.reduceBool</code> and <code>Lean.reduceNat</code> depend on.</p>\n</blockquote>\n<p>Out right saying that if you trust the compiler then you can prove false is really odd. In my head, prove of false is an indication of a bug somewhere that should be fixed. Using <code>axiom trustCompiler : True</code> instead of <code>axiom trustCompiler : False</code> would work the same way, no?</p>\n<p>In the case above the problem is that <code>IO</code> monad is effectively <code>StateM Unit</code> and you can easily copy <code>IO.RealWorld</code>. There is even TODO at the definitions of <code>EIO</code> which would prevent you from writing <code>IO.getRandomBytes 1 ()</code></p>",
        "id": 395986602,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1696987126
    },
    {
        "content": "<p>Now I'm completely confused, why does the <code>rfl</code> proof work? If you change the proof to <code>by unfold foo; rfl</code> then it does not work.</p>",
        "id": 395988118,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1696987942
    },
    {
        "content": "<p>I think the answer is this <a href=\"https://github.com/leanprover/lean4/blob/ca0e6b0522e2948e8d819886be1e8fc106354947/src/Lean/Meta/WHNF.lean#L779\">line</a>, the reduction happens only if the expression looks like <code>.app (.const `Lean.reduceBool _) (.const _ _)</code></p>",
        "id": 395989012,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1696988414
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/2656\">#2656</a> makes <code>IO.RealWorld</code> an opaque type.</p>\n<p>In <code>src/Init/System</code> in <code>unsafeBaseIO</code> we use an <code>unsafeCast ()</code> to \"construct\"  a RealWorld, and it seems like everyone else already behaves. :-)</p>\n<p>This independently prevents the example above.</p>\n<p>I haven't yet made <code>EIO</code> itself opaque, as <span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> has requested in a TODO in that file, because it is a bit more work to fully specify its API (so we can hide that it is really <code>EStateM</code>).</p>",
        "id": 395992134,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1696990304
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac Malone</span> I'm wondering if you can help me with something here.</p>\n<p>Including this example in the test suite for <code>lean4checker</code> has the consequence that <code>lake build</code> only succeeds 1/4 of the time!</p>\n<p>Options:</p>\n<ul>\n<li>remove the test file from the scope of <code>lake build</code>: I don't like this, because I would prefer that every time anyone builds the checker they are compelled to run the tests too!</li>\n<li>is there some custom Lake hackery that can tell <code>lake build</code> that it is meant to keep compiling a file until it works? :-) Obviously this is far from spec, but it's an unusual situation here!</li>\n</ul>",
        "id": 395995394,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1696992114
    },
    {
        "content": "<p>(beatings will continue until morale improves)</p>",
        "id": 395995461,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1696992135
    },
    {
        "content": "<p>There are a few other ways to write the IO so that you get a more reliable result. For example, if file <code>foo.txt</code> does not exist then you create such a file and return true, otherwise you delete it and return false</p>",
        "id": 395997695,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1696993419
    },
    {
        "content": "<p>that will ensure that you always alternate between true and false (and as an added bonus it cleans up after itself)</p>",
        "id": 395997782,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1696993454
    },
    {
        "content": "<p>If you did want to keep the random number generator implementation, I would suggest doing the \"keep compiling until it works\" in lean as a command elaborator</p>",
        "id": 395997915,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1696993552
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/395995394\">said</a>:</p>\n<blockquote>\n<ul>\n<li>remove the test file from the scope of <code>lake build</code>: I don't like this, because I would prefer that every time anyone builds the checker they are compelled to run the tests too!</li>\n</ul>\n</blockquote>\n<p>Running tests on a build strikes me as <em>very</em> weird. I cannot think of any major library or language which does that. While CIs certainly build &amp; test, the very fact that the process is called \"build &amp; test\" indicates that these are usually expected to be distinct invocations.</p>",
        "id": 396005804,
        "sender_full_name": "Mac Malone",
        "timestamp": 1696998187
    },
    {
        "content": "<p>I guess the fact that <code>lake test</code> doesn't exist may be contributing to me want to do everything during <code>build</code>. :-)</p>",
        "id": 396006408,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1696998565
    },
    {
        "content": "<p>Actually -- if I have a <code>test.sh</code> or <code>make test</code> that runs my actual testing, what is the idiomatic way to fire this via <code>lake ...</code>?</p>",
        "id": 396006527,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1696998625
    },
    {
        "content": "<p>While <code>lake test</code> sadly does not exist yet, <code>lake run test</code> is still a reasonable alternative (and does not introduce significant elaboration overhead anymore now that <code>lakefile.olean</code> exists).</p>",
        "id": 396006533,
        "sender_full_name": "Mac Malone",
        "timestamp": 1696998635
    },
    {
        "content": "<p>And I can only define scripts in the lakefile.lean itself?</p>",
        "id": 396006593,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1696998682
    },
    {
        "content": "<p>(Perhaps <code>lake run --help</code> could explain or link to an explanation of where scripts go / what they look like.)</p>",
        "id": 396006623,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1696998720
    },
    {
        "content": "<p>Yeah they go in the lakefile. There is <a href=\"https://github.com/leanprover/lean4/tree/master/src/lake#writing-and-running-scripts\">a section in the README on scripts</a>.</p>",
        "id": 396006739,
        "sender_full_name": "Mac Malone",
        "timestamp": 1696998792
    },
    {
        "content": "<p>If you want to do something more complicated, there is the mathlib approach of a utility exe.</p>",
        "id": 396006788,
        "sender_full_name": "Mac Malone",
        "timestamp": 1696998843
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">Depends on the correctness of the Lean compiler, interpreter, and all `[implemented_by ...]` and `[extern ...]` annotations.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">trustCompiler</span> <span class=\"o\">:</span> <span class=\"n\">False</span>\n</code></pre></div>\n<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Umm... It appears the <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/6477890086/job/17588810613#step:18:126\">robots have discovered that this axiom is very effective</a>.</p>",
        "id": 396013210,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697002832
    },
    {
        "content": "<p>I don't really like the idea of a false axiom hanging around... can't it be a true axiom instead?</p>",
        "id": 396013276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697002868
    },
    {
        "content": "<p>Oops, yes!</p>",
        "id": 396013468,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697002972
    },
    {
        "content": "<p>Okay, arriving soon.</p>",
        "id": 396013867,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697003196
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/6478956267/job/17591582160\">https://github.com/leanprover-community/mathlib4/actions/runs/6478956267/job/17591582160</a></p>\n<p>There still seems to be some issues</p>",
        "id": 396027520,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1697009548
    },
    {
        "content": "<p>Those PRs should maybe merge master? Scott pushed since then</p>",
        "id": 396034402,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1697012185
    },
    {
        "content": "<p>I’m getting a similar issue withe the lean4checker update: <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/6476538847/job/17585410139\">https://github.com/leanprover-community/mathlib4/actions/runs/6476538847/job/17585410139</a></p>\n<p>Am I correct that the way to go is to wait and rerun CI when things are settled?</p>",
        "id": 396042780,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1697015193
    },
    {
        "content": "<p>Just merge master or rebase onto master.</p>",
        "id": 396045958,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697016202
    },
    {
        "content": "<p>I hope I am under a serious misunderstanding: <code>leanchecker</code> rejected that code before <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> added a test for it, right?  We are not going to be special-casing every soundness leak into <code>leanchecker</code>?</p>",
        "id": 396065444,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1697023243
    },
    {
        "content": "<p>Yes, you are seriously misunderstanding.</p>",
        "id": 396065564,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697023291
    },
    {
        "content": "<p><code>lean4checker</code> rejected this example. All I did today was added a test case that verified that <code>lean4checker</code> rejected this example!</p>",
        "id": 396065732,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697023340
    },
    {
        "content": "<p>Yay!  Thanks for the assurance, Scott!</p>",
        "id": 396065762,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1697023351
    },
    {
        "content": "<p>(This was slightly tricky because it was non deterministic. I'll replace it with something deterministic tomorrow per Mario's suggestion.)</p>",
        "id": 396065886,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697023399
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/396065732\">said</a>:</p>\n<blockquote>\n<p><code>lean4checker</code> rejected this example. All I did today was added a test case that verified that <code>lean4checker</code> rejected this example!</p>\n</blockquote>\n<p>This is a surprise to me. I would expect <code>lean4checker</code> to accept the example (with 1/4 probability), or the deterministic revision of it with 100% probability. The only thing the follow up work has done is to make the example, while still proving <code>False</code>, at least depend on additional axioms. Making IO.RealWorld opaque will permanently break this example, but as Mac mentioned we remain susceptible to bad <code>implemented_by</code> implementations.</p>\n<p>Does <code>lean4checker</code> have a mechanism to disallow axioms outside a whitelist / does it <code>#print axioms</code> at the end? Otherwise I don't see how it could prevent this from still being an issue.</p>",
        "id": 396148770,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697050595
    },
    {
        "content": "<p>I think <code>lean4checker</code> rejects the example due to buggy support for <code>reduceBool</code>, which when fixed would cause it to accept the example. The error that lean4checker gives to reject</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">IO.getRandomBytes</span> <span class=\"mi\">1</span> <span class=\"o\">()</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"n\">bs</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">bs</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">!</span> <span class=\"bp\">&gt;=</span> <span class=\"mi\">128</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">T1</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"bp\">=</span> <span class=\"n\">Lean.reduceBool</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">T2</span> <span class=\"o\">:</span> <span class=\"n\">Lean.reduceBool</span> <span class=\"n\">foo</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">contradiction</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"n\">nomatch</span> <span class=\"n\">T1.trans</span> <span class=\"n\">T2</span>\n</code></pre></div>\n<p>is</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>uncaught exception: (kernel) unknown declaration 'foo'\n</code></pre></div>\n<p>It gives the same error in a case that it should arguably accept:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">T1</span> <span class=\"o\">:</span> <span class=\"n\">Lean.reduceBool</span> <span class=\"n\">foo</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I'm guessing that when lean4checker asks the kernel to validate <code>T1</code>, it doesn't provide it with a compiled version of <code>foo</code> to use with <code>reduceBool</code></p>",
        "id": 396154226,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1697053105
    },
    {
        "content": "<p>Of course -- the way <code>lean4checker</code> builds up the environment leads to everything being effectively noncomputable</p>",
        "id": 396159033,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697055388
    },
    {
        "content": "<p>Incidentally, I noticed that even regular lean gives a similar error when you use a constructor directly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">T1</span> <span class=\"o\">:</span> <span class=\"n\">Lean.reduceBool</span> <span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"c1\">-- unknown declaration 'Bool.true'</span>\n</code></pre></div>",
        "id": 396159219,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697055486
    },
    {
        "content": "<blockquote>\n<p>I think lean4checker rejects the example due to buggy support for reduceBool which when fixed would cause it to accept the example.</p>\n</blockquote>\n<p>So does this mean &lt;<a href=\"https://manifold.markets/tfae/is-the-lean-kernel-unsound\">https://manifold.markets/tfae/is-the-lean-kernel-unsound</a>&gt; ought to resolve to “yes”?</p>",
        "id": 397827059,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1697874839
    },
    {
        "content": "<p>I think the word \"buggy\" was used in an interesting way in that sentence.</p>",
        "id": 397827137,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697874889
    },
    {
        "content": "<p><code>lean4checker</code> rejects that example, which is what we want it to do.</p>",
        "id": 397827161,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697874928
    },
    {
        "content": "<p>(And so no, I don't think this is relevant to that manifold question.)</p>",
        "id": 397827174,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697874954
    },
    {
        "content": "<p>The manifold market question is a bit ambiguous about whether it is about the \"lean kernel\" or lean4checker. The lean kernel had an issue, but lean4checker was not broken, because it doesn't support reduceBool at all.</p>",
        "id": 397827362,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697875124
    },
    {
        "content": "<p>(I would not describe <code>lean4checker</code>'s behavior as \"correct\" here insofar as reduceBool is considered a part of the lean system and it is not supposed to be always rejected, but currently it is very difficult to support reduceBool outside the context of an elaborator session.)</p>",
        "id": 397827550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697875247
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/397827161\">said</a>:</p>\n<blockquote>\n<p><code>lean4checker</code> rejects that example, which is what we want it to do.</p>\n</blockquote>\n<p>I don't really agree with this. It should accept the example, resulting in a proof of false depending on the <code>reduceBool</code> or <code>trustCompiler</code> axiom</p>",
        "id": 397827687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697875375
    },
    {
        "content": "<p>The only way you can argue that this example should be rejected (setting aside the other part of the exploit regarding running IO in safe code) is if you think <code>reduceBool</code> should not exist in the kernel</p>",
        "id": 397827985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697875634
    },
    {
        "content": "<p>Here's a variant on the example which uses only features working as designed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">fooUnsafe</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"n\">unsafeBaseIO</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">EIO.catchExceptions</span>\n    <span class=\"o\">(</span><span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">IO.getRandomBytes</span> <span class=\"mi\">1</span><span class=\"o\">)[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">!</span> <span class=\"bp\">≥</span> <span class=\"mi\">128</span><span class=\"o\">)</span>\n    <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">false</span>\n<span class=\"kd\">@[</span><span class=\"n\">implemented_by</span> <span class=\"n\">fooUnsafe</span><span class=\"kd\">]</span>\n<span class=\"n\">opaque</span> <span class=\"n\">fooBody</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">fooBody</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">T1</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"bp\">=</span> <span class=\"n\">Lean.reduceBool</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">T2</span> <span class=\"o\">:</span> <span class=\"n\">Lean.reduceBool</span> <span class=\"n\">foo</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">contradiction</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"n\">nomatch</span> <span class=\"n\">T1.trans</span> <span class=\"n\">T2</span>\n</code></pre></div>",
        "id": 397828352,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697875966
    },
    {
        "content": "<p>There is however a clear path to saying that the proof of false in this code is \"my fault\": I used <code>reduceBool</code>, and this means that every <code>implemented_by</code> is effectively an axiom, and I have made an unsound choice of <code>implemented_by</code> in the example</p>",
        "id": 397828574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697876198
    },
    {
        "content": "<p>Thanks! Here is my attempt at a condensed summary:<br>\nUse of <code>reduceBool</code> increases the trustbase considerably, including to every single <code>implemented_by</code> in any dependency, and is expected (though not intended) to likely be inconsistent.<br>\nThe lean kernel should report proofs using <code>reduceBool</code> as depending on this axiom, but did not (does not?) do that; this lack of axiom tracking could be considered a soundness bug.<br>\nSuch proofs (correct or not) currently cannot be checked with lean4checker,  because it simply doesn’t support <code>reduceBool</code>. In that sense lean4checker is sound (and the manifold question should still resolve to No). Whether it would correctly report the axiom as used if it <em>had</em> support for <code>reduceBool</code> is a hypothetical.</p>",
        "id": 397831257,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1697878787
    },
    {
        "content": "<blockquote>\n<p>and is expected (though not intended) to likely be inconsistent.</p>\n</blockquote>\n<p>It is not expected to be inconsistent, although inconsistencies here are considerably more frequent than actual soundness bugs</p>",
        "id": 397833679,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697881220
    },
    {
        "content": "<p>Importantly, if there is any inconsistency accessible to <code>native_decide</code>, then we lose another important and desirable property of lean: it is a memory-safe language, you cannot cause UB from safe code</p>",
        "id": 397833747,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697881310
    },
    {
        "content": "<blockquote>\n<p>The lean kernel should report proofs using reduceBool as depending on this axiom, but did not (does not?) do that; this lack of axiom tracking could be considered a soundness bug.</p>\n</blockquote>\n<p>This was the original soundness bug report, and it was fixed by adding an artificial <code>trustCompiler</code> axiom which appears as a dependency of <code>reduceBool</code> so that any use of it will put <code>trustCompiler</code> in the <code>#print axioms</code> list</p>",
        "id": 397833935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697881466
    },
    {
        "content": "<p>An alternative solution would be to add special support for <code>reduceBool</code> in <code>#print axioms</code>; I think we will want something like this eventually anyway so that the presence of <code>reduceBool</code> indicates that we should also display all <code>implemented_by</code> axioms</p>",
        "id": 397833987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697881542
    },
    {
        "content": "<p>I meant “expected” in the descriptive sense (we are not surprised if someone finds bugs), not in the prescriptive sense (we want it to be that way). Ambiguous language, I guess (“I do expect my dog to behave well, but it’s a rascal, so I expect regular trouble.”). Is there a less ambiguous verb?</p>",
        "id": 397834331,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1697881892
    },
    {
        "content": "<p>It is a bug, but not a soundness bug. Maybe we could call it a safety bug?</p>",
        "id": 397834871,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697882349
    },
    {
        "content": "<p>Of course in rust this is what they would call a soundness bug, but they aren't trying to maintain a logical system and a memory-safe programming language at the same time</p>",
        "id": 397834986,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697882429
    },
    {
        "content": "<p><code>reduceBool</code> has been tracked with an axiom since <a href=\"https://github.com/leanprover/lean4/pull/2654\">lean4#2654</a>, which landed in <code>v4.2.0-rc2</code>.</p>",
        "id": 397880452,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697926204
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/397834986\">said</a>:</p>\n<blockquote>\n<p>Of course in rust this is what they would call a soundness bug, but they aren't trying to maintain a logical system and a memory-safe programming language at the same time</p>\n</blockquote>\n<p>Following this thread, I'm actually confused now what exactly would constitute a soundness bug in Lean (and whether there is some consensus on that question). Is there something to read about that? Perhaps a definition might look like \"prove <code>False</code> using any language features except for [exhaustive list] and pass both leanchecker and [some hypothetical checker thay bans you from using custom axioms and maybe other things]\"?</p>\n<p>I would have thought it's important to be precise about this, but maybe I'm wrong... In other threads people have pointed out that (perhaps I misunderstood) at the very least some notions of soundness in Lean are not relevant/interesting to Mathlib or doing math in general.</p>",
        "id": 397883482,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1697929906
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"638715\">@ab</span> A proof of false using the lean kernel and without axioms (except the 3 standard ones) would qualify as a soundness bug in either the kernel or the theory</p>",
        "id": 397886238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697933276
    },
    {
        "content": "<p>lean4checker is capable of performing this check, except that it doesn't tell you what axioms were used, so if you use a bad axiom you can still get lean4checker to validate your proof - simply watching the error code and not looking at the statements of theorems is not sufficient</p>",
        "id": 397886414,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697933437
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/397833747\">said</a>:</p>\n<blockquote>\n<p>it is a memory-safe language, you cannot cause UB from safe code</p>\n</blockquote>\n<p>While Lean strives to be memory-safe (just like pretty much any library) and purely functional code is memory-safe by default (as it is in most functional languages), I think the correctness of this statement heavily depends on what you wish to define as \"safe\" code. If you mean bad memory accesses is only possible in code the Lean kernel or elaborator will mark <code>unsafe</code> that seems clearly false (as memory-unsafe code can be wrapped in <code>opaque</code>). If you mean without any <code>extern</code>, <code>implemented_by</code>, or metaprogramming shenanigans,  the situation is better, but as a lot of code makes use of these things, that doesn't seem like an especially strong guarantee.</p>",
        "id": 397890088,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697936219
    },
    {
        "content": "<p>As in rust, one needs to sometimes grow the set of synonyms of <code>unsafe</code> as that particular syntactic marker is not necessarily a part of the unsafety-inducing feature, but I think it should be possible to have <em>some</em> list of unsafe features, such that as long as you don't use those then you haven't broken safety. <code>implemented_by</code> is only unsafe in conjunction with <code>reduceBool</code>, but either way it's still signposted. <code>extern</code> is definitely unsafe. \"Metaprogramming shenanigans\" are poorly scoped but let's say yes it is unsafe since you can implement your own version of <code>unsafe</code> that way. <code>opaque</code> is not unsafe AFAIK, you have to combine it with an <code>implemented_by</code> or <code>extern</code> for something interesting to happen.</p>\n<p>Also as in rust, the point is not actually to say that one should write code not using any of these features, and indeed some very critical core features have to be implemented using these tools so we can't actually do without them. However, they limit the scope of auditing from everything in the library to just a few things that do sketchy stuff, and in practice this has been shown to be significantly useful in improving overall quality because you can bring those core parts to a higher standard of correctness and documentation to compensate for the necessary bending of the rules of the type system.</p>",
        "id": 397891344,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697936949
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/397891344\">said</a>:</p>\n<blockquote>\n<p><code>implemented_by</code> is only unsafe in conjunction with <code>reduceBool</code></p>\n</blockquote>\n<p>Are we talking still talking about memory-safety or have we reverted to type-safety? I am not sure how <code>reduceBool</code> effects memory-safety.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/397891344\">said</a>:</p>\n<blockquote>\n<p>\"Metaprogramming shenanigans\" are poorly scoped but let's say yes it is unsafe since you can implement your own version of <code>unsafe</code> that way.</p>\n</blockquote>\n<p>The problem with most metaprogramming shenanigans is that they are not detectable from within Lean, they require some sort of external checker to reproduce results. For metaprogramming produced memory-unsafe code, this would require an external compiler to recompile things in a restricted manner.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/397891344\">said</a>:</p>\n<blockquote>\n<p>However, they limit the scope of auditing from everything in the library to just a few things that do sketchy stuff, and in practice this has been shown to be significantly useful in improving overall quality because you can bring those core parts to a higher standard of correctness and documentation to compensate for the necessary bending of the rules of the type system.</p>\n</blockquote>\n<p>I agree. To me, though, there is a major difference between a memory-safe language where memory-unsafe stuff is necessarily clearly marked and a \"memory-safe by default\" language (e.g., most functional programming languages including Haskell and Lean) where things can be made memory-unsafe without clear markings and only discoverable through post-facto external analysis.</p>",
        "id": 397893312,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697938136
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac Malone</span> <a href=\"#narrow/stream/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/397893312\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/397891344\">said</a>:</p>\n<blockquote>\n<p><code>implemented_by</code> is only unsafe in conjunction with <code>reduceBool</code></p>\n</blockquote>\n<p>Are we talking still talking about memory-safety or have we reverted to type-unsafety . I am not sure how <code>reduceBool</code> effects memory-safety.</p>\n</blockquote>\n<p>I'm talking about memory-safety. If you can prove a thing is true and evaluate it to false, then you can get memory unsafety. (Actually, you're right, that doesn't need <code>reduceBool</code>, <code>implemented_by</code> is sufficient.) Example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">six</span> <span class=\"o\">:=</span> <span class=\"mi\">6</span>\n<span class=\"kd\">@[</span><span class=\"n\">implemented_by</span> <span class=\"n\">six</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"k\">#eval</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"o\">⟨</span><span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>I think this is just limited to <code>@[implemented_by] def</code> though. With <code>@[implemented_by] opaque</code> you can't cause unsafety unless the implementation doesn't act like a pure function (e.g. it is nondeterministic or returns provably different values on provably equal inputs), and I don't think the regular type system will let you do this without another signpost.</p>",
        "id": 397893527,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697938283
    },
    {
        "content": "<p>Put another way, I think lean should be able to be at least as memory safe as rust (it has most of the same escape hatches with the same attacker model), and this seems to be a useful thing regardless.</p>",
        "id": 397893638,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697938356
    },
    {
        "content": "<p>I am definitely not talking about an iron-clad safe type system like ML, I don't think lean will ever be that, it's just not useful enough in practice</p>",
        "id": 397893701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697938420
    },
    {
        "content": "<blockquote>\n<p>things can be made memory-unsafe without clear markings</p>\n</blockquote>\n<p>what evidence do you have for this?</p>",
        "id": 397893844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697938498
    },
    {
        "content": "<p>Every method of breaking memory safety I know comes with some kind of calling card</p>",
        "id": 397893872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697938524
    },
    {
        "content": "<p>But remember that the goal is not defense against malicious agents, it is raising the bar for accidental memory errors across teams of fallible humans (like the one we're dealing with now in rc2/3!)</p>",
        "id": 397894040,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697938644
    },
    {
        "content": "<p>The most important implication of that is that metaprogramming shenanigans are much less scary than they would be in a malicious user setting; a culture of marking unsafe things as unsafe is what prevents bad tactics from just ignoring restrictions without a signpost</p>",
        "id": 397894187,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697938757
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/397893872\">said</a>:</p>\n<blockquote>\n<p>Every method of breaking memory safety I know comes with some kind of calling card</p>\n</blockquote>\n<p>The way I was thinking of is that one can just directly override a definition's IR in the the <code>declMapExt</code> to be something memory-unsafe (i.e., a kind of <code>implemented_by</code> without the attribute).</p>",
        "id": 397901196,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697945191
    },
    {
        "content": "<p>(Also, I suspect this will become even easier and more common when the new in-Lean compiler arrives. Performance-sensitive libraries will likely desire to swap out definitions with faster LLVM or assembly-optimized code.)</p>",
        "id": 397901436,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697945412
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/397891344\">said</a>:</p>\n<blockquote>\n<p>As in rust, one needs to sometimes grow the set of synonyms of <code>unsafe</code> as that particular syntactic marker is not necessarily a part of the unsafety-inducing feature</p>\n</blockquote>\n<p>I think a separate memory-unsafe keyword would be very nice! It could then be eventually possible to prove memory-safety at the Lean-level at a particular use site. Using <code>unsafe</code> makes such proofs impossible (as far as I am aware).</p>",
        "id": 397901681,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697945676
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac Malone</span> <a href=\"#narrow/stream/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/397901196\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/397893872\">said</a>:</p>\n<blockquote>\n<p>Every method of breaking memory safety I know comes with some kind of calling card</p>\n</blockquote>\n<p>The way I was thinking of is that one can just directly override a definition's IR in the the <code>declMapExt</code> to be something memory-unsafe (i.e., a kind of <code>implemented_by</code> without the attribute).</p>\n</blockquote>\n<p>The calling card here is nasty metaprogramming code you have to write yourself. Again, this sounds like a malicious user, the right defense here is to say that this is not good code and discourage it from promulgating</p>",
        "id": 397902460,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697946504
    },
    {
        "content": "<p>You can also write procedural macros in rust that hide <code>unsafe</code>. Just Say No</p>",
        "id": 397902500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697946574
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac Malone</span> <a href=\"#narrow/stream/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/397901681\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/397891344\">said</a>:</p>\n<blockquote>\n<p>As in rust, one needs to sometimes grow the set of synonyms of <code>unsafe</code> as that particular syntactic marker is not necessarily a part of the unsafety-inducing feature</p>\n</blockquote>\n<p>I think a separate memory-unsafe keyword would be very nice! It could then be eventually possible to prove memory-safety at the Lean-level at a particular use site. Using <code>unsafe</code> makes such proofs impossible (as far as I am aware).</p>\n</blockquote>\n<p>Proving memory-safety at the lean level would be extremely difficult, as it would require a deep embedding of the lean runtime. It's a nice project idea but it is a long-term thing. (In that case it wouldn't matter whether you use <code>unsafe</code> or not, you can express what safety means explicitly and see what all functions are doing, <code>unsafe</code> or otherwise.)</p>",
        "id": 397902633,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697946721
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/397902460\">said</a>:</p>\n<blockquote>\n<p>The calling card here is nasty metaprogramming code you have to write yourself. Again, this sounds like a malicious user, the right defense here is to say that this is not good code and discourage it from promulgating</p>\n</blockquote>\n<p>I think you are undervaluing the positive benefits of this kind of metaprogramming shenanigans. I imagine there will be many DSLs that inject code directly and may not themselves be memory-safe (and thus promulgate downwards). For instance, Alloy already allows you to write memory-unsafe code, and would probably be doing a trick like this for C code generation if it was currently possible. FFI code may also enable direct access to memory primitives to enable more bare metal coding for performance-intensive actions. For example, the <code>CompactedRegion</code> object used in the Lean core.</p>\n<p>The point here is that I do not think it will generally be reasonable to expect that Lean libraries will be contractually memory-safe like they usually are in Rust due to the fact that it simply isn't strictly enforced (and likely cannot be) by the language. It is also not like this is without precedence within functional programming. It is also relatively easy to write memory-unsafe code in Haskell, for instance. I do still think that libraries should generally strive to be memory-safe and memory-unsafety is a usually a code smell. But I think that calling Lean a memory-safe language may give users expectations that it is like Rust and lead to confusion and frustration when they find out memory unsafety is quite possible and already exposed publicly (without <code>unsafe</code>) in just core.</p>",
        "id": 397905115,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697949263
    },
    {
        "content": "<blockquote>\n<p>I think you are undervaluing the positive benefits of this kind of metaprogramming shenanigans.</p>\n</blockquote>\n<p>I am not, metaprogramming shenanigans are of course useful and I do them all the time. But they are <em>tricky</em> and require careful auditing. They can be as bad as any unsafe code, although they usually aren't.</p>\n<blockquote>\n<p>For instance, Alloy already allows you to write memory-unsafe code, and would probably be doing a trick like this for C code generation if it was currently possible.</p>\n</blockquote>\n<p>As far as the \"culture\" is concerned, good metaprograms should be clear about whether they are always safe, always unsafe or whether they contain an internal \"calling card\" for opting in to unsafety. For alloy I think one would just say that every alloy block is unsafe, because C has no meaningful additional unsafety signpost.</p>",
        "id": 397905702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697949886
    },
    {
        "content": "<blockquote>\n<p>The point here is that I do not think it will generally be reasonable to expect that Lean libraries will be contractually memory-safe like they usually are in Rust due to the fact that it simply isn't strictly enforced (and likely cannot be) by the language.</p>\n</blockquote>\n<p>I think you overestimate the difference between rust and lean in this regard. Rust \"strictly enforces memory safety\" in the same way that lean \"strictly enforces memory safety\": there is a large and useful subset of the language with the property that if you stay in that subset then memory safety is promised. You are not prevented from exiting that subset, but it is considered good design to ensure that whenever you leave the garden you put a \"here be dragons\" sign</p>",
        "id": 397905898,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697950087
    },
    {
        "content": "<p>See the <a href=\"https://docs.rs/plutonium/latest/plutonium/\">plutonium</a> crate for a great example of a library that deliberately ignores this design practice for comedic effect</p>",
        "id": 397906090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697950265
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/397905898\">said</a>:</p>\n<blockquote>\n<p>You are not prevented from exiting that subset, but it is considered good design to ensure that whenever you leave the garden you put a \"here be dragons\" sign</p>\n</blockquote>\n<p>My understanding of Rust is that the signpost is not optional: memory-unsafe code must be marked unsafe. Even the plutonium crate you mentioned just hides the <code>unsafe</code> marking from the user, the code is still marked as such to Rust's view of it. Lean can have memory-unsafe code with no internal marking, which I consider to be a very significant difference. I view Rust's rules on memory-safety to be much closer to Lean's rules on type-safety than its rules on memory-safety. You also <a href=\"#narrow/stream/270676-lean4/topic/soundness.20bug.3A.20native_decide.20leakage/near/397834986\">noted</a> that this comparison worked somewhat in the reverse -- as Rust would treat failure to mark memory-safety as unsoundness. However, I can understand how one could view this difference to be practically less significant than I do.</p>",
        "id": 397907128,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697951244
    },
    {
        "content": "<blockquote>\n<p>Lean can have memory-unsafe code with no internal marking, which I consider to be a very significant difference.</p>\n</blockquote>\n<p>Lean has an internal marking for unsafe code, <code>.unsafe</code> is a <code>DeclarationSafety</code> setting and if you don't use it the kernel rejects the definition</p>",
        "id": 397907878,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697951918
    },
    {
        "content": "<p>Macros/elaborators/tactics are not required to surface this <code>unsafe</code> as a piece of literal input text (although they are encouraged to), but that's analogous to what the <code>#[safe]</code> macro is doing in the plutonium crate</p>",
        "id": 397907942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697952000
    },
    {
        "content": "<p>It is true though that Rust has a well defined \"AST\" layer which all macros desugar to, such that thereafter everything is in the hands of the compiler and we can make clearer statements about what is and is not allowed (and in particular, all unsafe ops have to be wrapped in <code>unsafe</code> by this point). In lean this layer does not really exist, as user code continues to interact at the AST layer and the typechecker layer. The only point where you can sensibly say the user has to take their hands off now and let the core do its thing is the Expr layer and the kernel</p>",
        "id": 397908311,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697952287
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I'm confused. Doesn't that just further demonstrate that Rust memory-safety and Lean type-safety have more in common than Lean memory-safety and Rust memory-safety?</p>",
        "id": 397908317,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697952289
    },
    {
        "content": "<p>As <code>DeclarationSafety</code> is type-safety not memory-safety and the kernel-checked <code>Expr</code> layer works like Rust's compiler-checked AST layer.</p>",
        "id": 397908392,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697952338
    },
    {
        "content": "<p>Rust memory-safety of course has parallels to both Lean memory-safety and lean type-safety. But Rust memory-safety is not really a type system property, it is partially upheld by type system rules but <code>unsafe</code> is an AST layer effect not a type checker effect</p>",
        "id": 397908499,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697952383
    },
    {
        "content": "<p>As far as the rust soundness theorem goes, every <code>unsafe</code> block comes with an extra proof obligation (you can imagine <code>:= sorry</code> being stuffed somewhere in the syntax) arguing that memory safety is not broken by this unsafe block. In that way it certainly looks like a type system property, and one could in principle do the same thing for lean, embedding the runtime and making assertions about the memory safety of unsafe blocks (and the compiler proving these assertions for anything satisfying the regular lean type system)</p>",
        "id": 397909266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697952699
    },
    {
        "content": "<p>Lean rigorously checks type-safety via the kernel and Rust rigorously checks memory-safety via the compiler. One can only bypass this checks via a mandatory <code>unsafe</code> marking (which may or may not exposed at user-level syntax, but is a code smell if not). Thus, Lean type-safety and Rust memory-safety can be seen to have a comparable level of rigor in this respect. For memory-safety, Lean performs no such rigorous check. Thus, Lean memory-safety can be seen as being on a significantly lower level to both Rust memory-safety and Lean type-safety, and, therefore, Lean is not memory-safe in the way it is type-safe or the way Rust is memory-safe.</p>",
        "id": 397909540,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697952799
    },
    {
        "content": "<p>This is the general thesis I was attempting to assert based on my understanding of the two languages.</p>",
        "id": 397909726,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697952877
    },
    {
        "content": "<blockquote>\n<p>For memory-safety, Lean performs no such rigorous check.</p>\n</blockquote>\n<p>At some level I agree with you, Lean has certainly not prioritized this. However, the core language itself (CIC stuff) is memory-safe (to the best of our knowledge), which means that memory safety is possible to layer on top without much difficulty: you just have to treat any departure from that base language as unsafe, and then trim the paranoia back for certain additional things which we can reason are safe in all possible use cases.</p>\n<p>Here's another rust example: the <code>#[no_mangle]</code> attribute is unsafe, because it allows you to cause name collisions between functions with different signatures (the linker will merge the two definitions, and hence this ends up as an accidental <code>implemented_by</code>). There is no word <code>unsafe</code> in the attribute name, and this is considered unfortunate, but it doesn't really break the memory safety promise of the language itself, they just say that you should treat uses of this attribute as equivalent to an <code>unsafe</code> block, and the <code>unsafe_code</code> linter is taught this as well, so if you enable this then you can be sure that if the lint doesn't fire then there are neither <code>unsafe</code> blocks nor <code>#[no_mangle]</code> definitions in the crate.</p>",
        "id": 397910937,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697953491
    },
    {
        "content": "<p>Passing the <code>unsafe_code</code> linter is a really high bar, most projects at a certain level of complexity will have need for some nonzero amount of unsafe code, but a surprisingly large amount of code in the wild can be done with no unsafe at all (in both rust and lean), so it's not as useless a lint as you might think. More realistically, there might be some half dozen unsafe blocks in the project and you just surround them with copious amounts of documentation.</p>",
        "id": 397911176,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697953739
    },
    {
        "content": "<p>(FFI crates in particular tend to have a much higher incidence of unsafe code. But you can still do your best to document the invariants of the project you are linking to and try to provide a safe interface so that the unsafety is limited to the FFI itself and downstream packages don't also need to pay the price.)</p>",
        "id": 397911265,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697953824
    }
]