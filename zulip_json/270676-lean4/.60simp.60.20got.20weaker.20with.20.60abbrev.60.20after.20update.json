[
    {
        "content": "<p>Hi there! I am developing a tactic for computing asymptotics of real functions, and for this, I need a type for \"lazy formal multiseries,\" which I have defined as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Seq</span><span class=\"bp\">.</span><span class=\"n\">Seq</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Stream'</span><span class=\"w\"> </span><span class=\"n\">Seq</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Multiseries</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">basis</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">basis</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ℝ</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Seq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Multiseries</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I used <code>abbrev</code> because I frequently rely on the API for <code>Stream'.Seq</code>. This allows me, for instance, to directly use <code>simp</code> lemmas for <code>Stream'.Seq</code>. However, after updating Lean from <code>v4.14.0-rc2</code> to <code>v4.15.0-rc1</code>, <code>simp</code> stopped working in many places. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Seq</span><span class=\"bp\">.</span><span class=\"n\">Seq</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">TypeTags</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">MinMax</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Stream'</span><span class=\"w\"> </span><span class=\"n\">Seq</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Multiseries</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">basis</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">basis</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ℝ</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Seq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Multiseries</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">leadingExp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">basis_hd</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">basis_tl</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ms</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multiseries</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">basis_hd</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">basis_tl</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WithBot</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">ms</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⊥</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exp</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">maxExp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">basis_hd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">basis_tl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">li</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Multiseries</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">basis_hd</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">basis_tl</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WithBot</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">li</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">leadingExp</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">maximum</span><span class=\"bp\">.</span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">maxExp_nil</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">basis_hd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">basis_tl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">maxExp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">basis_hd</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">basis_hd</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">basis_tl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">basis_tl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">maxExp</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">maxExp_nil_again</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">basis_hd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">basis_tl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">maxExp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">basis_hd</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">basis_hd</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">basis_tl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">basis_tl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c1\">-- simp made no progress</span>\n</code></pre></div>\n<p>My observations:</p>\n<ol>\n<li>It works correctly if I define it with <code>def</code>.</li>\n<li>It also works if I use <code>simp (config := { index := false })</code> in the last line, which I find a little strange.</li>\n</ol>\n<p>The issue seems to arise because <code>simp</code> unfolds the reducible definition <code>Multiseries</code> before searching for lemmas. </p>\n<p>I have two questions:</p>\n<ol>\n<li>Is this behavior of <code>simp</code> intentional?</li>\n<li>Is defining it with <code>def</code> and translating all necessary lemmas about <code>Stream.Seq'</code> the only solution, or are there some hacks?</li>\n</ol>",
        "id": 486113918,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1733324784
    },
    {
        "content": "<p>In the definition of the simp lemma, if you replace the definition of <code>MultiSeries</code> by hand, writing <code>([] : List (Seq (ℝ × Multiseries basis_tl)))</code> instead of <code>[]</code>, the problem gets fixed.</p>\n<p>When simp generates the discrimination tree keys, it uses the setting <code>iota := false</code>, meaning that it doesn't unfold match expressions. So the discrimination tree keys contain the match expression from the definition of <code>Multiseries</code>. However, when it looks up expressions during the <code>simp</code> tactic, it uses <code>iota := true</code>, so then it does reduce the match expression.</p>\n<p>Because the discrimination tree keys are different, it never tries the lemma. <code>index := false</code> turns off the use of the discrimination tree, so that makes it work.</p>\n<p>This behaviour was introduced with <a href=\"https://github.com/leanprover-community/mathlib4/pull/6053\">#6053</a>, and seems like a bug to me.</p>",
        "id": 486194250,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1733353612
    },
    {
        "content": "<p>Is this perhaps fixed by <a href=\"https://github.com/leanprover/lean4/pull/6123\">lean#6123</a>? If someone wanted to try it out the <code>lean-pr-testing-6123</code> branch of Mathlib might suffice.</p>",
        "id": 486194555,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1733353779
    },
    {
        "content": "<p>It doesn't seem to be fixed there.</p>",
        "id": 486333495,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1733412894
    },
    {
        "content": "<p>Note also that replacing <code>simp</code> by <code>simp -iota</code> makes it work as well.</p>",
        "id": 486333621,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1733412920
    },
    {
        "content": "<p>But if we write <code>([] : List (Seq (ℝ × Multiseries basis_tl)))</code> instead of <code>[]</code>, then <code>simp</code> works and <code>simp -iota</code> doesn't work.</p>",
        "id": 486334103,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1733413039
    },
    {
        "content": "<p>So the underlying problem is that discrimination tree keys are computed in one fixed configuration. And using a different lookup configuration may cause mismatches in the discrimination tree keys.</p>",
        "id": 486334525,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1733413155
    },
    {
        "content": "<p>So I guess the best we can do is to make sure that the configuration for computing the discrimination tree keys is the same as the default configuration for <code>simp</code>.</p>",
        "id": 486335171,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1733413299
    },
    {
        "content": "<p>(So that in this case <code>simp</code> works and <code>simp -iota</code> doesn't work)</p>",
        "id": 486336020,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1733413498
    },
    {
        "content": "<p>There were recent changes around this; the default config for computing the discr tree keys should now have <code>iota := true</code>. See <a href=\"https://github.com/leanprover/lean4/blob/019f8e175f9650b829aca8ee501f41c0a5d9076d/src/Lean/Meta/Tactic/Simp/Types.lean#L125\">here</a>.</p>",
        "id": 486336465,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1733413607
    },
    {
        "content": "<p>A minimized Mathlib free example still fails on lean nightly</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Multiseries</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">basis</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">basis</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Multiseries</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"o\">)</span>\n\n<span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">maxExp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">basis_hd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">basis_tl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">li</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Multiseries</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">basis_hd</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">basis_tl</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">maxExp_nil</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">basis_hd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">basis_tl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">maxExp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">basis_hd</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">basis_hd</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">basis_tl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">basis_tl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">([])</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">maxExp_nil_again</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">basis_hd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">basis_tl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">maxExp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">basis_hd</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">basis_hd</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">basis_tl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">basis_tl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c1\">-- simp made no progress</span>\n</code></pre></div>",
        "id": 486337591,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1733413906
    },
    {
        "content": "<p>So it seems to still use <code>iota := false</code> for computing the discrimination tree keys for simp lemmas.</p>",
        "id": 486337860,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1733413979
    },
    {
        "content": "<p>Ah you're right, a different config is used for global simp theorems. <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span> <a href=\"https://github.com/leanprover/lean4/blob/019f8e175f9650b829aca8ee501f41c0a5d9076d/src/Lean/Meta/Tactic/Simp/SimpTheorems.lean#L210\">https://github.com/leanprover/lean4/blob/019f8e175f9650b829aca8ee501f41c0a5d9076d/src/Lean/Meta/Tactic/Simp/SimpTheorems.lean#L210</a></p>",
        "id": 486339163,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1733414297
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span>, could you open an issue with this one?</p>",
        "id": 486414786,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1733443139
    },
    {
        "content": "<p>Here is the issue: <a href=\"https://github.com/leanprover/lean4/pull/6331\">lean#6331</a></p>",
        "id": 486596872,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1733520231
    }
]