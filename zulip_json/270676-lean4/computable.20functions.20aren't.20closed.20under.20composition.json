[
    {
        "content": "<p>I've been running into some sad/frustrating issues where I'll have two not-<code>noncomputable</code> functions, f and g, but their composition is noncomputable. Essentially this happens because some of the compiler optimizations are nondeterministic. (Okay, they're \"deterministic\" in the strict sense, but what I mean is that they're very fragile and sensitive to small changes.)</p>\n<p>Because the compiler tries to inline small-ish things, I've found it quite tricky to produce a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, but there's an example of this I describe <a href=\"https://github.com/Timeroot/ComputableReal/blob/498ebfa701dac798922eae65ccca69872f3c3386/ComputableReal/SpecialFunctions/Basic.lean#L93\">here</a>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">--This works:</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sign</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"c1\">--This works:</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"c1\">--This, which is just the logical and of the two above expressions, fails as its noncomputable:</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sign</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 501388672,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1740327461
    },
    {
        "content": "<p>What's going on is that the expressions refers to noncomputable data (in this case, the division of two reals). So it is \"structurally\" noncomputable.</p>",
        "id": 501388734,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1740327493
    },
    {
        "content": "<p>But then the compiler recognizes that this data isn't actually used -- it gets referred to by some of the relevant instances, but then it's never actually used, so it doesn't need this value. So it compiles it and happily moves on, and it's computable.</p>",
        "id": 501388766,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1740327528
    },
    {
        "content": "<p>But the conditions on when it recognizes that it can drop the data seem kind of fragile. If it doesn't manage to do the right optimizations in the right order, then the compiled top-level function still takes the Real.instDiv'd data, which is noncomputable, and so it fails.</p>",
        "id": 501388835,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1740327595
    },
    {
        "content": "<p>could you complete your code snippet such that it works on live lean?</p>",
        "id": 501388945,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740327674
    },
    {
        "content": "<p>Not easily, since it requires the <code>ComputableReal</code> package (and a lot of dependent code). This is what I mean by difficulty getting a good <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>. :(</p>",
        "id": 501389086,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1740327822
    },
    {
        "content": "<p>I would like to find an easier way to trigger this behavior though, I'm trying</p>",
        "id": 501389157,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1740327864
    },
    {
        "content": "<p>It requires, at a minimum:</p>\n<ul>\n<li>A type <code>A</code> and a dependent type <code>B : A -&gt; Type</code></li>\n<li>A noncomputable function <code>f : A</code></li>\n<li>A computable function <code>g : (x : A) (y : B x)</code> whose value depends only on data in <code>y</code>, not in <code>x</code></li>\n<li>A computable function <code>z : B f</code></li>\n</ul>\n<p>Then when you try to evaluate <code>g f z</code>, sometimes the compiler will stop and <em>not</em> examine g's data dependency, and see that you depend on <code>f</code> which is noncomputable, and fail. And sometimes the compiler will recognize that g doesn't depend on f, and so it effectively compiles to something like <code>g _ z</code>, and can run it.</p>",
        "id": 501389502,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1740328162
    },
    {
        "content": "<p>The relevant compiler pass -- or maybe, one relevant pass -- is <code>compiler.reduce_arity</code>. But this happens before lots of other passes, which may make it more \"obvious\" that the data dependency isn't there. I think if this pass could get triggered again later it would fix \"most\" of the fragility.</p>",
        "id": 501389702,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1740328319
    },
    {
        "content": "<p>A couple of heuristics I've noticed:</p>\n<ul>\n<li>Adding the <code>@[inline]</code> attribute to <code>g</code> significantly improves the chances of it working. In the example above, it makes</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sign</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>work, for instance, whereas without the <code>@[inline]</code> attribute it doesn't. But then if I change the second term to <code>(2 - 1 / 2 : ‚Ñù).sign</code>, that fails even with the inline attribute (and <code>#eval (2 - 1 / 2 : ‚Ñù).sign = 1</code> still works fine.)</p>\n<ul>\n<li>If you put all the \"used\" data arguments after all the \"unused\" data arguments, it seems much more likely to correctly drop them. In fact it might be strictly necessary. That is, supposed <code>g</code> has the signature <code>g : (n : Nat) (x : A) (y : B x)</code>; and <code>g</code> uses the data in <code>n</code> and <code>y</code>. Then, in my experiments, this will <em>never</em> work and end up computable. But if you reorder the arguments to be <code>g : (x : A) (n : Nat) (y : B x)</code>, then it will sometimes work.</li>\n</ul>",
        "id": 501389980,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1740328519
    },
    {
        "content": "<p>Given that there is significant work on the new code generator at the moment, you may need to wait until it is deployed, as we're no longer modifying the old one barring critical bugs.</p>",
        "id": 501432997,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1740363761
    },
    {
        "content": "<p>I see, alright. Makes sense.<br>\nFWIW I was thinking about how I would ideally have this addressed. (I won't say \"fixed\", because it's not exactly a bug, just ... undesirable behavior.) I think anything based on compiler optimizations is ultimately kind of fragile.</p>\n<p>So I was wondering, if somehow there could be something like a <code>noData</code> modifier, sort of similar to how <code>outParam</code> modifies a parameter but doesn't modify the type. And this would tell the compiler that, even though this is a data-carrying type being passed in, its value is not used anywhere and so it should make sure the type is dropped. And then there would be some kind of requirement, for this to pass, that the function only refers to that parameter in the context of <code>Prop</code>s, arguments to types, or other <code>noData</code> function parameters.</p>\n<p>Of course, alternately it could become part of the spec that the compiler <em>must</em> identify all <code>noData</code> arguments (which it can do) and inline them; this is just sort of philosophically changing what is currently a compiler \"optimization\" into a compiler \"spec\".</p>\n<p>I have <em>no</em> clue how much work such a feature or guarantee would be. :) Just thinking out loud</p>",
        "id": 501433847,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1740364304
    },
    {
        "content": "<p>I remember looking into how to add something like <code>noData</code> to Lean 3 at some point. I'm not sure I can find the discussions from around 2022 about that.</p>\n<p>Something else I remember is a <code>Computable</code> class, which would be a way to replace expressions with a computation: <a class=\"message-link\" href=\"/#narrow/channel/113488-general/topic/computable.20class/near/274328626\">#general &gt; computable class @ üí¨</a> (it's not quite <code>@[csimp]</code> since a <code>Computable</code> instance can conditionally apply).</p>\n<p>You might also look into discussions about the <code>erased</code> type from back then. I think one idea with \"<code>noData</code>\" was to make it so working with <code>erased</code> would be seamless somehow.</p>",
        "id": 501434768,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740364967
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/270676-lean4/topic/computable.20functions.20aren't.20closed.20under.20composition/near/501432997\">said</a>:</p>\n<blockquote>\n<p>Given that there is significant work on the new code generator at the moment, you may need to wait until it is deployed, as we're no longer modifying the old one barring critical bugs.</p>\n</blockquote>\n<p>How can I try out the new generator? I tried <code>set_option compiler.enableNew true</code> but it didn't seem to have any effect. (It still says \"compiling [old]\".)</p>",
        "id": 501591659,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1740414798
    },
    {
        "content": "<p>Enabling the new compiler enables it in addition to the old one as the new one is not yet at the point where it can produce a binary.</p>",
        "id": 501594672,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1740415511
    },
    {
        "content": "<p>Ah, ok.</p>",
        "id": 501594763,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1740415532
    }
]