[
    {
        "content": "<p>When working on <a href=\"https://github.com/leanprover-community/mathlib4/pull/21330\">#21330</a>, which changes some <code>aesop</code> proofs to be <code>rfl</code> proofs, I discovered that replacing a proof in one declaration can break a proof in a later declaration. This seems very worrying to me, because it means that a proof can be, in some sense, \"wrong\" even if lean says it is correct. And making a change to a proof in one file can break a later file.</p>\n<p>Here is the minimal working example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Comma</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PLift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">Comma</span><span class=\"o\">]</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">CommaMorphism</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Comma</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span>\n<span class=\"w\">  </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommaMorphism</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">rfl</span><span class=\"bp\">âŸ©</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- replace this with `id rfl` for the example to work</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">(kernel) declaration type mismatch, '_example' has type</span>\n<span class=\"cm\">  âˆ€ [inst : Inhabited Comma] (X : Comma) (f : CommaMorphism X), f = f</span>\n<span class=\"cm\">but it is expected to have type</span>\n<span class=\"cm\">  âˆ€ [inst : Inhabited Comma] (X : Comma) (f : CommaMorphism X), f = mk f.s</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Comma</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommaMorphism</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>By using <code>#print mk</code>, we can see how the different proofs of <code>w</code> affect the definition of <code>mk</code>. If the proof is given as <code>rfl</code>, then <code>#print mk</code> shows that the proof is replaced by <code>mk.proof_2 : default = default</code>, but when the proof is given as <code>id rfl</code>, then it shows <code>mk.proof_2 : default = { down := rfl }</code>. Although these versions are definitionally equal (as proven by <code>rfl</code>), the second option is better because it matches the expected type of the proof.</p>\n<p>Interestingly, this minimal example can also be fixed by replacing <code>default = c</code> with <code>c = default</code></p>\n<p>The original example involved the Discrete category, in which a morphism from <code>X</code> to <code>Y</code> is defined as a <code>PLift</code> of <code>X = Y</code>, and the relevant constants are <code>CategoryTheory.Comma.fromProd</code> and <code>CategoryTheory.Comma.equivProd</code>.</p>",
        "id": 497313462,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1738547475
    },
    {
        "content": "<p>I've encountered this issue before while working on <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> 's Formalizing Mathematics about half a year ago.</p>",
        "id": 497316964,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1738549849
    },
    {
        "content": "<p>Interesting. This is an example of the elaborator defeq accepting something the kernel defeq doesn't.</p>\n<p>I wouldn't attribute the error to the way AbstractNestedProofs works. There's no reason to expect the following variation to fail:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Comma</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PLift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">Comma</span><span class=\"o\">]</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">CommaMorphism</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Comma</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span>\n<span class=\"w\">  </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">proof_2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Comma</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommaMorphism</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">rfl</span><span class=\"bp\">âŸ©</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">proof_2</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">(kernel) declaration type mismatch, '_example' has type</span>\n<span class=\"cm\">  âˆ€ [inst : Inhabited Comma] (X : Comma) (f : CommaMorphism X), f = f</span>\n<span class=\"cm\">but it is expected to have type</span>\n<span class=\"cm\">  âˆ€ [inst : Inhabited Comma] (X : Comma) (f : CommaMorphism X), f = mk f.s</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Comma</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommaMorphism</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 497320521,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738552401
    },
    {
        "content": "<blockquote>\n<p>This is an example of the elaborator defeq accepting something the kernel defeq doesn't.</p>\n</blockquote>\n<p>Maybe connected to <a href=\"#narrow/channel/287929-mathlib4/topic/Slow.20rfl.20.28timeout.29.20with.20.60Algebra.2Eadjoin.60/near/485429951\">#mathlib4 &gt; Slow rfl (timeout) with &#96;Algebra.adjoin&#96; @ ðŸ’¬</a> which is also about structure eta.</p>",
        "id": 497320971,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1738552777
    }
]