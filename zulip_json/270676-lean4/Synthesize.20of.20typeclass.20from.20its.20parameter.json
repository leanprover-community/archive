[
    {
        "content": "<p>I'm trying to formalize modal logic in Lean 4, and I finished formalizing Gödel's ontological proof in this link <a href=\"https://github.com/znssong/lean-modal-logic/blob/main/god_exists.lean\">https://github.com/znssong/lean-modal-logic/blob/main/god_exists.lean</a>. I found the formalization of modal logic will be very easy if typeclass can be synthesized from its parameter; for example, in current nightly version of Lean 4, the following code</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span>\n</code></pre></div>\n<p>will fail and report that typeclass can't be synthesized.</p>\n<p>We use typeclass to represent the \"current\" possible world: <code>@[class] axiom World : Type</code> and <code>variable [w : World]</code>. The necessary modality takes a <code>&amp;Prop</code> (notation for <code>[World] → Prop</code>), and outputs a <code>Prop</code> which uses the current world <code>w</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Necessary</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">&amp;</span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">w'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Accessible</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">w'</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">@.</span><span class=\"n\">w'</span>\n</code></pre></div>\n<p>where <code>@.</code> is the instantiation of <code>&amp;Prop</code> at a certain possible world. So, when you write <code>□∀x, p x</code>, the elaborator will know <code>∀x, p x</code> is a <code>Prop</code> and <code>□</code> needs a <code>&amp;Prop</code>, so it will automatically introduce the parameter <code>[World]</code> in <code>&amp;Prop := [World] → Prop</code> into the context as <code>w✝</code>. Moreover, because the lastly introduced local instance will get more priority (see the source code of <code>Lean.Meta.SynthInstance.getInstances</code>), so <code>w✝</code> will become the new \"current world\", and the proposition <code>p</code> in <code>□p</code> will automatically uses the world implicitly mentioned in <code>□</code>. That is, when I'm writing <code>∀x, p x</code> for <code>p : [w : World] → @Object w → Prop</code>, it will be instantiated as <code>∀x, @p w x</code> where <code>w</code> be the section variable (current world), and when writing <code>□∀x, p x</code>, it will be instantiated as <code>∀w', Accessible w w' → ∀x, @p w' x</code>, because the synthesizer will choose newly introduced <code>w✝</code> as the instance of class <code>World</code>.</p>\n<p>But another things happens. Without this modification, the compilation will fail at <code>positive_possible_exists</code>, when elaborating <code>◇∃ x, P x</code>. That is because the type of <code>x</code> is a metavariable during elaboration, and we need to fill the metavariable; for example, it is <code>?m.49386 P w✝</code> now.  However, <code>?m.49386</code> is of type <code>{P : Property} → [w : World] → Sort ?u.49372</code>, and its context is only the global context <code>w : World</code>, where the newly introduced variable <code>P</code> and <code>w✝</code> turned to parameters in the type of metavariable. So in <code>isDefEq</code>, <code>?m.49386</code> will be filled using <code>w</code> instead of <code>w✝</code>, since the type class inference only cares about <code>LCtx</code> of metavariables and ignores <code>[w : World]</code> in the parameter of its type. So it will report an error: <code>synthesized type class instance is not definitionally equal to expression inferred by typing rules</code>.</p>\n<p>I modified the Lean source code for fixing this, and the snippet was contained in the proof. I wonder whether this snippet could be merged into the mainline. May I open a PR for this?</p>",
        "id": 473276331,
        "sender_full_name": "Shuhao Song",
        "timestamp": 1727494082
    },
    {
        "content": "<p>I'm struggling to understand what you're asking. Can you give an example of whatever problem you're seeing without using <code>axiom</code>? </p>\n<p>In general, proposals to touch anything to do with typeclass synthesis are received with considerable skepticism. :-)</p>",
        "id": 473284063,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1727498600
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/270676-lean4/topic/Synthesize.20of.20typeclass.20from.20its.20parameter/near/473284063\">said</a>:</p>\n<blockquote>\n<p>I'm struggling to understand what you're asking. Can you give an example of whatever problem you're seeing without using <code>axiom</code>? </p>\n<p>In general, proposals to touch anything to do with typeclass synthesis are received with considerable skepticism. :-)</p>\n</blockquote>\n<p>Why you need \"without using <code>axiom</code>\"? Postulating <code>axiom</code> or <code>variable</code> in examples are common. For example, when you want to consider an abstract class as example, you may use <code>@[class] axiom C : Type</code>.</p>",
        "id": 473296831,
        "sender_full_name": "Shuhao Song",
        "timestamp": 1727505072
    },
    {
        "content": "<p>Mathlib has many variables but no axioms. So postulating axioms in mathematics in lean is arguably extremely rare, not common.</p>",
        "id": 475081347,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728207465
    }
]