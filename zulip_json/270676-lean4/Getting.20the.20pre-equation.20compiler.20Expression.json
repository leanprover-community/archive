[
    {
        "content": "<p>Hello, I am trying to write an attribute macro which uses <code>getConstInfo</code> to get a <code>def</code> function. I want to get the function without any compilation via BrecOn. Is this possible?</p>\n<p>For example, I have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">counting</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">counting</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p><code>getConstInfo</code> though gives the Expression for </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">counting</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">Nat.brecOn</span> <span class=\"n\">n</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Nat.below</span> <span class=\"n\">n</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n      <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.fst.fst</span><span class=\"o\">)</span>\n      <span class=\"n\">f</span>\n</code></pre></div>",
        "id": 364738162,
        "sender_full_name": "Lev Stambler",
        "timestamp": 1686290327
    },
    {
        "content": "<p>No, this expression is not stored so unless you intercept it during creation it isn't available. There are basically four options:</p>\n<ol>\n<li>Use the definition (brecOn ugliness)</li>\n<li>Use the equations (you can ask for these to be generated)</li>\n<li>Use the <code>_sunfold</code> smart unfolding theorem (from which 2 is generated IIRC)</li>\n<li>Use the compiled code or IR (not an Expr, but reflects the original recursive structure better)</li>\n</ol>",
        "id": 364739148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686290683
    },
    {
        "content": "<p>Lean also doesn‚Äôt have native <code>match</code></p>",
        "id": 364750799,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1686294294
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Getting.20the.20pre-equation.20compiler.20Expression/near/364739148\">said</a>:</p>\n<blockquote>\n<p>No, this expression is not stored so unless you intercept it during creation it isn't available. There are basically four options:</p>\n<ol>\n<li>Use the definition (brecOn ugliness)</li>\n<li>Use the equations (you can ask for these to be generated)</li>\n<li>Use the <code>_sunfold</code> smart unfolding theorem (from which 2 is generated IIRC)</li>\n<li>Use the compiled code or IR (not an Expr, but reflects the original recursive structure better)</li>\n</ol>\n</blockquote>\n<p>Thank you for the response! What do you mean by getting the equations and how could I do so?</p>",
        "id": 365257528,
        "sender_full_name": "Lev Stambler",
        "timestamp": 1686470584
    },
    {
        "content": "<p>this might be relevant? <a href=\"#narrow/stream/270676-lean4/topic/Equational.20Lemmas\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Equational.20Lemmas</a><br>\nwhich references this api: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Meta/Eqns.html#Lean.Meta.getEqnsFor\">https://leanprover-community.github.io/mathlib4_docs/Lean/Meta/Eqns.html#Lean.Meta.getEqnsFor</a>?</p>",
        "id": 365263749,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1686472907
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/Getting.20the.20pre-equation.20compiler.20Expression/near/365263749\">said</a>:</p>\n<blockquote>\n<p>this might be relevant? <a href=\"#narrow/stream/270676-lean4/topic/Equational.20Lemmas\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Equational.20Lemmas</a><br>\nwhich references this api: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Meta/Eqns.html#Lean.Meta.getEqnsFor\">https://leanprover-community.github.io/mathlib4_docs/Lean/Meta/Eqns.html#Lean.Meta.getEqnsFor</a>?</p>\n</blockquote>\n<p>This is fantastic thank you</p>",
        "id": 365501293,
        "sender_full_name": "Lev Stambler",
        "timestamp": 1686563357
    },
    {
        "content": "<p>Okay. <code>getEqnsFor</code> looks almost like what I would want but would love to just get the expressions in the match (not the associated theorems for termination) .</p>",
        "id": 365567510,
        "sender_full_name": "Lev Stambler",
        "timestamp": 1686577348
    },
    {
        "content": "<p>do you have an example? I'm not really familiar with what the function returns right now...</p>",
        "id": 366094280,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1686731656
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/Getting.20the.20pre-equation.20compiler.20Expression/near/366094280\">said</a>:</p>\n<blockquote>\n<p>do you have an example? I'm not really familiar with what the function returns right now...</p>\n</blockquote>\n<p>So, overall, I would like some simple way to modify my written function to add small statements after every sub-expression in a recursive function (i.e. counting runtime). I think it'd be doable if for a recursive function, I can get an expression associated with a case.</p>\n<p>So, for </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">counting3</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Bool</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">counting3</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>I'd get some expression representing <code>0 =&gt; false</code> and <code>n + 1 =&gt; counting3 n</code>. Right now, getEqnsFor returns</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">private</span> <span class=\"kd\">theorem</span> <span class=\"n\">counting3._eq_1</span> <span class=\"o\">:</span> <span class=\"n\">counting3</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">counting3</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">private</span> <span class=\"kd\">theorem</span> <span class=\"n\">counting3._eq_2</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">n_1</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"n\">counting3</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n_1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">counting3</span> <span class=\"n\">n_1</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">n_1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">counting3</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n_1</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>which basically encapsulated the functionallity.</p>\n<p>I may also start looking into the compiled code/ IR but have no clue where to start there (I do not have much experience with IR or compilers). <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> do you know of any reading material which I could check out for this? I found <a href=\"https://github.com/leanprover-community/lean/blob/master/doc/export_format.md\">this <code>export_format</code></a> readme, but am unsure if this is what you were referring to.</p>",
        "id": 366303647,
        "sender_full_name": "Lev Stambler",
        "timestamp": 1686776797
    },
    {
        "content": "<p>Why not do it <em>before</em> the definition is compiled? Then you can do whatever you want</p>",
        "id": 366303826,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686776870
    },
    {
        "content": "<p>i.e. an attribute on the definition, or using a new keyword instead of <code>def</code></p>",
        "id": 366303956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686776906
    },
    {
        "content": "<p>When processing a declaration you are given very explicitly all the cases and can do lowering as you see fit</p>",
        "id": 366304071,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686776948
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Getting.20the.20pre-equation.20compiler.20Expression/near/366303826\">said</a>:</p>\n<blockquote>\n<p>Why not do it <em>before</em> the definition is compiled? Then you can do whatever you want</p>\n</blockquote>\n<p>How could I go about doing this? My end goal is to make it an attribute on the definition but am finding it very challenging to debug when writing directly within the attribute and am thus prototyping outside of the attribute macro.</p>\n<p>Alternatively, how would I use a new keyword instead of <code>def</code>?</p>",
        "id": 366490893,
        "sender_full_name": "Lev Stambler",
        "timestamp": 1686834063
    }
]