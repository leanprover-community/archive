[
    {
        "content": "<p>I'm trying to prove that a function is an inverse of another one, but I'm getting stuck trying to do a <code>rw</code> or simplifying the goal. What I have is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">foo₁</span>\n  <span class=\"bp\">|</span> <span class=\"n\">foo₂</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Bar</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Foo</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">here</span> <span class=\"o\">{</span><span class=\"n\">fs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Foo</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">::</span> <span class=\"n\">fs</span><span class=\"o\">)</span> <span class=\"n\">f</span>\n  <span class=\"bp\">|</span> <span class=\"n\">there</span> <span class=\"o\">{</span><span class=\"n\">fs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Foo</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f₁</span> <span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">fs</span> <span class=\"n\">f₂</span> <span class=\"bp\">→</span> <span class=\"n\">Bar</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">::</span> <span class=\"n\">fs</span><span class=\"o\">)</span> <span class=\"n\">f₂</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">from_fin</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Fin</span> <span class=\"n\">fs.length</span> <span class=\"bp\">→</span> <span class=\"bp\">Σ</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">,</span> <span class=\"n\">Bar</span> <span class=\"n\">fs</span> <span class=\"n\">f</span>\n  <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"o\">::</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">Bar.here</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">::</span> <span class=\"n\">fs</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">lt</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">from_fin</span> <span class=\"n\">fs</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Nat.lt_of_succ_lt_succ</span> <span class=\"n\">lt</span><span class=\"o\">⟩</span>\n      <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">Bar.there</span> <span class=\"n\">b</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">to_fin</span> <span class=\"o\">{</span><span class=\"n\">fs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Foo</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Bar</span> <span class=\"n\">fs</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Fin</span> <span class=\"n\">fs.length</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">here</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">Nat.zero_lt_succ</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">there</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">to_fin</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">inverse</span> <span class=\"o\">{</span><span class=\"n\">fs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Foo</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">fs</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">from_fin</span> <span class=\"n\">fs</span> <span class=\"o\">(</span><span class=\"n\">to_fin</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">here</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">there</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">inverse</span> <span class=\"n\">b</span>\n\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">to_fin</span><span class=\"o\">,</span> <span class=\"n\">Fin.succ</span><span class=\"o\">,</span> <span class=\"n\">from_fin</span><span class=\"o\">]</span>\n\n      <span class=\"c1\">-- This is what I want to do, but it causes `tactic 'rewrite' failed, motive is not type correct`</span>\n      <span class=\"c1\">-- rw [Nat.add_zero (to_fin b).val]</span>\n      <span class=\"c1\">-- rw [h]</span>\n\n      <span class=\"c1\">-- Tried a different approach</span>\n      <span class=\"n\">congr</span>\n      <span class=\"bp\">.</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n      <span class=\"bp\">.</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n      <span class=\"bp\">.</span> <span class=\"c1\">-- `simp` doesn't work here nor does a direct `rw` or `subst`</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_zero</span> <span class=\"o\">(</span><span class=\"n\">to_fin</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">]</span>\n        <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The goal seems trivially true, but I don't know how I can do the rewrite (since it says it's not \"type correct\") to use the inductive hypothesis. Any suggestions?</p>",
        "id": 354998926,
        "sender_full_name": "Scott Godwin",
        "timestamp": 1682986827
    },
    {
        "content": "<p>kind of a silly solution, but this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">inverse</span> <span class=\"o\">{</span><span class=\"n\">fs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Foo</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">fs</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">from_fin</span> <span class=\"n\">fs</span> <span class=\"o\">(</span><span class=\"n\">to_fin</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">here</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">@</span><span class=\"n\">there</span> <span class=\"n\">fs</span> <span class=\"n\">f₁</span> <span class=\"n\">_</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">from_fin</span> <span class=\"n\">fs</span> <span class=\"o\">⟨</span><span class=\"n\">to_fin</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span><span class=\"bp\">;</span> <span class=\"o\">(⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">Bar.there</span> <span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">Sigma</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">_</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">inverse</span> <span class=\"n\">b</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 355003173,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682989015
    },
    {
        "content": "<p>Thanks! I'll admit I'm a bit confused why that works but the other approaches didn't. If I understand it correctly, <code>show</code> normalizes both the goal and the given term and unifies them. But that would require it to normalize <code>(to_fin b).val + 0</code> to <code>(to_fin b).val</code> which, while obvious, isn't being normalized when using <code>simp</code>, <code>rw</code>, and <code>subst</code></p>",
        "id": 355005354,
        "sender_full_name": "Scott Godwin",
        "timestamp": 1682990143
    },
    {
        "content": "<p><code>show</code> doesn't normalize anything, it changes the goal to a specified term and unifies it with the goal. The key advantage it has over <code>dsimp</code> and <code>unfold</code> and the like is that you are giving explicitly where you want to end up, rather than what procedure you want to apply. The issue with those other methods is that they don't produce a goal which has the LHS of <code>inverse b</code> syntactically within them</p>",
        "id": 355005971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682990510
    },
    {
        "content": "<p>note that it is important to use only <em>definitional</em> rewriting tactics here (like <code>dsimp</code> over <code>simp</code>), because your goal has a dependent function and so non-definitional rewrites are either not going to apply or will result in a type incorrect term</p>",
        "id": 355006092,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682990577
    },
    {
        "content": "<p>the presence of the <code>let ⟨f, b⟩ := ...; ⟨f, Bar.there b⟩</code> in the definition is messing up <code>dsimp</code> and making it try the wrong thing</p>",
        "id": 355006311,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682990708
    }
]