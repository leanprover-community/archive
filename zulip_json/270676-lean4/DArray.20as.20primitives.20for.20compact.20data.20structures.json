[
    {
        "content": "<p>Lean currently provides <code>Array (α : Type)</code> backed by an efficient implementation. I’d like to make the case that it would be useful to (also) have <code>DArray (α : ∀ (i:Nat), Type)</code>, with the same representation.</p>\n<p>Conceptually, and in terms of proving things, it could look like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">DArray</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span> <span class=\"n\">mk</span> <span class=\"o\">::</span>\n  <span class=\"n\">size</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">vals</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"n\">i</span>\n\n<span class=\"n\">DArray.empty</span> <span class=\"o\">:</span> <span class=\"n\">DArray</span> <span class=\"n\">α</span>\n<span class=\"n\">DArray.get</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">DArray</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">a.size</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"n\">i</span>\n<span class=\"n\">DArray.push</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">DArray</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"n\">a.size</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DArray</span> <span class=\"n\">α</span>\n<span class=\"n\">DArray.set.</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">DArray</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">a.size</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"n\">i.val</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DArray</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>and all the other array operations you’d expect, just with the more general type – and annotated with the usual <code>@[extern]</code> annotations so that this is <em>not</em> the runtime representation.</p>\n<p>The benefit of such a data structure is that it unlocks libraries to implement almost arbitrary complex <em>compact</em> type-safe data structures.</p>\n<p>Consider places where you’d currently use <code>Array (α × β)</code>. This is rather expensive: An array with <strong>n</strong> entries costs $3 + 4 n$ words, and an access requires two indirections. You could improve things a bit by using <code>Array α × Array β</code>, so now you have $6 + 2n$, but still two indirections.</p>\n<p>With <code>DArray</code> you can write a data structure that's isomorphic to <code>Array (α × β)</code> like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Nat.even</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span>\n<span class=\"kd\">def</span> <span class=\"n\">Alternating</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">i.even</span> <span class=\"k\">then</span> <span class=\"n\">α</span> <span class=\"k\">else</span> <span class=\"n\">β</span>\n<span class=\"kd\">structure</span> <span class=\"n\">ArrayPair</span> <span class=\"n\">where</span>\n  <span class=\"n\">arr</span> <span class=\"o\">:</span> <span class=\"n\">DArray</span> <span class=\"o\">(</span><span class=\"n\">Alternating</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"n\">heven</span> <span class=\"o\">:</span> <span class=\"n\">arr.size.even</span>\n</code></pre></div>\n<p>and now the cost is $3 + 2n$ words, and accessing is only one indirection.</p>\n<p>The implementation is a bit nasty, with all those array calculations, but at least it’s doable.</p>\n<p>Of course, this is a rather simple example, I wonder what other kind of data structures might be possible with this… Maybe a library doing more complex Array-of-Tuples transformations.</p>\n<p>It’s _almost_ possible to define this in a pure library, simply using the existing <code>lean_array_*</code> functions in <code>@[extern …]</code>; only the constructor/projections themselves would need a bit of extra code. Preliminary experiments at &lt;<a href=\"https://github.com/nomeata/lean-darray\">https://github.com/nomeata/lean-darray</a>&gt;. But given how this is tied to the FFI, it should probably be provided by the code, if at all?</p>\n<p>Does this sound useful? Should I turn this into a Lean RFC?</p>",
        "id": 392833050,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1695561907
    },
    {
        "content": "<p>(Another use case I can think of and that we talked about here some time ago is tabulating/memoizing  <em>dependent</em> functions with enumerable domain, like <code>Nat.fib</code>.)</p>",
        "id": 392834672,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1695562858
    },
    {
        "content": "<p>There have been some other discussions about dependent arrays before. One point that should be mentioned is that the reason this can't \"just\" be <code>Array (Sigma α)</code> is that the runtime representation of this would be an array of pairs. The trick is that we can encode the first nat in each pair using the position of the element itself.</p>",
        "id": 392857490,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1695580517
    },
    {
        "content": "<p>I think if we're doing any core changes, I'd want the most primitive array you can get in C (which is really just a fixed-length block of memory, that you can address in somewhat arbitrary ways, that can have uninitialized data, etc). But I think last time it was discussed, core doesn't want to change any of the basic FFI types at the moment...</p>",
        "id": 393342164,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1695768111
    },
    {
        "content": "<p>That’s reasonable. And I guess one can implement this as a separate library with judicious use of <code>coerce</code> and  <code>implemented_by</code>.</p>",
        "id": 393422459,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1695803093
    }
]