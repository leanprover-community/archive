[
    {
        "content": "<p>When I elaborate a function using structural recursion, like in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span>\n <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">foo</span> <span class=\"n\">n</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">foo</span>\n</code></pre></div>\n<p>I see it’s using <code>Nat.brecOn</code> to compile it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">Nat.brecOn</span> <span class=\"n\">x</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Nat.below</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.fst.fst</span><span class=\"o\">)</span>\n      <span class=\"n\">f</span>\n</code></pre></div>\n<p>The argument of <code>Nat.brecOn</code> here is <code>(n : Nat) → Nat.below n → Bool</code>, and <code>@Nat.below motive n</code> is a dependent vector of size <code>n</code>, (inductively defined and isomorphic to <code>(i : Fin n) → motive i</code>).</p>\n<p>This looks like it would perform memoization, if the <code>Nat.below n</code> argument contains all the various for <code>i &lt; n</code>, but it doesn't seem to be compiled that way.</p>\n<p>So I wonder: How does the compiler turn the <code>x.fst.fst</code> into a normal recursive function calls? And why go through this detour in the first place?</p>\n<p>(RTFM with pointers are welcome too :-))</p>",
        "id": 397938517,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1697975055
    },
    {
        "content": "<p>I may be able to answer the “why”: This way function definitions that are not just primitively recursive can be expressed using this kind of structural recursion, e.g. the typical <code>fib</code> function</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fib</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span>\n <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">fib</span> <span class=\"n\">n</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">fib</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">fib</span>\n</code></pre></div>\n<p>doesn't need to resort to well-founded recursion.</p>",
        "id": 397941639,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1697978045
    },
    {
        "content": "<p>Ok, and the answer of “how is it compiled” might simply be “not at all”. If I manually write a function using <code>Nat.brecOn</code> in a way that I might try to tease the code generator with, like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sum_below</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">@</span><span class=\"n\">Nat.below</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">unit</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">⟨⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩,</span> <span class=\"bp\">.</span><span class=\"n\">unit</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">sum_below</span> <span class=\"n\">n</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Nat.brecOn</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"n\">sum_below</span>\n</code></pre></div>\n<p>which would look at _all_ the previous values in the <code>Nat.below</code>, it says</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">code</span> <span class=\"n\">generator</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"n\">support</span> <span class=\"n\">recursor</span> <span class=\"bp\">'</span><span class=\"n\">Nat.brecOn'</span> <span class=\"n\">yet</span><span class=\"o\">,</span> <span class=\"n\">consider</span> <span class=\"n\">using</span> <span class=\"bp\">'</span><span class=\"k\">match</span> <span class=\"bp\">...</span> <span class=\"k\">with</span><span class=\"bp\">'</span> <span class=\"n\">and</span><span class=\"bp\">/</span><span class=\"n\">or</span> <span class=\"n\">structural</span> <span class=\"n\">recursion</span>\n</code></pre></div>\n<p>So I conclude that the input to the code generator is _not_ the form I see with <code>#print</code>, with recursion replaced with <code>Nat.brecOn</code>, but some earlier, not-yet-elaborated-to-recursers-form of the function definition? Is that correct?</p>",
        "id": 397941961,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1697978399
    },
    {
        "content": "<p>Yes, that is exactly right. And the potentially unexpected memoization from <code>brecOn</code> that would otherwise happen is one of the and perhaps the main reason for that.</p>",
        "id": 397948973,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1697985368
    },
    {
        "content": "<p>Thanks! What is the “earlier, not-yet-elaborated” form that is then compiled?</p>",
        "id": 397950470,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1697986841
    },
    {
        "content": "<p>Just a direct recursive call, which the compiler understands in contrast to the kernel</p>",
        "id": 397950688,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1697987037
    },
    {
        "content": "<p>Browsing the code a bit it seems that “earlier” state, where recursion is still explicit, is a <code>PreDefinition</code> and <code>addPreDefinitions</code> in <code>src/Lean/Elab/PreDefinition/Main.lean</code> tries various strategies to turn this into a <code>Declaration</code> with recursers which can be added to the environment.</p>\n<p>For example in <code>def structuralRecursion</code> then it produces a <code>preDefNonRec</code> which is added to the kernel’s environment  with <code>addNonRec</code>, and it also produces a <code>let preDef ← eraseRecAppSyntax preDefs[0]!</code> with arbitrary recursion, which is compiled using <code>addAndCompilePartialRec #[preDef]</code>.<br>\nOddly, <code>addAndCompilePartialRec</code> via <code>addAndCompileUnsafe</code> calls <code>eraseRecAppSyntax</code>, but why not, doppelt hält besser.<br>\n<code>addAndCompileUnsafe</code> creates a <code>Declaration.mutualDefnDecl</code>, which I understand can be compiled. I am a bit surprised that this declaration (which the kernel can’t handle, can it) is still passed to <code>addDecl decl</code>…</p>\n<p>Ok, that goes into C++ land, and there it checks that mutual definitions are always <code>partial</code> or <code>unsafe</code>… makes sense. <br>\nBut why is there no name clash now between the recurser-based non-recursive definition, and the mutually recursive one, when both are added to the environment? Does one of them get a mangled name?</p>",
        "id": 397964835,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1698000663
    },
    {
        "content": "<p>I believe <code>mutualDefnDecl</code> is used basically by the compiler only, so there is no interaction or clash with <code>defnDecl</code>s</p>",
        "id": 397969430,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1698005567
    }
]