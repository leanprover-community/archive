[
    {
        "content": "<p>This is a curious question. Whenever I use Coq, after a proof is complete, Coq spends a fair amount of time on the <code>Qed</code> because it needs to check the proof term generated by the tactics. In Lean, I never witnessed this: after I reach the end of a proof, Lean manages to quickly move to the next theorem, even for reasonably big proofs. I've been quite amazed by that. So my question is: where is the magic?</p>\n<p>Sub-question: if we use <code>termination_by</code> and <code>decreasing_by</code> clauses, after Lean has checked the proof of termination, we need to wait an amount of time which is proportional to the time spent on playing the main body of the proof (the proof without the proof of termination). Is it because Lean needs to modify and subsequently re-check the proof term to account for the termination measure?</p>",
        "id": 465660395,
        "sender_full_name": "Son Ho",
        "timestamp": 1724829020
    },
    {
        "content": "<p>the magic is that lean doesn't do a lot of computation at the end of a proof, unlike coq</p>",
        "id": 465663187,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1724829537
    },
    {
        "content": "<p>the kernel does recheck the proof, but this is usually not a bottleneck</p>",
        "id": 465663474,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1724829601
    },
    {
        "content": "<p>to the sub-question, yes lean will do some modifications to the expression when trying to eliminate the recursion. It shouldn't be that expensive though, and I am doubtful it is (supposed to be) linear in the average case</p>",
        "id": 465663872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1724829725
    }
]