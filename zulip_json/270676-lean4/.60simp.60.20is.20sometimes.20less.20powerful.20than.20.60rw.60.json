[
    {
        "content": "<p>By the way I've recently encountered more cases where <code>rw</code> succeeds but <code>simp</code> fails. One such case is when the goal is <code>(f + g) ≫ h = _</code> where <code>h : End X X</code>(notice that <code>End X X</code> is defeq to <code>X ⟶ X</code> but not reducibly), where <code>rw [add_comp]</code> succeeds but <code>simp [add_comp]</code> fails.  Is this because <code>simp</code> uses discrimination trees but <code>rw</code> does not?</p>",
        "id": 497521128,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1738612898
    },
    {
        "content": "<p>Yeah, possibly. You can sort of model <code>rw</code> as matching on just the head of the discrimination tree key, then using defeq for the rest.</p>",
        "id": 497523078,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738613677
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/HeadIndex.lean\">https://github.com/leanprover/lean4/blob/master/src/Lean/HeadIndex.lean</a> gives the algorithm for how rw creates keys</p>",
        "id": 497523189,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738613724
    },
    {
        "content": "<p>It's like it does <code>(&lt;- whnfCore e).getAppFn</code>, where <code>whnfCore</code> is configured not to do beta reduction. It only does zeta reduction. Then (1) if it's a constant, that's the key, and (2) if it's anything else, it uses a tag for the corresponding <code>Expr</code> node. There are also special cases for Expr.proj and Expr.lit, which are very rare.</p>",
        "id": 497523503,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738613855
    },
    {
        "content": "<p>Reading the docstring: why is \"The head of <code>let x := 1; f x</code> is <code>.const f</code>\"?</p>",
        "id": 497523830,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1738613995
    },
    {
        "content": "<p>That's because it's zeta reducing the let to <code>f 1</code> first.</p>",
        "id": 497523964,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738614034
    },
    {
        "content": "<p>OK I see, thanks.</p>",
        "id": 497524149,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1738614118
    },
    {
        "content": "<p>(I wonder if <code>rw</code> ought to unfold abbrevs when forming keys, like <code>simp</code>. That would let rw lemmas tolerate abbreviations a lot better, both in the goal and in the lemma. It would likely lead to some surprise rewrites though.)</p>",
        "id": 497524542,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738614255
    },
    {
        "content": "<p>12 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Quotients.20are.20not.20reducibly.20defeq.20to.20their.20definitions\">#mathlib4 &gt; Quotients are not reducibly defeq to their definitions</a> by <span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span>.</p>",
        "id": 497673115,
        "sender_full_name": "Notification Bot",
        "timestamp": 1738677746
    },
    {
        "content": "<p>Sorry for not being clear, I think everything left in this topic should instead be moved; the others are discussions about <code>simp</code> vs. <code>rw</code>.</p>",
        "id": 497673927,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1738677946
    },
    {
        "content": "<p>10 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/instances.20don.27t.20apply.20to.20instance-defeq.20types\">#lean4 &gt; instances don't apply to instance-defeq types</a> by <span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span>.</p>",
        "id": 497674258,
        "sender_full_name": "Notification Bot",
        "timestamp": 1738678039
    },
    {
        "content": "<p>I forgot to mention that my understanding is that <code>simp -index</code> approximates <code>rw</code>'s behavior</p>",
        "id": 497685634,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738680843
    },
    {
        "content": "<p>(Please try to avoid using <code>simp -index</code> in Mathlib without good reason --- certainly it would require a comment explaining what's going on. It's more of a backwards compatibility trick than a feature.)</p>",
        "id": 498017707,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1738806351
    },
    {
        "content": "<p>Here's another case where <code>simp_rw</code> is less powerful than <code>rw</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">BigOperators</span><span class=\"bp\">.</span><span class=\"n\">Group</span><span class=\"bp\">.</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum_add_distrib</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>(in this particular example, <code>rw</code> works, but if this is nested then <code>simp_rw</code> is basically necessary unless some deep <code>conv</code> or <code>sum_congr</code> lemmas get applied). As mentioned above, <code>simp_rw -index [Finset.sum_add_distrib]</code> works here instead, or <code>simp_rw [Finset.sum_add_distrib (g := fun y ↦ y)]</code>.  The latter is undesirable since in applications in nested sums, this function might be a function of some of the other indices, so I can't spell it out this nicely. </p>\n<ol>\n<li>Is there a better option than <code>-index</code> or applying a ton of <code>conv</code> / <code>congr</code> steps?</li>\n<li>I'm struggling to see why <code>-index</code> is relevant at all here: if I replace <code>y</code> with a function of <code>y</code>, then things behave as documented. Why is that option the thing that fixes it?</li>\n<li>Is there a general lemma we can add to mathlib that would make examples like the above work? I would have guessed that <code>Finset.sum_add_distrib</code> is the correct generality here, but since <code>simp</code> can't apply it, something seems wrong with that guess.</li>\n</ol>",
        "id": 502567698,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1740745980
    },
    {
        "content": "<p>To make matters more confusing still, this one fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum_add_distrib</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)]</span>\n</code></pre></div>\n<p>but now <em>not</em> specifying the choice of <code>g</code> makes it work instead... Is the general idea that higher-order unification struggles with the identity function?</p>",
        "id": 502568093,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1740746105
    },
    {
        "content": "<p>It looks like the <code>2</code> is being specialized to <code>Nat</code>?</p>",
        "id": 502569282,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1740746460
    },
    {
        "content": "<p>Right, and this doesn't happen with the <code>rw</code> version</p>",
        "id": 502569756,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1740746606
    },
    {
        "content": "<p>Afaik the discrimination tree indexing sometimes still misses applicable lemmas when number literals are involved. That would explain why <code>simp -index</code> works.</p>",
        "id": 502569809,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1740746630
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/channel/270676-lean4/topic/.60simp.60.20is.20sometimes.20less.20powerful.20than.20.60rw.60/near/502569809\">said</a>:</p>\n<blockquote>\n<p>Afaik the discrimination tree indexing sometimes still misses applicable lemmas when number literals are involved. That would explain why <code>simp -index</code> works.</p>\n</blockquote>\n<p>Interesting - I don't see where number literals are involved in the first example though?</p>",
        "id": 502569899,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1740746660
    },
    {
        "content": "<p>Oh yeah, then that's probably not the root cause. But if <code>-index</code> fixes it, that points to some issue with the discr tree.</p>",
        "id": 502570800,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1740746968
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/blob/93d4ae6635c0c755c9f7368f9b99483d4557b7a6/src/Lean/Elab/Tactic/Simp.lean#L121-L137\">Here</a>'s the relevant lines for <code>simp</code>, and <a href=\"https://github.com/leanprover/lean4/blob/93d4ae6635c0c755c9f7368f9b99483d4557b7a6/src/Lean/Elab/Tactic/Rewrite.lean#L15-L31\">here</a>'s the lines for <code>rw</code>. The code for <code>simp</code> does <code>Term.synthesizeSyntheticMVars (postpone := .no) (ignoreStuckTC := true)</code>, and <code>rw</code> uses <code>Term.withSynthesize</code>.</p>",
        "id": 502573730,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1740747896
    },
    {
        "content": "<p>Interestingly,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">BigOperators</span><span class=\"bp\">.</span><span class=\"n\">Group</span><span class=\"bp\">.</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum_add_distrib</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>works, so this is probably a bug in <code>simp</code>.</p>",
        "id": 502574785,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1740748228
    },
    {
        "content": "<p>Woah, that one I'm shocked by, nice find!</p>",
        "id": 502575579,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1740748500
    },
    {
        "content": "<p>It looks like <code>simp</code> uses different logic for matching terms and for matching identifiers.</p>",
        "id": 502575642,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1740748523
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">discr_tree_simp_key</span><span class=\"w\"> </span><span class=\"n\">Finset.sum_add_distrib</span><span class=\"w\"> </span><span class=\"c1\">-- @Finset.sum _ _ _ _ &lt;other&gt;</span>\n<span class=\"bp\">#</span><span class=\"n\">discr_tree_simp_key</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"c1\">-- @Finset.sum _ _ _ _ (@HAdd.hAdd _ _ _ _ _)</span>\n</code></pre></div>\n<p>I would guess that <code>.other</code> is not matching with <code>HAdd.hAdd</code>.</p>",
        "id": 502629836,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1740763744
    },
    {
        "content": "<p>Lambdas are also often problematic for indexing</p>",
        "id": 502650494,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1740770480
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> What you point out is a difference, but the key difference is that <code>rw</code> elaborates the lemma, does the rewrite, then completes elaboration of the lemma. However, simp elaborates the lemma up front as far as it can, abstracts the metavariables, and then later, inside the simp algorithm, <a href=\"https://github.com/leanprover/lean4/blob/93d4ae6635c0c755c9f7368f9b99483d4557b7a6/src/Lean/Meta/Tactic/Simp/Rewrite.lean#L60\"><code>synthesizeArgs</code></a> is what's responsible for filling in those metavariables.</p>\n<p>The difference between <code>Finset.sum_add_distrib</code> and <code>id Finset.sum_add_distrib</code> is that simp treats identifiers as a special case; the first is essentially the same as adding <code>@Finset.sum_add_distrib</code> to the simp set, but the latter is like adding <code>fun X Y s f g inst =&gt; @Finset.sum_add_distrib X Y s f g inst</code> to the simp set, with all the arguments explicit. I am guessing there is some difference between implicit vs explicit arguments in <code>synthesizeArgs</code>.</p>",
        "id": 502654768,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740772113
    },
    {
        "content": "<p>Maybe it's worth checking if setting the option <code>tactic.skipAssignedInstances</code> has any effect? If it does, then there's a difference between whether the AddCommMonoid is an implicit argument or an explicit argument.</p>",
        "id": 502654827,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740772145
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/.60simp.60.20is.20sometimes.20less.20powerful.20than.20.60rw.60/near/502654768\">said</a>:</p>\n<blockquote>\n<p>The difference between <code>Finset.sum_add_distrib</code> and <code>id Finset.sum_add_distrib</code> is that simp treats identifiers as a special case; the first is essentially the same as adding <code>@Finset.sum_add_distrib</code> to the simp set, but the latter is like adding <code>fun X Y s f g inst =&gt; @Finset.sum_add_distrib X Y s f g inst</code> to the simp set, with all the arguments explicit. I am guessing there is some difference between implicit vs explicit arguments in <code>synthesizeArgs</code>.</p>\n</blockquote>\n<p><code>simp</code>ing with <code>@id _ @Finset.sum_add_distrib</code> also works, but just <code>@Finset.sum_add_distrib</code> does not, so I don't think it's the binder types.</p>",
        "id": 502656738,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1740772865
    },
    {
        "content": "<p>Did <code>tactic.skipAssignedInstances</code> have no effect then?</p>",
        "id": 502658467,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740773522
    },
    {
        "content": "<p>Yes, it had no effect</p>",
        "id": 502658559,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1740773542
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/channel/270676-lean4/topic/.60simp.60.20is.20sometimes.20less.20powerful.20than.20.60rw.60/near/502629836\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">discr_tree_simp_key</span><span class=\"w\"> </span><span class=\"n\">Finset.sum_add_distrib</span><span class=\"w\"> </span><span class=\"c1\">-- @Finset.sum _ _ _ _ &lt;other&gt;</span>\n<span class=\"bp\">#</span><span class=\"n\">discr_tree_simp_key</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"c1\">-- @Finset.sum _ _ _ _ (@HAdd.hAdd _ _ _ _ _)</span>\n</code></pre></div>\n<p>I would guess that <code>.other</code> is not matching with <code>HAdd.hAdd</code>.</p>\n</blockquote>\n<p>Indeed. The <code>fun y =&gt; c + y</code> is getting eta reduced into <code>c +</code>, which lean doesn't see as a lambda. My RefinedDiscrTree handles this correctly.</p>",
        "id": 502688468,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740787784
    }
]