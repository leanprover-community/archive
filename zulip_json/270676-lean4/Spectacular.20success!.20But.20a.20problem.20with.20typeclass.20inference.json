[
    {
        "content": "<p>Type coercions and type classes in Lean make possible very concise forms of expression, often far more concise and readable than what is available in Agda.</p>\n<p>For example, here is a definition of de Bruijn indices for a tiny lambda calculus.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">lookup</span> <span class=\"o\">:</span> <span class=\"n\">TpEnv</span> <span class=\"bp\">→</span> <span class=\"n\">Tp</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">stop</span> <span class=\"o\">:</span>\n       <span class=\"c1\">----------------</span>\n       <span class=\"n\">lookup</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">▷</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">A</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pop</span> <span class=\"o\">:</span>\n       <span class=\"n\">lookup</span> <span class=\"bp\">Γ</span> <span class=\"n\">B</span>\n       <span class=\"c1\">----------------</span>\n     <span class=\"bp\">→</span> <span class=\"n\">lookup</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">▷</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">B</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">prefix</span><span class=\"o\">:</span><span class=\"mi\">90</span> <span class=\"s2\">\"S\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lookup.pop</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"Z\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lookup.stop</span>\n</code></pre></div>\n<p>Something similar to the above is easy to do in Agda. But what Lean makes easy, and Agda makes hard, is to convert a natural number into the corresponding de Bruijn index.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">▷</span> <span class=\"n\">A</span> <span class=\"bp\">∋</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">Nat.zero</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"n\">lookup.stop</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">∋</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">▷</span> <span class=\"n\">A</span> <span class=\"bp\">∋</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"n\">lookup.pop</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"bp\">∅</span> <span class=\"bp\">▷</span> <span class=\"n\">ℕ</span> <span class=\"bp\">⇒</span> <span class=\"n\">ℕ</span> <span class=\"bp\">▷</span> <span class=\"n\">ℕ</span> <span class=\"bp\">▷</span> <span class=\"n\">ℕ</span> <span class=\"bp\">∋</span> <span class=\"n\">ℕ</span> <span class=\"bp\">⇒</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>This is great! However, when I use it inside a larger term, Lean gets into trouble with inference.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">one_c</span> <span class=\"o\">:</span> <span class=\"bp\">∅</span> <span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⇒</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">⇒</span> <span class=\"n\">A</span> <span class=\"bp\">⇒</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"bp\">ƛ</span> <span class=\"bp\">ƛ</span> <span class=\"bp\">#</span> <span class=\"n\">S</span> <span class=\"n\">Z</span> <span class=\"bp\">⬝</span> <span class=\"bp\">#</span> <span class=\"n\">Z</span>\n<span class=\"kd\">def</span> <span class=\"n\">one_c'</span> <span class=\"o\">:</span> <span class=\"bp\">∅</span> <span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⇒</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">⇒</span> <span class=\"n\">A</span> <span class=\"bp\">⇒</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"bp\">ƛ</span> <span class=\"bp\">ƛ</span> <span class=\"bp\">#</span> <span class=\"mi\">1</span> <span class=\"bp\">⬝</span> <span class=\"bp\">#</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>The first of these is fine, but the second (which should be equivalent) reports an error for <code># 0</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">typeclass</span> <span class=\"kd\">instance</span> <span class=\"n\">problem</span> <span class=\"n\">is</span> <span class=\"n\">stuck</span><span class=\"o\">,</span> <span class=\"n\">it</span> <span class=\"n\">is</span> <span class=\"n\">often</span> <span class=\"n\">due</span> <span class=\"n\">to</span> <span class=\"n\">metavariables</span>\n  <span class=\"n\">OfNat</span> <span class=\"bp\">?</span><span class=\"n\">m.30623</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>Is there any workaround? Any suggestions gratefully received.</p>\n<p>The complete code from which the above snippets are taken is available at <a href=\"https://github.com/plfa/plfl/blob/main/src/Typesig.lean\">https://github.com/plfa/plfl/blob/main/src/Typesig.lean</a>.</p>",
        "id": 403032593,
        "sender_full_name": "Philip Wadler",
        "timestamp": 1700414033
    },
    {
        "content": "<p>Hi Phil! With a recent Lean, I get a slightly different error message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">typeclass</span> <span class=\"kd\">instance</span> <span class=\"n\">problem</span> <span class=\"n\">is</span> <span class=\"n\">stuck</span><span class=\"o\">,</span> <span class=\"n\">it</span> <span class=\"n\">is</span> <span class=\"n\">often</span> <span class=\"n\">due</span> <span class=\"n\">to</span> <span class=\"n\">metavariables</span>\n  <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"bp\">∅▷</span><span class=\"n\">A</span><span class=\"bp\">⇒</span><span class=\"n\">A</span><span class=\"bp\">▷</span><span class=\"n\">A</span><span class=\"bp\">∋?</span><span class=\"n\">m.116054</span><span class=\"o\">)</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>This is indeed a problem: we don't know what type to look up before converting the numeral, but without knowing the type none of the <code>OfNat</code> instances are a perfect match. Lean never uses the knowledge that there is only one applicable instance in order to fill in holes in the typeclass problem, so we are stuck. I believe it would be similar in Haskell?</p>\n<p>One workaround would be to use a more syntactic approach, by strengthening the <code>#</code> notation when followed by a numeral:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">#</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">num</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"bp\">←</span> <span class=\"n\">n.getNat.foldM</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">acc</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"bp\">$</span><span class=\"n\">acc</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Z</span><span class=\"o\">))</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">#</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It would even be possible to override the meaning of any numeral but that probably isn't a good idea. Or you could expand that approach into a full EDSL for <code>term</code> depending on what your goals are.</p>",
        "id": 403040559,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1700418895
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span>  Thanks very much.   Your explanation makes sense if it <em>never</em> works, but in fact it works sometimes and fails others. I'd be happy to provide additional type information to help the inferencer, but I have no idea what extra information to provide or how to provide it. Any clues?</p>",
        "id": 403043784,
        "sender_full_name": "Philip Wadler",
        "timestamp": 1700420845
    },
    {
        "content": "<p>The specific problem is the type variable introduced by the application, we can either specify it in a subterm:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">ƛ</span> <span class=\"bp\">ƛ</span> <span class=\"bp\">#</span> <span class=\"mi\">1</span> <span class=\"bp\">⬝</span> <span class=\"o\">(</span><span class=\"bp\">#</span> <span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">⊢</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>or in the <code>application</code> application itself if we unfold the notation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">ƛ</span> <span class=\"bp\">ƛ</span> <span class=\"n\">term.application</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">#</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">#</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 403044353,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1700421223
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> Thanks, that gives a workaround.</p>",
        "id": 403045223,
        "sender_full_name": "Philip Wadler",
        "timestamp": 1700421788
    }
]