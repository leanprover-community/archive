[
    {
        "content": "<p>I'm attempting to understand the conceptual framework of lake's build system, and while I've understood some things, I still don't <em>get</em> some foundational things, like \"what a facet really is\".</p>\n<p>I'm hoping that by (1) linking to what I have already found helpful here and (2) airing my confusions, people will be able to find a resource on zulip if they have similar questions—and, if my confusions aren't too idiosyncratic, maybe this discussion could help with documentation more generally. :)</p>\n<h3>Resources</h3>\n<p>The place to start is of course the <a href=\"https://lean-lang.org/doc/reference/latest///Build-Tools-and-Distribution/Lake/\">language reference page for Lake</a>, which is a great help already.</p>\n<p>I'll also link here the <a href=\"https://github.com/leanprover/doc-gen4/blob/main/lakefile.lean\">docgen4 lakefile</a>, which constitutes a worked example of custom <code>target</code>s and <code>package_</code>, <code>module_</code>, and <code>library_facet</code>s.</p>\n<p>There's also some insight in <a href=\"#narrow/channel/113488-general/topic/Lean.204.20project.20blueprint/near/395438384\">this Zulip thread</a> from Mac Malone, who is responsible for Lake (though from 2023; have things changed?). There's some oblique info in <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Lake.3A.20module_facet.20that.20skips.20some.20modules.3F/with/441310637\">this thread</a> on some limitations of <code>module_facet</code> (2024; still relevant?) and another small worked example for sqlite bindings on zulip <a href=\"#narrow/channel/270676-lean4/topic/lakefile.20lean_exe.20troubles.20with.20FFI.2E/near/412719185\">here</a>.</p>\n<p>There are also some tiny but useful examples in the <a href=\"https://github.com/leanprover/lean4/blob/df898a5c87d7031c5687cfcdf79b29e576306439/src/lake/examples/targets/lakefile.lean\">example file for lake in the lean4 repo</a>.</p>\n<h3>Questions</h3>\n<p>There's one main question I have, then one smaller question.</p>\n<p><strong>1. What's the difference between a facet and a target? (What is each?) Likewise, what's the relationship between modules/packages/libraries and facets/targets?</strong></p>\n<p>Here are the clues I have so far (each of which is an excerpt from the reference manual).</p>\n<blockquote>\n<p>A <em>target</em> represents an output that can be requested by a user. A persistent build output, such as object code, an executable binary, or an <a href=\"https://lean-lang.org/doc/reference/latest///Elaboration-and-Compilation/#--tech-term-___olean-file\"><code>.olean</code> file</a>, is called an <em>artifact</em>. In the process of producing an artifact, Lake may need to produce further artifacts; for example, compiling a Lean program into an executable requires that it and its dependencies be compiled to object files, which are themselves produced from C source files, which result from elaborating Lean sourcefiles and producing <a href=\"https://lean-lang.org/doc/reference/latest///Elaboration-and-Compilation/#--tech-term-___olean-file\"><code>.olean</code> files</a>. Each link in this chain is a target, and Lake arranges for each to be built in turn.</p>\n</blockquote>\n<blockquote>\n<p><em>Custom targets</em> contain arbitrary code to run a build, written using Lake's internal API.</p>\n</blockquote>\n<blockquote>\n<p>... Lake proceeds to build each artifact. This involves running the appropriate build tool on the input files and saving the artifact and its trace file, <strong>as specified in the corresponding facet.</strong> (emph mine)</p>\n</blockquote>\n<blockquote>\n<p>A <em>facet</em> describes the production of a target from another. Conceptually, any target may have facets. However, executables, external libraries, and custom targets provide only a single implicit facet. Packages, libraries, and modules have multiple facets that can be requested by name when invoking <a href=\"https://lean-lang.org/doc/reference/latest///Build-Tools-and-Distribution/Lake/#build\"><code>lake build</code></a> to select the corresponding target.</p>\n<p>When no facet is explicitly requested, but an initial target is designated, <a href=\"https://lean-lang.org/doc/reference/latest///Build-Tools-and-Distribution/Lake/#build\"><code>lake build</code></a> produces the initial target's <em>default facet</em>. Each type of initial target has a corresponding default facet (e.g. producing an executable binary from an executable target or building a package's <a href=\"https://lean-lang.org/doc/reference/latest///Build-Tools-and-Distribution/Lake/#--tech-term-default-targets\">default targets</a>)</p>\n</blockquote>\n<blockquote>\n<p><strong><code>lake build [targets...]</code></strong></p>\n<p>Builds the specified facts of the specified targets.</p>\n<p>Each of the <code>targets</code> is specified by a string of the form:</p>\n<p><code>[[@]package[/]][target|[+]module][:facet]</code></p>\n<p>The optional <code>@</code> and <code>+</code> markers can be used to disambiguate packages and modules from file paths as well as executables, and libraries, which are specified by name as <code>target</code>. [...] Module targets may also be specified by their filename, with an optional facet after a colon.</p>\n<p>The available <a href=\"https://lean-lang.org/doc/reference/latest///Build-Tools-and-Distribution/Lake/#--tech-term-facet\">facets</a> depend on whether a package, library, executable, or module is to be built. They are listed in <a href=\"https://lean-lang.org/doc/reference/latest///Build-Tools-and-Distribution/Lake/#lake-facets\">the section on facets</a>.</p>\n</blockquote>\n<blockquote>\n<p><code>a</code> – The <a href=\"https://lean-lang.org/doc/reference/latest///Build-Tools-and-Distribution/Lake/#--tech-term-default-facet\">default facet</a>(s) of target <code>a</code></p>\n<p><code>@a</code> – The <a href=\"https://lean-lang.org/doc/reference/latest///Build-Tools-and-Distribution/Lake/#--tech-term-default-targets\">default targets</a> of <a href=\"https://lean-lang.org/doc/reference/latest///Build-Tools-and-Distribution/Lake/#--tech-term-package\">package</a> <code>a</code></p>\n<p><code>+A</code> – The Lean artifacts of module <code>A</code> (because the default facet of modules is <code>leanArts</code>)</p>\n<p><code>@a/b</code> – The default facet of target <code>b</code> of package <code>a</code></p>\n</blockquote>\n<blockquote>\n<p>... packages depend on other packages, while build targets depend on other build targets, which may be in the same package or in a different one. One facet of a given target may depend on other facets of the same target.</p>\n</blockquote>\n<blockquote>\n<p>Package facets allow the production of an artifact or set of artifacts from a whole package. The Lake API makes it possible to query a package for its libraries; thus, one common use for a package facet is to build a given facet of each library.</p>\n</blockquote>\n<p>(Aside: in <a href=\"https://lean-lang.org/doc/reference/latest///Build-Tools-and-Distribution/Lake/#The-Lean-Language-Reference--Build-Tools-and-Distribution--Lake--Configuration-File-Format--Lean-Format--Targets--Custom-Facets\">these callouts in the manual</a>, \"Library facets\" and \"Module facets\" at the start of the respective bubbles are both typoed as \"Package facets\".)</p>\n<p><strong><em>Confusions and subquestions:</em></strong></p>\n<ul>\n<li>Modules, libraries, and packages have facets; targets also have facets. Are modules, libraries, and packages targets, or do they <em>have</em> targets? Packages and libraries are indeed called \"initial targets\" at some point in the manual. However, packages can also <em>have</em> targets (and <code>target</code> defines targets \"for the package\"), suggesting packages are not necessarily targets per se—or not <em>just</em> targets. Likewise, I wouldn't think of packages, libraries, and modules as meeting the definition of target and \"representing a kind of output\" in and of themselves (if anything, they're <em>sources</em>, the \"opposite\" of a target!).</li>\n<li>A target seems to in part be a <em>way of producing artifacts</em>; after all, it contains code for a job. But so do facets; in fact, according to some language, apparently facets are <em>the</em> things that specify how to produce artifacts. Why are they separate things? Do all targets <em>only</em> produce artifacts \"via\" a facet? The language used seems to suggest so at times, but in e.g. the docgen source, the <code>target</code>s seem self-contained.</li>\n<li>Likewise, targets can already depend on other targets. So why do we need facets to do the same? What is the motivation behind having facets in the first place? Is it simply to enable a different command line interface, or does it give us a conceptually different sort of thing?</li>\n<li>\"Each type of <em>initial</em> target has a corresponding default facet\". Is the initial part conceptually crucial here? Do non-initial targets not necessarily have default facets? Why?</li>\n<li>We can add facets to packages, libraries, and modules via the respective commands. The language seems to suggest we could add them to (other?) targets, too. But these don't seem to be \"blessed\" in the same way. Is this just a measure of (in)convenience? Or are the abstractions of package/library/module woven more deeply into the conceptual framework of lake in a way that changes how we should understand their relationship to facets/targets? (Obviously they are woven deeply into lake in general, but I'm trying to figure out if the very concept of targets and facets depends on them in some way.)</li>\n</ul>\n<p>I don't expect every question to be answered individually here; but hopefully this is enough to make clear where I'm confused! Sometimes it feels like there are unspoken assumptions about what these systems <em>should</em> look like or be capable of that I'm not privy to, so I'm trying to make it obvious which assumptions I don't share—I suspect that there is some relatively simple presentation which would make answering all of these questions trivial!</p>\n<p><strong>2. What's the intended utility of the return type of a facet or target?</strong></p>\n<p>I'm guessing the answer here is \"it allows facets/targets to provide data to other facets/targets which may call it, such that the calling facet/target can use that data to access the called facet/target's built artifacts/computed metadata/etc.\". But is this right? If so, is this the full extent of what that data is for?</p>\n<hr>\n<p>If you read this far, thanks. :)</p>",
        "id": 534711290,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1755290813
    },
    {
        "content": "<p>You mind find reading the lakefile of doc-gen helpful; I certainly can't claim whether it's idiomatic, but it is making heavier-than-usual usage of lake facets</p>",
        "id": 534716722,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1755294347
    },
    {
        "content": "<p>Indeed—that is already linked above! :)</p>",
        "id": 534717789,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1755295176
    },
    {
        "content": "<p>Some quick clarifications for now:</p>\n<ul>\n<li>Package, libraries, and modules are all targets (and, more specifically, initial targets). A target is anything one can request from Lake, e.g., via <code>lake build</code>, <code>lake query</code>, or a <code>fetch</code> in the Lake API. While it is true that packages, libraries, and modules are not ouputs per se, requesting them does produce an output (their default targets / facet(s)).</li>\n<li>A facet is essentially a function between targets. It produces a target from another. For example, the module <code>c</code> facet (i.e., <code>+mod:c</code>) produces the module's C target from a module target. Initial targets are those not produced by facet. Instead, they are specified by a Lake configuration  file. Initial targets have a default facet to determine which of their possible outputs Lake should produce when they are requested.</li>\n</ul>\n<blockquote>\n<p>We can add facets to packages, libraries, and modules via the respective commands. The language seems to suggest we could add them to (other?) targets, too.</p>\n</blockquote>\n<p>Yes! The API theoretically supports this. However, this is currently unimplemented due to a lack of use cases.</p>",
        "id": 534718706,
        "sender_full_name": "Mac Malone",
        "timestamp": 1755295806
    }
]