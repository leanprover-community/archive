[
    {
        "content": "<p>mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">23</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span>\n  <span class=\"k\">show</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">_</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I don't want Lean to unfold this let binding, and yet it is happening; I'd expect this if I did <code>simp only [x]</code>. Is this expected behaviour or a bug? Is there any way to work around this?</p>",
        "id": 387048689,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1692875831
    },
    {
        "content": "<p>There is a config flag, but I always forget what it's called</p>",
        "id": 387050278,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1692876376
    },
    {
        "content": "<p>Is it <code>simp (config { zeta := false })</code>?</p>",
        "id": 387050442,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1692876433
    },
    {
        "content": "<p>having to write <code>simp (config := ...)</code> for every single one is pretty awful, especially as this is a \"destructive\" change</p>",
        "id": 387050864,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1692876589
    },
    {
        "content": "<p>Usually let bindings are quite short to hide long terms, so having to write <code>simp [my_thing]</code> is not awful, if this is wanted behaviour</p>",
        "id": 387050974,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1692876613
    },
    {
        "content": "<p>and now instead I'd have to set every single simp after initialising a <code>let</code> to have <code>zeta := false</code>?</p>",
        "id": 387051043,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1692876639
    },
    {
        "content": "<p>I didn't say I liked it :)</p>",
        "id": 387053246,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1692877452
    },
    {
        "content": "<p>I agree that I don't much like this default, and it might be useful enough to have a mathlib tactic <code>simp_no_zeta</code> that  shortens this</p>",
        "id": 387058981,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1692879341
    },
    {
        "content": "<p><code>simp {zeta := false}</code> would be ok IMO too</p>",
        "id": 387114298,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692892941
    },
    {
        "content": "<p>Or we could override the syntax of <code>simp</code> in mathlib to change the default</p>",
        "id": 387114538,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692893003
    },
    {
        "content": "<p>I'd be strongly in favour with overriding the default in mathlib or petitioning for it to be changed in core. Are issues still discouraged for core?</p>",
        "id": 387115043,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1692893141
    },
    {
        "content": "<p>/poll Which default behavior of simp would you prefer in mathlib</p>\n<ul>\n<li>zeta := true (default in Lean 4), unfolds lets</li>\n<li>zeta := false (default in Lean 3), does not unfold lets</li>\n</ul>",
        "id": 387118737,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692894195
    },
    {
        "content": "<p>(non-binding, but to get a feel for how skewed opinion is)</p>",
        "id": 387118806,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692894219
    },
    {
        "content": "<p>One thing to note is that lean 4 does not support <code>let x = ...; simp [x]</code>, so it'd be good to have a short syntax for that as well</p>",
        "id": 387132842,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1692898909
    },
    {
        "content": "<p>As of today, mathlib <a href=\"https://github.com/leanprover-community/mathlib4/blob/40c20c89a8574527dbe6f05e0ff26e4596a1c775/Mathlib/Tactic/DefEqTransformations.lean#L104\">now has</a> <code>unfold_let x</code> to do targeted zeta reduction.</p>",
        "id": 387144184,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1692902673
    },
    {
        "content": "<p>Just so everyone knows <code>simp (config := {zeta := false})</code> will <a href=\"https://github.com/leanprover/lean4/blob/1dd443a368db461e218147d06e006251342d4159/src/Lean/Meta/Tactic/Simp/Main.lean#L688\">preserve <code>let</code> expressions</a>, so if the goal is <code>let x := 1; x = 1</code> then it will remain unchanged.</p>",
        "id": 387145066,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1692903088
    },
    {
        "content": "<p>Maybe the <code>zeta</code> configuration should be split into two, one that controls substitution of fvars (what the poll is about) and one that controls whether let expressions are reduced (which I presume the poll isn't about)</p>",
        "id": 387145261,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1692903184
    },
    {
        "content": "<p>FWIW I very rarely end up with goals with <code>let</code>s in explicitly, but have local decls quite often. (also we wish we could could do <code>simp {zeta := false}</code> and not <code>simp (config := {zeta:=False})</code> but currently cannot)</p>",
        "id": 387156762,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1692908549
    },
    {
        "content": "<p>For those that voted for zeta being true, I'm curious as to what are your reasons, too</p>",
        "id": 387258598,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1692962757
    },
    {
        "content": "<p>is it possible to at least make a quick macro so that this can be worked around for the moment? something like <code>simpζ</code> := <code>simp</code> + <code>zeta := false</code></p>",
        "id": 387901760,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1693321528
    },
    {
        "content": "<p>this currently makes some proofs unreadable in the tactic state...</p>",
        "id": 387901806,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1693321541
    },
    {
        "content": "<p>I was happy at one point to learn about <code>set</code> which makes it easier to control how my bindings display at various times. <a href=\"#narrow/stream/113488-general/topic/How.20to.20unwrap.20a.20let.20expression/near/371334004\">This discussion</a> might be related?</p>",
        "id": 387921425,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1693327737
    },
    {
        "content": "<p>I was discussing <code>simp</code> issues with Tomas over lunch and he reminded me of this thread (I voted in the poll but then forget). This allowed to write <a href=\"https://github.com/leanprover-community/sphere-eversion/commit/872b6d2507a081783408cdf034c70d0639e66896\">this fix</a> which really looks like restoring sanity. Is there any progress on making that the default in Lean core? Or any explanation about why the Lean 4 behavior could be a desired default? <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span></p>",
        "id": 390774825,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694628046
    },
    {
        "content": "<p>And <a href=\"https://github.com/leanprover-community/sphere-eversion/commit/fb95368db041d06e247864725a0bd16dc5c3e61f\">one more</a>. <code>simp (config := {zeta := false}) </code> is quickly becoming my favorite tactic. It's long to type but it's really worth the trouble!</p>",
        "id": 390775654,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694628273
    },
    {
        "content": "<p>Lean 4 is becoming <a href=\"https://github.com/leanprover-community/sphere-eversion/commit/1e945bb1a02e234541286930b08ab350d43994b1\">so easy</a> it almost feels like cheating!</p>",
        "id": 390776015,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694628389
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> and <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> would you mind explaining why you prefer <code>zeta := true</code> as the default?</p>",
        "id": 390778296,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694629196
    },
    {
        "content": "<p>To be honest I also just pushed <a href=\"https://github.com/leanprover-community/sphere-eversion/commit/fd734e1ede3d1ddef2175e0378d0d9e0e549e076\">this commit</a> getting rid of many <code>unfold_let</code>. I wrote those yesterday because <code>let x := ... ; simp [x]</code> didn't work so I replaced them by <code>let x := ... ; unfold_let x; simp;</code>. I know understand <code>let x := ... ; simp</code> works. But really I <em>very much</em> prefer to have to tell <code>simp</code> which definitions it should unfold since it is some much more compact and explicit. In a proving context <code>let</code> is used to hide complexity. Undoing this work by default seems a really wrong choice.</p>",
        "id": 390779622,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694629665
    },
    {
        "content": "<p>I mean, I'd probably say <code>have</code> hides complexity, and <code>let</code> just makes it more compact... other than explicit <code>unfold_let</code>, are the let-definitions frequently being unfolded in other parts of the proof? (maybe in defeq checks or something)</p>",
        "id": 390780088,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694629833
    },
    {
        "content": "<p>Sure they are also unfolded in defEq checks</p>",
        "id": 390780413,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694629955
    },
    {
        "content": "<p>And the difference between <code>have</code> and <code>let</code> is that one is for Prop and the other for data, so I don't understand what you mean.</p>",
        "id": 390780694,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694630067
    },
    {
        "content": "<p>You can <code>have</code> non-prop values... the difference is purely in whether the definitional equality is visible, no?</p>",
        "id": 390782046,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694630678
    },
    {
        "content": "<p>You can but this is never what you want to do.</p>",
        "id": 390782185,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694630742
    },
    {
        "content": "<p>(at least in CS-world I do use this, not frequently but not rarely...)</p>",
        "id": 390782419,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694630836
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span> really? I would be interested in seeing an example. You're saying that you need to use the fact that some piece of data has a particular type without actually caring what the thing is in particular? (sorry if I sound incredulous, I'm just surprised)</p>",
        "id": 390782860,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694631017
    },
    {
        "content": "<p>Let me look through the archives........</p>",
        "id": 390783231,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694631153
    },
    {
        "content": "<p><a href=\"https://github.com/JamesGallicchio/LeanColls/blob/9cb0a0c9a838bea24be80eace168bcc5f9481596/LeanColls/Array/Basic.lean#L32\">here's an example.</a>. The idea is I build a proof while building a value, then I want to forget the full definition and have just the generated proof as the only \"fact\" about the value.</p>",
        "id": 390783580,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694631297
    },
    {
        "content": "<p>iirc it was <code>have</code> instead of <code>let</code> specifically to prevent tactics from expanding the definition (which is unwieldy).</p>",
        "id": 390783826,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694631386
    },
    {
        "content": "<p>of course I could have <code>zeta:=false</code>'d at the callsites, but this clearly makes more sense to be thrown out at the definition site.</p>",
        "id": 390783947,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694631437
    },
    {
        "content": "<p>That's only supporting the idea that <code>zeta := false</code> should be the default.</p>",
        "id": 390784950,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694631828
    },
    {
        "content": "<p>And I still find this example really weird (but I can't play with it since it isn't a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>).</p>",
        "id": 390785053,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694631854
    },
    {
        "content": "<p>I'm also very confused about what is happening here, I think in part because your <code>Array</code> is not <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array#doc\">docs#Array</a></p>",
        "id": 390785579,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694632072
    },
    {
        "content": "<p>sorry, this is the first snippet grep found <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span> but yes, I'm not opposed to <code>zeta:=false</code>, I know in math-applications you frequently go between wanting to expand <code>let</code>s and not, whereas in CS-land I try to prove the properties I need and then close the definition permanently.</p>",
        "id": 390785942,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694632218
    },
    {
        "content": "<p>Perhaps someone can make a toolchain with the default changed so there is something more concrete to look at? (I think the preferred method today is to make a draft PR, and then wait an hour for the <code>leanprover/lean4-pr-releases:pr-release-NNNN</code> toolchain is available.)</p>",
        "id": 390820402,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1694649005
    },
    {
        "content": "<p>Scott, I would like to try that, and I created <a href=\"https://github.com/PatrickMassot/lean4/tree/simp_zeta_false\">https://github.com/PatrickMassot/lean4/tree/simp_zeta_false</a>, but I'm reluctant to open a draft PR since it doesn't seem to comply to the contributions instructions. Do you know whether there is a way to run CI for this branch in my fork? That would be a first step.</p>",
        "id": 391026136,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694729891
    },
    {
        "content": "<p>I made some notes on my experience <a href=\"#narrow/stream/270676-lean4/topic/home.20cooked.20release\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/home.20cooked.20release</a></p>",
        "id": 391027578,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694730724
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span> thanks but I have no idea how to implement your list.</p>",
        "id": 391041571,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694738487
    },
    {
        "content": "<p>Specifically \"Make sure that both the Nix-CI and CI workflows are enabled to run. The first was fine but the second was turned off by default for me. \"</p>",
        "id": 391041631,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694738516
    },
    {
        "content": "<p>I still have no idea how to run CI in my fork but I think I built Lean locally with that change without a single error.</p>",
        "id": 391062729,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694746804
    },
    {
        "content": "<p>As far as I understand, none of Matthew's list is needed, except the first step.</p>\n<p>You enable actions by visiting:<br>\n<a href=\"https://github.com/&lt;username&gt;/lean4/settings/actions\">https://github.com/&lt;username&gt;/lean4/settings/actions</a></p>\n<p>After that you just push a tag to your fork.</p>",
        "id": 391076496,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1694753117
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>, you should add your github username to your zulip profile, as a good example. :-)</p>",
        "id": 391076522,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1694753136
    },
    {
        "content": "<p>Scott, the point is that I see <br>\n<a href=\"/user_uploads/3121/VTpqLLUv99RXOGdF8pb6cbgd/image.png\">image.png</a><br>\nand that doesn't seem to be good enough.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/VTpqLLUv99RXOGdF8pb6cbgd/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/VTpqLLUv99RXOGdF8pb6cbgd/image.png\"></a></div>",
        "id": 391163485,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694782446
    },
    {
        "content": "<p>That's what I have on mine. Just nothing happens when you push a tag?</p>",
        "id": 391165827,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694783092
    },
    {
        "content": "<p>Oh I didn't realize I needed to push a tag to my fork! It seems to work. Sorry about taking so long.</p>",
        "id": 391167159,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694783440
    },
    {
        "content": "<p>Perfectly understandable.</p>",
        "id": 391168176,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694783749
    },
    {
        "content": "<p>I made progress: I have <a href=\"https://github.com/PatrickMassot/lean4/actions\">https://github.com/PatrickMassot/lean4/actions</a> saying tests are successful, but PR release failed, complaining about a missing token.</p>",
        "id": 391300009,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694827103
    },
    {
        "content": "<p>The PR release error is confusing and should be removed, but is ultimately harmless: <a href=\"https://github.com/PatrickMassot/lean4/releases/tag/zeta_false2\">https://github.com/PatrickMassot/lean4/releases/tag/zeta_false2</a></p>",
        "id": 391365161,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1694862617
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/270676-lean4/topic/home.20cooked.20release/near/383286960\">said</a>:</p>\n<blockquote>\n<ul>\n<li>The action for releasing can require additional permission set directly in the <code>.github/workflows/ci.yml</code>. This seems like a known issue and can be fixed by adding </li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"YAML\"><pre><span></span><code><span class=\"nt\">permissions</span><span class=\"p\">:</span>\n<span class=\"w\">  </span><span class=\"nt\">contents</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">write</span>\n</code></pre></div>\n<p>after the <code>on:</code> node in the file</p>\n</blockquote>\n<p>Does this fix it?</p>",
        "id": 391385004,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694875291
    },
    {
        "content": "<p>We simply should not attempt PR releases in forks /cc <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span></p>",
        "id": 391418260,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1694897276
    },
    {
        "content": "<p>Yep, thank you, that is my bug! <a href=\"https://github.com/leanprover/lean4/pull/2550\">lean4#2550</a></p>",
        "id": 391468050,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1694936829
    },
    {
        "content": "<p>It turns out the <code>zeta</code> config option isn't powerful enough to force <code>simp</code> to preserve let bindings. See</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">f_zero</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.sub_self</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">n</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">zeta</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">})</span> <span class=\"o\">[</span><span class=\"n\">Nat.zero_add</span><span class=\"o\">]</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>which happily ignores the option and closes the goal anyway. Compare to Lean 3:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">f_zero</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">nat.sub_self</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- dsimp only [g],</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nat.zero_add</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>which does not close the goal without the <code>dsimp</code> line. <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> this is what prevents fixing the sphere instance proof, even with a patched version of <code>field_simp</code>.</p>\n<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> any idea how we could get back a <code>simp</code> that does not break through <code>let</code> values?</p>",
        "id": 391576668,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694986814
    },
    {
        "content": "<p>Of course in my example this looks like a feature, but in actual example it <em>prevents</em> simp from closing the goal, by sending it to a dead end.</p>",
        "id": 391576686,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694986854
    },
    {
        "content": "<p>I think this might happen because even if it's not unfolded, <code>g</code> is considered reducible?</p>",
        "id": 391578178,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694987946
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n      <span class=\"n\">contextual</span>  <span class=\"o\">:=</span> <span class=\"n\">false</span>\n      <span class=\"n\">memoize</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n      <span class=\"n\">singlePass</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n      <span class=\"n\">zeta</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n      <span class=\"n\">beta</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n      <span class=\"n\">eta</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n      <span class=\"n\">iota</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n      <span class=\"n\">proj</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n      <span class=\"n\">decide</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n      <span class=\"n\">arith</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n      <span class=\"n\">autoUnfold</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">})</span>\n</code></pre></div>\n<p>also doesn't seem to help</p>",
        "id": 391578439,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694988088
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/simp.20unfolding.20let.20bindings/near/391576668\">said</a>:</p>\n<blockquote>\n<p>any idea how we could get back a <code>simp</code> that does not break through <code>let</code> values?</p>\n</blockquote>\n<p>I think this would require somehow ensure that <a href=\"https://github.com/leanprover/lean4/blob/ee3ac9901e9ef5d065c586a902a523710e5b61e9/src/Lean/Meta/Tactic/Simp/Rewrite.lean#L64\">this <code>isDefEq</code></a> can't see through let bindings.</p>\n<p>When you traverse a term and there are let bindings then with <code>zeta:=false</code> let variables are replaced with a <a href=\"https://github.com/leanprover/lean4/blob/ee3ac9901e9ef5d065c586a902a523710e5b61e9/src/Lean/Meta/Tactic/Simp/Main.lean#L700C16-L700C16\">fresh local free variable</a> and thus simp can't see through them anymore. Something like this needs to be done to let bindings that are in the context at the start of simp run.</p>\n<p>I see two options:</p>\n<p>- have an option on <code>isDefEq</code> not to unfold let bindings<br>\n  - before running simp on an expression replace all let free variables with new fresh local free variables and after simp is done replace them back</p>",
        "id": 391579814,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1694988483
    },
    {
        "content": "<p>There seems to be config setting <code>zetaNonDep</code> in <code>MetaM</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"sd\">/-- If zetaNonDep == false, then non dependent let-decls are not zeta expanded. -/</span>\n  <span class=\"n\">zetaNonDep</span>         <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n</code></pre></div>\n<p>setting this to <code>false</code> might do the trick</p>",
        "id": 391581117,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1694989133
    },
    {
        "content": "<p>That setting controls whether to zeta expand local let bindings that have <code>nonDep</code> set to true -- my understanding is that this value is not something you can count on unless your code is fully responsible for your local context.</p>",
        "id": 391581738,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1694989572
    },
    {
        "content": "<p>It looks like <code>revert g</code> prevents <code>simp</code> unfolding it, which is consistent with Tomas' explanation</p>",
        "id": 391582335,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694989959
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/simp.20unfolding.20let.20bindings/near/391581738\">said</a>:</p>\n<blockquote>\n<p>That setting controls whether to zeta expand local let bindings that have <code>nonDep</code> set to true -- my understanding is that this value is not something you can count on unless your code is fully responsible for your local context.</p>\n</blockquote>\n<p>Yeah, a quick test reveals that it does not work</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Qq</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">MetaM</span> <span class=\"n\">Unit</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n\n  <span class=\"n\">withLetDecl</span> <span class=\"bp\">`</span><span class=\"n\">x</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">10</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n    <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"with `zetaNonDep := true` is x =?= y: {← isDefEq x y}\"</span>\n\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">xyEq</span><span class=\"o\">,</span><span class=\"n\">zetaFVars</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">withConfig</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">cfg</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">cfg</span> <span class=\"k\">with</span> <span class=\"n\">zetaNonDep</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"n\">trackZeta</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">})</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">do</span>\n      <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">isDefEq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">getZetaFVarIds</span><span class=\"o\">)</span>\n\n    <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"with 'zetaNonDep := false` is x =?= y: {xyEq}\"</span>\n\n    <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"expandend let fvars {← zetaFVars.toList.mapM (fun id =&gt; ppExpr (Expr.fvar id))}\"</span>\n</code></pre></div>\n<p>returns </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">with</span> <span class=\"bp\">`</span><span class=\"n\">zetaNonDep</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"bp\">`</span> <span class=\"n\">is</span> <span class=\"n\">x</span> <span class=\"bp\">=?=</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">true</span>\n<span class=\"k\">with</span> <span class=\"bp\">'</span><span class=\"n\">zetaNonDep</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"bp\">`</span> <span class=\"n\">is</span> <span class=\"n\">x</span> <span class=\"bp\">=?=</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">true</span>\n<span class=\"n\">expandend</span> <span class=\"k\">let</span> <span class=\"n\">fvars</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I hoped that it would return <code>with 'zetaNonDep := false' is x =?= y: false</code></p>\n<p>There is an option to track which fvars are zeta expanded which seems to work as expected. Not sure if it can be helpful.</p>",
        "id": 391582730,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1694990279
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> You can still set <code>nonDep := true</code> for everything in the context</p>",
        "id": 391583040,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1694990432
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/simp.20unfolding.20let.20bindings/near/391583040\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> You can still set <code>nonDep := true</code> for everything in the context</p>\n</blockquote>\n<p>What does that do? And do you mean <code>LocalDecl.ldecl.nonDep</code>?</p>",
        "id": 391583163,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1694990508
    },
    {
        "content": "<p>Ok, setting <code>nonDep := true</code> manually works, but as Kyle said it is probably not reliable</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Qq</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">MetaM</span> <span class=\"n\">Unit</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n\n  <span class=\"n\">withLetDecl</span> <span class=\"bp\">`</span><span class=\"n\">x</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n\n    <span class=\"k\">let</span> <span class=\"n\">lctx</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getLCtx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">modifyLocalDecl</span> <span class=\"n\">x.fvarId</span><span class=\"bp\">!</span>\n      <span class=\"k\">fun</span> <span class=\"n\">decl</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">ldecl</span> <span class=\"n\">i</span> <span class=\"n\">id</span> <span class=\"n\">name</span> <span class=\"n\">type</span> <span class=\"n\">val</span> <span class=\"n\">nonDep</span> <span class=\"n\">kind</span> <span class=\"o\">:=</span> <span class=\"n\">decl</span> <span class=\"k\">then</span>\n          <span class=\"bp\">.</span><span class=\"n\">ldecl</span> <span class=\"n\">i</span> <span class=\"n\">id</span> <span class=\"n\">name</span> <span class=\"n\">type</span> <span class=\"n\">val</span> <span class=\"n\">true</span> <span class=\"n\">kind</span>\n        <span class=\"k\">else</span>\n          <span class=\"n\">decl</span>\n\n    <span class=\"n\">withLCtx</span> <span class=\"n\">lctx</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getLocalInstances</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">10</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n      <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"with `zetaNonDep := true` is x =?= y: {← isDefEq x y}\"</span>\n\n      <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">xyEq</span><span class=\"o\">,</span><span class=\"n\">zetaFVars</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">withConfig</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">cfg</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">cfg</span> <span class=\"k\">with</span> <span class=\"n\">zetaNonDep</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"n\">trackZeta</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">})</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">do</span>\n        <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">isDefEq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">getZetaFVarIds</span><span class=\"o\">)</span>\n\n      <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"with 'zetaNonDep := false` is x =?= y: {xyEq}\"</span>\n\n      <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"expandend let fvars {← zetaFVars.toList.mapM (fun id =&gt; ppExpr (Expr.fvar id))}\"</span>\n</code></pre></div>\n<p>prints</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">with</span> <span class=\"bp\">`</span><span class=\"n\">zetaNonDep</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"bp\">`</span> <span class=\"n\">is</span> <span class=\"n\">x</span> <span class=\"bp\">=?=</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">true</span>\n<span class=\"k\">with</span> <span class=\"bp\">'</span><span class=\"n\">zetaNonDep</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"bp\">`</span> <span class=\"n\">is</span> <span class=\"n\">x</span> <span class=\"bp\">=?=</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">false</span>\n<span class=\"n\">expandend</span> <span class=\"k\">let</span> <span class=\"n\">fvars</span> <span class=\"o\">[]</span>\n</code></pre></div>",
        "id": 391583777,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1694990907
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> I just meant that you can't depend on it unless you were responsible for the values. Here's code that sets <code>nonDep</code> for all local let bindings (which I think is OK to do?), and then you get the same output as your message.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Qq</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">setNonDep</span> <span class=\"o\">(</span><span class=\"n\">lctx</span> <span class=\"o\">:</span> <span class=\"n\">LocalContext</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">LocalContext</span> <span class=\"o\">:=</span>\n  <span class=\"n\">lctx.foldl</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"n\">lctx</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">lctx'</span> <span class=\"n\">decl</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">lctx'.modifyLocalDecl</span> <span class=\"n\">decl.fvarId</span> <span class=\"k\">fun</span> <span class=\"n\">decl</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">decl</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ldecl</span> <span class=\"n\">index</span> <span class=\"n\">fvarId</span> <span class=\"n\">userName</span> <span class=\"n\">type</span> <span class=\"n\">value</span> <span class=\"n\">_nonDep</span> <span class=\"n\">kind</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"bp\">.</span><span class=\"n\">ldecl</span> <span class=\"n\">index</span> <span class=\"n\">fvarId</span> <span class=\"n\">userName</span> <span class=\"n\">type</span> <span class=\"n\">value</span> <span class=\"n\">true</span> <span class=\"n\">kind</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">decl</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">MetaM</span> <span class=\"n\">Unit</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n\n  <span class=\"n\">withLetDecl</span> <span class=\"bp\">`</span><span class=\"n\">x</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">10</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n    <span class=\"n\">withLCtx</span> <span class=\"o\">(</span><span class=\"n\">setNonDep</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getLCtx</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getLocalInstances</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n\n    <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"with `zetaNonDep := true` is x =?= y: {← isDefEq x y}\"</span>\n\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">xyEq</span><span class=\"o\">,</span><span class=\"n\">zetaFVars</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">withConfig</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">cfg</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">cfg</span> <span class=\"k\">with</span> <span class=\"n\">zetaNonDep</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"n\">trackZeta</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">})</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">do</span>\n      <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">isDefEq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">getZetaFVarIds</span><span class=\"o\">)</span>\n\n    <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"with 'zetaNonDep := false` is x =?= y: {xyEq}\"</span>\n\n    <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"expandend let fvars {← zetaFVars.toList.mapM (fun id =&gt; ppExpr (Expr.fvar id))}\"</span>\n</code></pre></div>\n</div></div>",
        "id": 391584000,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1694991051
    },
    {
        "content": "<p>(There's also a nonDep flag in let expressions themselves, and when you intro them I believe that's what sets the nonDep flag for the ldecl. I'm not sure exactly, but isDefEq might always do zeta reduction of lets, so it doesn't matter if the let expressions could have garbage nonDep values here?)</p>",
        "id": 391584190,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1694991218
    },
    {
        "content": "<p>The <code>nonDep</code> in let binding does not seem to affect <code>isDefEq</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"k\">let</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">Expr.letE</span> <span class=\"bp\">`</span><span class=\"n\">z</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">bvar</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">true</span>\n    <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"with 'zetaNonDep := false` is y =?= z: {← isDefEq y z}}\"</span>\n</code></pre></div>\n<p>still returns true</p>",
        "id": 391584439,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1694991519
    },
    {
        "content": "<p>Yeah, for example WHNF <a href=\"https://github.com/leanprover/lean4/blob/ee3ac9901e9ef5d065c586a902a523710e5b61e9/src/Lean/Meta/WHNF.lean#L517\">always zeta reduces lets</a></p>",
        "id": 391584548,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1694991636
    },
    {
        "content": "<p>Here is demonstration that setting <code>nonDep := true</code> to local context can fix simp. Not sure how reliably but it might work</p>\n<p>I had to peel bunch of layers of simp, so <code>mysimp</code> rather then closing the goal prints out the reduced term</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">f_zero</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.sub_self</span> <span class=\"n\">n</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Parser</span> <span class=\"n\">Tactic</span> <span class=\"k\">in</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">mysimp</span><span class=\"o\">)</span> <span class=\"s2\">\"mysimp\"</span> <span class=\"o\">(</span><span class=\"n\">config</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">discharger</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"bp\">&amp;</span><span class=\"s2\">\" only\"</span><span class=\"o\">)</span><span class=\"bp\">?</span>\n  <span class=\"o\">(</span><span class=\"s2\">\" [\"</span> <span class=\"n\">withoutPosition</span><span class=\"o\">((</span><span class=\"n\">simpStar</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">simpErase</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">simpLemma</span><span class=\"o\">),</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"s2\">\"]\"</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">location</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">setNonDep</span> <span class=\"o\">(</span><span class=\"n\">lctx</span> <span class=\"o\">:</span> <span class=\"n\">LocalContext</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">LocalContext</span> <span class=\"o\">:=</span>\n  <span class=\"n\">lctx.foldl</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"n\">lctx</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">lctx'</span> <span class=\"n\">decl</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">lctx'.modifyLocalDecl</span> <span class=\"n\">decl.fvarId</span> <span class=\"k\">fun</span> <span class=\"n\">decl</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">decl</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ldecl</span> <span class=\"n\">index</span> <span class=\"n\">fvarId</span> <span class=\"n\">userName</span> <span class=\"n\">type</span> <span class=\"n\">value</span> <span class=\"n\">_nonDep</span> <span class=\"n\">kind</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"bp\">.</span><span class=\"n\">ldecl</span> <span class=\"n\">index</span> <span class=\"n\">fvarId</span> <span class=\"n\">userName</span> <span class=\"n\">type</span> <span class=\"n\">value</span> <span class=\"n\">true</span> <span class=\"n\">kind</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">decl</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Meta</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[tactic mysimp]</span> <span class=\"kd\">def</span> <span class=\"n\">mySimpTactic</span> <span class=\"o\">:</span> <span class=\"n\">Tactic</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">{</span> <span class=\"n\">ctx</span><span class=\"o\">,</span> <span class=\"n\">dischargeWrapper</span> <span class=\"o\">}</span> <span class=\"bp\">←</span> <span class=\"n\">withMainContext</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mkSimpContext</span> <span class=\"n\">stx</span> <span class=\"o\">(</span><span class=\"n\">eraseLocal</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span>\n\n  <span class=\"n\">withMainContext</span> <span class=\"k\">do</span>\n    <span class=\"n\">withLCtx</span> <span class=\"o\">(</span><span class=\"n\">setNonDep</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getLCtx</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getLocalInstances</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n      <span class=\"n\">withConfig</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">cfg</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">cfg</span> <span class=\"k\">with</span> <span class=\"n\">zetaNonDep</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"n\">trackZeta</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">})</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">mvarId</span> <span class=\"bp\">←</span> <span class=\"n\">getMainGoal</span>\n        <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">usedSimps'</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mvarId.getType</span><span class=\"o\">)</span> <span class=\"n\">ctx</span>\n\n        <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"simp reduced goal to: {← ppExpr r.expr}\"</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">n</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">mysimp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">zeta</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">})</span> <span class=\"o\">[</span><span class=\"n\">Nat.zero_add</span><span class=\"o\">]</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n</div></div>\n<p>with <code>zetaNonDep := true</code> <code>mysimp</code> prints out <code>simp reduced goal to: True</code> i.e. solves to goal<br>\nwith <code>zetaNonDep := false</code> <code>mysimp</code> prints out <code>simp reduced goal to: g + n = n</code> i.e. leaves the goal unchanged</p>",
        "id": 391585481,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1694992710
    },
    {
        "content": "<p>(How do I put the code into the collapsible box?)</p>",
        "id": 391585619,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1694992886
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>```spoiler SomeCaption\n````lean\nexample True := trivial\n````\n```\n</code></pre></div>",
        "id": 391585724,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1694992988
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/2682\">lean4#2682</a>; I am told that <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span> on the issue mean something to the team.</p>",
        "id": 396504701,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1697203204
    },
    {
        "content": "<p>Some feedback from Leo:</p>\n<blockquote>\n<ol>\n<li>Community wants us to split the <code>zeta</code> flag into two new flags:</li>\n</ol>\n<ul>\n<li>\n<p>zeta1 : Given <code>... x : ty := val ... |- C[x]</code>, <code>simp</code> reduces it to <code> ... x : ty := val ... |- C[val]</code></p>\n</li>\n<li>\n<p>zeta2 : Given <code>.... |- C[let x : ty := val; e[x]]</code>, <code>simp</code> reduces it to <code> ... |- C[e[val]]</code></p>\n</li>\n</ul>\n<p><strong> Please send suggestions to name the new flags. </strong></p>\n<ol start=\"2\">\n<li>Community wants <code>zeta1 := false</code> and <code>zeta2 := true</code> as the default setting for <code>simp</code></li>\n</ol>\n</blockquote>\n<p>I think this would make most people happy, yes?</p>",
        "id": 399064764,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1698509541
    },
    {
        "content": "<p>Is there any situation in which we want <code>zeta1</code> but not <code>zeta2</code>? If so, we could have <code>zeta := true; zeta_ctx := true</code> for <code>zeta1 &amp;&amp; zeta2</code>, and <code>zeta := true; zeta_ctx := false</code> for <code>zeta2</code> only.</p>",
        "id": 399065351,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698510125
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>, given the proposed defaults, it seems the only effect of your suggestion is making it impossible to select <code>zeta1 := true</code>, <code>zeta2 := false</code>, in the (possibly unlikely) scenario that someone wants that. </p>\n<p>(In particular, given the proposed defaults, in the likely scenarios your proposal doesn't actually reduce the amount of configuration by the user.)</p>",
        "id": 399191493,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1698620110
    },
    {
        "content": "<p>How about we name</p>\n<ul>\n<li><code>zeta2</code> as just <code>zeta</code> (i.e. so sometimes people will use <code>zeta := false</code> to completely turn of zeta reduction)</li>\n<li><code>zeta1</code> as <code>zeta_ctx</code> (i.e. so sometimes people will use <code>zeta_ctx := true</code> to additionally do zeta reduction in the context)</li>\n</ul>",
        "id": 399191582,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1698620178
    },
    {
        "content": "<p>That seems reasonable to me. If someone does want to zeta reduce just local variables, there are thing like mathlib's <code>unfold_let</code> tactic when it's given no arguments, or core's <code>zeta</code> conv-mode tactic.</p>",
        "id": 399192945,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698621531
    },
    {
        "content": "<p>Maybe instead of <code>zeta_ctx</code> it could be <code>zeta_locals</code>?</p>",
        "id": 399192949,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698621542
    },
    {
        "content": "<p>The lean3 feature of doing <code>simp [n]</code> to unfold the let binding for <code>n</code> is back, BTW</p>",
        "id": 399194244,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1698622851
    },
    {
        "content": "<p>Good to know, though <code>unfold_let</code> without arguments will unfold all local variables, so if you want the missing configuration you can do <code>unfold_let; simp (config := {zeta := false}) ...</code></p>",
        "id": 399194703,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698623368
    },
    {
        "content": "<p>I am confused by the new behavior of <code>simp</code> in the presence of <code>let</code> bindings in the local context. It seems that <code>config := {zeta := false}</code> is now interpreted as: Lean shouldn't touch anything that is a let.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">abs</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">abs_eq_self</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"o\">}:</span> <span class=\"n\">abs</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">x</span><span class=\"bp\">/</span><span class=\"mi\">2</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">abs</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">zeta</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">})</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">abs_eq_self.mpr</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- simp made no progress</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Using <code>generalize y = z at *</code> before the simp call make it work.</p>",
        "id": 400836090,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699401592
    },
    {
        "content": "<p>I assume you meant \"shouldn't touch\"</p>",
        "id": 400836321,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699401677
    },
    {
        "content": "<p>Yes, thanks Eric.</p>",
        "id": 400836579,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699401755
    },
    {
        "content": "<p><del>Isn't this what the <code>zeta_ctx</code> option discussed above is supposed to solve? Presumably it doesn't exist  yet</del> Nevermind, I see that this should work without unfolding</p>",
        "id": 400836727,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699401793
    },
    {
        "content": "<p><del>The last comments on <a href=\"https://github.com/leanprover/lean4/pull/2682\">lean4#2682</a> are relevant. I think we'll soon get a <code>zeta_ctx</code> flag that does the zeta-reductions in the goals, but doesn't do the ones that are local hypotheses.</del></p>",
        "id": 400836793,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1699401816
    },
    {
        "content": "<p>There is no zeta reduction involved in this example</p>",
        "id": 400836836,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699401832
    },
    {
        "content": "<p>this looks like a bug to me</p>",
        "id": 400836855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699401840
    },
    {
        "content": "<p>Thanks for making the same mistake as me, Floris, to make me feel better!</p>",
        "id": 400836916,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699401859
    },
    {
        "content": "<p>put another way, I would expect <code>simp (config := {zeta := false})</code> to act the same as <code>clear_value at *; simp</code> and this isn't</p>",
        "id": 400836989,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699401914
    },
    {
        "content": "<p>I opened <a href=\"https://github.com/leanprover/lean4/pull/2843\">lean4#2843</a></p>",
        "id": 400837893,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699402457
    }
]