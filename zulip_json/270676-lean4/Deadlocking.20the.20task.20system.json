[
    {
        "content": "<p>While experimenting with the <code>Task</code> system to get a feel for how one might use it for an async setup I noticed that one can rather easily provoke a deadlock in the scheduler like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sleep</span> <span class=\"o\">(</span><span class=\"n\">ms</span> <span class=\"o\">:</span> <span class=\"n\">UInt32</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"sleeping for {ms}\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">t</span> <span class=\"bp\">←</span> <span class=\"n\">IO.asTask</span> <span class=\"o\">(</span><span class=\"n\">IO.sleep</span> <span class=\"n\">ms</span><span class=\"o\">)</span>\n  <span class=\"n\">IO.println</span> <span class=\"s2\">\"Task started, waiting\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">res</span> <span class=\"o\">:=</span> <span class=\"n\">t.get</span>\n  <span class=\"n\">IO.println</span> <span class=\"s2\">\"Task done\"</span>\n  <span class=\"k\">match</span> <span class=\"n\">res</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">()</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">error</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">t1</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">sleep</span> <span class=\"mi\">1000</span>\n  <span class=\"n\">IO.println</span> <span class=\"s2\">\"t1 done\"</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">main</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"c1\">-- set this to nproc</span>\n  <span class=\"k\">let</span> <span class=\"n\">ts</span> <span class=\"bp\">←</span> <span class=\"n\">List.range</span> <span class=\"mi\">8</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">mapM</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">IO.asTask</span> <span class=\"n\">t1</span><span class=\"o\">)</span>\n  <span class=\"n\">for</span> <span class=\"n\">t</span> <span class=\"k\">in</span> <span class=\"n\">ts</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">t.get</span>\n    <span class=\"n\">IO.println</span> <span class=\"n\">r</span>\n  <span class=\"n\">IO.println</span> <span class=\"s2\">\"bye\"</span>\n</code></pre></div>\n<p>To my understanding this happens because Lean does spawn at max 8 (nproc on my machine) pthreads under the hood and it will forcibly run a <code>Task</code> to completion instead of switching to other tasks if possible (for example because the current one is waiting).</p>\n<p>My first question is: Is this a bug? It certainly makes code behave rather differently on machines of different CPU count.</p>\n<p>Secondly this makes me wonder how I should view tasks in terms of async abstractions. It is certainly not usable for computations that want to switch contexts because they are sleeping. Or at least that seems to be the case from my interpretation of the above situation. I did see that we have the Promise abstraction which is based on Tasks, I am not quite certain whether I can provoke a similar issue with just Promises but I feel like it should be possible given how similarly they work?</p>\n<p>In general I would be curious if it is possible to get the above code working only without a deadlock somehow. I would also be interested in how people that understand the concurrency primitives better than me would imagine the design of a Lean async runtime on top of it. Having looked at it so far I can't quite see how to make it work with the runtime primitives yet.</p>",
        "id": 377948134,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1690156168
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> The main problem with your example is that you are waiting on a task from within another task, which worthlessly consumes a thread in the thread pool and is a known pitfall with tasks in Lean and something that one needs to carefully work around (i.e., with <code>bindTask</code> or the like).</p>",
        "id": 377954802,
        "sender_full_name": "Mac Malone",
        "timestamp": 1690159434
    },
    {
        "content": "<p>Right I understand the issue at hand. I just dont exactly see how this fits into my greater understanding of runtime provided green threads. In languages that I know the runtime is usually smart enough to switch green threads when they block or alternatively it doesn't provide a native green thread API at all and let's the user handle that but Lean fits in neither category so I am rather confused as to how would implement something with at least the intended behavior of the code above.</p>",
        "id": 378179566,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1690211621
    }
]