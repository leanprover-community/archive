[
    {
        "content": "<p>How do these differ? Does <code>simp only</code> call <code>rewrite</code>? I notice that sometimes I have to use <code>rewrite</code> instead of <code>simp only</code> when <code>simp only</code> runs into an infinite recursion. Is there a tactic more 'fundamental' than <code>rewrite</code>?</p>",
        "id": 537942588,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1757104278
    },
    {
        "content": "<p><code>rewrite</code> applies a singular rewrite using the equality it was given <code>simp only</code> performs all possible rewrites with the equalities it was given until it reaches a fixpoint.</p>",
        "id": 537944218,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1757104984
    },
    {
        "content": "<p>I think I see. So <code>simp only</code> does call <code>rewrite</code> one or more times?</p>",
        "id": 537944430,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1757105065
    },
    {
        "content": "<p>I don't think that their implementations share much code  (<code>simp</code> uses its own rewriting logic)</p>",
        "id": 537945350,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1757105421
    },
    {
        "content": "<p>To answer your implicit question: You can use the <code>+singlePass</code> option on simp to prevent loops:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">singlePass</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">eq_iff_iff</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 537945627,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1757105550
    },
    {
        "content": "<p>I was more just wondering how these tactics worked, but thank you.</p>",
        "id": 537945775,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1757105615
    },
    {
        "content": "<p>Is there a detailed description somewhere about how <code>rewrite</code> works?</p>",
        "id": 537946124,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1757105769
    },
    {
        "content": "<p>I mean not what it does, but how it works in the type theory.</p>",
        "id": 537947570,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1757106437
    },
    {
        "content": "<p>Well its proof output is <code>Eq.mpr (congrArg (fun x =&gt; ...) h) ?_</code> where the <code>...</code> is just the original expression with all occurrences of the left-hand side substituted</p>",
        "id": 537947887,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1757106591
    },
    {
        "content": "<p>And <code>h</code> is the equality being applied?</p>",
        "id": 537948104,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1757106706
    },
    {
        "content": "<p>Thank you.</p>",
        "id": 537948361,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1757106836
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"139442\">Paige Thomas</span> <a href=\"#narrow/channel/270676-lean4/topic/is.20.60rewrite.60.20more.20'fundamental'.20than.20.60simp.20only.60.3F/near/537945775\">said</a>:</p>\n<blockquote>\n<p>I was more just wondering how these tactics worked</p>\n</blockquote>\n<p>A few months ago <span class=\"user-mention\" data-user-id=\"133339\">@Mirek Olšák</span> (with some help from me) wrote a tutorial about metaprogramming in Lean. The first file is a general introduction to tactic programming, and the second and third file are about how <code>rw</code> and <code>simp</code> work respecively. So if you want to learn about this in more detail, feel free to read this tutorial. See also <a class=\"stream-topic\" data-stream-id=\"239415\" href=\"/#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Introduction.20to.20tactic.20programming/with/533155473\">#metaprogramming / tactics &gt; Introduction to tactic programming</a></p>",
        "id": 537948873,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1757107080
    },
    {
        "content": "<p>Awesome! Thank you!</p>",
        "id": 537949442,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1757107467
    }
]