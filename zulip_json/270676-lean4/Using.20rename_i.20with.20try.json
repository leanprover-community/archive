[
    {
        "content": "<p>When I try using <code>try rename_i x</code> when no inaccessible variables are present, I still get a \"too many variable names provided\" error despite using try. Is there a workaround?</p>\n<p>I'm probably trying to solve the wrong problem though. My actual goal is to get access to all the variables generated from the <code>cases</code> tactic without having to manually mention each case. Is there a version of the macro that's equivalent to <code>intro h ; cases h ; all_goals revert &lt;all the variables introduced by cases</code>?</p>",
        "id": 497210944,
        "sender_full_name": "LambdaDuck (Andreas Källberg)",
        "timestamp": 1738455717
    },
    {
        "content": "<p>This is a bug in <code>rename_i</code>. It's merely logging an error, but not aborting execution, so <code>try</code> doesn't catch it and backtrack. Would you mind reporting it in the Lean 4 github?</p>",
        "id": 497211243,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738456059
    },
    {
        "content": "<p>For your second question, I suppose this is where a Coq-style ssreflect-style sublanguage could come in handy. In ssreflect, there is a focus on manipulating the target rather than introducing local variables.</p>\n<p>If you know what the type is (say it's <code>T</code>) you could do <code>apply T.recOn</code> rather than doing <code>intro</code> first. (Never mind, I thought this would work, but in a test it didn't.)</p>",
        "id": 497211317,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738456139
    },
    {
        "content": "<p>I found that using the variable within the try block so that the other tactic can report an error did work, which seems consistent with your description. For example, I could do this to revert all inaccessible variables into arguments for the goal: <code>all_goals repeat rename_i h; revert h</code></p>",
        "id": 497212093,
        "sender_full_name": "LambdaDuck (Andreas Källberg)",
        "timestamp": 1738457020
    },
    {
        "content": "<p>Here's a sketch of a tactic (<code>cases_on</code>) that does <code>cases</code> on the first parameter. It doesn't fully implement what <code>cases</code> does though (like it doesn't pick up on custom eliminators). It's possible to do this by calling out to the <code>cases</code> tactic, or <code>cases</code> tactic internals, but I was just experimenting and figured I'd paste it here.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"cases_on\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">g0</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">popMainGoal</span>\n<span class=\"w\">  </span><span class=\"n\">g0</span><span class=\"bp\">.</span><span class=\"n\">withContext</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">g0</span><span class=\"bp\">.</span><span class=\"n\">intro1</span>\n<span class=\"w\">    </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">withContext</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">dom</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">getType</span>\n<span class=\"w\">      </span><span class=\"n\">matchConstInduct</span><span class=\"w\"> </span><span class=\"n\">dom</span><span class=\"bp\">.</span><span class=\"n\">getAppFn</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"Expecting type to be an inductive type, not{indentExpr dom}\"</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">ival</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">          </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkConstWithFreshMVarLevels</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkCasesOnName</span><span class=\"w\"> </span><span class=\"n\">ival</span><span class=\"bp\">.</span><span class=\"n\">name</span><span class=\"o\">)</span>\n<span class=\"w\">          </span><span class=\"c1\">-- use the g0 context so that `x` doesn't appear in any premises</span>\n<span class=\"w\">          </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">g0</span><span class=\"bp\">.</span><span class=\"n\">withContext</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">forallMetaTelescope</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferType</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"w\">          </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">params</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">dom</span><span class=\"bp\">.</span><span class=\"n\">getAppArgs</span>\n<span class=\"w\">          </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">params</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">            </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"n\">params</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">              </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"(internal error) failed to assign inductive type parameter\"</span>\n<span class=\"w\">          </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">args</span>\n<span class=\"w\">          </span><span class=\"c1\">-- Set major premise (replace the metavariable)</span>\n<span class=\"w\">          </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"bp\">.</span><span class=\"n\">set!</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ival</span><span class=\"bp\">.</span><span class=\"n\">numParams</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">fvar</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">          </span><span class=\"c1\">-- Set remaining arguments as synthetic opaque so they can be tactic goals</span>\n<span class=\"w\">          </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">minors</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"o\">[</span><span class=\"n\">ival</span><span class=\"bp\">.</span><span class=\"n\">numParams</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">toArray</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">mvarId!</span><span class=\"o\">)</span>\n<span class=\"w\">          </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">minors</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">            </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">setKind</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">syntheticOpaque</span>\n<span class=\"w\">          </span><span class=\"c1\">-- Construct recursor application, motive still needs solving-for</span>\n<span class=\"w\">          </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkAppN</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">args</span>\n<span class=\"w\">          </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">gs</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">casesOn</span>\n<span class=\"w\">          </span><span class=\"n\">pushGoals</span><span class=\"w\"> </span><span class=\"n\">gs</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases_on</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  case nil</span>\n<span class=\"cm\">  ⊢ 0 ≤ [].length</span>\n\n<span class=\"cm\">  case cons</span>\n<span class=\"cm\">  ⊢ ∀ (head : Nat) (tail : List Nat), 0 ≤ (head :: tail).length</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>",
        "id": 497213383,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738458384
    }
]