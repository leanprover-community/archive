[
    {
        "content": "<p>This question came up in a recent Lean thread on HN.  A user asked if Lean supports list comprehensions; the main motivation is as follows:  with list comprehensions, for a k-ary function, the notation </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span> <span class=\"n\">Function</span> <span class=\"n\">Arguments</span> <span class=\"bp\">|</span> <span class=\"n\">arg_1</span> <span class=\"bp\">&lt;-</span><span class=\"n\">List_1</span> <span class=\"bp\">...</span> <span class=\"n\">arg_k</span> <span class=\"n\">List_k</span> <span class=\"o\">]</span>\n</code></pre></div>\n<p>works irrespective of the \"rank\" k; this is very convenient for numerical functions with many arguments.  Do we have something like this?  If not, is it easy to code such variadic notation?</p>",
        "id": 391401759,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1694884523
    },
    {
        "content": "<p>You can do this with do notation quite easily, I think…</p>",
        "id": 391402106,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1694884792
    },
    {
        "content": "<p>It is definitely <code>do</code>able, but a one-liner polymorphic notation would be much nicer.  By the way, I yanked the terminology \"rank polymorphism\" from array languages, and the programmers using them have excellent arguments for its utility.</p>",
        "id": 391402217,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1694884917
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.Basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">L1</span> <span class=\"n\">L2</span> <span class=\"n\">L3</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"bp\">←</span> <span class=\"n\">L1</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"bp\">←</span> <span class=\"n\">L2</span>\n  <span class=\"k\">let</span> <span class=\"n\">c</span> <span class=\"bp\">←</span> <span class=\"n\">L3</span>\n  <span class=\"n\">return</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span>\n</code></pre></div>",
        "id": 391402314,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1694885002
    },
    {
        "content": "<p>You can put those on one line with <code>;</code> if you really want a one-liner.</p>",
        "id": 391402353,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1694885043
    },
    {
        "content": "<p>(to be clear, that is <code>(do let a ← L1; let b ← L2; let c ← L3; return f a b c)</code>)</p>",
        "id": 391402454,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694885146
    },
    {
        "content": "<p>Though you can also write the even shorter <code> do return f (← L1) (← L2) (← L3)</code> which de-sugars to the above</p>",
        "id": 391402528,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694885200
    },
    {
        "content": "<p>Even this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">L1</span> <span class=\"n\">L2</span> <span class=\"n\">L3</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">return</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">L1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">L2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">L3</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 391402600,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1694885279
    },
    {
        "content": "<p>Lean4 is magic.</p>",
        "id": 391402635,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1694885284
    },
    {
        "content": "<p>note that this does only work for <code>List</code>, while the <code>do</code> for-in notation works for lots more types. but there are generic ways to get the same <code>List</code>-like behavior with other types, it just requires mac's itertools or my leancolls :P</p>",
        "id": 391402672,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694885322
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>, what's going on with the lack of <code>do</code> there?</p>",
        "id": 391402862,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694885479
    },
    {
        "content": "<p><code>return</code> does more than just <code>pure</code></p>",
        "id": 391403084,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1694885585
    },
    {
        "content": "<p>i don't know if it's .. <em>desirable</em>.......... that the one without <code>do</code> works, but it's certainly <em>interesting</em> that it does!</p>",
        "id": 391403253,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694885733
    },
    {
        "content": "<p>The <code>return</code> trick is fantastic.</p>",
        "id": 391404115,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1694886303
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/Rank-polymorphic.20fmap.20on.20Lists/near/391403253\">said</a>:</p>\n<blockquote>\n<p>i don't know if it's .. <em>desirable</em>.......... that the one without <code>do</code> works, but it's certainly <em>interesting</em> that it does!</p>\n</blockquote>\n<p>Desirability aside, it is <em>deliberate</em>, <code>return</code> is a term constructor that automatically acts like <code>do return</code></p>",
        "id": 391425284,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694904141
    },
    {
        "content": "<p>FYI, <code>return</code> also short-circuits. E.g. a <code>return</code> in a <code>for</code> loop ends the loop. So it's really more like C's <code>return</code> than Haskell's.</p>",
        "id": 391655749,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1695029649
    }
]