[
    {
        "content": "<p>I'm considering using a special form of induction, but the <code>induction</code> tactic doesn't behave as expected, and I'm seeking advice. Since my current situation is complex (using more technical terms, I'm attempting to perform induction on a structure that is a model of restricted induction axioms like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>I</mi><mrow><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">I_\\mathrm{open}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">open</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><msub><mi mathvariant=\"normal\">Σ</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">I\\Sigma_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord\"><span class=\"mord\">Σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>), to illustrate the issue, I provide a simpler example with a type <code>N</code> that has restricted induction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Init</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">N</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">add_zero</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">add</span> <span class=\"n\">n</span> <span class=\"n\">zero</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">add_succ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">add</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">succ_ne_zero</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">zero</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">Restriction</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">restricted_induction</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Restriction</span> <span class=\"n\">motive</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>Now, I want to prove <code>n ≠ zero → add m n ≠ zero</code>, but it results in an error.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  tactic 'introN' failed, insufficient number of binders</span>\n\n<span class=\"cm\">  nm: N</span>\n<span class=\"cm\">  ⊢ Restriction fun n =&gt; n ≠ zero → add m n ≠ zero</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">restricted_induction</span>\n</code></pre></div>\n<p>Supplementing an term as an argument resolves this error, but I cannot establish the proof for the case when <code>n = zero</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"n\">using</span> <span class=\"n\">restricted_induction</span>\n  <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">·</span> <span class=\"c\">/-</span>\n<span class=\"cm\">      case zero</span>\n<span class=\"cm\">      n m : N</span>\n<span class=\"cm\">      h : n ≠ zero</span>\n<span class=\"cm\">      x✝ : ?m.190</span>\n<span class=\"cm\">      ⊢ add m zero ≠ zero</span>\n<span class=\"cm\">    -/</span>\n    <span class=\"c1\">-- we cannot prove this since there is no proof of zero ≠ zero</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>While using <code>revert h</code> eliminates the error and allows the proof, doing this every time feels cumbersome, especially when there are many assumptions.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">revert</span> <span class=\"n\">h</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">restricted_induction</span>\n  <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">contradiction</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_succ</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">succ_ne_zero</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>What would be the recommended approach in this situation? Should <code>induction</code> not be used in such cases?</p>",
        "id": 416724841,
        "sender_full_name": "Palalansoukî",
        "timestamp": 1705650683
    },
    {
        "content": "<p>It's cumbersome in a different way, but you could use <code>refine</code>, assuming your induction principle is tagged <code>@[elab_as_elim]</code> to get the elaborator to solve for the <code>motive</code> argument.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">restricted_induction</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Restriction</span> <span class=\"n\">motive</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">restricted_induction</span> <span class=\"bp\">?</span><span class=\"n\">res</span> <span class=\"bp\">?</span><span class=\"n\">zero</span> <span class=\"bp\">?</span><span class=\"n\">succ</span> <span class=\"n\">n</span>\n  <span class=\"c1\">-- has three goals, `res`, `zero` and `succ`</span>\n</code></pre></div>",
        "id": 416750961,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705660853
    },
    {
        "content": "<p>It seems that this is not working well. In the generated <code>zero</code> goal, the <code>n</code> appearing in the assumption <code>h</code> should be rewritten to <code>zero</code>, but it is not, so it cannot be proven.</p>",
        "id": 416755050,
        "sender_full_name": "Palalansoukî",
        "timestamp": 1705662178
    },
    {
        "content": "<p>Ah, ok, you need to do the same <code>revert</code>/<code>intro</code> trick with <code>refine</code> too to get that to happen, so this is no better than what you have.</p>",
        "id": 416755737,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705662404
    },
    {
        "content": "<p>One could argue that this is a bug in the <code>induction</code> tactic; it should only <code>intro</code> in cases where the <code>motive</code> is the conclusion of that case.</p>\n<p>Maybe open an issue and we can see how often this comes up and whether <code>induction</code> should handle it, or whether these are too corner case and users just have to apply the lemma manually (revert + refine)</p>",
        "id": 416763015,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705665380
    },
    {
        "content": "<p>Looking at the code a bit, I one possible fix would be to extend <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.Match.Alt#doc\">docs#Lean.Meta.Match.Alt</a> with a field indicating whether this “alternative” as the <code>motive</code> as the result type, and then use that field in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Tactic.ElimApp.evalAlts#doc\">docs#Lean.Elab.Tactic.ElimApp.evalAlts</a> to run</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>          <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">altMVarId</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">altMVarId'.introNP</span> <span class=\"n\">numGeneralized</span>\n</code></pre></div>\n<p>only if it is set. Probably worth fixing.</p>",
        "id": 416769546,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705668030
    },
    {
        "content": "<p>Thanks. I opened the issue <a href=\"https://github.com/leanprover/lean4/issues/3212\">https://github.com/leanprover/lean4/issues/3212</a></p>",
        "id": 417388201,
        "sender_full_name": "Palalansoukî",
        "timestamp": 1705996229
    },
    {
        "content": "<p>Not sure if I should post this here or in a new thread, but: it would be cool if this fix could be extended to <code>cases</code> as well. I have a very similar case where my <code>cases_eliminator</code> comes out of a quotient type, so requires a side-condition that doesn't conclude a <code>motive _</code>; I can't use <code>induction</code> because my use case almost always has non-atomic parameters in the type of the scrutinee.</p>",
        "id": 522065715,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1748941601
    }
]