[
    {
        "content": "<p>I have defined a binary tree with inner nodes, which i made into an instance of Membership:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">emp</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bnode</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">memb'</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"bp\">.</span><span class=\"n\">emp</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"bp\">.</span><span class=\"n\">bnode</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\">  </span><span class=\"n\">memb'</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">memb'</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Membership</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">mem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">memb'</span>\n</code></pre></div>\n<p>With this i can now write for a Tree nat_tree holding natural numbers</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">nat_tree</span><span class=\"w\">    </span><span class=\"c1\">-- : Prop</span>\n</code></pre></div>\n<p>However i would like to use this also in boolean contexts. As this is clearly decidable. How do i go about this, declare this as an instance of Decidable (and if so, how?) or should i immediately define the above functions to return booleans and and then declare Tree as instance of another type class (BoolMemb, or something like that)? </p>\n<p>Thank you!</p>",
        "id": 498825951,
        "sender_full_name": "Anton Mueller",
        "timestamp": 1739210119
    },
    {
        "content": "<p>Can you make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> (<code>nat_tree</code> is not defined there)?</p>",
        "id": 498826421,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739210274
    },
    {
        "content": "<p>The error message should inform you how to state the <code>Decidable</code> instance</p>",
        "id": 498826501,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739210288
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">emp</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bnode</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n\n<span class=\"c1\">-- don't use BEq for this; likely you want true Eq</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">memb'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"bp\">.</span><span class=\"n\">emp</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">False</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"bp\">.</span><span class=\"n\">bnode</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">memb'</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">memb'</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Membership</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">mem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">memb'</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">memb''</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"bp\">.</span><span class=\"n\">emp</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"bp\">.</span><span class=\"n\">bnode</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"n\">memb''</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"n\">memb''</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">memb'_iff_memb''</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">memb'</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">memb''</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">memb'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">memb''</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">or_assoc</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">decidable_of_iff'</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">memb'_iff_memb''</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 498827308,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739210526
    },
    {
        "content": "<p>The general pattern is (1) define the Prop version, (2) define the Bool version, (3) prove they're equivalent, and (4) define the Decidable instance using the Bool version.</p>\n<p>(1) generally doesn't need additional hypotheses. (2) may have additional decidability hypotheses that the algorithm requires.</p>",
        "id": 498827737,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739210660
    },
    {
        "content": "<p>The BEq class has no logical content. The <code>=</code> operator comes with every type for free, and you should use it unless you have a special use case.</p>\n<p><code>DecidableEq</code> provides a <code>BEq</code> instance. Plus, that <code>BEq</code> instance satisfies <code>LawfulBEq</code>, so it has logical content.</p>",
        "id": 498828001,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739210748
    },
    {
        "content": "<p>Should <code>memb''</code> arguably be defined with <code>BEq</code>?</p>",
        "id": 498828410,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739210866
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/270676-lean4/topic/instance.20.3A.20Decidable/near/498826421\">schrieb</a>:</p>\n<blockquote>\n<p>Can you make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> (<code>nat_tree</code> is not defined there)?</p>\n</blockquote>\n<p>Should have defined it, but nat_tree was intended to be some very simple example that merely type checks the #check command:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nat_tree</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"bp\">.</span><span class=\"n\">emp</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nat_tree'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"bp\">.</span><span class=\"n\">bnode</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"bp\">.</span><span class=\"n\">emp</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"bp\">.</span><span class=\"n\">emp</span>\n</code></pre></div>",
        "id": 498828699,
        "sender_full_name": "Anton Mueller",
        "timestamp": 1739210936
    },
    {
        "content": "<p>What I was leading to is that you could then use <code>#eval</code> instead of <code>#check</code> to have Lean tell you where the Decidable issue is (you can try it with Kyle's code above)</p>",
        "id": 498828888,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739210992
    },
    {
        "content": "<p>I think it's up to the author <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>. I could have easily used <code>=</code> in the Bool-valued version too to head off that question.</p>",
        "id": 498828897,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739210994
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/270676-lean4/topic/instance.20.3A.20Decidable/near/498826501\">schrieb</a>:</p>\n<blockquote>\n<p>The error message should inform you how to state the <code>Decidable</code> instance</p>\n</blockquote>\n<p>Thank you, this perfectly solves my question!</p>",
        "id": 498828912,
        "sender_full_name": "Anton Mueller",
        "timestamp": 1739210999
    },
    {
        "content": "<p>The argument for <code>BEq</code> there would be if you want to construct trees of floats, with a nan-respecting membership operator (nan is not in any tree)</p>",
        "id": 498829109,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739211057
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816604\">Anton Mueller</span> has marked this topic as resolved.</p>",
        "id": 498829264,
        "sender_full_name": "Notification Bot",
        "timestamp": 1739211117
    },
    {
        "content": "<p>That's let you use <code>memb''</code> in non-lawful cases, but the resulting <code>Membership</code> instance wouldn't be useable, right?</p>",
        "id": 498829398,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739211156
    },
    {
        "content": "<p>Correct, the distinction only matters if you care about the non-lawful case at all</p>",
        "id": 498831597,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739211753
    },
    {
        "content": "<p>I get that that's what you meant, but it's worth pointing out that <code>∈</code> notation can't be used in that case; you'd have to go back to <code>memb</code> itself and make it conditional on there being a <code>BEq</code> instance.</p>\n<p>The reason for <code>memb''</code> in the first place is that it's a way to define the <code>Decidable (a ∈ T)</code> instance, rather than being useful on its own.</p>",
        "id": 498833398,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739212276
    }
]