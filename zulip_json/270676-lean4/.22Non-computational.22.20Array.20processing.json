[
    {
        "content": "<p>I have a question about compiled code and what Lean does with \"non-computational\" data changes.</p>\n<p>Specifically, consider the following function.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">blahj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">mapFinIdx</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"bp\">âŸ©</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>So this function takes an array of <code>Nat</code>s, along with a proof that they are all less than some <code>n</code>, and packages them all up as <code>Fin n</code>. However, when compiled, Lean \"forgets about\" the <code>Fin n</code> - they are just <code>Nat</code>. The data representation of the array doesn't actually change, I think. Does this function end up therefore as a no-op? Does it still have to traverse the array (making it O(a.size) even if it doesn't actually do anything)? What happens here?</p>",
        "id": 525666983,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750842358
    },
    {
        "content": "<p>This function does not currently end as a no-op, you can inspect the generated IR with <code>set_option trace.compiler.ir.result true</code>, it does indeed iterate over the array</p>",
        "id": 525674694,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1750844997
    },
    {
        "content": "<p>Thanks. Is there a way to implement it so that it IS a no-op?</p>",
        "id": 525674761,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750845020
    },
    {
        "content": "<p>wasn't there some sort of unsafe cast that would allow you to do that</p>",
        "id": 525675350,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750845194
    },
    {
        "content": "<p>A shame if it has to be unsafe.</p>",
        "id": 525675421,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750845220
    },
    {
        "content": "<p>If you can live with a subtype rather than <code>Fin</code>, then <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.attachWith#doc\">docs#Array.attachWith</a> will work.</p>",
        "id": 525687053,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1750849355
    },
    {
        "content": "<p>Though that also uses <code>unsafe</code>, which makes it no more useful to Wrenna</p>",
        "id": 525688639,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750849994
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330967\">@Wrenna Robson</span> , perhaps it's worth remembering that the fact this operation is \"noncomputational\" is an implementation detail that lives outside the type theory, and so anything that exploits it is by definition <code>unsafe</code>.</p>",
        "id": 525688784,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750850047
    },
    {
        "content": "<p>(sure, the compiler could natively detect this, but the code it generates would amount to what you would otherwise write via <code>unsafe</code> and <code>implemented_by</code>)</p>",
        "id": 525688946,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750850108
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/.22Non-computational.22.20Array.20processing/near/525688639\">said</a>:</p>\n<blockquote>\n<p>Though that also uses <code>unsafe</code>, which makes it no more useful to Wrenna</p>\n</blockquote>\n<p>I would say that there is a difference between using a safe library function that is implemented using <code>unsafe</code> and calling an <code>unsafe</code> library function directly in your own code. If you get unsafe behavior in the former case, it's necessarily a Lean bug, whereas in the latter case you have to make sure that you uphold all invariants yourself.</p>",
        "id": 525690673,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1750850794
    },
    {
        "content": "<p>Is \"structures with a single data field have a runtime representation of just that field\" a specified behavior that downstream code can reasonably rely on?</p>",
        "id": 525691002,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750850915
    },
    {
        "content": "<p>It's at least written down in documentation that is not considered internal implementation details.</p>",
        "id": 525691293,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1750851026
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I was thinking about this in line with my permutation arrays thing, incidentally, if you were wondering about the context.</p>",
        "id": 525697037,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750852863
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260921\">Markus Himmel</span> <a href=\"#narrow/channel/270676-lean4/topic/.22Non-computational.22.20Array.20processing/near/525687053\">said</a>:</p>\n<blockquote>\n<p>If you can live with a subtype rather than <code>Fin</code>, then <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.attachWith#doc\">docs#Array.attachWith</a> will work.</p>\n</blockquote>\n<p>One could imagine a version of \"attachWith\" that did this but went to <code>Fin</code> instead. It's often somewhat annoying that <code>Fin</code> isn't a subtype, really, because it means stuff built for subtypes doesn't work directly with it.</p>",
        "id": 525697276,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750852940
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/270676-lean4/topic/.22Non-computational.22.20Array.20processing/near/525691002\">said</a>:</p>\n<blockquote>\n<p>Is \"structures with a single data field have a runtime representation of just that field\" a specified behavior that downstream code can reasonably rely on?</p>\n</blockquote>\n<p>Yes (as Henrik notes), but there are some minor bugs where this does not happen today (e.g. the one I pointed out in <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/noncomputable.20checker.20regression/near/525102142\">#lean4 &gt; noncomputable checker regression @ ðŸ’¬</a>, or <a href=\"https://github.com/leanprover/lean4/pull/2589\">lean4#2589</a>). I plan to fix all of these in the coming quarter.</p>",
        "id": 525788115,
        "sender_full_name": "Cameron Zwarich",
        "timestamp": 1750884635
    }
]