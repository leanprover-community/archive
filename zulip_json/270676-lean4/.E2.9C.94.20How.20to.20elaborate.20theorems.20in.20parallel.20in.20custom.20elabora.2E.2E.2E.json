[
    {
        "content": "<p><a href=\"https://github.com/verse-lab/veil\">Veil</a> has a <a href=\"https://github.com/verse-lab/veil/blob/008920a878e6809c26f348b02df94190d1816c5b/Veil/DSL/Check/Main.lean#L482\"><code>#check_invariants</code></a>  command that generates the syntax for a list of Lean <code>theorem</code>s and <a href=\"https://github.com/verse-lab/veil/blob/008920a878e6809c26f348b02df94190d1816c5b/Veil/DSL/Check/Main.lean#L200\">runs <code>elabCommand</code></a> on each of them. It also reads the InfoTree messages that are generated during the elaboration of each theorem to collate the results into readable output.</p>\n<p>Seeing the parallel elaboration support that <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> recently added to Lean (many thanks!), I've managed to get all these <code>elabCommand</code> calls to run asynchronously and read the InfoTree messages for all of them to collate results in the same way as before. The code for that is in <a href=\"https://github.com/verse-lab/veil/blob/008920a878e6809c26f348b02df94190d1816c5b/Veil/DSL/Check/Main.lean#L271-L298\"><code>Veil/DSL/Check/Main.lean:CheckTheorems#L271-298</code></a> (on a branch for now):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">results</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">async</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getOptions</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Prepare tasks for parallel execution (but don't execute them yet)</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">cancelTk</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">CancelToken</span><span class=\"bp\">.</span><span class=\"n\">new</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">tasks</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BaseIO</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"bp\">.</span><span class=\"n\">SnapshotTree</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">allTheorems</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">thmId</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"n\">wrapAsyncAsSnapshot</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">processThm</span><span class=\"w\"> </span><span class=\"n\">thmId</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">cancelTk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">desc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{thmId.theoremName}\"</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">tasks</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">tasks</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">task</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">BaseIO</span><span class=\"bp\">.</span><span class=\"n\">asTask</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">task</span><span class=\"w\"> </span><span class=\"o\">()))</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Execute tasks in parallel and collect results</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">allTasks</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">BaseIO</span><span class=\"bp\">.</span><span class=\"n\">mapTasks</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">snaptree</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">snaptree</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">tasks</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">trees</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">allTasks</span><span class=\"bp\">.</span><span class=\"n\">get</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">results</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">trees</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">tree</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">msgsTxt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">intercalate</span><span class=\"w\"> </span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">tree</span><span class=\"bp\">.</span><span class=\"n\">element</span><span class=\"bp\">.</span><span class=\"n\">diagnostics</span><span class=\"bp\">.</span><span class=\"n\">msgLog</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"bp\">.</span><span class=\"n\">filterMapM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">msg</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">msgStr</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">msg</span><span class=\"bp\">.</span><span class=\"n\">toString</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">msg</span><span class=\"bp\">.</span><span class=\"n\">severity</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">information</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">msgStr</span><span class=\"bp\">.</span><span class=\"n\">startsWith</span><span class=\"w\"> </span><span class=\"n\">CheckTheoremResultStringMarker</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">          </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">msgStr</span><span class=\"bp\">.</span><span class=\"n\">stripPrefix</span><span class=\"w\"> </span><span class=\"n\">CheckTheoremResultStringMarker</span>\n<span class=\"w\">        </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">))</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">json</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">parseStrAsJson</span><span class=\"w\"> </span><span class=\"n\">msgsTxt</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">checkResult</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">CheckTheoremResult</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">none</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">fromJson?</span><span class=\"w\"> </span><span class=\"n\">json</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">cr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">checkResult</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">cr</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"n\">err</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"could not parse {msgsTxt} as CheckTheoremResult: {err}\"</span>\n<span class=\"w\">      </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">checkResult</span><span class=\"bp\">.</span><span class=\"n\">get!</span>\n<span class=\"w\">    </span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">results</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">results</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">allTheorems</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">thmId</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">processThm</span><span class=\"w\"> </span><span class=\"n\">thmId</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">results</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n</code></pre></div>\n<p>The issue is I don't know how to do this such that the theorems are persisted in the environment. The documentation of <code>wrapAsyncAsSnapshot</code> makes it clear that it drops all state after doing the computation.</p>\n<p>I looked at the implementation of <code>elabMutualDef</code>. I guess I could try re-implementing some of that logic, but that seems very error-prone (a quick  attempt led to some errors about <code>mainOnly</code> environments) and difficult for me to maintain in the long-term.</p>\n<p>Questions:</p>\n<ul>\n<li>Is there some more user-facing API for elaborating a bunch of theorems in parallel and persisting the changes to the environment? Or a willingness to add one? <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></li>\n<li>If not, how do you recommend I implement this functionality in Veil? It greatly improves our performance, so it's a priority for us.</li>\n</ul>",
        "id": 516877180,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1746705378
    },
    {
        "content": "<p>Do you specifically need more parallelism than what <code>theorem</code> already provides, i.e. in the theorem signature as well?</p>",
        "id": 516932822,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1746720507
    },
    {
        "content": "<p>No, I don't need more parallelism. What <code>theorem</code> currently provides is sufficient — I just don't know how to make multiple theorems be elaborated in parallel (and persist in the environment) from a single command.</p>",
        "id": 516951165,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1746726875
    },
    {
        "content": "<p>Maybe I'm missing something very basic.</p>",
        "id": 516951842,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1746727120
    },
    {
        "content": "<p>Ahh, looking at your third link, I would assume the proofs are already being elaborated asynchronously by the theorem elaborator, but then each result is immediately being waited on, destroying any chance for parallelism. The waiting is happening both from <code>#guard_msgs</code> and your own code at <code>getConstInfo</code>. The former one is a bit problematic to eliminate but otherwise I'd assume first doing all your <code>elabCommand</code> calls in one loop and then doing the <code>getConstInfo</code>s in a separate loop should do the trick.</p>",
        "id": 516978925,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1746737709
    },
    {
        "content": "<p>Ah, indeed, they are being elaborated asynchronously. Thank you for looking at the code! I really appreciate it.</p>\n<blockquote>\n<p>I'd assume first doing all your <code>elabCommand</code> calls in one loop and then doing the <code>getConstInfo</code>s in a separate loop should do the trick.</p>\n</blockquote>\n<p>I tried this and it works in terms of elaborating the theorems in parallel, but the current code when run with<code>Elab.async = false</code> also does two additional things:</p>\n<ol>\n<li>it <a href=\"https://github.com/verse-lab/veil/blob/008920a878e6809c26f348b02df94190d1816c5b/Veil/DSL/Check/Main.lean#L214-L217\">resets the environment</a> when a theorem is not proven, such that only proven <code>theorem</code>s are in the environment afterwards</li>\n<li>it <a href=\"https://github.com/verse-lab/veil/blob/008920a878e6809c26f348b02df94190d1816c5b/Veil/DSL/Check/Main.lean#L241-L263\">captures</a> the messages generated by each theorem, parses them, and then removes them from the InfoTree, so only the summary is eventually shown to the user</li>\n</ol>\n<p>I'm not sure what is the best way achieve this with asynchronous code. What comes to mind right now is: I can write my own version of <code>elabMutualDef</code> that does <code>withoutErrToSorry</code> before doing the actual elaboration (for point 1) and doesn't insert the <code>infoState</code> hole from the child task, but just <code>resolve</code>s the <code>infoPromise</code> and parses it directly.</p>\n<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> do you see a better option?</p>\n<p>The ideal API I can envision for my use-case would be a transactional API similar to <code>wrapAsyncAsSnapshot</code>, but where you can both inspect the InfoTree and \"commit\" the changes made asynchronously into the top-level environment if you want. I'm not sure anyone else has a use for that kind of API, though.</p>",
        "id": 517046698,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1746775768
    },
    {
        "content": "<p>Actually,  modifying <code>elabMutualDef</code> to add a <code>withoutErrToSorry</code> doesn't seem to change anything. Not sure what's going on.</p>\n<p>In any case, maintaining a separate version of <code>elabMutualDef</code> seems like a very bad idea.</p>",
        "id": 517063404,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1746781394
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"542918\">George Pîrlea</span> <a href=\"#narrow/channel/270676-lean4/topic/How.20to.20elaborate.20theorems.20in.20parallel.20in.20custom.20elaborator.3F/near/517046698\">said</a>:</p>\n<blockquote>\n<ol>\n<li>it <a href=\"https://github.com/verse-lab/veil/blob/008920a878e6809c26f348b02df94190d1816c5b/Veil/DSL/Check/Main.lean#L214-L217\">resets the environment</a> when a theorem is not proven, such that only proven <code>theorem</code>s are in the environment afterwards</li>\n</ol>\n</blockquote>\n<p>This in itself should work as before</p>\n<p><span class=\"user-mention silent\" data-user-id=\"542918\">George Pîrlea</span> <a href=\"#narrow/channel/270676-lean4/topic/How.20to.20elaborate.20theorems.20in.20parallel.20in.20custom.20elaborator.3F/near/517046698\">said</a>:</p>\n<blockquote>\n<ol>\n<li>it <a href=\"https://github.com/verse-lab/veil/blob/008920a878e6809c26f348b02df94190d1816c5b/Veil/DSL/Check/Main.lean#L241-L263\">captures</a> the messages generated by each theorem, parses them, and then removes them from the InfoTree, so only the summary is eventually shown to the user</li>\n</ol>\n</blockquote>\n<p>The async messages should be stored in <code>Lean.Elab.Command.State.snapshotTasks</code>, see e.g. <code>logGoalsAccomplishedSnapshotTask</code> for how to wait on and collect them (you should be able to ignore the <code>defsParsedSnap</code> there). Resetting the field then should get rid of them.</p>",
        "id": 517274687,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1746896215
    },
    {
        "content": "<p>The difficulty with (1) is that <code>#check_invariants</code> checks multiple theorems and I don't want to remove all of them if just one fails (but rather just the one that failed). The current use of <code>getEnv</code> and <code>setEnv</code> crucially relies on theorems being elaborated one by one. So, for instance, if I have theorems 1-6 and 3 is not proven, I want 1, 2, 4, 5, and 6 to still be added to the environment. So it's not sufficient to capture the environment before 3 gets added and restore that.</p>",
        "id": 517420204,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1747019163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/channel/270676-lean4/topic/How.20to.20elaborate.20theorems.20in.20parallel.20in.20custom.20elaborator.3F/near/517274687\">said</a>:</p>\n<blockquote>\n<p>The async messages should be stored in <code>Lean.Elab.Command.State.snapshotTasks</code>, see e.g. <code>logGoalsAccomplishedSnapshotTask</code> for how to wait on and collect them (you should be able to ignore the <code>defsParsedSnap</code> there). Resetting the field then should get rid of them.</p>\n</blockquote>\n<p>That makes sense. Thank you!</p>",
        "id": 517420278,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1747019217
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"542918\">George Pîrlea</span> <a href=\"#narrow/channel/270676-lean4/topic/How.20to.20elaborate.20theorems.20in.20parallel.20in.20custom.20elaborator.3F/near/517420204\">said</a>:</p>\n<blockquote>\n<p>The difficulty with (1) is that <code>#check_invariants</code> checks multiple theorems and I don't want to remove all of them if just one fails (but rather just the one that failed).</p>\n</blockquote>\n<p>Oh, I see! <code>Environment.replayConsts</code> could be used to remove individual theorems... but at that point, I would question whether this syntactic approach really is the most fitting one for you. If the structure of your <code>theorem</code>s is relatively rigid, have you considered not using <code>theorem</code> at all and driving elaboration yourself so that you have perfect control over parallelism and additions to the environment?</p>",
        "id": 517457029,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1747036390
    },
    {
        "content": "<p>I think that's the way to go long-term, yes. Thanks so much for your help, Sebastian!</p>",
        "id": 517719573,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1747104190
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"542918\">George Pîrlea</span> has marked this topic as resolved.</p>",
        "id": 517719581,
        "sender_full_name": "Notification Bot",
        "timestamp": 1747104195
    }
]