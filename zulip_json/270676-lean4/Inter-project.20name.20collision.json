[
    {
        "content": "<p>I ran into a problem about collision of theorem names in different projects.<br>\nI have two personal projects, say A and B, using Lean4; A doesn't depend on Mathlib while B does.<br>\nThe problem is that I cannot use codes from the project A in B because some auxiliary lemmas in A have the same names as ones in Mathlib.<br>\nMy questions are:</p>\n<ul>\n<li>is there any \"standard\" solution in such a situation?</li>\n<li><code>lake build</code> stops at each collision pair with the error message like</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">B.lean</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"mi\">0</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"kn\">import</span> <span class=\"n\">A.Data.List.Basic</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">environment</span> <span class=\"n\">already</span> <span class=\"n\">contains</span> <span class=\"bp\">'</span><span class=\"n\">List.dropLast_eq_take'</span> <span class=\"k\">from</span> <span class=\"n\">Mathlib.Data.List.Basic</span>\n</code></pre></div>\n<p>It is good if I can detect all collision pair at onece. Any idea?</p>",
        "id": 379972682,
        "sender_full_name": "Jun Yoshida",
        "timestamp": 1690708693
    },
    {
        "content": "<p>Another concern is that, as Mathlib is growing, I am not sure my auxiliary theorems in the project A have \"safe\" names even in near future.</p>",
        "id": 379972734,
        "sender_full_name": "Jun Yoshida",
        "timestamp": 1690708713
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"433695\">@Jun Yoshida</span> The usual way to solve this is for packages to not define all their definitions within a namespace that matches the package / root module name (i.e., <code>A</code> and <code>B</code> and your example). Only very standard libraries like Mathlib and Std should stick stuff in the root namespace or augment existing namespaces like <code>List</code>.</p>",
        "id": 379976876,
        "sender_full_name": "Mac Malone",
        "timestamp": 1690709906
    },
    {
        "content": "<p>If <code>List.dropLast_eq_take</code>, for example, is defined inbetween <code>namespace A</code>-<code>end A</code>, then I cannot write <code>l.dropLast_eq_take</code> for <code>l : List Nat</code>.<br>\nThis seems a drawback.</p>",
        "id": 379979159,
        "sender_full_name": "Jun Yoshida",
        "timestamp": 1690710569
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 379979499,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1690710649
    },
    {
        "content": "<p>The \"standard\" solution for having names in library namespaces might be to try to contribute such lemmas to mathlib or std.</p>\n<p>Another solution would be to add a prefix to names you insert into library namespaces, like <code>List.my_dropLast_eq_take</code> or <code>List.jun_dropLast_eq_take</code>.</p>",
        "id": 379984460,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1690711884
    },
    {
        "content": "<p>The safest solution is to do what Mac suggested, put your own things into your own namespace. It's true that it's unfortunate that you can't use <code>l.dropLast_eq_take</code> notation, but that's the tradeoff you have to take if you want to be safe against name collisions.</p>",
        "id": 379985249,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1690712093
    },
    {
        "content": "<blockquote>\n<p>The \"standard\" solution for having names in library namespaces might be to try to contribute such lemmas to mathlib or std.</p>\n</blockquote>\n<p>In this particular case it sounds like the lemma is already in mathlib; the problem is that project A decided to reimplement this lemma rather than depending on mathlib</p>",
        "id": 380032319,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690723159
    },
    {
        "content": "<p>Thank you for a lot of advice. I do not use mathlib in the project A because it is a library for data structures/algorithms to be used in constructive context. Some name collision are actually due to <code>Classical</code>-free re-proof of theorems in std for which I just stupidly add primes in the last of the original name. I understand that the library name space is the safest solution, but it requires a huge refactor in the project A, which I want to avoid as much as possible.</p>\n<p>I also consider the use of private declarations. If I keep track with such declarations in the project, I can export them locally in the same way as <code>export private</code> does.<br>\nHere is my attempt to this approach:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Definition of pkg_local attribute and pkg_include command</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">I define</span>\n<span class=\"cm\">* `pkg_local (pkg := PackageName)?` attribute, which register a private declaration in a declaration list associated to `PackageName`, and</span>\n<span class=\"cm\">* `pkg_include (pkg := PackageName)? ident*` command, which imports declarations specified by `decl`s from the declaration list associated to `PackageName` into the current file.</span>\n<span class=\"cm\">In both cases, the part `(pkg := PackageName)` is optional; if it is not served, `PackageName` is the head of the current module name (i.e. in the module `A.B.C`, ``PackageName = `A``).</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span> <span class=\"n\">Command</span> <span class=\"n\">Meta</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">### `PkgLocalDecl`</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"sd\">/-- The data structure that carries major data of package local declarations -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">PkgLocalDecl</span> <span class=\"n\">where</span>\n  <span class=\"n\">pkgName</span> <span class=\"o\">:</span> <span class=\"n\">Name</span>\n  <span class=\"n\">declName</span> <span class=\"o\">:</span> <span class=\"n\">Name</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span><span class=\"o\">,</span> <span class=\"n\">Repr</span><span class=\"o\">,</span> <span class=\"n\">BEq</span><span class=\"o\">,</span> <span class=\"n\">Hashable</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">### `pkg_local` attribute</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">pkg_local</span><span class=\"o\">)</span> <span class=\"s2\">\"pkg_local \"</span> <span class=\"o\">(</span><span class=\"s2\">\"(\"</span> <span class=\"bp\">&amp;</span><span class=\"s2\">\"pkg\"</span> <span class=\"s2\">\" := \"</span> <span class=\"n\">ident</span> <span class=\"s2\">\")\"</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">attr</span>\n\n<span class=\"n\">initialize</span> <span class=\"n\">registerTraceClass</span> <span class=\"bp\">`</span><span class=\"n\">pkg_local</span>\n\n<span class=\"sd\">/-- The environment extension to track declarations with @[pkg_local] attribute. -/</span>\n<span class=\"n\">initialize</span> <span class=\"n\">pkglocalExtension</span> <span class=\"o\">:</span>\n    <span class=\"n\">SimpleScopedEnvExtension</span> <span class=\"n\">PkgLocalDecl</span> <span class=\"o\">(</span><span class=\"n\">HashSet</span> <span class=\"n\">PkgLocalDecl</span><span class=\"o\">)</span> <span class=\"bp\">←</span>\n  <span class=\"n\">registerSimpleScopedEnvExtension</span> <span class=\"o\">{</span>\n    <span class=\"n\">addEntry</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">dt</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">dt.insert</span>\n    <span class=\"n\">initial</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n  <span class=\"o\">}</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">Lean.Name.head</span> <span class=\"o\">:</span> <span class=\"n\">Name</span> <span class=\"bp\">→</span> <span class=\"n\">Name</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">anonymous</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">anonymous</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">str</span> <span class=\"bp\">.</span><span class=\"n\">anonymous</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">str</span> <span class=\"n\">child</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">child.head</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">num</span> <span class=\"n\">child</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">child.head</span>\n\n<span class=\"n\">initialize</span> <span class=\"n\">registerBuiltinAttribute</span> <span class=\"o\">{</span>\n  <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">pkg_local</span>\n  <span class=\"n\">descr</span> <span class=\"o\">:=</span> <span class=\"s2\">\"Attribute for package-local definitions/theorems.\"</span>\n  <span class=\"n\">applicationTime</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">afterTypeChecking</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">declName</span> <span class=\"n\">stx</span> <span class=\"n\">kind</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"bp\">|</span> <span class=\"n\">pkg_local</span> <span class=\"bp\">$</span><span class=\"o\">[(</span><span class=\"n\">pkg</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">pkgid</span><span class=\"o\">)]</span><span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">stx</span>\n      <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"unexted `@[pkg_local]` attribute {stx}\"</span>\n    <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">global</span> <span class=\"o\">:=</span> <span class=\"n\">kind</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"`@[pkg_local]` can only be used as a global attribute.\"</span>\n    <span class=\"k\">if</span> <span class=\"bp\">!</span><span class=\"o\">(</span><span class=\"n\">isPrivateName</span> <span class=\"n\">declName</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n      <span class=\"n\">logWarning</span> <span class=\"s2\">\"`[@pkg_local]` is used on a non-private declaration.\"</span>\n    <span class=\"n\">MetaM.run'</span> <span class=\"k\">do</span>\n      <span class=\"n\">dbg_trace</span> <span class=\"s2\">\"declName : {declName}\"</span>\n      <span class=\"k\">let</span> <span class=\"n\">moduleName</span> <span class=\"bp\">←</span> <span class=\"n\">getMainModule</span>\n      <span class=\"k\">let</span> <span class=\"n\">pkgName</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">pkgid.map</span> <span class=\"k\">fun</span> <span class=\"n\">id</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">id.getId</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">getD</span> <span class=\"n\">moduleName.head</span>\n      <span class=\"n\">dbg_trace</span> <span class=\"s2\">\"pkgName : {pkgName}\"</span>\n      <span class=\"n\">pkglocalExtension.add</span> <span class=\"o\">{</span><span class=\"n\">pkgName</span><span class=\"o\">,</span> <span class=\"n\">declName</span><span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">### `pkg_include` command</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">pkg_include</span><span class=\"o\">)</span> <span class=\"s2\">\"pkg_include \"</span> <span class=\"o\">(</span><span class=\"s2\">\"(\"</span> <span class=\"bp\">&amp;</span><span class=\"s2\">\"pkg\"</span> <span class=\"s2\">\" := \"</span> <span class=\"n\">ident</span> <span class=\"s2\">\")\"</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"n\">ident</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">pkg_include_all</span><span class=\"o\">)</span> <span class=\"s2\">\"pkg_include \"</span> <span class=\"o\">(</span><span class=\"s2\">\"(\"</span> <span class=\"bp\">&amp;</span><span class=\"s2\">\"pkg\"</span> <span class=\"s2\">\" := \"</span> <span class=\"n\">ident</span> <span class=\"s2\">\")\"</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"s2\">\" * \"</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n\n<span class=\"kd\">@[inline]</span> <span class=\"kd\">def</span> <span class=\"n\">getPkgLocalDecls</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadEnv</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">pkgName</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">PkgLocalDecl</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">declsAll</span> <span class=\"o\">:=</span> <span class=\"n\">pkglocalExtension.getState</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span>\n  <span class=\"n\">bif</span> <span class=\"n\">pkgName</span> <span class=\"bp\">==</span> <span class=\"bp\">.</span><span class=\"n\">anonymous</span> <span class=\"k\">then</span>\n    <span class=\"n\">return</span> <span class=\"n\">declsAll.toArray</span>\n  <span class=\"k\">else</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">decls</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">PkgLocalDecl</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n    <span class=\"n\">for</span> <span class=\"n\">d</span> <span class=\"k\">in</span> <span class=\"n\">declsAll</span> <span class=\"k\">do</span>\n      <span class=\"k\">if</span> <span class=\"n\">d.pkgName</span> <span class=\"bp\">=</span> <span class=\"n\">pkgName</span> <span class=\"k\">then</span> <span class=\"n\">decls</span> <span class=\"o\">:=</span> <span class=\"n\">decls.push</span> <span class=\"n\">d</span>\n    <span class=\"n\">return</span> <span class=\"n\">decls</span>\n\n<span class=\"sd\">/-- Construct `Lean.Declaration` from `PkgLocalDecl` -/</span>\n<span class=\"kd\">@[inline]</span> <span class=\"kd\">def</span> <span class=\"n\">makeDecl</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadEnv</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadError</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">pkgdecl</span> <span class=\"o\">:</span> <span class=\"n\">PkgLocalDecl</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">Declaration</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">cinfo</span> <span class=\"bp\">←</span> <span class=\"n\">getConstInfo</span> <span class=\"n\">pkgdecl.declName</span>\n  <span class=\"k\">let</span> <span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">Name</span> <span class=\"o\">:=</span>\n    <span class=\"n\">mkPrivateName</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">privateToUserName</span><span class=\"bp\">?</span> <span class=\"n\">pkgdecl.declName</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getD</span> <span class=\"n\">pkgdecl.declName</span><span class=\"o\">)</span>\n  <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"n\">name</span> <span class=\"k\">then</span>\n    <span class=\"n\">throwError</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"'{name}' has already been declared\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">constval</span> <span class=\"o\">:</span> <span class=\"n\">ConstantVal</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">name</span><span class=\"o\">,</span>\n    <span class=\"n\">levelParams</span> <span class=\"o\">:=</span> <span class=\"n\">cinfo.levelParams</span><span class=\"o\">,</span>\n    <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"n\">cinfo.type</span>\n  <span class=\"o\">}</span>\n  <span class=\"k\">match</span> <span class=\"n\">cinfo</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">thmInfo</span> <span class=\"n\">tinfo</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">return</span> <span class=\"n\">Declaration.thmDecl</span> <span class=\"o\">{</span>\n      <span class=\"n\">constval</span> <span class=\"k\">with</span>\n      <span class=\"n\">value</span> <span class=\"o\">:=</span> <span class=\"n\">mkConst</span> <span class=\"n\">pkgdecl.declName</span> <span class=\"o\">(</span><span class=\"n\">tinfo.levelParams.map</span> <span class=\"n\">mkLevelParam</span><span class=\"o\">),</span>\n    <span class=\"o\">}</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">return</span> <span class=\"n\">Declaration.defnDecl</span> <span class=\"o\">{</span>\n      <span class=\"n\">constval</span> <span class=\"k\">with</span>\n      <span class=\"n\">value</span> <span class=\"o\">:=</span> <span class=\"n\">mkConst</span> <span class=\"n\">pkgdecl.declName</span> <span class=\"o\">(</span><span class=\"n\">cinfo.levelParams.map</span> <span class=\"n\">mkLevelParam</span><span class=\"o\">),</span>\n      <span class=\"n\">hints</span> <span class=\"o\">:=</span> <span class=\"n\">ReducibilityHints.abbrev</span><span class=\"o\">,</span>\n      <span class=\"n\">safety</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">cinfo.isUnsafe</span> <span class=\"k\">then</span> <span class=\"bp\">.</span><span class=\"n\">unsafe</span> <span class=\"k\">else</span> <span class=\"bp\">.</span><span class=\"n\">safe</span>\n    <span class=\"o\">}</span>\n\n<span class=\"kd\">@[command_elab «pkg_include»]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabPkgInclude</span> <span class=\"o\">:</span> <span class=\"n\">CommandElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span> <span class=\"n\">pkg_include</span> <span class=\"bp\">$</span><span class=\"o\">[(</span><span class=\"n\">pkg</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">pkgid</span><span class=\"o\">)]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"n\">ids</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">stx</span>\n    <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"invalid use of 'pkg_include' command: {stx}\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">pkgName</span> <span class=\"o\">:</span> <span class=\"n\">Name</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">pkgid.map</span> <span class=\"k\">fun</span> <span class=\"n\">id</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">id.getId</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getD</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getMainModule</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">head</span>\n  <span class=\"k\">let</span> <span class=\"n\">pkgdecls</span> <span class=\"bp\">←</span> <span class=\"n\">getPkgLocalDecls</span> <span class=\"n\">pkgName</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">decls</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">PkgLocalDecl</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n  <span class=\"n\">for</span> <span class=\"n\">id</span> <span class=\"k\">in</span> <span class=\"n\">ids.getElems</span> <span class=\"k\">do</span>\n    <span class=\"n\">dbg_trace</span> <span class=\"s2\">\"finding {id.getId} from {repr pkgdecls}\"</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">pkgdecl</span> <span class=\"o\">:=</span> <span class=\"n\">pkgdecls.find</span><span class=\"bp\">?</span> <span class=\"k\">fun</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">id.getId.isSuffixOf</span> <span class=\"n\">d.declName</span>\n      <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"local declaration not found: {id}\"</span>\n    <span class=\"n\">dbg_trace</span> <span class=\"s2\">\"{id} → {repr pkgdecl} found\"</span>\n    <span class=\"n\">decls</span> <span class=\"o\">:=</span> <span class=\"n\">decls.push</span> <span class=\"n\">pkgdecl</span>\n  <span class=\"n\">liftCoreM</span> <span class=\"k\">do</span>\n    <span class=\"n\">for</span> <span class=\"n\">decl</span> <span class=\"k\">in</span> <span class=\"n\">decls</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">decl</span> <span class=\"bp\">←</span> <span class=\"n\">makeDecl</span> <span class=\"n\">decl</span>\n      <span class=\"n\">addDecl</span> <span class=\"n\">decl</span>\n      <span class=\"n\">compileDecl</span> <span class=\"n\">decl</span>\n\n<span class=\"kd\">@[command_elab «pkg_include_all»]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabPkgIncludeAll</span> <span class=\"o\">:</span> <span class=\"n\">CommandElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span> <span class=\"n\">pkg_include</span> <span class=\"bp\">$</span><span class=\"o\">[(</span><span class=\"n\">pkg</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">pkgid</span><span class=\"o\">)]</span><span class=\"bp\">?</span> <span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">stx</span>\n    <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"invalid use of 'pkg_include' command: {stx}\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">pkgdecls</span> <span class=\"o\">:=</span> <span class=\"n\">pkglocalExtension.getState</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span>\n  <span class=\"n\">liftCoreM</span> <span class=\"k\">do</span>\n    <span class=\"n\">for</span> <span class=\"n\">pkgdecl</span> <span class=\"k\">in</span> <span class=\"n\">pkgdecls</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">decl</span> <span class=\"bp\">←</span> <span class=\"n\">makeDecl</span> <span class=\"n\">pkgdecl</span>\n      <span class=\"n\">addDecl</span> <span class=\"n\">decl</span>\n      <span class=\"n\">compileDecl</span> <span class=\"n\">decl</span>\n</code></pre></div>\n</div></div>\n<p>Expected workflow is</p>\n<ol>\n<li>Define a private def/theorem with <code>pkg_local</code> attribute:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- A.Data.List.Basic</span>\n\n<span class=\"kd\">@[pkg_local]</span>\n<span class=\"kn\">private</span> <span class=\"kd\">theorem</span> <span class=\"n\">List.foo</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x.length</span> <span class=\"bp\">=</span> <span class=\"n\">x.length</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<ol start=\"2\">\n<li>In other modules in the same project, import the declaration using <code>pkg_include</code> command:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- A.Data.MyData.Lemma</span>\n\n<span class=\"c1\">-- #print List.foo -- error before `pkg_include`</span>\n\n<span class=\"n\">pkg_include</span> <span class=\"n\">List.foo</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">List.foo</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">private theorem List.foo.{u} : {α : Type u} → (x : List α) → x.length = x.length := List.foo</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 383729366,
        "sender_full_name": "Jun Yoshida",
        "timestamp": 1691693531
    }
]