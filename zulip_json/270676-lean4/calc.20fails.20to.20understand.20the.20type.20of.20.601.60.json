[
    {
        "content": "<p>The following</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">calc</span>\n<span class=\"w\">  </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>fails with the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">invalid</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"k\">calc</span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"n\">step</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"bp\">-</span><span class=\"n\">hand</span><span class=\"w\"> </span><span class=\"n\">side</span><span class=\"w\"> </span><span class=\"n\">is</span>\n<span class=\"w\">  </span><span class=\"bp\">↑?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">358</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">previous</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"bp\">-</span><span class=\"n\">hand</span><span class=\"w\"> </span><span class=\"n\">side</span><span class=\"w\"> </span><span class=\"n\">is</span>\n<span class=\"w\">  </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>\n<p>It seems that Lean thinks the first <code>1</code> is <code>1 : Nat</code> (indeed <code>Nat.one_lt_two</code> proves the first line) and of course the <code>calc</code> block fails (one can put <code>sorry</code> at the end and the error is still there). Is this a bug? I naively assumed that, since the goal is <code>(1 : Int) &lt; 2*x</code>, Lean would be able to understand that <code>1</code> means <code>1 : Int</code>.</p>",
        "id": 499038478,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1739288501
    },
    {
        "content": "<p>I also feel like it's a bug, and that I've seen it mentioned before</p>",
        "id": 499038639,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1739288542
    },
    {
        "content": "<p>Do you know if this is specific to <code>calc</code> in some sense? (I am just checking if there is already an opened issue)</p>",
        "id": 499039129,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1739288695
    },
    {
        "content": "<p>I've seen this issue mentioned in relation to <code>calc</code>, not anywhere else</p>",
        "id": 499039238,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1739288724
    },
    {
        "content": "<p>I've opened an <a href=\"https://github.com/leanprover/lean4/issues/7035\">issue</a>.</p>",
        "id": 499040920,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1739289176
    },
    {
        "content": "<p>This is definitely covered by an existing issue</p>",
        "id": 499041478,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1739289314
    },
    {
        "content": "<p>My impression is that for some reason (which I think has been explained to me) <code>calc</code> will not unify the starting term in the calculation with the starting term it's expecting. Maybe the unification only happens after the calc block has itself been compiled?</p>",
        "id": 499042252,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739289494
    },
    {
        "content": "<p><a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/channel/113489-new-members/topic/.E2.9C.94.20Question.20on.20placeholder.20in.20calc\">#new members &gt; ✔ Question on placeholder in calc</a>  (thanks <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> )</p>",
        "id": 499042540,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1739289564
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/blob/0f1133fe69caddf47b5d3766888da929513917af/src/Lean/Elab/Calc.lean#L151-L161\">https://github.com/leanprover/lean4/blob/0f1133fe69caddf47b5d3766888da929513917af/src/Lean/Elab/Calc.lean#L151-L161</a></p>",
        "id": 499056291,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739293337
    },
    {
        "content": "<p>Ah, I see, thanks!</p>",
        "id": 499056841,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1739293504
    },
    {
        "content": "<p>It would be possible with a completely different architecture for <code>calc</code>. Sketch:</p>\n<ol>\n<li>Have a way to take syntax and extract an operation, a LHS, and a RHS. This would have to be user-extensible.</li>\n<li>Have a way to elaborate the operations themselves.</li>\n<li>Have a way to chain these operations to form the composite operation.</li>\n<li>Have a way to unify this operation with the expected type to derive the LHS and RHS of the target.</li>\n<li>Use the target LHS and RHS to insert type hints in the chain.</li>\n<li>Elaborate all the LHSs and RHSs and proofs.</li>\n<li>Assemble.</li>\n</ol>\n<p>Likely this will change the way <code>calc</code> elaborates in ways that will break existing proofs (I can't say how, but there are too many changes where it won't happen).</p>\n<p>The current method is to elaborate each step and its proof one at a time, with a heuristic that extracts the previous step's elaborated RHS to use it as a hint for the next step's first <code>_</code>. It's low-tech and makes a lot of assumptions about how relations work syntactically and term-wise, but it somehow works well enough in practice.</p>",
        "id": 499058032,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739293860
    }
]