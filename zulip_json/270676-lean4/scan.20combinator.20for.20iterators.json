[
    {
        "content": "<p>I noticed there is no Std Iterator combinator for scan (like fold but it accumulates the partial results) so [1,2,3].iter.scan (. + .) 0 |&gt;.toList  would be [0,1,3,6]. You can see this in <a href=\"https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#v:scanl\">Haskell</a>, <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.scan\">Rust</a> for example. I have an implementation that I believe works which I could package into a PR, but I had a bit of trouble precisely determining what i ought to include in the IsPlausibleStep definition, so i would appreciate some feedback/sanity checking if possible. I'm also decently new to Lean.</p>\n<p>Implementation <a href=\"https://live.lean-lang.org/#codez=HYQwtgpgzgDiDGEAEBlALgEwHQEk0QCcQ0B7AqAKAqjQIFd406DkV4RgkAKQRuAkAuJABUAnjGQB3AJTcwA4WMlJASYQLxSCQHIZXQE3A80eundAzcAHFGmRIAWhCBSRIAlsGCF5PB0gTx5JrwBmfipI+qr+jgC0kUhuEBjxSABGEOx0UMgBTuRozvhEaE4knCJOEAA2GFDOwE6FIOVIAG4NdJJ11iR0uezl5S4A5rEQAB65xTVuBHmExGReEGB1+Bg4tbmCAEIkJOVUFC4YDIVNrOzAuFAACuUg6U5J5RDoEDBIANp4s6TTfHK6AF0kF5HFw6vIAAJfAgAWW4bA4SD+oSQJhkcjR8mhLzeXCh+ThXARnGR+kxGJkZlUVwIJDeNjsXgAPkhShVVut5CDHHksC58qByuhiBAsItlvE1uCALxIAINDIqbmOOqaJCywAX5ABvOp84AChrC/AaDpIcVoFZSjay2htAC+gEvyJU8nk4a63e6PZ74N7grhYNmVPJq1V6g1CtAirA+KTM1llSoAOVGG2VvP5hEFRtF5stnJt9GQyjT0LmBEuNzuUAeTxx3A1uozBCzkfweqmTsE0Lh/x0AYTGEmhDwapAMmLLpVaDVmp1aDDmcNrfaaGsQ+m/FlLimI4XzaXIoANN54L5N+n9YuI1Ggo3L/vr22fN5Hc7J27K57az68tx++zg2DPcWyjGM4ygABrJw3n4NM73DbMxSWC1JXzJBbSLEt8jLCsPWrL06y4Bt5ybEC223QhOyQbskF7P9IOg9cR3HODp3VJBtXgq9sxNVd1wELdXGHadgIPfBXwnd93SrGtvVeX9/QY31p1jRwWQwYpkFgycLwQ5ckIlDkZXQws3xdUsflwmSCJ/IiuIfRCKIIKiaLorANLcMzXWkr85OUpB3M0qgXBoDhEA+GFihAQcwCBT5sJ+JFaNCIEuwSsh4XOJL/lRdFUQ0WwWC8D88Nkutz2JKzfJxLwaHk8Fzw07knCCNdBAAQnssic2QvNwVXCBgDTGBmGQAAeFl3IgAJbmNCaAsDQc00cbVdO45deLXXNUIagt7QdZa1oc/SfEO/1FqtbgkhEJBqzAOAkHuYAhmsGQCBm1SeQqDI0yeXInLwLECWS/Rz2I0TH1FJyDp0sBiHgNdrGqQQuEABMJqPS8s6t9ISCDwKQ9RmkVNrTFkNX/IMnNHY9rBgJ1pQAPmBHTHD+4YJAAQVPASju6rBbxI+8+efEBDpGlgkHmqaibmybFuZlmVrnCGeIkU0nJ5qmVeXY9n3PNxOdPR1DscA2ufgE2/0W5Mxium67oep6XpkWmkHe8pPpdMmsCU9dNBpun1QZsXRslyaEhl8bJt9y3Vq6sSVzXDXzy10iE9fS3FKg3Frtupx7pAR7q2epBXtLt53c9nlvY8iAA/p4PFfFqOAoj2aW8Czz/Vru284LovBlLl2YFjA5gFC4BwveSLQBiuKLIy0k4pn6LYlSjHvjIAAZHZcWJbKUXJWIBK8aW7nKNAcHup5IH1YgiiGseJ6nle54+BffhB5eosHYB14/gAwrsJ4jBMqIlJLlZKnBNynwjufS+19FiDVbA/KgEcN6wh9lleKm9P7/CBFwIIggqQonCDoFwDVIFgg2Bg7gfBzw8BkLoGQMDHCkBolqfiKdBZ6SPCeM8gk6jHgCMebaRlrRygVFpVAWUIFmDtMlfwFB0HQiwYiHBBRF7UUHICbgRD8qqDCFQihNDMTUKBu4XgPNGGhBYdKLwXBuxqM4LeTkdQCbsPyBQQag50DYA/pQCgABiCALRGjvAAIyHgAEyHgAMwAj5PkZxf4kAAGoAoyAAAxICZAzLApAt5OBoME0JDQPhRNiQkpJhAsBw1xEIEg6ACCDAKU02ggwZB5JSc01pIAYDiGAIOAARMM3J+TCnFLQBQIAA\">here</a></p>",
        "id": 563896743,
        "sender_full_name": "cmlsharp",
        "timestamp": 1765824001
    },
    {
        "content": "<p>Hi, <span class=\"user-mention\" data-user-id=\"1006649\">@cmlsharp</span>, thanks for your suggestion. I think <code>scan</code> is a welcome addition to the standard library, so I'd be happy to see a PR for this combinator.</p>\n<p>In Lean, we can only reason about code that provably terminates*, so while you can execute <code>[1,2,3].iter.scan (. + .) 0 |&gt;.toList</code>, you will not be able to prove anything about the returned list without proving that <code>[1,2,3].iter.scan (. + .) 0</code> is a finite iterator.</p>\n<p>The <code>IsPlausibleStep</code> predicate is needed for proving that your iterator is finite by providing an <code>Std.Iterators.Finite</code> instance. It should simply be as strong as possible. Proving finiteness of <code>it.scan f init</code> given that <code>it</code> is finite (and productiveness given that <code>it</code> is productive), you will usually notice if your <code>IsPlausibleStep</code> predicate is too weak. In your case, I'm optimistic that it's strong enough since you have included all the proofs from the branches done (<code>h</code>, <code>hs</code>, <code>hp</code>) in it.</p>\n<p>Before we can add <code>scan</code> to the standard library, the PR should include <code>Std.Iterators.Finite</code> and <code>Std.Iterators.Productive</code> instances for <code>scan</code> and there should be lemmas analogous to <code>Std.Data.Iterators.Lemmas.Combinators.Drop</code>, so that we have verified the basic properties of the iterator. Optionally -- and depending on how much time you are willing to invest -- you could also try implementing a generalization that takes a <em>monadic</em> accumulation function <code>scanM</code> similarly to <code>foldM</code> or <code>mapM</code>.</p>\n<p>*) slight oversimplification</p>",
        "id": 563984640,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1765873105
    },
    {
        "content": "<p>Thanks for the feedback and the explanation. I believe I have come up with <a href=\"https://live.lean-lang.org/#codez=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\">instances</a> for both Productive and Finite (taking a lot of inspiration from the existing combinators)</p>\n<p>I will package this up into a PR then. I have not yet implemented a monadic generalization, but I will attempt this as well</p>",
        "id": 564880210,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766305087
    },
    {
        "content": "<blockquote>\n<p>and there should be lemmas analogous to <code>Std.Data.Iterators.Lemmas.Combinators.Drop</code>, so that we have verified the basic properties of the iterator.</p>\n</blockquote>\n<p>to follow up slightly on this, I think one of the most natural lemmas to prove about this iterator is that it is equivalent to its 'List' version, however, the standard library does not contain List.scanl. There is List.scanl/List.scanr in Batteries however. </p>\n<p>Are there any plans to bring List.scanl into the standard library?</p>",
        "id": 564900384,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766331469
    },
    {
        "content": "<p>I think this would be a good idea. I would want parity between List/Array/Vector. I haven't reviewed the theorems for scanl available in Batteries. Are they complete? Improving these things, either in Batteries or a PR to lean4, would be welcome.</p>",
        "id": 564908616,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1766342015
    },
    {
        "content": "<p>The List implementations for scanl/scanr in Batteries are fairly complete wrt lemmas, however there is no implementation for Array.scanl/scanr. There is an implementation for List.Vector with a subset of the lemmas that exist for List.</p>\n<p>I'd love to improve the state of Lean's standard library, so if there is interest, I'll happily propose a PR that attempts to bring scan (in iterator/vector/array/list) form into Std. That said if this is more appropriate for Batteries, I can propose it there too. I'm not really sure what the general rules are about what things should go where.</p>",
        "id": 564909440,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766343050
    },
    {
        "content": "<p>I quickly reviewed the material in Batteries on <code>List.scanl</code>. It seems reasonable, I made a few improvements in <a href=\"https://github.com/leanprover-community/batteries/pull/1569\">https://github.com/leanprover-community/batteries/pull/1569</a>.</p>",
        "id": 564913860,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1766348939
    },
    {
        "content": "<p>I would be happy for this to be extended to cover <code>Array</code> and <code>Vector</code> (not Mathlib's <code>List.Vector</code>), plus iterators. It may actually make sense to initially PR to Batteries, where it's fine to work incrementally (e.g. do <code>Array</code> before <code>Vector</code>, etc). For <code>lean4</code>, I'd like to have evidence that we'll actually get complete coverage before starting to merge things. But I would like this material there, too.</p>",
        "id": 564913979,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1766349115
    },
    {
        "content": "<p>Ok, awesome! I appreciate your guidance here. I'll put together some initial PRs!</p>",
        "id": 564914201,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766349360
    },
    {
        "content": "<p>I have been looking exactly for something like this! Thanks so much for starting work on it.<br>\nConsidering the user is expected to provide the initial value anyways, I think it would be fine if the iterator doesn't yield this initial value. So,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">iter</span><span class=\"bp\">.</span><span class=\"n\">scan</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">toList</span>\n</code></pre></div>\n<p>would return [1, 3, 6] instead of [0, 1, 3, 6]<br>\nThis would remove a conditional in the <code>step</code> function, which may have a tangible impact in tight loops.</p>",
        "id": 564921939,
        "sender_full_name": "Seong-Heon Jung",
        "timestamp": 1766361084
    },
    {
        "content": "<p>I’m glad you find this useful. I’d be a little hesitant to make this modification to scan itself, because scan is a well-defined combinator with well-defined semantics elsewhere (indeed this is how Rust’s Iterator::scan works,  how Haskell’s scanl work and how Batteries’ List.scanl work). </p>\n<p>As for performance, I’d be interested in seeing benchmarks here. It’s true that there’s necessarily a branch, but it’s the type of thing the branch predictor _should_ be good at predicting (it’s false and then true forever after).</p>",
        "id": 564922211,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766361566
    },
    {
        "content": "<p>That actually makes me wonder, does lean have cold path hints?</p>",
        "id": 564922359,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766361694
    },
    {
        "content": "<p>Also, I’m not sure how good lean is at compiling chained iterator combinators into simple loops in practice, but this is also the kind of thing that an optimizing compiler should be able to hoist out of the loop via unrolling.</p>",
        "id": 564924118,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766363936
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1006649\">cmlsharp</span> <a href=\"#narrow/channel/270676-lean4/topic/scan.20combinator.20for.20iterators/near/564922211\">said</a>:</p>\n<blockquote>\n<p>I’m glad you find this useful. I’d be a little hesitant to make this modification to scan itself, because scan is a well-defined combinator with well-defined semantics elsewhere (indeed this is how Rust’s Iterator::scan works,  how Haskell’s scanl work and how Batteries’ List.scanl work). </p>\n<p>As for performance, I’d be interested in seeing benchmarks here. It’s true that there’s necessarily a branch, but it’s the type of thing the branch predictor _should_ be good at predicting (it’s false and then true forever after).</p>\n</blockquote>\n<p><a href=\"https://live.lean-lang.org/#codez=HYQwtgpgzgDiDGEAEBlALgEwHQEk0QCcQ0B7AqAKAqjQIFd406DkV4RgkAKQRuAkAuJABUAnjGQB3AJTcwA4WMlJASYQLxSCQHIZXQE3A80eundAzcAHFGmRIAWhCBSRIAlsGCF5PB0gTx5JrwBmfipI+qr+FC4YDGhOAG6s7MC4UAAKADYgdFBOAEbpEOgQMEgA2niExGRIfHK6ALpejlxOaPIAAhUEALLcbBw1SHVIJjJyo/JdRSVcnfg9fUmDwxPjMmaqqQQkJTZ2XgA+SCJOEOkYAHIQAB5t/E2OSF1VBCkZWTn5hfgzgBfkrVgXPNQOl0MQIIDXIRAJfkk3mvTqOiwJzOGGcUIIeE03hkygejla2IAvEhfgBvAFAwggsH4DStazotwEAQklzMrGQ4EgUFocEAGm88F8/DZaC51J5tIhQUpwG5vPBWB83gAvrC8Y9Hjg0plsnkCtNnG0uMjTudjdjCRKCDS+fhlcKpIckFAANZOEr3LWOZ6kV46976r5Grj/cVU21S+0Q9kwuGEBGhJHuz1MwhY3H4y1IEnkuUK6X0tCMuMs0XpzFoTQ2u3g9UqbOBvWfQ0/Y3cLCpkqE52OI4YEhuARN+YvN4tg3fYrccO16NKsuwwRdJO6GRYQfDzU+5sfKdG1pITdD+yRYA0DiIMrdIcgNFgeplP3VWqhJ8rsf+xYDN/6VYjBotgsF4e7Bm2M4Vv0yRga204wF4NAzkeFaDg8BRtGWeAJgswwVnOkZ1g6S4PGAxDwIyXCAAmETxfmQXbtlhaBSJCASZHSEgMg8Ry/GaqKVtiICCtYMCwkSAB82YYUgbgSAAgsKrLGvOioOrKEbypKqkQiqIDZjAzDIAAPEcm4QGx4JICZx4ouc2aOPmGmFjGxalhiSlljWhELvggoqhWskKfA6r2TJEDycKoWmrZlw3G0IlIAQbF9o8PFdh6PYYpowmibmkk+kgBksFZpkYOZ7HGaZ3aheSynedprmVh5WUqdKIUFc06VpglSXpCl/akiebg5WJ+U+kVlXHmVFl0tZQ3IKaW7ICJzrnpewDXqUt6gA+T7lHRLJ/nt233jJH60ZU/oADIkDsP6cH+IxjDJrJeGZARZOkaA4GAMAFJA8rEE4Q5UC462bSdu3Pgdyzvjed5osA50vgQADCJDpAUjD3bD/7PZwopvdNn3fb9/0QIDsQgxQ00XT0XZLPtl2vkMcNcEEggbKEIQTC0wAoU93AC103B8BWPAyOur2OKQq7cGSTUVgWWnSn5ilK/zaCCkEqryNBuOC+MVC010DMDEzRDfnwOBog03Ac4BqhhILfMC7zwvzKLSkS8m0vcKuZucLKmvGixsvzBQFNoug2Ao1AQA\">Here's</a> a  slightly modified impl that does not yield the initial element. I only have my windows machine at the moment, and the timing functionality (<code>IO.monoMsNow</code>) seems to be broken for windows, so I cannot provide any reliable benchmark numbers.</p>",
        "id": 564928127,
        "sender_full_name": "Seong-Heon Jung",
        "timestamp": 1766370022
    },
    {
        "content": "<p>I agree with <span class=\"user-mention\" data-user-id=\"1006649\">@cmlsharp</span> that we should use standard behaviour for scan. In Haskell there's scanl that doesn't take initial element, and it works like this:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"nf\">scanl1</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">+</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">]</span>\n</code></pre></div>\n<p>Maybe we could have this?</p>",
        "id": 564962359,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766394857
    },
    {
        "content": "<p>implementation is pretty staightforward :</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">scanl1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">scanl</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n\n<span class=\"bp\">#</span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">scanl1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">6</span><span class=\"o\">,</span><span class=\"mi\">10</span><span class=\"o\">]</span>\n<span class=\"bp\">#</span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"a\"</span><span class=\"o\">,</span><span class=\"s2\">\"b\"</span><span class=\"o\">,</span><span class=\"s2\">\"c\"</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">scanl1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"a\"</span><span class=\"o\">,</span><span class=\"s2\">\"ab\"</span><span class=\"o\">,</span><span class=\"s2\">\"abc\"</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 565005369,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1766410754
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"942100\">Alfredo Moreira-Rosa</span> <a href=\"#narrow/channel/270676-lean4/topic/scan.20combinator.20for.20iterators/near/565005369\">said</a>:</p>\n<blockquote>\n<p>implementation is pretty staightforward :</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">scanl1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">scanl</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n\n<span class=\"bp\">#</span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">scanl1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">6</span><span class=\"o\">,</span><span class=\"mi\">10</span><span class=\"o\">]</span>\n<span class=\"bp\">#</span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"a\"</span><span class=\"o\">,</span><span class=\"s2\">\"b\"</span><span class=\"o\">,</span><span class=\"s2\">\"c\"</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">scanl1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"a\"</span><span class=\"o\">,</span><span class=\"s2\">\"ab\"</span><span class=\"o\">,</span><span class=\"s2\">\"abc\"</span><span class=\"o\">]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>The discussion is about <code>scan</code> on Iterators, not lists</p>",
        "id": 565025493,
        "sender_full_name": "Seong-Heon Jung",
        "timestamp": 1766417168
    },
    {
        "content": "<p>To be fair, it evolved to extending it also for Array and Vector, and i was answering about behaviour exemple just above my comment for <code>scanl1</code> that also does not exist yet for Lists.</p>",
        "id": 565029776,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1766418620
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"1006649\">@cmlsharp</span>  <a href=\"https://live.lean-lang.org/#codez=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\">here</a> is a version that conforms to current implementation of <code>Map</code> by having <code>f</code> being part of the <code>Scan</code> signature.</p>",
        "id": 565075364,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1766440935
    },
    {
        "content": "<p>It would make the code simpler if you store <code>@IterM α m β</code> instead of <code>α</code>. You just convert back and forth between the two.</p>",
        "id": 565081743,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766446135
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"942100\">Alfredo Moreira-Rosa</span> <a href=\"#narrow/channel/270676-lean4/topic/scan.20combinator.20for.20iterators/near/565075364\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"1006649\">cmlsharp</span>  <a href=\"https://live.lean-lang.org/#codez=HYQwtgpgzgDiDGEAEBlALgEwHQEk0QCcQ0B7AqAKAqjQIFd406DkV4RgkAKQRuAkAuJABUAnjGQB3AJTcwA4WMlJASYQLxSCQHIZXQE3A80eundAzcAHFGnQDN5Z1ftUmZEgBaEIFJEgCWwYIXkeTyQEeFtggFoIpH8IDDikACMIdjooZCtvcjQffCI0bxJOEW8IABsMKB9gbwKQMqQAN3q6SVqXEjoc9jKy3wBzGIgADxyi6v8CXMJiMmCIMFr8DBwanMEAIRISMqoKXwwGAsbWdmBcKAAFMpA070SyiHQIGCQAbTwZ0im+OV0AXSQAG8bII7EgHEgTABfYJeLi1eQAAU+BAAstw2BwkL8IVCkFYZHInPJUc9XlwUXkMVwsZxcfozISkMSZODLgQSK9XO5ggAfJAlcorNbyOFeXJYXx5UBldDECBYBZLOKrREAXgJ9XSKnFXlqmiQmsAF+RA2pS4Ay+ry/AadpIZVoZZq9aa2itaGAS/JdRKJTgrjc7g8nvhXoiuFghRVcoaDRarXK0AqsKEpPzBaUKgA5EbrPWS6WEWU2xWO52it30ZDKfOo2YEC7XW5Qe6PcncY3mwsEYtJ/AWybewSojF/HSRzMYCaEPCGkAyGu+/VoQ0ms1oeNF619tpoFzTqb8TW+Sazzc97cKgA0IXgYSPBILlq3ieToRCXp9S/9TaDbdDuTcBOwoxjG569m+d5pl4ApQAA1t4rz8PmXbPher79mWqoVkg7rVrWeT1o2gYtsG7ZcJ2G7dhB/YnoQQ5ICOLIQuO8GIQes4LihK5GkgpqoQmJZ2nuB4CMefgziu4GXvgn6Lt+AbNq2IYvIBEZsWGK7QUgAoYEUyDIUuT6CTuSqLE62EarhVZfr6dbfMRSlkQBFECS+JYDvRpLUsxugyFgen+LZfqKX+KmaUgAX6VQvg0BwiDvGiRQgFOYCAh8hHfDivmAiCtgqHijjQt5XxkJiZzZX8+LMsSGhuCwwQ/iRyntg+dKOWF5LBDQqmIg+enit4Nj7oIACEbnoR5WEioie4QMA+YwMwyAADwCgFEBWDctprZFUZTvmXimsZ7k7sJ+7TS6YnWR6nqHSdk2maE90RvtV1cIkIhIC2YBwEgdzAIMLgyAQW3aV45TpPmjw5HRBB4NdlHSRhipw3dRlgMQ8D7i4VSCFwgAJhIxmVkFgPVhhJ8NoFIFpbQq535gKxrAdGcNzjeLgwN66oAHxIPdMNDBIACCd7XTYE00Yq74gPdS0sEgu0bXTO3rft/NGb6/FUWhUvnaJD5s8jJY3u+D7+CLd5evdXgW6L8A20B+05qM3Cfd93i/SA/0toDSDA/7ryg2U4MSkzZMIRTkyaBzXNGjzcvLYr63xCrq3rRpGua0dQIPXrEj2nD11G9RMkQJ+jvqZHbtfT9f0A0DMic0gwehzBfFRf4sfcwn2fy+nkWp9tA+d8gEaBWP7t197Df+03MBpvswBxcACVvEloCpel9llQy6UbylMS5aC+L2AVMIlfkZAADLbBSdKVXiTJEjEYnBMrtxlGgOC/Y8kCWsQQoC0l4rzXgfLe7wd4/ByolZKU5gDH3ymfIqw4SYEAAMI7EeIwcq2IGTVRfpwI879U6f2/r/BY80+xAL2BQVOqAzhYEyMAAASuUSBaDH4AmBCfcEkIL5cCgGcWc31hHrCQFSQgNIH74OfsxEkggORcjfl4TGaBsaiI4HgY2plLprBvEIrRUlS4ozMiqGaOQC57nTFYbUEAbx4XjsIKs6Y8IOJsrzDshjgBnhMR5NGl9RwsQ6qRNsDBEBQCgGQAA8jYY03jtF+NMmjdMAB9G8qSnEADE7FUDmmQBYDCOApjvKk6aQgbLrzgSybenC97vCyb4WoyBcR6Gun5f44o8pggKvw2EvoESUwRqgqRvlQ5cFCKkough7bEykSElq4ToBRIILEji1NxSCLEciJitIKqyIJC/Jwmy3DmXkAknWJlkx6KsnhcZbgACO5yxE6OTEXcSp5LmnQVDIQyEpZntWYWwhoFzrqfWCAcI4QDbzwCmZTJA/R5ozD6AALwGJonxlj2jpmlJyJAmTMneH3LzcU8Aig0HoIwOYvpcUkAxSI1JpKQDpCqKcg0zyjGaFeZhcy5ZEQrQANx8zrqk+oDQihlC+m8IF5ROm+hADAGAkqfD7niWIrlSS3mU29Jki5ho2U8WDuKEVYqOHzKak5MJd5lkxKsJ0/MeS3AFLkO1SZ00cllB1FUzeNSzVX2gX8dKjS1gtOYm0h8HSum8N6effpEotlGJ2T5PZeDfIEPkfcx0HLMXctLLyyyORNS2M9RAX54oAWMJlSC7ZD5wVeDJcvd0VKCAQstHivV+LgjsBZf7R0hpBB6tzWYiyFjFZCo9r9UVvQkASqlVWuVDphgIByK60p5SbJqs5UOgJXBg3NKwBIKwKZFXKtSTIDtBrDRGpAUmVepximxTQMG4FsCfVpT9fWLhQamm2lafoCNUhEE9OQVCaEghxR7vwP4SJwLAHjBTfSNNci5A8gal4FgDQ2qVt8MCqgXhD2IysHQTgoLPGDWGtmxJusy7Dr5WgcUc1OCrtheu1ofELnbu1dwSDipD3HqVV9M99Kcj7iNb6SG97zhuvzRgD1OpQUfVrp7V4bwXD/CkHdbqdBEgYbg0QzUdaJS0vxSZ3G4TjXKanQ0DK5rQqhKeEsyJtqF1eBIIkJMvg+LpP9lAcJZSHmxxIkOTUZm7xMp7ZzEiXh8yCuFZZ01s6/XkjJo5lZN5okwAKEUMmJBIAWgAFYAFEAstziAwCA6DvjFZcxKWL31tM0B835iADyYvjpNdOxL0qcOyra3zTI2Qs5GQFCMZdHd1YEpvMHG8gBOAlSYALgJvT3RG0unBzNM6ZK8FNras2Fuafoe1GAnIMAvps/6r9PCkGFVA9wDtoLBCSPRLgxDVVkNQl+UgJRSF1TBAooOzVtEuMjKe2OBZZFI4oFS7a9jLyAeo21Y6iAzqilSdKUdkgJ32HesPu+s7n76lvCUYcRg3gTiP3DZqDpl3gPXZhJs+7EjdkyKQ4cjN8gK3FPR5j6tiba0iGCIiyY9RvAouQC4QX8g/uw+o6YgJwOgl+V4nDPArbidZc4ETqFJwD1HoVQJ9ZCKkVEFRei0FViXA4rbXSglKr46kvJU274g0rcmcZeJ1bsN9yZMUxOmAVmZ3AGVW8LnwL1MmevXQzaKOLQ0CJ6d8Bvq8dZQJ5rknZO/3tMA9T0+tOwNDc+8drXSKYPlD089rh6aUP1Q8Oh9hWHOfHdw/h0EJpmOpJD+UdG9WdOl/V2C/nRljM29Cw7Iy3boBNbFnVjr1mO9lBvCOMHbYIdQ9WXamKjb4rIGxxApPu8YGE8L2n0NcgKcsSAznvpiij/HDHsz17rO5DEK8FgEgVh2839J8XqAsG+/tUfXHuUBvqAtvgnrjlAhdm8DxuTv+pTlnt0pfrGoINAQhhXm9s/pFG/qksws0tBj/r3tCv/o2s+kAZHjYIvt4h+snjAlwNGiBiSIMn1O9twEwaiNwHwA+DwDIIrhgaQExLnNMseF8o9NeDCsXPog6DJldA+MWjqIIPfk/ASMVMSFQPQqiGTBVHvtAjgFONwrQVdvwjoD+rYEYeImwbwNdFwSxCotwBQRVBLKKLUDTHwXkFQPNFOOgNgFApQBQAAMQQDNDWYACMV4AATFeAAMz/BSh5AaHYgRhIAADUkUMgAADDpDzFgKQNfN4DQH4QEfUO8CEeEVETEYQFgJjBSEICQOgAQAMFkTUbQAMDIHyJkZQbUfUXru4UgAAEQ9EZENE5F5FAA\">here</a> is a version that conforms to current implementation of <code>Map</code> by having <code>f</code> being part of the <code>Scan</code> signature.</p>\n</blockquote>\n<p>Thanks! I had made this change locally but I appreciate it nonetheless!</p>",
        "id": 565093202,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766459135
    },
    {
        "content": "<p>Well not this exact change, I still store the iterator internally</p>",
        "id": 565093226,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766459179
    },
    {
        "content": "<p>Is there a reason to store \\a instead?</p>",
        "id": 565093238,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766459201
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/270676-lean4/topic/scan.20combinator.20for.20iterators/near/564962359\">said</a>:</p>\n<blockquote>\n<p>I agree with <span class=\"user-mention silent\" data-user-id=\"1006649\">cmlsharp</span> that we should use standard behaviour for scan. In Haskell there's scanl that doesn't take initial element, and it works like this:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"nf\">scanl1</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">+</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">]</span>\n</code></pre></div>\n<p>Maybe we could have this?</p>\n</blockquote>\n<p>scanl1 (and foldl1) are useful combinations for sure (for example when your accumulator doesn’t have an identity element), though you need a little more care in designing them because of the possibility of empty structures. </p>\n<p>Haskell throws an exception which is not suitable in lean of course (I suppose you could always define a ! variant)</p>\n<p>I suppose for list and array you could have it take a proof that the structure is non-empty. For Vector just make the input Vector a (n + 1), and for Iterator I suppose you could define the combinator to implement Iterator only if the inner iterator is productive.</p>",
        "id": 565205566,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766519244
    },
    {
        "content": "<p>(Sorry, bug in the Zulip app caused message to send twice).</p>",
        "id": 565205671,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766519309
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1006649\">cmlsharp</span> <a href=\"#narrow/channel/270676-lean4/topic/scan.20combinator.20for.20iterators/near/565205566\">said</a>:</p>\n<blockquote>\n<p>scanl1 (and foldl1) are useful combinations for sure (for example when your accumulator doesn’t have an identity element), though you need a little more care in designing them because of the possibility of empty structures.</p>\n</blockquote>\n<p>I see two directions to handle this case. The first is, as you say, requiring a proof of non-emptyness of the input. The other is to place a constraint that the type of the accumulator is inhabited.</p>",
        "id": 565329370,
        "sender_full_name": "Seong-Heon Jung",
        "timestamp": 1766624043
    },
    {
        "content": "<p><code>scanl1 (+) []</code> is just <code>[]</code>. Only <code>foldl1</code> throws an exception for empty list.</p>",
        "id": 565329738,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766624439
    },
    {
        "content": "<p>To be in line with other API we could handle this like e.g. <code>List.head</code>. So, we can have foldl1, foldl1?, foldl1!, foldl1D.</p>",
        "id": 565329836,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766624616
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/270676-lean4/topic/scan.20combinator.20for.20iterators/near/565329738\">said</a>:</p>\n<blockquote>\n<p><code>scanl1 (+) []</code> is just <code>[]</code>. Only <code>foldl1</code> throws an exception for empty list.</p>\n</blockquote>\n<p>Oh right of course good point</p>",
        "id": 565333989,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766631200
    },
    {
        "content": "<p>Ok this is not the iterator combinator per se, but I've made the first work-in-progress PR towards this goal (adding scanlM, scanrM to list and scanl,scanr,scanrM,scanlM to Array). Once this is completed, I plan on doing Iterator and then maybe vector.</p>\n<p><a href=\"https://github.com/leanprover-community/batteries/pull/1581\">https://github.com/leanprover-community/batteries/pull/1581</a></p>",
        "id": 565544082,
        "sender_full_name": "cmlsharp",
        "timestamp": 1766891003
    },
    {
        "content": "<p>Iterator combinator PR (building off the above)</p>\n<p><a href=\"https://github.com/leanprover-community/batteries/pull/1585\">https://github.com/leanprover-community/batteries/pull/1585</a></p>",
        "id": 565859433,
        "sender_full_name": "cmlsharp",
        "timestamp": 1767156883
    },
    {
        "content": "<p>It's a big PR, maybe to simplify review, it could be divided into 3 distinct ones. One for List, Array, Iterator ?</p>",
        "id": 565876141,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1767171374
    },
    {
        "content": "<p>It  depends on tbe earlier <a href=\"https://github.com/leanprover-community/batteries/pull/1581\">batteries#1581</a> PR which adds the List and Array stuff. If that PR gets merged, the lines of code difference should be smaller. Is there a better way to handle PRs that depend on one another like this?</p>",
        "id": 565898686,
        "sender_full_name": "cmlsharp",
        "timestamp": 1767188593
    },
    {
        "content": "<p>I believe github has support for showing dependencies. See e.g. <a href=\"https://github.com/leanprover-community/batteries/pull/815\">https://github.com/leanprover-community/batteries/pull/815</a> (also for PRs in not-mathlib, you can prepend the name of the repo e.g. <a href=\"https://github.com/leanprover-community/batteries/pull/1581\">batteries#1581</a> instead of links)</p>",
        "id": 565899363,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1767189118
    },
    {
        "content": "<p>Thanks for both tips!</p>",
        "id": 565899548,
        "sender_full_name": "cmlsharp",
        "timestamp": 1767189272
    },
    {
        "content": "<p>Per a comment on my initial PR, I split these two PRs into 3</p>\n<ul>\n<li><a href=\"https://github.com/leanprover-community/batteries/pull/1588\">batteries#1588</a>: List.scanlM/List.scanrM</li>\n<li><a href=\"https://github.com/leanprover-community/batteries/pull/1589\">batteries#1589</a> : Array.scan{l,r,lM,rM}</li>\n<li><a href=\"https://github.com/leanprover-community/batteries/pull/1590\">batteries#1590</a>: Iter{,M}.scan{,M}</li>\n</ul>",
        "id": 565905830,
        "sender_full_name": "cmlsharp",
        "timestamp": 1767193723
    }
]