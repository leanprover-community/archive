[
    {
        "content": "<p>What is the best source to learn more about Grind? I've found this one helpful:<br>\n<a href=\"https://pr-451--lean-reference-manual-review.netlify.app/The--grind--tactic\">https://pr-451--lean-reference-manual-review.netlify.app/The--grind--tactic</a></p>\n<p>Given the name, perhaps it is inspired by Grind in PVS? <a href=\"https://pvs.csl.sri.com/doc/pvs-prover-guide.pdf\">https://pvs.csl.sri.com/doc/pvs-prover-guide.pdf</a></p>\n<p>It also seems similar to <a href=\"https://gitlab.inria.fr/fbesson/itauto\">https://gitlab.inria.fr/fbesson/itauto</a> in Rocq.<br>\nAnd I guess Isabelle may have something similar.</p>\n<p>I would expect Lean's grind to use the most modern algorithms, and I would be curious what they are.</p>",
        "id": 526381683,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1751284071
    },
    {
        "content": "<p>If you care about the actual implementation of grind the easiest way to figure out what's going on is probably to read <a href=\"https://github.com/leanprover/lean4/pulls?q=+is%3Apr+author%3Aleodemoura+is%3Aclosed+\">https://github.com/leanprover/lean4/pulls?q=+is%3Apr+author%3Aleodemoura+is%3Aclosed+</a>, there is obviously inspirations from existing literature, for example the linear integer stuff is based on <a href=\"https://leodemoura.github.io/files/cutsat.pdf\">https://leodemoura.github.io/files/cutsat.pdf</a> but it also has custom modifications to avoid having to do case splits that are not published anywhere.</p>\n<p>I don't know whether grind is related to PVS though based on the fact that Leo used to work at SRI maybe there is at least a spiritual connection.</p>\n<p>I would also reason that grind is quite obviously more capable than itauto given the fact that it can prove the provided example on which itauto fails:</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Goal</span> <span class=\"k\">forall</span> <span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">y</span> <span class=\"o\">-&gt;</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">z</span> <span class=\"o\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">z</span> <span class=\"o\">-&gt;</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">p</span><span class=\"o\">.</span>\n<span class=\"kn\">Proof</span><span class=\"o\">.</span>\n<span class=\"k\">intros</span><span class=\"o\">.</span>\n<span class=\"kn\">Fail</span> <span class=\"k\">intuition</span> <span class=\"kp\">congruence</span><span class=\"o\">.</span>\n<span class=\"kn\">Abort</span><span class=\"o\">.</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"c1\">-- works</span>\n</code></pre></div>\n<p>I don't know if Isabelle has an all-in-one tool that can keep up with grind, grind has the ability to perform case analysis, congruence closure and e matching and linear integer stuff which I'm somewhat confident sledgehammer can probably do. But on top of that it also supports reasoning in arbitrary (commutative) (semi)rings, fields and linear arithmetic. I'm not sure whether sledgehammer can do that? Maybe an Isabelle expert here can chime in on that.</p>",
        "id": 526384405,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1751284922
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> </p>\n<p>About itauto, you read that example a bit too quickly. itauto was in fact designed to solve that example.<br>\nitauto also combines with other tactics. So, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">itauto</span><span class=\"w\"> </span><span class=\"n\">ring</span>\n</code></pre></div>\n<p>would do something similar in Rocq, although I suspect Grind to be more efficient.</p>",
        "id": 526390529,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1751286808
    },
    {
        "content": "<p>How does a ring solver come into play here? A is an arbitrary type without any additional assumptions isn't it?</p>",
        "id": 526390713,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1751286866
    },
    {
        "content": "<p>Those were two separate remarks.</p>\n<ol>\n<li>itauto solves that goal.</li>\n<li>itauto ring      supports reasoning in arbitrary (commutative) (semi)rings.</li>\n</ol>",
        "id": 526391075,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1751286978
    },
    {
        "content": "<p>Does there also exist grind? that produces a term?</p>",
        "id": 526412126,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1751292678
    },
    {
        "content": "<p>There does exist a <code>grind?</code> that produces something akin to <code>simp?</code>  but nothing that directly produces a term no. Internally grind does obviously generate a term but there is little point in putting it int othe proof script</p>",
        "id": 526412380,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1751292745
    },
    {
        "content": "<p>you can use <code>show_term grind</code> to get the proof term (as with any tactic)</p>",
        "id": 526413865,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751293102
    },
    {
        "content": "<p>Ah ok, I see. show_term should suffice.</p>",
        "id": 526416348,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1751293708
    },
    {
        "content": "<p>Please don't. :-)</p>",
        "id": 526502858,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1751327994
    },
    {
        "content": "<p>Now I wonder even more how big those terms can get. I guess for context since <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> knows that I come from metamath and the big feature is complete traceability. I consider every tactic as a black box and I want to learn what it does, sometimes just so that I can port the proof.</p>\n<p>I guess this translates why I like #explode, conv and the simple tactics that much.</p>",
        "id": 526509713,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1751333289
    },
    {
        "content": "<p>I guess we all have different use cases.</p>",
        "id": 526509749,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1751333318
    },
    {
        "content": "<p>I didn't mean that what you get from <code>show_term grind</code> would be terrible: it actually produces decent proof terms quite often. Just that it's missing the point of <code>grind</code>-style automation to care what it did. :-)</p>",
        "id": 526522754,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1751344200
    },
    {
        "content": "<p>(As long as it's working...!)</p>",
        "id": 526522799,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1751344212
    },
    {
        "content": "<p>Ah I didn't mean to replace grind with the show term, I just wanted to see if there is something that can be inspected. I guess this is a question of perspective. A proof author, given a step can use grind to solve it. But for a proof reader this step is a black box. It would be easy for example to see, ah grind does a case split on n from 120 to 800 or something like that and solves each goal individually.</p>\n<p>Also is it designed to be extended. Let's say I have a decision procedure that has to look at finite amount of cases. Can I extend grind to solve goals of a specific form?</p>",
        "id": 526644147,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1751386943
    },
    {
        "content": "<blockquote>\n<p>It would be easy for example to see, ah grind does a case split on n from 120 to 800 or something like that and solves each goal individually.</p>\n</blockquote>\n<p>I don't think this is easy to see at all for non trivial proofs by inspecting the proof term</p>",
        "id": 526644291,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1751387000
    },
    {
        "content": "<p>I've tried it out </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">interval_cases</span><span class=\"w\"> </span><span class=\"n\">k</span>\n<span class=\"w\">  </span><span class=\"n\">repeat</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>works, but </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n</code></pre></div>\n<p>fails. Maybe I'm misusing it.</p>",
        "id": 526645891,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1751387563
    },
    {
        "content": "<p>It's not intended that grind can solve that problem (yet). When it does, it will not be by case-bashing, and it will equally well prove (k &lt; 2^1000) → (k^2 &lt; 2^3000).</p>",
        "id": 526836627,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1751472420
    },
    {
        "content": "<p>that sounds optimistic TBH, lean really likes to compute big numbers</p>",
        "id": 526836808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751472472
    },
    {
        "content": "<p>well, 2^1000 isn't too big to represent so maybe that's possible, but if the number was even bigger I would expect it to have issues</p>",
        "id": 526837030,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751472550
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"725717\">@metakuntyyy</span> the proof is \"obviously\"</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">revert</span>\n</code></pre></div>\n<p><span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 526837906,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751472805
    },
    {
        "content": "<p>Can someone tell me where the entry point of the grind tactic is in the code.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"s2\">\"grind\"</span><span class=\"w\"> </span><span class=\"n\">optConfig</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">&amp;</span><span class=\"s2\">\" only\"</span><span class=\"o\">)</span><span class=\"bp\">?</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"s2\">\" [\"</span><span class=\"w\"> </span><span class=\"n\">withoutPosition</span><span class=\"o\">(</span><span class=\"n\">grindParam</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"]\"</span><span class=\"o\">)</span><span class=\"bp\">?</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">&amp;</span><span class=\"s2\">\" on_failure \"</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span>\n</code></pre></div>\n<p>This code is bespoke. Am I supposed to look for a def called grind? If so, where is it defined.</p>",
        "id": 526879507,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1751490531
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Tactic/Grind.lean#L263\">https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Tactic/Grind.lean#L263</a></p>",
        "id": 526879707,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1751490623
    },
    {
        "content": "<p>Ah I see, what is the purpose of the code in Init? I couldn't understand how this is connected and what it's doing.</p>",
        "id": 526880696,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1751491133
    },
    {
        "content": "<p>It declares the syntax for people to use, the other file declares how the syntax is elaborated, this is the approach for all meta programs in Lean (though some macros allow to do both things at once)</p>",
        "id": 526880785,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1751491183
    },
    {
        "content": "<p>Ah, so Init = Syntax and Elab is where the juice is made.</p>\n<p>If I wanted to add a logging line to grind, kinda like a hello world every time I call grind. Would it work to just change the code to add a println?</p>",
        "id": 526881828,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1751491724
    },
    {
        "content": "<p>If you compile your own Lean from source with an <code>IO.println</code> line added you would see it in the info view yes, the more idiomatic way would be to use the <code>trace</code> framework that you see being used in grind (and other elaborators) all over the place. Given that you seem to have basically zero experience with meta programming though I would suggest to maybe take a look through the meta programming book before trying to do things in grind.</p>",
        "id": 526882210,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1751491820
    },
    {
        "content": "<p>The questions I ask are independent of grind. I am indeed trying to understand how to do metaprogramming. I thought adding a newline and seeing how the sauce is made would help me more.  My preferred approach is top-down. I want to understand the architecture and building step first.</p>",
        "id": 526882764,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1751492003
    }
]