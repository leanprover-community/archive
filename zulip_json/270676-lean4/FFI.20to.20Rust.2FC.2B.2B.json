[
    {
        "content": "<p>I tried to build the Rust FFI template <a href=\"https://github.com/yatima-inc/FFI.lean\">in this repo.</a> It basicly compiles the Rust functions to a static c++ library and then uses functions from that in the lean code. But for some strange reason <code>lake build</code> fails on my machine. I get the following strange error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Compiling</span> <span class=\"n\">shim.cpp</span>\n<span class=\"n\">Creating</span> <span class=\"n\">libffi.a</span>\n<span class=\"n\">Linking</span> <span class=\"n\">libffi.so</span>\n<span class=\"n\">Building</span> <span class=\"n\">FFI</span>\n<span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"bp\">&gt;</span> <span class=\"n\">LEAN_PATH</span><span class=\"bp\">=./</span><span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">lib</span> <span class=\"n\">LD_LIBRARY_PATH</span><span class=\"bp\">=/</span><span class=\"n\">home</span><span class=\"bp\">/</span><span class=\"n\">tage</span><span class=\"bp\">/.</span><span class=\"n\">elan</span><span class=\"bp\">/</span><span class=\"n\">toolchains</span><span class=\"bp\">/</span><span class=\"n\">leanprover</span><span class=\"c1\">--lean4---nightly-2022-12-08/lib:./build/lib:./build/src /home/tage/.elan/toolchains/leanprover--lean4---nightly-2022-12-08/bin/lean ./lean/./FFI.lean -R ./lean/. -o ./build/lib/FFI.olean -i ./build/lib/FFI.ilean -c ./build/ir/FFI.c --load-dynlib=libffi.so</span>\n<span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">stderr</span><span class=\"o\">:</span>\n<span class=\"n\">libc</span><span class=\"bp\">++</span><span class=\"n\">abi</span><span class=\"o\">:</span> <span class=\"n\">terminating</span> <span class=\"n\">due</span> <span class=\"n\">to</span> <span class=\"n\">uncaught</span> <span class=\"n\">exception</span> <span class=\"n\">of</span> <span class=\"n\">type</span> <span class=\"n\">lean</span><span class=\"o\">::</span><span class=\"n\">exception</span><span class=\"o\">:</span> <span class=\"n\">error</span> <span class=\"n\">loading</span> <span class=\"n\">library</span><span class=\"o\">,</span> <span class=\"bp\">./</span><span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">libffi.so</span><span class=\"o\">:</span> <span class=\"n\">undefined</span> <span class=\"n\">symbol</span><span class=\"o\">:</span> <span class=\"n\">_ZNSt8ios_base4InitD1Ev</span>\n<span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">external</span> <span class=\"n\">command</span> <span class=\"bp\">`/</span><span class=\"n\">home</span><span class=\"bp\">/</span><span class=\"n\">tage</span><span class=\"bp\">/.</span><span class=\"n\">elan</span><span class=\"bp\">/</span><span class=\"n\">toolchains</span><span class=\"bp\">/</span><span class=\"n\">leanprover</span><span class=\"c1\">--lean4---nightly-2022-12-08/bin/lean` exited with code 134</span>\n</code></pre></div>\n<p>I think the point here is the undefined symbol <code>_ZNSt8ios_base4InitD1Ev</code>. After some googling it seems that it has something to do with the linking of libc++.so.</p>\n<p>So does anyone have any experience of linking c++ libraries and what might cause the error?</p>",
        "id": 318767057,
        "sender_full_name": "Tage Johansson",
        "timestamp": 1672508752
    },
    {
        "content": "<p>Yeah, this is something we've been trying to do for a while. So far, the setup is flaky and doesn't work on all machines. There is a <code>nix</code> branch that seems to work though (I haven't tested it yet). This is highly experimental at this point, as you can see</p>",
        "id": 318768210,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1672509577
    },
    {
        "content": "<p>Is there a reason you are going over C++ instead of just using the C FFI that we already have in Lean? In theory we could auto generate all of the Lean &lt;-&gt; C FFI &lt;-&gt; Rust glue code automatically just from the types that are in Lean without dealing with C++ at all.</p>",
        "id": 318772010,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1672512343
    },
    {
        "content": "<p>Basically like <a href=\"https://github.com/rust-lang/rust-bindgen\">https://github.com/rust-lang/rust-bindgen</a> but for Lean instead (of course the tool would be written in Lean instead of Rust in order to access the <code>Environment</code>.</p>",
        "id": 318772267,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1672512544
    },
    {
        "content": "<p>Do you mean parsing Rust code in Lean?</p>",
        "id": 318772916,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1672512980
    },
    {
        "content": "<p>No. When you compile lean code and you tag a declaration with <code>@[export]</code> you can know the symbol name in advance, furthermore you can also deduce the C type of the function in advance based on our FFI. Since you can do this you can also automatically decude a Rust representation of any Lean type automatically (based on #[repr(C)], however many lean types will end up being lean_object*. For that you can define type aliases + wrapper functions to allocate and pattern match on stuff). So in theory I believe it should be possible to automatically generate a <code>.rs</code> file using a Lean program that reads some other Lean file and exposes all of the functions tagged with <code>export</code> in that Lean file to Rust + at least working representation of all Lean types defined in that file in Rust. I don't think that representation and the way you interact with it will necessarily end up being safe but it should in general be possible.</p>",
        "id": 318773514,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1672513418
    },
    {
        "content": "<p>So basically writing a bindgen that generates a Rust C FFI layer for some arbitrary Lean file automatically should be perfectly possible.</p>",
        "id": 318773575,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1672513448
    },
    {
        "content": "<p>Sorry, I still don't understand it. Suppose we have some huge Rust lib whose behavior we want to access from Lean. How would an automatically generated <code>.rs</code> file help us bridge the gap between Lean and Rust?</p>",
        "id": 318774255,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1672513956
    },
    {
        "content": "<p>We want to use access Rust programs from Lean, not the other way around</p>",
        "id": 318774917,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1672514477
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/270676-lean4/topic/FFI.20to.20Rust.2FC.2B.2B/near/318774917\">said</a>:</p>\n<blockquote>\n<p>We want to use access Rust programs from Lean, not the other way around</p>\n</blockquote>\n<p>But surely you are passing Lean objects into those rust programs so you will still need the information about Lean exposed in Rust no? Exposing the Rust types to Lean is also possible via C FFI if you want to.</p>",
        "id": 318775332,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1672514767
    },
    {
        "content": "<p>What I am confused about is, why are you taking the indirection over the C++ FFI with cxx when both Rust and Lean support C FII.</p>",
        "id": 318775599,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1672514931
    },
    {
        "content": "<p>In my mind, it's the flow of data. Lean can use code that's written in C. So does Rust. But we are trying to use code that's written in Rust from Lean</p>",
        "id": 318776792,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1672515911
    },
    {
        "content": "<p>The Lean objects that we want to pass are extremely simple, like unboxed unsigned integers and such. Writing the bindings is the easy part - we do it by hand.</p>",
        "id": 318776959,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1672516030
    },
    {
        "content": "<p>But then why is C++ (rather than C) involved?</p>",
        "id": 318777105,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672516145
    },
    {
        "content": "<p>Because that's what <a href=\"https://cxx.rs/\">https://cxx.rs/</a> provides</p>",
        "id": 318777236,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1672516264
    },
    {
        "content": "<p>... is there <a href=\"https://c.rs/\">https://c.rs/</a> ?</p>",
        "id": 318777263,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672516295
    },
    {
        "content": "<p>Unlucky.</p>",
        "id": 318777277,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672516307
    },
    {
        "content": "<p>Avoiding C++ should make everything easier.</p>",
        "id": 318777298,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672516317
    },
    {
        "content": "<p>The C ABI is in general the normal way to do FFI; I imagine it must be supported natively by Rust</p>",
        "id": 318777380,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672516375
    },
    {
        "content": "<p>It is, CXX does still use the C ABI under the hood it just hides stuff behind a C++ facade.</p>",
        "id": 318777413,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1672516414
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"544752\">@Tage Johansson</span> Okay it works now (thanks everyone!!)<br>\nThe misconception I had was that I didn't think we could call Rust code <em>from C</em>. I thought it was like Lean, which allows us to call C code from it.</p>\n<p>Here's the PR with the changes: <a href=\"https://github.com/yatima-inc/FFI.lean/pull/1\">https://github.com/yatima-inc/FFI.lean/pull/1</a><br>\nYou might as well just fetch the <code>c</code> branch</p>",
        "id": 318785395,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1672523728
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> I tried that approach, but I still get the <code>undefined symbol</code> error above. The <code>--load-dynlib</code> doesn't include all the rust library dependencies. Also how this is added to the lean runtime command is rather undocumented. I also need some way of providing the libraries in topological order which is not the default case. How can I add more runtime dynlibs to the lean command invocation by lake?</p>",
        "id": 328254404,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1676558428
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"433842\">Anders Christiansen Sørby</span> has marked this topic as unresolved.</p>",
        "id": 328254632,
        "sender_full_name": "Notification Bot",
        "timestamp": 1676558476
    },
    {
        "content": "<p>I'm trying to link lean with an advanced rust application and using lean as the main entrypoint and executable.</p>",
        "id": 328254907,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1676558535
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> Is it possible to disable the load dynlib feature in Lake? I don't think I will need this in the interpreter</p>",
        "id": 328270017,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1676561996
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"433842\">@Anders Christiansen Sørby</span> the repo had to undergo <a href=\"https://github.com/yatima-inc/RustFFI.lean/commit/2a397cbc0904e2d575862c4067b512b6cc6b65f8\">yet another change</a> in order to work when used as a dependency. This is the template: <a href=\"https://github.com/yatima-inc/RustFFI.lean\">https://github.com/yatima-inc/RustFFI.lean</a></p>",
        "id": 328307744,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1676572227
    },
    {
        "content": "<p>I based it on that repo, but it is a rust lib with no dependencies so not very representative. With dependencies you need to have all the dynlib dependencies topologically sorted or disable the --load-dynlib</p>",
        "id": 328326799,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1676578161
    },
    {
        "content": "<p>I guess I could do something similar to copy out all those libraries too</p>",
        "id": 328327010,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1676578235
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"433842\">Anders Christiansen Sørby</span> <a href=\"#narrow/stream/270676-lean4/topic/FFI.20to.20Rust.2FC.2B.2B/near/328270017\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> Is it possible to disable the load dynlib feature in Lake? I don't think I will need this in the interpreter</p>\n</blockquote>\n<p>Just turn off <code>precompileModules</code>? Oh, I guess you mean turning off loading external shared libraries during interpretation. Sadly, no that is not currently an option. It would be pretty easier to add though.</p>",
        "id": 328332133,
        "sender_full_name": "Mac Malone",
        "timestamp": 1676580284
    },
    {
        "content": "<p>One important design decision question, though, would be what should happen if a dependent package wants its dependencies dynlibs loaded but the dependency itself does not.</p>",
        "id": 328332354,
        "sender_full_name": "Mac Malone",
        "timestamp": 1676580367
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"433842\">@Anders Christiansen Sørby</span> <br>\nWhy does the external shared library not properly declare its dependencies? At least on Unix, loading a correctly linked dynlib should automatically load its dependencies.</p>",
        "id": 328336035,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1676581622
    },
    {
        "content": "<p>I suppose a simple workaround for avoiding the --load-dynlib though would be not to tell Lake about the library but add it manually to the linker flags</p>",
        "id": 328336262,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1676581695
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> Yeah, that could be a nice feature.</p>",
        "id": 328338514,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1676582535
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> So that would mean using just <code>target</code> instead of <code>externLib</code>? <br>\nThe library declares some of it's dependencies which is shown by <code>ldd</code>, but not all apparently(?). I don't know why. It is built with rust and cargo to a static lib. Copied over to the build dir. How this interpreter dynamic loading is enabled is mysterious and it would be nice to have an option. <br>\nWould love for some more work on the FFI. Maybe someone will make a full rust FFI ABI interface?</p>",
        "id": 328339944,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1676583035
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> I've tried handcrafting the link args, but I run into other problems:<br>\nUsing roughly <code>/home/anderscs/.elan/toolchains/leanprover--lean4---nightly-2023-02-06/bin/leanc -o ./build/bin/remodel ./build/ir/Main.o ./build/ir/Remodel.o -Lbuild/lib/ -Lrust/target/release/deps -lc -lc++ -lc++abi -lffi -lremodel_rust_ffi</code></p>\n<p>Which leads to some undefined references</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">/</span><span class=\"n\">nix</span><span class=\"bp\">/</span><span class=\"n\">store</span><span class=\"bp\">/</span><span class=\"n\">pnajkjw1fz03z1x27ski1qbx9n3hd4df</span><span class=\"bp\">-</span><span class=\"n\">binutils</span><span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">39</span><span class=\"bp\">/</span><span class=\"n\">bin</span><span class=\"bp\">/</span><span class=\"n\">ld</span><span class=\"o\">:</span> <span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">lib</span><span class=\"bp\">//</span><span class=\"n\">libremodel_rust_ffi.so</span><span class=\"o\">:</span> <span class=\"n\">undefined</span> <span class=\"n\">reference</span> <span class=\"n\">to</span> <span class=\"bp\">`</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">__cxx11</span><span class=\"o\">::</span><span class=\"n\">basic_string</span><span class=\"bp\">&lt;</span><span class=\"n\">char</span><span class=\"o\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">char_traits</span><span class=\"bp\">&lt;</span><span class=\"n\">char</span><span class=\"bp\">&gt;</span><span class=\"o\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">allocator</span><span class=\"bp\">&lt;</span><span class=\"n\">char</span><span class=\"bp\">&gt;</span> <span class=\"bp\">&gt;</span><span class=\"o\">::</span><span class=\"n\">_M_replace</span><span class=\"o\">(</span><span class=\"n\">unsigned</span> <span class=\"n\">long</span><span class=\"o\">,</span> <span class=\"n\">unsigned</span> <span class=\"n\">long</span><span class=\"o\">,</span> <span class=\"n\">char</span> <span class=\"n\">const</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">unsigned</span> <span class=\"n\">long</span><span class=\"o\">)</span><span class=\"bp\">'</span>\n<span class=\"bp\">/</span><span class=\"n\">nix</span><span class=\"bp\">/</span><span class=\"n\">store</span><span class=\"bp\">/</span><span class=\"n\">pnajkjw1fz03z1x27ski1qbx9n3hd4df</span><span class=\"bp\">-</span><span class=\"n\">binutils</span><span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">39</span><span class=\"bp\">/</span><span class=\"n\">bin</span><span class=\"bp\">/</span><span class=\"n\">ld</span><span class=\"o\">:</span> <span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">lib</span><span class=\"bp\">//</span><span class=\"n\">libremodel_rust_ffi.so</span><span class=\"o\">:</span> <span class=\"n\">undefined</span> <span class=\"n\">reference</span> <span class=\"n\">to</span> <span class=\"bp\">`</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">__future_base</span><span class=\"o\">::</span><span class=\"n\">_Result_base</span><span class=\"o\">::</span><span class=\"n\">_Result_base</span><span class=\"o\">()</span><span class=\"bp\">'</span>\n<span class=\"bp\">/</span><span class=\"n\">nix</span><span class=\"bp\">/</span><span class=\"n\">store</span><span class=\"bp\">/</span><span class=\"n\">pnajkjw1fz03z1x27ski1qbx9n3hd4df</span><span class=\"bp\">-</span><span class=\"n\">binutils</span><span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">39</span><span class=\"bp\">/</span><span class=\"n\">bin</span><span class=\"bp\">/</span><span class=\"n\">ld</span><span class=\"o\">:</span> <span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">lib</span><span class=\"bp\">//</span><span class=\"n\">libremodel_rust_ffi.so</span><span class=\"o\">:</span> <span class=\"n\">undefined</span> <span class=\"n\">reference</span> <span class=\"n\">to</span> <span class=\"bp\">`</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">__throw_bad_cast</span><span class=\"o\">()</span><span class=\"bp\">'</span>\n<span class=\"bp\">/</span><span class=\"n\">nix</span><span class=\"bp\">/</span><span class=\"n\">store</span><span class=\"bp\">/</span><span class=\"n\">pnajkjw1fz03z1x27ski1qbx9n3hd4df</span><span class=\"bp\">-</span><span class=\"n\">binutils</span><span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">39</span><span class=\"bp\">/</span><span class=\"n\">bin</span><span class=\"bp\">/</span><span class=\"n\">ld</span><span class=\"o\">:</span> <span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">lib</span><span class=\"bp\">//</span><span class=\"n\">libremodel_rust_ffi.so</span><span class=\"o\">:</span> <span class=\"n\">undefined</span> <span class=\"n\">reference</span> <span class=\"n\">to</span> <span class=\"bp\">`</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">__cxx11</span><span class=\"o\">::</span><span class=\"n\">basic_string</span><span class=\"bp\">&lt;</span><span class=\"n\">char</span><span class=\"o\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">char_traits</span><span class=\"bp\">&lt;</span><span class=\"n\">char</span><span class=\"bp\">&gt;</span><span class=\"o\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">allocator</span><span class=\"bp\">&lt;</span><span class=\"n\">char</span><span class=\"bp\">&gt;</span> <span class=\"bp\">&gt;</span><span class=\"o\">::</span><span class=\"bp\">~</span><span class=\"n\">basic_string</span><span class=\"o\">()</span><span class=\"bp\">'</span>\n<span class=\"bp\">/</span><span class=\"n\">nix</span><span class=\"bp\">/</span><span class=\"n\">store</span><span class=\"bp\">/</span><span class=\"n\">pnajkjw1fz03z1x27ski1qbx9n3hd4df</span><span class=\"bp\">-</span><span class=\"n\">binutils</span><span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">39</span><span class=\"bp\">/</span><span class=\"n\">bin</span><span class=\"bp\">/</span><span class=\"n\">ld</span><span class=\"o\">:</span> <span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">lib</span><span class=\"bp\">//</span><span class=\"n\">libremodel_rust_ffi.so</span><span class=\"o\">:</span> <span class=\"n\">undefined</span> <span class=\"n\">reference</span> <span class=\"n\">to</span> <span class=\"bp\">`</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">thread</span><span class=\"o\">::</span><span class=\"n\">detach</span><span class=\"o\">()</span><span class=\"bp\">'</span>\n<span class=\"bp\">/</span><span class=\"n\">nix</span><span class=\"bp\">/</span><span class=\"n\">store</span><span class=\"bp\">/</span><span class=\"n\">pnajkjw1fz03z1x27ski1qbx9n3hd4df</span><span class=\"bp\">-</span><span class=\"n\">binutils</span><span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">39</span><span class=\"bp\">/</span><span class=\"n\">bin</span><span class=\"bp\">/</span><span class=\"n\">ld</span><span class=\"o\">:</span> <span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">lib</span><span class=\"bp\">//</span><span class=\"n\">libremodel_rust_ffi.so</span><span class=\"o\">:</span> <span class=\"n\">undefined</span> <span class=\"n\">reference</span> <span class=\"n\">to</span> <span class=\"bp\">`</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">thread</span><span class=\"o\">::</span><span class=\"n\">join</span><span class=\"o\">()</span><span class=\"bp\">'</span>\n</code></pre></div>\n<p>Why are these rust symbols not linked? I suppose these are from the rust std lib and intended to be loaded at runtime?</p>",
        "id": 328418473,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1676625453
    },
    {
        "content": "<p>Ok, the answer is that I didn't link with <code>stdc++</code>and Idk why that is needed in a rust binary.</p>",
        "id": 328419035,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1676625614
    },
    {
        "content": "<p>Reading between the lines, it seems like your Rust library has Rust dependencies, and maybe some parts of those are implemented in C++?</p>",
        "id": 328421562,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676626374
    },
    {
        "content": "<p>Ok, it works now. <code>leanc -o ./build/bin/remodel ./build/ir/Main.o ./build/ir/Remodel.o -Lbuild/lib/ -lssl -lstdc++ -lffi -lremodel_rust_ffi</code><br>\nI think I can remove the <code>-lstdc++</code> too if I don't include the cxx rust dependency.</p>",
        "id": 328424269,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1676627110
    },
    {
        "content": "<p>Rust shouldn't need stdc++ normally</p>",
        "id": 328424341,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1676627133
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span>  Follow up question: How do I add the targets to extraDepTargets without causing <code>unknown identifier '_package.name'</code></p>",
        "id": 328430757,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1676628907
    },
    {
        "content": "<p>Oh, it was just adding strings not symbols</p>",
        "id": 328435404,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1676630310
    },
    {
        "content": "<p>What would be best practice for working with strings in a Rust to Lean and Lean to Rust context? Is it passing strings to <code>lean_mk_string_from_bytes(str, str_len)</code> based on the string in Rust? Just using <code>lean_mk_string(str)</code> on a null terminated C string borrowed from rust seems to cause segmentation fault.</p>",
        "id": 336481886,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1677245313
    },
    {
        "content": "<p>This causes a segmentation fault. Do I perhaps need to run <code>lean_inc(ns)</code>? <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> ?</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">rust_test</span><span class=\"p\">(</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">char</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"c1\">//char* namec = malloc();</span>\n<span class=\"w\">  </span><span class=\"n\">lean_obj_res</span><span class=\"w\"> </span><span class=\"n\">ns</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lean_mk_string</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"kt\">char</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">name_l</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lean_string_cstr</span><span class=\"p\">(</span><span class=\"n\">ns</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 336491993,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1677247793
    },
    {
        "content": "<p>I don't see how that could fail if the string is indeed null-terminated. But really there's no reason not to use <code>lean_mk_string_from_bytes</code> if you want to avoid the extra conversion</p>",
        "id": 336505841,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1677251006
    },
    {
        "content": "<p>Both of them cause segmentation fault apparently. Does lean_mk_string_from_bytes copy the string? Need to do more debugging next week.</p>",
        "id": 337899234,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1677278007
    },
    {
        "content": "<p>It does</p>",
        "id": 337960468,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1677317332
    },
    {
        "content": "<p>It causes a segmentation fault and idk why.<br>\n Given this rust code calling from inside a tokio runtime:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">CString</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">).</span><span class=\"n\">expect</span><span class=\"p\">(</span><span class=\"s\">\"CString::new failed\"</span><span class=\"p\">);</span>\n<span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">name_raw</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"p\">.</span><span class=\"n\">into_raw</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rust_test</span><span class=\"p\">(</span><span class=\"n\">name_raw</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">name_len</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"c1\">// Take back ownership and drop</span>\n<span class=\"w\">        </span><span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">CString</span>::<span class=\"n\">from_raw</span><span class=\"p\">(</span><span class=\"n\">name_raw</span><span class=\"p\">));</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>This causes a Segmentation fault in <code>0x000000000447258b in lean::utf8_strlen(char const*, unsigned long) ()</code></p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"kt\">char</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"nf\">rust_test</span><span class=\"p\">(</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">char</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">size_t</span><span class=\"w\"> </span><span class=\"n\">name_len</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"n\">lean_obj_res</span><span class=\"w\"> </span><span class=\"n\">ns</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lean_mk_string_from_bytes</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">name_len</span><span class=\"p\">);</span>\n<span class=\"c1\">//...</span>\n</code></pre></div>\n<p>I've also tried to use the rust <code>as_bytes</code> approach</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"p\">.</span><span class=\"n\">as_bytes</span><span class=\"p\">();</span>\n<span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rust_test</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">().</span><span class=\"n\">cast</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">());</span>\n\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>But this also leads to segmentation fault. Can this be due to the pointer being freed before it is passed to C? I'm pretty stuck</p>",
        "id": 338604352,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1677595254
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> Do you have some hints?</p>",
        "id": 338608451,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1677596183
    },
    {
        "content": "<p>There is some way to find out the address of a segfault in gdb, you could check what the correlation to the pointer address in Rust is. Otherwise I can't say anything on these snippets.</p>",
        "id": 338630120,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1677601251
    },
    {
        "content": "<p>gdb reports the segfault in <code>lean::utf8_strlen(char const*, unsigned long)</code>, but it seems to happen even when I set the size to 0 and the pointer should never be accessed.</p>",
        "id": 338759290,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1677655655
    },
    {
        "content": "<p>I guess my next step would be to break the error down into even smaller pieces.</p>",
        "id": 338759408,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1677655688
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> When compiling on Mac, I obtain this result:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">info</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Compiling</span><span class=\"w\"> </span><span class=\"n\">ffi</span><span class=\"bp\">.</span><span class=\"n\">c</span>\n<span class=\"n\">info</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Creating</span><span class=\"w\"> </span><span class=\"n\">libffi</span><span class=\"bp\">.</span><span class=\"n\">a</span>\n<span class=\"n\">info</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Linking</span><span class=\"w\"> </span><span class=\"n\">libffi</span><span class=\"bp\">.</span><span class=\"n\">dylib</span>\n<span class=\"n\">info</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Building</span><span class=\"w\"> </span><span class=\"n\">Main</span>\n<span class=\"n\">info</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Linking</span><span class=\"w\"> </span><span class=\"n\">ffi</span>\n<span class=\"n\">dyld</span><span class=\"o\">[</span><span class=\"mi\">67114</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"n\">Library</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">loaded</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">rpath</span><span class=\"bp\">/</span><span class=\"n\">libc</span><span class=\"bp\">++.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"n\">dylib</span>\n<span class=\"w\">  </span><span class=\"n\">Referenced</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"mi\">4</span><span class=\"n\">C4C44C3</span><span class=\"bp\">-</span><span class=\"mi\">5555</span><span class=\"bp\">-</span><span class=\"mi\">3144</span><span class=\"bp\">-</span><span class=\"n\">A162</span><span class=\"bp\">-</span><span class=\"mi\">517666152</span><span class=\"n\">A8B</span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"n\">Users</span><span class=\"bp\">/</span><span class=\"n\">chasenorman</span><span class=\"bp\">/</span><span class=\"n\">Research</span><span class=\"bp\">/</span><span class=\"n\">RustFFI</span><span class=\"bp\">.</span><span class=\"n\">lean</span><span class=\"bp\">/</span><span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">bin</span><span class=\"bp\">/</span><span class=\"n\">ffi</span>\n<span class=\"w\">  </span><span class=\"n\">Reason</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tried</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">'./</span><span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">lib</span><span class=\"bp\">/</span><span class=\"n\">libc</span><span class=\"bp\">++.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"n\">dylib'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">no</span><span class=\"w\"> </span><span class=\"n\">such</span><span class=\"w\"> </span><span class=\"n\">file</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>libc++.1.dylib is a Mac-specific library that is not anywhere in the filesystem, so it's no wonder it can't find it. I am not sure what is convincing ffi.c that it needs it. Do you have any ideas on what I should do?</p>",
        "id": 496437444,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738104648
    },
    {
        "content": "<p>Here's a maniacal manual fix:<br>\n<code>install_name_tool -change @rpath/libc++.1.dylib /usr/lib/libc++.1.dylib build/bin/ffi</code></p>",
        "id": 496438803,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738105466
    },
    {
        "content": "<p>Ugh, it's been a <em>while</em> since I've touched this. Unfortunately I can't debug it on a Mac</p>",
        "id": 496438864,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1738105510
    },
    {
        "content": "<p>Honestly, it could be lake's fault. I don't see this library mentioned anywhere explicitly</p>",
        "id": 496439160,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738105677
    },
    {
        "content": "<p>In case someone else can and wants to help, here's the repo I think Chase is talking about: <a href=\"https://github.com/argumentcomputer/RustFFI.lean\">https://github.com/argumentcomputer/RustFFI.lean</a></p>\n<p>Note: the last commit is 2 years old. Things are surely very different nowadays.</p>",
        "id": 496439381,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1738105795
    },
    {
        "content": "<p>Is there anything special you have to do to get FFI working in VSCode? I still get \"could not find native implementation of external declaration\" even though the compiled binary works</p>",
        "id": 496439448,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738105814
    },
    {
        "content": "<p>How do you make that error message pop up?</p>",
        "id": 496439659,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1738105938
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> <br>\nI open the project in VSCode and add <code>#eval addFromRust 1 2</code></p>",
        "id": 496439877,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738106077
    },
    {
        "content": "<p>Yeah the kernel can't do it because it's not implemented in Lean. The binary works because it's linked in the compilation process</p>",
        "id": 496439945,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1738106131
    },
    {
        "content": "<p>So in general, this is a dead end?</p>",
        "id": 496440050,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738106180
    },
    {
        "content": "<p>AFAIK you won't be able to <code>#eval</code> things implemented in C.</p>",
        "id": 496440424,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1738106367
    },
    {
        "content": "<p>Can tactics use code that is compiled outside of the trusted kernel? I didn't necessarily need to use #eval</p>",
        "id": 496440680,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738106513
    },
    {
        "content": "<p>Thanks so much for the really quick response, I'd probably flounder for a lot longer otherwise</p>",
        "id": 496440763,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738106544
    },
    {
        "content": "<p>Oh, I'm pretty sure tactics can use implementations accessed via FFI. You just need to figure out a serialization format so the implementations can communicate</p>",
        "id": 496440928,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1738106650
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/channel/270676-lean4/topic/FFI.20to.20Rust.2FC.2B.2B/near/496440424\">said</a>:</p>\n<blockquote>\n<p>AFAIK you won't be able to <code>#eval</code> things implemented in C.</p>\n</blockquote>\n<p>That's wrong, you just wont be able to <code>#reduce</code>, <code>#eval</code> is in no relation to the kernel.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"346696\">Chase Norman</span> <a href=\"#narrow/channel/270676-lean4/topic/FFI.20to.20Rust.2FC.2B.2B/near/496440680\">said</a>:</p>\n<blockquote>\n<p>Can tactics use code that is compiled outside of the trusted kernel? I didn't necessarily need to use #eval</p>\n</blockquote>\n<p>yes</p>",
        "id": 496440952,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1738106672
    },
    {
        "content": "<p>Ah, right. There's <code>#eval</code> and <code>#reduce</code>. I had forgotten about those two and thought <code>#eval</code> was <code>#reduce</code>. Thanks for the reminder</p>",
        "id": 496441076,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1738106762
    },
    {
        "content": "<p>Serialization was my original solution, I was looking for something a little bit more long-term. Do you have advice for how I might go about directly calling Rust code?</p>",
        "id": 496441185,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738106804
    },
    {
        "content": "<p>I've never done FFI with Rust in Lean but it seems pretty clear to me that you should be able to just let rust expose functions that conform to the C ABI and call them like you would any other C FFI function with lean_objects as parameters.</p>",
        "id": 496441363,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1738106888
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> This github repo goes to C first before Rust, so nothing out of the ordinary. Do you have a hypothesis for why the linking that works with <code>lake exe ffi</code> does not work with <code>#eval</code> in the <code>Main.lean</code>?</p>",
        "id": 496441521,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738106986
    },
    {
        "content": "<p>Lakefile for reference:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lake</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">System</span><span class=\"w\"> </span><span class=\"n\">Lake</span><span class=\"w\"> </span><span class=\"n\">DSL</span>\n\n<span class=\"n\">package</span><span class=\"w\"> </span><span class=\"n\">RustFFI</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">default_target</span><span class=\"kd\">]</span>\n<span class=\"n\">lean_exe</span><span class=\"w\"> </span><span class=\"n\">ffi</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">root</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"ss\">`Main</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ffiC</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"ffi.c\"</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ffiO</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"ffi.o\"</span>\n\n<span class=\"n\">target</span><span class=\"w\"> </span><span class=\"n\">importTarget</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pkg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Package</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FilePath</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">oFile</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pkg</span><span class=\"bp\">.</span><span class=\"n\">oleanDir</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">ffiO</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">srcJob</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inputFile</span><span class=\"w\"> </span><span class=\"n\">ffiC</span>\n<span class=\"w\">  </span><span class=\"n\">buildFileAfterDep</span><span class=\"w\"> </span><span class=\"n\">oFile</span><span class=\"w\"> </span><span class=\"n\">srcJob</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">srcFile</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">flags</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"s2\">\"-I\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getLeanIncludeDir</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toString</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">compileO</span><span class=\"w\"> </span><span class=\"n\">ffiC</span><span class=\"w\"> </span><span class=\"n\">oFile</span><span class=\"w\"> </span><span class=\"n\">srcFile</span><span class=\"w\"> </span><span class=\"n\">flags</span>\n\n<span class=\"n\">extern_lib</span><span class=\"w\"> </span><span class=\"n\">libffi</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pkg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Package</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">nameToStaticLib</span><span class=\"w\"> </span><span class=\"s2\">\"ffi\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">job</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">fetch</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">pkg</span><span class=\"bp\">.</span><span class=\"n\">target</span><span class=\"w\"> </span><span class=\"ss\">``importTarget</span>\n<span class=\"w\">  </span><span class=\"n\">buildStaticLib</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pkg</span><span class=\"bp\">.</span><span class=\"n\">libDir</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">job</span><span class=\"o\">]</span>\n\n<span class=\"n\">extern_lib</span><span class=\"w\"> </span><span class=\"n\">some_rust_lib</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pkg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Package</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">proc</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"cargo\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"s2\">\"build\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"--release\"</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"n\">cwd</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pkg</span><span class=\"bp\">.</span><span class=\"n\">dir</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">nameToStaticLib</span><span class=\"w\"> </span><span class=\"s2\">\"some_rust_lib\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">srcPath</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pkg</span><span class=\"bp\">.</span><span class=\"n\">dir</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"s2\">\"target\"</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"s2\">\"release\"</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">name</span>\n<span class=\"w\">  </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">FS</span><span class=\"bp\">.</span><span class=\"n\">createDirAll</span><span class=\"w\"> </span><span class=\"n\">pkg</span><span class=\"bp\">.</span><span class=\"n\">libDir</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">tgtPath</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pkg</span><span class=\"bp\">.</span><span class=\"n\">libDir</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">name</span>\n<span class=\"w\">  </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">FS</span><span class=\"bp\">.</span><span class=\"n\">writeBinFile</span><span class=\"w\"> </span><span class=\"n\">tgtPath</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">FS</span><span class=\"bp\">.</span><span class=\"n\">readBinFile</span><span class=\"w\"> </span><span class=\"n\">srcPath</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">tgtPath</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 496441624,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738107022
    },
    {
        "content": "<p>For a long-term solution I would personally avoid relying on the data format that Lean 4 chooses (like lean_obects as Henrik mentioned) to encode data because that might change.</p>\n<p>Instead, I would write my data to arrays of bytes following my own protocol on the Lean side, then deserialize it in Rust (following my own protocol again).</p>",
        "id": 496441675,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1738107052
    },
    {
        "content": "<p>Using JSON right now. The files are getting pretty large. I just was concerned that the extra translation and piping was adding latency. Not to mention there are weird OS-specific things like special characters cannot be sent over stdin on Windows. And pipes get broken and terminated Lean processes don't terminate the external code</p>",
        "id": 496442004,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738107233
    },
    {
        "content": "<p>But perhaps FFI is only worse as far as OS compatibility and stability goes.</p>",
        "id": 496442133,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738107292
    },
    {
        "content": "<p>Can you exploit specific patterns on your data to shrink it? It's often the case with specific problem domains.</p>\n<p>Gluing FFI code often becomes the most fragile point in the pipeline. I would spend extra time on the data format used</p>",
        "id": 496442395,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1738107460
    },
    {
        "content": "<p>I can definitely switch to custom serialization, but we are sending the entire goal state and all definitions/types recursively needed to express it. So basically we are serializing a decent percentage of the entire working memory of the Lean process.</p>",
        "id": 496442755,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738107658
    },
    {
        "content": "<p>But if we can directly call, then we can do all sorts of cool things. We can envison systems where information is sent as it is required, intermediate feedback can be sent back from the rust, visualizations can show in the infoview, etc.</p>",
        "id": 496442882,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738107723
    },
    {
        "content": "<p>So I was hoping FFI would be a qualitative change, not just a quantitative one.</p>",
        "id": 496442931,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738107747
    },
    {
        "content": "<p>Are you sending the same partial data over and over or are you updating a state with diffs?</p>",
        "id": 496442975,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1738107782
    },
    {
        "content": "<p>Right now 1 tactic call is 1 terminal command is 1 json file. Are you suggesting that I have some kind of server set up, where I have a way to check if there is one currently running and if so send information to that server?</p>",
        "id": 496443163,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738107902
    },
    {
        "content": "<p>But also ensuring that there are not multiple users at the same time</p>",
        "id": 496443237,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738107947
    },
    {
        "content": "<p>There are multiple ways to tackle this. You need to find your bottlenecks and redundancies. But the general idea is correct: manage a state in Rust so you don't need to send the same data over and over. Have the Rust state be updated with patches. You can even use a proper database like DuckDB or Polars for this. This is my suggestion</p>",
        "id": 496443676,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1738108189
    },
    {
        "content": "<p>These ideas may or may not apply, depending on the data flow of your application. Either way, looking at a more efficient data format instead of using generic JSON seems to be worth it.</p>\n<p>Also, you mentioned \"file\" a few times. I hope you're not writing things to your filesystem just to communicate with Rust. <em>That</em> would have a great potential to become a bottleneck</p>",
        "id": 496444388,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1738108559
    },
    {
        "content": "<p>While it happens to be the same data in practice, there is nothing stopping variables from changing definitions, changing names, being considered opaque, etc. How the problem is encoded is somewhat at the discretion of the serializer. I think it would take just as long to ensure that definitions and their hashes are all present on the Rust side as it would to send them over. And yes, it's done over stdio.</p>",
        "id": 496444989,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738108877
    },
    {
        "content": "<p><a href=\"https://github.com/abdoo8080/lean-cvc5/tree/main\">https://github.com/abdoo8080/lean-cvc5/tree/main</a></p>\n<p>cvc5 seems to have the same kind of situation, and they have FFI working</p>",
        "id": 496445643,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738109183
    },
    {
        "content": "<p>I use the FFI between Lean and Rust regularly. I wrote a tutorial here: <a href=\"https://leni.sh/post/240304-rust-call-lean/\">https://leni.sh/post/240304-rust-call-lean/</a></p>",
        "id": 496643191,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1738184767
    }
]