[
    {
        "content": "<p>The output of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SemiNormedGroup#doc\">docs4#SemiNormedGroup</a> is comical (wait for the help).</p>\n<p>Are these gigantic instance names (which people occasionally notice for random reasons, e.g. what just happened to me) actually a problem? If so, do we need to petition the core Lean devs to change the default instance-naming algorithm? Or is it OK to just let these 2500+ character (yes, they are now at over 2500 characters) instance names continue to pile up in mathlib?</p>",
        "id": 359958700,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684617004
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousLinearMap.instNormedSpaceContinuousLinearMapToSemiringToDivisionSemiringToSemifieldToFieldToNormedFieldIdToNonAssocSemiringContinuousLinearMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToModuleToModuleTopologicalSpaceTo_topologicalAddGroupAddCommMonoidToContinuousAddToAddGroupToSeminormedAddGroupContinuousLinearMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToModuleTopologicalSpaceTo_topologicalAddGroupAddCommMonoidToContinuousAddToAddGroupToSeminormedAddGroupModuleSmulCommClass_selfToCommMonoidToCommRingToEuclideanDomainToMulActionToMonoidWithZeroToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoidToDivisionAddCommMonoidToMulActionWithZeroContinuousConstSMulToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedRingToSeminormedCommRingToNormedCommRingToSMulToZeroToAddMonoidToSMulZeroClassToZeroToSMulWithZeroContinuousSMulToZeroToCommMonoidWithZeroToCommGroupWithZeroBoundedSMulModuleSmulCommClass_selfToMulActionToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoidToDivisionAddCommMonoidToMulActionWithZeroContinuousConstSMulToSMulToZeroToAddMonoidToSMulZeroClassToSMulWithZeroContinuousSMulBoundedSMulInstSeminormedAddCommGroupContinuousLinearMapToSemiringToDivisionSemiringToSemifieldToFieldToNormedFieldIdToNonAssocSemiringContinuousLinearMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToModuleToModuleTopologicalSpaceTo_topologicalAddGroupAddCommMonoidToContinuousAddToAddGroupToSeminormedAddGroupContinuousLinearMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToModuleTopologicalSpaceTo_topologicalAddGroupAddCommMonoidToContinuousAddToAddGroupToSeminormedAddGroupModuleSmulCommClass_selfToCommMonoidToCommRingToEuclideanDomainToMulActionToMonoidWithZeroToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoidToDivisionAddCommMonoidToMulActionWithZeroContinuousConstSMulToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedRingToSeminormedCommRingToNormedCommRingToSMulToZeroToAddMonoidToSMulZeroClassToZeroToSMulWithZeroContinuousSMulToZeroToCommMonoidWithZeroToCommGroupWithZeroBoundedSMulModuleSmulCommClass_selfToMulActionToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoidToDivisionAddCommMonoidToMulActionWithZeroContinuousConstSMulToSMulToZeroToAddMonoidToSMulZeroClassToSMulWithZeroContinuousSMulBoundedSMul#doc\">docs4#ContinuousLinearMap.instNormedSpaceContinuousLinearMapToSemiringToDivisionSemiringToSemifieldToFieldToNormedFieldIdToNonAssocSemiringContinuousLinearMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToModuleToModuleTopologicalSpaceTo_topologicalAddGroupAddCommMonoidToContinuousAddToAddGroupToSeminormedAddGroupContinuousLinearMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToModuleTopologicalSpaceTo_topologicalAddGroupAddCommMonoidToContinuousAddToAddGroupToSeminormedAddGroupModuleSmulCommClass_selfToCommMonoidToCommRingToEuclideanDomainToMulActionToMonoidWithZeroToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoidToDivisionAddCommMonoidToMulActionWithZeroContinuousConstSMulToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedRingToSeminormedCommRingToNormedCommRingToSMulToZeroToAddMonoidToSMulZeroClassToZeroToSMulWithZeroContinuousSMulToZeroToCommMonoidWithZeroToCommGroupWithZeroBoundedSMulModuleSmulCommClass_selfToMulActionToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoidToDivisionAddCommMonoidToMulActionWithZeroContinuousConstSMulToSMulToZeroToAddMonoidToSMulZeroClassToSMulWithZeroContinuousSMulBoundedSMulInstSeminormedAddCommGroupContinuousLinearMapToSemiringToDivisionSemiringToSemifieldToFieldToNormedFieldIdToNonAssocSemiringContinuousLinearMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToModuleToModuleTopologicalSpaceTo_topologicalAddGroupAddCommMonoidToContinuousAddToAddGroupToSeminormedAddGroupContinuousLinearMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToModuleTopologicalSpaceTo_topologicalAddGroupAddCommMonoidToContinuousAddToAddGroupToSeminormedAddGroupModuleSmulCommClass_selfToCommMonoidToCommRingToEuclideanDomainToMulActionToMonoidWithZeroToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoidToDivisionAddCommMonoidToMulActionWithZeroContinuousConstSMulToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedRingToSeminormedCommRingToNormedCommRingToSMulToZeroToAddMonoidToSMulZeroClassToZeroToSMulWithZeroContinuousSMulToZeroToCommMonoidWithZeroToCommGroupWithZeroBoundedSMulModuleSmulCommClass_selfToMulActionToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoidToDivisionAddCommMonoidToMulActionWithZeroContinuousConstSMulToSMulToZeroToAddMonoidToSMulZeroClassToSMulWithZeroContinuousSMulBoundedSMul</a> is an example. I'm impressed that our infrastructure deals with it just fine. They're only going to get bigger.</p>",
        "id": 359958760,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684617049
    },
    {
        "content": "<p>Oh, something that breaks is that you can never see the equations in the docs because you always get \"One or more equations did not get rendered due to their size.\"</p>",
        "id": 359959263,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684617382
    },
    {
        "content": "<p>I can't find an issue for this. Did I miss it?</p>",
        "id": 359959460,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684617516
    },
    {
        "content": "<p>Is there an alterantive naming algorithm that you would suggest?</p>",
        "id": 359960064,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1684617975
    },
    {
        "content": "<p>The Lean 3 one!</p>",
        "id": 359960117,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684618037
    },
    {
        "content": "<p>I mean, the community Lean 3 one, which was working fine for everyone (and which IIRC was modified from 3.4.1)</p>",
        "id": 359960144,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684618060
    },
    {
        "content": "<p>I think we had a discussion about this during one of the porting meetings about a month ago (maybe two). Gabriel seemed to be in favor of it, but I guess it wasn't entirely clear what exactly the algorithm would be / what the preferences are.</p>",
        "id": 359965144,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1684621664
    },
    {
        "content": "<p>I thought we more or less settled on <code>Bar.instFoo</code> for <code>instance Foo Bar</code></p>",
        "id": 359985468,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1684638684
    },
    {
        "content": "<p>see <a href=\"https://github.com/leanprover-community/mathlib4/pull/3759\">!4#3759</a></p>",
        "id": 359985681,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1684638847
    },
    {
        "content": "<p>So currently the policy is \"<code>instance : foo</code> considered harmful; please change to <code>instance instfoo : foo</code>? Are we going to make this mandatory in mathlib, e.g. lint for it? Or are we going to open an issue and petition the devs for a core change?</p>",
        "id": 360012580,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684657438
    },
    {
        "content": "<p>I suspect we don't need a core change and can just change the meaning of <code>instance</code> in mathlib</p>",
        "id": 360013609,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684657911
    },
    {
        "content": "<p>Oh -- make the naming follow the Lean 3 convention automatically? That is clearly the coolest solution!</p>",
        "id": 360013957,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684658080
    },
    {
        "content": "<p>So would it be reasonable to open an issue against mathlib suggesting this? The only reason I'm pushing it is that right now there doesn't seem to be an issue anywhere, because it's not really causing any problems, just general hilarity, and there's an easy fix (\"rename the instance manually\"). But at some point it might blow up in our faces.</p>",
        "id": 360014153,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684658184
    },
    {
        "content": "<p>Besides giving reasonable names to instances, could it also be one of these hygiene things, where you are not allowed to use the autogenerated name and, if you want to explicitly use the instance, you must give it a name?</p>",
        "id": 360014459,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684658372
    },
    {
        "content": "<p>(or even have a tactic code action that automatically fills in the correct instance name.)</p>",
        "id": 360014693,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684658513
    },
    {
        "content": "<p>Or at the very least prefix autogenerated names with an underscore to emphasize that you shouldnât be using it. But that way you still can use them, for debugging stuff etc.</p>",
        "id": 360014697,
        "sender_full_name": "Max Nowak ð",
        "timestamp": 1684658516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/ridiculous.20instance.20names/near/360013609\">said</a>:</p>\n<blockquote>\n<p>I suspect we don't need a core change and can just change the meaning of <code>instance</code> in mathlib</p>\n</blockquote>\n<p>I strongly dislike options that require globally overriding core commands, as this has a variety of knock on effects like mathport not working properly, linters and code actions not detecting the command anymore, third party processing of lean AST data getting messed up, etc.</p>",
        "id": 360017672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684659787
    },
    {
        "content": "<p>it is an option but I would consider it as a last resort</p>",
        "id": 360018058,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684659950
    },
    {
        "content": "<p>Then what is your preferred solution?</p>",
        "id": 360019186,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684660429
    },
    {
        "content": "<p>fixing the algorithm in core</p>",
        "id": 360020495,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684660960
    },
    {
        "content": "<p>I don't think anyone thinks this is desirable, we can all see the characteristics of exponential growth</p>",
        "id": 360020571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684660993
    },
    {
        "content": "<p>we just haven't been sufficiently motivated to fix it yet, since It Works Fine <span aria-label=\"tm\" class=\"emoji emoji-2122\" role=\"img\" title=\"tm\">:tm:</span></p>",
        "id": 360020723,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684661051
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/270676-lean4/topic/ridiculous.20instance.20names/near/360014459\">said</a>:</p>\n<blockquote>\n<p>Besides giving reasonable names to instances, could it also be one of these hygiene things, where you are not allowed to use the autogenerated name and, if you want to explicitly use the instance, you must give it a name?</p>\n</blockquote>\n<p>I dislike that, because that means we now need to name all the instances even though the (Lean 3) autogenerated name is usually the correct one.</p>",
        "id": 360060640,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1684676904
    },
    {
        "content": "<p>On a related note, are we supposed to #align instances names ?</p>",
        "id": 360064841,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1684678452
    },
    {
        "content": "<p>I usually align them if I add an explicit name</p>",
        "id": 360065878,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1684678835
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/ridiculous.20instance.20names/near/360017672\">said</a>:</p>\n<blockquote>\n<p>I strongly dislike options that require globally overriding core commands, as this has a variety of knock on effects like mathport not working properly, linters and code actions not detecting the command anymore, third party processing of lean AST data getting messed up, etc.</p>\n</blockquote>\n<p>I don't think any of these particular concerns would apply here.  We can override the instance naming heuristic with a macro that rewrites <code>instance : ...</code> to <code>instance sensibleName : ...</code>, which would not change the AST.  But it's still confusing if <code>instance</code> does something different if you import mathlib.</p>",
        "id": 360106106,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1684694634
    },
    {
        "content": "<p>I would also be very happy to see the change made in core!</p>",
        "id": 360161278,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684734348
    },
    {
        "content": "<p>In the meantime if you want to hunt for long names you can use:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Util.LongNames</span>\n<span class=\"bp\">#</span><span class=\"n\">long_names</span>\n</code></pre></div>\n<p>(or #long_names 1000 to only show names longer than 1000 characters).</p>",
        "id": 361195420,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1685063698
    },
    {
        "content": "<p>I was experimenting with dealing with these enormous instance names tonight, by coming up with some heuristic that names instances based on explicit arguments and types.</p>\n<p><a href=\"https://gist.github.com/kmill/e84679c5bc5d4283f20470f2330f90c7\">Here's a list of all the instances currently in mathlib</a>, using the current autogenerated names, and <a href=\"https://gist.github.com/kmill/40d0d5c1440904c7b537ba43c6b4e86f\">here's a list using the experimental heuristic</a>.</p>\n<p><a href=\"https://github.com/kmill/lean4/blob/4079991977de765553d0775be715287467e00262/src/Lean/Elab/DefView.lean#L69-L134\">Here's the naming function</a>, and I used the following to create these text files:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"print_all_instances\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">â</span> <span class=\"n\">getEnv</span>\n  <span class=\"k\">let</span> <span class=\"n\">names</span> <span class=\"o\">:=</span> <span class=\"n\">Meta.instanceExtension.getState</span> <span class=\"n\">env</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">instanceNames</span>\n  <span class=\"k\">let</span> <span class=\"n\">names</span> <span class=\"o\">:=</span> <span class=\"n\">names.foldl</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">ns</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ns.push</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n  <span class=\"k\">let</span> <span class=\"n\">names</span> <span class=\"o\">:=</span> <span class=\"n\">names.heapSort</span> <span class=\"o\">(</span><span class=\"n\">lt</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">n1</span> <span class=\"n\">n2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n1.toString.length</span> <span class=\"bp\">&gt;</span> <span class=\"n\">n2.toString.length</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">out</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"s2\">\"\"</span>\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">names.size</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">names</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n    <span class=\"n\">out</span> <span class=\"o\">:=</span> <span class=\"n\">out</span> <span class=\"bp\">++</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{n.toString.length} {names[i]!}</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span>\n  <span class=\"n\">IO.FS.writeFile</span> <span class=\"s2\">\"instances.txt\"</span> <span class=\"n\">out</span>\n\n<span class=\"n\">print_all_instances</span>\n</code></pre></div>\n<p>I only had to modify seven mathlib files to get it to compile, either to update some references to autogenerated instances or to help <code>to_additive</code> additivize a name.</p>\n<p>Named instances are mixed into both of these lists, which skews things a bit (and probably the worst names have already been renamed), but still in the new list over 98.5% have fewer than 80 characters, vs 92.2% in the old one.</p>\n<p>I haven't really spent any time evaluating the results yet to see how to improve the heuristics, or whether to use a completely different approach.</p>",
        "id": 406006425,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701766625
    },
    {
        "content": "<p>I just checked the <a href=\"https://github.com/leanprover-community/mathlib4/pull/3759\">#3759</a> example, and with this the instance comes out as <code>Seminorm.instConditionallyCompleteLatticeSeminorm</code> rather than the slightly longer <code>Seminorm.instConditionallyCompleteLatticeSeminormToSeminormedRingToSeminormedCommRingToNormedCommRingToAddGroupToSMulToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoidToDivisionAddCommMonoidToSMulZeroClassToZeroToCommMonoidWithZeroToCommGroupWithZeroToSemifieldToFieldToSMulWithZeroToMonoidWithZeroToSemiringToDivisionSemiringToMulActionWithZeroToAddCommMonoid</code>.</p>",
        "id": 406007760,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701767035
    },
    {
        "content": "<p>There are sort of conflicting goals here:</p>\n<ul>\n<li>The generated instance names should be globally unique</li>\n<li>But, if you have two of the same instance, name collision can sometimes help you detect it</li>\n<li>Short unreadable names that are guaranteed to be unique help with the first point</li>\n<li>But, it can be helpful seeing instance names in terms to figure out what's going on</li>\n</ul>\n<p>Sebastian came up with an idea of doing the simplest name possible and tagging it with the current module name to make sure it's globally unique, which would work, but in this experiment I wanted to see how far pruning the instance names could go, since the names can sometimes be valuable.</p>",
        "id": 406009046,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701767477
    },
    {
        "content": "<p>putting the module name is another way to say \"never refer to this directly\"</p>",
        "id": 406009392,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701767597
    },
    {
        "content": "<p>I'm not sold on treating global uniqueness as a requirement. It's fine if it is 95% unique because you can always rename it</p>",
        "id": 406009761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701767718
    },
    {
        "content": "<p>and you can automatically avoid collisions when the duplicate is in a dependency</p>",
        "id": 406009826,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701767743
    },
    {
        "content": "<p>Yeah, both the current name generator and the experimental one are doing that using <code>mkUnusedBaseName</code></p>",
        "id": 406010019,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701767809
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/ridiculous.20instance.20names/near/406009761\">said</a>:</p>\n<blockquote>\n<p>It's fine if it is 95% unique because you can always rename it</p>\n</blockquote>\n<p>That is just not true if both instances are outside of your control e.g. because they are part of other packages</p>",
        "id": 406011144,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1701768173
    },
    {
        "content": "<p>I was thinking of qualifying that that the names should still be reasonably scoped to the library in question, but generally the usage of constants defined in the library will ensure this</p>",
        "id": 406011882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701768414
    },
    {
        "content": "<p>In general the answer to that is to petition the upstream library to name the offending instance</p>",
        "id": 406011957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701768441
    },
    {
        "content": "<p>TBH this is a problem with the global namespace in general, not limited to instances. If I make <code>List.sort</code> in my library because it's missing from std, and you do the same thing for the same reason, then now no one can use both our libraries at the same time</p>",
        "id": 406012240,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701768537
    },
    {
        "content": "<p>Yes but let's stay at anonymous instances for this thread. If you <em>don't</em> name something, it is ridiculous that you may be forced to rename it later</p>",
        "id": 406012516,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1701768637
    },
    {
        "content": "<p>that doesn't sound ridiculous at all...? If you didn't name the thing you might need to name it later for a variety of reasons</p>",
        "id": 406012621,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701768676
    },
    {
        "content": "<p>But <em>the system giving it the wrong name</em> should never be one of these reasons</p>",
        "id": 406012812,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1701768732
    },
    {
        "content": "<p>If this was an actually anonymous and unnameable instance we would not have this problem, we could just use private / hygienic names and call it a day</p>",
        "id": 406012813,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701768732
    },
    {
        "content": "<p>but this is supposed to actually give things names a user would use</p>",
        "id": 406012860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701768749
    },
    {
        "content": "<p>and that means it comes at the cost of potential ambiguity, because any good (for humans) naming system has a reasonable amount of ambiguity</p>",
        "id": 406012977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701768795
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/ridiculous.20instance.20names/near/406012860\">said</a>:</p>\n<blockquote>\n<p>but this is supposed to actually give things names a user would use</p>\n</blockquote>\n<p>No, that is your goal. As you correctly inferred above, my goal is to give it a name that can technically be accessed for debugging and referenced in doc-gen but makes it sufficiently obvious that references to it should never be committed.</p>",
        "id": 406013317,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1701768916
    },
    {
        "content": "<p>As Scott has already and successfully removed all references to anonymous instance names in mathlib (there could be new ones of course), it doesn't seem to me like people would object to that goal</p>",
        "id": 406013547,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1701768984
    },
    {
        "content": "<p>Okay, but in that case we will need to ban anonymous instances</p>",
        "id": 406013635,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701769016
    },
    {
        "content": "<p>It's fine to refer to anonymous instances anonymously... like we're usually doing, via typeclass search</p>",
        "id": 406013743,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1701769071
    },
    {
        "content": "<p>because these instances need to be reasonably nameable and referenceable</p>",
        "id": 406013823,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701769086
    },
    {
        "content": "<p>Ok but as a library design requirement we don't know whether users will need to refer to them by name (either in projects or on zulip)</p>",
        "id": 406014084,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701769182
    },
    {
        "content": "<p>and they should have names that blend in with the rest of the library</p>",
        "id": 406014361,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701769262
    },
    {
        "content": "<p>If <code>instance</code> doesn't do this, then I want a command that does</p>",
        "id": 406014440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701769294
    },
    {
        "content": "<p>There are some examples in <code>Mathlib/CategoryTheory/Limits/Shapes/WidePullbacks.lean</code> of needing to add attributes to DecidableEq instances created via deriving handlers.</p>",
        "id": 406014644,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701769364
    },
    {
        "content": "<p>If it's in the same project that seems okay, you can still name the instance. But lessening the need to refer to instance names explicitly in general seems like a sensible goal.</p>",
        "id": 406015236,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1701769555
    },
    {
        "content": "<p>Sure, but we can do both: discourage their use but also don't make them obnoxiously bad names</p>",
        "id": 406015410,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701769612
    },
    {
        "content": "<p>That doesn't sound too far from my own stance! My proposal would have been <code>Seminorm.Â«instConditionallyCompleteLattice@Mathlib.Analysis.SeminormÂ»</code>, is that sufficiently between \"discouraging\" and \"obnoxiously bad\" for your taste?</p>",
        "id": 406020750,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1701770944
    },
    {
        "content": "<p>it's pretty bad, I can't even type that on my keyboard in zulip</p>",
        "id": 406021224,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701771061
    },
    {
        "content": "<p>I don't think the names themselves need to discourage use. The fact that they are written by robots will make them awkward enough already</p>",
        "id": 406021828,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701771200
    },
    {
        "content": "<p>Would you have typed out <code>Seminorm.instConditionallyCompleteLatticeSeminorm</code>? Or copied it from docgen, found by searching for substrings or via navigation?</p>",
        "id": 406021891,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1701771217
    },
    {
        "content": "<p>It is very difficult to predict all the ways these names get around. I have had to write private names, hygienic names, pretty much any declaration comes up in the course of debugging or discussion eventually</p>",
        "id": 406022185,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701771290
    },
    {
        "content": "<p>and you also don't control all the venues for writing text. I might be writing that on my phone while in line at the store</p>",
        "id": 406022405,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701771345
    },
    {
        "content": "<p><code>Seminorm.instConditionallyCompleteLatticeSeminorm</code> actually doesn't look that bad. Most of the characters in it are just because the human-written mathlib name itself is long</p>",
        "id": 406022790,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701771444
    },
    {
        "content": "<p>It's still not something I would write blindly in a store but copy from a docgen tab, but workflows may differ</p>",
        "id": 406023077,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1701771513
    },
    {
        "content": "<p>for sure I will copy that if I have an option</p>",
        "id": 406023140,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701771529
    },
    {
        "content": "<p>but workflows may differ</p>",
        "id": 406023275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701771564
    },
    {
        "content": "<p>oh, another weird place you might see a lean name is in latex documents / papers</p>",
        "id": 406023528,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701771632
    },
    {
        "content": "<p>it's not even that weird to be referencing an instance in such a case if you are trying to align a \"Theorem: foo is a group\"</p>",
        "id": 406023705,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701771689
    },
    {
        "content": "<p>or you are using the blueprint tool or similar and you want to link to the corresponding lean theorem, and then latex complains because of the <code>Â«</code> and you have a little latex debugging / configuration session</p>",
        "id": 406024148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701771807
    },
    {
        "content": "<p>now that I come to think about it, linkifiers are also a case where support for unusual characters is lacking. Let's test your example: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Seminorm#doc\">docs#Seminorm</a>.Â«instConditionallyCompleteLattice@Mathlib.Analysis.SeminormÂ»</p>",
        "id": 406024466,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701771899
    },
    {
        "content": "<p>oof</p>",
        "id": 406024476,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701771902
    },
    {
        "content": "<p>That's a problem we can have today with referring to syntax, we should fix that</p>",
        "id": 406024724,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1701771970
    },
    {
        "content": "<p>(we could also consider fixing that by rendering them in ascii)</p>",
        "id": 406024950,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701772026
    },
    {
        "content": "<p>writing a regex for lean names is very un-fun</p>",
        "id": 406025247,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701772094
    },
    {
        "content": "<p>it would probably help if lean used actual unicode character classes</p>",
        "id": 406025414,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701772141
    },
    {
        "content": "<p>Then it seems like we're at a standstill again regarding this issue. It should be clear by now that \"works in 95% of cases\" is not how core operates.</p>",
        "id": 406026041,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1701772335
    },
    {
        "content": "<p>This is a naming heuristic, is it not?</p>",
        "id": 406026113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701772362
    },
    {
        "content": "<p>heuristic implying that 100% correctness is not a goal</p>",
        "id": 406026175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701772386
    },
    {
        "content": "<p>I would argue that you should just not have unnamed instances under these circumstances</p>",
        "id": 406026440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701772471
    },
    {
        "content": "<p>It would rather say it is a combination of naming and hygiene. Hygiene <em>is</em> supposed to work in 100% of cases</p>",
        "id": 406026513,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1701772491
    },
    {
        "content": "<p>it works in 99.9% of cases</p>",
        "id": 406026590,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701772514
    },
    {
        "content": "<p>but for theorem names, hygienic names are always the devil</p>",
        "id": 406026830,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701772572
    },
    {
        "content": "<p><code>initialize</code> declarations are an example of hygienic names that I have genuinely never needed to call or write (although I have needed to debug them and locating them by name is hard)</p>",
        "id": 406027301,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701772705
    },
    {
        "content": "<p>but <code>deriving FromJson</code> is a example of a bad hygienic named declaration, because it's not that weird to want to talk about that function</p>",
        "id": 406027479,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701772766
    },
    {
        "content": "<p>and instances are at about the same level of badness if they are hygienic. you can avoid talking about them in most situations, but it's unreasonably difficult to deal with them when things aren't going to plan</p>",
        "id": 406027737,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701772836
    },
    {
        "content": "<p>and for the record I'm 100% on board with Kyle's new naming algorithm, it's clearly giving better results</p>",
        "id": 406029435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701773385
    },
    {
        "content": "<p>Slightly facetious alternative suggestion: if the name is longer than 80 characters cut the rest off and replace it with a hash. No one except the compiler is reading that far anyway</p>",
        "id": 406030034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701773583
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/ridiculous.20instance.20names/near/406009761\">said</a>:</p>\n<blockquote>\n<p>I'm not sold on treating global uniqueness as a requirement. It's fine if it is 95% unique because you can always rename it</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/ridiculous.20instance.20names/near/406012240\">said</a>:</p>\n<blockquote>\n<p>TBH this is a problem with the global namespace in general, not limited to instances. If I make <code>List.sort</code> in my library because it's missing from std, and you do the same thing for the same reason, then now no one can use both our libraries at the same time</p>\n</blockquote>\n<p>As I now see Kyle pointed out above, sometimes non-uniqueness of instance names is a <em>feature</em>, just as it is with regular names; it reminds you that the instance you wrote already exists elsewhere, and you didn't need to write it in the first place.</p>",
        "id": 406052767,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701781688
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/ridiculous.20instance.20names/near/406007760\">said</a>:</p>\n<blockquote>\n<p>I just checked the <a href=\"https://github.com/leanprover-community/mathlib4/pull/3759\">#3759</a> example, and with this the instance comes out as <code>Seminorm.instConditionallyCompleteLatticeSeminorm</code> rather than the slightly longer <code>Seminorm.&lt;snip&gt;</code>.</p>\n</blockquote>\n<p>Was it a deliberate choice to keep the trailing <code>Seminorm</code> here?</p>",
        "id": 406054269,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701782189
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> What about prefixing all instances names with the lake project in which they reside (e.g., <code>Mathlib.instAddGroupInt</code>). This should avoid the problem with downstream projects import two projects with overlapping instance names, but could allow a heuristic which works only 99% of the time <em>within</em> a project.</p>",
        "id": 406176192,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1701818440
    },
    {
        "content": "<p>I was going to propose essentially that as a compromise too :-)</p>\n<p>The version I was going to suggest though is <code>instAddGroupInt._Mathlib</code> (either with or without that <code>_</code>) to make sure that the instance is added into the correct namespace, in case that matters</p>",
        "id": 406177365,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701819113
    },
    {
        "content": "<p>Maybe only do that for things in the root namespace?</p>",
        "id": 406177567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701819240
    },
    {
        "content": "<p>But then you have to type it if you ever refer to it. With <code>Mathlib.</code> you could just <code>open Mathlib</code>.</p>",
        "id": 406177626,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1701819255
    },
    {
        "content": "<p>Mario, that doesn't solve Sebastian's problem that instances in different libraries should be 100% unique.</p>",
        "id": 406177670,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1701819281
    },
    {
        "content": "<p>As long as the namespaces are independent you still have this property. If they aren't independent, you have other problems</p>",
        "id": 406177740,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701819340
    },
    {
        "content": "<p>Two projects could write instances for <code>List</code></p>",
        "id": 406177819,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1701819388
    },
    {
        "content": "<p>One reason I like this idea of tagging instances with the project name is that it gives you a better idea of where an instance comes from. It's small yet still a fairly unobtrusive affordance.</p>",
        "id": 406177869,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701819432
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> Do we want to refer to autogenerated instance names in code? I also like how this discourages you a little from doing it (but not so much that you won't if you need to)</p>",
        "id": 406177903,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701819461
    },
    {
        "content": "<p>I don't like prefixing with <code>Mathlib</code> because there's no relationship between a namespace and a module, so why should it presume that <code>Mathlib</code> (or whatever the project name is) is the prefix to use?</p>",
        "id": 406178019,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701819524
    },
    {
        "content": "<p>In general I wouldn't want to refer to it in code, but as we've addressed, it does happen.</p>",
        "id": 406178032,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1701819537
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/270676-lean4/topic/ridiculous.20instance.20names/near/406177819\">said</a>:</p>\n<blockquote>\n<p>Two projects could write instances for <code>List</code></p>\n</blockquote>\n<p>If two projects write instance of the same type for <code>List</code>, then you probably want to be really sure that the instances are actually equal; having a monadic list bind in project A that reverses the list but one in project B that doesn't would be very confusing.</p>\n<p>We don't have this problem for functions, because definining a function with the same name but a different behavior is just an error.</p>",
        "id": 406178078,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701819569
    },
    {
        "content": "<p>I am very <span aria-label=\"sob\" class=\"emoji emoji-1f62d\" role=\"img\" title=\"sob\">:sob:</span> about not having <code>import Foo renaming</code> or similar to just solve these issues once and for all</p>",
        "id": 406178206,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701819644
    },
    {
        "content": "<p>... though I can't help feel this is a non issue in the case being discussed here; if two projects really define the same instance on the same type with the same name, this is a probably a strong indication that the result really belong upstream anyway</p>",
        "id": 406178262,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701819697
    },
    {
        "content": "<p>Eric, the problem isn't identical instances (of course, non-defeq instances would be problematic), the problem is naming conflicts. Those could arise for genuinely different (but not of the same type) instances with a heuristic that is only 99% effective at hygiene (without prefixing with the project name)</p>",
        "id": 406178269,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1701819703
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/270676-lean4/topic/ridiculous.20instance.20names/near/406178032\">said</a>:</p>\n<blockquote>\n<p>In general I wouldn't want to refer to it in code, but as we've addressed, it does happen.</p>\n</blockquote>\n<p>I meant more, is it something we want to do so much that we'd want to make sure we can do <code>open Mathlib</code> to make it easier?</p>",
        "id": 406178271,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701819707
    },
    {
        "content": "<p>Kyle, you're right. Probably not. So I am also fine with your suggestion.</p>",
        "id": 406178352,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1701819739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/ridiculous.20instance.20names/near/406054269\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/ridiculous.20instance.20names/near/406007760\">said</a>:</p>\n<blockquote>\n<p>I just checked the <a href=\"https://github.com/leanprover-community/mathlib4/pull/3759\">#3759</a> example, and with this the instance comes out as <code>Seminorm.instConditionallyCompleteLatticeSeminorm</code> rather than the slightly longer <code>Seminorm.&lt;snip&gt;</code>.</p>\n</blockquote>\n<p>Was it a deliberate choice to keep the trailing <code>Seminorm</code> here?</p>\n</blockquote>\n<p>No definitely not, thanks for pointing that out. Getting people to evaluate the names is why I was sharing examples <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 406178565,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701819886
    },
    {
        "content": "<p>I tweaked the heuristics a bit more, and I have it adding suffixes using the module root which (I hope?) prevents inter-project instance conflicts.</p>\n<p>Even with these <code>_mathlib</code> suffixes, now the percent of names that are less than 80 characters long has stayed about the same (it's gone from 98.5% to 98.6%). <a href=\"https://gist.github.com/kmill/b78fc3ac196ed51071106d264908aed3\">Here's a list</a> if anyone wants to take a look. Note that auto-named instances from Lean core do not yet appear with a suffix here. <a href=\"https://github.com/kmill/lean4/blob/ed3699192e0ffd7cd01a9e11d2e95902c5a06737/src/Lean/Elab/DefView.lean#L71-L171\">Here's</a> the new algorithm.</p>",
        "id": 406223830,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701837516
    },
    {
        "content": "<p>I <em>think</em> Kevin's example in his first message is currently in mathlib as the 2579 character <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/NormedSpace/OperatorNorm.html#ContinuousLinearMap.instNormedSpaceContinuousLinearMapToSemiringToDivisionSemiringToSemifieldToFieldToNormedFieldIdToNonAssocSemiringContinuousLinearMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToModuleToModuleTopologicalSpaceToTopologicalAddGroupAddCommMonoidToContinuousAddToAddGroupToSeminormedAddGroupContinuousLinearMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToModuleTopologicalSpaceToTopologicalAddGroupAddCommMonoidToContinuousAddToAddGroupToSeminormedAddGroupModuleSmulCommClass_selfToCommMonoidToCommRingToEuclideanDomainToMulActionToMonoidWithZeroToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoidToDivisionAddCommMonoidToMulActionWithZeroContinuousConstSMulToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedRingToSeminormedCommRingToNormedCommRingToSMulToZeroToAddMonoidToSMulZeroClassToZeroToSMulWithZeroContinuousSMulToZeroToCommMonoidWithZeroToCommGroupWithZeroBoundedSMulModuleSmulCommClass_selfToMulActionToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoidToDivisionAddCommMonoidToMulActionWithZeroContinuousConstSMulToSMulToZeroToAddMonoidToSMulZeroClassToSMulWithZeroContinuousSMulBoundedSMulInstSeminormedAddCommGroupContinuousLinearMapToSemiringToDivisionSemiringToSemifieldToFieldToNormedFieldIdToNonAssocSemiringContinuousLinearMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToModuleToModuleTopologicalSpaceToTopologicalAddGroupAddCommMonoidToContinuousAddToAddGroupToSeminormedAddGroupContinuousLinearMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToModuleTopologicalSpaceToTopologicalAddGroupAddCommMonoidToContinuousAddToAddGroupToSeminormedAddGroupModuleSmulCommClass_selfToCommMonoidToCommRingToEuclideanDomainToMulActionToMonoidWithZeroToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoidToDivisionAddCommMonoidToMulActionWithZeroContinuousConstSMulToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToSeminormedRingToSeminormedCommRingToNormedCommRingToSMulToZeroToAddMonoidToSMulZeroClassToZeroToSMulWithZeroContinuousSMulToZeroToCommMonoidWithZeroToCommGroupWithZeroBoundedSMulModuleSmulCommClass_selfToMulActionToZeroToNegZeroClassToSubNegZeroMonoidToSubtractionMonoidToDivisionAddCommMonoidToMulActionWithZeroContinuousConstSMulToSMulToZeroToAddMonoidToSMulZeroClassToSMulWithZeroContinuousSMulBoundedSMul\">ContinuousLinearMap.instNormedSpaceContinuousLinearMapToSemiringToDivisionSemiringToSemifieldToFieldToNormedFieldIdToNonAssocSemiringContinuousLinearMapToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToModuleToModuleTopologicalSpaceToTopologicalAddGroupAddCommMonoidToContinuousAddToAddGroupToSeminormedAddGroupContinuousLinearMapToTopologicalSpaceTo...(2117 characters omitted)...</a></p>\n<p>It's a little obscure how it comes to this, but with the heuristics in the naming experiment, this comes out as  just <code>ContinuousLinearMap.instNormedSpaceId_mathlib</code> instead. The <code>Id</code> comes from a <code>RingHom.id</code> that appears inside the <code>ContinuousLinearMap</code> notation. The heuristic drops <code>ContinuousLinearMap</code> from the instance name itself since it already appears in the namespace name.</p>",
        "id": 406224095,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701837715
    },
    {
        "content": "<p>The use of underscores reminds me: maybe we should use underscore separation instead of camel casing. I know that's not the usual advice but we can make an exception for instances, and it will help a lot with being able to mentally tokenize these identifiers</p>",
        "id": 406224456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701837945
    },
    {
        "content": "<p>although it's possible that with the new heuristic there are never enough tokens for it to matter</p>",
        "id": 406224545,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701837998
    },
    {
        "content": "<p>I also have another proposal for how to avoid the <code>_mathlib</code> in many cases: if the declaration's namespace is a type (or other declaration), and that type was declared in the current project, then the suffix is not needed. This maintains the property that declarations from different projects are distinct, because they can't both have defined the type in the namespace</p>",
        "id": 406224700,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701838112
    },
    {
        "content": "<blockquote>\n<p>This maintains the property that declarations from different projects are distinct, because they can't both have defined the type in the namespace</p>\n</blockquote>\n<p>Interesting proposal, it makes sense. I would like to propose a variant though that both uses a more precise suffix and should make it unnecessary in virtually all cases (which we should measure): we suffix the whole module name unless <em>any</em> of the declarations used in the generated instance name are from the current module. With that we should have guaranteed uniqueness again except with fringe mangling collisions like declaring an instance of the same class for both <code>N.X</code> and <code>M.X</code> or both <code>X Y</code> and <code>XY</code>.<br>\nThe reason I'm involving the full module name again is that while it's true that name collisions in the same project can be fixed easily, it is one of these language design papercuts that we really really want to avoid. Especially to beginners it must be absolutely puzzling to get a naming collision from something they haven't even named and can easily leave a sour aftertaste of the entire language.</p>",
        "id": 406276690,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1701858843
    },
    {
        "content": "<p>The aftertaste can probably be watered down significantly if the error message clearly tells that this is a naming collision and offers solutions to it, like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Try</span> <span class=\"n\">replacing</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span>\n<span class=\"k\">with</span>\n<span class=\"kd\">instance</span> <span class=\"n\">instFoo</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span>\n</code></pre></div>",
        "id": 406277532,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1701859172
    },
    {
        "content": "<p>Certainly after putting in the work to enable that but I'm not yet seeing a downside to my proposal that would fix the issue at the root compared to Mario's</p>",
        "id": 406280155,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1701860178
    },
    {
        "content": "<p>asking for it to be in the module and not the package will rule out a lot of mathlib instances</p>",
        "id": 406280231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701860213
    },
    {
        "content": "<p>That many? Neither the class nor the type nor other relevant parts are from the module?</p>",
        "id": 406280382,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1701860273
    },
    {
        "content": "<p>My impression is that Kevin's example linked above wouldn't meet the requirement</p>",
        "id": 406280534,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701860313
    },
    {
        "content": "<p>it's not that weird to have a \"diamond\" file that shows that structure <code>A</code> has property <code>B</code> if you don't want either <code>A</code> or <code>B</code> to import the other</p>",
        "id": 406280779,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701860401
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> what is the advantage of restricting to \"module\" instead of \"package\" in your proposed rule?</p>",
        "id": 406280871,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701860417
    },
    {
        "content": "<p>If you don't do that, you lose the described level of uniqueness and there is no advantage compared to Mario's proposal</p>",
        "id": 406282390,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1701860822
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/ridiculous.20instance.20names/near/406280779\">said</a>:</p>\n<blockquote>\n<p>it's not that weird to have a \"diamond\" file that shows that structure <code>A</code> has property <code>B</code> if you don't want either <code>A</code> or <code>B</code> to import the other</p>\n</blockquote>\n<p>It is a reasonable case, more than Kevin's example that apparently is a porting workaround. I would still prefer to see some data on this.</p>",
        "id": 406282780,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1701860919
    },
    {
        "content": "<p>maybe <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> can run a test?</p>",
        "id": 406282977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701860967
    },
    {
        "content": "<p>kevin's case is also not that unusual though, the right generalization is that there is a certain non-instance definition which is intended to be <code>local instance</code>'d in certain files</p>",
        "id": 406283199,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701861036
    },
    {
        "content": "<p>although I think it's not as problematic to have a module prefix on local instances</p>",
        "id": 406283296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701861075
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/270676-lean4/topic/ridiculous.20instance.20names/near/406280871\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> what is the advantage of restricting to \"module\" instead of \"package\" in your proposed rule?</p>\n</blockquote>\n<p>Is âpackageâ even a concept thatâs known to lean? Isnât it all modules somewhere in a search path? I smell a layering violation here (but might be wrong)</p>",
        "id": 406284426,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1701861505
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/ridiculous.20instance.20names/near/406276690\">said</a>:</p>\n<blockquote>\n<p>The reason I'm involving the full module name again is that while it's true that name collisions in the same project can be fixed easily, it is one of these language design papercuts that we really really want to avoid. Especially to beginners it must be absolutely puzzling to get a naming collision from something they haven't even named and can easily leave a sour aftertaste of the entire language.</p>\n</blockquote>\n<p>In my opinion, long instance names are a <strong>much</strong> larger paper cut for new users, especially if the naming conflict comes with a good error message and the instructions to name the instance. For example, you see them <em>all the time</em> in doc gen, and they take up the entire search drop down. Of course, we could fix this by removing instances from doc gen search, but that seems like a silly hack.</p>\n<p>(EDIT: the point being, I think using only the package instead of the full module is better because it results in short names.)</p>",
        "id": 406321525,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1701874189
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> I'm not sure what the right terminology is here, but it's between the full module name and the module root (the <code>A</code> in <code>A.B.C</code>). I'm not completely certain about this, but I've been under the impression that different Lake packages are not supposed to have intersecting sets of module roots.</p>",
        "id": 406339919,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701879422
    },
    {
        "content": "<p>Yes, absolutely: But thatâs a concept of lake (the build tool), as a wrapper around lean (the compiler/language). Lean itself (I believe) just sees modules, and it would be somewhat odd if lean the language has to know about how modules are grouped in packages.</p>\n<p>It may seem silly to from a userâs point of view to have such abstraction boundaries between components that to the user â rightfully â are all just âLeanâ. But such abstraction boundaries keep the complexity in check, and should not be given up easily.</p>\n<p>Saying âuse the first component of the nameâ  might be ok here, because it pragmatically in the common case together with how people (and lake) typically structure lean compilation, so Iâm not vetoing the idea, despite the abstraction leak smell.</p>\n<p>(Or maybe we have already given up on this separation of concern; I think an optimization in how lean looks up modules in the search path assumes that the first component determines which search path entry to look at. So maybe the <span aria-label=\"ship\" class=\"emoji emoji-1f6a2\" role=\"img\" title=\"ship\">:ship:</span> has <span aria-label=\"sailboat\" class=\"emoji emoji-26f5\" role=\"img\" title=\"sailboat\">:sailboat:</span>ed.)</p>",
        "id": 406352767,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1701883622
    },
    {
        "content": "<p>Lean 4 has actually assumed that the first component of module names is unique in the search path for longer than it had any package manager. Among other reasons, it allows the system to tell the user where it expected the file for <code>import A.B</code> to be if it was able to find A but not B.</p>",
        "id": 406354224,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1701884188
    },
    {
        "content": "<p>If this is a leak, it'll show up as \"the user is surprised because two modules sharing a top-level module have instances with identical autogenerated names\".</p>\n<p>But, yeah, it turns out the module root seems to be known as a \"package\" internally (independent of Lake packages I guess), and when importing the first thing on the search path that provides a package owns that package. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.SearchPath.findWithExt#doc\">docs#Lean.SearchPath.findWithExt</a></p>",
        "id": 406354351,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701884229
    },
    {
        "content": "<p>I know the idea of an environment extension to track autogenerated definitions has been kicked around. I wonder if we could generalize that idea to one that tracks provenance of autogenerated features of definitions?</p>\n<p>The simplest implementation is that the extension could associate a list of strings to a declaration, though for tooling it could be a list of some inductive type that records more interpretable information (like whether or not the declaration itself was autogenerated, and perhaps, if it was, what declaration it is associated with).</p>\n<p>For example, instances with autogenerated names could be tagged with \"<code>instance</code> command named this instance with an autogenerated name\". Then if you import two modules that happen to have declarations with the same names, the error message can report provenance. If this information is structured enough, YaÃ«l's suggestion from earlier could be implementable.</p>",
        "id": 406355181,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701884550
    },
    {
        "content": "<p>I just had an odd idea, and I'm not sure what I think about it yet. We could extend the lexical syntax for names so that they can end with the <code>â¦</code> ellipsis character. When this character is present, then Lean looks for a name with the given prefix.</p>\n<p>The pretty printer could pretty print long constants with <code>â¦</code> truncation, supplying enough characters beyond the long constant cutoff so that the truncated name uniquely determines the constant.</p>\n<p>In the documentation, long names can also be truncated. If they use this character, then the names from the documentation can still be copy/pasted.</p>\n<p>Given this, then I think there is less concern about whether a full module name is tacked onto the end of autogenerated instance names. The pretty printer could even be aware of the format of the module name trailer and try to truncate it there, even if it's not a long name.</p>",
        "id": 406363259,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701887612
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/ridiculous.20instance.20names/near/406282977\">said</a>:</p>\n<blockquote>\n<p>maybe <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> can run a test?</p>\n</blockquote>\n<p>I'm happy to run tests. Let me know if I got this right:</p>\n<ul>\n<li>Your version is \"if the declaration's namespace is itself a declaration that is declared in the current package, then the suffix is not needed\"</li>\n<li>Sebastian's version is \"if any constant whose name appears in the autogenerated name is a declaration in the current module, then the suffix is not needed\"</li>\n</ul>\n<p>Would you be want with your version to be upgraded to Sebastian's, but with \"module\" -&gt; \"package\"? I'm considering the current namespace as being one of the constants that appears in the autogenerated name.</p>",
        "id": 406364570,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701888102
    },
    {
        "content": "<p>[Did not mean to post anything]</p>",
        "id": 406389142,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1701896867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/ridiculous.20instance.20names/near/406339919\">said</a>:</p>\n<blockquote>\n<p>I'm not completely certain about this, but I've been under the impression that different Lake packages are not supposed to have intersecting sets of module roots.</p>\n</blockquote>\n<p>This is not a safe assumption. Currently, Lean does enforce this and Lake does not work around it, but Lake does not enforce it and I hoping to eventually work around Lean here to support intersecting module roots.</p>",
        "id": 406412729,
        "sender_full_name": "Mac Malone",
        "timestamp": 1701907974
    },
    {
        "content": "<p>As an aside, It is actually relatively easy for Lake to work around this -- all it has to do is organize files in the build directory such that, as far as Lean is concerned, they share the same path. (Though just removing the check in Lean core is similarly easy.)</p>",
        "id": 406413014,
        "sender_full_name": "Mac Malone",
        "timestamp": 1701908112
    },
    {
        "content": "<p>I also think this is a very important medium-term feature. It is very likely that a number of packages from the same author / organization may wish to share the same module root but be distributed as separate packages. In fact, Mathlib even may want to do something like this itself in the future to allow downloading subsets of the library.</p>",
        "id": 406413304,
        "sender_full_name": "Mac Malone",
        "timestamp": 1701908264
    },
    {
        "content": "<p>Let's say someone is using these overlay packages and there is a conflict between autogenerated names between two such packages. Whose \"fault\" is that? (In the sense of who would someone in this position feel should have gotten things right.) Is it Lean for not making unique enough names, or is it the package authors for not testing that their overlay packages can be simultaneously imported?</p>",
        "id": 406414171,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1701908676
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/ridiculous.20instance.20names/near/406178206\">said</a>:</p>\n<blockquote>\n<p>I am very <span aria-label=\"sob\" class=\"emoji emoji-1f62d\" role=\"img\" title=\"sob\">:sob:</span> about not having <code>import Foo renaming</code> or similar to just solve these issues once and for all</p>\n</blockquote>\n<p>Why can't we have this exactly? Or is it just hard to implement and we haven't managed to do it yet?</p>",
        "id": 406471723,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1701930661
    },
    {
        "content": "<p>it's baked pretty deeply into the design of lean</p>",
        "id": 406476429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701932283
    },
    {
        "content": "<p>as for whether it's worth doing anyway? That's above my pay grade, take it up with the FRO</p>",
        "id": 406476502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701932308
    },
    {
        "content": "<p>From my past expereince toying with this, one major problem was that C symbols are derived directly from the Lean name (with just some mangling to make them valid C identifiers). Thus, even with a perfect Lean-level rename, the resulting modules wouldstill not link due to a symbol clash.</p>",
        "id": 406516889,
        "sender_full_name": "Mac Malone",
        "timestamp": 1701946153
    },
    {
        "content": "<p>I think it would be good to have an issue asking about this. It is indeed very difficult to change at this point, but even more substantial changes to how <code>import</code> works are on the medium term roadmap (i.e. \"the module system\") so it would be good to keep this point \"live\".</p>",
        "id": 407114583,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1702248329
    }
]