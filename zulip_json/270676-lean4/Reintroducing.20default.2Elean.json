[
    {
        "content": "<p>I really like the notion of having a special file to collect imports (instead of <code>Foo/</code> and <code>Foo.lean</code>). Could this extend to other folders as well? E.g. there have occasionally been discussions on being able to write <code>import Mathlib.Tactic</code> to import the whole <code>Mathlib/Tactic/</code> folder. Would it make sense to also be able to have a <code>lib.lean</code> file in <code>Mathlib/Tactic/</code> to specify what gets imported when you write <code>import Mathlib.Tactic</code>?</p>",
        "id": 390895028,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1694685327
    },
    {
        "content": "<p>Oops, a moment too late</p>",
        "id": 390895072,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1694685341
    },
    {
        "content": "<p>lean 3 has <code>default.lean</code>, rust has <code>mod.rs</code>, python has <code>__init__.py</code></p>",
        "id": 390895175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694685368
    },
    {
        "content": "<p>putting the root file in the same folder is good for organization purposes</p>",
        "id": 390895232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694685391
    },
    {
        "content": "<p>Did lean3 pick favorites between <code>Foo/default.lean</code> and <code>Foo.lean</code>, or just complain that it was ambiguous? I think Python picks favorites, I have no idea about rust.</p>",
        "id": 390895317,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694685421
    },
    {
        "content": "<p>it picks favorites</p>",
        "id": 390895350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694685433
    },
    {
        "content": "<p>Why does it have to be a file even? Can't we make Lean import all context of folder <code>X</code> when we write <code>import X</code>?</p>",
        "id": 390895361,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1694685438
    },
    {
        "content": "<p>I think <code>Foo.lean</code> wins over <code>Foo/default.lean</code></p>",
        "id": 390895400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694685448
    },
    {
        "content": "<p>lean 3 was totes okay with ambiguous imports</p>",
        "id": 390895441,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694685467
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/270676-lean4/topic/Pre-RFC.3A.20lean.2Flake.20module.20resolution/near/390895361\">said</a>:</p>\n<blockquote>\n<p>Why does it have to be a file even? Can't we make Lean import all context of folder <code>X</code> when we write <code>import X</code>?</p>\n</blockquote>\n<p>I think we don’t want that sometimes; I believe it’s been discussed before but I’m not sure where</p>",
        "id": 390895523,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1694685490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Pre-RFC.3A.20lean.2Flake.20module.20resolution/near/390895441\">said</a>:</p>\n<blockquote>\n<p>lean 3 was totes okay with ambiguous imports</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/lean/blob/cce7990ea86a78bdb383e38ed7f9b5ba93c60ce0/src/util/lean_path.cpp#L178\">Looks like</a> it complains.</p>",
        "id": 390895610,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694685531
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/270676-lean4/topic/Pre-RFC.3A.20lean.2Flake.20module.20resolution/near/390895523\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/270676-lean4/topic/Pre-RFC.3A.20lean.2Flake.20module.20resolution/near/390895361\">said</a>:</p>\n<blockquote>\n<p>Why does it have to be a file even? Can't we make Lean import all context of folder <code>X</code> when we write <code>import X</code>?</p>\n</blockquote>\n<p>I think we don’t want that sometimes; I believe it’s been discussed before but I’m not sure where</p>\n</blockquote>\n<p>I mean, we don't really want that at all in mathlib because of import reduction efforts (except maybe <code>Tactic</code>), but we can always lint against it.</p>",
        "id": 390895732,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1694685588
    },
    {
        "content": "<p>14 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4/topic/Pre-RFC.3A.20lean.2Flake.20module.20resolution\">#lean4 &gt; Pre-RFC: lean/lake module resolution</a> by <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>.</p>",
        "id": 390895734,
        "sender_full_name": "Notification Bot",
        "timestamp": 1694685590
    },
    {
        "content": "<p>Another relevant point about lean module resolution: for the most part, lean only cares about resolving paths to oleans, and lake has a lot more flexibility to do whatever is convenient here inside the <code>build/</code> directory</p>",
        "id": 390896011,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694685686
    },
    {
        "content": "<p>e.g. even if there is <code>A.lean</code> and <code>B/default.lean</code> it could still normalize them to <code>build/lib/A.olean</code> and <code>build/lib/B.olean</code></p>",
        "id": 390896138,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694685733
    },
    {
        "content": "<p>The source path is only used in lean for the server to resolve go-to-def queries and similar things</p>",
        "id": 390896316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694685813
    },
    {
        "content": "<p>my 2c, i find it a little annoying to have to look through a file list for the relevant <code>lib.rs</code> or <code>mod.rs</code> or whatever in rust packages, whereas <code>Foo.lean</code> one level up I find a bit easier.</p>\n<p>plus the mental model of no distinction between resolving <code>Foo.Bar</code> and <code>Foo.Bar.Bax</code> is nice.</p>\n<p>if VSCode had a setting to alphabetize files and folders together, I'd have ~no complaints with the status quo.</p>",
        "id": 390967570,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694705615
    },
    {
        "content": "<blockquote>\n<p>if VSCode had a setting to alphabetize files and folders together, I'd have ~no complaints with the status quo.</p>\n</blockquote>\n<p>I agree this is the main obstacle; though the same complaint applies to GitHub, as that's the other main way that mathlib code is viewed</p>",
        "id": 390969396,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694706048
    },
    {
        "content": "<p>and if that's really the reason, then we should just use <code>MyModule/aaa.lean</code> instead. which, honestly, I think is a pretty great idea. it exists to be first in the list! :)</p>",
        "id": 390970649,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694706399
    },
    {
        "content": "<p>or <code>0.lean</code>, which does appear to be first in VSCode</p>",
        "id": 390971032,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694706490
    },
    {
        "content": "<p><code>_.lean</code> goes before 0, even</p>",
        "id": 390971181,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694706525
    },
    {
        "content": "<p>_ also works with lake already -- if you call a file <code>Mathlib/_.lean</code>, then <code>import Mathlib._</code> just works <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 390972141,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694706842
    },
    {
        "content": "<p>whereas it seems <code>*.lean</code> is special cased somehow</p>",
        "id": 390972205,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694706854
    },
    {
        "content": "<p>or <code>__init__.lean</code> <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span></p>",
        "id": 391004121,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694719198
    },
    {
        "content": "<p><code>import Mathlib.__init__</code> doesn't have quite the same ring to it <span aria-label=\"stuck out tongue closed eyes\" class=\"emoji emoji-1f61d\" role=\"img\" title=\"stuck out tongue closed eyes\">:stuck_out_tongue_closed_eyes:</span></p>",
        "id": 391005017,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694719629
    },
    {
        "content": "<p>you should never have to write that anyway, the whole meaning of introducing this mechanism is that you would just write <code>import Mathlib</code></p>",
        "id": 391005232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694719702
    },
    {
        "content": "<p>Sure. I'm just not convinced of the value of making the file resolution algorithm more complicated.</p>",
        "id": 391007328,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694720628
    },
    {
        "content": "<p>The mental model right now is quite clean, which I appreciate. No algorithm to learn, it just matches the file structure. If you want to be able to write <code>import Mathlib</code>, you make a file called <code>Mathlib</code>.</p>",
        "id": 391007510,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694720707
    },
    {
        "content": "<p>but then you have one file which is not inside the source tree</p>",
        "id": 391007600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694720748
    },
    {
        "content": "<p>FWIW another small benefit to Python's model is to facilitate complexity changing while preserving backwards compatibility.</p>",
        "id": 391007696,
        "sender_full_name": "Julian Berman",
        "timestamp": 1694720781
    },
    {
        "content": "<p>Specifically if you have a <code>Foo</code>, a file, and later Foo grows and needs to become a package, you have a way of not breaking everyone's imports because <code>import Foo</code> can continue to work</p>",
        "id": 391007752,
        "sender_full_name": "Julian Berman",
        "timestamp": 1694720809
    },
    {
        "content": "<p>that's true even if it's spelled <code>Foo.lean</code> instead of <code>Foo/default.lean</code> though</p>",
        "id": 391007790,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694720834
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Reintroducing.20default.2Elean/near/391007600\">said</a>:</p>\n<blockquote>\n<p>but then you have one file which is not inside the source tree</p>\n</blockquote>\n<p>I mean, I'm okay with <code>_.lean</code> too! <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> <code>import Mathlib._</code> There's no real <em>reason</em> why we feel compelled to write one-component imports except the norms from other languages, which always feels like a questionable incentive.</p>",
        "id": 391008057,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694720957
    },
    {
        "content": "<p>I think the key advantages of the <code>__init__</code> (or <code>_</code> or some other alphabetically early) proposal, as opposed to the current <code>Foo.lean</code> design, are:</p>\n<ul>\n<li>They work in tandem with Mario's other Pre-RFC</li>\n<li>They mean that <code>Foo/__init__.lean</code> appears right next to <code>Foo/Bar.lean</code> in the VSCode sidebar/github sidebar/file explorer of choice, rather than being arbitrarily far away.</li>\n</ul>",
        "id": 391008161,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694721000
    },
    {
        "content": "<p>(In reality, I'm fine with any of these, it's not worth bikeshedding about :p)</p>",
        "id": 391008553,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694721160
    },
    {
        "content": "<blockquote>\n<p>that's true even if it's spelled Foo.lean instead of Foo/default.lean though</p>\n</blockquote>\n<p>(Ah, indeed, I forgot Lean lets you have <code>Foo</code> a directory and <code>Foo.lean</code> next to each other, Python does not really.)</p>",
        "id": 391008771,
        "sender_full_name": "Julian Berman",
        "timestamp": 1694721255
    },
    {
        "content": "<p>Is there a reason why we want this to be controlled by packages instead of clients? Like, in Java-world, you write <code>import Whatever.*</code> for all importable names starting with <code>Whatever.</code>. I think Lake might already let you do that? and lake already lets you put all files in your tree into a package with a bit of lakefile magic</p>",
        "id": 391008895,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694721309
    },
    {
        "content": "<p>Only reason I have the import collection files right now is because it's the current norm. If we all switched to writing <code>import Mathlib.*</code> and not having these files, I'd be fine with that</p>",
        "id": 391009076,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694721380
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Reintroducing.20default.2Elean/near/390895175\">said</a>:</p>\n<blockquote>\n<p>lean 3 has <code>default.lean</code>, rust has <code>mod.rs</code>, python has <code>__init__.py</code></p>\n</blockquote>\n<p>Lean 4 specifically follows Rust's new model introduced in their module system cleanup <a href=\"https://doc.rust-lang.org/edition-guide/rust-2018/path-changes.html#no-more-modrs\">https://doc.rust-lang.org/edition-guide/rust-2018/path-changes.html#no-more-modrs</a></p>",
        "id": 391009224,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1694721459
    },
    {
        "content": "<p>This is similar to Haskell as well, right?</p>",
        "id": 391010532,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1694721985
    },
    {
        "content": "<p>Well, rust has the option to use either one, and both are used in practice</p>",
        "id": 391012097,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694722695
    },
    {
        "content": "<p>the 2018 change was just to make the <code>mod.rs</code> thing not required</p>",
        "id": 391012144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694722720
    },
    {
        "content": "<p>regarding:</p>\n<blockquote>\n<p>This eliminates the special name, and if you have a bunch of files open in your editor, you can clearly see their names, instead of having a bunch of tabs named <code>mod.rs</code>.</p>\n</blockquote>\n<p><a href=\"/user_uploads/3121/wsXMB-FzaakujqZsfCoufpOk/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/wsXMB-FzaakujqZsfCoufpOk/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/wsXMB-FzaakujqZsfCoufpOk/image.png\"></a></div>",
        "id": 391012338,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694722819
    },
    {
        "content": "<p>The rust situation with a bunch of tabs named <code>mod.rs</code> is a bit worse than ours, because in rust modules named <code>mod.rs</code> often do a lot, while in lean <code>default.lean</code> files are almost always just imports (we have considered linting to ensure this), so you won't be spending a lot of time in them</p>",
        "id": 391012696,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694722988
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/Reintroducing.20default.2Elean/near/390967570\">said</a>:</p>\n<blockquote>\n<p>if VSCode had a setting to alphabetize files and folders together, I'd have ~no complaints with the status quo.</p>\n</blockquote>\n<p>To me it sounds like the issue can be solved in the extension by offering a project view, like some IDEs do, rather than changing how modules work and asking everyone to update their code. Personally, since I never was a heavy lean 3 user, and have seen both conventions in different languages, the lean 4 convention feels much cleaner. Imagine opening a large project and then opening a number of files named <code>default.lean </code>  and then having to carefully disambiguate which default file belongs to which module. (The tab headers shrink when you have many open files, and the folder names next to yhe filename get truncated).</p>",
        "id": 391014266,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694723727
    },
    {
        "content": "<p>is a project view like that possible in VSCode? (if anyone knows)</p>",
        "id": 391014835,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694723978
    },
    {
        "content": "<p>It certainly would be. The side panel can be modified</p>",
        "id": 391014923,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694724004
    },
    {
        "content": "<p>If latex-workshop can show me the doc structure and take me directly to the relevant file, then I don't see why a project view is impossible for lean.</p>",
        "id": 391015075,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694724077
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Reintroducing.20default.2Elean/near/391012338\">said</a>:</p>\n<blockquote>\n<p>regarding:</p>\n<blockquote>\n<p>This eliminates the special name, and if you have a bunch of files open in your editor, you can clearly see their names, instead of having a bunch of tabs named <code>mod.rs</code>.</p>\n</blockquote>\n<p><a href=\"/user_uploads/3121/wsXMB-FzaakujqZsfCoufpOk/image.png\">image.png</a></p>\n</blockquote>\n<p>Isn't this a design choice mathlib made, and not something forced by the lean4 module system?</p>",
        "id": 391016550,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694724717
    },
    {
        "content": "<p>of course, everything is design decisions</p>",
        "id": 391017480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694725206
    },
    {
        "content": "<p>anyway, I would be in favor of introducing the <em>option</em> to use either style, like rust does. It's a decision of the library whether they want to organize files one way or the other</p>",
        "id": 391017665,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694725305
    },
    {
        "content": "<p>I suspect that, given the option, libraries will gravitate toward using <code>default.lean</code>, since in the current style these files are actually rather different from normal files, containing imports and nothing else. There are very few of these files in mathlib, they are generally discouraged, and this is independent of whether they are spelled <code>Foo.lean</code> or <code>Foo/default.lean</code></p>",
        "id": 391017908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694725424
    },
    {
        "content": "<p>As long as it is optional, I guess I have no objections. Although, a project view with the option to completely abstract away the filesystem for vscode users might be very nice to have, while also resolving the issues raised in this thread.</p>",
        "id": 391017931,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694725441
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Reintroducing.20default.2Elean/near/391017908\">said</a>:</p>\n<blockquote>\n<p>I suspect that, given the option, libraries will gravitate toward using <code>default.lean</code>, since in the current style these files are actually rather different from normal files, containing imports and nothing else. There are very few of these files in mathlib, they are generally discouraged, and this is independent of whether they are spelled <code>Foo.lean</code> or <code>Foo/default.lean</code></p>\n</blockquote>\n<p>I wouldn't, for the reason mentioned earlier.</p>",
        "id": 391017999,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694725456
    },
    {
        "content": "<p>would you use \"subpackage files\" at all (that is, <code>Foo.lean</code> or <code>Foo/default.lean</code> where the folder <code>Foo/</code> exists)? What would you put in them?</p>",
        "id": 391018102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694725518
    },
    {
        "content": "<p>In addition to imports, some top level definitions and theorems.</p>",
        "id": 391018157,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694725554
    },
    {
        "content": "<p>if you don't use subpackage files then the whole discussion is moot</p>",
        "id": 391018166,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694725560
    },
    {
        "content": "<p>Top level definitions usually have to go at the bottom of the folder import structure, not the top. That's why mathlib has so many <code>Basic.lean</code> files</p>",
        "id": 391018329,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694725644
    },
    {
        "content": "<p>By top level, I mean the kind of things that go into the introduction section of a paper: the main theorem statements. The goal would be to setup the rest of the subpackage to allow me to write the main proofs in a few easy to read lines with heavy commenting to explain the intuition</p>",
        "id": 391018480,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694725710
    },
    {
        "content": "<p>I think a reasonable convention is to use <code>Foo.lean</code> for files with stuff in them and <code>Foo/default.lean</code> for pure aggregation files</p>",
        "id": 391018569,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694725778
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Reintroducing.20default.2Elean/near/391018569\">said</a>:</p>\n<blockquote>\n<p>I think a reasonable convention is to use <code>Foo.lean</code> for files with stuff in them and <code>Foo/default.lean</code> for pure aggregation files</p>\n</blockquote>\n<p>I guess at an abstract level, this is subjective. At a UX level on vscode, the default.lean thing is just adding extra steps and making it hard to tell which tab corresponds to the default.lean I am looking for. Currently <code>Foo.lean</code> tells me that this contains imports from and stuff about <code>Foo/..</code></p>",
        "id": 391018795,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694725896
    },
    {
        "content": "<p>the point is, you never want to open a <code>default.lean</code> file so there is no need to look for one</p>",
        "id": 391018885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694725929
    },
    {
        "content": "<p>there is nothing in those files</p>",
        "id": 391018926,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694725952
    },
    {
        "content": "<p>I might want to. That's the point. Also, if you are writing a program in lean, the programming language, the top level file of a subpackage includes the entry point of a framework or a main function</p>",
        "id": 391018963,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694725979
    },
    {
        "content": "<p>again, that's not a default.lean file under the convention I described</p>",
        "id": 391018998,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694725998
    },
    {
        "content": "<p>Why would you want two files, one for imports and one for toplevel stuff, when the toplevel file will have to get the imports again.</p>",
        "id": 391019040,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694726029
    },
    {
        "content": "<p>You never have both</p>",
        "id": 391019072,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694726044
    },
    {
        "content": "<p>lean wouldn't allow it anyway</p>",
        "id": 391019106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694726050
    },
    {
        "content": "<p>either you have <code>Foo.lean</code> with stuff in it (and imports), or <code>Foo/default.lean</code> with only imports, or neither</p>",
        "id": 391019128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694726069
    },
    {
        "content": "<p>Seems like a more complicated condition than the current one.</p>\n<p>Then again, as long as it is optional, I am not worried. I would never use default files. I have had enough of <code>__init__.py</code> tab hell for a lifetime.</p>",
        "id": 391019218,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694726127
    },
    {
        "content": "<p>In mathlib we found that it was a bad idea to have files that play double duty as aggregating their children and then adding more stuff</p>",
        "id": 391019234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694726141
    },
    {
        "content": "<p>That's probably because of the long list of imports you would have, given the number of modules right under each folder. Think of writing a simple web framework with a deeper file hierarchy that has fewer modules at each level.</p>",
        "id": 391019386,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694726210
    },
    {
        "content": "<p>For a program this is less of an issue, but mathlib often has files that are intended for use by other things, not necessarily to come together into one main function</p>",
        "id": 391019431,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694726239
    },
    {
        "content": "<p>If you had like a 100 lines of imports , I can understand not wanting to add anything else there.</p>",
        "id": 391019479,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694726267
    },
    {
        "content": "<p>so if you forget to include one of your children then files can go missing</p>",
        "id": 391019485,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694726269
    },
    {
        "content": "<p>Most folders don't have a fanout that large, 20 is more common</p>",
        "id": 391019557,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694726292
    },
    {
        "content": "<p>Exactly. So adding some top level code under the imports is not a big deal.</p>",
        "id": 391019635,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694726333
    },
    {
        "content": "<p>for mathlib this is also bad because it means you have to import all the children to get the top level theorem, even though not all the children are necessarily used in the top level theorem</p>",
        "id": 391019713,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694726375
    },
    {
        "content": "<p>and when someone adds another child later that doesn't contribute to the top level theorem it's not clear whether the top file should import it or not</p>",
        "id": 391019810,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694726406
    },
    {
        "content": "<p>My gut feeling is that the convention adopted will split cleanly along two divides:</p>\n<ol>\n<li>Lean 3 power users vs people who started off  with lean 4</li>\n<li>Projects with flatter hierarchy and larger fanout vs projects with deeper hierarchy and smaller fanout</li>\n</ol>",
        "id": 391019860,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694726429
    },
    {
        "content": "<p>I don't think this is about familiarity with lean 3</p>",
        "id": 391019902,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694726456
    },
    {
        "content": "<p>there are actual technical and maintenance reasons to prefer one over the other</p>",
        "id": 391019951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694726485
    },
    {
        "content": "<p>One can find technical arguments for both sides if one is motivated. The motivation can be past experiences with module systems and/or projects worked on.</p>",
        "id": 391020110,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694726547
    },
    {
        "content": "<p>I think it would an interesting experiment to have both options and see where things stand in 10 years.</p>",
        "id": 391020151,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694726574
    },
    {
        "content": "<p>the best system I have used to date in this regard was dotnet core. Namespaces did everything and file-hierarchy never mattered.</p>",
        "id": 391020370,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694726686
    },
    {
        "content": "<p>example?</p>",
        "id": 391020636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694726828
    },
    {
        "content": "<p>The advantage of file hierarchy is that you know where to find a package with a given name. Even if the compiler uses <code>package</code> declarations in every file to determine where things go, you still need to have a sane file structure or else people won't be able to find things</p>",
        "id": 391020841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694726914
    },
    {
        "content": "<p>The ones I gave above and then some. For example you say: </p>\n<blockquote>\n<p>so if you forget to include one of your children then files can go missing</p>\n</blockquote>\n<p>But the converse is also true. I may want to have fine grained control over imports. and add some toplevel code. In some situations, the files wouldn't be going missing.</p>",
        "id": 391020924,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694726962
    },
    {
        "content": "<p>no I mean literally how would you lay out files and what would you write in .net</p>",
        "id": 391020987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694726998
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Reintroducing.20default.2Elean/near/391020987\">said</a>:</p>\n<blockquote>\n<p>no I mean literally how would you lay out files and what would you write in .net</p>\n</blockquote>\n<p>I wouldn't worry about it. I'd use the project/solution view</p>",
        "id": 391021078,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694727027
    },
    {
        "content": "<p>I <em>really</em> don't like visual studio's \"virtual folder hierarchy\" which is almost but not quite the one on disk</p>",
        "id": 391021149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694727075
    },
    {
        "content": "<p>it means when you drag things around stuff gets out of sync</p>",
        "id": 391021192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694727107
    },
    {
        "content": "<p>That's true. But that's a visual studio thing and I am not sure if it was a bug. But it is possible to implement a sensible project view. IntelliJ has one.</p>",
        "id": 391021345,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694727178
    },
    {
        "content": "<p>I don't think people would appreciate us trying to reinvent a custom folder hierarchy separate from the one vscode provides, even ignoring the work involved</p>",
        "id": 391021377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694727195
    },
    {
        "content": "<p>trying to replicate that in other editors sounds even harder, there will always be people using the plain old file hierarchy</p>",
        "id": 391021501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694727263
    },
    {
        "content": "<p>if nothing else, github clearly does</p>",
        "id": 391021535,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694727281
    },
    {
        "content": "<p>There again, a cultural difference might exist, this time between mathematicians and computer scientists. If we can hide the folder structure and just present the module hierarchy, I doubt most people would dislike it. Power users are always a different story.</p>\n<p>We don't have to supercede the folder view either. Latex Workshop goes even further.  It extracts the file structure from one of the metadata files, constructs the document structure and presents it in the bottom half of the side panel.</p>",
        "id": 391021651,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694727346
    },
    {
        "content": "<p>the document structure is a completely different matter, that's the outline view and we already have that (IIRC)</p>",
        "id": 391021753,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694727386
    },
    {
        "content": "<p>Extracting the module hierarchy must be simpler. Anyway, the project overview idea is meant to solve the problem <span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span>  raised, namely the annoyances with vscode file explorer</p>",
        "id": 391021839,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694727449
    },
    {
        "content": "<p>As a newcomer to visual studio I found the module hierarchy view endlessly confusing</p>",
        "id": 391021853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694727457
    },
    {
        "content": "<p>big fan of not hiding filesystem</p>",
        "id": 391021975,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694727507
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/Reintroducing.20default.2Elean/near/391021975\">said</a>:</p>\n<blockquote>\n<p>big fan of not hiding filesystem</p>\n</blockquote>\n<p>It doesn't have to be hidden.</p>",
        "id": 391022014,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694727524
    },
    {
        "content": "<p>Also visual studio lets you switch to the file explorer view. Most IDEs do this. W.r.t to implementing a solution view, among the  IDEs  I used, I found XCode &gt; IntelliJ &gt; Visual Studio &gt; Eclipse (personal opinion ofc)</p>",
        "id": 391022274,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694727669
    },
    {
        "content": "<p>By the way, rust also lets you decouple the module hierarchy from the file hierarchy with <code>#[path = \"somewhere/else.rs\"] mod foo;</code>. But it's a sufficiently ugly syntax as to discourage people from abusing it to create on-disk structures not matching the module structure</p>",
        "id": 391022483,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694727804
    },
    {
        "content": "<p>but this has a high cost for incremental compilation and IDEs, because it means you have to read the whole project to find out where a given file like <code>somewhere/else.rs</code> actually lives with respect to the module structure</p>",
        "id": 391022687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694727912
    },
    {
        "content": "<p>Anyway, dotnet aside, I am happily using lean's current module system. If  <code>default.lean</code> is coming back, I hope it remains optional. </p>\n<p>I am guessing a project module hierachy view should not be as complicated for lean since there is a one-one mapping of files and modules.</p>",
        "id": 391022944,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694728047
    },
    {
        "content": "<p>As an aside on \"hiding file systems\", this is the world we are headed towards: <a href=\"https://www.theverge.com/22684730/students-file-folder-directory-structure-education-gen-z\">https://www.theverge.com/22684730/students-file-folder-directory-structure-education-gen-z</a></p>",
        "id": 391023345,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694728247
    },
    {
        "content": "<p>^it's already routinely a problem for first year CS students here LOL</p>",
        "id": 391023435,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694728313
    },
    {
        "content": "<p>but we beat the unix into them by year 2 :-)</p>",
        "id": 391023511,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1694728346
    },
    {
        "content": "<p>I guess in German-speaking countries it is hard to survive your first year exams if you can't figure out how to compile your programs.</p>",
        "id": 391023921,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694728575
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/Reintroducing.20default.2Elean/near/391023345\">said</a>:</p>\n<blockquote>\n<p>As an side on \"hiding file systems\", this is the world we are headed towards: <a href=\"https://www.theverge.com/22684730/students-file-folder-directory-structure-education-gen-z\">https://www.theverge.com/22684730/students-file-folder-directory-structure-education-gen-z</a></p>\n</blockquote>\n<p>You make it sound like future, but it's already there.</p>",
        "id": 391023926,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694728578
    },
    {
        "content": "<p>Maybe it's not fully there. I still see students who understand the question \"where did you put the file you downloaded?\". But they have no clue about the answer.</p>",
        "id": 391024012,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694728640
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/Reintroducing.20default.2Elean/near/391024012\">said</a>:</p>\n<blockquote>\n<p>\"where did you put the file you downloaded?\". But they have no clue about the answer.</p>\n</blockquote>\n<p>I think this particular problem has been around forever (i.e. since browsers)</p>",
        "id": 391024459,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694728876
    },
    {
        "content": "<p>Getting back to the point, a module hierarchy view would be nice to have for this reason alone: making life simpler for newcomers of the younger generation.</p>",
        "id": 391024853,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694729102
    },
    {
        "content": "<p>a command to be able to open a file by module name would be nice</p>",
        "id": 391024909,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694729158
    },
    {
        "content": "<p>the closest approximation to this is to type <code>import Foo</code> and then ctrl-click on <code>Foo</code></p>",
        "id": 391024980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694729192
    },
    {
        "content": "<p>A quick google search for this landed me on this repo : <a href=\"https://github.com/hashicorp/vscode-terraform/pull/746\">https://github.com/hashicorp/vscode-terraform/pull/746</a></p>",
        "id": 391025043,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694729244
    },
    {
        "content": "<p>the second result was vscode's tree-view API: <a href=\"https://code.visualstudio.com/api/extension-guides/tree-view\">https://code.visualstudio.com/api/extension-guides/tree-view</a></p>",
        "id": 391025167,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694729303
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Reintroducing.20default.2Elean/near/391024980\">said</a>:</p>\n<blockquote>\n<p>the closest approximation to this is to type <code>import Foo</code> and then ctrl-click on <code>Foo</code></p>\n</blockquote>\n<p>This could be implemented as a command that can be entered in the new search bar in vscode</p>",
        "id": 391025375,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694729435
    },
    {
        "content": "<p>just as soon as we get completion for imports</p>",
        "id": 391025529,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694729527
    },
    {
        "content": "<p>I just want to establish something quickly: what exactly are the use cases of a <code>default.lean</code> file in the first place (comprehensively)? Specifically, what are all the situations where someone would need <em>manual</em> control over which files in a folder are imported, instead of just making <code>import Foo.*</code> figure out on the fly how to import everything in <code>Foo/</code> automatically and relying on that?</p>\n<p>I can think of a couple possible partial answers:</p>\n<ol>\n<li>sometimes (when?) import order matters, and we get different behavior for different orders, so we need to specify the right one.</li>\n<li>someone might want to <em>exclude</em> an import for some reason.</li>\n<li>(?) eliminating redundant imports is useful (is it?) but nontrivial to compute over and over (is it?), so we effectively want a permanent cache of the “minimized” list of imports. (But lake seems to do this every build, so my feeling is that this might not be a real concern?)</li>\n</ol>\n<p>Are there other (possibly more technical) purposes?</p>",
        "id": 391062788,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1694746820
    },
    {
        "content": "<p>One of the reasons rust doesn't do <code>import Foo.*</code> style imports is that directory traversals might be slow (you don't know what else is in the directory) or impossible (e.g. network drives or linux directories without the traversal permission set)</p>",
        "id": 391063805,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694747224
    },
    {
        "content": "<blockquote>\n<p>(But lake seems to do this every build, so my feeling is that this might not be a real concern?)</p>\n</blockquote>\n<p>see my ongoing battle to make lake less slow</p>",
        "id": 391064247,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694747441
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/270676-lean4/topic/Reintroducing.20default.2Elean/near/391062788\">said</a>:</p>\n<blockquote>\n<ol start=\"3\">\n<li>(?) eliminating redundant imports is useful (is it?) but nontrivial to compute over and over (is it?), so we effectively want a permanent cache of the “minimized” list of imports. (But lake seems to do this every build, so my feeling is that this might not be a real concern?)</li>\n</ol>\n</blockquote>\n<p>Yes, as <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> notes this somewhat of a performance bottleneck for Lake. Lake needs to maintain order and eliminate duplicate imports (and packages!) and this means that when computing a import graph there currently is little ability to reuse work between modules (i.e., the import arrays and sets have to be reconstructed for every module).</p>",
        "id": 391083675,
        "sender_full_name": "Mac Malone",
        "timestamp": 1694756342
    },
    {
        "content": "<p>There are potential avenues for improvement here, but the underlying issue  of needing to order and deduplicate still remains and is less than ideal, but somewhat inherit to Lean's current module system.</p>",
        "id": 391084643,
        "sender_full_name": "Mac Malone",
        "timestamp": 1694756750
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/Reintroducing.20default.2Elean/near/391023345\">said</a>:</p>\n<blockquote>\n<p>As an aside on \"hiding file systems\", this is the world we are headed towards: <a href=\"https://www.theverge.com/22684730/students-file-folder-directory-structure-education-gen-z\">https://www.theverge.com/22684730/students-file-folder-directory-structure-education-gen-z</a></p>\n</blockquote>\n<p>Interesting... I'm right in that generation but I literally never heard of that phenomenon.</p>",
        "id": 391090590,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1694759379
    },
    {
        "content": "<p>Yeah but you're a power user</p>",
        "id": 391090697,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694759424
    },
    {
        "content": "<p>how long have you been using computers? (i.e. programming or other power user things, not youtube and snapchat)</p>",
        "id": 391090716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694759437
    },
    {
        "content": "<p>It's the people who don't know what a command line is that don't know anything about directory structure</p>",
        "id": 391090779,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694759480
    },
    {
        "content": "<p>And they are legion in mathematics departments</p>",
        "id": 391090806,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694759491
    },
    {
        "content": "<p>I've been doing computer stuff since I was 11, so 10 years?</p>",
        "id": 391090833,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1694759509
    },
    {
        "content": "<p>if you've been doing more-than-youtube/facebook since you were 11 then you are definitely a power user</p>",
        "id": 391091155,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694759647
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/270676-lean4/topic/Reintroducing.20default.2Elean/near/391062788\">said</a>:</p>\n<blockquote>\n<p>I just want to establish something quickly: what exactly are the use cases of a <code>default.lean</code> file in the first place (comprehensively)? Specifically, what are all the situations where someone would need <em>manual</em> control over which files in a folder are imported, instead of just making <code>import Foo.*</code> figure out on the fly how to import everything in <code>Foo/</code> automatically and relying on that?</p>\n<p>I can think of a couple possible partial answers:</p>\n<ol>\n<li>sometimes (when?) import order matters, and we get different behavior for different orders, so we need to specify the right one.<br>\n[...]</li>\n</ol>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/6763\">#6763</a> might be of interest for 1.  Most of the files build by reordering alphabetically the imports, the main difference being time to build the files.  One file had a massive slowdown, one file I was not able to get to work, unless some import appeared before some others.</p>",
        "id": 391105840,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1694765066
    },
    {
        "content": "<p>Wait, why can't import order be computed the usual way? Construct the DAG, complain about cycles, and perform topological sort? What is an example of import order affecting behavior beyond this?</p>",
        "id": 391118258,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694768906
    },
    {
        "content": "<p>Import order affects the order of declarations in the environment</p>",
        "id": 391118751,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694769060
    },
    {
        "content": "<p>Also, it effects the order initializers are run, which can easily be designed in a non-communicative manner (since they have arbitrary stateful effects).</p>",
        "id": 391119290,
        "sender_full_name": "Mac Malone",
        "timestamp": 1694769233
    },
    {
        "content": "<p>declarations are in a hashmap, they aren't ordered</p>",
        "id": 391119583,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694769308
    },
    {
        "content": "<p>in fact even within a file lean isn't able to remember what order declarations came in</p>",
        "id": 391119630,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694769326
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> But there is <code>const2ModIdx</code> to figure that out?</p>",
        "id": 391119910,
        "sender_full_name": "Mac Malone",
        "timestamp": 1694769416
    },
    {
        "content": "<p>oh, modules are ordered, constants are not</p>",
        "id": 391119984,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694769442
    },
    {
        "content": "<p>Yes, but you can go from constant to module and sort constants by their module index.</p>",
        "id": 391120065,
        "sender_full_name": "Mac Malone",
        "timestamp": 1694769469
    },
    {
        "content": "<p>constants are in modules, but the order of constants within a module is random</p>",
        "id": 391120091,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694769478
    },
    {
        "content": "<p>Oh, yeah.</p>",
        "id": 391120150,
        "sender_full_name": "Mac Malone",
        "timestamp": 1694769489
    },
    {
        "content": "<p>But, we were talking about module order here, right?</p>",
        "id": 391120233,
        "sender_full_name": "Mac Malone",
        "timestamp": 1694769517
    },
    {
        "content": "<p>I was reacting to</p>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Reintroducing.20default.2Elean/near/391118751\">said</a>:</p>\n<blockquote>\n<p>Import order affects the order of declarations in the environment</p>\n</blockquote>",
        "id": 391120288,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694769535
    },
    {
        "content": "<p>I assumed that also included the order of declarations which appear in environment extensions which usually are ordered by module.</p>",
        "id": 391120581,
        "sender_full_name": "Mac Malone",
        "timestamp": 1694769607
    },
    {
        "content": "<p>I think you are right that the main cause of order dependence is because of initializers; in practice this usually manifests as pushing things to a vector or something in the initializer, and then that becomes the default sort order for things like typeclass inference</p>",
        "id": 391120606,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694769615
    },
    {
        "content": "<p>environment extensions are ordered</p>",
        "id": 391120720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694769649
    },
    {
        "content": "<p>if you declare tags on three declarations those tags will show up in the relevant environment extension in source order</p>",
        "id": 391120911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694769706
    },
    {
        "content": "<p>but the declarations themselves will be shuffled</p>",
        "id": 391120934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694769714
    },
    {
        "content": "<p>I was thinking of things like tag attributes where the order of all tagged declarations in the array of all entries will be ordered by import.</p>",
        "id": 391121081,
        "sender_full_name": "Mac Malone",
        "timestamp": 1694769742
    },
    {
        "content": "<p>You beat me to it. <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 391121172,
        "sender_full_name": "Mac Malone",
        "timestamp": 1694769768
    },
    {
        "content": "<p>Hmm, ok! Thanks for the responses; here are some thoughts!</p>\n<p>My feeling is that there are really two classes of needs/concerns here:</p>\n<ul>\n<li>having a sort of <em>permanent cache</em> (more or less) of imports in a folder, so that we can avoid directory traversals and minimize import redundancy</li>\n<li>being able to fine-tune imports, so that we can customize the selection of imported files and avoid timing issues (or is the goal to just make this not happen?)</li>\n</ul>\n<p>The interesting thing about the permanent cache is that it could in most cases be computed periodically without human intervention and maintenance.</p>\n<p>(Re: dealing with impossible directory traversals when computing such a cache: I’d hope that either 1) they’re pulling from a place which already has this permanent cache, and don’t need to ever make it/adjust it themselves 2) they can occasionally surmount the issues, e.g. by running some command with appropriate permissions 3) they’re rare enough to make this a low burden.)</p>",
        "id": 391123577,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1694770462
    },
    {
        "content": "<p>So, here are the things I’d personally like to be true.</p>\n<ul>\n<li>\n<p>Your average uncomputery mathematician could write <code>import Foo</code> and by default, it imports <code>Foo/</code>. (Or <code>import Foo.*</code>, but I think even glob syntax would not be intuitive to most; but let’s table that bikeshed for now, the point is that by default, without setup, there’s a way to do folder imports)</p>\n</li>\n<li>\n<p>Anyone who needs to can override the default behavior as suits their needs.</p>\n</li>\n</ul>\n<p>I think we could achieve that in a few ways; here’s a sketch of some partial possibilities.</p>\n<ul>\n<li>\n<p>Each folder comes with a file, say  <code>.imports.lean</code> (starts with <code>.</code>, is hidden from people who don’t need it), which is by default constructed (and reconstructed) automatically by <em>some tool</em> at <em>some point</em>. I don’t know the optimal way to fill in these blanks, but I think we could probably find a reasonable (recurring) time to do this.</p>\n<ul>\n<li>\n<p>It could also have restrictions to cordon off the difficult edge cases—since this would be intended for the average user who likely has a typical-looking project, maybe we only do this automatically when the directory is small; if the traversal starts to take too long, we demand a manually triggered reconstruction/update of the file instead of constructing it at an automatic <em>time</em>. (I’m not sure exactly when directory traversal starts to get slow, but I’d hope it’s not slow at least up to ~100 files…)</p>\n</li>\n<li>\n<p>We could maybe put extra info in the file that helps us not do extra work, like remembering imports of each file in the directory so that we  only recompute on changes</p>\n</li>\n<li>\n<p>In general, “by lake, during build” is the obvious choice, but maybe there’s a better, less-obvious one; maybe only certain builds, or maybe a linter should request a manual update. Maybe this should be configurable to be different between larger and smaller projects, enabling “average mathematicians” to work without fuss, while not tying larger projects down.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Then, when we want to override the default for some reason, we could either…</p>\n<ul>\n<li>\n<p>…simply edit <code>.imports.lean</code>, and remove some marker content at the top which indicates to <em>the tool</em> that it should autogenerate it/overwrite it</p>\n</li>\n<li>\n<p>…or create a new file <code>_imports.lean</code> (or whatever) that’s not hidden, and we enforce never having both this file and <code>.imports.lean</code> at once</p>\n</li>\n<li>\n<p>…or, if import order is eventually meant to be irrelevant, add another file e.g. <code>_importOverrides.lean</code> (or whatever) which just specifies <em>changes</em> to the imports (I.e. extra included/excluded files). <code>.imports.lean</code> would then be reconstructed by <em>the tool</em> with this file in mind—the file itself would be otherwise “inert”. EDIT: wrote this part before the above discussion; looks like it’s unavoidably relevant in certain specific situations!</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>Anyway, thought I’d put these thoughts out there, just in case it helps refine what would be a good idea one way or another! :)</p>",
        "id": 391125516,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1694771007
    },
    {
        "content": "<p>how is the existing module system preserved?</p>",
        "id": 391129519,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694772231
    },
    {
        "content": "<p>Does any currently well-used language other than C or C++ force programmers to import modules/files in some order? How does it work in haskell, which would also have typeclass inference issues?</p>",
        "id": 391130525,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1694772558
    },
    {
        "content": "<p>directory traversal starts to become problematic around 5000 files, maybe a bit less on windows</p>",
        "id": 391134906,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694774245
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/Reintroducing.20default.2Elean/near/391130525\">said</a>:</p>\n<blockquote>\n<p>Does any currently well-used language other than C or C++ force programmers to import modules/files in some order?</p>\n</blockquote>\n<p>Order of imports matters in almost every interpreted language, including Python, Ruby, and JavaScript/TypeScript, just to name a few.</p>",
        "id": 391136531,
        "sender_full_name": "Mac Malone",
        "timestamp": 1694774778
    },
    {
        "content": "<p>For fun, I tried to see how I would implement the <code>import Foo.*</code> and I tried with importing a fixed file.  However, with the code below, I get an error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Elab.Command</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"k\">in</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"myImport\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">imp</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Import</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">imports.toList</span> <span class=\"bp\">++</span> <span class=\"o\">[{</span> <span class=\"n\">module</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">Mathlib.Data.Nat.Basic</span> <span class=\"o\">}]</span>\n  <span class=\"k\">let</span> <span class=\"n\">newEnv</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.importModules</span> <span class=\"n\">imp</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getOptions</span><span class=\"o\">)</span>\n  <span class=\"n\">setEnv</span> <span class=\"n\">newEnv</span>\n\n<span class=\"n\">myImport</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Lean server printed an error: libc++abi: terminating due to uncaught exception of type</span>\n<span class=\"cm\">lean::exception: cannot evaluate `[init]` declaration 'Std.CodeAction.cmdCodeActionExt'</span>\n<span class=\"cm\">in the same module</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>I imagine that what I am doing is very crude: what is a better approach?</p>",
        "id": 391174554,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1694785503
    },
    {
        "content": "<p>You're on an old version of Lean. This works fine for me, after changing <code>imp</code> to <code>imp.toArray</code>.</p>",
        "id": 391590004,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1694996610
    },
    {
        "content": "<p>I first ran</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>$<span class=\"w\"> </span>elan<span class=\"w\"> </span>self<span class=\"w\"> </span>update\ninfo:<span class=\"w\"> </span>checking<span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span>self-updates\ninfo:<span class=\"w\"> </span>downloading<span class=\"w\"> </span>self-update\ninfo:<span class=\"w\"> </span>elan<span class=\"w\"> </span>updated<span class=\"w\"> </span>successfully<span class=\"w\"> </span>to<span class=\"w\"> </span><span class=\"m\">3</span>.0.0\n\n$<span class=\"w\"> </span>lean<span class=\"w\"> </span>--version\nLean<span class=\"w\"> </span><span class=\"o\">(</span>version<span class=\"w\"> </span><span class=\"m\">4</span>.1.0-rc1,<span class=\"w\"> </span>commit<span class=\"w\"> </span>339615042d90,<span class=\"w\"> </span>Release<span class=\"o\">)</span>\n</code></pre></div>\n<p>Then I pulled master on mathlib and ran</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>$<span class=\"w\"> </span>lake<span class=\"w\"> </span>exe<span class=\"w\"> </span>cache<span class=\"w\"> </span>get!\nAttempting<span class=\"w\"> </span>to<span class=\"w\"> </span>download<span class=\"w\"> </span><span class=\"m\">3765</span><span class=\"w\"> </span>file<span class=\"o\">(</span>s<span class=\"o\">)</span>\nDownloaded:<span class=\"w\"> </span><span class=\"m\">3765</span><span class=\"w\"> </span>file<span class=\"o\">(</span>s<span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span>attempted<span class=\"w\"> </span><span class=\"m\">3765</span>/3765<span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"m\">100</span>%<span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"m\">100</span>%<span class=\"w\"> </span>success<span class=\"o\">)</span>\nDecompressing<span class=\"w\"> </span><span class=\"m\">3765</span><span class=\"w\"> </span>file<span class=\"o\">(</span>s<span class=\"o\">)</span>\nunpacked<span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"m\">7688</span><span class=\"w\"> </span>ms\n</code></pre></div>\n<p>However, I still get an error with the code above (I did have to change <code>List</code> to <code>Array</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Lean</span> <span class=\"o\">(</span><span class=\"n\">version</span> <span class=\"mi\">4</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"bp\">-</span><span class=\"n\">rc1</span><span class=\"o\">,</span> <span class=\"n\">commit</span> <span class=\"mi\">339615042</span><span class=\"n\">d90</span><span class=\"o\">,</span> <span class=\"n\">Release</span><span class=\"o\">)</span>\n<span class=\"n\">libc</span><span class=\"bp\">++</span><span class=\"n\">abi</span><span class=\"o\">:</span> <span class=\"n\">terminating</span> <span class=\"n\">due</span> <span class=\"n\">to</span> <span class=\"n\">uncaught</span> <span class=\"n\">exception</span> <span class=\"n\">of</span> <span class=\"n\">type</span> <span class=\"n\">lean</span><span class=\"o\">::</span><span class=\"n\">exception</span><span class=\"o\">:</span> <span class=\"n\">cannot</span> <span class=\"n\">evaluate</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">init</span><span class=\"o\">]</span><span class=\"bp\">`</span> <span class=\"n\">declaration</span> <span class=\"bp\">'</span><span class=\"n\">Std.CodeAction.cmdCodeActionExt'</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">same</span> <span class=\"n\">module</span>\n<span class=\"o\">[</span><span class=\"n\">Error</span> <span class=\"bp\">-</span> <span class=\"mi\">4</span><span class=\"o\">:</span><span class=\"mi\">21</span><span class=\"o\">:</span><span class=\"mi\">40</span> <span class=\"n\">AM</span><span class=\"o\">]</span> <span class=\"n\">Request</span> <span class=\"n\">textDocument</span><span class=\"bp\">/</span><span class=\"n\">codeAction</span> <span class=\"n\">failed.</span>\n  <span class=\"n\">Message</span><span class=\"o\">:</span> <span class=\"n\">Server</span> <span class=\"n\">process</span> <span class=\"n\">for</span> <span class=\"n\">file</span><span class=\"o\">:</span><span class=\"bp\">///</span><span class=\"n\">home</span><span class=\"bp\">/</span><span class=\"n\">damiano</span><span class=\"bp\">/</span><span class=\"n\">Matematica</span><span class=\"bp\">/</span><span class=\"n\">Lean4</span><span class=\"bp\">/</span><span class=\"n\">mathlib4</span><span class=\"bp\">/</span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">adomaniLeanUtils</span><span class=\"bp\">/</span><span class=\"n\">importStar.lean</span> <span class=\"n\">crashed</span><span class=\"o\">,</span> <span class=\"n\">likely</span> <span class=\"n\">due</span> <span class=\"n\">to</span> <span class=\"n\">a</span> <span class=\"n\">stack</span> <span class=\"n\">overflow</span> <span class=\"n\">or</span> <span class=\"n\">a</span> <span class=\"n\">bug.</span>\n  <span class=\"n\">Code</span><span class=\"o\">:</span> <span class=\"bp\">-</span><span class=\"mi\">32902</span>\n</code></pre></div>",
        "id": 391603355,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1695003838
    },
    {
        "content": "<p>Hmm.. trying sprinkling <code>enableInitializersExecution</code> in your code?</p>",
        "id": 391613786,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695010137
    },
    {
        "content": "<p>I tried</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elab</span> <span class=\"s2\">\"myImport\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">enableInitializersExecution</span>\n  <span class=\"k\">let</span> <span class=\"n\">imp</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">imports</span> <span class=\"bp\">++</span> <span class=\"bp\">#</span><span class=\"o\">[{</span> <span class=\"n\">module</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">Mathlib.Data.Nat.Basic</span> <span class=\"o\">}]</span>\n  <span class=\"k\">let</span> <span class=\"n\">newEnv</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.importModules</span> <span class=\"n\">imp</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getOptions</span><span class=\"o\">)</span>\n  <span class=\"n\">setEnv</span> <span class=\"n\">newEnv</span>\n</code></pre></div>\n<p>but Lean does not like that <code>enableInitializersExecution</code> is `unsafe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">kernel</span><span class=\"o\">)</span> <span class=\"n\">invalid</span> <span class=\"n\">declaration</span><span class=\"o\">,</span> <span class=\"n\">it</span> <span class=\"n\">uses</span> <span class=\"n\">unsafe</span> <span class=\"n\">declaration</span> <span class=\"bp\">'</span><span class=\"n\">Lean.enableInitializersExecution'</span>\n</code></pre></div>\n<p>Anyway, thank you very much for your suggestions!</p>",
        "id": 391616773,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1695011911
    },
    {
        "content": "<p>Use <code>unsafe</code> from <code>Std.Util.TermUnsafe</code>.</p>",
        "id": 391617197,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695012162
    },
    {
        "content": "<p>Success!  Thanks Scott!  This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Util.TermUnsafe</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"k\">in</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"myImport\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">unsafe</span> <span class=\"n\">enableInitializersExecution</span>\n  <span class=\"k\">let</span> <span class=\"n\">imp</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">imports</span> <span class=\"bp\">++</span> <span class=\"bp\">#</span><span class=\"o\">[{</span> <span class=\"n\">module</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">Mathlib.Data.Nat.Basic</span> <span class=\"o\">}]</span>\n  <span class=\"k\">let</span> <span class=\"n\">newEnv</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.importModules</span> <span class=\"n\">imp</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getOptions</span><span class=\"o\">)</span>\n  <span class=\"n\">setEnv</span> <span class=\"n\">newEnv</span>\n\n<span class=\"n\">myImport</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Nat.commSemiring</span>\n</code></pre></div>\n<p>Lean is clearly not too happy with revisiting imports.  Currently, this may panic, but that's ok!  Thanks a lot!</p>",
        "id": 391618344,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1695012758
    },
    {
        "content": "<p>This \"almost\" works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.List.Basic</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">importStar</span><span class=\"o\">)</span> <span class=\"s2\">\"import*\"</span> <span class=\"s2\">\"?\"</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">colGt</span> <span class=\"n\">ident</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"k\">in</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span> <span class=\"kn\">import</span><span class=\"bp\">*</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">?%$</span><span class=\"n\">info</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"n\">pat</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">imps</span> <span class=\"o\">:</span> <span class=\"n\">System.FilePath</span> <span class=\"o\">:=</span> <span class=\"s2\">\"Mathlib.lean\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">stripImp</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">IO.FS.lines</span> <span class=\"n\">imps</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">String.trim</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">String.drop</span> <span class=\"bp\">·</span> <span class=\"mi\">7</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">withDots</span> <span class=\"o\">:=</span> <span class=\"n\">stripImp.filter</span> <span class=\"o\">(</span><span class=\"n\">String.isPrefixOf</span> <span class=\"n\">pat.getId.toString</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">paths</span> <span class=\"o\">:=</span> <span class=\"n\">withDots.map</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">spl</span> <span class=\"o\">:=</span> <span class=\"n\">String.splitOn</span> <span class=\"n\">s</span> <span class=\"s2\">\".\"</span>\n    <span class=\"n\">System.mkFilePath</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">spl.dropLast</span> <span class=\"bp\">++</span> <span class=\"o\">[(</span><span class=\"n\">spl.last'.getD</span> <span class=\"s2\">\"\"</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"s2\">\".lean\"</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">names</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span> <span class=\"n\">paths.mapM</span> <span class=\"o\">(</span><span class=\"n\">moduleNameOfFileName</span> <span class=\"bp\">.</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">newImports</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Import</span> <span class=\"o\">:=</span> <span class=\"n\">names.map</span> <span class=\"o\">({</span> <span class=\"n\">module</span> <span class=\"o\">:=</span> <span class=\"bp\">·</span> <span class=\"o\">})</span>\n  <span class=\"k\">let</span> <span class=\"n\">oldAndNewImports</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">imports</span> <span class=\"bp\">++</span> <span class=\"n\">newImports</span>\n  <span class=\"k\">if</span> <span class=\"n\">info.isSome</span> <span class=\"k\">then</span> <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{\"</span><span class=\"bp\">\\</span><span class=\"n\">n</span><span class=\"s2\">\".intercalate (withDots.map (\"</span><span class=\"kn\">import</span> <span class=\"s2\">\" ++ ·)).toList}\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">newEnv</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span> <span class=\"n\">importModules</span> <span class=\"n\">oldAndNewImports</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getOptions</span><span class=\"o\">)</span>\n  <span class=\"n\">unsafe</span> <span class=\"n\">enableInitializersExecution</span>\n  <span class=\"n\">setEnv</span> <span class=\"n\">newEnv</span>\n</code></pre></div>",
        "id": 391646671,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1695026915
    },
    {
        "content": "<p>Writing <code>import* Mathlib.Data.ENat</code> is equivalent to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.ENat.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.ENat.Lattice</span>\n</code></pre></div>\n<p>while <code>import* Mathlib.Data.Nat.L</code><br>\nis equivalent to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Lattice</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Log</span>\n</code></pre></div>\n<p>The only issue is that, if you import the command in the previous message from a separate file, then there needs to be \"something\" between the last actual <code>import</code> and <code>import*</code>.  For instance, this works</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.importStar</span>        <span class=\"c1\">-- we import the `import*` command</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.MvPolynomial.Basic</span>  <span class=\"c1\">-- random imports</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Polynomial.Basic</span>\n\n<span class=\"kn\">section</span> <span class=\"kd\">end</span>  <span class=\"c1\">-- \"something\", `/-!-/` would also work as \"something\"</span>\n<span class=\"kn\">import</span><span class=\"bp\">*</span> <span class=\"n\">Mathlib.Data.Nat.L</span>  <span class=\"c1\">-- this works.  It would not, without the previous `section end`.</span>\n</code></pre></div>",
        "id": 391647017,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1695027036
    }
]