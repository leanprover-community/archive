[
    {
        "content": "<p>I'd like to propose allowing match expressions to unify terms containing syntactically equal functions. I am unqualified to comment on realizability, but I'd like to sketch why I think it would be beneficial, and document workarounds I'm aware of.</p>\n<p>I have to admit one workaround I discovered during the writing of this proposal is <del><em>relatively</em> decent</del>, but still has drawbacks. If nothing else, this proposal will serve as documentation for that workaround <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> Update: more drawbacks found</p>\n<h2>Minified example</h2>\n<p>Ideally, Lean ought to accept the following code as valid.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">ArityTwo</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zth</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fst</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">TwoNats</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ArityTwo</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">TwoNatWrapper</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TwoNats</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">TwoNatWrapper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zth</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">extract</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TwoNatWrapper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zth</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)):</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ``Tactic `cases` failed with a nested error: [...]``</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">42</span>\n</code></pre></div>\n<p>Notice that the functions in the example are <em>syntactically equal</em> up to the variables that ought to be unified.</p>\n<h2>A specific use case example</h2>\n<p>Similar to universal algebras, I work with expressions that accept a signature that specifies custom operators and their arities.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Signature</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Op</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"n\">Params</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Op</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sig</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Signature</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sig</span><span class=\"bp\">.</span><span class=\"n\">Op</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sig</span><span class=\"bp\">.</span><span class=\"n\">Params</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"n\">sig</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Let's say we have a particular signature (with one nullary and one binary operation) that represents the following type.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">PairExpr</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">null</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PairExpr</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Matching on types defined in terms of <code>PairExpr</code> is not problematic at all, it's a simple type. However, the <code>Expr pairSignature</code> version of <code>PairExpr.pair .null .null</code> is <code>Expr.op .pair fun | .zth =&gt; N | .fst =&gt; N</code>, where N is <code>Expr.op .null nofun</code>.</p>\n<p>Unifying two <code>Expr pairSignature</code> values, (unless they are both <code>var</code>), will fail because they are defined using functions that carry the arguments.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Fuller code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>structure Signature.{u, v} where\n  Op: Type u\n  Params: Op → Type v\n\ninductive Expr (sig: Signature) where\n| var (x: Nat)\n| op (op: sig.Op) (args: sig.Params op → Expr sig)\n\n\ninductive ArityZero\ninductive ArityOne | zth\ninductive ArityTwo | zth | fst\n\ninductive pairSignature.Op where\n| null\n| pair\n\ndef pairSignature.Params: Op → Type\n| Op.null =&gt; ArityZero\n| Op.pair =&gt; ArityTwo\n\nopen pairSignature in\ndef pairSignature: Signature := { Op, Params }\n\ndef Expr.null: Expr pairSignature := Expr.op .null nofun\ndef Expr.pair (l r: Expr pairSignature): Expr pairSignature :=\n  Expr.op .pair fun | .zth =&gt; l | .fst =&gt; r\n\n\ninductive IsSubset: Expr pairSignature → Expr pairSignature → Prop\n| null: IsSubset .null .null\n| pair {la lb ra rb} (subL: IsSubset la lb) (subR: IsSubset ra rb): IsSubset (.pair la ra) (.pair lb rb)\n\ndef IsSubset.foo {l r b} (sub: IsSubset (.pair l r) b): True :=\n  match sub with\n  | .pair pl pr =&gt; trivial\n</code></pre></div>\n\n</div></div>\n<h2>Related</h2>\n<p>My proposal is loosely related to a problem described by Andrej Bauer in his <a href=\"https://proofassistants.stackexchange.com/a/2050/1695\">answer</a> about representing universal algebras vs concrete algebraic structures. While my proposal does not solve the crux of that problem, it does make it easier to work with the general setting where n-ary function applications are represented as functions whose domain is a size-n type.</p>\n<h2>Current state</h2>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"ss\">`cases</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">nested</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">Dependent</span><span class=\"w\"> </span><span class=\"n\">elimination</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">solve</span><span class=\"w\"> </span><span class=\"n\">equation</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ArityTwo</span><span class=\"bp\">.</span><span class=\"n\">zth</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ArityTwo</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ArityTwo</span><span class=\"bp\">.</span><span class=\"n\">zth</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">la</span><span class=\"bp\">✝</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ArityTwo</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ra</span><span class=\"bp\">✝</span>\n<span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"ss\">`pair</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">after</span><span class=\"w\"> </span><span class=\"n\">processing</span>\n<span class=\"w\">  </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">dependent</span><span class=\"w\"> </span><span class=\"n\">pattern</span><span class=\"w\"> </span><span class=\"n\">matcher</span><span class=\"w\"> </span><span class=\"n\">can</span><span class=\"w\"> </span><span class=\"n\">solve</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">following</span><span class=\"w\"> </span><span class=\"n\">kinds</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">equations</span>\n<span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"n\">var</span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"n\">term</span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"n\">term</span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"n\">var</span><span class=\"bp\">&gt;</span>\n<span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"n\">term</span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"n\">term</span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">terms</span><span class=\"w\"> </span><span class=\"n\">are</span><span class=\"w\"> </span><span class=\"n\">definitionally</span><span class=\"w\"> </span><span class=\"n\">equal</span>\n<span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"n\">constructor</span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"n\">constructor</span><span class=\"bp\">&gt;</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">examples</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">nil</span>\n</code></pre></div>\n<p>Ideally, the dependent pattern matcher would be extended to handle <code>&lt;function&gt; = &lt;function&gt;</code> as long as the bodies are compatible.</p>\n<h2>Known workarounds</h2>\n<h3>Have two types (<code>Expr</code> and <code>PairExpr</code>) and convert between them as necessary</h3>\n<p>This means lots of duplication and boilerplate code.</p>\n<h3>Use recursors directly</h3>\n<p>Very clumsy and time consuming. All this ↴ just to eliminate <code>IsSubset.pair</code>:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Example</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>def IsSubset.elimPairLeft {la lb ra rb: Expr pairSignature} (sub: IsSubset (.pair la ra) (.pair ra rb)): IsSubset la ra :=\n  sub.rec\n    (motive := fun a b _ =&gt; ∀ {la lb ra rb}, a = .pair la ra → b = .pair lb rb → IsSubset la lb)\n    (fun eq =&gt; Expr.noConfusion eq fun opEq =&gt; pairSignature.Op.noConfusion opEq)\n    (fun {la lb ra rb} isSubL _ _ _ la&#39; lb&#39; ra&#39; rb&#39; eqA eqB =&gt;\n      let eqA := eq_of_heq (Expr.noConfusion eqA (fun _ =&gt; id))\n      let eqB := eq_of_heq (Expr.noConfusion eqB (fun _ =&gt; id))\n      let eqLa: la = la&#39; := congr eqA (rfl: ArityTwo.zth = .zth)\n      let eqLb: lb = lb&#39; := congr eqB (rfl: ArityTwo.zth = .zth)\n      eqLa ▸ eqLb ▸ isSubL)\n    rfl\n    rfl\n</code></pre></div>\n\n</div></div>\n<h3>Bake in arguments directly into Expr</h3>\n<p>Unidiomatic, unintuitive/not-easy-to-think-of solution that employs extra constructors in the Expr type to encode variable number of arguments. Essentially, we'd like to build something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Arities</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Op</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"n\">arity</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Op</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"c1\">-- Note: the codomain is Nat instead of Type as in Signature</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">VectorExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sig</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Arities</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sig</span><span class=\"bp\">.</span><span class=\"n\">Op</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">VectorExpr</span><span class=\"w\"> </span><span class=\"n\">sig</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sig</span><span class=\"bp\">.</span><span class=\"n\">arity</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>but that does not work because <code>List.Vector</code> does not accept the type that we're defining. (<code>(kernel) arg #3 of 'VectorExpr.op' contains a non valid occurrence of the datatypes being declared</code>).</p>\n<p>So we have to implement \"vectors\" ourselves directly in <code>Expr</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">ExprKind</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">expr</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">VectorExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sig</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Arities</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">ExprKind</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">VectorExpr</span><span class=\"w\"> </span><span class=\"n\">sig</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">expr</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">op</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sig</span><span class=\"bp\">.</span><span class=\"n\">Op</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">VectorExpr</span><span class=\"w\"> </span><span class=\"n\">sig</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sig</span><span class=\"bp\">.</span><span class=\"n\">arity</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"o\">)))</span>\n<span class=\"w\">  </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">VectorExpr</span><span class=\"w\"> </span><span class=\"n\">sig</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">expr</span>\n\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">VectorExpr</span><span class=\"w\"> </span><span class=\"n\">sig</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">head</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">VectorExpr</span><span class=\"w\"> </span><span class=\"n\">sig</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">expr</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">tail</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">VectorExpr</span><span class=\"w\"> </span><span class=\"n\">sig</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">VectorExpr</span><span class=\"w\"> </span><span class=\"n\">sig</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>with the above, <code>VectorExpr arities .expr</code> is accepted by match expressions. However:</p>\n<ul>\n<li>It restricts us to only finite arities. With function pattern matching, <code>Expr</code> would be more user-friendly with finite signatures, and still accept infinite signatures in the general case.</li>\n<li>Additional boilerplate is required for destructuring VectorExpr. Things that were trivial like \"There exists an argument such that\" now aren't. Imagine defining an interpretation function for these expressions. It gets more complicated as you find yourself reimplementing list traversal every time. (You can't just define a helper traversal function as that breaks structural termination checking.)</li>\n</ul>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Example of successfully matching on VectorExpr</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>def pairArities.arity: pairSignature.Op → Nat\n| .null =&gt; 0\n| .pair =&gt; 2\n\ndef pairArities: Arities := { Op := pairSignature.Op, arity := pairArities.arity }\n\nabbrev PairExpr := VectorExpr pairArities .expr\ndef PairExpr.null: PairExpr := VectorExpr.op .null VectorExpr.nil\ndef PairExpr.pair (a b: PairExpr): PairExpr :=\n  VectorExpr.op .pair (VectorExpr.cons a (VectorExpr.cons b VectorExpr.nil))\n\ninductive PairExpr.IsSubset: PairExpr → PairExpr → Prop\n| null: IsSubset .null .null\n| pair {la lb ra rb} (subL: IsSubset la lb) (subR: IsSubset ra rb): IsSubset (.pair la ra) (.pair lb rb)\n\ndef PairExpr.IsSubset.foo {la ra lb rb} (sub: IsSubset (.pair la ra) (.pair lb rb)): IsSubset la lb :=\n  match sub with\n  | .pair subL _ =&gt; subL\n\ndef PairExpr.sumVars: PairExpr → Nat\n| .var x =&gt; x\n| .null =&gt; 0\n| .pair a b =&gt; a.sumVars + b.sumVars\n</code></pre></div>\n\n</div></div>",
        "id": 555054465,
        "sender_full_name": "Jozef Mikušinec",
        "timestamp": 1762935106
    },
    {
        "content": "<p>unfortunately these are not syntactically equal</p>",
        "id": 555102421,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762949540
    },
    {
        "content": "<p>because of the variables</p>",
        "id": 555102465,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762949552
    },
    {
        "content": "<p>you would need to know that it's injective wrt the variables for the unification to be sound</p>",
        "id": 555102602,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762949588
    },
    {
        "content": "<p>But they are syntactically equal <em>up to the variables to be unified</em>, are they not?</p>",
        "id": 555115732,
        "sender_full_name": "Jozef Mikušinec",
        "timestamp": 1762953305
    },
    {
        "content": "<p>notice how when I change your example a little bit it becomes unsound to unify the variable</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">ArityZero</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zth</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ArityZero</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ArityZero</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">NoNats</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ArityZero</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">OneNatWrapper</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NoNats</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OneNatWrapper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zth</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">NoNats</span><span class=\"bp\">.</span><span class=\"n\">subsingleton</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subsingleton</span><span class=\"w\"> </span><span class=\"n\">NoNats</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">allEq</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ArityZero</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">wrapZero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OneNatWrapper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zth</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">wrapOne</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OneNatWrapper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zth</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">NoNats</span><span class=\"bp\">.</span><span class=\"n\">subsingleton</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zth</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zth</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">wrapZero_ne_wrapOne</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">wrapZero</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">wrapOne</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">OneNatWrapper</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">OneNatWrapper</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_ne_one</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">NoNats</span><span class=\"bp\">.</span><span class=\"n\">subsingleton</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zth</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zth</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">OneNatWrapper</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">extract</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OneNatWrapper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zth</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"c1\">-- uhoh</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n\n<span class=\"c1\">-- contradiction!</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">wrapZero_eq_wrapOne</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">wrapZero</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">wrapOne</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">extract</span><span class=\"w\"> </span><span class=\"n\">wrapOne</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>",
        "id": 555118650,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762954119
    },
    {
        "content": "<p>Due in part to a related problem and also due to some limitations of the structural recursion compiler the workaround I have been using is to pass a <code>(sc : ...) (hsc : sc = ...)</code> everywhere and have <code>sc</code> in all the types so when I match on them it unifies the free variable <code>sc</code> and now I have an <code>hsc</code> I can work with.</p>",
        "id": 555121583,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762954935
    },
    {
        "content": "<p>Ouch.</p>\n<p>Would it be too much of a hack to only support functions whose domains are inductives whose constructors have no parameters? This should still cover lots of common cases, and we could guarantee soundness if the function just enumerates all its values for all its inputs, is that correct?</p>",
        "id": 555144329,
        "sender_full_name": "Jozef Mikušinec",
        "timestamp": 1762960128
    },
    {
        "content": "<p>Thank you for the counterexample</p>",
        "id": 555144654,
        "sender_full_name": "Jozef Mikušinec",
        "timestamp": 1762960173
    }
]