[
    {
        "content": "<p>It's very easy to forget <code>Id.run</code> and <code>pure</code> when working with the Id monad, resulting in defeq issues when silently casting between <code>X</code> and <code>Id X</code>. While core is now mostly free of these as of <a href=\"https://github.com/leanprover/lean4/pull/7352\">lean4#7352</a>, it's still easy for them to end up reappearing in downstream projects, which lead users down dead ends like <code>simp [Id.run, Pure.pure, Bind.bind]</code>, leaving them with a bad goal state.</p>\n<p>Should <code>Id</code> be redefined as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Not simp-normal, use Pure.pure instead. -/</span>\n<span class=\"w\">  </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">::</span>\n<span class=\"w\">  </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Pure</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">pure</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">pure_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Pure</span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>such that it is impossible to make this mistake?</p>",
        "id": 575920947,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772075042
    },
    {
        "content": "<p>What's the difference between using a single element structure and removing <code>@[expose]</code> as a way to prevent defeqs?</p>",
        "id": 575925362,
        "sender_full_name": "Niels Voss",
        "timestamp": 1772077893
    },
    {
        "content": "<p>With a 1-field structure, you still have <code>.mk a.run = a</code> as a defeq.</p>",
        "id": 575925868,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1772078182
    },
    {
        "content": "<p>Another difference is that for the 1-field structure, <code>Id X = X</code> (or equivalently, <code>Id = id</code>) becomes independent of Lean, which occasionally matters</p>",
        "id": 575926987,
        "sender_full_name": "Niels Voss",
        "timestamp": 1772078845
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/270676-lean4/topic/Should.20Id.20be.20a.20structure.3F/near/575925868\">said</a>:</p>\n<blockquote>\n<p>With a 1-field structure, you still have <code>.mk a.run = a</code> as a defeq.</p>\n</blockquote>\n<p><code>run (pure x) = x</code> is the one we care about</p>",
        "id": 575933660,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772082856
    },
    {
        "content": "<p>YES please! When I was implementing automatic differentiation for monadic code the defeq abuse was a major pain point. At some point I just gave up an defined my own id monad.</p>",
        "id": 575955071,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1772093050
    }
]