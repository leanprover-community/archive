[
    {
        "content": "<p>Is the following grind failure known? (It fails both on latest mathlib and on Lean nightly)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- works</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n\n<span class=\"c1\">-- fails</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n</code></pre></div>\n<p>(<code>cc</code> succeeds here)</p>",
        "id": 536398074,
        "sender_full_name": "Christian Merten",
        "timestamp": 1756293742
    },
    {
        "content": "<p><a href=\"#narrow/channel/270676-lean4/topic/.60grind.60.20with.20partial.20application\">#lean4 &gt; &#96;grind&#96; with partial application</a></p>",
        "id": 536398575,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756293973
    },
    {
        "content": "<p>The underlying cause might be the same, but this example does not involve any e-matching.</p>",
        "id": 536399289,
        "sender_full_name": "Christian Merten",
        "timestamp": 1756294259
    },
    {
        "content": "<p>Yes, this is by design.</p>",
        "id": 536417323,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1756300336
    },
    {
        "content": "<p>Could you elaborate on why this is expected or is this documented somewhere? I could not find anything related to this in the language reference.<br>\nIs there a way to make grind succeed here (by providing some arguments for example)?</p>",
        "id": 536419048,
        "sender_full_name": "Christian Merten",
        "timestamp": 1756300862
    },
    {
        "content": "<p>Multiple people already had that problem. :C<br>\nI hope this will be addressed. I'm not familiar with <code>grind</code>'s code so looking at this myself would be a huge work.</p>",
        "id": 538417078,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1757418499
    },
    {
        "content": "<p>You can add <code>set_option trade.grind.debug true</code> to see representation of an e-graph:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"bp\">#</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">val</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">#</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">val</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">#</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ctor</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">#</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ctor</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">#</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">val</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">#</span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"bp\">.</span><span class=\"n\">eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ctor</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">#</span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"mi\">8</span>\n<span class=\"w\">    </span><span class=\"bp\">#</span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">    </span><span class=\"bp\">#</span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">    </span><span class=\"bp\">#</span><span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Eq</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"mi\">11</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"mi\">13</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"bp\">#</span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">    </span><span class=\"bp\">#</span><span class=\"mi\">11</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"mi\">12</span>\n<span class=\"w\">    </span><span class=\"bp\">#</span><span class=\"mi\">12</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">    </span><span class=\"bp\">#</span><span class=\"mi\">13</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"mi\">12</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"bp\">#</span><span class=\"mi\">8</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"mi\">6</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"bp\">#</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"mi\">9</span><span class=\"o\">}</span>\n</code></pre></div>\n<p><code>f a m</code> belongs to <code>#11</code> and <code>f a</code> (I think, not sure) belongs to <code>#6</code>. I don't know why 2-ary application isn't represent as two 1-ary applications. This way, instead of <code>#11 := #7 #8 #12</code> we would get <code>#11 := #6 #12</code>, and grind would succeed.</p>",
        "id": 538445272,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1757426447
    },
    {
        "content": "<p><del>I think it might be implemented this way, because current code isn't able to match patterns across multiple e-nodes. So to be able to match n-ary patterns the whole n-ary expression must be stored in one e-node.</del><br>\nThis is probably not a problem, the whole expressions are stored in e-nodes and 1-ary application can always be treated as n-ary.</p>",
        "id": 538446283,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1757426698
    },
    {
        "content": "<p><a href=\"https://arxiv.org/pdf/1701.04391\">https://arxiv.org/pdf/1701.04391</a></p>\n<p>I think this is the paper grind algorithm is based upon? In the paper the proposed congruent procedure is:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>procedure congruent(D, E)\n  (f, a) ‚Üê app(D); (g, b) ‚Üê app(E)\n  return a ‚âà b and\n    [(f ‚âà g and type(f) ‚â° type(g)) or\n      (f and g are local definitions and congruent(def(f), def(g)))]\n</code></pre></div>\n<p>And I think that what is currently implemented in lean4 is</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>procedure congruent(D, E)\n  (f, a) ‚Üê app(D); (g, b) ‚Üê app(E)\n  return a ‚âà b and\n    [if f and g are both applications\n      then congruent(def(f), def(g))\n      else f ‚âà g and type(f) ‚â° type(g)]\n</code></pre></div>\n<p>I.e. if <code>f</code> and <code>g</code> are applications they're being eagerly unfolded.</p>\n<p>Similarly the proposed congrhash procedure:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>procedure congrhash(D)\n  given: `h`, a hash function on terms\n  (f, a) ‚Üê app(D)\n  return hashcombine(h(repr[f]), h(repr[a]))\n</code></pre></div>\n<p>is implemented in lean4 as</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>procedure congrhash(D)\n  given: `h`, a hash function on terms\n  (f, a) ‚Üê app(D)\n  if f is application then\n    return hashcombine(congrhash(f), h(repr[a]))\n  else\n    return hashcombine(h(repr[f]), h(repr[a]))\n</code></pre></div>\n<p>The \"local definition\" part was replaced with checking if expression is application, which I think is fine. We don't want grind to automatically unfold definitions.<br>\nBut we shouldn't eagerly unfold applications until reaching head expression. I think that implementing the congruence algorithm as described in the paper would fix the issue.</p>",
        "id": 538546465,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1757460492
    },
    {
        "content": "<p>Looks like this was fixed in nightly. <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 561833138,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764841456
    },
    {
        "content": "<p>Or not? It seems like this particular case works, by doesn't in this other example <a href=\"#narrow/channel/270676-lean4/topic/.60grind.60.20should.20unfold.20projections/near/538388380\">#lean4 &gt; &#96;grind&#96; should unfold projections @ üí¨</a></p>",
        "id": 561835528,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764842229
    },
    {
        "content": "<p>Maybe <code>grind</code> learned how to rewrite equalities in head expressions, but still can't match grind patterns when head expression is an e-class?</p>",
        "id": 561836226,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764842423
    },
    {
        "content": "<p>Relevant PR: <a href=\"https://github.com/leanprover/lean4/pull/11323\">https://github.com/leanprover/lean4/pull/11323</a></p>",
        "id": 561858408,
        "sender_full_name": "Th√©ophile",
        "timestamp": 1764849424
    }
]