[
    {
        "content": "<p>Does the order of imports affect the correctness or behavior of a Lean program?</p>\n<p>More specifically: Are there any scenarios where reordering the import statements in a Lean file could result in changes to the program's correctness, introduce errors, or alter its runtime behavior?</p>",
        "id": 466733720,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1725209902
    },
    {
        "content": "<p>Actually, several things can go wrong, the simplest one of which is that a timeout may occur since lean may end up going via a \"longer\" path than previously.</p>",
        "id": 466733859,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725209965
    },
    {
        "content": "<p>There was at some point a proposal or reordering alphabetically <em>all</em> import statements, almost all worked as intended with the alphabetical replacement, some timed out, but would still work increasing the time limit, but one of them I was not able to fix.</p>",
        "id": 466734009,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725210026
    },
    {
        "content": "<p>Was that purely a problem with the instance inference not finding the right instances in time or using wrong ones first?</p>",
        "id": 466735643,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1725210786
    },
    {
        "content": "<p>At least, it's not possible in Lean to import a certain declaration twice, so reordeing imports would not change terms etc. which are actually written out explicitly, right?</p>",
        "id": 466735842,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1725210896
    },
    {
        "content": "<p>I could not debug the one that kept failing no matter the time limit (it was in... norm_num, maybe?).  The others I think that it was instance inference: sometimes, it just had to wade through useless stuff, other times, it may have found a \"wrong\" one.  Let me see if I can find the PR.</p>",
        "id": 466735995,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725210994
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/6763\">#6763</a></p>",
        "id": 466736025,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725211032
    },
    {
        "content": "<p>In the PR, you can also find a <a href=\"#narrow/stream/287929-mathlib4/topic/Alphabetical.20listing.20of.20imports\">link to a Zulip discussion</a> about it.</p>",
        "id": 466736200,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725211181
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span>â€”this was a very interesting read! It's quite surprising (at least to me) that the order of imports can have such a significant impact in certain pathological cases. I'm trying to determine whether any of these cases indicate bugs in Lean, or if everything is functioning as intended.</p>\n<p>Are there two distinct issues here: one leading to a compilation error and another causing a compilation timeout? Can we construct a minimal working example (<a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>) for each scenario?</p>\n<p>Assuming the compilation is successful, would it be theoretically possible for a change in import order to alter runtime behavior? Can we come up with an example of such a scenario?</p>",
        "id": 466744503,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1725215312
    },
    {
        "content": "<p>So just to elaborate on the instance order, here's a small mock example where a \"change of imports\" does alter your program output:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Init</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">ToString</span><span class=\"bp\">.</span><span class=\"n\">Basic</span><span class=\"w\"> </span><span class=\"c1\">-- contains `instToStringNat`</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">IO</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ToString</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">println</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"you entered {n}\"</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\">        </span><span class=\"c1\">-- you entered 1</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">ToString</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"c1\">-- instToStringNat</span>\n\n<span class=\"c1\">-- assume: due to changed import order, this now has higher priority.</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">badInstance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToString</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"42\"</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\">        </span><span class=\"c1\">-- you entered 42</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">ToString</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"c1\">-- badInstance</span>\n</code></pre></div>\n<p>This is equivalent to having the <code>badInstance</code> in a second file that's either imported before or after the existing import.</p>\n<p>This isn't a bug in Lean, but rather a bad setup by the person adding <code>badInstance</code>. Now, in mathlib it's much more complicated because there is a huge hierarchy of structures, you do want to have multiple paths how to synthesise certain instances, and you have to set your instances up correctly. (In the linked discussion they mention the <code>Subalgebra.toX</code> instances which took higher priority than they should)</p>\n<p>Same should apply for implicit arguments <code>{_ : _}</code>, but I'd think that's less commonly a problem because of how they are resolved.</p>\n<p>It's also thinkable that a tactic is dependent on the order things are in the environment. For example (not exactly the same as import order, but maybe it's still close enough)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"w\">  </span><span class=\"n\">assumption</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"n\">assumption</span>\n\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\">   </span><span class=\"c1\">-- 3</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"c1\">-- 2</span>\n</code></pre></div>\n<p>here I would say isn't a bug in <code>assumption</code> but rather a mistake by the person using <code>assumption</code> in a definition.</p>\n<p>I guess my main point is that I believe while it's certainly a bug if the order of imports changes the behaviour of your code, it's most likely not a bug in Lean itself but rather bugs in tactic code or library setups.</p>",
        "id": 466758059,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1725222451
    },
    {
        "content": "<p>I agree with Jon's point of view: \"good\" code should probably be independent of import order, but whether it is or not, I do not consider the <em>possibility</em> of writing import-order-depending code as a bug in Lean necessarily.</p>",
        "id": 466760226,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725223867
    },
    {
        "content": "<p>As for code behaviour, you could write a linter that checks whether the imports are sorted alphabetically and logs a warning otherwise: this is certainly import-order-dependent code!</p>",
        "id": 466760381,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725223933
    }
]