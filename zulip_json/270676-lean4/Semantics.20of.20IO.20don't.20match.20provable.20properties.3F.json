[
    {
        "content": "<p>I was experimenting with the <code>IO</code> monad and noticed that it was defined using <code>EStateM</code> and <code>IO.RealWorld</code>. I was worried that this gives you too much control over the monad, to the point where you can \"reset time\" by saving and restoring an old version of the world.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">set_option</span><span class=\"w\"> </span><span class=\"n\">autoImplicit</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">world</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">println</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"s2\">\"hello\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">world</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"c1\">-- force evaluation of r</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">EStateM.Result.ok</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"c1\">-- irreducible computation to prevent optimization</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">println</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"s2\">\"ok\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">world</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">println</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"s2\">\"ok2\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">world</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">EStateM.Result.error</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">println</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"s2\">\"ok\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">world</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">run_eq_ok</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">println</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"s2\">\"ok\"</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"n\">w</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">run</span>\n<span class=\"w\">  </span><span class=\"n\">aesop</span>\n\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">run</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">hello</span>\n<span class=\"cm\">ok</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>Here, <code>run</code> prints both \"hello\" and \"ok\", but we can prove that it only prints \"ok\". Of course, the problem comes down to the fact that we are using the same <code>IO.RealWorld</code> value twice. But I think this problem could have been avoided if IO was made into an opaque monad instead of something easily unfoldable. Do I basically have to accept that proofs about the properties of IO functions are meaningless because their logical representation doesn't match their behavior?</p>",
        "id": 485680245,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733162372
    },
    {
        "content": "<p>it gets worse if you look at the definition of <code>IO.RealWorld</code> <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 485682447,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1733163139
    },
    {
        "content": "<p>it's not even opaque</p>",
        "id": 485682473,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1733163152
    },
    {
        "content": "<p>I assumed that would get fixed eventually. But the ability to use values of <code>IO.RealWorld</code> twice seems like a very deep issue.</p>",
        "id": 485682726,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733163255
    },
    {
        "content": "<p>Lean doesn't have support for <a href=\"https://en.wikipedia.org/wiki/Substructural_type_system\">affine types</a>, which could address this. (Or inventing time travel so if you use an old version of the world you can just go back in time <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>)</p>\n<p>Another issue is that even if you had this, things like IO.Ref have no axioms, and Mario thinks the obvious axioms might even lead to inconsistencies.</p>",
        "id": 485683788,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733163716
    },
    {
        "content": "<p>I mean, any axioms for IO.Ref would almost certainly be unsound if you could just send the world back in time. Would changing IO to an opaque monad fix these issues, or would it lead to the same problems?</p>",
        "id": 485684632,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733164021
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Semantics.20of.20IO.20don't.20match.20provable.20properties.3F/near/485683788\">said</a>:</p>\n<blockquote>\n<p>(Or inventing time travel so if you use an old version of the world you can just go back in time <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>)</p>\n</blockquote>\n<p>maybe you may have the compiler optimise the first print away, to make this consistent?</p>",
        "id": 485684721,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1733164059
    },
    {
        "content": "<p>It actually took me a while to get a program where the compiler <em>didn't</em> optimize the first print away. That's why I had to use <code>Rat</code> in my example, since it is complicated enough that the compiler couldn't deduce that <code>(0 : Rat) = 0</code> is defeq to <code>True</code>.</p>\n<p>However, I suspect that optimizing  the first print away in general is an undecidable problem. Especially because that first print could have instead been a <code>readLine</code> that returned a useful value, that we later use in conjunction with the old world.</p>",
        "id": 485685440,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733164290
    },
    {
        "content": "<p>Is there any way in which Lean can support something that behaves semantically like affine types without having to modify the kernel?</p>",
        "id": 485685799,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733164432
    },
    {
        "content": "<p>I doubt there's a \"sufficiently smart compiler\" that would solve the issue through optimization; that readLine example points to it not just being undecidable, but impossible.</p>",
        "id": 485685811,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733164437
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/270676-lean4/topic/Semantics.20of.20IO.20don't.20match.20provable.20properties.3F/near/485684632\">said</a>:</p>\n<blockquote>\n<p>Would changing IO to an opaque monad fix these issues, or would it lead to the same problems?</p>\n</blockquote>\n<p>Sorry, I don't know, though my suspicion would be that without proper affine type support there are bound to be other semantic leaks. I don't know if there are well-known tricks in the literature though.</p>",
        "id": 485686058,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733164521
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/270676-lean4/topic/Semantics.20of.20IO.20don't.20match.20provable.20properties.3F/near/485685799\">said</a>:</p>\n<blockquote>\n<p>Is there any way in which Lean can support something that behaves semantically like affine types without having to modify the kernel?</p>\n</blockquote>\n<p>You should be able to bolt an affine type checker on top of Lean. I don't know if I have the correct link, but here's an example of homotopy type theory in Lean 4: <a href=\"https://github.com/forked-from-1kasper/ground_zero\">https://github.com/forked-from-1kasper/ground_zero</a> It adds an extra checker to make sure that theorems are only doing HoTT-appropriate things. The trusted code base would expand to include your checker and some amount of the elaborator.</p>",
        "id": 485686393,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733164672
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Semantics.20of.20IO.20don't.20match.20provable.20properties.3F/near/485686393\">said</a>:</p>\n<blockquote>\n<p>You should be able to bolt an affine type checker on top of Lean. I don't know if I have the correct link, but here's an example of homotopy type theory in Lean 4: <a href=\"https://github.com/forked-from-1kasper/ground_zero\">https://github.com/forked-from-1kasper/ground_zero</a> It adds an extra checker to make sure that theorems are only doing HoTT-appropriate things.</p>\n</blockquote>\n<p>Maybe this could be used in conjunction with something like <code>Part</code>, which would prevent the code from being run unless it was proven to be safe. (I was also thinking of how <code>Part</code> could in theory let you write unsafe code with stuff like <code>malloc</code> and <code>free</code> but not actually run it unless it was safe)</p>",
        "id": 485687215,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733164931
    },
    {
        "content": "<p>i suppose ideally we'd have all IO things be defined with partial?</p>",
        "id": 485687867,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1733165176
    },
    {
        "content": "<p>or would that be annoying?</p>",
        "id": 485687889,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1733165186
    },
    {
        "content": "<p>well maybe we should leave <code>IO</code> alone because so much depends on it and just accept that proofs about <code>IO</code> are useless, but it might be good to have a more safe monad that was actually semantically valid that would be good enough to replace <code>IO</code> in most cases</p>",
        "id": 485688281,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733165338
    },
    {
        "content": "<p>I was originally thinking that we could define something like <code>AffineM T : Type -&gt; Type := StateT T Part</code> but I'm actually not sure that's good enough</p>",
        "id": 485688607,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733165451
    },
    {
        "content": "<p>Yeah, often there's the \"programming type\" and the \"proving type\". If there's a \"proving IO\" with good semantics, then you would need to extend your trusted code base with the \"proving IO -&gt; programming IO\" evaluator, which is probably not that much code.</p>",
        "id": 485688912,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733165561
    },
    {
        "content": "<p>I believe that making <code>IO</code> opaque (such that you can't even tell it's a function type) would be sufficient to avoid leaks related to time travelling tokens because the token wouldn't be available in the first place. But the issue Kyle mentioned about IO.Ref is deeper than that and would still be the case even if everything related to IO.Ref was opaque (it already is to a great extent), because it has to do with the fact that <code>IO.Ref</code> can be used to construct state larger than an <code>IO Unit</code> value could store (by cardinality considerations, just by virtue of being a type living at a fixed universe)</p>",
        "id": 485701707,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733170579
    },
    {
        "content": "<p>Have you thought about any solutions to that problem <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>?</p>\n<p>Maybe there could be an inductive type <code>T</code> that represents all the values that an IO.Ref could store, and the interface requires an injective function from your type to <code>T</code> and a decoding function. Theoretically <code>IO.Ref</code> uses <code>T</code>, but behind the scenes the runtime would just use your type directly.</p>",
        "id": 485702266,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733170875
    },
    {
        "content": "<p>Yeah, I had a demo that did basically that somewhere</p>",
        "id": 485702317,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733170904
    },
    {
        "content": "<p>it was mediated by a typeclass so you didn't have to do too much work</p>",
        "id": 485702395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733170925
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ST'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">StateM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">ST'</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsRef</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ω</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Ref</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">IsRef</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mkRef</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsRef</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ST'</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ref</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inst</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Ref</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@&amp;</span><span class=\"w\"> </span><span class=\"n\">Ref</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ST'</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">m</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">]</span><span class=\"bp\">?.</span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get!</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- ignore the `get!` here</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Ref</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@&amp;</span><span class=\"w\"> </span><span class=\"n\">Ref</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ST'</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">((),</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">set!</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ω</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ST'</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[])</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n</code></pre></div>",
        "id": 485702480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733170970
    },
    {
        "content": "<p>could you give a concrete example of an issue that <code>IO.Ref</code> causes?</p>",
        "id": 485704324,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1733171736
    },
    {
        "content": "<p>because i don't quite get what the problem is</p>",
        "id": 485704365,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1733171752
    },
    {
        "content": "<p>I don't have an actual proof of false, so it's a bit handwavy</p>",
        "id": 485704470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733171784
    },
    {
        "content": "<p>any anecdotal evidence?</p>",
        "id": 485705154,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1733172059
    },
    {
        "content": "<p>because from my understanding, i don't quite see how <code>IO.Ref</code> creates \"too large\" <code>IO Unit</code>s</p>",
        "id": 485705418,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1733172182
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Logic</span><span class=\"bp\">.</span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"c1\">-- this type parameter doesn't matter</span>\n\n<span class=\"c1\">-- For fixed r, this function has type α → ST σ Unit.</span>\n<span class=\"c1\">-- But it's injective? `α` need not be smaller than `ST σ Unit`</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">set'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ST</span><span class=\"bp\">.</span><span class=\"n\">Ref</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ST</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ST</span><span class=\"bp\">.</span><span class=\"n\">Ref</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ST</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ST</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">get</span>\n\n<span class=\"c1\">-- this is not exactly true, but this is the idea</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">set'_inv</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ST</span><span class=\"bp\">.</span><span class=\"n\">Ref</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">set'</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"c1\">-- reasonable axiom because `runST` allows you to get the `α` out</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">pure_inj</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ST</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- so what happens if `α := (ST σ Unit -&gt; Prop)`?</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PLift</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">runST</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">ST</span><span class=\"bp\">.</span><span class=\"n\">mkRef</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ST</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">set'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">set'</span><span class=\"w\"> </span><span class=\"n\">r</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"n\">r</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">set'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">set'_inv</span><span class=\"w\"> </span><span class=\"n\">r</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Injective</span><span class=\"w\"> </span><span class=\"n\">set'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">congr_arg</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">H</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">pure_inj</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"k\">nomatch</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">cantor_injective</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">this</span>\n</code></pre></div>",
        "id": 485707107,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733172895
    }
]