[
    {
        "content": "<p>I am wondering how to manually prove some falsity in Lean4, such as proving <code>0 ≠ 1</code> and <code>¬(Even 1)</code>.</p>\n<p>Although the <code>cases</code> tactic can eliminate those impossible subgoals, I prefer to solve them manually for enjoyment.</p>\n<div class=\"codehilite\" data-code-language=\"lean4\"><pre><span></span><code>-- by simp\nexample : 1 ≠ 0 := by simp\n\n-- by cases\nexample : 1 ≠ 0 := by\n  intro h\n  cases h\n</code></pre></div>\n<p>I am able to prove <code>0 ≠ 1</code> using the <code>rewrite</code> tactic.</p>\n<div class=\"codehilite\" data-code-language=\"lean4\"><pre><span></span><code>-- by rewrite\ndef is_zero : Nat → Prop\n  | .zero =&gt; True\n  | .succ _ =&gt; False\n\nexample : (0 = 1) → False := by\n  have h_0_eq_0 : is_zero 0 = is_zero 0 := rfl\n  intro h_0_eq_1\n  conv at h_0_eq_0 =&gt; {\n    left\n    rw [h_0_eq_1]\n  }\n  have h_false_eq_true : False = True := h_0_eq_0\n  rewrite [h_false_eq_true]\n  exact trivial\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"lean4\"><pre><span></span><code>-- even by crazy recOn!\ndef f : Nat → Prop :=\n  @Nat.rec (fun _ =&gt; Prop) False (fun _ _ =&gt; True)\n\nexample (n : Nat) : (.succ n = 0) → False :=\n  fun e =&gt; @Eq.subst _ f (.succ n) 0 e True.intro\n</code></pre></div>\n<p>And to prove <code>Even 1</code> is false by <code>cases</code>.</p>\n<div class=\"codehilite\" data-code-language=\"lean4\"><pre><span></span><code>example : ¬(Even 1) := by\n  intro h\n  cases h\n</code></pre></div>\n<p>But I am unsure how to prove <code>¬(Even 1)</code> manually, can someone show the proof and put some materials about this?</p>\n<div class=\"codehilite\" data-code-language=\"lean4\"><pre><span></span><code>inductive Even : Nat → Prop where\n  | zero : Even 0\n  | add_two : (k : Nat) → Even k → Even (k + 2)\n\nexample : ¬(Even 1) := by\n  intro h\n  sorry -- How?\n</code></pre></div>\n<p>Thank you all!</p>",
        "id": 407911689,
        "sender_full_name": "y-samuel",
        "timestamp": 1702544093
    },
    {
        "content": "<p>You can always #print a lemma to see the proof. This will be using <code>noConfusion</code></p>",
        "id": 407912785,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1702544509
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/270676-lean4/topic/How.20to.20prove.20.60.C2.AC.28Even.201.29.60.20manually.3F/near/407912785\">said</a>:</p>\n<blockquote>\n<p>You can always #print a lemma to see the proof. This will be using <code>noConfusion</code></p>\n</blockquote>\n<p>Magic #print! Thank you!</p>",
        "id": 407922681,
        "sender_full_name": "y-samuel",
        "timestamp": 1702547630
    },
    {
        "content": "<p>I wonder if there is a method based on typed pattern matching?</p>",
        "id": 407934173,
        "sender_full_name": "y-samuel",
        "timestamp": 1702551256
    },
    {
        "content": "<p>If you try pattern match, it will give you type errors. You need to use the <code>nomatch</code> keyword, or the <code>match h with .</code> extension in Std (Std/Tactic/NoMatch)</p>",
        "id": 407934465,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1702551363
    },
    {
        "content": "<p>(sorry, I think <code>nomatch</code> is mathlib/std)</p>",
        "id": 407934684,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1702551428
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">Even</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">↦</span> <span class=\"n\">nomatch</span> <span class=\"n\">h</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">as</span>\n</code></pre></div>",
        "id": 407934743,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1702551446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/270676-lean4/topic/How.20to.20prove.20.60.C2.AC.28Even.201.29.60.20manually.3F/near/407934684\">said</a>:</p>\n<blockquote>\n<p>(sorry, I think <code>nomatch</code> is mathlib/std)</p>\n</blockquote>\n<p>it's actually the other way round!</p>",
        "id": 407935392,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1702551657
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/270676-lean4/topic/How.20to.20prove.20.60.C2.AC.28Even.201.29.60.20manually.3F/near/407934465\">said</a>:</p>\n<blockquote>\n<p>If you try pattern match, it will give you type errors. You need to use the <code>nomatch</code> keyword, or the <code>match h with .</code> extension in Std (Std/Tactic/NoMatch)</p>\n</blockquote>\n<p>Oh, Very Thank You!<br>\nI thought how to turn type errors in pattern matching into some information (like mata-programming, I am not sure) indeed!<br>\nI think I should read \"The Little Typer\" because I remember this book use recursor directly.</p>",
        "id": 407938154,
        "sender_full_name": "y-samuel",
        "timestamp": 1702552620
    },
    {
        "content": "<p>Generally speaking, programming and proving with recursors directly is quite dreadful. Tactics and pattern matching is much easier! But knowing how they work is part of the fun, and that's what you're doing here, so in that spirit I'll translate a bit of code from The Little Typer into Lean for you. Apologies in advance for unidiomatic Lean - I'm trying to connect Lean syntax to the book, rather than follow proper Lean naming conventions.</p>\n<p>The first step is getting your hands on a recursor. Lean makes one for each inductive type, and it's used to justify the termination of recursive definitions with pattern matching, but let's pretend that we need to write our own in order to get something that looks more like the one in Pie:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">indNat</span> <span class=\"o\">(</span><span class=\"n\">mot</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">mot</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">mot</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">mot</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">tgt</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">mot</span> <span class=\"n\">tgt</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">base</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">step</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">indNat</span> <span class=\"n\">mot</span> <span class=\"n\">base</span> <span class=\"n\">step</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It sounds like you understand recursors already, so I won't get into this more. To check your understanding, write the equivalent for lists and binary trees.</p>\n<p>To do the kind of thing you want to do, we need to build the \"no confusion\" lemma for <code>Nat</code>. This states that the constructors of <code>Nat</code> are disjoint (that is, zero never equals successor) and injective (equal successors means their arguments are equal). The way we do this is a bit formulaic, but the explanations in the literature are not so accessible in my opinion - I had a hard time learning them, at least!</p>\n<p>Note that \"no confusion\" says \"assume that these Nats are equal\" and then after that says what the consequences of that equality are. If they're both zero, there's nothing learned. If they're a mix of zero and successor, then their equality implies falsehood (this is the disjointness bit). If they're both successor, then their equality implies the equality of the smaller <code>Nat</code>s under the <code>succ</code> constructor. The \"consequences of equality\" bit can be captured in this function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">IfEqual</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">k</span>\n</code></pre></div>\n<p>Generally, there's $n^2$ cases for $n$ constructors, and all the off-diagonal ones are <code>False</code> while the on-diagonal ones are the conjunction of the equalities of the constructor arguments.</p>\n<p>Exercises:</p>\n<ol>\n<li>Rewrite <code>IfEqual</code> using <code>indNat</code></li>\n<li>Create the corresponding <code>IfEqual</code> for lists and for binary trees</li>\n</ol>\n<p>The type of \"no confusion\" is now <code>(n k : Nat) (eq : n = k) : IfEqual n k</code>. Check your understanding by instantiating it with some concrete <code>Nat</code>s and see what the resulting statement says.</p>\n<p>Proving this by induction on <code>n</code> and <code>k</code> is not the way forward, however - the false cases are simply disjointness, but that's what we're trying to prove! A little trick is needed: prove only the on-diagonal cases!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ifEqualSelf</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IfEqual</span> <span class=\"n\">n</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"n\">indNat</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">IfEqual</span> <span class=\"n\">k</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">True.intro</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>Like <code>IfEqual</code>, this isn't really recursive. Here's another exercise: use <code>indNat</code> to define <code>casesNat</code>, which is like <code>indNat</code> without an induction hypothesis, and then use it here.</p>\n<p>Given the diagonal case, substitution can be used with the equality assumption to prove \"no confusion\" (which I've renamed a bit here to match The Little Typer as best as I remember it - my PDF is on the other computer and the paper version under a pile of stuff right now):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ifEqualThenWhat</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IfEqual</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n  <span class=\"n\">eq</span> <span class=\"bp\">▸</span> <span class=\"n\">ifEqualSelf</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>This says that if two numbers are equal, then the consequences of that equality hold. Expanding out the four cases for <code>n</code> and <code>k</code>, this is injectivity and disjointness of constructors.</p>\n<p>This is super annoying to use. Here's some examples:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">zeroNotOne</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"n\">ifEqualThenWhat</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"n\">eq</span>\n<span class=\"kd\">def</span> <span class=\"n\">zeroNotTwo</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"n\">ifEqualThenWhat</span> <span class=\"mi\">0</span> <span class=\"mi\">2</span> <span class=\"n\">eq</span>\n<span class=\"kd\">def</span> <span class=\"n\">oneNotThree</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">ifEqualThenWhat</span> <span class=\"mi\">1</span> <span class=\"mi\">3</span> <span class=\"n\">eq</span>\n  <span class=\"n\">ifEqualThenWhat</span> <span class=\"mi\">0</span> <span class=\"mi\">2</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>Exercise: prove that eight doesn't equal fifteen. Write it out in full with no underscores.</p>\n<p>This can be used with the recursor to implement decidable equality of <code>Nat</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Decidable</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">decNatEq</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">indNat</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">indNat</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"n\">isTrue</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">k'</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"n\">ifEqualThenWhat</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">k'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))))</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n'</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">indNat</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">n'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">))</span>\n        <span class=\"o\">(</span><span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"n\">ifEqualThenWhat</span> <span class=\"o\">(</span><span class=\"n\">n'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n        <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">k'</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n           <span class=\"k\">match</span> <span class=\"n\">ih</span> <span class=\"n\">k'</span> <span class=\"k\">with</span>\n           <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">eq</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isTrue</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">eq</span><span class=\"o\">)</span>\n           <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">notEq</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">k'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n             <span class=\"n\">notEq</span> <span class=\"o\">(</span><span class=\"n\">ifEqualThenWhat</span> <span class=\"o\">(</span><span class=\"n\">n'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>Exercises:</p>\n<ol>\n<li>Extract the three non-recursive cases into helper lemmas</li>\n<li>Replace the uses of <code>▸</code> and pattern matching on <code>Decidable</code> with recursors a la <code>indNat</code></li>\n<li>Use your dependent cases operation from earlier to simplify <code>decNatEq</code></li>\n<li>Generalize this definition to <code>List</code> and binary trees - the list case will require an input proof that the elements have decidable equality. Do all this with recursors.</li>\n</ol>\n<p>By the time you've done all this, you'll have a good idea of what happens behind the scenes! For more info, read <a href=\"http://www.e-pig.org/downloads/concon.pdf\">A Few Constructions on Constructors</a> by McBride, Goguen, and McKinna - it's got all this and more, and its techniques are an important part of what goes on in Lean.</p>",
        "id": 407979870,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1702566264
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"354934\">David Thrane Christiansen</span> <a href=\"#narrow/stream/270676-lean4/topic/How.20to.20prove.20.60.C2.AC.28Even.201.29.60.20manually.3F/near/407979870\">said</a>:</p>\n<blockquote>\n<p>Generally speaking, programming and proving with recursors directly is quite dreadful. Tactics and pattern matching is much easier! But knowing how they work is part of the fun, and that's what you're doing here, so in that spirit I'll translate a bit of code from The Little Typer into Lean for you. Apologies in advance for unidiomatic Lean - I'm trying to connect Lean syntax to the book, rather than follow proper Lean naming conventions.</p>\n<p>The first step is getting your hands on a recursor. Lean makes one for each inductive type, and it's used to justify the termination of recursive definitions with pattern matching, but let's pretend that we need to write our own in order to get something that looks more like the one in Pie:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">indNat</span> <span class=\"o\">(</span><span class=\"n\">mot</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">mot</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">mot</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">mot</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">tgt</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">mot</span> <span class=\"n\">tgt</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">base</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">step</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">indNat</span> <span class=\"n\">mot</span> <span class=\"n\">base</span> <span class=\"n\">step</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It sounds like you understand recursors already, so I won't get into this more. To check your understanding, write the equivalent for lists and binary trees.</p>\n<p>To do the kind of thing you want to do, we need to build the \"no confusion\" lemma for <code>Nat</code>. This states that the constructors of <code>Nat</code> are disjoint (that is, zero never equals successor) and injective (equal successors means their arguments are equal). The way we do this is a bit formulaic, but the explanations in the literature are not so accessible in my opinion - I had a hard time learning them, at least!</p>\n<p>Note that \"no confusion\" says \"assume that these Nats are equal\" and then after that says what the consequences of that equality are. If they're both zero, there's nothing learned. If they're a mix of zero and successor, then their equality implies falsehood (this is the disjointness bit). If they're both successor, then their equality implies the equality of the smaller <code>Nat</code>s under the <code>succ</code> constructor. The \"consequences of equality\" bit can be captured in this function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">IfEqual</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">k</span>\n</code></pre></div>\n<p>Generally, there's $n^2$ cases for $n$ constructors, and all the off-diagonal ones are <code>False</code> while the on-diagonal ones are the conjunction of the equalities of the constructor arguments.</p>\n<p>Exercises:</p>\n<ol>\n<li>Rewrite <code>IfEqual</code> using <code>indNat</code></li>\n<li>Create the corresponding <code>IfEqual</code> for lists and for binary trees</li>\n</ol>\n<p>The type of \"no confusion\" is now <code>(n k : Nat) (eq : n = k) : IfEqual n k</code>. Check your understanding by instantiating it with some concrete <code>Nat</code>s and see what the resulting statement says.</p>\n<p>Proving this by induction on <code>n</code> and <code>k</code> is not the way forward, however - the false cases are simply disjointness, but that's what we're trying to prove! A little trick is needed: prove only the on-diagonal cases!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ifEqualSelf</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IfEqual</span> <span class=\"n\">n</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"n\">indNat</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">IfEqual</span> <span class=\"n\">k</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">True.intro</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>Like <code>IfEqual</code>, this isn't really recursive. Here's another exercise: use <code>indNat</code> to define <code>casesNat</code>, which is like <code>indNat</code> without an induction hypothesis, and then use it here.</p>\n<p>Given the diagonal case, substitution can be used with the equality assumption to prove \"no confusion\" (which I've renamed a bit here to match The Little Typer as best as I remember it - my PDF is on the other computer and the paper version under a pile of stuff right now):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ifEqualThenWhat</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IfEqual</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n  <span class=\"n\">eq</span> <span class=\"bp\">▸</span> <span class=\"n\">ifEqualSelf</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>This says that if two numbers are equal, then the consequences of that equality hold. Expanding out the four cases for <code>n</code> and <code>k</code>, this is injectivity and disjointness of constructors.</p>\n<p>This is super annoying to use. Here's some examples:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">zeroNotOne</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"n\">ifEqualThenWhat</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"n\">eq</span>\n<span class=\"kd\">def</span> <span class=\"n\">zeroNotTwo</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"n\">ifEqualThenWhat</span> <span class=\"mi\">0</span> <span class=\"mi\">2</span> <span class=\"n\">eq</span>\n<span class=\"kd\">def</span> <span class=\"n\">oneNotThree</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">ifEqualThenWhat</span> <span class=\"mi\">1</span> <span class=\"mi\">3</span> <span class=\"n\">eq</span>\n  <span class=\"n\">ifEqualThenWhat</span> <span class=\"mi\">0</span> <span class=\"mi\">2</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>Exercise: prove that eight doesn't equal fifteen. Write it out in full with no underscores.</p>\n<p>This can be used with the recursor to implement decidable equality of <code>Nat</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Decidable</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">decNatEq</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">indNat</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">indNat</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"n\">isTrue</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">k'</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"n\">ifEqualThenWhat</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">k'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))))</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n'</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">indNat</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">n'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">))</span>\n        <span class=\"o\">(</span><span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"n\">ifEqualThenWhat</span> <span class=\"o\">(</span><span class=\"n\">n'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n        <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">k'</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n           <span class=\"k\">match</span> <span class=\"n\">ih</span> <span class=\"n\">k'</span> <span class=\"k\">with</span>\n           <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">eq</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isTrue</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">eq</span><span class=\"o\">)</span>\n           <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">notEq</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">k'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n             <span class=\"n\">notEq</span> <span class=\"o\">(</span><span class=\"n\">ifEqualThenWhat</span> <span class=\"o\">(</span><span class=\"n\">n'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>Exercises:</p>\n<ol>\n<li>Extract the three non-recursive cases into helper lemmas</li>\n<li>Replace the uses of <code>▸</code> and pattern matching on <code>Decidable</code> with recursors a la <code>indNat</code></li>\n<li>Use your dependent cases operation from earlier to simplify <code>decNatEq</code></li>\n<li>Generalize this definition to <code>List</code> and binary trees - the list case will require an input proof that the elements have decidable equality. Do all this with recursors.</li>\n</ol>\n<p>By the time you've done all this, you'll have a good idea of what happens behind the scenes! For more info, read <a href=\"http://www.e-pig.org/downloads/concon.pdf\">A Few Constructions on Constructors</a> by McBride, Goguen, and McKinna - it's got all this and more, and its techniques are an important part of what goes on in Lean.</p>\n</blockquote>\n<p>Thankkkkkk uuuuuuuuu!<br>\nYes, it is fun for me and I want to know the \"details\".<br>\nI will take the time to exercise your ideas!<br>\nAgain, thank you!</p>",
        "id": 408325042,
        "sender_full_name": "y-samuel",
        "timestamp": 1702719864
    }
]