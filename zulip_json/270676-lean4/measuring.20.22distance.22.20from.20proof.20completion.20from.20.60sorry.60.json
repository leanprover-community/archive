[
    {
        "content": "<p>ok i have a bit of a galaxy-brained question</p>\n<p>Is there a quantification of \"how close\" a proof is to completion from information like the type of a sorry? if that doesn't make sense happy to try clarifying. </p>\n<p>Context: typically program synthesis problems have a spectrum of \"how correct\" solutions are (like an image is a percentage of pixels correct), so i'm wondering how much of regular program synthesis practices can be ported to proof generation</p>",
        "id": 459324753,
        "sender_full_name": "Quinn",
        "timestamp": 1723164181
    },
    {
        "content": "<p>If something along these lines were possible in general, it would seem really close to giving an algorithm to prove anything.</p>\n<p>However, any minimally complicated theory is undecidable.</p>\n<p>So I am very skeptical that for a general theorem about the natural numbers such a distance can be computed systematically.</p>",
        "id": 459353433,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723175299
    },
    {
        "content": "<p>indeed, such a quantification would give you a way to predict what direction a proof should move in to finish. you'd be able to do a kind of A* search through proofs. i suppose that would mean that if such a quantification existed (and were computable), it would probably either be not distinguishing enough to be useful (so you're basically still brute-forcing), or it would get stuck on some problems (i.e. the distance cannot be lowered from certain proof states, despite there being a route.)</p>",
        "id": 459421871,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1723196035
    },
    {
        "content": "<p>or it somehow gets stuck in an infinite descending chain which never reaches the actual goal</p>",
        "id": 459422190,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1723196131
    },
    {
        "content": "<p>Theoretical objections based on decidability have nothing to do with the probable existence (and near term availability!) of extremely useful implementations of such a function. :-)</p>\n<p>Realistically such a function is likely to either be an explicit component of, or extractable from, any system like AlphaProof that generates and tries to solve its own problems or variations. Training an approximation to \"how provable does this goal look?\" that is better than just \"I can prove this, and disprove that, but everything else <span aria-label=\"woman shrugging\" class=\"emoji emoji-1f937-200d-2640\" role=\"img\" title=\"woman shrugging\">:woman_shrugging:</span>\" seems pretty useful!</p>",
        "id": 459609987,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1723254479
    },
    {
        "content": "<p>Define C(T) for a type T to be 0 if T cannot be proven and otherwise to be the sum over all proofs <code>p : T</code> of 2^-(length [in binary] of the trace of type checking <code>p : T</code>).  C is not computable but it can be (expensively) approximated (upper-bounded) by enumerating all type checking traces.  Then 1/C (or -C) is a measure of how close a proof is to completion.</p>\n<p>(This is the brute force approach, but presumably whatever we'd extract from AlphaProof would approximate this)</p>",
        "id": 459616121,
        "sender_full_name": "Jason Gross",
        "timestamp": 1723256747
    },
    {
        "content": "<p>This specific measure quite possibly is infinite for all provable statements...</p>",
        "id": 459649322,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1723273393
    },
    {
        "content": "<p>In the sense that A: each provable statement can have an infinite number of proofs, and B: there are countably many provable statements. From this we can create an encoding where proofs of length <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding=\"application/x-tex\">a2^{i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8247em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span></span></span></span></span></span></span></span></span> (with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> coprime) are only those proving the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>-th provable statement (ordering by length, then lexicographically).</p>",
        "id": 459652341,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1723274551
    },
    {
        "content": "<p>I suppose that in this sense, \"how provable\" really does only mean \"is it provable\"</p>",
        "id": 459652747,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1723274813
    },
    {
        "content": "<p>Ok, I misunderstood the context.  In fact, some tactics introduce implicitly or explicitly an approximation to such measure and work towards diminishing its value.  For instance, this measure might the length of the target expression or the number of <code>-</code> symbols.</p>",
        "id": 459654335,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723275791
    },
    {
        "content": "<p>An early work that attempts to do this is <a href=\"https://arxiv.org/abs/2202.01344\">Polu et al 2022</a> \"We depart from Polu &amp; Sutskever (2020) and use a proofsize objective\" (as opposed to presumably a success probability objective)</p>",
        "id": 459763298,
        "sender_full_name": "llllvvuu",
        "timestamp": 1723325176
    },
    {
        "content": "<blockquote>\n<p>Realistically such a function is likely to either be an explicit component of, or extractable from, any system like AlphaProof that generates and tries to solve its own problems or variations.</p>\n</blockquote>\n<p>extractable only assuming language model interpretability goes really well, but indeed!</p>",
        "id": 462412388,
        "sender_full_name": "Quinn",
        "timestamp": 1723667065
    },
    {
        "content": "<p>thanks for the thought provoking responses!</p>",
        "id": 462412411,
        "sender_full_name": "Quinn",
        "timestamp": 1723667080
    }
]