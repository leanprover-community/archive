[
    {
        "content": "<p><code>private builtin_initialize envExtensionsRef : IO.Ref (Array (Ext EnvExtensionState)) ← IO.mkRef #[]</code><br>\nwhat does that left-arrow mean in above code snippet?</p>",
        "id": 452228779,
        "sender_full_name": "Keith",
        "timestamp": 1721268460
    },
    {
        "content": "<p>That the result in the <code>IO</code> monad to the right of it should be evaluated during initialisation. It's a relative of the monadic evaluation left arrow.</p>",
        "id": 452229234,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1721268828
    },
    {
        "content": "<p>If I understand correctly, that the <code>envExtensionsRef</code> variable will get its value by evaluating <code>← IO.mkRef #[]</code> during initialization, which has type IO.Ref (Array (Ext EnvExtensionState)). Right?</p>",
        "id": 452230378,
        "sender_full_name": "Keith",
        "timestamp": 1721269512
    },
    {
        "content": "<p>By the way, does that initialization you mentioned mean this <a href=\"https://github.com/leanprover/lean4/blob/master/src/initialize/init.cpp#L27\"><code>extern \"C\" LEAN_EXPORT void lean_initialize()</code></a> ?</p>",
        "id": 452230883,
        "sender_full_name": "Keith",
        "timestamp": 1721269913
    },
    {
        "content": "<p>I believe each module has an initialization function, and calling a module's initialization function runs all of the <code>initialize</code> and <code>builtin_initialize</code> functions in the module (as well as all those in modules it depends on). Not sure what <code>lean_initialize</code> does.</p>",
        "id": 452335626,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1721306942
    },
    {
        "content": "<p>User initializers are implemented mostly here: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/InitAttr.lean#L40-L100\">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/InitAttr.lean#L40-L100</a></p>\n<p>The <code>builtin_initialize</code> command is a macro for</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">initFn</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">Ref</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ext</span><span class=\"w\"> </span><span class=\"n\">EnvExtensionState</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">mkRef</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span>\n<span class=\"kd\">@[</span><span class=\"n\">builtin_init</span><span class=\"w\"> </span><span class=\"n\">initFn</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">envExtensionsRef</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">Ref</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ext</span><span class=\"w\"> </span><span class=\"n\">EnvExtensionState</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>The idea is that the <code>initFn</code> gets registered in the <code>builtin_init</code> environment extension as being the bit of coded that needs to be run to initialize this <code>envExtensionsRef</code> constant, and then once the modules are fully imported, the import system tells all the environment extensions to construct the environment (it might be somewhere in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.finalizeImport#doc\">docs#Lean.finalizeImport</a>, but I'm not sure).</p>\n<p>That C function seems to be initialization of Lean itself, way before any of this environment construction. It's possible that <code>builtin_init</code> functions are loaded there as well, but I'm a bit hazy on how Lean's bootstrapping works. The point of \"builtins\" are to have code that exists inside Lean before Lean's even loaded anything, so that Lean can be implemented mostly in itself.</p>",
        "id": 452395774,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721322702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"670366\">Keith</span> has marked this topic as resolved.</p>",
        "id": 453577400,
        "sender_full_name": "Notification Bot",
        "timestamp": 1721789839
    }
]