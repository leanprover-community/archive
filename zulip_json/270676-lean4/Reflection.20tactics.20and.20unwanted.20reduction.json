[
    {
        "content": "<p>BTW, this issue was also reported a while ago as <a href=\"https://github.com/leanprover-community/mathlib4/pull/7729\">#7729</a>, although I am not sure why it's in the mathlib repo</p>",
        "id": 471277537,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726670798
    },
    {
        "content": "<p>there are some more bits of information there about exactly why this is slow</p>",
        "id": 471277597,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726670821
    },
    {
        "content": "<p>I believe the short version is that this has nothing to do with the thing being binary or unary and more to do with the fact that it is unfolding way more than it should be doing and seeing huge terms (but also doing it in unary)</p>",
        "id": 471277896,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726670902
    },
    {
        "content": "<p>Hmm, that seems related but not quite the question here: There it looks we need better control over the reduction strategy  -  the question here is really just about whether using lists and indexing is ever a real bottleneck.</p>",
        "id": 471277979,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1726670929
    },
    {
        "content": "<p>Maybe you are saying that there are far bigger fish to fry :-D</p>",
        "id": 471278013,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1726670939
    },
    {
        "content": "<p>yes, that is what I am saying</p>",
        "id": 471278043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726670947
    },
    {
        "content": "<p>the indexing strategy certainly matters but for 2^8 it should be approximately zero and it's embarrassing that it's not</p>",
        "id": 471278164,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726670983
    },
    {
        "content": "<p>Have you tried doing this as proof producing instead and measuring the performance of that?</p>",
        "id": 471278312,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726671017
    },
    {
        "content": "<p>my gut feeling is that kernel reduction in lean is really bad performance-wise and I haven't really seen anything to suggest otherwise</p>",
        "id": 471278555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726671085
    },
    {
        "content": "<p>that's why I always tell people to write proof producing tactics instead</p>",
        "id": 471278601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726671100
    },
    {
        "content": "<p>For <a href=\"https://github.com/leanprover-community/mathlib4/pull/7729\">#7729</a>, I wonder if we can instead of letting the kernel solve</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">…</span><span class=\"w\">  </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Linear</span><span class=\"bp\">.</span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Linear</span><span class=\"bp\">.</span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">…</span>\n</code></pre></div>\n<p>that we can prove the goal</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">…</span><span class=\"w\">  </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Linear</span><span class=\"bp\">.</span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Linear</span><span class=\"bp\">.</span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">…</span>\n</code></pre></div>\n<p>and then,in a separate step, apply that to <code>List.length as</code>. That should avoid any reduction in the atoms, shouldn’t it?</p>",
        "id": 471278792,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1726671146
    },
    {
        "content": "<blockquote>\n<p>my gut feeling is that kernel reduction in lean is really bad performance-wise and I haven't really seen anything to suggest otherwise</p>\n</blockquote>\n<p>Oh, absolutely! But it’s  also sometimes convenient. And the roadmap does mention faster reduction :-)</p>",
        "id": 471278883,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1726671176
    },
    {
        "content": "<p>I'm not really convinced by that either, writing proof producing tactics is about as easy, especially if you have <code>Qq</code> on your side</p>",
        "id": 471279019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726671219
    },
    {
        "content": "<p>We don't have a small reproducer for the bug in <a href=\"https://github.com/leanprover-community/mathlib4/pull/7729\">#7729</a>? Maybe I can cook one up, using a well-founded definition that you better not reduce in the kernel.</p>",
        "id": 471279085,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1726671240
    },
    {
        "content": "<p>Maybe it will be good someday but that's like waiting for an implementation of communism that doesn't suck</p>",
        "id": 471279092,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726671241
    },
    {
        "content": "<p>you have to be extremely careful with kernel reduction to guard everything in sight so that unwanted things are not reduced</p>",
        "id": 471279250,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726671281
    },
    {
        "content": "<p>What about large proof certificates like LRAT proofs – isn't it desirable to have a compact encoding of them in the proof term, that's checked by reflection, rather than exploding them into an inductive proof?</p>",
        "id": 471279411,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1726671334
    },
    {
        "content": "<p>when I plot the performance cost of kernel typechecking on everything in lean the declarations that top the list are all the ones using these methods</p>",
        "id": 471279473,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726671352
    },
    {
        "content": "<p>18 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4/topic/Faster.20Nat-indexed.20data.20structure.20for.20kernel.20reduction\">#lean4 &gt; Faster Nat-indexed data structure for kernel reduction</a> by <span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span>.</p>",
        "id": 471279556,
        "sender_full_name": "Notification Bot",
        "timestamp": 1726671364
    },
    {
        "content": "<p>I took the liberty of splitting this from the narrow question of a kernel-friendly Nat-indexed map</p>",
        "id": 471279638,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1726671392
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Reflection.20tactics.20and.20unwanted.20reduction/near/471279473\">said</a>:</p>\n<blockquote>\n<p>when I plot the performance cost of kernel typechecking on everything in lean the declarations that top the list are all the ones using these methods</p>\n</blockquote>\n<p>But is that because they have expensive proofs and would be even slower if the kernel would have to look at many small explicit steps? Or because we just do reflection badly.</p>",
        "id": 471279800,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1726671447
    },
    {
        "content": "<p>We do reflection badly</p>",
        "id": 471279849,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726671461
    },
    {
        "content": "<p>And if we wouldn’t do it badly, shouldn’t it always be faster to evaluate a small function that does the steps, rather than checking a large inductive proof?</p>",
        "id": 471279910,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1726671479
    },
    {
        "content": "<p>it is actually faster to look at explicit steps</p>",
        "id": 471279918,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726671481
    },
    {
        "content": "<p>because there is less unfolding</p>",
        "id": 471279997,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726671497
    },
    {
        "content": "<p>everything matches syntactically after instantiation</p>",
        "id": 471280054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726671513
    },
    {
        "content": "<p>That’s sad, but sounds like something that can be fixed.</p>",
        "id": 471280058,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1726671514
    },
    {
        "content": "<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 471280101,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726671523
    },
    {
        "content": "<p>Coq has good kernel reduction, and it completely changes the way people write tactics</p>",
        "id": 471280188,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726671545
    },
    {
        "content": "<p>but keep in mind that we're talking multiple years of work on writing advanced compilers inside the kernel, bytecode evaluation and jit compiling and such</p>",
        "id": 471280334,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726671590
    },
    {
        "content": "<p>and it's all in the TCB</p>",
        "id": 471280590,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726671646
    },
    {
        "content": "<p>Well, we do have <code>by native_decide</code>. So at least for the part of proofs by reflection that checks ground terms, we are not far off, aren't we?</p>",
        "id": 471280729,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1726671675
    },
    {
        "content": "<p>At least for those who accept that in the TCB (which seems comparable to what Coq has to offer,  with jit and stuff in the TCB?)</p>",
        "id": 471280849,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1726671709
    },
    {
        "content": "<p>yes. But coq's bytecode evaluator works on open terms</p>",
        "id": 471280884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726671720
    },
    {
        "content": "<p>and the jit compiling is beyond what lean can do</p>",
        "id": 471280982,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726671732
    },
    {
        "content": "<p>we don't have a fast evaluator for open terms</p>",
        "id": 471281172,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726671786
    },
    {
        "content": "<p>I also know people in MetaCoq crazy enough to prove the correctness of the bytecode evaluator, so the TCB story is not really the same</p>",
        "id": 471281439,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726671862
    },
    {
        "content": "<p>Reproducer for <a href=\"https://github.com/leanprover-community/mathlib4/pull/7729\">#7729</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bad</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">bad</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">profiler</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_arith</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">profiler</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">bad</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">bad</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">bad</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_arith</span>\n</code></pre></div>\n<p>I’ll open <a href=\"https://github.com/leanprover/lean4/issues/5384\">a lean4 issue</a>, so that it’s recorded.</p>",
        "id": 471281633,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1726671912
    },
    {
        "content": "<p>For open term reduction I wonder how fast they have to be. Of course it shouldn’t be stupidly slow (as in <a href=\"https://github.com/leanprover-community/mathlib4/pull/7729\">#7729</a>), but maybe the bottle neck is usually going to be the closed evaluation part in roofs by reflection?</p>",
        "id": 471283017,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1726672253
    }
]