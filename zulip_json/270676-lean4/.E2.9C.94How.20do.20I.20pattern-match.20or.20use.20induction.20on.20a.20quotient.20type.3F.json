[
    {
        "content": "<p>I tried to use a <code>match</code> statement, but I can't seem to find the constructor name. I also tried <code>induction q using Quot.lift</code>, but I get the error 'extra targets for '@Quot.lift' and I do not know what that means. I would manually <code>Quot.lift</code> to get what I want, but it involves some thinking, because there are extra assumptions involved.</p>\n<p>I can work an example out, if desired.</p>",
        "id": 529447453,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752839905
    },
    {
        "content": "<p>Use induction with <code>Quot.ind</code> instead</p>",
        "id": 529448421,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752840213
    },
    {
        "content": "<p>Since <code>Quot.lift</code> can only do the nondependent case</p>",
        "id": 529448620,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752840279
    },
    {
        "content": "<p>I'm trying to construct data, and not a proposition, so <code>Quot.ind</code> does not work. My particular case is also non-dependent, which is why I hoped to use <code>Quot.lift</code>. Actually, the fully general versions <code>Quot.hrecOn</code> or <code>Quot.rec</code> seem to work (so that would be a possiblity to solve the issue), of course I will have to prove a heterogeneous equality, but it's probably fine.</p>\n<p>Out of curiosity, is there a way to pattern-match?</p>",
        "id": 529449689,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752840660
    },
    {
        "content": "<p>Don't use tactics if you're constructing data</p>",
        "id": 529449894,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752840720
    },
    {
        "content": "<p>I don't think you can pattern match here</p>",
        "id": 529450013,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752840757
    },
    {
        "content": "<p>Just curious, what's the application?</p>",
        "id": 529450182,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752840803
    },
    {
        "content": "<p>Yeah, I agree that tactics wouldn't be the best solution so that I thought that pattern matching might be best.</p>\n<p>So I have this function <code>checkProperty: List Nat  -&gt; Bool</code> that checks a property for a list of natural numbers (whether it contains three natural numbers summing up to a specified value). Now I want to define an algorithm that checks whether this property holds for the divisors <code>Nat.divisors n</code> of a number (which is a finite set). Thus, lifting <code>checkProperty</code> to <code>checkProperty': Finset Nat -&gt; Bool</code> with lifting for quotients would be nice.</p>\n<p>I can prove that <code>checkProperty</code> actually respects the setoid relation on <code>List Nat</code> that defines multisets, if we assume the lists to not have duplicate entries and satisfy a positivity condition (which could be dropped if I change my code a bit). These assumptions are what complicates the situation a bit, since I can't just use <code>Quot.lift</code> in a super straightforward manner.</p>\n<p>Let me know if I should write some code later.</p>",
        "id": 529451853,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752841444
    },
    {
        "content": "<p>do you have a proof that your algorithm is invariant under permutation</p>",
        "id": 529496541,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752857388
    },
    {
        "content": "<p>you can also use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.rec#doc\">docs#Multiset.rec</a> or any of its variants</p>",
        "id": 529496571,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752857402
    },
    {
        "content": "<p><code>Multiset.rec</code> uses <code>Multiset.cons</code>, so I would have to change the proof.</p>\n<p>Yes, I have that the algorithm is invariant under permutation. There is a caveat though: The inputs must cannot contain duplicate entries (and they must have positive entries). So pattern matching would have been the most convenient, I think. I am sure I will find a workaround though by trying a couple of things :)</p>",
        "id": 529510556,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752864055
    },
    {
        "content": "<p>You can pass those additional things in as hypotheses for your conclusion in the quotient recursor</p>",
        "id": 529510681,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752864127
    },
    {
        "content": "<p>Ahh thank you! Yeah, that was the plan of action. I messed up something up though with getting the right motive, so I will probably have to be more careful when doing that.</p>",
        "id": 529510909,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752864284
    },
    {
        "content": "<p>Update: I ended up implementing my own divisors function. It's really easy and it avoids the really annoying juggling with setoids and propositions that would have been required to use <code>Quot.lift</code>. I'm marking this as resolved.</p>",
        "id": 529846113,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1753093869
    }
]