[
    {
        "content": "<p>I have noticed that when a type contains implicit binders, Lean automatically discards them, creating meta-variables in the remaining expression;  this does not happen with the default binders. Here is an MWE demonstrating this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Parser</span> <span class=\"n\">Term</span> <span class=\"n\">Meta</span> <span class=\"n\">Tactic</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">false</span>\n\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">expType</span><span class=\"o\">)</span> <span class=\"s2\">\"expectedType?\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kd\">@[term_elab expType]</span> <span class=\"kd\">def</span> <span class=\"n\">traceExpectedType</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">some</span> <span class=\"n\">type</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">logInfo</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">←</span> <span class=\"n\">ppExpr</span> <span class=\"n\">type</span>\n    <span class=\"n\">mkSorry</span> <span class=\"n\">type</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">panic</span><span class=\"bp\">!</span> <span class=\"s2\">\"Expected type not available\"</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"c1\">-- Correct: ∀ (n : Nat), n + 1 = 1 + n</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"c1\">-- Incorrect: n✝ + 1 = 1 + n✝</span>\n</code></pre></div>\n<p>(However, the correct type is displayed in both examples when the part after the <code>:=</code> is replaced by an underscore.)<br>\nI initially assumed that this had to do with auto-implicits, but the error remains after disabling this feature. Is the above behaviour expected, and if so, is there a way to disable it?</p>",
        "id": 354187515,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1682745428
    },
    {
        "content": "<p>You're looking at <a href=\"https://leanprover.github.io/lean4/doc/lean3changes.html#implicit-lambdas\">https://leanprover.github.io/lean4/doc/lean3changes.html#implicit-lambdas</a></p>",
        "id": 354242341,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1682755200
    },
    {
        "content": "<p>Thanks.</p>",
        "id": 354256405,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1682757426
    },
    {
        "content": "<p>Is there an option to disable the implicit lambda feature in a file? (just like for <code>autoImplicit</code>s)<br>\nFor context, I am trying to create a clone of Lean's <code>by</code> tactic to modify the tactic execution. The code below works for the most part, but for theorem statements involving implicit binders, a tactic proof that works with the original <code>by</code> does not work with the clone <code>by'</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Parser</span> <span class=\"n\">Term</span> <span class=\"n\">Meta</span> <span class=\"n\">Tactic</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">byTactic'</span><span class=\"o\">)</span> <span class=\"s2\">\"by' \"</span> <span class=\"n\">tacticSeq</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">mkTacticMVar</span> <span class=\"o\">(</span><span class=\"n\">type</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tacticCode</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mvar</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"n\">type</span> <span class=\"n\">MetavarKind.syntheticOpaque</span>\n  <span class=\"k\">let</span> <span class=\"n\">mvarId</span> <span class=\"o\">:=</span> <span class=\"n\">mvar.mvarId</span><span class=\"bp\">!</span>\n  <span class=\"k\">let</span> <span class=\"n\">ref</span> <span class=\"bp\">←</span> <span class=\"n\">getRef</span>\n  <span class=\"n\">registerSyntheticMVar</span> <span class=\"n\">ref</span> <span class=\"n\">mvarId</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">SyntheticMVarKind.tactic</span> <span class=\"n\">tacticCode</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">saveContext</span><span class=\"o\">)</span>\n  <span class=\"n\">return</span> <span class=\"n\">mvar</span>\n\n<span class=\"kd\">@[term_elab byTactic']</span> <span class=\"kd\">def</span> <span class=\"n\">elabByTactic'</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">expectedType</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">dbg_trace</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">ppExpr</span> <span class=\"n\">expectedType</span><span class=\"o\">)</span>\n    <span class=\"n\">mkTacticMVar</span> <span class=\"n\">expectedType</span> <span class=\"n\">stx</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">tryPostpone</span>\n    <span class=\"n\">throwError</span> <span class=\"o\">(</span><span class=\"s2\">\"invalid 'by</span><span class=\"se\">\\'</span><span class=\"s2\">' tactic, expected type has not been provided\"</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- macro_rules</span>\n<span class=\"c1\">--   | `(by $tacs) =&gt; `(by' $tacs)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"c1\">-- works</span>\n  <span class=\"n\">simp</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span><span class=\"bp\">'</span>\n  <span class=\"n\">intro</span> <span class=\"c1\">-- error</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>\n<p>(I am actually planning to take a different approach now, but would like to know for future reference.)</p>",
        "id": 354261971,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1682758238
    },
    {
        "content": "<p>there is a macro <code>no_implicit_lambda%</code> which disables implicit lambda, and a corresponding mdata node <code>noImplicitLambda</code></p>",
        "id": 354267438,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682758999
    },
    {
        "content": "<p>I'm pretty sure <code>by</code> is using something like that</p>",
        "id": 354267553,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682759020
    },
    {
        "content": "<p>actually there is some special casing of <code>byTactic</code> here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">shouldPropagateExpectedTypeFor</span> <span class=\"o\">(</span><span class=\"n\">nextArg</span> <span class=\"o\">:</span> <span class=\"n\">Arg</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">nextArg</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">expr</span> <span class=\"n\">_</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span> <span class=\"c1\">-- it has already been elaborated</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">stx</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"c1\">-- TODO: make this configurable?</span>\n    <span class=\"n\">stx.getKind</span> <span class=\"bp\">!=</span> <span class=\"bp\">``</span><span class=\"n\">Lean.Parser.Term.hole</span> <span class=\"bp\">&amp;&amp;</span>\n    <span class=\"n\">stx.getKind</span> <span class=\"bp\">!=</span> <span class=\"bp\">``</span><span class=\"n\">Lean.Parser.Term.syntheticHole</span> <span class=\"bp\">&amp;&amp;</span>\n    <span class=\"n\">stx.getKind</span> <span class=\"bp\">!=</span> <span class=\"bp\">``</span><span class=\"n\">Lean.Parser.Term.byTactic</span>\n</code></pre></div>",
        "id": 354269335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682759257
    },
    {
        "content": "<p>Thanks a lot. I will look into this.</p>",
        "id": 354278803,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1682760611
    },
    {
        "content": "<p>So if I understand correctly, the <code>shouldPropagateExpectedTypeFor</code> function is what I would need to modify to correct <code>by'</code>.</p>",
        "id": 354294159,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1682762701
    }
]