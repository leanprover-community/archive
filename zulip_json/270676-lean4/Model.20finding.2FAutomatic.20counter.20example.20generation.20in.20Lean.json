[
    {
        "content": "<p>As someone who originally started doing formalisation in Isabelle, I am used to having a counter example finder that lets me know when the theorem I just stated is wrong for trivial reasons. This has sometimes been a big time saver since it kept me from trying to formalise a wrong theorem. </p>\n<p>I wondered if anyone is currently working on/planning to work on something similar for Lean. As far as I know, Mathlib has a tool called SlimCheck which is a port of Haskell's QuickCheck. Essentially that works by randomly generating finite structures and testing the given lemma on them. How widely is SlimCheck currently used? </p>\n<p>Isabelle has two tools for model finding. The leightweight 'quickcheck' always runs in the background but has limited capability. And there is Nitpick which often succeeds in finding (finite) counterexamples when quickcheck fails, but it has to be invoked manually. Nitpick works by translating the problem to the logic of Kodkod which is a SAT-based model finder. It is not limited to counterexample search but can also find positive models. For example, when you make the definition of a graph you can let Nitpick generate a (finite) example and even specify the cardinality (number of vertices). </p>\n<p>I assume that similar tools might exist in other proof assistants, but I've not done the research yet. </p>\n<p>In general I find the topic very interesting and could imagine spending some time on it; which is why I wanted to check if other people are working on model finding in Lean already.</p>",
        "id": 451552547,
        "sender_full_name": "Jonas Bayer",
        "timestamp": 1721062835
    },
    {
        "content": "<p>SlimCheck is the only tool dedicated to this currently. There are a few automation tactics that can also come up with counter examples. For example <code>omega</code> is a linear integer arithmetic tactic that tries to generate a counter example for the linear constraints it was given (not that this does not have to be sound, there might just be constrains that omega doesn't understand that invalidate the counter example) and <a href=\"https://github.com/leanprover/leansat\">LeanSAT</a> is capable of counter example generation for arbitrary BitVec and boolean problems (same constraints thing as omega).</p>\n<p>There does not currently exist a Nitpick style tool to my knowledge.</p>",
        "id": 451554121,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1721063079
    },
    {
        "content": "<p>... and afaik nobody is working on anything like it and it also doesn't exist for other proof assistants (but I could be wrong there). The problem, as always, is that it's a ton of work with very limited academic payoff.</p>",
        "id": 451560018,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1721064013
    },
    {
        "content": "<p>SlimCheck could be a lot better than it is at present: no one has seriously worked on it since the initial implementation, so we're still missing basic generators for types, etc.</p>\n<p>There's also some harder work but that would make SlimCheck more powerful:</p>\n<ul>\n<li>switch to generating <code>Expr</code>s rather than actual terms</li>\n<li>enable running MetaM code during generation, so e.g. we can run calculations to filter results. (There have been some previous attempts at this that foundered.)</li>\n</ul>",
        "id": 451826388,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1721153512
    },
    {
        "content": "<p>I would love to see automatic counterexample generation on every new declaration!</p>",
        "id": 451826538,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1721153537
    },
    {
        "content": "<p>Thanks for the helpful replies! It's great to hear that there is interest in principle. </p>\n<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> so you think that using SlimCheck as a basis for lightweight checking in the background would be a good approach? I'm not sure how Isabelle quickcheck works, it might well do a very similar thing but probably it's worthwhile to check.</p>",
        "id": 452002579,
        "sender_full_name": "Jonas Bayer",
        "timestamp": 1721207541
    },
    {
        "content": "<p>To be honest, I don't have a super high level of confidence that we could get SlimCheck to the point that it is performant enough to run in the background everywhere. But this is ignorance rather than a specific negative reason. I do really hope that someone will experiment in this direction, and either come up with something we could deploy for everyone, or failing that teach us what needs to be done instead!</p>",
        "id": 452104599,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1721229136
    },
    {
        "content": "<p>Coming back to this thread -- <span class=\"user-mention\" data-user-id=\"605003\">@Jonas Bayer</span> did you spend any more time looking into SlimCheck for your use-case?  It seems on a cursory search of GitHub that basically no one uses SlimCheck, and I am curious why that might be. Anyone know of serious use-cases?</p>\n<p>I'm a big fan of property-based testing in general, and I'm also familiar with the QuickChick framework for Coq (see <a href=\"https://softwarefoundations.cis.upenn.edu/qc-current/index.html\">https://softwarefoundations.cis.upenn.edu/qc-current/index.html</a>). I'd love to see good support for property-based testing in Lean, and I'd be willing to help with that.</p>\n<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> if you had a wishlist of what needs to be done to get SlimCheck to the point that it could be used easily, even by new users, I'd be glad to know it. (I see your ideas above, but if you have more comprehensive thoughts I'm glad to know them.)</p>",
        "id": 474874271,
        "sender_full_name": "Mike Hicks",
        "timestamp": 1728064295
    },
    {
        "content": "<p>I also imagine that some potential users would prefer SlimCheck to not be in Mathlib, but rather in Std or someplace smaller ...</p>",
        "id": 474888249,
        "sender_full_name": "Mike Hicks",
        "timestamp": 1728070163
    },
    {
        "content": "<p>I've been contemplating to pull out slim check from mathlib for a while. Given that I wrote most of the ported code I would assume that's fine with mathlib</p>",
        "id": 474888588,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1728070234
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> In the event that SlimCheck can't find a place in Lean, it would be a welcome addition to Batteries.</p>",
        "id": 474947106,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1728105449
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"658606\">@Mike Hicks</span> I do not have a specific use case per se; the reason I'm interested in this topic is that in my experience it was valuable to have tools like Quickcheck/Nitpick in Isabelle. Sometimes when you state a lemma a hypothesis might be missing and these tools were quite good at detecting this (not 100% reliably, of course, but sufficiently often to be helpful). </p>\n<p>The reason that you can't find example use cases of Slimcheck on Github might also be due to the nature of the tool. If its used in formalisation and detects that a lemma is trivially wrong the user will usually just fix the lemma and not keep the Slimcheck call in the proof. Though it might also just genuinely not be used a lot..</p>",
        "id": 475583302,
        "sender_full_name": "Jonas Bayer",
        "timestamp": 1728398478
    },
    {
        "content": "<blockquote>\n<p>I've been contemplating to pull out slim check from mathlib for a while.</p>\n</blockquote>\n<p>I think this probably isn't worth the churn; as written <code>slim_check</code> isn't really fit for purpose, as it can only find witnesses for decidable predicates, rather than <code>norm_num</code>- or <code>aesop</code>-able predicates. Changing this requires a change to slim_check to pass around <code>Q(_)</code> or <code>Expr</code> objects.</p>",
        "id": 475585745,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728398980
    },
    {
        "content": "<p>I think it would be best to improve it in mathlib where there are more meta reviewers, and migrate it only after such a refactor</p>",
        "id": 475585979,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728399035
    },
    {
        "content": "<p>Well apart form being useful as a tactic for these things <code>slim_check</code> can also be considered a general property testing tool that software people would want to use. These kinds of users often don't care about non decidable predicates so having <code>slim_check</code> available just like that + potentially a deriving mechanism would already be a huge win for that community. Given the pace of mathlib reviews development outside of mathlib would most likely also be faster.</p>",
        "id": 475586497,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1728399177
    },
    {
        "content": "<p>I'm intending to use SlimCheck extensively, it's a fantastic package and concept.  I want to search for interesting theorems automatically and it's good to test before embarking on an attempted proof or disproof.  And to use it for model checking would be interesting to me.  For example, for checking statements in modal logic.  But it really needs some documentation, that would be <a href=\"https://github.com/leanprover-community/mathlib4/pull/1\">#1</a> on my wishlist.  Even fixing the few examples in the sources would be great for a newcomer.  Is anyone working on a SlimCheck manual I wonder?</p>",
        "id": 476241051,
        "sender_full_name": "Matthew Fairtlough",
        "timestamp": 1728601395
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/Model.20finding.2FAutomatic.20counter.20example.20generation.20in.20Lean/near/475586497\">said</a>:</p>\n<blockquote>\n<p>Well apart form being useful as a tactic for these things <code>slim_check</code> can also be considered a general property testing tool that software people would want to use. These kinds of users often don't care about non decidable predicates so having <code>slim_check</code> available just like that + potentially a deriving mechanism would already be a huge win for that community. Given the pace of mathlib reviews development outside of mathlib would most likely also be faster.</p>\n</blockquote>\n<p>So is there anyone here that has a hard reason against this? Otherwise I'll pull it to leanprover/SlimCheck today.</p>",
        "id": 476354891,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1728641335
    },
    {
        "content": "<p>I spoke to another Lean user yesterday and she suggested that moving Slimcheck into Lean (rather than Std or Batteries) would be ideal. <span class=\"user-mention\" data-user-id=\"119741\">@François G. Dorais</span> above also suggests going this way. Thanks!</p>",
        "id": 476358052,
        "sender_full_name": "Mike Hicks",
        "timestamp": 1728642533
    },
    {
        "content": "<p>I have this dream that <code>slim_check</code> will one day disprove statements about  topological spaces (say) by trying a random topological space of size 3 and seeing what <code>decide</code> makes of the statement. Will moving it into core prevent this dream from happening?</p>",
        "id": 476375981,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728648995
    },
    {
        "content": "<p>No, the goal should always be to make it extensible</p>",
        "id": 476376059,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1728649034
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> I lost track of the discussion, I really want to make SlimCheck more accessible. Getting it out of Mathlib is a great step in that direction. I'm just checking in what the current plan is. </p>\n<p>SlimCheck makes perfect sense in a separate repo, it also makes sense in Lean and in Batteries. Which option are you going for?</p>",
        "id": 476571454,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1728789726
    },
    {
        "content": "<p>The first</p>",
        "id": 476591020,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1728810185
    },
    {
        "content": "<p><a href=\"https://github.com/hargoniX/SlimCheck\">https://github.com/hargoniX/SlimCheck</a> i put it here for now so I have somewhere to push while I work on pulling it from mathlib. But it'll eventually move to leanprover/ I think, so probably don't depend on this one (it doesn't even compile right now anyways)</p>",
        "id": 476593052,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1728812335
    },
    {
        "content": "<p>I'm going to start a quick conversation amongst Mathlib maintainers to get approval for adding leanprover/SlimCheck as a Mathlib dependency. It may be that in this case it is pro forma, but we'll see what comes up.</p>",
        "id": 476604253,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1728824112
    },
    {
        "content": "<p>Two things that came up in maintainers discussion:</p>",
        "id": 476645444,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1728862312
    },
    {
        "content": "<ol>\n<li>if I understand correctly about our plans to work on this in the near future, perhaps moving it to leanprover-community/SlimCheck makes more sense for now than leanprover/SlimCheck.</li>\n</ol>",
        "id": 476645450,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1728862315
    },
    {
        "content": "<ol start=\"2\">\n<li>perhaps the material on <code>RandT</code> and <code>ULiftable</code> that currently is in Mathlib, supporting SlimCheck, doesn't really belong in a standalone repository, and could be moved to Batteries with the separated SlimCheck depending on it.</li>\n</ol>",
        "id": 476645511,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1728862369
    },
    {
        "content": "<p><code>RandT</code> would be great in Batteries now that we will soon have Mersenne Twister <a href=\"https://github.com/leanprover-community/batteries/pull/984\">batteries#984</a>, and other PRNG planned.</p>",
        "id": 476652629,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1728869562
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/270676-lean4/topic/Model.20finding.2FAutomatic.20counter.20example.20generation.20in.20Lean/near/476645511\">said</a>:</p>\n<blockquote>\n<ol start=\"2\">\n<li>perhaps the material on <code>RandT</code> and <code>ULiftable</code> that currently is in Mathlib, supporting SlimCheck, doesn't really belong in a standalone repository, and could be moved to Batteries with the separated SlimCheck depending on it.</li>\n</ol>\n</blockquote>\n<p>ULiftable is not necessary, you can just write a 5 liner specific to <code>Gen</code>. RandT sure.</p>",
        "id": 476694377,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1728889276
    },
    {
        "content": "<p>Probably this deserves another thread, but I'll post here to gauge interest:</p>\n<p>The <a href=\"https://softwarefoundations.cis.upenn.edu/qc-current/index.html\">QuickChick library for Coq</a> has some pretty cool support for automatically deriving generators for simple, inductively defined types that satisfy a dependent predicate. Think: Binary trees (the type) that satisfy the binary search tree ordering invariant (the predicate). The same support can also translate predicates in Prop into computable checkers, e.g., translating an inductive relation defining the BST invariant into a checker from binary trees to bool. All described in <a href=\"https://lemonidas.github.io/pdf/ComputingCorrectly.pdf\">this paper</a>. </p>\n<p>This support makes QuickChick much more usable. What are folks' thoughts about trying to implement equivalent support for it in Slimcheck? It seems to me that one benefit of Lean, compared to Coq, is the much better metaprogramming support that should hopefully make it easier to implement.</p>",
        "id": 477917683,
        "sender_full_name": "Mike Hicks",
        "timestamp": 1729450249
    },
    {
        "content": "<p>This has been on my mind for years, it's quite an obvious step to take to improve the adoption of the tool across the eco system, just didn't have the time/priority for me yet unfortunately.</p>",
        "id": 477921710,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1729453793
    },
    {
        "content": "<p>Would it be a good Masters project for a CS student or is it too technical?</p>",
        "id": 477922074,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1729454052
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"658606\">Mike Hicks</span> <a href=\"#narrow/channel/270676-lean4/topic/Model.20finding.2FAutomatic.20counter.20example.20generation.20in.20Lean/near/477917683\">said</a>:</p>\n<blockquote>\n<p>Probably this deserves another thread, but I'll post here to gauge interest:</p>\n<p>... The same support can also translate predicates in Prop into computable checkers, e.g., translating an inductive relation defining the BST invariant into a checker from binary trees to bool. All described in <a href=\"https://lemonidas.github.io/pdf/ComputingCorrectly.pdf\">this paper</a>. </p>\n</blockquote>\n<p>Oh, this idea of converting <code>Prop</code> predicates to checkers is interesting and could also be applied to FFI.</p>\n<p>When interacting with foreign code or external components, it would be great to check (incoming) runtime values against checkers reified from <code>Prop</code> predicates found in the Lean external/export definitions.</p>",
        "id": 478486671,
        "sender_full_name": "Yuri",
        "timestamp": 1729687415
    },
    {
        "content": "<p>It's a good point that this support is useful for more than just testing. It also enables proofs by reflection. You specify something as an inductive relation but then automatically generate a computational version of the same thing, proved equivalent to the original. Then you can switch between the two when doing proofs, whichever is more convenient.</p>\n<p>In our Cedar development in Lean, we define <a href=\"https://github.com/cedar-policy/cedar-spec/blob/main/cedar-lean/Cedar/Validation/Typechecker.lean\">type checking as a function</a>, since ultimately we want to run it during testing. But this makes the proof of type soundness harder than it would be if we'd specified typing as an inductive relation instead (at least, that's my guess). Being able to derive the typechecker we have now from an inductive relation would have given us the best of both worlds, AFAICS.</p>",
        "id": 478491928,
        "sender_full_name": "Mike Hicks",
        "timestamp": 1729688814
    },
    {
        "content": "<p>For the specific use case in Cedar you are describing another option is to write the relation inductively and then a function that returns <code>Decidable (HasType Ctx term typ)</code></p>",
        "id": 478492338,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1729688924
    }
]