[
    {
        "content": "<p>From <a href=\"https://leanprover.github.io/theorem_proving_in_lean/tactics.html#using-the-simplifier\">Theorem Proving in Lean 3</a>:</p>\n<blockquote>\n<p>It may seem that commutativity and left-commutativity are problematic, in that repeated application of either causes looping. But the simplifier detects identities that permute their arguments, and uses a technique known as <em>ordered rewriting</em>. This means that the system maintains an internal ordering of terms, and only applies the identity if doing so decreases the order. With the three identities mentioned above, this has the effect that all the parentheses in an expression are associated to the right, and the expressions are ordered in a canonical (though somewhat arbitrary) way. Two expressions that are equivalent up to associativity and commutativity are then rewritten to the same canonical form.</p>\n</blockquote>\n<p>I also think that at one point I may have heard that simp assigned natural number scores to various expressions, and only applied a rewrite if it decreased the score, though I'm not sure if this was true.</p>\n<p>I'm wondering if this is still the case in Lean 4, or does Lean 4 always just replace the LHS with the RHS?</p>",
        "id": 534324682,
        "sender_full_name": "Niels Voss",
        "timestamp": 1755132665
    },
    {
        "content": "<p>I think <code>simp</code> still compares expressions with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr.lt#doc\">docs#Lean.Expr.lt</a> to prevent infinite looping with commutativity theorems</p>",
        "id": 534324727,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755132724
    },
    {
        "content": "<p>or maybe it's the quick lt</p>",
        "id": 534324758,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755132766
    },
    {
        "content": "<p>Oh I see. So it doesn't compute numerical scores, but there's still a linear order on expressions (implemented in C++)?</p>",
        "id": 534324802,
        "sender_full_name": "Niels Voss",
        "timestamp": 1755132795
    },
    {
        "content": "<p>I will see if I can find where this happens in the code</p>",
        "id": 534325214,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755133137
    },
    {
        "content": "<p>Well I found the core algorithm in <a href=\"https://github.com/leanprover/lean4/blob/f8c743e37d993b3c95754e4865b88cab8fbea2ce/src/library/expr_lt.cpp#L197\">https://github.com/leanprover/lean4/blob/f8c743e37d993b3c95754e4865b88cab8fbea2ce/src/library/expr_lt.cpp#L197</a> (and there's another copy of it in stage0) with a simple search, though I don't know where it is invoked</p>",
        "id": 534325923,
        "sender_full_name": "Niels Voss",
        "timestamp": 1755133666
    },
    {
        "content": "<p>It seems to be defined by recursion on Expr. I could be wrong but:</p>\n<ul>\n<li>Expressions of different types (e.g. fvar vs bvar) are compared by some ordering that I'm not sure about</li>\n<li>Literals are compared by their value (I'm guessing alphabetical order is used for strings)</li>\n<li>Bound variables are compared by their de brujin index</li>\n<li>Constants are compared first by their name and next by their universe level expression</li>\n<li>Function applications are compared first by their function (making a recursive call) and next by their argument (again, making a recursive call)</li>\n<li>Lambdas and Pis are compared first by their \"binding domain\" and next by their body</li>\n<li>Free variables are compared by their index in the local context</li>\n<li>Metavariables are compared by their ids</li>\n<li>Sorts and lets seem to be more complicated</li>\n</ul>",
        "id": 534326709,
        "sender_full_name": "Niels Voss",
        "timestamp": 1755134306
    },
    {
        "content": "<p>There's also a \"quick mode\" which first uses hashes for comparison, and only uses the extended algorithm if the hashes were equal</p>",
        "id": 534326790,
        "sender_full_name": "Niels Voss",
        "timestamp": 1755134383
    },
    {
        "content": "<p>A couple of remarks on this:</p>\n<ol>\n<li>When talking about \"ordered term rewriting\" people usually mean term rewriting systems ordered by a relation that is stable under substitution (and often more properties, called a \"rewrite ordering\"). These orderings are inherently not linear and not even total. The two most popular orderings used for these purposes are KBO and LPO</li>\n<li><a href=\"http://Expr.lt\">Expr.lt</a> is not called directly from within simp to the best of my understanding</li>\n<li><code>simp</code> will use an LPO implementation called <code>acLt</code> in a particular situation:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">thm</span><span class=\"bp\">.</span><span class=\"n\">perm</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  We use `.reduceSimpleOnly` because this is how we indexed the discrimination tree.</span>\n<span class=\"cm\">  See issue #1815</span>\n<span class=\"cm\">  -/</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"o\">(</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">acLt</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">reduceSimpleOnly</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">simp</span><span class=\"bp\">.</span><span class=\"n\">rewrite</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"s2\">\"{‚Üê ppSimpTheorem thm}, perm rejected {e} ==&gt; {rhs}\"</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">simp</span><span class=\"bp\">.</span><span class=\"n\">rewrite</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"s2\">\"{‚Üê ppSimpTheorem thm}:{indentExpr e}</span><span class=\"se\">\\n</span><span class=\"s2\">==&gt;{indentExpr rhs}\"</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"bp\">.</span><span class=\"n\">hasBinderNameHint</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"bp\">.</span><span class=\"n\">resolveBinderNameHint</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">rhs</span>\n<span class=\"n\">recordSimpTheorem</span><span class=\"w\"> </span><span class=\"n\">thm</span><span class=\"bp\">.</span><span class=\"n\">origin</span>\n<span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">proof?</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>where the <code>perm</code> flag on a simp theorem that indicates:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"ss\">`perm</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"n\">are</span><span class=\"w\"> </span><span class=\"n\">identical</span><span class=\"w\"> </span><span class=\"n\">modulo</span><span class=\"w\"> </span><span class=\"n\">permutation</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">variables</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>which is exactly what is referred to in the quote above.</p>\n<p>And lastly, <code>simp</code> in Lean 4 will totally rewrite in loops to its heart's content, after all this special situation from above often does not occur in cyclic rewrite systems:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">thm1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">thm2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>yields</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">simp'</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nested</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">maximum</span><span class=\"w\"> </span><span class=\"n\">recursion</span><span class=\"w\"> </span><span class=\"n\">depth</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">been</span><span class=\"w\"> </span><span class=\"n\">reached</span>\n<span class=\"n\">use</span><span class=\"w\"> </span><span class=\"ss\">`set_option</span><span class=\"w\"> </span><span class=\"n\">maxRecDepth</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"n\">num</span><span class=\"bp\">&gt;`</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">increase</span><span class=\"w\"> </span><span class=\"n\">limit</span>\n<span class=\"n\">use</span><span class=\"w\"> </span><span class=\"ss\">`set_option</span><span class=\"w\"> </span><span class=\"n\">diagnostics</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">diagnostic</span><span class=\"w\"> </span><span class=\"n\">information</span>\n</code></pre></div>",
        "id": 534400252,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1755156216
    },
    {
        "content": "<p><a href=\"https://leanprover.github.io/theorem_proving_in_lean4/Tactics/#using-the-simplifier\">https://leanprover.github.io/theorem_proving_in_lean4/Tactics/#using-the-simplifier</a> (3rd major paragraph)</p>\n<p>I think the same quote was pasted into the Lean 4 version, but surroundings aren't necessarily the same. So id guess it was purposeful and the remark would still apply.</p>",
        "id": 534578946,
        "sender_full_name": "Yan Yablonovskiy üá∫üá¶",
        "timestamp": 1755217297
    },
    {
        "content": "<p>Just to be clear about this as I can't quite tell if there is any confusion left: <code>simp</code> is not in general an ordered rewriting system but as noted in the initial quote, my analysis of the code and this part of the reference manual, falls back to ordered rewriting in a very particular situation:</p>\n<blockquote>\n<p>But the simplifier detects identities that permute their arguments, and uses a technique known as <em>ordered rewriting</em>.</p>\n</blockquote>\n<p>In all other situations it will just perform normal left-to-right rewriting without any safe guards for rewrite loops, confluence etc. (all things that a full ordered rewriting system is able to do). In fact if <code>simp</code> <em>was</em> an ordered rewriting system it would behave completely differently to how we are used to working with it and things like engineering particular simp normal forms would be a very different endeavour.</p>",
        "id": 534630692,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1755253464
    }
]