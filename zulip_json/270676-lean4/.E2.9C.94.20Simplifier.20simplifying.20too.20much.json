[
    {
        "content": "<p>Given a group <code>G</code> acting on a measurable space <code>E</code> (a <code>MulAction G E</code>), I'm trying to define <code>MulAction (Measure E)</code> that acts by sending <code>g μ =&gt; μ.map (fun x =&gt; g • x)</code> (i.e., to the pushforward of <code>g</code> acting on the underlying space).</p>\n<p>However, I've run into an issue showing that this satisfies <code>one_smul</code> because the simplifier is (as far as I can tell) simplifying \"twice\". See the explanations in the code below.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">MeasureTheory</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">smul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">one_smul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">μ</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Goal is now</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ⊢ 1 • μ = μ</span>\n\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HSMul</span><span class=\"bp\">.</span><span class=\"n\">hSMul</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Goal becomes</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ⊢ map (fun x ↦ SMul.smul 1 x) μ = μ</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- ...but I'd like it to be</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ⊢ map (fun x ↦ 1 • x) μ = μ</span>\n\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n\n<span class=\"w\">  </span><span class=\"n\">mul_smul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(Maybe there is already something like this in Mathlib, but I haven't been able to find it. If it exists, I'm more than happy to use whatever is already there!)</p>",
        "id": 521066550,
        "sender_full_name": "Björn Wehlin",
        "timestamp": 1748514801
    },
    {
        "content": "<p>Just FIY this action already exists. But the action has been put on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DomMulAct#doc\">docs#DomMulAct</a> to avoid conflicting with the action of eg <code>ℝ≥0ˣ</code> by <code>(r • μ) s = r • μ s</code>.</p>",
        "id": 521066943,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1748514958
    },
    {
        "content": "<p>You can look at lemmas containing <code>domSMul</code> in their name to find it, eg <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.integral_domSMul#doc\">docs#MeasureTheory.integral_domSMul</a></p>",
        "id": 521067018,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1748514976
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/270676-lean4/topic/Simplifier.20simplifying.20too.20much/near/521066943\">said</a>:</p>\n<blockquote>\n<p>Just FIY this action already exists. But the action has been put on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DomMulAct#doc\">docs#DomMulAct</a> to avoid conflicting with the action of eg <code>ℝ≥0ˣ</code> by <code>(r • μ) s = r • μ s</code>.</p>\n</blockquote>\n<p>Thanks, I'll take a look.</p>",
        "id": 521067724,
        "sender_full_name": "Björn Wehlin",
        "timestamp": 1748515257
    },
    {
        "content": "<p>I've had this annoyance as well: trying to define an instance of a (dependent) structure, and then you want to be able to unfold the function (here smul) into exactly what you defined it to be. But there isn't any tactic that does that. The best you can do is to manyally use  <code>change</code>: <code>change μ.map (fun x =&gt; 1 • x) = _</code></p>",
        "id": 521070235,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1748516222
    },
    {
        "content": "<p>I see, thank you.</p>",
        "id": 521083819,
        "sender_full_name": "Björn Wehlin",
        "timestamp": 1748521298
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873766\">Björn Wehlin</span> has marked this topic as resolved.</p>",
        "id": 521083836,
        "sender_full_name": "Notification Bot",
        "timestamp": 1748521306
    },
    {
        "content": "<p>I usually define the <code>SMul</code> instance first, write the simp lemmas I want about it, and then define the<code>MulAction</code> afterwards.</p>",
        "id": 521087871,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748522892
    },
    {
        "content": "<p>Hi, I'm sorry but I don't think I know what you mean. I started something like this but got stuck on the same thing (I can see why this gets the same result but I don't know what the alternative you're proposing is).</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SMul</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">smul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">asdf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">μ</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">HSMul</span><span class=\"bp\">.</span><span class=\"n\">hSMul</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ SMul.smul 1 μ = μ</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 521131392,
        "sender_full_name": "Björn Wehlin",
        "timestamp": 1748537018
    },
    {
        "content": "<p>I think Kevin means something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">MeasureTheory</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SMul</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">smul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">smul_measure</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">one_smul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">smul_measure</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">mul_smul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 521136995,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748539170
    },
    {
        "content": "<p>When you have class-based notation involved, often you need to follow up with some definition lemmas that restate the operations in terms of the definition.</p>",
        "id": 521137152,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748539220
    },
    {
        "content": "<p>Then you can use those lemmas to correctly rewrite the notation into its definition.</p>",
        "id": 521137200,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748539234
    },
    {
        "content": "<p>(If classes were to extend <code>HSMul</code> instead of <code>SMul</code>, I think in <code>one_smul</code> you would see the <code>smul</code> (well, <code>hSMul</code>) definition automatically inlined. Something mathlib might want to think about doing.)</p>",
        "id": 521137717,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748539430
    },
    {
        "content": "<p>Yep:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">MeasureTheory</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MulAction'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">HSMul</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- One is the neutral element for `•` -/</span>\n<span class=\"w\">  </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">one_smul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Associativity of `•` and `*` -/</span>\n<span class=\"w\">  </span><span class=\"n\">mul_smul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MulAction'</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hSMul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">one_smul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ⊢ ∀ (b : Measure E), Measure.map (fun x =&gt; 1 • x) b = b</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">mul_smul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 521137945,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748539506
    },
    {
        "content": "<p>I see. Maybe it would also be possible to add a tactic that expands one level of definitions?</p>",
        "id": 521138367,
        "sender_full_name": "Björn Wehlin",
        "timestamp": 1748539674
    },
    {
        "content": "<p>I've found that unfolding notation typeclasses is usually not the right thing to do; these unfolding lemmas need to exist at some point or another. (I'm not saying that one-level unfolding is not wanted elsewhere though. There's a Lean RFC about it. It's necessary when trying to unfold some kinds of recursive definitions.)</p>",
        "id": 521138811,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748539836
    },
    {
        "content": "<p>(I just tried using <code>simp +singlePass only [HSMul.hSMul]</code>, but that doesn't work. I also tried it as <code>simp +singlePass only [↑HSMul.hSMul]</code> in case <code>↑</code> is respected, but it doesn't seem to be.)</p>",
        "id": 521139515,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748540119
    },
    {
        "content": "<p>Can instead <code>Smul</code> be defined as an extension of <code>HSmul</code>? That saves unfolding <code>SMul.smul</code>.</p>\n<p>And the same for <code>Add</code> extending <code>HAdd</code> etc.?</p>",
        "id": 521149720,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1748543932
    },
    {
        "content": "<p>Yeah, possibly.</p>\n<p>I've also wondered about the possibility of making the non-heterogenous classes be abbreviations for the heterogenous ones.</p>",
        "id": 521150355,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748544192
    },
    {
        "content": "<p>What about the <code>@[default_instance]</code> annotations? I presume those are the reason why we can't have <code>abbrev</code>s like you suggest?</p>",
        "id": 521255085,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1748597017
    },
    {
        "content": "<p>Yes, that's what I was wondering about. I just had a moment to test it out. Default instances don't have any loop checking, so it causes divergence when an instance can't be found. The low-priority was also necessary to make sure it gets tried <em>after</em> the Nat OfNat instance, to prevent another divergence.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">HOp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">γ</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">HOp</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">default_instance</span><span class=\"w\"> </span><span class=\"n\">low</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">instOp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Op</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HOp</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‹</span><span class=\"n\">Op</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">›</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Op</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Op</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">()</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">HOp</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">HOp</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">HOp</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"c1\">-- stack overflow</span>\n</code></pre></div>\n<p>Some options:</p>\n<ol>\n<li>Have a variant of <code>default_instance</code> that's just for causing a unification (here, making a heterogenous operator become homogeneous). Not sure how this would work with the various Pow classes.</li>\n<li>Make default instances be more aware of loops.</li>\n<li>Don't rearrange the classes, but give structure instance notation the ability to unfold classes like <code>HAdd.hAdd</code> automatically somehow. Maybe that could enable <code>simp [(· + ·)]</code> finally working (in the sense that it actual unfolds all the way to the underlying instance).</li>\n</ol>",
        "id": 521380131,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748644069
    },
    {
        "content": "<p>What's wrong with using <code>extends</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">HOp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">γ</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">HOp</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">default_instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Op</span><span class=\"bp\">.</span><span class=\"n\">toHOp</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Op</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Op</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">()</span>\n\n<span class=\"kn\">infix</span><span class=\"o\">:</span><span class=\"mi\">60</span><span class=\"w\"> </span><span class=\"s2\">\"#\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">HOp</span><span class=\"bp\">.</span><span class=\"n\">op</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"c1\">-- successfully infers return type `Nat`</span>\n\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">CommOp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Op</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">op_comm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommOp</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">add</span>\n<span class=\"w\">  </span><span class=\"n\">op_comm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"c1\">-- automatically unfolds into my given definition of `op`:</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ⊢ ∀ (a b : Int), a.add b = b.add a</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This does the same as the current behaviour. Except it works nicely with definiting structures, exactly how I had wanted it to.</p>",
        "id": 521382234,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1748645578
    },
    {
        "content": "<p>I never meant to suggest that anythign was wrong with using <code>extends</code>, and it's a natural idea that I expected to work. I wanted to understand the solution space here.</p>",
        "id": 521382569,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748645858
    },
    {
        "content": "<p>Similarly, it would be nice to extend <code>OfNat α (nat_lit 0)</code> instead of <code>Zero α</code>. But then you run into the trouble that <code>Ring</code> will have two different fields named <code>ofNat</code>, namely for 0 and for 1.</p>",
        "id": 521393270,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1748654055
    }
]