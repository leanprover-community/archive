[
    {
        "content": "<p>I noticed that in <code>Mathlib/Geometry/Euclidean/SignedDist.lean</code>, elaboration of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">signedInfDist</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">→ᵃ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">innerₗ</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">-ᵥ</span><span class=\"w\"> </span><span class=\"n\">orthogonalProjection</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">‖⁻¹</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">-ᵥ</span><span class=\"w\"> </span><span class=\"n\">orthogonalProjection</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">toAffineMap</span><span class=\"bp\">.</span><span class=\"n\">comp</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">AffineMap</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">-ᵥ</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">orthogonalProjection</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>is sped up by about 40% if we replace <code>orthogonalProjection</code> with <code>EuclideanGeometry.orthogonalProjection</code>. Even though we have used <code>open EuclideanGeometry</code>, Lean still attempts to elaborate <code>orthogonalProjection</code> in the root namespace before it tries it in the <code>EuclideanGeometry</code> namespace.</p>\n<p>Is this kind of behaviour expected? I hadn't expected that Lean attempts to elaborate constants in multiple different ways. And is there a way to change the order in which these are attempted? I feel like writing <code>open X</code> should give priority to constants in the <code>X</code> namespace over those in the root namespace.</p>",
        "id": 513277321,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745157984
    },
    {
        "content": "<p>Have you verified your hypothesis that it attempts one of the names before another? I thought that the way it worked is that it tries all interpretations simultaneously. The \"ambiguous interpretation\" error is when elaboration errors don't winnow down the list.</p>",
        "id": 513290312,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1745168453
    },
    {
        "content": "<p>I discovered it by looking at the profiler trace: it was unsuccesfully trying to find some weird coercion. This turned out to come from trying the wrong <code>orthogonalProjection</code>. Fully specifying the name got rid of this.</p>",
        "id": 513290793,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745168871
    },
    {
        "content": "<p>That's consistent with trying all interpretations simultaneously, right?</p>",
        "id": 513291061,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1745169091
    },
    {
        "content": "<p>Yes that's right. I first thought you meant it was doing parallel computation</p>",
        "id": 513291142,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745169147
    },
    {
        "content": "<p>Oh no, sorry, I mean more like concurrently (but without any multiplexing). It saves the elaborator state and attempts all interpretations of the constant.</p>",
        "id": 513291338,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1745169331
    },
    {
        "content": "<p>This is know behavior, and it's a reason why it can be good to choose different names for things even if they're in different namespaces.</p>",
        "id": 513291425,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1745169383
    },
    {
        "content": "<p>Since you've been looking at this case, I'm idly wondering whether there are any heuristics that we might consider in the app elaborator to be able to fail fast on <code>_root_.orthogonalProjection</code>. (The heuristic needs to have no false negatives.) Does anything pop out to you?</p>",
        "id": 513291549,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1745169507
    },
    {
        "content": "<p>I don't think there is a way to make it fail particularly fast; it has to attempt coercions to make sure the elaboration fails.</p>",
        "id": 513292246,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745170202
    },
    {
        "content": "<p>Should we just move it to <code>Submodule.orthogonalProjection</code>?</p>",
        "id": 513293936,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1745171955
    },
    {
        "content": "<p>(and the other one to <code>AffineSubspace.orthogonalProjection</code>)</p>",
        "id": 513293950,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1745171973
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/24247\">#24247</a> does the rename to <code>Submodule.orthogonalProjection</code></p>",
        "id": 513343967,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745212798
    },
    {
        "content": "<p>Should we rename <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasOrthogonalProjection#doc\">docs#HasOrthogonalProjection</a> to <code>Submodule.OrthogonalProjection</code> (note the lack of <code>Has</code>)?</p>",
        "id": 513468019,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1745268644
    },
    {
        "content": "<p>I'm not too sure about the naming conventions. This class doesn't contain data, just a proof that there exists some orthogonal projection, so it is a bit different form classes like <code>Add</code> that give an <code>add</code> function. So I think the <code>Has</code> might describe to this?</p>",
        "id": 513469395,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745269329
    },
    {
        "content": "<p>Aha, so it should be <code>Is</code>, except <code>Is</code> doesn't make any sense, so it's <code>Has</code>. Sure, I agree with this logic.</p>",
        "id": 513475908,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1745272660
    }
]