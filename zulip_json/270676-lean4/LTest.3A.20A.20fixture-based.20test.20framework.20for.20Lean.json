[
    {
        "content": "<p>Hello everyone,</p>\n<p>I've experimented with several iterations of a test framework similar to <a href=\"https://docs.pytest.org/\"><code>pytest</code></a> and <a href=\"https://github.com/la10736/rstest\"><code>rstest</code></a>.<br>\nThe current iteration is <code>LTest</code>, a fixture-based test framework for Lean 4 which should aid testing of IO focused programs and libraries with  dependencies that require significant effort for setup and teardown.</p>\n<p>It's available here: <a href=\"https://github.com/alexf91/LTest/\">https://github.com/alexf91/LTest/</a></p>\n<p>It's all quite experimental and my first deeper journey into Lean and Lean metaprogramming beyond a few tutorials and manuals, but I think it's usable. At this point, it supports fixtures and testcases, both implemented as macros.</p>\n<p>A fixture has a state of type <code>σ</code>, a value of type <code>α</code> and three fields:</p>\n<ul>\n<li><code>default : σ</code> the default value of the state</li>\n<li><code>setup : ... → StateT σ IO α</code> returns the value passed to dependencies</li>\n<li><code>teardown : StateT σ IO Unit</code> for cleanup</li>\n</ul>\n<p>Only the <code>setup</code> function is required, unless <code>σ</code> is not inhabited. Then default has to be set.</p>\n<p>A fixture for the value <code>0</code> and without a state looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">fixture</span> <span class=\"n\">Zero</span> <span class=\"n\">Unit</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span>\n  <span class=\"n\">default</span>  <span class=\"o\">:=</span> <span class=\"o\">()</span>\n  <span class=\"n\">setup</span>    <span class=\"o\">:=</span> <span class=\"k\">do</span> <span class=\"n\">return</span> <span class=\"mi\">0</span>\n  <span class=\"n\">teardown</span> <span class=\"o\">:=</span> <span class=\"n\">return</span>\n</code></pre></div>\n<p>Fixtures can also depend on other fixtures by specifying them as a requirement.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">fixture</span> <span class=\"n\">One</span> <span class=\"n\">Unit</span> <span class=\"n\">Nat</span> <span class=\"n\">requires</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Zero</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">setup</span> <span class=\"o\">:=</span> <span class=\"k\">do</span> <span class=\"n\">return</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>Finally, we can define a testcase.<br>\nA testcase always has the type <code>IO Unit</code>, but can also depend on fixtures.<br>\nJust like for fixtures, requirements are optional.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">testcase</span> <span class=\"n\">testNothing</span> <span class=\"o\">:=</span> <span class=\"k\">do</span> <span class=\"n\">return</span>\n\n<span class=\"n\">testcase</span> <span class=\"n\">testOne</span> <span class=\"n\">requires</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">One</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">assertEqual</span> <span class=\"n\">n</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>Eventually, we want to run testcases. They are compiled into a program. The <code>main</code> function<br>\nis created with <code>#LTestMain</code>. Tests are registered with an extension when they are declared.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">LTestMain</span>\n</code></pre></div>\n<p>Teardowns are executed in reverse order of their setup functions.<br>\nDuring execution, <code>stdout</code> and <code>stderr</code> are captured for setups, teardowns and the testcase itself.<br>\nThey are reported when a testsuite is run and something fails. There are a few examples in the <code>examples</code> directory.</p>\n<p>The framework is still missing a lot of things, and some of them (parameters...) might require a redesign:</p>\n<ul>\n<li>Parametrized fixtures and testcases</li>\n<li>Running testcases in interactive mode or during compilation</li>\n<li>Reporting where an assertion failed</li>\n<li>Scopes: Currently everything is scoped most locally (every fixture instance has its own state),<br>\n<code>pytest</code> would call the setup function of a fixture used by multiple dependencies only once for every testcase, not every time it appears in a requirements field (basically a topsort with some constraints for scopes).<br>\n         This can be mitigated with <code>IO.Ref</code>s to some extent.</li>\n</ul>\n<p>The implementation itself is another story, especially the macros, but it's all work in progress.<br>\nI'm open for suggestions. This is not used anywhere, so everything can break.</p>",
        "id": 356197079,
        "sender_full_name": "Alexander Fasching",
        "timestamp": 1683339606
    }
]