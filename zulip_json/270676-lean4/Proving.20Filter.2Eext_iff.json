[
    {
        "content": "<p>I was trying out <a href=\"https://github.com/bridgekat/filter-game\">https://github.com/bridgekat/filter-game</a> and proving <code>Filter.ext_iff</code> in it, by following only the hints given by Lean and <a href=\"https://github.com/madvorak/lean4-cheatsheet/blob/main/lean-tactics.pdf\">this tactics cheat sheet</a>, I got the 2nd proof <code>Filter.ext_iff''</code> in the following <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, it's much more verbose than the 1st simple proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Filter.Basic</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Filter.ext_iff₁</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">filter_eq_iff</span><span class=\"o\">,</span> <span class=\"n\">Set.ext_iff</span><span class=\"o\">,</span> <span class=\"n\">Filter.mem_sets</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Filter.ext_iff₂</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Iff.intro</span>\n  <span class=\"bp\">.</span> <span class=\"n\">intro</span> <span class=\"n\">f_eq_g</span>\n    <span class=\"n\">intro</span> <span class=\"n\">s</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Iff.intro</span>\n    <span class=\"bp\">.</span> <span class=\"n\">intro</span> <span class=\"n\">s_mem_f</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">&lt;-</span><span class=\"n\">f_eq_g</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">s_mem_f</span>\n    <span class=\"bp\">.</span> <span class=\"n\">intro</span> <span class=\"n\">s_mem_g</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">f_eq_g</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">s_mem_g</span>\n  <span class=\"bp\">.</span> <span class=\"n\">intro</span> <span class=\"n\">set_mem_iff</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">filter_eq_iff</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.ext_iff</span><span class=\"o\">]</span>\n    <span class=\"n\">intro</span> <span class=\"n\">s</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">set_mem_iff</span> <span class=\"n\">s</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Filter.mem_sets</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">set_mem_iff</span>\n</code></pre></div>\n<p>My question is: </p>\n<ol>\n<li>Is there somewhere between these 2 proofs that's idiomatic and also down to the basics?</li>\n<li>How could I realize that the proof can be a <code>simp only</code> with a few lemmas when <code>simp?</code> made no progress? Can <code>simp</code> somehow give some hints about what shapes of the assumptions and goals it faced right before  it gave up so that I might figure out the lemmas?</li>\n</ol>",
        "id": 390157952,
        "sender_full_name": "Utensil Song",
        "timestamp": 1694359774
    },
    {
        "content": "<p>I am not sure about the <code>Filter</code> proof, since I never really worked with filters.</p>\n<p>As for <code>simp</code>, when it fails, it means that it tried <em>all</em> simp lemmas and was able to apply <em>none</em>.  This means that place where it was when it failed is exactly where you are.</p>\n<p>The other question, about what lemmas to add, that is <em>very</em> dependent on context and if there were a good automation for that, more proof would be easier to formalize!</p>",
        "id": 390162086,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1694363357
    },
    {
        "content": "<p>Thanks for your answer~</p>\n<p>I'm asking Q1 because I wonder how experts simplify their proofs in general. This is a simple proof which uses little knowledge about filters but lots of basics of Lean 4. So it could be a good example for discussion.</p>\n<p>By Q2, I imagine <code>simp</code> (or other automation tactics, e.g. <code>aesop</code>) would know its search depth and evaluate the complexity of the remaining goals and can provide useful insight even in failure.</p>",
        "id": 390163408,
        "sender_full_name": "Utensil Song",
        "timestamp": 1694364569
    },
    {
        "content": "<p>I also would like to share my experience about places where I thought Lean 4 would help me (from my Lean 3 experience) but instead I was confused:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<ol>\n<li>When I typed the first line of the theorem that ends with <code>by</code>, I got <code>unexpected end of input; expected '{'</code> but expected to feel normal inside the tactic mode</li>\n<li>Whey I typed the dot after <code>apply Iff.intro</code>, I got the same error</li>\n<li>When I typed the dot in a new line with the right indentation, I got 1 goal in Tactic State, and an error \"unsolved goals\" in \"Messages\", which is a duplication of the goal in Tactic State, then I need to collapse it to avoid visual influence</li>\n<li>When I typed the first dot line such as <code>. intro s_mem_f</code> (which has 1 tactic and should leave unresolved goals) and enter, I got an indentation aligned with the dot, so that Lean is not giving me goals within the case after the tactic, so I have to figure out I need to indent to be back in the case to see the effect of the first line</li>\n<li>When I typed <code>exact s_mem_g</code> and enter, I end up in a new line indented within the case, and Tactic State is saying \"No gaols\", but code has error underlines, I have to expand \"All messages\" (which usually contain duplicated messages, so I collapse them to avoid visual influence) to see the rest of goals. Again I realized that I need to un-indent to get hints back in Tactic State</li>\n<li>When I'm after <code>rw [filter_eq_iff]</code>, I have no idea how to proceed exactly, I know I need an <code>iff</code> from Set, but I have no hints from Lean if I typed <code>rw [Set.</code>, so I have to guess it by name convetion</li>\n<li>Whenever I want to <code>intro</code> with a single letter, the auto complete would always change my letter e.g. <code>s</code> into something that already existed like <code>S</code>, I have to click or hit Esc to avoid the change before I hit enter to change to the new line</li>\n<li>When I typed <code>specialize</code>, Lean seemed to accept it with no argument, but it made no progress, I kind of hoped that I can have some hints for the arguments, but no, so I read the hover doc, and fill the 1st argument, then I really don't know what to do next, what kind of expression should I provide? No hints, I have to use my <code>intro</code> mind to fill the 2nd argument (Strangely, this time the autocomplete is not change my <code>s</code>)</li>\n<li>Finally, when I'm at the end of the line <code>exact set_mem_iff</code>, I got no error but also I saw a \"goal\" in the infoview, I thought I haven't finished, but when I enter, the new line gives me a clean \"No goals\", I went back and realized that the goal is in the \"Expected Type\", it shadows me from seeing \"No goals\" in \"Tactic state\".</li>\n</ol>\n</div></div>",
        "id": 390163564,
        "sender_full_name": "Utensil Song",
        "timestamp": 1694364717
    },
    {
        "content": "<p>With the help of <code>#explode</code>, I have managed to get somewhere in between:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Filter.ext_iff₃</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">calc</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">f.sets</span> <span class=\"bp\">=</span> <span class=\"n\">g.sets</span><span class=\"o\">)</span>                           <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">filter_eq_iff</span><span class=\"o\">]</span>\n          <span class=\"n\">_</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">f.sets</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">g.sets</span>      <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.ext_iff</span><span class=\"o\">]</span>\n          <span class=\"n\">_</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">g</span>                <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">Filter.mem_sets</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>However, I can't make <code>simp_rw</code> go away with more explicit form without increasing the \"step count\" in <code>#explode</code>, nor can I get \"step count\" close to 19 in an explicit form.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- 19</span>\n<span class=\"bp\">#</span><span class=\"n\">explode</span> <span class=\"n\">Filter.ext_iff₁</span>\n\n<span class=\"c1\">-- 38</span>\n<span class=\"bp\">#</span><span class=\"n\">explode</span> <span class=\"n\">Filter.ext_iff₂</span>\n\n<span class=\"c1\">-- 31</span>\n<span class=\"bp\">#</span><span class=\"n\">explode</span> <span class=\"n\">Filter.ext_iff₃</span>\n</code></pre></div>\n<p>My attempts and the <code>#explode</code> tables can be view <a href=\"https://utensil.github.io/lean-playground/FiltersMWE.html\">here</a> . Any hint would be appreciated. <span aria-label=\"thank you\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"thank you\">:thank_you:</span></p>",
        "id": 391845029,
        "sender_full_name": "Utensil Song",
        "timestamp": 1695107694
    }
]