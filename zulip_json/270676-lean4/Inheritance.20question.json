[
    {
        "content": "<p>I have a very basic question but I'm not sure about the idiomatic solution. Maybe I'm too much used to python, but I want to be able to write a function taking as argument any object inheriting from some basic class. Ideally I would like to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Enough</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n</code></pre></div>\n<p>and then define a function </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">getX</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"s2\">\"some way to state that α is a structure extending Enough\"</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">a.x</span>\n</code></pre></div>\n<p>That could be applied to <code>x : Extra</code> where</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Extra</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n</code></pre></div>\n<p>I know I can use</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Enough</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">getX</span> <span class=\"o\">[</span><span class=\"n\">Enough</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">Enough.x</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Extra</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Enough</span> <span class=\"o\">(</span><span class=\"n\">Extra</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">Extra.x</span>\n  <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">Extra.y</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">getX</span> <span class=\"o\">(</span><span class=\"n\">Extra.mk</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But this doesn't feel right. What am I missing?</p>",
        "id": 391949736,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695140478
    },
    {
        "content": "<p>I think that's the idiomatic solution, as it's what we use to generalize over subobjects and morphisms</p>",
        "id": 391949946,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695140527
    },
    {
        "content": "<p>What you (and everyone else) are missing is automation to build this automatically</p>",
        "id": 391949968,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695140537
    },
    {
        "content": "<p>Your alternative is to exploit dot notation \"seeing through\" <code>extends</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Enough</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Enough.getX</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Enough</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">a.x</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Extra</span> <span class=\"kd\">extends</span> <span class=\"n\">Enough</span> <span class=\"n\">where</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Extra</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getX</span>\n</code></pre></div>",
        "id": 391950447,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695140680
    },
    {
        "content": "<p>Yes, this is inspired by what we do in algebraic situations, but somehow it feels weirder when <code>Extra</code> has no parameter at all.</p>",
        "id": 391950591,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695140719
    },
    {
        "content": "<p>These correspond roughly to what C++ calls dynamic polymorphism and static polymorphism, respectively</p>",
        "id": 391950655,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695140738
    },
    {
        "content": "<p>I'm curious how Rust and Haskell solve this</p>",
        "id": 391950767,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695140765
    },
    {
        "content": "<p>I have a hard time deciding whether I should use the dot notation trick. It really feels dirty.</p>",
        "id": 391951137,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695140899
    },
    {
        "content": "<p>It also breaks <code>Extra.mk 1 2 3</code>, though you can fix that by writing <code>Extra.mk {} 1 2 3</code> and using the <code>FlatHack</code> trick from my CICM paper</p>",
        "id": 391951294,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695140935
    },
    {
        "content": "<p>Currently in my code I use the solution I showed at the beginning of this thread, with a ugly derive handler.</p>",
        "id": 391951639,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695141004
    },
    {
        "content": "<p>And I really mean ugly: <a href=\"https://github.com/leanprover-community/mathlib4/blob/pm_widgets/Mathlib/Tactic/Widget/SelectInsertParamsClass.lean\">https://github.com/leanprover-community/mathlib4/blob/pm_widgets/Mathlib/Tactic/Widget/SelectInsertParamsClass.lean</a></p>",
        "id": 391951821,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695141051
    },
    {
        "content": "<p>It does the job at <a href=\"https://github.com/leanprover-community/mathlib4/blob/pm_widgets/Mathlib/Tactic/Widget/Calc.lean#L50-L54\">https://github.com/leanprover-community/mathlib4/blob/pm_widgets/Mathlib/Tactic/Widget/Calc.lean#L50-L54</a> but don't dare PRing this.</p>",
        "id": 391952029,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695141112
    },
    {
        "content": "<p>What's the <code>getX</code> in your application?</p>",
        "id": 391952389,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695141241
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Inheritance.20question/near/391950767\">said</a>:</p>\n<blockquote>\n<p>I'm curious how Rust and Haskell solve this</p>\n</blockquote>\n<p>It looks like Rust does the same thing as what you did above (their <code>trait</code> is our <code>class</code>/<code>instance</code>)</p>",
        "id": 391952453,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695141254
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Inheritance.20question/near/391952389\">said</a>:</p>\n<blockquote>\n<p>What's the <code>getX</code> in your application?</p>\n</blockquote>\n<p>There are simply the fields of <code>SelectInsertParamsClass</code>.</p>",
        "id": 391952911,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695141440
    },
    {
        "content": "<p>So my example would be closer to my actual code as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Enough</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Extra</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Enough</span> <span class=\"o\">(</span><span class=\"n\">Extra</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">Extra.x</span>\n  <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">Extra.y</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">Enough.x</span> <span class=\"o\">(</span><span class=\"n\">Extra.mk</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 391953107,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695141498
    },
    {
        "content": "<p>I think the dot notation trick doesn't work anyway, it does not allow to assign a type to functions that would need to use this trick.</p>",
        "id": 391954272,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695141964
    },
    {
        "content": "<p>I think <code>extends</code> generates a <code>Coe</code> instance, doesn't it? Could you use <code>Coe A Enough</code>?</p>",
        "id": 391954626,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1695142088
    },
    {
        "content": "<blockquote>\n<p>I think the dot notation trick doesn't work anyway, it does not allow to assign a type to functions that would need to use this trick.</p>\n</blockquote>\n<p>These functions would just consume an <code>Enough</code> (the base structure)</p>",
        "id": 391954700,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695142115
    },
    {
        "content": "<p>I would have reached for a coercion first also</p>",
        "id": 391954890,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1695142193
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Inheritance.20question/near/391954700\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think the dot notation trick doesn't work anyway, it does not allow to assign a type to functions that would need to use this trick.</p>\n</blockquote>\n<p>These functions would just consume an <code>Enough</code> (the base structure)</p>\n</blockquote>\n<p>I need them to consume more general arguments, otherwise there would be no discussion.</p>",
        "id": 391955052,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695142245
    },
    {
        "content": "<p>You could also consider</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Enough</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ToEnough</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toEnough</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Enough</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Extra</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Enough</span> <span class=\"o\">(</span><span class=\"n\">Extra</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toEnough</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">e</span> <span class=\"k\">with</span> <span class=\"o\">}</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">Enough.x</span> <span class=\"o\">(</span><span class=\"n\">ToEnough.toEnough</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Extra.mk</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 391956487,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695142756
    },
    {
        "content": "<p>Indeed that also works, but still feels clunky (and requires a derive handler too).</p>",
        "id": 391956788,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695142857
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/Inheritance.20question/near/391954626\">said</a>:</p>\n<blockquote>\n<p>I think <code>extends</code> generates a <code>Coe</code> instance, doesn't it? Could you use <code>Coe A Enough</code>?</p>\n</blockquote>\n<p>maybe it <em>should</em> autogenerate a <code>Coe</code> instance...... but that's something that would require core changes, I assume</p>",
        "id": 391957053,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1695142951
    },
    {
        "content": "<p>I don't think automatic generation of <code>Coe</code> is a good idea</p>",
        "id": 391958415,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695143476
    },
    {
        "content": "<p>Then a <code>To A B</code> class that is isomorphic to <code>Coe B A</code> but without the transitivity and notational baggage :)</p>",
        "id": 391958747,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1695143610
    }
]