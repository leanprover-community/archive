[
    {
        "content": "<p>Why can't we just use <code>Sort (max 1 u)</code> everywhere instead of <code>Type u</code>? I can't think of any problems this could cause other than \"It's longer to type\" (and the solution is, use a macro).</p>",
        "id": 495412873,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737600440
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/270676-lean4/topic/.60Sort.20.28max.201.20u.29.60/near/495412873\">said</a>:</p>\n<blockquote>\n<p>Why can't we just use <code>Sort (max 1 u)</code> everywhere instead of <code>Type u</code>? I can't think of any problems this could cause other than \"It's longer to type\" (and the solution is, use a macro).</p>\n</blockquote>\n<p>I think Type is very much a macro for Sort by design.</p>\n<p>To quote theorem proving in lean:<br>\n\"Moreover, <code>Type u</code> is also just syntactic sugar for <code>Sort (u+1)</code>\"</p>\n<p>from <a href=\"http://lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositions-as-types\">lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositions-as-types</a></p>",
        "id": 495413066,
        "sender_full_name": "Abraham Solomon",
        "timestamp": 1737600559
    },
    {
        "content": "<p>My understanding for the reason for <code>Type u</code> being <code>Sort (u + 1)</code> instead of <code>Sort (max u 1)</code> is that universe level unification works better for the former.</p>\n<p>This is a reason why there's both <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sigma#doc\">docs#Sigma</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PSigma#doc\">docs#PSigma</a>, or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod#doc\">docs#Prod</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PProd#doc\">docs#PProd</a>. The non-prop-polymorphic variants have less delicate universe levels.</p>",
        "id": 495413976,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737601145
    },
    {
        "content": "<p>Why is this \"delicate\"? Is it because you have to unify a max instead of a succ?</p>",
        "id": 495414249,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737601305
    },
    {
        "content": "<p>Two examples:</p>\n<ul>\n<li>If you unify <code>Type</code> and <code>Sort (u + 1)</code>, the only possible solution is <code>u = 0</code>, so we can assign <code>u := 0</code>.</li>\n<li>If you unify <code>Type</code> and <code>Sort (max u 1)</code>, there are two solutions <code>u = 0</code> and <code>u = 1</code>. We cannot assign <code>u</code>, so unification fails.</li>\n</ul>",
        "id": 495414511,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737601479
    },
    {
        "content": "<p>I see. Maybe I have been thinking too much \"in theory\". In theory, I could find and replace all instances of <code>Type u</code> with <code>Sort (max 1 u)</code> in all of Init and Mathlib, but in practice you encounter problems like this.</p>",
        "id": 495414745,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737601637
    },
    {
        "content": "<p>Context : Just now, I was unable to define an instance of <code>Monad fun t =&gt; (t -&gt; r) -&gt; r</code> for <code>r</code> possibly a <code>Prop</code>. I think I have found a workaround.</p>",
        "id": 495414911,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737601779
    },
    {
        "content": "<p>Why would <code>Sort (max 1 u)</code> help if a <code>Prop</code> is required?</p>",
        "id": 495415568,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1737602202
    },
    {
        "content": "<p>also if you have a <code>Prop</code> and you need a <code>Type</code>, there's always <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PLift#doc\">docs#PLift</a></p>",
        "id": 495415640,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1737602251
    },
    {
        "content": "<p>Another thing worth noting is that whilst our mental model of universe levels is Nat, there apparently aren't enough axioms known to the system to make it Nat so the less complicated the better. Didn't someone give the example once that the system doesn't know that max u v is either u or v?</p>",
        "id": 495439408,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1737617428
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/270676-lean4/topic/.60Sort.20.28max.201.20u.29.60/near/495412873\">said</a>:</p>\n<blockquote>\n<p>Why can't we just use <code>Sort (max 1 u)</code> everywhere instead of <code>Type u</code>? I can't think of any problems this could cause other than \"It's longer to type\" (and the solution is, use a macro).</p>\n</blockquote>\n<p>you say you can't think of any downsides, but are there <em>upsides</em>? Right now, i don't understand why you would want this change...</p>",
        "id": 495452022,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1737622289
    },
    {
        "content": "<p>btw, you might run into some issues as follows: let <code>X : Type 1</code>, and a function <code>foo.{u} : Type u -&gt; Z</code>. Then <code>foo.{1} X</code> typechecks when <code>Type u = Sort (u + 1)</code>, while it doesn't when <code>Type u = Sort (max 1 u)</code>.</p>",
        "id": 495452686,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1737622511
    },
    {
        "content": "<p>I think early versions of Lean actually defined <code>Type u = Sort (max 1 u)</code></p>",
        "id": 495464492,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737626654
    },
    {
        "content": "<p>i'd just like to note that for the life of me i can't figure out why you'd want <code>Type 0</code>  and <code>Type 1</code> to refer to the same thing</p>",
        "id": 495465788,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1737626986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/270676-lean4/topic/.60Sort.20.28max.201.20u.29.60/near/495464492\">said</a>:</p>\n<blockquote>\n<p>I think early versions of Lean actually defined <code>Type u = Sort (max 1 u)</code></p>\n</blockquote>\n<p>Yes, this is correct (EDIT: I think we actually didn't call it <code>Type u</code>, but we wrote <code>Sort (max 1 u)</code> frequently explicitly). <br>\nIIRC it was the case in Lean 2. It worked fine most of the time, but sometimes (significantly more often than in Lean 3), you had to give some universe variables explicitly.</p>",
        "id": 495473381,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1737629249
    },
    {
        "content": "<p>I wonder if there's some elaborator shenanigans you can use to make it do \"If <code>Sort (max 1 u) =?= Type v</code> is stuck then try <code>u =?= v + 1</code>. I think maybe.</p>",
        "id": 495486258,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737633636
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/270676-lean4/topic/.60Sort.20.28max.201.20u.29.60/near/495452022\">said</a>:</p>\n<blockquote>\n<p>You can't think of any downsides, but are there <em>upsides</em>? Right now, i don't understand why you would want this change...</p>\n</blockquote>\n<p>I think I was thinking about this because <code>Sort (max 1 u)</code> is more general then <code>Type u</code>. It <del>unifies</del> can unify with more things.</p>",
        "id": 495486590,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737633719
    },
    {
        "content": "<p>i don't see how it is more general, though?</p>",
        "id": 495486829,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1737633783
    },
    {
        "content": "<p>wouldn't you then at least want <code>Sort (max 1 (u + 1))</code> or something?</p>",
        "id": 495487025,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1737633846
    },
    {
        "content": "<p>Isn't that just <code>Type u</code>?</p>",
        "id": 495487102,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737633865
    },
    {
        "content": "<p>it is, but spelled more fancily</p>",
        "id": 495487199,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1737633886
    },
    {
        "content": "<p>Also, since <code>Type u</code> can be spelled as <code>Sort (max 1 (u + 1))</code>, <code>Sort (max 1 u)</code> is strictly more general than <code>Type u</code>.</p>",
        "id": 495487831,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737634119
    },
    {
        "content": "<p>it's <em>wrong</em> for the same reason tho?</p>",
        "id": 495487946,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1737634180
    },
    {
        "content": "<p>what about <code>Sort (max 1 (max 1 u))</code>?</p>",
        "id": 495488017,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1737634246
    },
    {
        "content": "<p>How about \"try again later\"? Is that an option?</p>",
        "id": 495488483,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737634492
    },
    {
        "content": "<p>my point is, since the values <code>Sort (max 1 u)</code> and <code>Sort (u + 1)</code> can take are the same, neither is \"more general\"</p>",
        "id": 495488646,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1737634607
    },
    {
        "content": "<p>There are models of Lean where that is not the case :)</p>",
        "id": 495494163,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737637735
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/270676-lean4/topic/.60Sort.20.28max.201.20u.29.60/near/495488483\">said</a>:</p>\n<blockquote>\n<p>How about \"try again later\"? Is that an option?</p>\n</blockquote>\n<p>Sort of. There are lots of tasks that are conditional on whether unification succeeds, and there's no mechanism to go back once unification does succeed to try the other path.</p>\n<p>But there are also other tasks that defer defeq checking. For example, when there is a type error, it might be possible to insert a coercion. This is a deferred task, and periodically the system will try two things: (1) check defeq (and if defeq, no need to insert a coercion), (2) check if there is a coercion we can synthesize with the current information.</p>\n<p>Having too many deferred tasks like this is bad for performance though.</p>\n<p>I thought I remembered that deferred tasks would try a more forceful unification as a last resort, but that doesn't seem to be the case. What does seem to be the case is that defeq has <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.Config.univApprox#doc\">docs#Lean.Meta.Config.univApprox</a> true by default. You can check its docstring, but the gist is that it's willing to use approximate solutions, like for <code>max u ?v =?= u</code> it uses <code>?v := u</code> even though there could be other solutions.</p>",
        "id": 495494817,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737637917
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/270676-lean4/topic/.60Sort.20.28max.201.20u.29.60/near/495488017\">said</a>:</p>\n<blockquote>\n<p>what about <code>Sort (max 1 (max 1 u))</code>?</p>\n</blockquote>\n<p>Right now I can't think of any situation in which you would have this with the answer not being just <code>max 1 u</code>.</p>",
        "id": 495887305,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737824509
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Level.normalize#doc\">docs#Lean.Level.normalize</a> ensures any such situations dissappear quickly</p>",
        "id": 495915080,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737848871
    },
    {
        "content": "<p>On the theoretical side: it's important that the theory of levels is decidable. So allowing something seemingly mild as multiplication for levels, for example, would break this property.</p>",
        "id": 495922329,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1737856093
    },
    {
        "content": "<p>Universes aren't naturals, and so don't (and shouldn't) really have arithmetic. How I understand it is, universes form a Well Quasiorder (well-founded partial order) with bottom element <code>0</code>, injective successor operation <code>+1</code> compatible with the order, and a lattice-like join operation <code>max</code> compatible with the order (and <code>imax</code>, which is weird).</p>\n<p>There is an injection from the naturals to the universes, and these are the only definable concrete universes in Lean's type theory, but don't confuse the universes with the naturals.</p>",
        "id": 495923041,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737856763
    },
    {
        "content": "<p>Actually, does it have to be well founded? It's fine as long as you don't get Yablo's paradox, and that can probably be enforced with definability constraints.</p>",
        "id": 495923500,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737857133
    },
    {
        "content": "<p>nvm, it has to be well-founded because the ordinals are well founded.</p>",
        "id": 495923591,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737857226
    },
    {
        "content": "<p>No! You need a decidable theory in order to make sense of the type theory itself. Requiring wellfoundedness, regardless what you mean, makes the theory undecidable.</p>",
        "id": 495925549,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1737859134
    },
    {
        "content": "<p>What do you mean by decidable?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/channel/270676-lean4/topic/.60Sort.20.28max.201.20u.29.60/near/495925549\">said</a>:</p>\n<blockquote>\n<p>No! You need a decidable theory in order to make sense of the type theory itself. Requiring wellfoundedness, regardless what you mean, makes the theory undecidable.</p>\n</blockquote>",
        "id": 495926042,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737859651
    },
    {
        "content": "<p>The usual thing: there is some program (not necessarily efficient) that correctly returns true or false given a sentence in the language of the given theory.</p>",
        "id": 495926213,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1737859825
    },
    {
        "content": "<p>Why do I need decidable to \"make sense of the type theory\"? What does \"make sense\" mean?</p>",
        "id": 495926604,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737860227
    },
    {
        "content": "<p>You need to know what is and what isn't a rule.</p>",
        "id": 495926723,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1737860336
    },
    {
        "content": "<p>Do you mean like decidable axioms? (Given any logical formula, it is decidable to tell whether it is an axiom or not.)</p>",
        "id": 495926906,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737860507
    },
    {
        "content": "<p>No, I mean a decidable theory of levels. However, this is so that the type theory is axiomatizable (it is decidable whether a sequent is an axiom or not).</p>",
        "id": 495927162,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1737860763
    },
    {
        "content": "<p>So, \"given a level formula, it is decidable whether it is true or false\"? I don't see why you would need that to \"make sense\" of the type theory. Most of math isn't decidable, but I think it is still possible to make sense of it.</p>",
        "id": 495927320,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737860942
    },
    {
        "content": "<p>Presburger arithmetic is decidable and so is Lean's level theory, which is a mild extension of it.</p>",
        "id": 495927696,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1737861346
    },
    {
        "content": "<p>I don't think there is universe level addition though?</p>",
        "id": 495928616,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737862294
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/270676-lean4/topic/.60Sort.20.28max.201.20u.29.60/near/495923041\">said</a>:</p>\n<blockquote>\n<p>How I understand it is, universes form a Well Quasiorder (well-founded partial order)</p>\n</blockquote>\n<p>Sorry to nitpick, but these two concepts aren't the same! A WQO is a well-founded preorder without infinite antichains. Goes to show just how awful our nomenclature around well-foundedness is.</p>",
        "id": 495949891,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737882953
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/270676-lean4/topic/.60Sort.20.28max.201.20u.29.60/near/495927320\">said</a>:</p>\n<blockquote>\n<p>So, \"given a level formula, it is decidable whether it is true or false\"? I don't see why you would need that to \"make sense\" of the type theory. Most of math isn't decidable, but I think it is still possible to make sense of it.</p>\n</blockquote>\n<p>Given two level formulas, Lean has to be able to determine if the levels are the same as part of its typechecking algorithm.</p>",
        "id": 495950091,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737883088
    },
    {
        "content": "<p>For instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">))))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>",
        "id": 495950170,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737883171
    },
    {
        "content": "<p>I guess in a partial order, \"not more\" is different from \"less\", so you get two different definitions.</p>",
        "id": 496005883,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737928871
    },
    {
        "content": "<p>You can think about the decidability issue in this way:</p>\n<ul>\n<li>For terms, if there is a type incompatibility according to the definitional equality algorithm, you can insert casts using propositional equalities to deal with it.</li>\n<li>For universe levels, there is no such thing as a propositional equality, and instead you rely on the decision procedure. There's no \"making sense of\" universe levels that you can do that can help typechecking succeed.</li>\n</ul>",
        "id": 496011270,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737933441
    },
    {
        "content": "<p>I was thinking of reasoning about universes from outside the theory, but that makes sense too.</p>",
        "id": 496023143,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737943683
    }
]