[
    {
        "content": "<p>I noticed that replacing an equality comparison against a constant variant in a hot path with a specialized, inline function results in a noticeable speedup, leading to a few percent higher throughput across <a href=\"https://github.com/pandaman64/lean-regex/pull/122\">regex benchmarks</a>.</p>\n<p>It appears that the derived <code>decEqNode</code> function wasn't inlined, which may have prevented constant folding and other optimizations. Having specialization for constant arguments might also help in such cases.</p>\n<p>Here's a small example demonstrating the difference. I hope feedback like this is welcome. Thanks!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">done</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">epsilon</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inline</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">always_inline</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"bp\">.</span><span class=\"n\">isDone</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Compiler</span><span class=\"bp\">.</span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"c1\">-- This comparison was not inlined</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"mi\">42</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"mi\">1</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"c1\">-- This version seems faster in my actual example</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">isDone</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"mi\">42</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 532916004,
        "sender_full_name": "pandaman",
        "timestamp": 1754400239
    },
    {
        "content": "<p>Yeah this slightly unfortunate but there is another option which works just as well: <code>n matches .done</code> which is shorthand for what you do in <code>Node.isDone</code>.</p>",
        "id": 532918999,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754401199
    },
    {
        "content": "<p>Ideally this would be compiled efficiently regardless of what you do though</p>",
        "id": 532919383,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754401292
    },
    {
        "content": "<p>Thank you for reporting this. I have created <a href=\"https://github.com/leanprover/lean4/pull/9795\">lean4#9795</a>. <span class=\"user-mention\" data-user-id=\"395416\">@pandaman</span>, as described in the issue, I wasn't able to reproduce a slowdown from this in compiled code using your code example. If you happen to know how to make the difference visible in compiled code, feel free to add a comment to the issue.</p>",
        "id": 533410351,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1754637662
    },
    {
        "content": "<p>Hi thank you for looking into this! Yeah, this example is for illustration purpose and I didn't check if this one reproduces the slowness. I was able to modify the benchmark to reproduce the slowdown:</p>\n<p><a href=\"https://github.com/leanprover/lean4/issues/9795#issuecomment-3167497020\">https://github.com/leanprover/lean4/issues/9795#issuecomment-3167497020</a></p>\n<p>It seems that a variant with <code>Char</code> and testing with non-matching cases (which is closer to my original benchmarking) are crucial.</p>",
        "id": 533443180,
        "sender_full_name": "pandaman",
        "timestamp": 1754651260
    },
    {
        "content": "<p>Great, thank you! I'm sure that this will help tracking down the issue.</p>",
        "id": 533443444,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1754651383
    },
    {
        "content": "<p>Oh, wow, looking at the generated IR, it's reusing the storage from the <code>Node</code> for the <code>IO</code> result type, which falsifies the numbers. However, after fixing this, <code>f'</code> is still measurably slower. I have updated the issue with a version of the benchmarking code which I hope produces meaningful numbers.</p>",
        "id": 533444766,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1754651971
    }
]