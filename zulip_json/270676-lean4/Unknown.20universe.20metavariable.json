[
    {
        "content": "<p>Consider this example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span> <span class=\"n\">m</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_comm</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I'm trying to execute this example in Lean while inspecting its proof state</p>\n<p>I have this function which elaborates an expression from a syntax</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">syn</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Lean.Parser.runParserCategory</span>\n      <span class=\"o\">(</span><span class=\"n\">env</span> <span class=\"o\">:=</span> <span class=\"n\">env</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">catName</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">term</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">input</span> <span class=\"o\">:=</span> <span class=\"s2\">\"∀ (n m: Nat), n + m = m + n\"</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">fileName</span> <span class=\"o\">:=</span> <span class=\"s2\">\"&lt;stdin&gt;\"</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">termElabM</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Elab.TermElabM</span> <span class=\"o\">(</span><span class=\"n\">Except</span> <span class=\"n\">String</span> <span class=\"n\">Lean.Expr</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"n\">try</span>\n      <span class=\"k\">let</span> <span class=\"n\">expr</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.Elab.Term.elabTerm</span> <span class=\"n\">syn</span>\n        <span class=\"o\">(</span><span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">catchExPostpone</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">implicitLambda</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n      <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"n\">expr</span>\n    <span class=\"n\">catch</span> <span class=\"n\">ex</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">error</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">ex.toMessageData.toString</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>However when I procedurally run the same series of tactics on the expression generated by the above <code>termElabM</code>, I get the following error messages</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">unknown</span> <span class=\"kd\">universe</span> <span class=\"n\">metavariable</span> <span class=\"bp\">'?</span><span class=\"n\">_uniq.9'</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>In comparison, if I extract the expression directly from <code>  env.find? name |&gt;.get! |&gt;.type</code> (where <code>name</code> is <code>Nat.add_comm</code>), the series of tactics will result in 0 goals. How can I fix this issue? I think the problem is in the elaborator?</p>",
        "id": 360121517,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1684703091
    },
    {
        "content": "<p>The same behaviour shows up if instead of <code>elabTerm</code> that I use <code>elabType</code> (which internally calls <code>elabTerm</code>.</p>",
        "id": 360122984,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1684704162
    },
    {
        "content": "<p>If anyone is interested I can post a minimal example but I'm mainly just interested in how <code>elabTerm</code>'s expression is different from the one from <code>ConstantInfo.type</code></p>",
        "id": 360126084,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1684706471
    },
    {
        "content": "<p><code>ConstantInfo.type</code> uses the level variables from <code>ConstantInfo.levelParams</code>. What <code>elabTerm</code> does when it comes across a constant is that it uses fresh universe level metavariables. I'm just answering this question, but I'm not sure this will help with your earlier question.</p>\n<p>The \"unknown universe metavariable\" error is pointing toward you using the <code>expr</code> in a different metavariable context than the one you generated it.</p>\n<p>If you think that all the metavariables should be solved for right after elaborating, you could thrown in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing#doc\">docs4#Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing</a> before the <code>return</code> and then use <code>instantiateMVars expr</code> to substitute in all the solutions to all the metavariables.</p>",
        "id": 360130070,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684709878
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Unknown.20universe.20metavariable/near/360130070\">said</a>:</p>\n<blockquote>\n<p><code>ConstantInfo.type</code> uses the level variables from <code>ConstantInfo.levelParams</code>. What <code>elabTerm</code> does when it comes across a constant is that it uses fresh universe level metavariables. I'm just answering this question, but I'm not sure this will help with your earlier question.</p>\n<p>The \"unknown universe metavariable\" error is pointing toward you using the <code>expr</code> in a different metavariable context than the one you generated it.</p>\n<p>If you think that all the metavariables should be solved for right after elaborating, you could thrown in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing#doc\">docs4#Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing</a> before the <code>return</code> and then use <code>instantiateMVars expr</code> to substitute in all the solutions to all the metavariables.</p>\n</blockquote>\n<p>Yes. In my applications I have to save the <code>Lean.Elab.Tactic.SavedState</code> and resume it with <code>state.term.restore</code>. I'll try your suggestions. Thanks</p>",
        "id": 360133862,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1684713444
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Unknown.20universe.20metavariable/near/360130070\">said</a>:</p>\n<blockquote>\n<p><code>ConstantInfo.type</code> uses the level variables from <code>ConstantInfo.levelParams</code>. What <code>elabTerm</code> does when it comes across a constant is that it uses fresh universe level metavariables. I'm just answering this question, but I'm not sure this will help with your earlier question.</p>\n<p>The \"unknown universe metavariable\" error is pointing toward you using the <code>expr</code> in a different metavariable context than the one you generated it.</p>\n<p>If you think that all the metavariables should be solved for right after elaborating, you could thrown in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing#doc\">docs4#Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing</a> before the <code>return</code> and then use <code>instantiateMVars expr</code> to substitute in all the solutions to all the metavariables.</p>\n</blockquote>\n<p>Is there a way to <code>InstantiateMVars</code> on the metavariables generated by tactics?</p>",
        "id": 360380431,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1684791434
    },
    {
        "content": "<p>I tried with <code>unsolvedGoals.forM Lean.instantiateMVarDeclMVars</code> but executing a tactic like <code>apply Or.inr</code> still results in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic</span> <span class=\"bp\">'</span><span class=\"n\">apply'</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">unify</span>\n  <span class=\"bp\">?</span><span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"bp\">?</span><span class=\"n\">b</span>\n<span class=\"k\">with</span>\n  <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span>\n<span class=\"n\">case</span> <span class=\"n\">inl</span>\n<span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">h</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"n\">p</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span>\n</code></pre></div>\n<p>I have the <code>Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing</code> right before executing the tactic:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>        <span class=\"n\">Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing</span>\n        <span class=\"k\">let</span> <span class=\"n\">unsolvedGoals</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.Elab.Tactic.run</span> <span class=\"n\">mvarId</span> <span class=\"n\">tac</span>\n        <span class=\"n\">unsolvedGoals.forM</span> <span class=\"n\">Lean.instantiateMVarDeclMVars</span>\n        <span class=\"k\">let</span> <span class=\"n\">nextState</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Elab.Tactic.SavedState</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n          <span class=\"n\">term</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Lean.Elab.Term.saveState</span><span class=\"o\">),</span>\n          <span class=\"n\">tactic</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">goals</span> <span class=\"o\">:=</span> <span class=\"n\">unsolvedGoals</span> <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"n\">nextState</span>\n</code></pre></div>",
        "id": 360380981,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1684791669
    },
    {
        "content": "<p>The theorem I'm trying to prove is this one. It runs fine in the IDE but when I try to run the same sequence of tactics with <code>Lean.Elab.Tactic.SavedState</code> it gives the above error.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span>\n  <span class=\"n\">assumption</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span>\n  <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 360381138,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1684791728
    }
]