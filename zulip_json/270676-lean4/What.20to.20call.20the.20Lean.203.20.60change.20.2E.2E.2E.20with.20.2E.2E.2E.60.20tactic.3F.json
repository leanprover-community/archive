[
    {
        "content": "<p>Recall that the Lean 3 tactic <code>change p with r</code> would search for all subexpressions matching <code>p</code> in the target and replace them with <code>r</code>. It is sort of like <code>rw [show p = r by rfl]</code>, but it avoids any sort of \"motive not type correct\" error. The replacement <code>r</code> has to be defeq to <code>p</code>.</p>\n<p>Now that we're in Lean 4, we could have a fresh start with the syntax. The <code>change p with r</code> syntax isn't so bad, but it's also not so illuminating what it will be, plus it should be <code>change p to r</code> or <code>change p for r</code> to be more grammatical.</p>\n<p>Some constraints are that it would be good to make sure the keyword used is a keyword, and it would be nice to avoid introducing a new keyword.</p>\n<p>Some ideas:</p>\n<ol>\n<li><code>change_matching p with r</code> — still uses <code>with</code> not-so-grammatically, but at least we see the word <code>matching</code></li>\n<li><code>change p := r</code> — no need for a new keyword, but doesn't evoke changing all occurrences of <code>p</code>.</li>\n<li>Scrap it, create a <code>dconv</code> tactic mode, and have it be <code>dconv in p =&gt; change r</code> (or equivalently <code>dconv =&gt; pattern p &lt;;&gt; change r</code>). Sort of appealing, though it is a good amount of work, and it also is more limited with how it handles locations (like <code>change p with r at *</code>), at least if it handles locations the way <code>conv</code> itself does.</li>\n<li>Scrap it, create a <code>drw</code> tactic that is to <code>rw</code> as <code>dsimp</code> is to <code>simp</code>. You would write <code>drw [p = r]</code>. We could make it so that <code>drw [h]</code> allows <code>h</code> to either be a proof or a proposition, allowing <code>drw</code> to accept <code>rw</code> lemmas where the LHS is defeq to the RHS (the proof in this case would be discarded).</li>\n</ol>\n<p>I'm sort of leaning toward 4 here. However, elaboration works better with a <code>change ... with ...</code> tactic (i.e., you might be able to avoid some type ascriptions), since it can figure out the type of <code>p</code> from whatever it matches in the target expression and use that to elaborate of <code>r</code>, though maybe the flexibility of <code>drw</code> outweights that minor inconvenience.</p>",
        "id": 482889162,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731871457
    },
    {
        "content": "<p>change p =&gt; r?</p>",
        "id": 482894174,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1731875679
    },
    {
        "content": "<p>I like the direction of <code>drw</code>. There is a variant where the keyword is still <code>rw</code> and either it just always does that when the lemma is a rfl lemma, or there is some marker on the argument that says that it should do rfl rewriting. This is related to <a href=\"https://github.com/leanprover/lean4/issues/6033\">https://github.com/leanprover/lean4/issues/6033</a></p>",
        "id": 482894298,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1731875779
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/channel/270676-lean4/topic/What.20to.20call.20the.20Lean.203.20.60change.20.2E.2E.2E.20with.20.2E.2E.2E.60.20tactic.3F/near/482894174\">said</a>:</p>\n<blockquote>\n<p>change p =&gt; r?</p>\n</blockquote>\n<p>Also quite nice, thanks for the suggestion! In particular neat when this means that <code>change r</code> is roughly the same as <code>change _ =&gt; r</code>.</p>",
        "id": 482894352,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1731875844
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> I thought <a href=\"https://github.com/leanprover/lean4/pull/6018#issuecomment-2466470747\">you weren't keen on that suggestion</a> earlier <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 482894676,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731876090
    },
    {
        "content": "<p>I'm not sure I see the connection to <a href=\"https://github.com/leanprover/lean4/pull/6033\">lean4#6033</a>, other than that if <code>rw</code> can doing matching under binders then so should <code>drw</code></p>",
        "id": 482895154,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731876486
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/What.20to.20call.20the.20Lean.203.20.60change.20.2E.2E.2E.20with.20.2E.2E.2E.60.20tactic.3F/near/482894676\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> I thought <a href=\"https://github.com/leanprover/lean4/pull/6018#issuecomment-2466470747\">you weren't keen on that suggestion</a> earlier <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n</blockquote>\n<p>fair point :-D. I had that objection again now, and the reminded myself of <code>fun _ =&gt; _</code>, where there isn't a tactic afterwards :-).</p>\n<p>The connection to that RFC is the desire that <code>rw</code> should just do all forms the rewriting maybe? Rather than having a myriad of rewriting like tactics?</p>",
        "id": 482895310,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1731876644
    },
    {
        "content": "<p>if we're really set on <code>with</code>, <code>replace</code> would be a grammatical name...</p>",
        "id": 482899367,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731880195
    },
    {
        "content": "<p>that is, unless i'm pulling a foreign</p>",
        "id": 482899447,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731880244
    },
    {
        "content": "<p>\"replace p with r\" is grammatical, but <code>replace x := v</code> is a pre-existing tactic</p>",
        "id": 482899467,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731880264
    },
    {
        "content": "<p>what does that tactic do?</p>",
        "id": 482899504,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731880299
    },
    {
        "content": "<blockquote>\n<p>Acts like <code>have</code>, but removes a hypothesis with the same name as<br>\nthis one if possible. For example, if the state is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">goal</span>\n</code></pre></div>\n<p>Then after <code>replace h := f h</code> the state will be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">goal</span>\n</code></pre></div>\n<p>whereas <code>have h := f h</code> would result in:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"n\">h</span><span class=\"bp\">†</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">goal</span>\n</code></pre></div>\n<p>This can be used to simulate the <code>specialize</code> and <code>apply at</code> tactics of Coq.</p>\n</blockquote>",
        "id": 482899736,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1731880498
    },
    {
        "content": "<p>At a high level, my not completely worked out thinking is that our tactics would look a bit differently if they were designed altogether, and from a user’s point of view, rather than their differing implementation.</p>\n<p>For example, when rewriting, we need to know what to rewrite, what to rewrite to, and how to rewrite it (e.g. by rfl, by a rewrite lemma, or by an explicit proof). Often some of these are implicit – with <code>change</code> the “what” is implicitly the whole goal, with <code>rw</code> the “what” is the rule’s lhs and the “what to” is the pattern; with the tactic discussed here the what and what to is explicit, but it only works for one of the “hows”.</p>\n<p>I’d wager that users tend to think first about what they want to achieve (e.g. <code>rewrite p to r</code>; strawman suggestions), and only then want to think about the how? That suggests that they should be able to write that, then get feedback from the system (e.g. indicate that it doesn't hold definitionally and a proof is necessary ) and then continue with the justification (e.g. <code>using p_eq_r</code>, or <code>by simp […]</code>)</p>\n<p>Or maybe the user knows the how first, e.g. know they want to apply <code>p_eq_r</code>, and they write something that leaves the “what” implicit (e.g. <code>rewrite using p_eq_r</code>), and then notice that the inferred “what” wasn’t quite the right one. Wouldn’t it be nice if they wouldn’t have to use a completely different tactic now, but could just add more information (<code>rewrite p using p_eq_r</code>).</p>\n<p>In the end there could be a single flexible and tactic that subsumed a whole set of rewriting and changing related tactics (<code>rewrite</code>, <code>simp_rw</code>, <code>change</code>, <code>change with </code>, maybe also <code>unfold</code>) , and and is hopefully easier and more consistent to use.</p>\n<p>I’m not saying that this vision is easily achievable, specially due to backwards compat considerations (but not only), and it shouldn’t block incremental improvements like this one. But it’s may a vision worth keeping in mind?</p>",
        "id": 482900546,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1731881226
    },
    {
        "content": "<p>I think there's still a place for more precise tactics, but I do like the vision of a tactic that makes a rewrite happen using multiple strategies, and it's something I've been thinking about too.</p>\n<p>I mentioned it in that PR thread, but <code>convert_to</code> <em>is</em> a tactic that defers the \"how\" and uses multiple strategies to try to prove the rewrite. It's just missing a <code>change ... with</code>-like interface. It's also missing <code>Eq.rec</code>-type strategies. By default it uses <code>using 1</code>, which seems to work as a heuristic, but having it do <code>using 0</code> (or having it choose a \"reasonable\" depth automatically) is plausible.</p>",
        "id": 482901557,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731882198
    },
    {
        "content": "<p>I don't want the tactic to be less precise, though! Same expressiveness, just a unified, compositional, consistent interface, with convenient and ergonomic defaults to the same features (or a superset thereof), including optional knobs for extra control (e.g. I could imagine such a tactic to behave like <code>change</code> if the lemma given is a rfl lemma, but have a way to use the Eq.rec-strategy explicitly)</p>",
        "id": 482901876,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1731882554
    },
    {
        "content": "<p>By \"precision\" I mean regarding the proof strategy, not in what's being rewritten, and it seems that one possible disagreement here is whether 'compositional' means between different tactics or whether there should be a featureful main rewrite tactic that can be configured with a compositional syntax (I'm reminded of the LOOP macro in Lisp, which is compositional in the second way but not the first).</p>",
        "id": 482902193,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731882859
    },
    {
        "content": "<p>Good points. As user I don't care too much of if it's a single tactic with optional fields, or a clever combination of tactics and tactic combinators. But it's probably easier with a main tactic, especially the “user says what they want, system gives feedback, user refines the tactic line” goal.</p>",
        "id": 482902537,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1731883210
    },
    {
        "content": "<p>Consider the <code>at $loc</code> syntax. To a user, this might actually feel like a tactic combinator or modifier, since it works (mostly) consistently across different tactics. You learn it once, apply it elsewhere, and maybe even naturally discover it's use with other tactics. I'd consider this compositional for these purposes, even though the actual implementation isn't (every tactic implements it again, of course using helpers).</p>",
        "id": 482902658,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1731883338
    },
    {
        "content": "<p>So if you want all the variant of this envisioned tactic could be their own <code>syntax</code> declarations with separate elaborators, and thus technically separate tactics, and still together give the UX of a single tactic.</p>",
        "id": 482902719,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1731883434
    }
]