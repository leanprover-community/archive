[
    {
        "content": "<p>Hey all,</p>\n<p>While working on an unrelated project about Turing machines, I realized that Lean 4 may have all the pieces in place to do something cool: prove that the Lean 4 type checker is undecidable, using Lean 4.</p>\n<p>The pieces:</p>\n<ul>\n<li>Lean 4 is bootstrapped, so the type checker exists as actual Lean code</li>\n<li>Mathlib contains core computability theorems, including Rice's theorem and the halting problem</li>\n<li>Type checking in Lean requires termination checking for recursive definitions, which is essentially the halting problem</li>\n</ul>\n<p>Could we connect these pieces to formally prove that type checking Lean code is undecidable in general? Has anyone explored this direction before? Any thoughts on feasibility or which parts of the compiler would be most amenable to this approach?</p>",
        "id": 527804196,
        "sender_full_name": "Eric Vergo",
        "timestamp": 1752034154
    },
    {
        "content": "<p>The core type checker of Lean is written in C++. Though you might have some luck with Lean4lean</p>",
        "id": 527808690,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1752037926
    },
    {
        "content": "<p>Also type checking in lean, at least for the core calculus, does not require termination checking, they are desugared long before the kernel checks the term, type checking is undecidable for other reasons</p>",
        "id": 527808755,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1752037985
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span></p>",
        "id": 527837984,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1752050917
    },
    {
        "content": "<p>Type checking in lean is undecidable, but for the \"wrong\" reasons; very similar systems like Rocq have decidable type checking. The termination checker underapproximates the halting problem, which is to say there are some definitions which are terminating but the checker doesn't know how to prove it. When this happens, lean rejects your definition and requires you to prove it terminating. But once you've done that, the termination checking problem becomes easy, it's just regular proof checking and no infinite search is required because the proof is right there handed to you.</p>",
        "id": 527838845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752051188
    },
    {
        "content": "<p>Thank you for the responses; this is very interesting! Is it fair to say that the reason you have to underapproximate the halting problem is because of implementation practicalities similar to recursion depth limits?</p>\n<p>It seems like a few of my assumptions were incorrect, sorry. I’m still getting my feet wet with theoretical computer science and will spend some time checking out lean4lean.</p>",
        "id": 527904373,
        "sender_full_name": "Eric Vergo",
        "timestamp": 1752072118
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/Can.20we.20prove.20the.20Lean.20type.20checker.20is.20undecidable.20in.20lean.3F/near/527838845\">said</a>:</p>\n<blockquote>\n<p>the termination checking problem becomes easy</p>\n</blockquote>\n<p>From a document you sent me some time ago (I think it's called \"ttt\"?) it talked about how in a contradictory context one can make non-terminating functions when unfolded (e.g. recursing upwards on Nat). Does that have an impact here?</p>",
        "id": 527905627,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752072478
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"624658\">Eric Vergo</span> <a href=\"#narrow/channel/270676-lean4/topic/Can.20we.20prove.20the.20Lean.20type.20checker.20is.20undecidable.20in.20lean.3F/near/527904373\">said</a>:</p>\n<blockquote>\n<p>Thank you for the responses; this is very interesting! Is it fair to say that the reason you have to underapproximate the halting problem is because of implementation practicalities similar to recursion depth limits?</p>\n</blockquote>\n<p>No. It is the nature of any type system that it allows some underapproximation of semantic correctness. To take a simple example, using simply typed functions, the expression <code>if true then \"hi\" else 1 : String</code> will generally not be well typed, even though it is semantically correct. That's a tradeoff we make to make type checking not just practical but also easy for a user to predict so they can use the system effectively. In this case we would say that we are deliberately not considering the value of the condition when typechecking, so we can just say \"one side is a <code>String</code> and the other is a <code>Nat</code>, that's not well typed\" and the user can learn. The point is to get the user to write <em>manifestly</em> correct expressions.</p>\n<p>When you increase the complexity of the type system you can typecheck more things that are semantically correct, so that's closing the gap a bit. With dependent types you can actually typecheck that if statement because it will have type <code>if true then String else Nat</code> and the system evaluates that expression to <code>String</code>. But the fundamental tradeoff is still unchanged. An example that would not be accepted is <code>if RiemannHypothesis then \"hi\" else 1 : String</code>, not just because we don't know how to prove riemann's hypothesis, but because the system won't even try to prove it in this situation - it doesn't <em>compute</em> to true and that's reason enough to reject it.</p>\n<p>So to come back to the original question, this underapproximation is really a fundamental property of decidable type systems, and has nothing to do with implementation limits.</p>",
        "id": 527915040,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752075133
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/270676-lean4/topic/Can.20we.20prove.20the.20Lean.20type.20checker.20is.20undecidable.20in.20lean.3F/near/527905627\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/Can.20we.20prove.20the.20Lean.20type.20checker.20is.20undecidable.20in.20lean.3F/near/527838845\">said</a>:</p>\n<blockquote>\n<p>the termination checking problem becomes easy</p>\n</blockquote>\n<p>From a document you sent me some time ago (I think it's called \"ttt\"?) it talked about how in a contradictory context one can make non-terminating functions when unfolded (e.g. recursing upwards on Nat). Does that have an impact here?</p>\n</blockquote>\n<p>(You are thinking of <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a>.) This is what I am referring to with</p>\n<blockquote>\n<p>Type checking in lean is undecidable, but for the \"wrong\" reasons</p>\n</blockquote>\n<p>and Henrik's</p>\n<blockquote>\n<p>type checking is undecidable for other reasons</p>\n</blockquote>\n<p>Most of my post would apply (and indeed it's easier to make the point) if Lean's type theory was decidable.</p>\n<p>But to the OP question as stated, this \"technicality\" is actually very relevant.</p>\n<blockquote>\n<p>Could we connect these pieces to formally prove that type checking Lean code is undecidable in general? </p>\n</blockquote>\n<p>Yes we can: the construction in <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> is not too hard to formalize, the hard part would be proving formally that you can embed decidable programs like turing machine evaluation for k steps in the definitional equality relation. My paper kind of handwaves that part (in true CS fashion); you would have to connect it up to <code>Mathlib.Computability.HaltingProblem</code> and show that primitive recursive function evaluation works as expected. There might also be more handwaving to show that in the non-halting case the definitional equality doesn't hold, because that requires you to know that the definitional equality relation is not degenerate and this is a very hard theorem.</p>",
        "id": 527917129,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752075771
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/Can.20we.20prove.20the.20Lean.20type.20checker.20is.20undecidable.20in.20lean.3F/near/527915040\">said</a>:</p>\n<blockquote>\n<p>No. It is the nature of any type system that it allows some underapproximation of semantic correctness ... The point is to get the user to write <em>manifestly</em> correct expressions.</p>\n</blockquote>\n<p>Wow, I was unaware of this subtlety and am not sure I have my head totally wrapped around it. Do you know where I might be able to read more about this specifically?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/Can.20we.20prove.20the.20Lean.20type.20checker.20is.20undecidable.20in.20lean.3F/near/527917129\">said</a>:</p>\n<blockquote>\n<p>Yes we can: the construction in <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> is not too hard to formalize, the hard part would be proving formally that you can embed decidable programs like turing machine evaluation for k steps in the definitional equality relation. My paper kind of handwaves that part (in true CS fashion); you would have to connect it up to <code>Mathlib.Computability.HaltingProblem</code> and show that primitive recursive function evaluation works as expected. There might also be more handwaving to show that in the non-halting case the definitional equality doesn't hold, because that requires you to know that the definitional equality relation is not degenerate and this is a very hard theorem.</p>\n</blockquote>\n<p>Cool. It's over my head but I'm going to take a crack at. Is it ok if I come back with some naive attempts and questions?</p>",
        "id": 527965496,
        "sender_full_name": "Eric Vergo",
        "timestamp": 1752094900
    }
]