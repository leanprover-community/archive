[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Termination.20checking.20for.20dummies/near/382594760\">said</a>:</p>\n<blockquote>\n<p>While you can't use <code>RBMap</code> in a nested inductive, you can use <code>RBNode</code>, the inductive it is defined from</p>\n</blockquote>\n<p>I still hold the belief that Lean would benefit from having either a somehow smarter way to detect strict positivity, or a way for the end-user to annotate things as strictly positive. <code>HashMap</code> and <code>RBMap</code> would benefit a lot from that imo</p>",
        "id": 382596051,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691408618
    },
    {
        "content": "<p>Sigma types are fundamentally not strictly positive though</p>",
        "id": 382597797,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691408976
    },
    {
        "content": "<p>They are a pair of an element of <code>T</code> and an element of an element of <code>T -&gt; Prop</code></p>",
        "id": 382598004,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691409014
    },
    {
        "content": "<p>And an annotation is hard because this is a kernel-level check</p>",
        "id": 382598173,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691409053
    },
    {
        "content": "<p>While it's obviously not strictly positive over the first argument, would <code>Sigma A</code> not be strictly positive for any A ?</p>",
        "id": 382598402,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691409113
    },
    {
        "content": "<p>What is <code>Sigma A</code>? <code>Sigma</code> takes two arguments</p>",
        "id": 382598607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691409146
    },
    {
        "content": "<p>the type <code>Sigma A</code>, given any type <code>A</code></p>",
        "id": 382598775,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691409191
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Sigma.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 382598825,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691409205
    },
    {
        "content": "<p>sorry, the first one is implicit. But I still don't know what you mean</p>",
        "id": 382598893,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691409221
    },
    {
        "content": "<p>because the explicit argument of <code>Sigma</code> is not a type</p>",
        "id": 382598926,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691409232
    },
    {
        "content": "<p>oops, you're right, nevermind then</p>",
        "id": 382599132,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691409264
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Termination.20checking.20for.20dummies/near/382598173\">said</a>:</p>\n<blockquote>\n<p>And an annotation is hard because this is a kernel-level check</p>\n</blockquote>\n<p>Other proof-assistants (namely, Coq)  do allow for the modification of certain kernel-checks through the use of pragmas/flags though</p>",
        "id": 382599476,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691409333
    },
    {
        "content": "<p>in some cases, with <em>heavy</em> reworking, it is possible to rephrase sigma types as inductive types by pushing properties into the leaves. This creates very dependent types though so I am wary of this approach</p>",
        "id": 382599519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691409342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"432410\">Arthur Adjedj</span> <a href=\"#narrow/stream/113489-new-members/topic/Termination.20checking.20for.20dummies/near/382599476\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Termination.20checking.20for.20dummies/near/382598173\">said</a>:</p>\n<blockquote>\n<p>And an annotation is hard because this is a kernel-level check</p>\n</blockquote>\n<p>Other proof-assistants (namely, Coq)  do allow for the modification of certain kernel-checks through the use of pragmas/flags though</p>\n</blockquote>\n<p>yep, this is never going to happen, we want a better soundness story than that</p>",
        "id": 382599769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691409383
    },
    {
        "content": "<p>Alright, makes sense.</p>",
        "id": 382599832,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691409397
    },
    {
        "content": "<p>also Coq would not allow this type, for the same reason</p>",
        "id": 382599848,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691409402
    },
    {
        "content": "<p>It would, if you tagged the inductive definition of <code>BkTree</code> with a tag to cancel the positivity-checking on it.</p>",
        "id": 382600089,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691409459
    },
    {
        "content": "<p>Some much more innocuous inductive types could also stand to be accepted by the positivity-checker. Agda is smarter for that matter. For example, the following gets accepted by Agda, but not by lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span>  <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Bar</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n<span class=\"bp\">|</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"o\">(</span><span class=\"n\">Foo</span> <span class=\"n\">Bar</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 382600926,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691409622
    },
    {
        "content": "<p>I'm not sure I would describe that type as innocuous</p>",
        "id": 382604055,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691410191
    },
    {
        "content": "<p>specifically, what are the bounds on when such types are accepted, and where is the paper proof of soundness of such an extension? I wouldn't even want to consider an extension without that</p>",
        "id": 382604840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691410356
    },
    {
        "content": "<p>I would have to dive into Agda's codebase again, but I believe the criteria is that <code>Foo</code>must be strictly positivive. As for a soundness proof of that extension, I do not have a paper-proof justification in hand, and would need to look into that. Such extension is however useful for formalising things like logical relations of other type theories, and is an issue I encountered when trying to port a formalisation from Agda to Lean.</p>",
        "id": 382605690,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691410537
    },
    {
        "content": "<p>I do however have an example in hand of a justifyably sound inductive type that doesn't get accepted by lean, let me find it again.</p>",
        "id": 382606047,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691410599
    },
    {
        "content": "<p>My opinion of the agda soundness story is very low, so \"agda can do it, why can't lean?\" isn't very persuasive to me</p>",
        "id": 382606141,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691410619
    },
    {
        "content": "<p><a href=\"https://proofassistants.stackexchange.com/questions/2045/unexpected-inductive-type-occurrence-error-for-recursive-inductive-type\">here</a><br>\nI don't know if lean 4 still compiles nested inductives to mutual ones, but it seems to have trouble compiling down nested inductive predicates. I should be able to make a MWE quickly enough. This sort of stuff is accepted by Coq with no issue.</p>",
        "id": 382607028,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691410781
    },
    {
        "content": "<p>I think the example you gave above is also justifiably sound (take <code>Foo x := Unit</code> and <code>Bar x := if x = Unit then Unit else Empty</code>), but that's just one example, not a whole scheme</p>",
        "id": 382607094,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691410796
    },
    {
        "content": "<p>Lean 4 does not compile nested inductives to mutual</p>",
        "id": 382607197,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691410809
    },
    {
        "content": "<p>but it does a check that should be equivalent to the existence of such a reduction</p>",
        "id": 382607289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691410827
    },
    {
        "content": "<p>and it needs to compute essentially the reduction in order to determine the structure of the recursor</p>",
        "id": 382607927,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691410949
    },
    {
        "content": "<p>Does agda even have recursors for these types?</p>",
        "id": 382608015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691410965
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Termination.20checking.20for.20dummies/near/382607094\">said</a>:</p>\n<blockquote>\n<p>I think the example you gave above is also justifiably sound (take <code>Foo x := Unit</code> and <code>Bar x := if x = Unit then Unit else Empty</code>), but that's just one example, not a whole scheme</p>\n</blockquote>\n<p>It is ! In general, there is a way to re-encode such types by \"inlining\" the structure <code>Foo</code> in some way, at least as long as Foo is not recursive. I've had to do that on a more complex example myself, and there hasn't been any fundamental issue to doing the translation.</p>",
        "id": 382608433,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691411047
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Termination.20checking.20for.20dummies/near/382608015\">said</a>:</p>\n<blockquote>\n<p>Does agda even have recursors for these types?</p>\n</blockquote>\n<p>Agda doesn't generate recursors for anything</p>",
        "id": 382608478,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691411058
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"432410\">Arthur Adjedj</span> <a href=\"#narrow/stream/113489-new-members/topic/Termination.20checking.20for.20dummies/near/382607028\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://proofassistants.stackexchange.com/questions/2045/unexpected-inductive-type-occurrence-error-for-recursive-inductive-type\">here</a><br>\nI don't know if lean 4 still compiles nested inductives to mutual ones, but it seems to have trouble compiling down nested inductive predicates. I should be able to make a MWE quickly enough. This sort of stuff is accepted by Coq with no issue.</p>\n</blockquote>\n<p>Here is an MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Forall</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Forall</span> <span class=\"n\">Foo</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span> <span class=\"n\">a</span>\n<span class=\"c\">/-</span><span class=\"cm\">only trivial inductive applications supported in premises:</span>\n<span class=\"cm\">  Forall Foo a-/</span>\n</code></pre></div>",
        "id": 382609022,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691411179
    },
    {
        "content": "<p>and what would the recursor be?</p>",
        "id": 382609381,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691411255
    },
    {
        "content": "<p>in that example, lean won't even allow it with <code>unsafe inductive</code>, probably because it has no idea how to generate the recursor</p>",
        "id": 382609583,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691411293
    },
    {
        "content": "<p>Coq manages to generate one:</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Inductive</span> <span class=\"n\">Forall</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=.</span>\n<span class=\"kn\">Inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"o\">|</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Forall</span> <span class=\"n\">Foo</span> <span class=\"n\">a</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Foo</span> <span class=\"n\">a</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Check</span> <span class=\"n\">Foo_ind</span><span class=\"o\">.</span> <span class=\"c\">(*Foo_ind</span>\n<span class=\"c\">     : forall (α : Type) (P : α -&gt; Prop), (forall a : α, Forall Foo a -&gt; P a) -&gt; forall α0 : α, Foo α0 -&gt; P α0*)</span>\n</code></pre></div>",
        "id": 382610414,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691411469
    },
    {
        "content": "<p>what does that look like with <code>| mk : p a -&gt; Forall p a</code>?</p>",
        "id": 382610776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691411537
    },
    {
        "content": "<p>and also <code>| mk : (p a -&gt; False) -&gt; Forall p a</code> (I hope this is rejected)</p>",
        "id": 382610924,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691411568
    },
    {
        "content": "<p>That induction principle looks odd because it doesn't have two motives, even though there are two inductives involved</p>",
        "id": 382611174,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691411628
    },
    {
        "content": "<p>(jscoq gives horrible copy-pasted stuff, so I'm sending screenshots)<br>\nThe former gives this:<br>\n<a href=\"/user_uploads/3121/a8dUqQpduPx-PajWA_QcgSQ8/image.png\">image.png</a><br>\nThe second doesn't get accepted.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/a8dUqQpduPx-PajWA_QcgSQ8/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/a8dUqQpduPx-PajWA_QcgSQ8/image.png\"></a></div>",
        "id": 382611227,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691411636
    },
    {
        "content": "<p>wait a minute, that's the same as the first one</p>",
        "id": 382611396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691411661
    },
    {
        "content": "<p>even with <code>p a</code>, it doesn't add a new motive</p>",
        "id": 382611450,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691411671
    },
    {
        "content": "<p>I think this recursor is not (intended to be) complete, it's only good enough to do induction over the <code>Foo</code> part without any mutual inductions that have to bounce back and forth between <code>Foo</code> and <code>Forall Foo</code></p>",
        "id": 382611691,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691411717
    },
    {
        "content": "<p>Coq's auto-generated recursors are broken on nested/mutual inductives, I'd have to do some <code>Scheme Induction</code> stuff to retrieve the correct ones, and I don't remember how</p>",
        "id": 382611703,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691411719
    },
    {
        "content": "<p>I'll look into it</p>",
        "id": 382611789,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691411738
    },
    {
        "content": "<p>in which case it may well be the case that no one has ever worked out the full scheme for nested inductives in coq and/or agda</p>",
        "id": 382612028,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691411774
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Inductive</span> <span class=\"n\">Forall</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">|</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Forall</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">.</span>\n<span class=\"kn\">Inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"o\">|</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Forall</span> <span class=\"n\">Foo</span> <span class=\"n\">a</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Foo</span> <span class=\"n\">a</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Scheme</span> <span class=\"n\">Foo_ind_2</span> <span class=\"o\">:=</span> <span class=\"n\">Induction</span> <span class=\"k\">for</span> <span class=\"n\">Foo</span> <span class=\"n\">Sort</span> <span class=\"kt\">Prop</span><span class=\"o\">.</span>\n<span class=\"kn\">Check</span> <span class=\"n\">Foo_ind_2</span><span class=\"o\">.</span>\n</code></pre></div>\n<p><a href=\"/user_uploads/3121/o1nR7OMelbLAqV1fM-mJvHVg/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/o1nR7OMelbLAqV1fM-mJvHVg/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/o1nR7OMelbLAqV1fM-mJvHVg/image.png\"></a></div>",
        "id": 382612297,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691411836
    },
    {
        "content": "<p>It doesn't add a motive here, but does do some \"inlining\" trick by asking for the motive to be indexed by α</p>",
        "id": 382612630,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691411901
    },
    {
        "content": "<p>that looks like it is treating alpha as an index rather than a parameter</p>",
        "id": 382612763,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691411936
    },
    {
        "content": "<p>that's usually undesirable, it makes the scheme weaker</p>",
        "id": 382612817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691411945
    },
    {
        "content": "<p>oh wait nvm, alpha0 is an element of type alpha</p>",
        "id": 382613028,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691411982
    },
    {
        "content": "<p>okay yeah, this is just <code>casesOn</code></p>",
        "id": 382613240,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691412012
    },
    {
        "content": "<p>I don't think there is any inlining happening here, you would get the same result if the argument to <code>foo</code> was of some other type <code>B</code></p>",
        "id": 382613686,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691412097
    },
    {
        "content": "<p>you're right</p>",
        "id": 382614114,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691412169
    },
    {
        "content": "<p>In any case, the same inductive definitions are allowed in <code>Type</code> in lean</p>",
        "id": 382614509,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691412253
    },
    {
        "content": "<p>However, it wouldn't make sense for lean to have trouble knowing whether <code>Foo</code> is a subsingleton here, since it's pretty obviously indexed</p>",
        "id": 382614693,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691412289
    },
    {
        "content": "<p>And also makes a seemingly correct recursors when defining this over <code>Type</code> :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Forall</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Forall</span> <span class=\"n\">Foo</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span> <span class=\"n\">a</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">Foo.rec</span>\n<span class=\"c\">/-</span><span class=\"cm\">{α : Sort u_2} →</span>\n<span class=\"cm\">  {a : α} →</span>\n<span class=\"cm\">    {motive_1 : Foo a → Sort u_1} →</span>\n<span class=\"cm\">      {motive_2 : Forall Foo a → Sort u_1} →</span>\n<span class=\"cm\">        ((a_1 : Forall Foo a) → motive_2 a_1 → motive_1 (Foo.foo a a_1)) → (t : Foo a) → motive_1 t-/</span>\n</code></pre></div>",
        "id": 382615522,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691412428
    },
    {
        "content": "<p>(Also, this conversation has strayed far away from termination-checking, maybe it's would be good to move it in some way ?)</p>",
        "id": 382616215,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691412545
    },
    {
        "content": "<p>57 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members/topic/Termination.20checking.20for.20dummies\">#new members &gt; Termination checking for dummies</a> by <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span>.</p>",
        "id": 382616562,
        "sender_full_name": "Notification Bot",
        "timestamp": 1691412604
    },
    {
        "content": "<p>I have to admit I have not yet carefully studied the rules for nested/mutual inductives in lean 4 like I did for lean 3 (which only had plain inductives and simulated the other stuff). It is not immediately obvious to me why the type being in <code>Prop</code> should matter here, but the error message suggests that it is an incompleteness in the implementation</p>",
        "id": 382617632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691412750
    },
    {
        "content": "<p>Should I open an issue then ?</p>",
        "id": 382617771,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691412778
    },
    {
        "content": "<p>it would be best to have an implementation in hand first</p>",
        "id": 382617939,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691412811
    },
    {
        "content": "<p>I could find myself spending some time into trying to fix this</p>",
        "id": 382618228,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691412859
    },
    {
        "content": "<p>I see now that the specific error message thrown here: <code>only trivial inductive applications supported in premises</code> is caused not by the kernel but the elaborator, when trying to create the <code>Foo.Below</code> type, which makes sense, these generally can't be created for <code>Prop</code> inductives</p>",
        "id": 382618238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691412861
    },
    {
        "content": "<p>there is an entirely different strategy used for prop inductives</p>",
        "id": 382618374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691412891
    },
    {
        "content": "<p>and perhaps it is not as complete</p>",
        "id": 382618438,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691412906
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/more.20flexible.20nested.20inductives/near/382617939\">said</a>:</p>\n<blockquote>\n<p>it would be best to have an implementation in hand first</p>\n</blockquote>\n<p>Speaking of implementation, I've made a fix to the transitivity issue of defeq regarding eta-for unit some time ago (<a href=\"https://github.com/leanprover/lean4/issues/2258\">#2258</a>), but was hesitant on making a PR for that, would it be worth doing one ?</p>",
        "id": 382619172,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691413046
    },
    {
        "content": "<p>unfortunately there doesn't seem to be an option to disable auxiliary constructions, although you could call the kernel directly</p>",
        "id": 382619297,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691413072
    },
    {
        "content": "<p>another hack is to define the type from an empty <code>prelude</code> file (it won't generate the <code>Below</code> if <code>Prod</code> hasn't been defined yet), although lots of other things might break</p>",
        "id": 382619686,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691413143
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/more.20flexible.20nested.20inductives/near/382619297\">said</a>:</p>\n<blockquote>\n<p>unfortunately there doesn't seem to be an option to disable auxiliary constructions, although you could call the kernel directly</p>\n</blockquote>\n<p>I've tried in the past to do that, but didn't manage to write something working. I might try my hand at it again</p>",
        "id": 382619761,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691413156
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/more.20flexible.20nested.20inductives/near/382619686\">said</a>:</p>\n<blockquote>\n<p>another hack is to define the type from an empty <code>prelude</code> file (it won't generate the <code>Below</code> if <code>Prod</code> hasn't been defined yet), although lots of other things might break</p>\n</blockquote>\n<p><code>prelude</code> doesn't help, I still get the same error here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">prelude</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Forall</span>  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Forall</span> <span class=\"n\">Foo</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 382620329,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691413250
    },
    {
        "content": "<p>oh interesting, apparently there are two implementations of <code>mkBelow</code>, one in C++ and one in lean</p>",
        "id": 382621625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691413492
    },
    {
        "content": "<p>yeah, it sems like all the helper functions like <code>noConfusion</code>, <code>CasesOn</code> etc.. have corresponding C++ versions</p>",
        "id": 382622180,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691413594
    },
    {
        "content": "<p>the C++ <code>mk_below</code> ignores inductive predicates, the lean one throws an error</p>",
        "id": 382622505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691413658
    },
    {
        "content": "<p>I'm confused then, why would I still get that error on prelude ?</p>",
        "id": 382622974,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691413743
    },
    {
        "content": "<p><code>elabInductiveViews</code> calls <code>mkBelow</code> twice, once via <code>mkInductiveDecl</code> -&gt; <code>mkAuxConstructions</code> (which checks for <code>Prod</code>) and once directly (unconditional)</p>",
        "id": 382623268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691413797
    },
    {
        "content": "<p>actually the first one is calling <code>Lean.mkBelow</code>, the C++ one</p>",
        "id": 382623699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691413871
    },
    {
        "content": "<p>which only does non-indpreds</p>",
        "id": 382623776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691413887
    },
    {
        "content": "<p>the second one is <code>IndPredBelow.mkBelow</code>, which fails on this inductive</p>",
        "id": 382623833,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691413900
    },
    {
        "content": "<p>Looking more into this, i've just realised that despite the red scary error message, <code>Foo</code> is still accepted, and all helpers other than <code>below</code> (and <code>noConfusion</code>, but <code>Prop</code> types shouldn't have one so all good). Also, this is a new regression from lean 4, the same piece of code works with no issue in Lean 3<br>\n<span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/more.20flexible.20nested.20inductives/near/382618374\">said</a>:</p>\n<blockquote>\n<p>there is an entirely different strategy used for prop inductives</p>\n</blockquote>\n<p>I couldn't find any piece of code which suggested that <code>Prop</code>-inductives are treated any differently when generating <code>below</code> lemmas, do you know where the difference in approach happens ?</p>",
        "id": 382724203,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691432289
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"432410\">@Arthur Adjedj</span> the C++ function <code>mk_below</code> starts with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">is_inductive_predicate</span><span class=\"o\">(</span><span class=\"n\">env</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n        <span class=\"n\">return</span> <span class=\"n\">env</span><span class=\"bp\">;</span>\n</code></pre></div>\n<p>meaning that it does nothing on inductive predicates, and conversely <code>IndPredBelow.mkBelow</code> is wrapped in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mkBelow</span> <span class=\"o\">(</span><span class=\"n\">declName</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">isInductivePredicate</span> <span class=\"n\">declName</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n    <span class=\"bp\">&lt;</span><span class=\"n\">stuff</span><span class=\"bp\">&gt;</span>\n  <span class=\"k\">else</span> <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Meta.IndPredBelow</span><span class=\"o\">]</span> <span class=\"s2\">\"Not inductive predicate\"</span>\n</code></pre></div>\n<p>meaning that it only does something on inductive predicates</p>",
        "id": 382738548,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691435949
    },
    {
        "content": "<p>As it turns out, any nested inductive predicate triggers the error, it just so happens that no one uses them:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Bar</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">Bar</span> <span class=\"bp\">→</span> <span class=\"n\">Bar</span>\n<span class=\"c\">/-</span><span class=\"cm\">only trivial inductive applications supported in premises:</span>\n<span class=\"cm\">  Foo Bar-/</span>\n</code></pre></div>\n<p>Replacing the condition <code>if x.isRec then</code>in <code>mkBelow</code> with <code>if x.isRec &amp;&amp; !x.isNested then</code>fixes the issue :) Should I make an issue + PR ? <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span></p>",
        "id": 382745816,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691438213
    },
    {
        "content": "<p>yeah, generating nothing sounds better than erroring</p>",
        "id": 382746018,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691438281
    },
    {
        "content": "<p>I don't think there is a general scheme to generate <code>below</code> lemmas for inductive predicate since those may heavily depend on the shape of the nested application, simply not generating them might be better for now.</p>",
        "id": 382746220,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691438351
    }
]