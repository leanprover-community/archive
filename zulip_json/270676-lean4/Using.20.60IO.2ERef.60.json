[
    {
        "content": "<p>I would like to confirm that I am not doing anything wrong when working with <code>IO.Ref</code>: my understanding is very superficial!</p>\n<p>To show my issue, there is the need for two files: one defining (<code>initializing</code>) the <code>IO.Ref</code> and one reading it.<br>\nFile1:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span>\n\n<span class=\"n\">initialize</span><span class=\"w\"> </span><span class=\"n\">myRef</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">Ref</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">mkRef</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"sd\">/-- checks whether the counter is `true` and, if so, then sets it to `false`.</span>\n<span class=\"sd\">It also prints a summary of what it is doing. -/</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"to_false\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">myRef</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"s2\">\"Counter was `true`, setting it to `false`\"</span>\n<span class=\"w\">    </span><span class=\"n\">myRef</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div>\n<p>File2:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">File1</span>\n\n<span class=\"n\">to_false</span><span class=\"w\"> </span><span class=\"c1\">-- Counter was `true`, setting it to `false`</span>\n</code></pre></div>\n<p>If you have this setup, in <code>File2</code> you will see the message that the command emits.</p>\n<p>However, with essentialy <em>whatever you type</em> (adding a line-break, a new command, a space, virtually anything), the message disappears and will not be back until you reload the file.</p>",
        "id": 462084557,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723547617
    },
    {
        "content": "<p>I can guess that, once the Ref is set to false, it does not get \"reset\" with modifications of the file.  Is there a way around this, ensuring that the message on the first <code>to_false</code> stays there if I modify the file?</p>",
        "id": 462084770,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723547693
    },
    {
        "content": "<p>That is the purpose of environment extensions</p>",
        "id": 462084847,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1723547723
    },
    {
        "content": "<p>So you are saying that I should be using an environment extension instead?</p>",
        "id": 462085003,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723547772
    },
    {
        "content": "<p>(I have never worked with them, so I really do not know what they are or how they work.)</p>",
        "id": 462085030,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723547787
    },
    {
        "content": "<p>Actually, the reason I was playing with this is for use in a linter: would an environment extension be something that a linter can modify?</p>",
        "id": 462085401,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723547958
    },
    {
        "content": "<p>Updated example:<br>\nFile1:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">counter</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span>\n\n<span class=\"n\">initialize</span><span class=\"w\"> </span><span class=\"n\">myCounter</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">EnvExtension</span><span class=\"w\"> </span><span class=\"n\">counter</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">registerEnvExtension</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">true</span><span class=\"bp\">⟩</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- checks whether the `EnvExtension` is `true` and, if so, then sets it to `false`.</span>\n<span class=\"sd\">It also prints a summary of what it is doing. -/</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"EnvExt_false\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">myCounter</span><span class=\"bp\">.</span><span class=\"n\">getState</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"s2\">\"EnvExt was `true`, setting it to `false`\"</span>\n<span class=\"w\">    </span><span class=\"n\">setEnv</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">myCounter</span><span class=\"bp\">.</span><span class=\"n\">setState</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">false</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>File2</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">File1</span>\n\n<span class=\"n\">EnvExt_false</span><span class=\"w\"> </span><span class=\"c1\">-- EnvExt was `true`, setting it to `false`</span>\n</code></pre></div>\n<p>and <code>EnvExt_false</code> does not stop printing its message when I edit the file!</p>",
        "id": 462087878,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723548802
    },
    {
        "content": "<p>The next step is to check whether this will work with a linter.</p>",
        "id": 462088052,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723548871
    },
    {
        "content": "<p>Unfortunately, I do not seem to be able to modify the <code>EnvExtension</code> from within a linter.</p>",
        "id": 462089425,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723549246
    },
    {
        "content": "<p>I think you need to write to the environment during the build of the oleans. The most common way this is done is via attribute tagging. I am not sure how useful it is to your use case but it gives examples of use.</p>",
        "id": 462092739,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1723549957
    },
    {
        "content": "<p>Can you give me an example of something that does that?</p>",
        "id": 462092877,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723550007
    },
    {
        "content": "<p>I’m away from my computer but <code>rg 'addEntry' Mathlib/Tactic</code> should provide many</p>",
        "id": 462094607,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1723550436
    },
    {
        "content": "<p>Ok, thanks!  This is probably enough: I just wanted to find an entry-point!</p>",
        "id": 462094803,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723550464
    },
    {
        "content": "<p>You probably want a <code>PersistentEnvExtension</code> also</p>",
        "id": 462096697,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1723551129
    },
    {
        "content": "<p>I am probably making things too complicated: all that I want is to pass the knowledge to the linter of whether it has already processed a command in a file or not.</p>",
        "id": 462096840,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723551187
    },
    {
        "content": "<p>(Note that <code>import</code> statements are not \"seen\" by the linter, so \"the first command\" really means \"the first non-<code>import</code> command\", but that is by default and also what I want!)</p>",
        "id": 462096915,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723551226
    },
    {
        "content": "<p>Processed in a separate file?</p>",
        "id": 462097039,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1723551266
    },
    {
        "content": "<p>I am trying to check whether each linted file starts with a doc-module string and report it if it does not.</p>",
        "id": 462097226,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723551318
    },
    {
        "content": "<p>So, every file that imports the linter will be processed.</p>",
        "id": 462097296,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723551335
    },
    {
        "content": "<p>If I understood your question correctly, then yes: the linter is in one file and every downstream file from there is where I want the check to happen.</p>",
        "id": 462097447,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723551367
    },
    {
        "content": "<p>Reading the docs, I think that <code>PersistentEnvExtension</code>s may not be what I want: if I understand correctly, the <code>Persistent</code> part is that it passes on information to the downstream modules.  While I do not really care about that information, I just want to perform a check on each module separately.</p>",
        "id": 462100438,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723552140
    },
    {
        "content": "<p>Sorry, I’m not exactly sure what is wanted. It seemed from your example that you wanted to persist some state from one file to the next.</p>",
        "id": 462102153,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1723552441
    },
    {
        "content": "<p>Ah no, I wanted the state of each file to change upon reaching some command.  The example above worked as intended for the actual command <code>EnvExt_false</code>, but <em>linter</em>s do not seem to be able to globally modify environment extensions.</p>",
        "id": 462102959,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723552569
    },
    {
        "content": "<p>So, it appears that within the linter, when it is processing a command, I can modify the envExtension, but as soon as the linter releases the current command, the environment switches back to what it was before the linter modified it.</p>",
        "id": 462103168,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723552617
    },
    {
        "content": "<p>I suspect that linters run in a <code>withoutModifyingEnv</code> wrapper, so I am really not sure what to do.</p>",
        "id": 462103321,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723552649
    },
    {
        "content": "<p>Their modifications of <code>IO.Ref</code>s do work, but the <code>IO.Ref</code>s are flimsy and need to reload the file to be reliably used.</p>",
        "id": 462103466,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723552678
    },
    {
        "content": "<p>I think what you actually want is for a linter to be able to access any syntax tree/snapshot up to the current command, which is a request that has come up before</p>",
        "id": 462104966,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1723553004
    },
    {
        "content": "<p>Then you don't need to carry any state yourself, which is good because we want linters to run in parallel to elaboration</p>",
        "id": 462105046,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1723553042
    },
    {
        "content": "<p>That would certainly be enough!  I think that for this specific case, a much smaller amount of information would be already sufficient!</p>",
        "id": 462105122,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723553061
    },
    {
        "content": "<p>While we are here, would it be possible to have an option to make the linters run <em>before</em> the corresponding the command that they are linting?</p>",
        "id": 462105261,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723553113
    },
    {
        "content": "<p>This is a bit of speculation at this point but if we give linters access to the snapshot of the command, we could have them decide for themselves if they want to wait for the snapshot after elaboration or not</p>",
        "id": 462105455,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1723553185
    },
    {
        "content": "<p>Ok, I have wanted the option of choosing to run a linter <em>before</em> its command very often.</p>",
        "id": 462105553,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723553230
    },
    {
        "content": "<p>The typical case is that you modify the command, say by replacing a proof by <code>sorry</code> and you want to see if it still compiles, up to the <code>sorry</code> message.</p>",
        "id": 462105626,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723553262
    },
    {
        "content": "<p>Currently, you have to find a way to make the name not clash with the one of the current declaration.</p>",
        "id": 462105745,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723553286
    },
    {
        "content": "<p>If you could run the linter before the command, you could simply make it not modify the environment and be done!</p>",
        "id": 462105790,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723553308
    },
    {
        "content": "<p>I'm not sure I see how that wouldn't utterly tank performance unless you're extremely careful about what commands you want to modify and test</p>",
        "id": 462105971,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1723553382
    },
    {
        "content": "<p>These are more \"diagnostic\" linters: I do not intend to run them everywhere, but either every once in a while, or just on some files.</p>",
        "id": 462106126,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723553432
    },
    {
        "content": "<p>E.g., imagine that at some point you want to see which lemmas could be proved by <code>by simp</code>.  You run your linter once a week and tally the results.</p>",
        "id": 462106285,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723553476
    },
    {
        "content": "<p>Another situation that I have encountered is when you want to know if using a terminal <code>refine</code> is quicker than an <code>exact</code>: you run the linter and wait for the results!</p>",
        "id": 462106653,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723553588
    },
    {
        "content": "<p>Can I just get confirmation that linters cannot modify <code>EnvExtension</code>s, whether they are persistent or not?  I have been failing to do it, but I do not know if it is just that I am misunderstanding how to do that!  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 462151549,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723564701
    },
    {
        "content": "<p>they cannot do it, because <code>EnvExtension</code>s store data in the <code>Environment</code>, and linters are run inside a <code>withoutModifyingEnv</code> block</p>",
        "id": 462204665,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1723580044
    },
    {
        "content": "<p>actually I take it back, looking at the code it seems like there is nothing stopping them from modifying the environment</p>",
        "id": 462204970,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1723580148
    },
    {
        "content": "<p>Mario, if you could show me some code where a linter leaves a trace of it linting something, I'd be very grateful!</p>",
        "id": 462216336,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723585121
    },
    {
        "content": "<p>All I really would like is just to know if a linter already linted something in a file or not, but anything would be welcome!</p>",
        "id": 462216372,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723585148
    },
    {
        "content": "<p>Also, where do you see what the linters do?  I have been able to figure something out by seeing the \"in action\", but I have not found the code that is used to run them.</p>",
        "id": 462216482,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723585207
    },
    {
        "content": "<p>search for <code>runLinters</code> in core</p>",
        "id": 462217708,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1723585875
    },
    {
        "content": "<p>Oh, in Lean.Elab.Command?</p>",
        "id": 462217853,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723585941
    },
    {
        "content": "<p>If I am reading this correctly, it saves the state before running each linter and then sets it back <em>but returns the messages</em>!</p>",
        "id": 462218067,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723586064
    },
    {
        "content": "<p>So, I could embed persistent information in the messages!</p>",
        "id": 462218145,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723586095
    },
    {
        "content": "<p>none of that seems to be rolling back the environment though, AFAIK</p>",
        "id": 462218201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1723586130
    },
    {
        "content": "<p>Doesn't the <code>State</code> contain the <code>Environment</code>?  That seems to be saved and returned by the linters.</p>",
        "id": 462218295,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723586170
    },
    {
        "content": "<p>oh, yes it's the <code>let savedState ← get</code> ... <code>modify fun s =&gt; { savedState with messages := s.messages }</code> part</p>",
        "id": 462218343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1723586204
    },
    {
        "content": "<p>Right, the only thing that seems to filter through are the messages.</p>",
        "id": 462218367,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723586223
    },
    {
        "content": "<p>I don't think you get access to those messages later though, they are collected in the server</p>",
        "id": 462218500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1723586282
    },
    {
        "content": "<p>I guess that you are right: you can detect them <em>outside</em> of the linter, but not pass them on \"silently\" to the linting of the next command.</p>",
        "id": 462218625,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723586361
    },
    {
        "content": "<p>Maybe linters can store some information in the infotrees?  Anyway, time for bed here!</p>\n<p>Thanks a lot, though!  This has been very fruitful!</p>",
        "id": 462219495,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723586777
    },
    {
        "content": "<p>In case anyone here is interested, I was able to get an <code>IO.Ref</code> to work for a new linter: <a href=\"https://github.com/leanprover-community/mathlib4/pull/15794\">#15794</a>.</p>",
        "id": 462266602,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723613694
    },
    {
        "content": "<p>Just to mention one more caveat without looking too far into your code: did you consider the thread safety of such a linter? The language server is an asynchronous program.</p>",
        "id": 462289008,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1723623081
    },
    {
        "content": "<p>I would be happy to consider thread safety, but I do not know what it is...  <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 462290415,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723623576
    },
    {
        "content": "<p>Is it a valid/useful data point that the linter successfully identified all of mathlib?</p>",
        "id": 462290595,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723623629
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/270676-lean4/topic/Using.20.60IO.2ERef.60/near/462290415\">said</a>:</p>\n<blockquote>\n<p>I would be happy to consider thread safety, but I do not know what it is...  <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>\n</blockquote>\n<p>Thread safety is relevant once your function is not the only thing that may access some piece of data (in this case your IO.Ref) at any given time. This can happen when someone is using your linter while editing code with the language server. The fun thing about thread safety is that violations of it do not necessarily have to show up for everyone always when using the feature. Due to the way that concurrency etc. works it can be a sporadic, hard to observe but confusing phenomenon.</p>",
        "id": 462291005,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1723623785
    },
    {
        "content": "<p>Oh, I see!  Thanks for the explanation!</p>",
        "id": 462291838,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723624146
    },
    {
        "content": "<p>I have certainly observed thread unsafety when I was using <code>IO.Ref</code>s, although I have not played enough with this linter to know if this one is or not thread safe.  I did not observe \"funny behaviour\", but also did not use it extensively.</p>",
        "id": 462291938,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723624194
    },
    {
        "content": "<p>Just to be clear: in the aseptic setting of CI running <code>lake build</code>, thread safety is completely irrelevant, right?</p>",
        "id": 462292116,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723624245
    },
    {
        "content": "<p>At the moment yes, lake runs one process per file and that process is currently still single threaded (though that is partially going to change when we have in file parallelism of course)</p>",
        "id": 462292267,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1723624294
    },
    {
        "content": "<p>In the case of an <code>IO.Ref</code>, if a thread starts \"in the middle\", what value does it use?</p>",
        "id": 462292554,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723624405
    },
    {
        "content": "<p>Oh the interesting question is what happens when two threads write to it at the same time</p>",
        "id": 462292728,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1723624475
    },
    {
        "content": "<p>And the answer is, who knows!</p>",
        "id": 462292740,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1723624480
    },
    {
        "content": "<p>So, is an <code>IO.Ref</code> ever \"safe\"?</p>",
        "id": 462292775,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723624497
    },
    {
        "content": "<p>If you can guarantee it is not accessed by multiple threads sure.</p>",
        "id": 462292827,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1723624524
    },
    {
        "content": "<p>And how can you guarantee that?</p>",
        "id": 462292875,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723624543
    },
    {
        "content": "<p>(In my case, there is a linter that modifies the <code>IO.Ref</code> as its last step.)</p>",
        "id": 462292991,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723624585
    },
    {
        "content": "<p>(And the linter is the only process that knows about the IO.Ref.)</p>",
        "id": 462293122,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723624629
    },
    {
        "content": "<p>I fear the answer here is: \"by not using <code>IO.ref</code> from a linter\".</p>",
        "id": 465047976,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1724625889
    },
    {
        "content": "<p>Yes, I tried a few possibilities and they only worked \"statically\": most edits to the file would make the linter unpredictable.</p>",
        "id": 465056619,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1724632590
    }
]