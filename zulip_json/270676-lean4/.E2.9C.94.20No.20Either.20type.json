[
    {
        "content": "<p>We have <code>Except</code>. Is it better for me to add <code>Either</code> as well?</p>\n<p>They should be isomorphic, but <code>Either</code> means slightly different.</p>",
        "id": 338495321,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1677555940
    },
    {
        "content": "<p>Isn't it <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sum#doc\">docs4#Sum</a> ?</p>",
        "id": 338495675,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677556222
    },
    {
        "content": "<p>We ended up implementing this: <a href=\"https://github.com/yatima-inc/YatimaStdLib.lean/blob/main/YatimaStdLib/Either.lean\">https://github.com/yatima-inc/YatimaStdLib.lean/blob/main/YatimaStdLib/Either.lean</a></p>",
        "id": 338571293,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677586705
    },
    {
        "content": "<p>What was your motivation for avoiding <code>Sum</code>?</p>",
        "id": 338571985,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677586910
    },
    {
        "content": "<p>Mostly a weird name for the semantics that we wanted</p>",
        "id": 338572623,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677587088
    },
    {
        "content": "<p>What semantics did you want? I would guess they are precisely the semantics that Sum intends to have.</p>",
        "id": 338573840,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677587471
    },
    {
        "content": "<p>Perhaps we should add  a mention of Haskell's Either in the docs for Sum?</p>",
        "id": 338574083,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677587538
    },
    {
        "content": "<p>\"this thing is either of this (left) form or that other (right) form\"</p>\n<p>\"Sum\" in my intuition means that we are summing up things of the same type. Our team agreed that \"Either\" delivers the meaning just by speaking it out loud</p>",
        "id": 338576626,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677588166
    },
    {
        "content": "<p>So your complaint is not that the <em>type</em> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sum#doc\">docs4#Sum</a> has the wrong semantics, but that its name does</p>",
        "id": 338576811,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677588210
    },
    {
        "content": "<p>I think that's what Arthur said, right?</p>",
        "id": 338577125,
        "sender_full_name": "Reid Barton",
        "timestamp": 1677588294
    },
    {
        "content": "<p>But anyways, surely the core library doesn't need both names for the same thing.</p>",
        "id": 338577196,
        "sender_full_name": "Reid Barton",
        "timestamp": 1677588311
    },
    {
        "content": "<p>Renaming <code>Sum</code> to <code>Either</code> (and <code>Prod</code> to <code>Pair</code>?) would help with various name confusions in mathlib between <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sum\">docs#sum</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum\">docs#finset.sum</a>, but I suspect it would make the Type theorists sad, and this is certainly something that the Lean4 devs do not want on their already overloaded plate right now.</p>",
        "id": 338577213,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677588316
    },
    {
        "content": "<p>In a sense \"sum\" is more accurate, because one might think that \"either an <code>Int</code> or an <code>Int</code>\" is the same thing as \"an <code>Int</code>\"</p>",
        "id": 338577297,
        "sender_full_name": "Reid Barton",
        "timestamp": 1677588335
    },
    {
        "content": "<p>Sum is surgical if you have subtypes of the same type. The notation fits perfectly, even. But for other use cases \"sum\" sounds like a misuse of something that was intended for something else</p>",
        "id": 338577850,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677588463
    },
    {
        "content": "<p>To what extend would better documentation fix \"sounds like a misuse\"?</p>",
        "id": 338577974,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677588489
    },
    {
        "content": "<p>I can't tell... the problem is in the name, and names really matter when programming</p>",
        "id": 338578233,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677588575
    },
    {
        "content": "<blockquote>\n<p>But for other use cases \"some\" sounds like a misuse of sumthing that was intended for sumthing else</p>\n</blockquote>\n<p>(Sorry... I couldn't stop myself.)</p>",
        "id": 338578590,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1677588643
    },
    {
        "content": "<p>The one practical difference I can think of (I believe this is the case in scala) is that <code>Either</code> is <em>right-biased</em> so that it has a <code>map</code> function which leaves the first component untouched (supposed to be the error) and maps only the second.</p>",
        "id": 338579436,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1677588878
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266304\">@Siddhartha Gadgil</span>, I think you're thinking of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Except#doc\">docs4#Except</a></p>",
        "id": 338579479,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677588894
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/No.20Either.20type/near/338579479\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"266304\">Siddhartha Gadgil</span>, I think you're thinking of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Except#doc\">docs4#Except</a></p>\n</blockquote>\n<p>In scala it is called <code>Either</code>, or at least I believe scala's <code>Either</code> means the same as Lean's <code>Except</code>.</p>",
        "id": 338580099,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1677589067
    },
    {
        "content": "<p>The Haskellers in our team started the <code>Either</code> movement because they weren't aware of <code>Except</code>. In the beginning, <code>Either</code> had the same asymmetries from the Haskell implementation.</p>\n<p>I was the one advocating in favor of dropping <code>Either</code> in favor of <code>Sum</code> and use <code>Except</code> for error signaling. But as the discussion went, I acknowledged that <code>Either</code> hits the nail on the head for the symmetric semantics. However, we did drop the asymmetry in favor of <code>Except</code></p>",
        "id": 338581575,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677589476
    },
    {
        "content": "<p>I wonder how far you could get by just making <code>Either</code> notation for <code>Sum</code></p>",
        "id": 338581745,
        "sender_full_name": "Reid Barton",
        "timestamp": 1677589535
    },
    {
        "content": "<p>That was another possibility, but we decided to make them truly different types with specific APIs for each use case</p>",
        "id": 338582062,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677589623
    },
    {
        "content": "<p>But I think we agree that there are no actual different use cases between <code>Sum</code> and <code>Either</code>, except the use case of \"having the name <code>Either</code>\"; right?</p>",
        "id": 338582176,
        "sender_full_name": "Reid Barton",
        "timestamp": 1677589665
    },
    {
        "content": "<p>I mean I didn't look too closely at the API you wrote but I'm sure you can find an essentially identical/expanded version of the API for <code>Sum</code></p>",
        "id": 338582325,
        "sender_full_name": "Reid Barton",
        "timestamp": 1677589708
    },
    {
        "content": "<p>And if you can't find the API you need for <code>Sum</code>, then it probably ought to exist</p>",
        "id": 338582442,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677589750
    },
    {
        "content": "<p>(it might be in Std or in mathlib, though)</p>",
        "id": 338582501,
        "sender_full_name": "Reid Barton",
        "timestamp": 1677589778
    },
    {
        "content": "<p>Is now a good time to mention that the notation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊕</mo></mrow><annotation encoding=\"application/x-tex\">\\oplus</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">⊕</span></span></span></span> for <code>Sum</code> is totally impossible from a mathematical perspective?</p>",
        "id": 338582547,
        "sender_full_name": "Reid Barton",
        "timestamp": 1677589795
    },
    {
        "content": "<p>We could call it <code>DisjointUnion</code></p>",
        "id": 338582698,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1677589839
    },
    {
        "content": "<p>So so... It just doesn't feel right to force a type to have a different semantic just by renaming it. I believe <code>Sum</code> was created for a purpose that doesn't coincide with the purpose we intended for <code>Either</code>. So we might as well make them not reducible to one another</p>",
        "id": 338582825,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677589879
    },
    {
        "content": "<p>I think <code>Sum</code> has the exact same purpose as <code>Either</code>. It's just that <code>Either</code> isn't used in the type theory/category theory language.</p>",
        "id": 338583050,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1677589940
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/270676-lean4/topic/No.20Either.20type/near/338582825\">said</a>:</p>\n<blockquote>\n<p>I believe <code>Sum</code> was created for a purpose that doesn't coincide with the purpose we intended for <code>Either</code></p>\n</blockquote>\n<p>What purpose do you believe it was created for?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/270676-lean4/topic/No.20Either.20type/near/338576626\">said</a>:</p>\n<blockquote>\n<p>\"Sum\" in my intuition means that we are summing up things of the same type. Our team agreed that \"Either\" delivers the meaning just by speaking it out loud</p>\n</blockquote>\n<p>I assume you agree that this intuition is a (understandable) misreading, and isn't actually related to the semantics of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sum?#doc\">docs4#Sum?</a></p>",
        "id": 338583094,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677589959
    },
    {
        "content": "<p>But as Reid more-or-less points out, <code>Sum</code> isn't a great name for 99% of mathematicians either.</p>",
        "id": 338583116,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1677589970
    },
    {
        "content": "<p>I wasn't really trying to point that out, but of course I agree</p>",
        "id": 338583255,
        "sender_full_name": "Reid Barton",
        "timestamp": 1677590025
    },
    {
        "content": "<p>Hence the \"more-or-less\" <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 338583333,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1677590043
    },
    {
        "content": "<p><code>DisjointUnion</code> makes more sense, but it still doesn't make sense to me to have a disjoint union of <code>Nat</code> and <code>String</code></p>",
        "id": 338583466,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677590086
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/270676-lean4/topic/No.20Either.20type/near/338582698\">said</a>:</p>\n<blockquote>\n<p>We could call it <code>DisjointUnion</code></p>\n</blockquote>\n<p>This puts us in a bit of a mess with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.disjointUnion#doc\">docs4#Finset.disjointUnion</a> vs <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.disjSum#doc\">docs4#Finset.disjSum</a></p>",
        "id": 338583496,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677590094
    },
    {
        "content": "<p>I opened myself up to the possibility that \"either\" is simply a much better name. And fixing things up with notation or abbreviations is probably just a worse solution</p>",
        "id": 338584123,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677590287
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266304\">Siddhartha Gadgil</span> <a href=\"#narrow/stream/270676-lean4/topic/No.20Either.20type/near/338580099\">said</a>:</p>\n<blockquote>\n<p>In scala it is called <code>Either</code>, or at least I believe scala's <code>Either</code> means the same as Lean's <code>Except</code>.</p>\n</blockquote>\n<p>What does scala call Lean's <code>Sum</code>?</p>",
        "id": 338584329,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677590346
    },
    {
        "content": "<p><code>TaggedUnion</code> is something I’ve never heard a mathematician say</p>",
        "id": 338585103,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1677590572
    },
    {
        "content": "<p>In general you could name a type after the type itself (e.g. sum, product, sigma, pi) or after its inhabitants (e.g. <code>Either</code>, <code>List</code>, <code>Int</code>).<br>\nIn other words, does <code>X</code> mean \"the type <code>X</code>\" or \"the type of <code>X</code>s\".<br>\nI think Lean tends towards the latter. One complicating factor is that in math, I don't think we have <em>any</em> word for the inhabitants of a disjoint union.</p>",
        "id": 338585683,
        "sender_full_name": "Reid Barton",
        "timestamp": 1677590753
    },
    {
        "content": "<p><code>Except a b</code> serves the same purpose as either and also has support for error handling and try catch sugar. Otherwise you can implement your own instance of MonadExcept</p>",
        "id": 338605407,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1677595452
    },
    {
        "content": "<p>Different option for the name from C/C++ is  <code>union</code> or <code> variant</code></p>",
        "id": 338606722,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1677595788
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"433842\">@Anders Christiansen Sørby</span> we weren't interested in monadic behavior or error handling for <code>Either</code>. We just want it to hold data</p>",
        "id": 338609845,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677596489
    },
    {
        "content": "<p>Then it makes sense to implement that, but you could use Except without using the MonadExcept features</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">match</span> <span class=\"n\">except</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">...</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">error</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>Ofc Either is more purpose general with names.</p>",
        "id": 338611605,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1677596926
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"433842\">@Anders Christiansen Sørby</span>, if you're going to use<code>Except</code> without the monadic except features (ie, left and right become symmetric) you should just use <code>Sum</code>.</p>",
        "id": 338623354,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677599642
    },
    {
        "content": "<p>suggestion: someone make a metaprogramming toolkit for re-declaring an existing type but where you can change the type name + the name of its constructors. and it would re-declare all functions available on the original type as available on the new type, implemented via an idempotent cast to the copied type :)</p>",
        "id": 338669116,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1677611186
    },
    {
        "content": "<p>reason for me bringing this up is that the issue with both <code>Sum</code> and <code>Either</code> when developing software is that the intent with the left/right sides are often unclear. OCaml polymorphic variants are nice specifically because they let you name the alternatives. And I think it would not be unreasonable to declare a new type most of the times you want an <code>Either</code> -- but the overhead of re-declaring it is that you have to re-implement all of the functionality.</p>",
        "id": 338669529,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1677611304
    },
    {
        "content": "<p>so if that re-declarationing is done automatically, problem solved :) just make a new type each time, and auto-generate its interface by copying from an isomorphic one.</p>",
        "id": 338669739,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1677611359
    },
    {
        "content": "<p>This tool would also need to register an import or delcaration hook of some kind, so that downstream files declarating results about <code>Sum</code> would reproduce the same results about <code>MyEither</code></p>",
        "id": 338671273,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677611757
    },
    {
        "content": "<p>That is if we have <code>Sum.foo</code> in <code>A.lean</code>, <code>MyEither</code> and the metaprogram in <code>AB.lean</code>, <code>Sum.bar</code> in <code>AC.lean</code>, then <code>ABC.lean</code> (which imports <code>AC</code> and <code>AB</code>) needs to get hold of both <code>MyEither.foo</code> and <code>MyEither.bar</code>. The former likely was generated by the metaprogram, but when is the latter generated?</p>",
        "id": 338671773,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677611899
    },
    {
        "content": "<p>Wouldn't <code>@[reducible] def Either := Sum</code> do essentially this? (i.e., declaring a new type and having all the functionality of the original.)</p>",
        "id": 338681075,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1677614764
    },
    {
        "content": "<p>Yeah, and you can declare new definitions/patterns for the constructors.</p>\n<p>But there is an advantage to it being a new type, because I think you'd want to stop people from using the original's constructors. I don't know how necessary it would be to copy future declarations to the namespace.</p>",
        "id": 338690681,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1677617942
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/270676-lean4/topic/No.20Either.20type/near/338681075\">said</a>:</p>\n<blockquote>\n<p>Wouldn't <code>@[reducible] def Either := Sum</code> do essentially this? (i.e., declaring a new type and having all the functionality of the original.)</p>\n</blockquote>\n<p>I was going to say <code>abbrev Either := Sum</code> (which I believe will also inline stuff).</p>",
        "id": 338729837,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1677636348
    },
    {
        "content": "<p>Inline which stuff exactly?</p>",
        "id": 338733886,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1677639586
    },
    {
        "content": "<p>Isn't <code>abbrev</code> just syntactic sugar for <code>@[reducible] def</code>? In any case, with this approach it's too easy to have an <code>Either</code>, call some method and now the thing you have is a <code>Sum</code>, then, dot notation doesn't find methods you implemented on <code>Either</code> anymore</p>",
        "id": 338753592,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1677653382
    },
    {
        "content": "<p>the idea here is that you wouldn't be putting methods on <code>Either</code>, you are just reusing the <code>Sum</code> API. If you wanted to add more methods you would add them to <code>Sum.foo</code></p>",
        "id": 338755522,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677654180
    },
    {
        "content": "<p>Right, but if you have to remember that methods should be implemented on <code>Sum</code> rather than <code>Either</code>, then the situation is even more confusing than just using <code>Sum</code>, so it's not really a solution</p>",
        "id": 338799983,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1677667777
    },
    {
        "content": "<p>Slightly related: I had a situation were I defined</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">SparseList</span> <span class=\"o\">(</span><span class=\"bp\">\\</span><span class=\"n\">alpha</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"bp\">\\</span><span class=\"n\">alpha</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>With the intention to specialize <code>SparseList.all : SparseList \\alpha -&gt; (p : \\alpha -&gt; Prop) -&gt; Prop</code> to mean <code>p</code> holds for all <code>Some</code> variants in the list.<br>\nI guess I could have implemented this as <code>List.sparse_all</code> or something, but, to me, it feels more natural to implement it on <code>SparseList</code></p>",
        "id": 338801184,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1677668018
    },
    {
        "content": "<p>Yeah. Abbreviations are dangerous wrt dot notation because dot notation will unfold them if necessary. So making a new type and copying what you want from the old type's namespace gives you much better control over the functions in that type's namespace.</p>",
        "id": 338918552,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1677694482
    },
    {
        "content": "<p>How many methods are there in the first place on <code>Sum</code>/<code>Either</code>? I can't imagine this being a serious issue</p>",
        "id": 338939216,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677699716
    },
    {
        "content": "<p>All the important ones should already be defined</p>",
        "id": 338939382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677699744
    },
    {
        "content": "<p>This feels a bit like the vector space / module debate we had some time ago. I was really pushing for <code>VectorSpace := Module</code> so I wouldn't have to tell my 1st year students what a module was, and eventually we tried it (as an abbreviation I think?) but never got it working properly and I think ultimately reverted it, and now I've just got used to telling 1st years that Module is French for vector space.</p>",
        "id": 338939616,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1677699810
    },
    {
        "content": "<p>Why can't we just let Sum be German for Either?</p>",
        "id": 338939776,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1677699854
    },
    {
        "content": "<p>Note: the adoption of <code>Either</code> was an internal decision in Yatima. We don't mean to push this change on the community by any means. If you want to read the full discussion: <a href=\"https://zulip.yatima.io/#narrow/stream/24-yatima-tools/topic/.5BYatimaStdLib.2Elean.5D.20Sum.2C.20Either.2C.20Except.2C.20Result/near/29279\">https://zulip.yatima.io/#narrow/stream/24-yatima-tools/topic/.5BYatimaStdLib.2Elean.5D.20Sum.2C.20Either.2C.20Except.2C.20Result/near/29279</a></p>\n<p>Edit: I forgot that stream is not web-public <span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span></p>",
        "id": 338940448,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677700059
    },
    {
        "content": "<p>Long story short: some haskellers in the team implemented <code>Either</code> with asymmetric API as a port of Haskell's implementation because they were not aware of <code>Except</code>. After some discussion, we decided to drop the asymmetrical API in favor of <code>Except</code>. Some of us even considered dropping <code>Either</code> altogether, but I ended up adopting it, aware of the existence of <code>Sum</code>. But I did so because I wanted to stick with the name \"either\", not reducible to \"sum\". And I also wanted to implement the functions with names that made the most sense to me when programming</p>",
        "id": 338942190,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677700643
    },
    {
        "content": "<p>The question is: would your constraints be handled by having <code>Either</code> be an abbreviation for <code>Sum</code> and upstreaming all the functions that don't already exist?</p>",
        "id": 338943177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677700921
    },
    {
        "content": "<p>AFAICT none of the names of the functions would be any different if they were implemented for <code>Sum</code></p>",
        "id": 338943380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677700967
    },
    {
        "content": "<p>They're isomorphic so an abbreviation would work. But is this solution semantically sensible?</p>",
        "id": 338944185,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677701172
    },
    {
        "content": "<p>Again, when I read \"sum\", \"inl\" and \"inr\" I have no idea what I'm talking about</p>",
        "id": 338944300,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677701203
    },
    {
        "content": "<p>Do you have the same problem with <code>Or.inl</code> and <code>Or.inr</code>?</p>",
        "id": 338944850,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677701353
    },
    {
        "content": "<p><code>Or</code> is fine but I have to assume I know what <code>inl</code> and <code>inr</code> means. \"intro\"?<br>\nEither way, we're not using <code>Or</code> (yet)</p>",
        "id": 338945215,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677701432
    },
    {
        "content": "<p>inl means left injection FYI</p>",
        "id": 338945246,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677701448
    },
    {
        "content": "<p>I guess we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/or.intro_left\">docs#or.intro_left</a> as well, so the naming is already a mess there</p>",
        "id": 338945254,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677701451
    },
    {
        "content": "<p>it's type theory jargon</p>",
        "id": 338945288,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677701464
    },
    {
        "content": "<p>I also assumed it meant \"intro\"</p>",
        "id": 338945327,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677701476
    },
    {
        "content": "<p><del>Did mathlib4 drop <code>or.intro_left</code>?</del> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Or.intro_left#doc\">docs4#Or.intro_left</a></p>",
        "id": 338945379,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677701494
    },
    {
        "content": "<p>possibly?</p>",
        "id": 338945420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677701506
    },
    {
        "content": "<p>I'm generally against having multiple names for things without a good reason</p>",
        "id": 338945526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677701539
    },
    {
        "content": "<p>Nevermind, I got the naming convention wrong</p>",
        "id": 338945558,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677701551
    },
    {
        "content": "<p>The long spelling lets you speficify the type argument, though I guess the <code>(a := _)</code> syntax makes that not needed any more</p>",
        "id": 338945768,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677701636
    },
    {
        "content": "<p>I suspect the naming comes from places like this -&gt; <a href=\"https://ncatlab.org/nlab/show/sum+type\">https://ncatlab.org/nlab/show/sum+type</a></p>",
        "id": 338945820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677701644
    },
    {
        "content": "<p>And having two spellings is ok for Prop but disastrous for data</p>",
        "id": 338945843,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677701650
    },
    {
        "content": "<p>it helps a bit if you don't use <code>Sum A B</code> and instead just use <code>A ⊕ B</code>. It's an \"anonymous variant type\"</p>",
        "id": 338946081,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677701733
    },
    {
        "content": "<p>it's not supposed to have a name</p>",
        "id": 338946096,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677701740
    },
    {
        "content": "<p>but if you just think of it as <code>A ⊕ B</code> then calling it \"plus\" or \"sum\" makes sense</p>",
        "id": 338946156,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677701759
    },
    {
        "content": "<p>Constructor names can be \"replaced\" too with <code>@[match_pattern] def Either.left := Sum.inl</code>. But at this point it's just too much... really feels like I've started off with the wrong foot</p>",
        "id": 338946249,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677701776
    },
    {
        "content": "<p>If you want actual names you should be using an <code>inductive</code> tailored to the application domain</p>",
        "id": 338946321,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677701803
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> Where do you find you reach for <code>Either</code>/<code>Sum</code>? I think I usually would want to make a custom inductive rather than using an anonymous union.</p>",
        "id": 338946335,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677701807
    },
    {
        "content": "<p>Sorry, I didn't understand the question</p>",
        "id": 338946609,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677701899
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>: probably when you want to only have to write the monadic operations on lists etc once</p>",
        "id": 338946656,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677701912
    },
    {
        "content": "<p>Mario said the same thing as me. In my experience, code quality is better when I write an explicit <code>inductive foo | bar (b : Bar) | baz (b : Baz)</code> and use <code>foo</code> rather than use <code>Bar ⊕ Baz</code>.</p>",
        "id": 338947078,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677702032
    },
    {
        "content": "<p>(In contrast, I do use <code>Prod</code> frequently, but I think that's because there's the curry/uncurry relationship with <code>-&gt;</code> so it's natural.)</p>",
        "id": 338947172,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677702065
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I'm not sure what you mean -- what do lists have to do with <code>Sum</code>?</p>",
        "id": 338947714,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677702224
    },
    {
        "content": "<p>I'm referring to the functions in <a href=\"https://github.com/yatima-inc/YatimaStdLib.lean/blob/main/YatimaStdLib/Either.lean\">https://github.com/yatima-inc/YatimaStdLib.lean/blob/main/YatimaStdLib/Either.lean</a></p>",
        "id": 338947981,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677702318
    },
    {
        "content": "<p>The danger of writing an explicit inductive every time is that you don't get the same pile of free helper functions</p>",
        "id": 338948023,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677702342
    },
    {
        "content": "<p><code>deriving</code> helps with that though</p>",
        "id": 338948179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677702389
    },
    {
        "content": "<p><code>def rights (l : List $ Either α β) : List β :=</code> was the List example I had in mind</p>",
        "id": 338948205,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677702396
    },
    {
        "content": "<p>It looks like what can't be done with <code>deriving</code> could be done with some code generation. Like <code>rights</code> could come from applying <code>List.filterMap</code>/<code>Array.filterMap</code> to a generated <code>right? : Either α β -&gt; Option α</code></p>",
        "id": 338948672,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677702566
    },
    {
        "content": "<p>I guess in general it would be possible to generate <code>foo?</code> defs by looking for <code>foo</code> in constructor arguments</p>",
        "id": 338949121,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677702711
    },
    {
        "content": "<p>The rough spec I had in mind was that if you have a constructor <code>bar : (x : X) -&gt; (y : Y x) -&gt; (z : Z x y) -&gt; Foo</code> you'd generate <code>bar? : Foo -&gt; Option ((x : X) × (y : Y x) × Z x y)</code>, and then whenever the sigmas are non-dependent you simplify them to a product.</p>",
        "id": 338950325,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677702952
    },
    {
        "content": "<p>and for example if it's a one-argument constructor <code>bar : X -&gt; Foo</code> it'd just be <code>bar? : Foo -&gt; Option X</code></p>",
        "id": 338950522,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677703021
    },
    {
        "content": "<p>The number of people who misunderstood the original intent of the <code>inl</code>/<code>inr</code> jargon was striking to me, btw. I'm not a type theorist... I'm just a programmer and I'd like other programmers to have an easy time understanding what I write. If someone ctrl-clicked on an abbreviated version of <code>Either</code> and went to <code>Sum</code>, then asked me what that is supposed to mean, I would have passed on misleading information. Whereas <code>Either</code> gets the point across on a first hit</p>",
        "id": 338953533,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677704140
    },
    {
        "content": "<p>It's a small detail, but these small details add up and can make a big difference on larger code bases. If a name can avoid the need to read a docstring, it's a relevant improvement</p>",
        "id": 338954599,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677704428
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/270676-lean4/topic/No.20Either.20type/near/338953533\">said</a>:</p>\n<blockquote>\n<p>The number of people who misunderstood the original intent of the <code>inl</code>/<code>inr</code> jargon was striking to me, btw. I'm not a type theorist... I'm just a programmer and I'd like other programmers to have an easy time understanding what I write. If someone ctrl-clicked on an abbreviated version of <code>Either</code> and went to <code>Sum</code>, then asked me what that is supposed to mean, I would have passed on misleading information. Whereas <code>Either</code> gets the point across on a first hit</p>\n</blockquote>\n<p>I think this means we need better documentation on <code>Sum</code> then</p>",
        "id": 338959060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677705665
    },
    {
        "content": "<p>To be fair, \"injection\" vs \"introduction\" are both reasonable readings, for all I know it's a pun between them</p>",
        "id": 338959137,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677705700
    },
    {
        "content": "<p>I don't know the originator of this naming convention</p>",
        "id": 338959171,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677705717
    },
    {
        "content": "<p>I think that this mostly indicates that you are misusing the type though. If you want better names for things you should not be using <code>Sum</code> at all. It is specifically intended for the case where you don't want to name things</p>",
        "id": 338959490,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677705836
    },
    {
        "content": "<p>I don't think <code>left</code> and <code>right</code> are significantly better names BTW, they don't tell you anything about what these things <em>mean</em></p>",
        "id": 338959691,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677705917
    },
    {
        "content": "<p>The one thing I like about <code>Either</code> for the exception monad is that <code>right</code> is when everything went right. (Of course, <code>left</code> is when the computation went left.)</p>",
        "id": 338959995,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677706042
    },
    {
        "content": "<p>I guess the other one should be <code>sideways</code> then</p>",
        "id": 338960042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1677706066
    },
    {
        "content": "<p>AFAIK, the \"right\" mnemonic is precisely the reason for the adoption in Haskell for error signaling</p>",
        "id": 338960346,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677706161
    },
    {
        "content": "<p>And this \"mnemonic\" is what you call \"obviously the right semantic without reading docstrings?\"</p>",
        "id": 338963325,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1677707411
    },
    {
        "content": "<p>I'll try to refrain from saying that this intuition is left.</p>",
        "id": 338963459,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677707477
    },
    {
        "content": "<p>In case it isn't clear: I read all this conversation very quickly and my comment is not meant to be taken seriously.</p>",
        "id": 338963800,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1677707634
    },
    {
        "content": "<p>I don't really have any opinions about this that should matter, but as far as I understand the folks that like <code>Either</code> (for the right of left reasons) are coming with some haskell experience, and I don't think we need to worry about our names matching haskell. <code>Option</code> vs. <code>Maybe</code> is another example of such a disconnect. What names/terminology do other functional languages use?</p>",
        "id": 338964474,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677707896
    },
    {
        "content": "<p>I've seen Option in ML and Rust.</p>",
        "id": 338964528,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1677707933
    },
    {
        "content": "<p>I support whatever name most scares mathematicians.</p>",
        "id": 338964538,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1677707936
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/270676-lean4/topic/No.20Either.20type/near/338964538\">said</a>:</p>\n<blockquote>\n<p>I support whatever name most scares mathematicians.</p>\n</blockquote>\n<p>I think the notation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊕</mo></mrow><annotation encoding=\"application/x-tex\">\\oplus</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">⊕</span></span></span></span> for the disjoint union is already scary enough :)</p>",
        "id": 338964625,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677707979
    },
    {
        "content": "<p>Not in that way! <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 338964641,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1677707989
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/No.20Either.20type/near/338963325\">said</a>:</p>\n<blockquote>\n<p>And this \"mnemonic\" is what you call \"obviously the right semantic without reading docstrings?\"</p>\n</blockquote>\n<p>No, I don't support the use of <code>Either</code> to signal errors. <code>Except</code> already has perfectly fine constructor names for that</p>",
        "id": 338978540,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677714975
    },
    {
        "content": "<p>But I do think <code>left</code> and <code>right</code> read better than <code>inl</code> and <code>inr</code>. And when I say \"read better\" I mean \"it's easier for me to think programmatically\"</p>\n<p>This is highly subjective. <code>inl</code> and <code>inr</code> have less letters and that's arguably an advantage</p>",
        "id": 338978854,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1677715182
    },
    {
        "content": "<p>I don't think we should optimize for shorter names to quite that degree, following that logic <code>l</code> and <code>r</code> would be the best names. I always read the names as \"in left\" and \"in right\"; as in, <code>Sum.inl a</code> means that <code>a</code> is \"in\" the left type of the sum. Clearly the <code>in</code> part of the constructor names isn't super clear, so I'd say <code>left</code> and <code>right</code> would be the best choice.</p>",
        "id": 339065333,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1677754722
    },
    {
        "content": "<p>+1 to adding <code>@[match_pattern] Sum.left/right := Sum.inl/r</code> to Std or similar</p>",
        "id": 339208374,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1677792534
    },
    {
        "content": "<p>I felt like I needed more Std4 PRs to get stuck in review limbo, so I went ahead and made this: <a href=\"https://github.com/leanprover/std4/pull/105\">https://github.com/leanprover/std4/pull/105</a></p>\n<p>(Maybe try to avoid bikeshedding? but this is a bikeshedding type PR <span aria-label=\"frowning\" class=\"emoji emoji-1f626\" role=\"img\" title=\"frowning\">:frowning:</span>)</p>",
        "id": 339657758,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1678004148
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515610\">Locria Cyber</span> has marked this topic as resolved.</p>",
        "id": 339824550,
        "sender_full_name": "Notification Bot",
        "timestamp": 1678097286
    },
    {
        "content": "<p>where does the name \"inl inr\" come from?</p>",
        "id": 339825606,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1678097513
    },
    {
        "content": "<p>from <a href=\"https://link.springer.com/book/10.1007/3-540-09724-4\">https://link.springer.com/book/10.1007/3-540-09724-4</a> if not earlier</p>",
        "id": 339902025,
        "sender_full_name": "Reid Barton",
        "timestamp": 1678117251
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20No.20Either.20type/near/338945246\">said</a>:</p>\n<blockquote>\n<p>inl means left injection FYI</p>\n</blockquote>\n<p>Someone reminded me of this thread in Banff (I also got the quiz on\" what does <code>inl</code> stand for\" wrong), but now I just spotted that MIL says <code>inl</code> is introduction left too, <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C03_Logic.html#disjunction\">https://leanprover-community.github.io/mathematics_in_lean/C03_Logic.html#disjunction</a>, should we change that, or can we all just agree that \"introduction left\" is a fine explanation for these names.</p>",
        "id": 363081072,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1685718521
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/or.intro_left\">docs#or.intro_left</a> existing is certainly an argument for that interpretation</p>",
        "id": 363097493,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685721816
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20No.20Either.20type/near/338978854\">said</a>:</p>\n<blockquote>\n<p>But I do think <code>left</code> and <code>right</code> read better than <code>inl</code> and <code>inr</code>. And when I say \"read better\" I mean \"it's easier for me to think programmatically\"</p>\n<p>This is highly subjective. <code>inl</code> and <code>inr</code> have less letters and that's arguably an advantage</p>\n</blockquote>\n<p>I much prefer <code>inl</code> and <code>inr</code> for programming -- they have the same number of letters which keeps code column-aligned (e.g., in matches). For the same reason, I like <code>lft</code> and <code>rht</code> better as names for the <code>a -&gt; b -&gt; a</code> and <code>a -&gt; b -&gt; b</code> functional utilities.</p>",
        "id": 363386698,
        "sender_full_name": "Mac Malone",
        "timestamp": 1685829385
    }
]