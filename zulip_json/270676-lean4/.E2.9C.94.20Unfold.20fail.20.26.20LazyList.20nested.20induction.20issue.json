[
    {
        "content": "<p>Found an example that causes unfold to fail:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">LazyList</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tl</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">delayed</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Thunk</span> <span class=\"o\">(</span><span class=\"n\">LazyList</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">LazyList</span>\n<span class=\"kd\">def</span> <span class=\"n\">length</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span>        <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">_</span> <span class=\"n\">as</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">length</span> <span class=\"n\">as</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">delayed</span> <span class=\"n\">as</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">length</span> <span class=\"n\">as.get</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">force</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">LazyList</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">delayed</span> <span class=\"n\">as</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">force</span> <span class=\"n\">as.get</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span>        <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">as</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">as</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span> <span class=\"n\">LazyList</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">rotate</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f.length</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">r.length</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">LazyList</span> <span class=\"n\">τ</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">r</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">List.nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False.elim</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">r'</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">match</span> <span class=\"n\">f.force</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span>  <span class=\"n\">LazyList.cons</span> <span class=\"n\">y</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f'</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">LazyList.cons</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">rotate</span> <span class=\"n\">f'</span> <span class=\"n\">r'</span> <span class=\"o\">(</span><span class=\"n\">LazyList.cons</span> <span class=\"n\">y</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"gr\">sorry</span><span class=\"o\">))</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">rotate_inv</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">R</span><span class=\"o\">}</span>\n  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">rotate</span> <span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"n\">nil</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"n\">F.length</span> <span class=\"bp\">+</span> <span class=\"n\">R.length</span>\n  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">F</span>\n  <span class=\"n\">case</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">rotate</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"gr\">sorry</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>The issue goes away if <code>rotate</code> doesn't take the <code>h</code> parameter, OR if there is only one match instead of two. So I'm not sure how to cut down this MWE more.</p>",
        "id": 274813994,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646906921
    },
    {
        "content": "<p>And a minor error-message complaint, I originally wrote <code>rotate_inv</code> as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">rotate_inv</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">rotate</span> <span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"n\">F.length</span> <span class=\"bp\">+</span> <span class=\"n\">R.length</span>\n  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">induction</span> <span class=\"n\">F</span>\n    <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"gr\">sorry</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>with the <code>h</code> as a parameter, and got a nebulous <code>tactic 'introN' failed, insufficient number of binders</code> at <code>induction F</code>. Unsure if that is an issue or if the error message is just too generic.</p>",
        "id": 274814456,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646907187
    },
    {
        "content": "<p>On further poking it looks like the second issue is because it tries to generalize <code>h</code>, but then the motive for the nested induction is left as a meta-variable and thus doesn't have the <code>(h : _) -&gt;</code> binder it expects to have</p>",
        "id": 274815467,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646907755
    },
    {
        "content": "<p>which, actually, is still the case if <code>h</code> is moved into the return type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">rotate_inv</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">R</span><span class=\"o\">}</span>\n  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">rotate</span> <span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"n\">F.length</span> <span class=\"bp\">+</span> <span class=\"n\">R.length</span>\n  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">F</span>\n  <span class=\"n\">case</span> <span class=\"n\">mk</span> <span class=\"n\">fn</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span>\n    <span class=\"n\">exact</span> <span class=\"n\">ih</span> <span class=\"o\">()</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"gr\">sorry</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>The <code>intro</code> raises the same error.</p>",
        "id": 274815675,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646907869
    },
    {
        "content": "<p>(Cleaned up the MWE above quite a bit; this seems to be as simple as I can get it)</p>",
        "id": 274943706,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1646987008
    },
    {
        "content": "<p>Thanks for the MWE. I am working on it.</p>",
        "id": 275032581,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647032100
    },
    {
        "content": "<p>Pushed a fix for this issue.<br>\nBTW, the <code>induction</code> tactic is not effective for types such as <code>LazyList</code>. <code>LazyList</code> is a nested inductive type because of the <code>Thunk</code>. Thus, the <code>LazyList.rec</code> recursor (used by the induction tactic) has two motives. See</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"n\">LazyList.rec</span>\n</code></pre></div>\n<p>I will modify <code>induction</code> to generate an error message in this kind of situation. <br>\nYou can use well-founded recursion to prove the theorem. We have recently added an example in \"Theorem Proving in Lean 4\" <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html#mutual-recursion\">https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html#mutual-recursion</a>.  It is much easier than in Lean 3. It is the <code>theorem numConsts_replaceConst</code> example.<br>\nYou can also add a custom induction theorem for <code>LazyList</code> which makes things much more convenient to use. Here is the example:<br>\n<a href=\"https://github.com/leanprover/lean4/blob/master/tests/lean/run/lazyListRotateUnfoldProof.lean#L33-L48\">https://github.com/leanprover/lean4/blob/master/tests/lean/run/lazyListRotateUnfoldProof.lean#L33-L48</a></p>",
        "id": 275043291,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647037743
    },
    {
        "content": "<p>Oh awesome, will give it a read!</p>",
        "id": 275043585,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1647037922
    },
    {
        "content": "<p>Okay, this makes sense. For some nested inductions you may want the motive to be different, in which case you can use the mutual definitions.</p>\n<p>But for LazyList since we never actually want the motives to differ we just define an induction technique that has the same motive for both.</p>",
        "id": 275044433,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1647038489
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> has marked this topic as resolved.</p>",
        "id": 275044438,
        "sender_full_name": "Notification Bot",
        "timestamp": 1647038496
    }
]