[
    {
        "content": "<p>Is there an inexpensive way of normalizing Lean definitions? The goal is to (SHA)-hash  the normalized forms for caching purposes.   </p>\n<p>Two definitions that normalize to the same text should be equivalent, but it is fine for equivalent definitions to not normalize to the same text.</p>\n<p>Perhaps normalizing up to variable renaming  and basic type inference is achievable? (In the example below, <code>foo</code> and <code>syntacticallyFoo</code> normalize to the same text, but <code>semanticallyFoo</code> does not). </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- some definition</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"c1\">-- some other definition with different</span>\n<span class=\"c1\">-- variable names and output type elided</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">syntacticallyFoo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">someVar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">someOtherVar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">someVar</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">someOtherVar</span>\n\n<span class=\"c1\">-- this is not syntactially identically modulo</span>\n<span class=\"c1\">-- variable renaming (but semantically identical)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">semanticallyFoo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span>\n</code></pre></div>",
        "id": 554516059,
        "sender_full_name": "Arvind Arasu",
        "timestamp": 1762641751
    },
    {
        "content": "<p>if you want hashing I think it would be better to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.ExprStructEq#doc\">docs#Lean.ExprStructEq</a></p>",
        "id": 554518280,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762644067
    },
    {
        "content": "<p>what are you hashing it for?</p>",
        "id": 554518286,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762644072
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"708769\">Arvind Arasu</span> <a href=\"#narrow/channel/270676-lean4/topic/Normalize.20definitions.20.28for.20hashing.20and.20caching.29/near/554516059\">said</a>:</p>\n<blockquote>\n<p>Perhaps normalizing up to variable renaming  and basic type inference is achievable?</p>\n</blockquote>\n<p>What do you mean \"basic type inference\"? I don't think you should have to do any type inference for this basic kind of normalization?</p>",
        "id": 554519486,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762645415
    },
    {
        "content": "<p>and if you're doing type inference then it's not really basic anymore</p>",
        "id": 554519730,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762645721
    },
    {
        "content": "<p>Thanks Aaron. </p>\n<p>The exact scenario requires some context - not sure I can do justice here: we are using Lean to capture user intent and drive actions using an LLM. Once a Lean definition is formulated, it triggers a potentially expensive LLM action (e.g., proof generation).  </p>\n<p>We want to mitigate this expense by caching the steps associated with a definition the first time it occurs and using it for subsequent equivalent definitions.</p>",
        "id": 554535234,
        "sender_full_name": "Arvind Arasu",
        "timestamp": 1762665038
    },
    {
        "content": "<p>You probably want to use the default <code>BEq</code> and <code>Hash</code> instances on <code>Lean.Expr</code>, since I believe that already accounts for renaming of variables. You might also want to account for reordering of variables/hypotheses by normalizing their order, which is being discussed here: <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/duplicate.20declarations/with/548299209\">#mathlib4 &gt; duplicate declarations</a></p>",
        "id": 554563409,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1762695839
    },
    {
        "content": "<p>Thanks Jovan. I hacked up something based on this suggestion and it works well for my purposes (but without re-ordering variables/hypothesis for now).</p>",
        "id": 554779885,
        "sender_full_name": "Arvind Arasu",
        "timestamp": 1762804478
    }
]