[
    {
        "content": "<p>I haven't actually written much Lean 4 code in some sense, I've been doing a lot of porting which is a different workflow to actually creating new theorems. I have now written some code though, and two things that frustrated me were no autocomplete in imports and no powerful autocomplete in lemma names. In the below screenshots I am pressing ctrl+space to switch on search, and Esc to switch it off. As can be seen, the results in Lean 3 are far more powerful than those in Lean 4.</p>\n<p><a href=\"/user_uploads/3121/0h6ZP92k7S3wuGPoWfChFI3E/autocomplete3.gif\">autocomplete3.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/0h6ZP92k7S3wuGPoWfChFI3E/autocomplete3.gif\" title=\"autocomplete3.gif\"><img src=\"/user_uploads/3121/0h6ZP92k7S3wuGPoWfChFI3E/autocomplete3.gif\"></a></div><p><a href=\"/user_uploads/3121/XzDXRfaVxLZOtj9vfRjff7na/autocomplete4.gif\">autocomplete4.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/XzDXRfaVxLZOtj9vfRjff7na/autocomplete4.gif\" title=\"autocomplete4.gif\"><img src=\"/user_uploads/3121/XzDXRfaVxLZOtj9vfRjff7na/autocomplete4.gif\"></a></div><p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> this is what I was alluding to in the other thread. Note in particular the powerful search for <code>coprimeiff</code>, which will potentially pick up results called <code>...coprime.iff...</code> and <code>...coprime_iff...</code>; I often do not know which one will be the one I'm looking for, but just writing <code>coprimeiff</code> searches for both. The ctrl-space search functionality is far more efficient than using the VS Code search functionality and furthermore gives far fewer false positives.</p>",
        "id": 358992435,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684332158
    },
    {
        "content": "<p>Is it better with <code>exact</code>?</p>",
        "id": 359005118,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1684335127
    },
    {
        "content": "<p>No, it's the same.</p>",
        "id": 359006768,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684335501
    },
    {
        "content": "<p><code>Nat.coprimeiff</code> works with both <code>rw</code> and <code>exact</code> (Lean suggests things like <code>Nat.coprime_mul_iff_left</code>) so maybe it's something to do with namespaces.</p>",
        "id": 359007815,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684335734
    },
    {
        "content": "<p>Oh I see, yes, Lean 4 only considers the next name component right now</p>",
        "id": 359008353,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1684335871
    },
    {
        "content": "<p>The absence of autocompletion of <code>import</code> is indeed very painful.</p>",
        "id": 359014508,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1684337439
    },
    {
        "content": "<p>Yeah in demos I say \"OK so let's try and prove a theorem about continuous functions. Hmm, how shall we start? Let's try <code>import continu</code>...oh look. \"</p>",
        "id": 359029260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684341452
    },
    {
        "content": "<p>part of me thinks normal autocomplete isn't really made for the lean3 powerful search... maybe it would be better to have macros for searching, like <code>search \"coprime iff\"</code>, that provide code actions for the search results?</p>",
        "id": 359034075,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1684342736
    },
    {
        "content": "<p>this could allow configurability &amp; flexibility -- maybe the search splits up words and looks for anything with all those words in any order, finding both <code>iff_coprime</code> and <code>coprime_iff</code> theorems</p>",
        "id": 359034488,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1684342847
    },
    {
        "content": "<p>and generally when i want a powerful search (rather than autocomplete) i <em>want</em> something that triggers more explicitly than autocomplete (which is sometimes finicky). does anyone else have that feeling?</p>",
        "id": 359034896,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1684342938
    },
    {
        "content": "<p>What I like about the ctrl-space dance is that I can do in the middle of writing a line of tactic code or term code or whatever without having to step outside of where I am (e.g. outside the middle of a 40 line proof) or do any clicking on anything etc.</p>",
        "id": 359037688,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684343677
    },
    {
        "content": "<p>Totally. I wonder if we can get the same interface with code actions.</p>",
        "id": 359038159,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1684343793
    },
    {
        "content": "<p>Note the intended behavior of autocomplete is documented here: <a href=\"https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_completion\">https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_completion</a></p>",
        "id": 359042934,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684345001
    },
    {
        "content": "<p>In particular:</p>\n<blockquote>\n<p>to achieve consistency across languages and to honor different clients usually the client is responsible for filtering and sorting.</p>\n</blockquote>\n<p>So it sounds like we should just return as many matches as possible and leave vscode to filter them</p>",
        "id": 359043480,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684345187
    },
    {
        "content": "<p>Lean's language server is actually very hackable, and most of the semantic information is already there (I say based on limited attempts while trying to improve semantic highlighting).</p>",
        "id": 359045641,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1684345770
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/autocomplete.20woes/near/359043480\">said</a>:</p>\n<blockquote>\n<p>So it sounds like we should just return as many matches as possible and leave vscode to filter them</p>\n</blockquote>\n<p>it's a bit unclear from the documentation what servers should return... if the cursor is at <code>Lean.some|</code> should we just return all matches for <code>Lean.</code> or all that start with <code>Lean.some</code> or all that start with <code>Lean.</code> and have the letters s o m e?</p>",
        "id": 359047256,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1684346176
    },
    {
        "content": "<p>In VSCode I think the expectation is something like the last one -- specifically <a href=\"https://github.com//Microsoft/vscode/issues/15419\">https://github.com//Microsoft/vscode/issues/15419</a> was open for ages it seems which is the behavior from Kevin's Lean 3 capture, and was open for like 3 years before they added an option to turn it <em>off</em> and not do the fuzzy matching</p>",
        "id": 359049642,
        "sender_full_name": "Julian Berman",
        "timestamp": 1684346843
    },
    {
        "content": "<p>I suspect we may even want to do something like the first, ignoring user input after the dot and returning all options for that namespace. unclear what to do at top level though (keywords + top level idents + all idents in all open namespaces??? maybe if that list is cached it would be fine)</p>",
        "id": 359050467,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1684347110
    },
    {
        "content": "<p>Autocompleting at <code>Lean.some|</code>, my personal preference would be:</p>\n<ol>\n<li>exact match <code>Lean.something</code>;</li>\n<li>within the <code>Lean</code> namespace, fuzzy match on the <code>some</code>;</li>\n<li>rest of <code>Lean</code> namespace.</li>\n</ol>\n<p>However, anything that works, trumps any of the above!</p>",
        "id": 359060482,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684350122
    },
    {
        "content": "<p>While we're at it, I always found it incredibly irritating that autocompleting <code>s.pr|</code> gives <code>set.prod|</code> instead of <code>s.prod|</code>.</p>",
        "id": 359064534,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1684351414
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> I think most of the discussion is about what the server sends back -- the client (i.e. VSCode) can do lots of nice things once it has all the results. In nvim there are literally 10 different implementations even of just the word \"fuzzy\" in your number 2, because lots of people expect different sorting behavior (based on contiguous letters, based on item type, based on lots of other things which can feel very nice or very wrong, etc.). But the server has to send back enough results first to even get started</p>",
        "id": 359064777,
        "sender_full_name": "Julian Berman",
        "timestamp": 1684351499
    },
    {
        "content": "<p>(regardless of anything I think most people of course probably expect that if there's an exact match on what you've typed, you should get that, and if there's prefix matches on what you typed you should get those higher than other results, etc.)</p>",
        "id": 359065000,
        "sender_full_name": "Julian Berman",
        "timestamp": 1684351558
    },
    {
        "content": "<p>Julian, in this discussion, the \"server\" is...?</p>",
        "id": 359065012,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684351561
    },
    {
        "content": "<p>The Lean process running in the background</p>",
        "id": 359065123,
        "sender_full_name": "Julian Berman",
        "timestamp": 1684351585
    },
    {
        "content": "<p>Ok, so \"my\" computer, right?</p>",
        "id": 359065153,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684351600
    },
    {
        "content": "<p>Yeah both running on your computer typically</p>",
        "id": 359065175,
        "sender_full_name": "Julian Berman",
        "timestamp": 1684351609
    },
    {
        "content": "<p>Ah, one is what lean passes on the the editor is the other is what the editor does with the info?</p>",
        "id": 359065231,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684351633
    },
    {
        "content": "<p>Exactly</p>",
        "id": 359065243,
        "sender_full_name": "Julian Berman",
        "timestamp": 1684351639
    },
    {
        "content": "<p>ok, this clears up some confusion!</p>",
        "id": 359065269,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684351650
    },
    {
        "content": "<p>I thought that server could refer to an online machine...</p>",
        "id": 359065304,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684351670
    },
    {
        "content": "<p>Yeah it's confusing terminology, we programmers have to get back at you mathematicians somehow.</p>",
        "id": 359065466,
        "sender_full_name": "Julian Berman",
        "timestamp": 1684351723
    },
    {
        "content": "<p>Anyway, just to clarify, by \"fuzzy\" I meant a regular expression along the lines of <code>Lean\\..*s.*o.*m.*e.*</code></p>",
        "id": 359065794,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684351837
    },
    {
        "content": "<p>I think that after an exact match, this what I would like.</p>",
        "id": 359065860,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684351862
    },
    {
        "content": "<p>But, in the meantime, I have to figure out what server means...  and who know what other traps have you laid out for me!</p>",
        "id": 359065961,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684351889
    },
    {
        "content": "<p>And what order do you want the results in, arbitrary? Usually it's nice if results matching <code>Lean.som.*e</code> ranks higher than <code>Lean.s.*o.*m.*e</code> if there are results that match both</p>",
        "id": 359066147,
        "sender_full_name": "Julian Berman",
        "timestamp": 1684351928
    },
    {
        "content": "<p>There's a nice writeup of even more hairy details in <code>fzy</code>'s documentation</p>",
        "id": 359066193,
        "sender_full_name": "Julian Berman",
        "timestamp": 1684351942
    },
    {
        "content": "<p><a href=\"https://github.com/jhawthorn/fzy/blob/master/ALGORITHM.md\">https://github.com/jhawthorn/fzy/blob/master/ALGORITHM.md</a></p>",
        "id": 359066261,
        "sender_full_name": "Julian Berman",
        "timestamp": 1684351967
    },
    {
        "content": "<p>I find that the <code>fzf</code> add-on is what I would like.  Let me find a link.</p>",
        "id": 359066265,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684351968
    },
    {
        "content": "<p>I use this <em>all the time</em> and it is great!</p>\n<p><a href=\"https://github.com/junegunn/fzf\">https://github.com/junegunn/fzf</a></p>",
        "id": 359066353,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684351998
    },
    {
        "content": "<p><em>nod</em> -- yeah I'm aware of fzf's, cool, makes sense.</p>",
        "id": 359066355,
        "sender_full_name": "Julian Berman",
        "timestamp": 1684351999
    },
    {
        "content": "<p>(although I would prefer exact matches, before going fuzzy)</p>",
        "id": 359066387,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684352015
    },
    {
        "content": "<p>We're completely off-topic clearly, but if you haven't tried <code>fzy</code> I'd definitely recommend it</p>",
        "id": 359066529,
        "sender_full_name": "Julian Berman",
        "timestamp": 1684352050
    },
    {
        "content": "<p>I find its algorithm hugely more intuitive to my fingers than <code>fzf</code>'s (which is described in that link)</p>",
        "id": 359066575,
        "sender_full_name": "Julian Berman",
        "timestamp": 1684352064
    },
    {
        "content": "<p>with fzf, I no longer need to worry about folder structures: i simply start typing a fuzzy match and the correct file opens automatically.  having this for mathlib lemmas would be awesome!</p>",
        "id": 359066583,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684352066
    },
    {
        "content": "<p>In fact, it may be <del>possible</del>easy to have a cheap implementation of scrubbing the lemma names from mathlib and feeding them to your favourite fuzzy finder, at least on the cli</p>",
        "id": 359066929,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684352214
    },
    {
        "content": "<p>We can let the user decide on the matching algorithm, right?</p>",
        "id": 359066944,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1684352221
    },
    {
        "content": "<p>(although, seeing the type of each lemma is invaluable and would be hard to achieve on the commandline)</p>",
        "id": 359067224,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684352323
    },
    {
        "content": "<p>i've gotten so used to <code>fzf</code> that <code>fzy</code> would probably be a step back by now, to the point i do weird stuff like <code>RTCyEv</code> for <code>ring_theory/polynomial/cyclotomic/eval</code>; but it may be worth trying <code>fzy</code> for a couple days...</p>",
        "id": 359071680,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1684353734
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/stream/270676-lean4/topic/autocomplete.20woes/near/359066944\">said</a>:</p>\n<blockquote>\n<p>We can let the user decide on the matching algorithm, right?</p>\n</blockquote>\n<p>The \"user\" here is vscode I think. Maybe there as settings that let you customize it?</p>",
        "id": 359073418,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684354373
    },
    {
        "content": "<p>Writing Lean 4 code now I just wrote <code>quotientKerEquivOfSurjective</code> and Lean complained that this doesn't exist, whereas I know it does because I just copied it from a file. It's probably in a namespace though. In Lean 3 ctrl-space tab just solved that problem immediately, it would suggest the correct fully qualified name as the first shot. I miss this feature.</p>",
        "id": 359073521,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684354417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/autocomplete.20woes/near/359073418\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/stream/270676-lean4/topic/autocomplete.20woes/near/359066944\">said</a>:</p>\n<blockquote>\n<p>We can let the user decide on the matching algorithm, right?</p>\n</blockquote>\n<p>The \"user\" here is vscode I think. Maybe there as settings that let you customize it?</p>\n</blockquote>\n<p>don't think so</p>",
        "id": 359078043,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1684355975
    },
    {
        "content": "<p>I have no personal experience clearly but looks like there's at least one extension which mucks with it -- <del>https://marketplace.visualstudio.com/items?itemName=cfognom.VSIntelliSenseTweaks so there seems like there may be the hooks needed to do this from extensions</del> OK never mind that's for Visual Studio which I must say I didn't even know was still a thing.</p>",
        "id": 359078784,
        "sender_full_name": "Julian Berman",
        "timestamp": 1684356246
    },
    {
        "content": "<p>Here's one that got me the other day:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">MetaM</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>\n<p>Autocomplete on <code>MetaM</code> does not tell me that I wanted <code>Lean.MetaM</code></p>",
        "id": 375795409,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689523639
    },
    {
        "content": "<p>Isn't that the same issue as above? And, for documentation purposes, <a href=\"https://github.com/leanprover/lean4/pull/1659\">lean4#1659</a></p>",
        "id": 375798172,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1689524602
    },
    {
        "content": "<p>Ah, it's exactly that issue; sorry for the noise</p>",
        "id": 375798598,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689524750
    },
    {
        "content": "<p>Can we put a bounty on issues? Because I would be willing to put a lot on this one :-)</p>",
        "id": 375799986,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1689525236
    },
    {
        "content": "<p>you can upvote it</p>",
        "id": 375801141,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1689525655
    },
    {
        "content": "<p>I've been wondering how one would implement this efficiently. Surely we cannot want to do a linear search through the entire environment and check for things that end on a word right?</p>",
        "id": 375803025,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1689526359
    },
    {
        "content": "<p>If only VS Code understood partial results, we could actually return matches as soon as we find them</p>",
        "id": 375804952,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1689527106
    },
    {
        "content": "<p>But if performance was adequate in Lean 3, it should be possible to implement in Lean 4 as well</p>",
        "id": 375805249,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1689527217
    },
    {
        "content": "<p>what ever happened to that fuzzy autocomplete PR?</p>",
        "id": 375805294,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1689527230
    },
    {
        "content": "<p>I thought this was among the things that was handled</p>",
        "id": 375805315,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1689527240
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/1710\">lean4#1710</a> seems to have been merged</p>",
        "id": 375805526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1689527309
    },
    {
        "content": "<p>Only workspace symbols uses fuzzy matching on the entire name so far</p>",
        "id": 375805735,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1689527393
    },
    {
        "content": "<p>I see <code>FuzzyMatching.lean</code> is still there in the current version of lean but <code>FuzzyMatching.fuzzyMatch</code>  appears to be unused outside a benchmark</p>",
        "id": 375806002,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1689527485
    },
    {
        "content": "<p>oh, <code>fuzzyMatchScoreWithThreshold?</code>  is used instead</p>",
        "id": 375806286,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1689527595
    },
    {
        "content": "<p>Oh there it is: <a href=\"https://github.com/Kha/lean4/commit/73a46a05a48cc3b5d0ee9d7b8dea9fa46bba5b60\">https://github.com/Kha/lean4/commit/73a46a05a48cc3b5d0ee9d7b8dea9fa46bba5b60</a>. I ran out of time for actually testing it and refound it in my stash just now</p>",
        "id": 375806788,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1689527789
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/2351\">lean4#2351</a></p>",
        "id": 378133472,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1690203935
    }
]