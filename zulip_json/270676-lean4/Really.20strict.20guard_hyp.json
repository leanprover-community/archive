[
    {
        "content": "<p>In Lean 3, the strict version of <code>guard_hyp</code> was sensitive even to bound variable names. I thought this was the same in Lean 4 but:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆƒ</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">guard_hyp</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"bp\">â‚›</span><span class=\"w\"> </span><span class=\"bp\">âˆƒ</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"c1\">-- I hoped this would have failed</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>\n<p>Is this is a bug? Is there another variant that would catch this?</p>",
        "id": 491412676,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1735658380
    },
    {
        "content": "<p>That seems to be an oversight. <a href=\"https://github.com/leanprover/lean4/pull/6483\">lean4#6483</a> (still pending updating tests and fixing mathlib)</p>",
        "id": 491413573,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1735659001
    },
    {
        "content": "<p>Thanks Kyle! I just wrote</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"guard_hyp_strict\"</span><span class=\"w\"> </span><span class=\"n\">hyp</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"s2\">\" : \"</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">withMainContext</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">fvarid</span><span class=\"w\"> </span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"n\">getFVarId</span><span class=\"w\"> </span><span class=\"n\">hyp</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">lDecl</span><span class=\"w\"> </span><span class=\"bp\">â†</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"n\">getLCtx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"n\">fvarid</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"hypothesis {hyp} not found\"</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">lDecl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">lDecl</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">hty</span><span class=\"w\"> </span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span><span class=\"w\"> </span><span class=\"n\">lDecl</span><span class=\"bp\">.</span><span class=\"n\">type</span>\n<span class=\"w\">    </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">equal</span><span class=\"w\"> </span><span class=\"n\">hty</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"hypothesis {hyp} has type{indentExpr hty}</span><span class=\"se\">\\n</span><span class=\"s2\">not{indentExpr e}\"</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆƒ</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">guard_hyp_strict</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆƒ</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"c1\">-- I hoped this would have failed</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>\n<p>in Verbose Lean, using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr.equal#doc\">docs#Lean.Expr.equal</a> just like in your fix!</p>",
        "id": 491413820,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1735659126
    },
    {
        "content": "<p>(and copy-pasting a bit of the <code>guard_hyp</code> implementation of course).</p>",
        "id": 491413845,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1735659159
    },
    {
        "content": "<p>However I wonder whether this means there should have a new MatchKind here. Do you claim the existing syntactic kind is an actual strict duplicate?</p>",
        "id": 491413909,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1735659237
    },
    {
        "content": "<p>Maybe there could be a different matching kind (to account for whether to consume mdata), but both <code>.alphaEq</code> and <code>.syntactic</code> were using <code>Expr.eqv</code> (which is what <code>==</code> is defined to use), and <code>Expr.equal</code> is definitely the syntactic equality.</p>",
        "id": 491415151,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1735660087
    },
    {
        "content": "<p>Ok, I missed that fact that <code>==</code> uses <code>Expr.eqv</code>.</p>",
        "id": 491415293,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1735660197
    },
    {
        "content": "<p>Since you are in this corner of Lean, it would be nice if <code>success_if_fail_with_msg </code> could have a code action to fix the message like <code>guard_hyp</code> does.</p>",
        "id": 491416261,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1735660824
    },
    {
        "content": "<p>(One side effect of this change is that now <code>a -&gt; b</code> and <code>a -&gt; b</code> aren't necessarily syntactically equal, since there's a hidden binder name inside these foralls.)</p>",
        "id": 491418543,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1735662255
    },
    {
        "content": "<p><code>success_if_fail_with_msg</code> seems to be a mathlib tactic</p>",
        "id": 491418628,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1735662325
    },
    {
        "content": "<p>Weird, I was sure I checked.</p>",
        "id": 491418750,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1735662416
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> For <code>#guard_*</code>'s syntatic equality, should we have a pass that normalizes binder names for non-dependent foralls? Or do we accept that we need to use alpha equality instead of syntactic equality in such cases? Or maybe you have some other ideas?</p>",
        "id": 491418898,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1735662501
    },
    {
        "content": "<p>Indeed itâ€™s in <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/SuccessIfFailWithMsg.lean\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/SuccessIfFailWithMsg.lean</a></p>",
        "id": 491418969,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1735662569
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Really.20strict.20guard_hyp/near/491418898\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> For <code>#guard_*</code>'s syntatic equality, should we have a pass that normalizes binder names for non-dependent foralls? Or do we accept that we need to use alpha equality instead of syntactic equality in such cases? Or maybe you have some other ideas?</p>\n</blockquote>\n<p>Since this came up again <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/.60guard_target.60.20in.20syntactic.20mode\">here</a>: I would certainly support having the normalization pass (or yet another <code>Expr.equal'</code> that ignores non-dependent binders.) Without it, <code>Expr.equal</code> ended up being near useless in my tests.</p>",
        "id": 503690543,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1741235320
    }
]