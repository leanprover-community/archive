[
    {
        "content": "<p>I haven't looked too deep into lake's documentation/source code yet, just wondering whether there is already an example configuration for this somewhere that I could reference.</p>\n<p>I would like to have a two-step build process, where:</p>\n<ul>\n<li>Some lean code gets compiled.</li>\n<li>It gets run, and it outputs a <code>.lean</code> and a <code>.c</code> file.</li>\n<li>These are then compiled and linked to get the final binary.</li>\n</ul>\n<p>My use-case is to generate FFI bindings for a somewhat large API.</p>",
        "id": 396658566,
        "sender_full_name": "György Kurucz",
        "timestamp": 1697296844
    },
    {
        "content": "<p><a href=\"https://github.com/tydeu/lean4-alloy\">https://github.com/tydeu/lean4-alloy</a> this exists and I made this with it: <a href=\"https://github.com/hargoniX/socket.lean\">https://github.com/hargoniX/socket.lean</a>.</p>\n<p>Generating API bindings could get a little harder but in theory <span aria-label=\"tm\" class=\"emoji emoji-2122\" role=\"img\" title=\"tm\">:tm:</span> alloy is capable of parsing C code right. So maybe it's possible to write some other clever stuff around it to use it for generating FFI with it. Idk if that is a use case <span class=\"user-mention\" data-user-id=\"315577\">@Mac Malone</span> intended?</p>",
        "id": 396658804,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1697297029
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/lake.3A.20generating.20FFI.20bindings/near/396658804\">said</a>:</p>\n<blockquote>\n<p>Generating API bindings could get a little harder but in theory <span aria-label=\"tm\" class=\"emoji emoji-2122\" role=\"img\" title=\"tm\">:tm:</span> alloy is capable of parsing C code right. </p>\n</blockquote>\n<p>I am not sure by generate if <span class=\"user-mention\" data-user-id=\"651522\">@György Kurucz</span>'s meant to parse the C code as that is not part of the lists steps. I think they may have meant generate in the sense of some form of Lean templating since they suggest outputting both a <code>.lean</code> and a <code>.c</code> file. On that point, Lean rarely needs templating because the metaprogramming facilities are strong enough that you can dynamically generate the relevant definitions in step 1 (when the Lean code is compiled). Alloy is designed to the other half of step 2 (output a <code>.c</code> file and compile and link it with the Lean output).</p>\n<p>If you do want to parse C code, Alloy is capable of doing so (at least to some extent -- e.g., it can verifiable parse <code>lean.h</code>), but I have no knowledge of this kind of binding generation being tested with Alloy or anything else.</p>",
        "id": 396668418,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697306517
    },
    {
        "content": "<p>Thanks for the pointers!</p>\n<blockquote>\n<p>If you do want to parse C code</p>\n</blockquote>\n<p>no parsing of C code is involved, I am in fact generating everything from an XML file...</p>\n<blockquote>\n<p>Lean rarely needs templating</p>\n</blockquote>\n<p>True, and I just recently learned that <code>IO</code> can be used during metaprogramming, so I could just read my XML file and generate the relevant definitions</p>\n<blockquote>\n<p>Alloy is designed to the other half of step 2</p>\n</blockquote>\n<p>Is there a way to feed Alloy my generated C functions?</p>",
        "id": 396669359,
        "sender_full_name": "György Kurucz",
        "timestamp": 1697307585
    },
    {
        "content": "<p>Generally speaking you can always construct <code>Syntax</code> objects for Alloy commands  and <code>elabCommand</code> them from your elaborator in order to get what you want.</p>",
        "id": 396669446,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1697307662
    },
    {
        "content": "<p>Hm does Alloy help with marshaling C types to Lean types beyond what Lean provides by default? A large part of my custom generated C shim is just for unpacking/packing Lean structures to C structs, so if I could simplify that using Alloy that would be very interesting for me.</p>",
        "id": 396670154,
        "sender_full_name": "György Kurucz",
        "timestamp": 1697308410
    },
    {
        "content": "<blockquote>\n<p>Generally speaking you can always construct Syntax objects for Alloy commands</p>\n</blockquote>\n<p>I would rather avoid round-tripping my C <code>String</code> to Alloy's AST representation and then back again to a string, unless Alloy is helping me with something.</p>",
        "id": 396670259,
        "sender_full_name": "György Kurucz",
        "timestamp": 1697308537
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"651522\">György Kurucz</span> <a href=\"#narrow/stream/270676-lean4/topic/lake.3A.20generating.20FFI.20bindings/near/396670154\">said</a>:</p>\n<blockquote>\n<p>Hm does Alloy help with marshaling C types to Lean types beyond what Lean provides by default?</p>\n</blockquote>\n<p>Yes, Alloy provides <code>alloy c enum</code> and <code>alloy c extern_type</code> as compact ways to declare Lean types backed by C values. Though it is hard to know how much they would help in your particular use case without more information about it.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"651522\">György Kurucz</span> <a href=\"#narrow/stream/270676-lean4/topic/lake.3A.20generating.20FFI.20bindings/near/396670259\">said</a>:</p>\n<blockquote>\n<p>I would rather avoid round-tripping my C <code>String</code> to Alloy's AST representation and then back again to a string, unless Alloy is helping me with something.</p>\n</blockquote>\n<p>This roundtrip does allow Alloy C to add metadata relevant to editor features (e.g., go-to-def, etc..) for the generated C code. However, that may or may not be of use in your case. You can also add code directly to Alloy's C shim like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Alloy.C</span>\n<span class=\"kn\">open</span> <span class=\"n\">Alloy</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Command</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">addCode</span>  <span class=\"o\">(</span><span class=\"n\">code</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CommandElabM</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">modifyEnv</span> <span class=\"k\">fun</span> <span class=\"n\">env</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">C.shimExt.modifyState</span> <span class=\"n\">env</span> <span class=\"k\">fun</span> <span class=\"n\">shim</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"o\">{</span><span class=\"n\">shim</span> <span class=\"k\">with</span> <span class=\"n\">text</span> <span class=\"o\">:=</span> <span class=\"n\">FileMap.ofString</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">shim.text.source</span> <span class=\"bp\">++</span> <span class=\"n\">code</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>However, I have not tested whether this breaks assumptions Alloy makes about the structure of the C code (but I don't think it should).</p>",
        "id": 396686318,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697327734
    },
    {
        "content": "<p>Like Henrik, I would personally suggest constructing <code>Syntax</code> rather the a string for C code. It at least two major advantages that I can think of at the moment:</p>\n<ol>\n<li>It ensures the C snippets you write are well-formed syntax (no hard to debug errors due to typos).</li>\n<li>You can use Lean's metaprogramming features to trace, debug, and otherwise analyze the C code being produced.</li>\n</ol>",
        "id": 396686690,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697328103
    },
    {
        "content": "<blockquote>\n<p>Yes, Alloy provides <code>alloy c enum</code> and <code>alloy c extern_type</code></p>\n</blockquote>\n<p>I want to recursively pack/unpack C structs and arrays, so unfortunately I don't think these help much. For example:</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"k\">typedef</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">some_opaque_pointer</span><span class=\"p\">;</span>\n<span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">X</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"kt\">uint32_t</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kt\">float</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// yes, not double unfortunately</span>\n<span class=\"w\">  </span><span class=\"kt\">uint32_t</span><span class=\"w\"> </span><span class=\"n\">len_c</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kt\">char</span><span class=\"w\"> </span><span class=\"o\">**</span><span class=\"n\">c</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"n\">some_opaque_pointer</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">Y</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">Y</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"kt\">uint32_t</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n</code></pre></div>\n<p>Should be translated to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">SomeOpaquePointer</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">Unit</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Y</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">UInt32</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">UInt32</span>\n<span class=\"kd\">structure</span> <span class=\"n\">X</span> <span class=\"n\">where</span>\n  <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">UInt32</span>\n  <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n  <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">String</span>\n  <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">SomeOpaquePointer</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Y</span>\n</code></pre></div>\n<blockquote>\n<p>You can also add code directly to Alloy's C shim like so</p>\n</blockquote>\n<p>Thanks, this should be useful for some quick-and-dirty testing to see whether Alloy works at all for my use-case, but I understand that you recommend generating <code>Syntax</code> as a proper solution.</p>\n<p>Anyway, in a week or two I might post my results here on Zulip once I have a minimum viable example working, maybe then people can chime in with any better ideas for how large C API bindings should be done.</p>",
        "id": 396726985,
        "sender_full_name": "György Kurucz",
        "timestamp": 1697354793
    },
    {
        "content": "<p>Alloy provides a C to C solution, i.e. write C in Lean then generate IR in C.</p>\n<p>Reading the topic, it seems <span class=\"user-mention\" data-user-id=\"651522\">@György Kurucz</span>  needs to create a binding to something, but I can't really see whether it's <a href=\"https://github.com/utensil/ginac-lean/blob/main/doc/ffi.md#ffi-to-c-in-lean-4\">FFI</a> or <a href=\"https://github.com/leanprover/lean4/tree/master/src/lake/examples/reverse-ffi\">reverse FFI</a> yet, probably the former.</p>\n<p>But I'm also thinking about a Lean to C++ solution for bindings, i.e. write Lean and then generate some glue code in C++ body with <code>extern</code> C interface. I just don't know if the native ability of Lean of generating IR fits in the picture, as Lean only generates C not C++.</p>\n<p>I'm also OK with a C++ to C++ solution, i.e. write (a subset of) C++ in Lean and then emit the C++ body as is then surround it with generate C code, then send to C++ compiler.</p>",
        "id": 396730598,
        "sender_full_name": "Utensil Song",
        "timestamp": 1697357864
    },
    {
        "content": "<p>To be exact, I'm thinking about a Lean equivalent of <a href=\"https://doc.rust-lang.org/nightly/nomicon/ffi.html\">Unsafe Rust</a>.</p>",
        "id": 396730826,
        "sender_full_name": "Utensil Song",
        "timestamp": 1697358058
    },
    {
        "content": "<p>Ah, I haven't been reading <span class=\"user-mention\" data-user-id=\"651522\">@György Kurucz</span> 's C struct to Lean structure example carefully enough, I think they are exactly <a href=\"https://github.com/tydeu/lean4-alloy#disclaimer\">the missing</a> <a href=\"https://github.com/tydeu/lean4-alloy/blob/master/Alloy/C/IR.lean#L27-L28\">pieces</a> in alloy but they belong to alloy.</p>",
        "id": 396733551,
        "sender_full_name": "Utensil Song",
        "timestamp": 1697360349
    },
    {
        "content": "<p>Hm <span class=\"user-mention\" data-user-id=\"315577\">@Mac Malone</span> is this on the longer term roadmap for Alloy? (Though handling all the ambiguous cases is far from trivial, e.g. when to translate a pointer to <code>Option</code>, or how to handle the lengths of arrays.)</p>",
        "id": 396742952,
        "sender_full_name": "György Kurucz",
        "timestamp": 1697367317
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"651522\">@György Kurucz</span> Looking at your example above, I am unclear on how you wish to \"pack/unpack C structs \". Since Lean objects are reference counted and follow a strict ABI, a pointer for e.g. the C <code>struct X</code> cannot be directly casted into the Lean <code>structure X</code> and vice-versa. Are you expecting to deallocate the C struct and allocate the Lean struct and vice versa each time they pass through the FFI interface (which seems like a significant overhead)? Or do you have something else in mind?</p>",
        "id": 396778478,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697398297
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac Malone</span> </p>\n<blockquote>\n<p>Are you expecting to deallocate the C struct and allocate the Lean struct and vice versa each time they pass through the FFI</p>\n</blockquote>\n<p>Yes exactly, I don't see any other way. (For my use-case I don't expect this to be a bottleneck. And if it ever becomes one, you can always just push more of the logic to the C side until the FFI boundary is no longer the hotspot.)</p>\n<p>Continuing the above example, this is roughly what I would want (and also the reverse):</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&lt;lean/lean.h&gt;</span>\n<span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&lt;stdlib.h&gt;</span>\n\n<span class=\"k\">typedef</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">some_opaque_pointer</span><span class=\"p\">;</span>\n<span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">X</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"kt\">uint32_t</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kt\">float</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kt\">uint32_t</span><span class=\"w\"> </span><span class=\"n\">len_c</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">char</span><span class=\"w\"> </span><span class=\"o\">**</span><span class=\"n\">c</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"n\">some_opaque_pointer</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">Y</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">Y</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"kt\">uint32_t</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">X</span><span class=\"p\">);</span>\n\n<span class=\"cm\">/* X -&gt; IO Unit */</span>\n<span class=\"n\">LEAN_EXPORT</span><span class=\"w\"> </span><span class=\"n\">lean_obj_res</span><span class=\"w\"> </span><span class=\"n\">glue_f</span><span class=\"p\">(</span><span class=\"n\">b_lean_obj_arg</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b_lean_obj_arg</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"n\">lean_object</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lean_ctor_get</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"kt\">uint32_t</span><span class=\"w\"> </span><span class=\"n\">len_c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lean_array_size</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">char</span><span class=\"w\"> </span><span class=\"o\">**</span><span class=\"n\">unmarshaled_c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">calloc</span><span class=\"p\">(</span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"kt\">char</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">len_c</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// TODO: who owns?</span>\n<span class=\"w\">  </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">uint32_t</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"n\">len_c</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"c1\">// TODO: copy or borrow?</span>\n<span class=\"w\">    </span><span class=\"n\">unmarshaled_c</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lean_string_cstr</span><span class=\"p\">(</span><span class=\"n\">lean_array_get_core</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">));</span>\n<span class=\"w\">  </span><span class=\"p\">}</span>\n\n<span class=\"w\">  </span><span class=\"c1\">// TODO: not the only way to store pointers</span>\n<span class=\"w\">  </span><span class=\"n\">some_opaque_pointer</span><span class=\"w\"> </span><span class=\"n\">unmarshaled_p</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">some_opaque_pointer</span><span class=\"p\">)</span><span class=\"n\">lean_unbox</span><span class=\"p\">(</span><span class=\"n\">lean_ctor_get</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">));</span>\n\n<span class=\"w\">  </span><span class=\"n\">lean_object</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lean_ctor_get</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"kt\">bool</span><span class=\"w\"> </span><span class=\"n\">y_is_some</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"n\">lean_is_scalar</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">Y</span><span class=\"w\"> </span><span class=\"n\">unmarshaled_y</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">y_is_some</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">unmarshaled_y</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lean_ctor_get_uint32</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"n\">unmarshaled_y</span><span class=\"p\">.</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lean_ctor_get_uint32</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"p\">}</span>\n\n<span class=\"w\">  </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">X</span><span class=\"w\"> </span><span class=\"n\">unmarshaled_x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">      </span><span class=\"p\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lean_ctor_get_uint32</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">lean_object</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">)),</span>\n<span class=\"w\">      </span><span class=\"p\">.</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">float</span><span class=\"p\">)</span><span class=\"n\">lean_ctor_get_float</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">lean_object</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">)),</span>\n<span class=\"w\">      </span><span class=\"p\">.</span><span class=\"n\">len_c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">len_c</span><span class=\"p\">,</span>\n<span class=\"w\">      </span><span class=\"p\">.</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">unmarshaled_c</span><span class=\"p\">,</span>\n<span class=\"w\">      </span><span class=\"p\">.</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">unmarshaled_p</span><span class=\"p\">,</span>\n<span class=\"w\">      </span><span class=\"p\">.</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y_is_some</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">unmarshaled_y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nb\">NULL</span><span class=\"p\">,</span>\n<span class=\"w\">  </span><span class=\"p\">};</span>\n\n<span class=\"w\">  </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">unmarshaled_x</span><span class=\"p\">);</span>\n\n<span class=\"w\">  </span><span class=\"n\">free</span><span class=\"p\">(</span><span class=\"n\">unmarshaled_c</span><span class=\"p\">);</span>\n\n<span class=\"w\">  </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">lean_io_result_mk_ok</span><span class=\"p\">(</span><span class=\"n\">lean_box</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">));</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>(There surely is a bug in this somewhere, writing this by hand is quite tricky, hence why I am looking for an alternate solution.)</p>",
        "id": 396780175,
        "sender_full_name": "György Kurucz",
        "timestamp": 1697400274
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"651522\">@György Kurucz</span> In that case, I can say that this kind of thing is on the roadmap for Alloy. In fact, this discussion has given me a number of ideas, so it is likely on the near-term roadmap. That is, there was something I was already working on for Alloy, but this would be my next endeavor (and I switch to this sooner given some difficulties I am having with the current thing I was working on). However, when I will have time to work on this is different question that I do not know the answer for (given that Alloy is not one of things I am currently being paid to work on). Nonetheless, I do not expect it to be <em>too</em> far off in the future.</p>\n<p>Alloy also already has some tools for this. For example, there is the notion of a \"translator\" (<code>alloy c translator</code>) which registers <code>of_lean</code> and <code>to_lean</code> definitions for marshalling and unmarshalling a C type to and from Lean (which was inspired by <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span>'s work on <a href=\"https://github.com/hargoniX/socket.lean\">socket.lean</a>). However, what Alloy is missing is the metaprogramming utilities to automatically generate such definitions for a structure.</p>",
        "id": 396782997,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697403704
    },
    {
        "content": "<p>Also, with a smart generator it may also be possible follow the pattern of <code>Float</code> or <code>Array</code> in core to embedded the C pointer in the Lean structure without having to marshal and unmarshall every field eagerly.</p>",
        "id": 396783086,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697403836
    },
    {
        "content": "<p>Here is a rather long-winded example of what I mean by an optimized representation (and which could be  cleaned up and shorten with some polish, a Lean fix, and additional Alloy utilities):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Alloy.C</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Alloy.C</span>\n\n<span class=\"n\">alloy</span> <span class=\"n\">c</span> <span class=\"kn\">include</span> <span class=\"bp\">&lt;</span><span class=\"n\">lean</span><span class=\"bp\">/</span><span class=\"n\">lean.h</span><span class=\"bp\">&gt;</span>\n\n<span class=\"n\">alloy</span> <span class=\"n\">c</span> <span class=\"kn\">section</span>\n<span class=\"n\">typedef</span> <span class=\"n\">struct</span> <span class=\"o\">{</span>\n  <span class=\"n\">uint32_t</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">m</span><span class=\"bp\">;</span>\n<span class=\"o\">}</span> <span class=\"n\">Y</span><span class=\"bp\">;</span>\n\n<span class=\"n\">static</span> <span class=\"n\">lean_external_class</span> <span class=\"bp\">*</span> <span class=\"n\">g_class_raw_Y</span> <span class=\"bp\">=</span> <span class=\"n\">NULL</span><span class=\"bp\">;</span>\n\n<span class=\"n\">static</span> <span class=\"n\">inline</span> <span class=\"n\">void</span> <span class=\"n\">Y_finalize</span><span class=\"o\">(</span><span class=\"n\">void</span><span class=\"bp\">*</span> <span class=\"n\">ptr</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n  <span class=\"n\">free</span><span class=\"o\">((</span><span class=\"n\">Y</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"n\">ptr</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"n\">static</span> <span class=\"n\">inline</span> <span class=\"n\">void</span> <span class=\"n\">noop_foreach</span><span class=\"o\">(</span><span class=\"n\">void</span> <span class=\"bp\">*</span><span class=\"n\">mod</span><span class=\"o\">,</span> <span class=\"n\">b_lean_obj_arg</span> <span class=\"n\">fn</span><span class=\"o\">)</span> <span class=\"o\">{}</span>\n\n<span class=\"n\">static</span> <span class=\"n\">inline</span> <span class=\"n\">lean_obj_res</span> <span class=\"n\">Y_to_Lean</span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n  <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">g_class_raw_Y</span> <span class=\"bp\">==</span> <span class=\"n\">NULL</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">g_class_raw_Y</span> <span class=\"bp\">=</span> <span class=\"n\">lean_register_external_class</span><span class=\"o\">(</span><span class=\"n\">Y_finalize</span><span class=\"o\">,</span> <span class=\"n\">noop_foreach</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n  <span class=\"o\">}</span>\n  <span class=\"n\">return</span> <span class=\"n\">lean_alloc_external</span><span class=\"o\">(</span><span class=\"n\">g_class_raw_Y</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"n\">static</span> <span class=\"n\">inline</span> <span class=\"n\">Y</span><span class=\"bp\">*</span> <span class=\"n\">Y_of_lean</span><span class=\"o\">(</span><span class=\"n\">lean_obj_arg</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n  <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"bp\">*</span><span class=\"o\">)(</span><span class=\"n\">lean_get_external_data</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">))</span><span class=\"bp\">;</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">PureY</span> <span class=\"n\">where</span>\n  <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">UInt32</span>\n  <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">UInt32</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">RawY</span> <span class=\"n\">where</span>\n  <span class=\"n\">data</span> <span class=\"o\">:</span> <span class=\"n\">PureY</span>\n  <span class=\"c1\">-- make the structure non-trivial</span>\n  <span class=\"c1\">-- this is unsafe hack around lean4#2292 for testing purposes</span>\n  <span class=\"n\">unit</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span>\n\n<span class=\"n\">alloy</span> <span class=\"n\">c</span> <span class=\"n\">translator</span> <span class=\"n\">RawY</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">toLean</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">Y_to_Lean</span>\n  <span class=\"n\">ofLean</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">Y_of_lean</span>\n<span class=\"o\">}</span>\n\n<span class=\"n\">alloy</span> <span class=\"n\">c</span> <span class=\"kn\">section</span>\n<span class=\"n\">LEAN_EXPORT</span> <span class=\"n\">lean_obj_res</span> <span class=\"n\">raw_Y_mk</span><span class=\"o\">(</span><span class=\"n\">lean_obj_arg</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">lean_obj_arg</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n  <span class=\"n\">Y</span><span class=\"bp\">*</span> <span class=\"n\">rawY</span> <span class=\"bp\">=</span> <span class=\"n\">malloc</span><span class=\"o\">(</span><span class=\"n\">sizeof</span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"o\">))</span><span class=\"bp\">;</span>\n  <span class=\"n\">rawY</span><span class=\"bp\">-&gt;</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">lean_ctor_get_uint32</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n  <span class=\"n\">rawY</span><span class=\"bp\">-&gt;</span><span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">lean_ctor_get_uint32</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">sizeof</span><span class=\"o\">(</span><span class=\"n\">uint32_t</span><span class=\"o\">))</span><span class=\"bp\">;</span>\n  <span class=\"n\">return</span> <span class=\"n\">to_lean</span><span class=\"bp\">&lt;</span><span class=\"n\">RawY</span><span class=\"bp\">&gt;</span><span class=\"o\">(</span><span class=\"n\">rawY</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"n\">LEAN_EXPORT</span> <span class=\"n\">uint32_t</span> <span class=\"n\">raw_Y_n</span><span class=\"o\">(</span><span class=\"n\">lean_obj_arg</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n  <span class=\"n\">return</span> <span class=\"n\">of_lean</span><span class=\"bp\">&lt;</span><span class=\"n\">RawY</span><span class=\"bp\">&gt;</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">-&gt;</span><span class=\"n\">n</span><span class=\"bp\">;</span>\n<span class=\"o\">}</span>\n<span class=\"n\">LEAN_EXPORT</span> <span class=\"n\">uint32_t</span> <span class=\"n\">raw_Y_m</span><span class=\"o\">(</span><span class=\"n\">lean_obj_arg</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n  <span class=\"n\">return</span> <span class=\"n\">of_lean</span><span class=\"bp\">&lt;</span><span class=\"n\">RawY</span><span class=\"bp\">&gt;</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">-&gt;</span><span class=\"n\">m</span><span class=\"bp\">;</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">extern</span> <span class=\"s2\">\"raw_Y_mk\"</span><span class=\"o\">]</span> <span class=\"n\">RawY.mk</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">extern</span> <span class=\"s2\">\"raw_Y_n\"</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">RawY.n</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">RawY</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">y.data.n</span>\n<span class=\"kd\">@[</span><span class=\"n\">extern</span> <span class=\"s2\">\"raw_Y_m\"</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">RawY.m</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">RawY</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">y.data.m</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">RawY.dataImpl</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">RawY</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">PureY</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">y.n</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">y.m</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">RawY.dataImpl_eq_data</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">RawY</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">y.data</span> <span class=\"bp\">=</span> <span class=\"n\">y.dataImpl</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">implemented_by</span> <span class=\"n\">RawY.dataImpl</span><span class=\"o\">]</span> <span class=\"n\">RawY.data</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.compiler.ir.result</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">addRawY</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">RawY</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">y.n</span> <span class=\"bp\">+</span> <span class=\"n\">y.m</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.compiler.ir.result</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">addPureY</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">PureY</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">addRawY</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">y</span> <span class=\"o\">()</span> <span class=\"c1\">-- due to lean4#2292, will optimize away `mk` w/o Unit</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test'</span> <span class=\"o\">:=</span>\n  <span class=\"n\">addPureY</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 396788464,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697410392
    },
    {
        "content": "<p>It would be even better if the <code>LEAN_EXPORT</code> glue code can have a safe default implementation for most of the parameter and return value combinations of primitive types, the opaque types, the structure types (that can be accessed and proven but passes like the opaque types in and out of bindings).</p>",
        "id": 396808149,
        "sender_full_name": "Utensil Song",
        "timestamp": 1697423713
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"296911\">@Utensil Song</span> Yeah, the eventual goal would be to have Alloy generate all of this automatically.</p>",
        "id": 396812048,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697425874
    },
    {
        "content": "<p>Would alloy support the generated body containing C++ code? Is it belong to alloy or do you see it a potential project that builds on alloy? Is it technically compatible? I haven't figured out whether I can use Lean to generate C++ code yet.</p>",
        "id": 396812664,
        "sender_full_name": "Utensil Song",
        "timestamp": 1697426249
    },
    {
        "content": "<p>I did some experiments on parsing C++ headers using libclang (with Python), but it seems that I should use Lean to do it instead (except maybe I need to first bootstrap a Lean libclang binding with Python then all following work can be done in Lean).</p>",
        "id": 396813268,
        "sender_full_name": "Utensil Song",
        "timestamp": 1697426597
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"296911\">@Utensil Song</span> A C++ grammar DSL is in the roadmap for Alloy. But someone else may get to writing one  (i.e., a Lean C++ grammar) first.</p>",
        "id": 396814070,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697427007
    },
    {
        "content": "<p>My thought process is that is a good idea to stabilize all the features for C bindings before duplicating/generalizing them for C++.</p>",
        "id": 396814341,
        "sender_full_name": "Mac Malone",
        "timestamp": 1697427143
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac Malone</span> <a href=\"#narrow/stream/270676-lean4/topic/lake.3A.20generating.20FFI.20bindings/near/396814341\">said</a>:</p>\n<blockquote>\n<p>My thought process is that is a good idea to stabilize all the features for C bindings before duplicating/generalizing them for C++.</p>\n</blockquote>\n<p>Sure, this is a better and pragmatic approach.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac Malone</span> <a href=\"#narrow/stream/270676-lean4/topic/lake.3A.20generating.20FFI.20bindings/near/396814070\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> A C++ grammar DSL is in the roadmap for Alloy. But someone else may get to writing one  (i.e., a Lean C++ grammar) first.</p>\n</blockquote>\n<p>Nice, then I'll start experimenting the (quite small) subset I need (for bindings) with alloy.</p>\n<p>A full set is a completely different story and I can't imagine the use case yet (except for parsing the header, but most stuff in the body can be safely ignored for this purpose, there is only so much grammar on the data type and API surface).</p>",
        "id": 396816520,
        "sender_full_name": "Utensil Song",
        "timestamp": 1697428369
    },
    {
        "content": "<p>It turns out easier than I thought, here is the <a href=\"https://github.com/utensil/lean4-alloy/commit/2dcb4d0f885fd3f5556e81ad891454b7e4993bdf\">quick-and-dirty POC</a> that now builds with <code>lake -R build Test -v</code>, I added only <code>new</code>, <code>delete</code>, <code>extern \"C\"</code> and made a simple <code>alloy cpp extern </code>(sorry for the ad hoc intrusive modifications).</p>",
        "id": 396826783,
        "sender_full_name": "Utensil Song",
        "timestamp": 1697434828
    },
    {
        "content": "<blockquote>\n<p>A full set is a completely different story</p>\n</blockquote>\n<p>Yeah just fair warning the C++ grammar is Turing-complete, you probably don't want to implement the whole thing, just stick to a well-defined subset. (Though you might not be able to, e.g. if you want to bind some library that has non-trivial template metaprograms.)</p>",
        "id": 396898435,
        "sender_full_name": "György Kurucz",
        "timestamp": 1697461526
    },
    {
        "content": "<p>I have more thoughts on this <a href=\"https://github.com/utensil/ginac-lean/blob/main/doc/codegen.md\">here</a>.  In my imagination, the end-user code might look like this (conceptually, not necessarily syntactically):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">alloy</span> <span class=\"n\">cpp</span> <span class=\"kn\">section</span>\n\n<span class=\"k\">with</span> <span class=\"s2\">\"xyz\"</span>\n    <span class=\"k\">from</span> <span class=\"bp\">&lt;</span><span class=\"n\">string</span><span class=\"bp\">&gt;</span> <span class=\"kn\">import</span> <span class=\"n\">xyz.string</span> <span class=\"n\">as</span> <span class=\"n\">Xyz.String</span>\n    <span class=\"kn\">open</span> <span class=\"n\">Xyz</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">reverse</span> <span class=\"o\">(</span><span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">String.mk</span> <span class=\"n\">str</span>\n    <span class=\"n\">s.reverse</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>where <code>\"xyz\"</code> is the library name (and linkage), <code>&lt;xyz/string&gt;</code> is the header file, <code>xyz</code> is the namespace, <code>string</code> is the class name, <code>String</code> is the Lean type name, <code>reverse</code> is the method name, <code>s.reverse</code> is the call site where the end-user can be prompted by code completion to call non-existing Lean <code>String.reverse</code> then everything is automatically generated. When we finish the line, we have called into the C++ <code>xyz::string::reverse</code> method.</p>",
        "id": 396914174,
        "sender_full_name": "Utensil Song",
        "timestamp": 1697466056
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"651522\">György Kurucz</span> <a href=\"#narrow/stream/270676-lean4/topic/lake.3A.20generating.20FFI.20bindings/near/396898435\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>A full set is a completely different story</p>\n</blockquote>\n<p>Yeah just fair warning the C++ grammar is Turing-complete, you probably don't want to implement the whole thing, just stick to a well-defined subset. (Though you might not be able to, e.g. if you want to bind some library that has non-trivial template metaprograms.)</p>\n</blockquote>\n<p>Yes, I do have one <a href=\"https://github.com/sudgy/sga/blob/master/sga.hpp\">such header only library</a> in mind, which uses C++20 <code>concept</code>, <code>constexpr</code> etc. But I'm not touching it (from Lean) anytime soon.</p>",
        "id": 396915200,
        "sender_full_name": "Utensil Song",
        "timestamp": 1697466330
    },
    {
        "content": "<p>It seems to me that using alloy to create a binding still has much boilerplate, even compared to raw Lean FFI, compare <a href=\"https://github.com/utensil/lean4-alloy/commit/3811e54297d159e91e64e224b7f1447f1ebe8848\">my libclang binding POC using alloy</a> to the GiNaC binding POC( <a href=\"https://github.com/utensil/ginac-lean/blob/main/lean/Ginac/Symbol.lean\">lean part</a>, <a href=\"https://github.com/utensil/ginac-lean/blob/main/cpp/Symbol.cpp\">C++ part</a>, which follows EigenLean to use C++ template to abstract most of the boilerplate away, and this part is preferable to be done on the Lean side), significant amount of boilerplate have to be written for each type, a lot of the copy-paste of the types name are involved.</p>",
        "id": 397083122,
        "sender_full_name": "Utensil Song",
        "timestamp": 1697540351
    },
    {
        "content": "<p>For a binding, usually there would be dozens of types involved, naturally one wishes to treat the type opaque at first, with the least of hassles, then gradually add Lean-side fields to it, and these fields are not necessarily a 1:1 mapping of the corresponding C/C++ type, might be just a selected few of interested fields and some extra Prop fields. For now, alloy requires declaring the Lean type (e.g. <code>Index</code> in the libclang example) in C struct, which is the opposite of what I'm wishing for: I wish to omit writing the C struct completely, and declare everything in Lean.</p>",
        "id": 397086052,
        "sender_full_name": "Utensil Song",
        "timestamp": 1697541378
    },
    {
        "content": "<p>We want to improve the built-in FFI in the future. An issue collecting use cases, especially with comparisons to other tools and languages, would be very useful I think.</p>",
        "id": 397098493,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1697545920
    },
    {
        "content": "<p>Most of the improvements I mentioned can actually be implemented in alloy, the language capabilities are already there, one exception is <a href=\"https://github.com/leanprover/lean4/pull/2292\">lean4#2292</a> .</p>\n<p>Sorry if I sound a bit too critical in this, that's only because I'm seeing so much potential inspired by the code generation design of Lean and alloy, and I'm interested in making some of these changes happen if they are aligned with the roadmap because I need them and implementing them is a better use of time than work around them.</p>\n<p>My motivating libraries are:</p>\n<ul>\n<li>GiNaC, C++, for symbolic calculation</li>\n<li>Libclang, C, for generating C++ binding for GiNaC</li>\n</ul>\n<p>They both have massive API surface, and initial surveys show potential to make binding them in Lean more effective.</p>",
        "id": 397133456,
        "sender_full_name": "Utensil Song",
        "timestamp": 1697556309
    },
    {
        "content": "<p>FYI if anyone in this thread is interested, I just posted about my use-case that prompted my questions: <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general/topic/Lean.20Vulkan\">#general &gt; Lean Vulkan</a></p>",
        "id": 399462295,
        "sender_full_name": "György Kurucz",
        "timestamp": 1698745723
    }
]