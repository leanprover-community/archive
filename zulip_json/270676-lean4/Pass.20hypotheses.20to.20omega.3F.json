[
    {
        "content": "<p>Would it be possible to have <code>omega [h, ...]</code> as a shortcut for <code>have := h; ...; omega</code>?</p>\n<p>I frequently need to provide additional facts so that <code>omega</code> can finish a proof, like in the following simple example (where in the concrete case, <code>P = Nat.Prime</code>).</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">gt_one</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">gt_one</span><span class=\"w\"> </span><span class=\"c1\">-- without this, `omega` does not work</span>\n<span class=\"w\">  </span><span class=\"n\">omega</span><span class=\"w\"> </span><span class=\"c1\">-- `omega [h.gt_one]` gives an error</span>\n</code></pre></div>\n<p>I would much prefer the compact <code>omega [h.gt_one]</code> here.</p>",
        "id": 500867262,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1740054953
    },
    {
        "content": "<p>I get the draw of having terser syntax, but it does go against the idea that by having lots of smaller tactics, we can combine them to do what we want.</p>\n<ol>\n<li>\n<p>Why make <code>omega</code> more complicated? What does <code>omega [e]</code> do that <code>have := e; omega</code> cannot? It appears the only savings is 7 characters.</p>\n</li>\n<li>\n<p>Maybe there's something about <code>have</code> that's lacking. Do we want some sort of <code>have [...]</code> tactic that introduces expressions into the local context?</p>\n</li>\n</ol>\n<p>An issue I've run into with <code>have</code> before is that it wants to know the full type (you know, those \"cannot synthesize placeholder\" errors). If there were a convenient way to add facts to the local context despite this (like maybe those placeholders get universally quantified to make local theorems) that would be really nice.</p>\n<p>I think this is the only possible value proposition to adding it to <code>omega</code>, that it could be tolerant to placeholders, like <code>simp</code> and <code>rw</code>. (In fact, this is why I added bracket syntax to the <code>subsingleton</code> tactic.) However, if we had a generic such mechanism, then all tactics would benefit.</p>",
        "id": 500938615,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740074046
    },
    {
        "content": "<p>Is it really just to be terser? To me the draw is more about encapsulation, and that these kinds of things get added to the context strictly to get a tactic to make progress, but then they're noise in the local context afterwards, and when reading the proof it's not immediately clear why some random extra proof is there because it's just being used in a \"hidden\" way by a tactic which may not even be on the next line sometimes. Isn't it a somewhat general thing that often one wants to run a tactic with some extra stuff in its purview but while making it quite clear that the extra stuff is being added strictly for use with this tactic?</p>\n<p>E.g. (brainstorming uninformedly) isn't it <code>[...]</code> that seems a bit like it'd be nice to generalize so that it means \"locally give this tactic some more stuff to work with while it works\", and then <code>[foo, bar] -&gt; omega</code> and <code>[foo, bar] -&gt; simp</code> and other cases where there's something \"transient\" added just for a tactic to make more progress than it would automatically make end up looking like each other?</p>",
        "id": 500941563,
        "sender_full_name": "Julian Berman",
        "timestamp": 1740075014
    },
    {
        "content": "<p>Regarding \"after\", <code>omega</code> is a finishing tactic, so there's no cluttered local context to worry about there.</p>\n<p>I like the idea of a combinator like you're suggesting. Maybe <code>with [e1, e2] =&gt; tac</code> adds <code>e1</code> and <code>e2</code> to the local context, runs <code>tac</code>, and then clears them?</p>",
        "id": 500941986,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740075184
    },
    {
        "content": "<p>Yes I ignored the finishing tactic bit :) I assume the argument doesn't strictly rely on that fact so I made believe it wasn't one because I couldn't remember my own examples where I was annoyed by this where it wasn't a finishing tactic. (I guess a <code>have</code> that itself wanted to use <code>omega</code> where I put the temporary stuff in the surrounding proof or something).</p>",
        "id": 500942169,
        "sender_full_name": "Julian Berman",
        "timestamp": 1740075262
    },
    {
        "content": "<p>If there were a way to add a local hypothesis that's marked as \"tactics, please use this!\" that would be neat. Then you could write <code>with [e1, e2] =&gt; simp</code>  rather than <code>with [e1, e2] =&gt; simp [*]</code></p>",
        "id": 500942349,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740075327
    },
    {
        "content": "<p>Separately, it would also be nice if there were a way to get <code>have</code> to be OK with placeholders... Like, downgrading the error to a warning, turn the placeholders into new goals, and let us move on and later fill in what's missing.</p>",
        "id": 500942729,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740075472
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Pass.20hypotheses.20to.20omega.3F/near/500942729\">said</a>:</p>\n<blockquote>\n<p>Separately, it would also be nice if there were a way to get <code>have</code> to be OK with placeholders... Like, downgrading the error to a warning, turn the placeholders into new goals, and let us move on and later fill in what's missing.</p>\n</blockquote>\n<p>I believe <code>have'</code> is doing this</p>",
        "id": 500952541,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1740078913
    },
    {
        "content": "<p><code>omega</code> will be redundant in a few months, and <code>grind</code>, which will subsume it, already has this functionality.</p>",
        "id": 500954223,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1740079544
    },
    {
        "content": "<p>Will <code>grind</code> be similarly (oe even more) efficient on goals that <code>omega</code> solves?</p>",
        "id": 500954430,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1740079625
    },
    {
        "content": "<p>We expect so. It will implement the algorithm from \"Cutting to the chase\" <a href=\"https://leodemoura.github.io/files/cutsat-jar2013.pdf\">https://leodemoura.github.io/files/cutsat-jar2013.pdf</a>. In fact, not only should it be similarly performant, it will give counterexamples, actually be a complete algorithm (<code>omega</code> was only ever a partial implementation; the shadows part is not there), and allow for improvements like generating diverse models, which enables guessing relevant new identities.</p>",
        "id": 500955969,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1740080231
    },
    {
        "content": "<p>... plus tightly integrated into powerful congruence closure+ematching automation, all designed with Lean's type theory and typeclass system in mind.</p>",
        "id": 500956816,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1740080582
    }
]