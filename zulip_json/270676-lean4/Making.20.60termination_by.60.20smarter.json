[
    {
        "content": "<p>Hi, is there a way to make the termination tactics used by <code>termination_by</code> smarter in any way ? In the following example, the proof of termination gets stuck trying to prove that <code>sizeOf a &lt; 1 + sizeOf a</code>, despite it being provable by <code>simp_arith</code>with no issue. Is the system extensible in any way that would allow me to plug in <code>simp_arith</code> without having to write the <code>decreasing_by</code> myself ?<br>\ncode example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">ComplexInductive</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">constr</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">ComplexInductive</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">n</span>\n<span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">NestedComplex</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">constr</span> <span class=\"o\">:</span> <span class=\"n\">ComplexInductive</span> <span class=\"n\">Nat</span> <span class=\"n\">NestedComplex</span> <span class=\"n\">Nat</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">NestedComplex</span>\n\n<span class=\"kd\">mutual</span>\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">decEqNestedComplex</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">NestedComplex</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x₁</span> <span class=\"o\">:</span> <span class=\"n\">NestedComplex</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x₁</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x₁</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">NestedComplex.constr</span> <span class=\"n\">a</span> <span class=\"o\">,</span> <span class=\"n\">NestedComplex.constr</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">inst</span>  <span class=\"o\">:=</span> <span class=\"n\">decEqComplexInductiveNestedComplex</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"bp\">;</span> <span class=\"c1\">-- sizeOf a &lt; 1 + sizeOf a</span>\n    <span class=\"k\">if</span> <span class=\"n\">h</span>  <span class=\"o\">:</span> <span class=\"n\">a</span>  <span class=\"bp\">=</span> <span class=\"n\">b</span>  <span class=\"k\">then</span> <span class=\"kd\">by</span> <span class=\"n\">subst</span> <span class=\"n\">h</span> <span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">isTrue</span> <span class=\"n\">rfl</span>\n    <span class=\"k\">else</span> <span class=\"n\">isFalse</span>  <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">intro</span> <span class=\"n\">n</span> <span class=\"bp\">;</span> <span class=\"n\">injection</span> <span class=\"n\">n</span> <span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">h</span>  <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"o\">)</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">decEqComplexInductiveNestedComplex</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span>  <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span>  <span class=\"n\">C</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">x₂</span> <span class=\"o\">:</span> <span class=\"n\">ComplexInductive</span> <span class=\"n\">A</span> <span class=\"n\">NestedComplex</span> <span class=\"n\">C</span> <span class=\"n\">n₁</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">x₃</span> <span class=\"o\">:</span> <span class=\"n\">ComplexInductive</span> <span class=\"n\">A</span> <span class=\"n\">NestedComplex</span> <span class=\"n\">C</span> <span class=\"n\">n₁</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">x₂</span> <span class=\"bp\">=</span> <span class=\"n\">x₃</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">x₂</span><span class=\"o\">,</span> <span class=\"n\">x₃</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ComplexInductive.constr</span> <span class=\"n\">a₁</span> <span class=\"n\">a₂</span> <span class=\"n\">a₃</span><span class=\"o\">,</span> <span class=\"n\">ComplexInductive.constr</span> <span class=\"n\">b₁</span> <span class=\"n\">b₂</span> <span class=\"n\">b₃</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">a₁</span> <span class=\"bp\">=</span> <span class=\"n\">b₁</span> <span class=\"k\">then</span> <span class=\"kd\">by</span> <span class=\"n\">subst</span> <span class=\"n\">h₁</span><span class=\"bp\">;</span> <span class=\"n\">exact</span><span class=\"o\">(</span>\n        <span class=\"k\">let</span> <span class=\"n\">inst₁</span> <span class=\"o\">:=</span> <span class=\"n\">decEqNestedComplex</span>  <span class=\"n\">a₂</span> <span class=\"n\">b₂</span><span class=\"bp\">;</span>\n        <span class=\"k\">if</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">a₂</span> <span class=\"bp\">=</span> <span class=\"n\">b₂</span> <span class=\"k\">then</span> <span class=\"kd\">by</span> <span class=\"n\">subst</span> <span class=\"n\">h₂</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"o\">(</span>\n            <span class=\"k\">if</span> <span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"n\">a₃</span> <span class=\"bp\">=</span> <span class=\"n\">b₃</span> <span class=\"k\">then</span> <span class=\"kd\">by</span> <span class=\"n\">subst</span> <span class=\"n\">h₃</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">isTrue</span> <span class=\"n\">rfl</span>\n            <span class=\"k\">else</span> <span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">intro</span> <span class=\"n\">n₂</span><span class=\"bp\">;</span> <span class=\"n\">injection</span> <span class=\"n\">n₂</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">h₃</span> <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"o\">))</span>\n        <span class=\"k\">else</span> <span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">intro</span> <span class=\"n\">n₃</span><span class=\"bp\">;</span> <span class=\"n\">injection</span> <span class=\"n\">n₃</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">h₂</span> <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"o\">))</span>\n    <span class=\"k\">else</span> <span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">intro</span> <span class=\"n\">n₄</span><span class=\"bp\">;</span> <span class=\"n\">injection</span> <span class=\"n\">n₄</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">h₁</span> <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">decEqNestedComplex</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">x</span>\n               <span class=\"n\">decEqComplexInductiveNestedComplex</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 400108867,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1699008607
    },
    {
        "content": "<p>For context, I am trying to make <code>deriving</code> handlers manage nested inductive types, the last problem I'm encountering regards proving termination, and it would make the automation much easier if such \"easy\" goals could be proven automatically.</p>",
        "id": 400109048,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1699008677
    },
    {
        "content": "<p>Yes, the default <code>decreasing_by</code> is <code>decreasing_tactic</code> which is basically <code>decreasing_with decreasing_trivial</code> where <code>decreasing_trivial</code> is an extensible tactic, i.e. you can add lines like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">decreasing_trivial</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">do_smart_thing</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>to make it do some additional logic</p>",
        "id": 400112672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699010011
    },
    {
        "content": "<p>alternatively you can overload <code>decreasing_tactic</code> instead if you want to do something else for the preprocessor</p>",
        "id": 400112823,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699010071
    },
    {
        "content": "<p>I'm puzzled as to why this goal doesn't get solved then: in <code>Init.WFTactics</code>, there is clearly </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">decreasing_trivial</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">arith</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">failIfUnchanged</span> <span class=\"o\">:=</span> <span class=\"n\">false</span> <span class=\"o\">}))</span><span class=\"bp\">;</span> <span class=\"n\">done</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and this tactic apparently solves the goal in general:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">arith</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">failIfUnchanged</span> <span class=\"o\">:=</span> <span class=\"n\">false</span> <span class=\"o\">})</span>\n</code></pre></div>\n<p>Yet the goal in my example above doesn't pass.</p>",
        "id": 400113072,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1699010175
    },
    {
        "content": "<p>If you inline the tactic definitions you get a better error message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">decreasing_by</span>\n  <span class=\"n\">simp_wf</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Prod.Lex.right</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Prod.Lex.left</span><span class=\"o\">)</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">PSigma.Lex.right</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">PSigma.Lex.left</span><span class=\"o\">)</span>\n  <span class=\"n\">first</span>\n  <span class=\"bp\">|</span> <span class=\"n\">done</span>\n  <span class=\"bp\">|</span> <span class=\"n\">subst_vars</span>\n    <span class=\"n\">decreasing_trivial</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">synthesized</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">definitionally</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"n\">expression</span> <span class=\"n\">inferred</span> <span class=\"kd\">by</span> <span class=\"n\">typing</span> <span class=\"n\">rules</span><span class=\"o\">,</span> <span class=\"n\">synthesized</span>\n  <span class=\"n\">ComplexInductive._sizeOf_inst</span> <span class=\"n\">Nat</span> <span class=\"n\">NestedComplex</span> <span class=\"n\">Nat</span> <span class=\"mi\">1</span>\n<span class=\"n\">inferred</span>\n  <span class=\"n\">ComplexInductive._sizeOf_inst</span> <span class=\"n\">Nat</span> <span class=\"n\">NestedComplex</span> <span class=\"n\">Nat</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 400114631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699010896
    },
    {
        "content": "<p>that last bit is a bit ambiguous though, with pp.all it is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">synthesized</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">definitionally</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"n\">expression</span> <span class=\"n\">inferred</span> <span class=\"kd\">by</span> <span class=\"n\">typing</span> <span class=\"n\">rules</span><span class=\"o\">,</span> <span class=\"n\">synthesized</span>\n  <span class=\"bp\">@</span><span class=\"n\">ComplexInductive._sizeOf_inst</span> <span class=\"n\">Nat</span> <span class=\"n\">NestedComplex</span> <span class=\"n\">Nat</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">OfNat.ofNat.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">instOfNatNat</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">instSizeOfNat</span>\n    <span class=\"n\">NestedComplex._sizeOf_inst</span> <span class=\"n\">instSizeOfNat</span>\n<span class=\"n\">inferred</span>\n  <span class=\"bp\">@</span><span class=\"n\">ComplexInductive._sizeOf_inst</span> <span class=\"n\">Nat</span> <span class=\"n\">NestedComplex</span> <span class=\"n\">Nat</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">OfNat.ofNat.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">instOfNatNat</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">instSizeOf.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n    <span class=\"n\">NestedComplex._sizeOf_inst</span> <span class=\"o\">(</span><span class=\"n\">instSizeOf.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 400114872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699011006
    },
    {
        "content": "<p>and the difference between <code>instSizeOfNat</code> and <code>instSizeOf.{1} Nat</code> is mathematically meaningful: <code>instSizeOfNat</code> is the identity function and <code>instSizeOf.{1} Nat</code> is <code>fun _ =&gt; 0</code></p>",
        "id": 400114937,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699011048
    },
    {
        "content": "<p>Well, actually that is an error message from the wrong <code>decreasing_trivial</code> branch; but replacing <code>decreasing_trivial</code> with <code>(simp (config := { arith := true, failIfUnchanged := false })); done</code> reveals that it also doesn't prove the goal, for much the same reason: the goal is <code>sizeOf a &lt; 1 + sizeOf a</code> where the two occurrences of <code>sizeOf</code> are using different <code>SizeOf Nat</code> instances</p>",
        "id": 400115905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699011457
    },
    {
        "content": "<p>If you use <code>Nat</code> instead of <code>A</code> and <code>C</code> in the mutual def it works without modifying the decreasing tactic</p>",
        "id": 400116437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699011664
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Making.20.60termination_by.60.20smarter/near/400112672\">said</a>:</p>\n<blockquote>\n<p>Yes, the default <code>decreasing_by</code> is <code>decreasing_tactic</code> which is basically <code>decreasing_with decreasing_trivial</code> where <code>decreasing_trivial</code> is an extensible tactic, i.e. you can add lines like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">decreasing_trivial</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">do_smart_thing</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>to make it do some additional logic</p>\n</blockquote>\n<p>How can I tell by looking at that line that I'm extending the tactic and not replacing it?</p>",
        "id": 400116632,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699011747
    },
    {
        "content": "<p>when a tactic has multiple <code>macro_rules</code> or <code>elab_rules</code> declarations for the same syntax, it will try all of them</p>",
        "id": 400116789,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699011815
    },
    {
        "content": "<p>when you use <code>macro</code> or <code>elab</code>, this creates a new <code>syntax</code> in addition to defining a <code>macro_rules</code> / <code>elab_rules</code> for it, so it will be replacing or overloading any existing syntax of the same shape</p>",
        "id": 400116994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699011885
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Making.20.60termination_by.60.20smarter/near/400116789\">said</a>:</p>\n<blockquote>\n<p>when a tactic has multiple <code>macro_rules</code> or <code>elab_rules</code> declarations for the same syntax, it will try all of them</p>\n</blockquote>\n<p>I thought it tried all of them until it finds one that is matching syntax. Are you saying it tries all of them until the tactic succeeds?</p>",
        "id": 400183676,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699034796
    },
    {
        "content": "<p>They are keyed by the syntax. It tries all rules for the syntax that was parsed</p>",
        "id": 400192636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699038850
    }
]