[
    {
        "content": "<p>It feels like we're getting a lot of questions by people who are (reasonably) confused about their wfrec definitions being silently marked as <code>irreducible</code>. Would it be better to require that every wfrec definition has an explicit <code>@[irreducible]</code> annotation (or <code>@[semireducible]</code>, <code>@[reducible]</code>, <code>abbrev</code> to override the default)? This way the error message for a wfrec definition with no annotation could explain the situation.</p>",
        "id": 450717917,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1720706396
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span></p>",
        "id": 450718008,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1720706407
    },
    {
        "content": "<p>That sounds like a very big hammer, and quite annoying. </p>\n<p>Do you have a sense of whether most questions are by people upgrading their code and who have previously relied on the semireducibility of the wf construction (in which case the confusion might get less over time), or also users without much prior expectation?</p>",
        "id": 450718646,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1720706567
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/Should.20wfrec.20defs.20require.20an.20.40.5Birreducible.5D.20annotation.3F/near/450718646\">said</a>:</p>\n<blockquote>\n<p>That sounds like a very big hammer, and quite annoying. </p>\n<p>Do you have a sense of whether most questions are by people upgrading their code and who have previously relied on the semireducibility of the wf construction (in which case the confusion might get less over time), or also users without much prior expectation?</p>\n</blockquote>\n<p>Seconded. I think if people want wf rec functions to be reducible, it should be their call.</p>",
        "id": 450719810,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1720706905
    },
    {
        "content": "<p>Ideally this should be a config option one can set at a file level or a project level.</p>",
        "id": 450720098,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1720706987
    },
    {
        "content": "<p>But I don't know where this default should be instantiated. Should the tactic monads handle this issue automatically (which means they look at lakefiles ), or should it be the tactic implementers job to get this config information.</p>",
        "id": 450720460,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1720707066
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/Should.20wfrec.20defs.20require.20an.20.40.5Birreducible.5D.20annotation.3F/near/450718646\">said</a>:</p>\n<blockquote>\n<p>Do you have a sense of whether most questions are by people upgrading their code and who have previously relied on the semireducibility of the wf construction (in which case the confusion might get less over time), or also users without much prior expectation?</p>\n</blockquote>\n<p>A mix of both I think. Certainly a bunch of new users. It doesn't help that at least FPIL and the Lean manual haven't yet been updated to reflect the new behaviour.</p>\n<p>But even with these doc updates, I would argue that forcing an annotation would be good language design. A definition that doesn't reduce by default is very surprising, both from a general type theory perspective (where we rely on implicit computation all the time) and in comparison with any other DTT system I know of. It's even more surprising when the definition reduces in some contexts but not others (cf <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4/topic/Why.20can.27t.20reduce.3F\">#lean4 &gt; Why can't reduce?</a>).</p>",
        "id": 450720817,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1720707154
    },
    {
        "content": "<p>A wfrec definition reducing is the surprising result. It is the only place in Lean where we have to reduce proofs. And because of that, it can get stuck for various reasons, in completely inscrutable ways for the user. Irreducibility is the only robust default for wfrec, and the robust way to reason about them is via their equation theorems.</p>",
        "id": 450721484,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1720707317
    },
    {
        "content": "<p>And there is a \"choose one\" dilemma between reducing as many wfrecs as possible and not importing proofs, which will be necessary to further scale big libraries in Lean in CPU, memory, and disk space</p>",
        "id": 450721856,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1720707419
    },
    {
        "content": "<p>Hmm, I see the issue, but I’m doubtful that forcing everyone to write something here is the right approach. It’s ugly (subjective aesthetics, I know), it’s requires a fair amount of technical expertise to make the right call here, and thus adds additional burden to every users, even those who don’t care (yet) about this distinction.</p>\n<p>I’d expect that there is a fair fraction of users who are perfectly happy to use <code>simp</code> and <code>rw</code> in their proofs and shouldn’t be bothered about reducibility.</p>\n<p>If anything, I could imagine requiring an explicit opt-in to well-founded recursion in the first place – this would provide some syntax that one can hover about and learn more, including the various pitfalls of well-founded recursion.</p>",
        "id": 450722160,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1720707489
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/Should.20wfrec.20defs.20require.20an.20.40.5Birreducible.5D.20annotation.3F/near/450721484\">said</a>:</p>\n<blockquote>\n<p>A wfrec definition reducing is the surprising result. It is the only place in Lean where we have to reduce proofs. And because of that, it can get stuck for various reasons, in completely inscrutable ways for the user. Irreducibility is the only robust default for wfrec, and the robust way to reason about them is via their equation theorems.</p>\n</blockquote>\n<p>I'm not arguing against any of this. I'm just saying that new users (and perhaps some old users) have no idea about any of this proof reduction business. So to them, the fact that <code>termination_by</code> makes your function irreducible is surprising.</p>",
        "id": 450723306,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1720707769
    },
    {
        "content": "<p>(Or, worse, even without <code>termination_by</code> if the default termination tactics do their job.)</p>",
        "id": 450724770,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1720708180
    },
    {
        "content": "<p>Perhaps we could address this with a linter that recommends adding the <code>@[irreducible]</code> explicitly?</p>",
        "id": 450724923,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720708214
    },
    {
        "content": "<p>(as opposed to actually making it required)</p>",
        "id": 450724959,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720708225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/Should.20wfrec.20defs.20require.20an.20.40.5Birreducible.5D.20annotation.3F/near/450722160\">said</a>:</p>\n<blockquote>\n<p>I’d expect that there is a fair fraction of users who are perfectly happy to use <code>simp</code> and <code>rw</code> in their proofs and shouldn’t be bothered about reducibility.</p>\n</blockquote>\n<p>I don't think you can hide the complexity for long. Some silly examples:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"c1\">-- works, special support I guess</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- fails</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- fails</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>",
        "id": 450725388,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1720708331
    },
    {
        "content": "<p>The linter is a good idea I think.</p>",
        "id": 450725514,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1720708365
    },
    {
        "content": "<p>That the first <code>rfl</code> works is in my opinion a bug (it ignores the current transparency setting in some cases) with a proposed fix in <a href=\"https://github.com/leanprover/lean4/pull/3772\">https://github.com/leanprover/lean4/pull/3772</a></p>",
        "id": 450730337,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1720709441
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/270676-lean4/topic/Should.20wfrec.20defs.20require.20an.20.40.5Birreducible.5D.20annotation.3F/near/450723306\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/Should.20wfrec.20defs.20require.20an.20.40.5Birreducible.5D.20annotation.3F/near/450721484\">said</a>:</p>\n<blockquote>\n<p>A wfrec definition reducing is the surprising result. It is the only place in Lean where we have to reduce proofs. And because of that, it can get stuck for various reasons, in completely inscrutable ways for the user. Irreducibility is the only robust default for wfrec, and the robust way to reason about them is via their equation theorems.</p>\n</blockquote>\n<p>I'm not arguing against any of this. I'm just saying that new users (and perhaps some old users) have no idea about any of this proof reduction business. So to them, the fact that <code>termination_by</code> makes your function irreducible is surprising.</p>\n</blockquote>\n<p>But consider also that both Lean and the whole field of DTT are slowly moving away from making reducible the default. Gratzer et al first discussed this in Controlling Unfolding in Type Theory, then implemented in various ways in various systems. Lean now has seal/unseal. We are not going to prevent people from making something reducible if they really want to but like with proofs, reducibility for everything, all the time, turns out not to be a great default if you also want scalability, modularity, and robustness. So expectations may shift in the future.</p>",
        "id": 450739796,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1720711257
    },
    {
        "content": "<p>I don't disagree with this direction, but Lean is currently very happy to implicitly reduce almost every definition. Wfrec is the odd one out. So unless you have plans to make everything irreducible by default in the near future, you will have confused users.</p>",
        "id": 450751296,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1720714420
    },
    {
        "content": "<p>If there is a missing linter here (but I don't think there is!) it is one checking (how?) for useful rewriting lemmas after the definition, not for enforcing a redundant annotation.</p>",
        "id": 450754894,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1720715198
    },
    {
        "content": "<p>Maybe this belongs on the type theory channel, not sure, but why is unfolding proofs tricky?</p>",
        "id": 450755941,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1720715436
    },
    {
        "content": "<p>To add to the question, is the trickiness limited to pathological examples, or is it a major practical headache?</p>",
        "id": 450756443,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1720715595
    },
    {
        "content": "<p>A third question: when is it safe to use unseal?</p>",
        "id": 450757595,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1720716005
    },
    {
        "content": "<p>Is it okay to use it on an API lemma for a definition, while increasingly unsafe for definitions which are more downstream?</p>",
        "id": 450757698,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1720716050
    },
    {
        "content": "<p>Acc.rec reduction in Lean 3 was really hit-or-miss, and then in 2021 it was disabled completely: <a href=\"https://github.com/leanprover-community/lean/pull/562\">https://github.com/leanprover-community/lean/pull/562</a></p>",
        "id": 450767525,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720719030
    },
    {
        "content": "<p>It could be feasible to have an error message on type mismatch errors that explains which definitions it ran into that were irreducible, explains why they might be, suggests using tactics, and explains, as a last resort that <code>unseal</code> exists.</p>",
        "id": 450769240,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720719617
    }
]