[
    {
        "content": "<p>I'm confused about the interaction between @ and explicitly supplying inputs with the <code>(A := B)</code> syntax. variables. Of course one might argue that these are two different ways to solve the same problem, so one should not use both. Apologies also for not minimising to be mathlib-free -- I suspect my confusion might partially stem from the fact that the typeclasses I'm using extend other typeclasses etc. Here's some code.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Topology</span><span class=\"bp\">.</span><span class=\"n\">Homeomorph</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">ehomeo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">≃ₜ</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">elinear</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"n\">he</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">ehomeo</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">elinear</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">τR</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">τA</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">τB</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">ehomeo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">≃ₜ</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">elinear</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">he</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">ehomeo</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">elinear</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">}</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ehomeo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ehomeo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elinear</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">elinear</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">τR</span><span class=\"w\"> </span><span class=\"n\">he</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ehomeo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ehomeo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elinear</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">elinear</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">τR</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">he</span>\n</code></pre></div>\n<p>The bottom line is that both of these compile which surprises me, because they seem to have a different number of inputs. My issue is that I can't work out what Lean is expecting from that <code>_</code> in the final example (and I conjecture that it won't be happy with any input).</p>\n<p>In the first example, the two inputs <code>τR</code> and <code>he</code> are not even consecutive inputs to <code>foo</code>; they seem to be the two inputs which cannot be solved by either instance synthesis or unification. I conclude from this that <code>@foo (X := bar) (Y := baz)</code> currently means \"fill in all the holes which you can, using any method you can, and ask the user for the ones you're stuck on\" which to be honest is probably quite a good interpretation.</p>\n<p>The second example I am completely stumped by. I conjecture that the underscore is impossible to fill in. Lean seems to claim that its type is <code>2 + 2 = 4</code> if you click just before the <code>_</code> and look in the infoview to see the expected type. But if I try to fill in the hole then Lean complains whatever I try. Can someone else do better?</p>\n<p>The answer to this might just be \"don't use @foo (A := bar)\" but I was wondering if experts could clarify what's going on in the second example.</p>\n<p>To un-#xy: I'm writing some code where there is more than topological space instance on a type so I need to use <code>@</code>s to stop instance synthesis errors. I wanted to use <code>(A := B)</code> to minimise the amount of <code>_</code> I had to write, but then when the variable change hit the FLT project some proofs broke (this was expected) and it was when fixing them that I ran into this issue: I was trying to add underscores to figure out what was going on, and was getting very counterintuitive (to me) behaviour.</p>",
        "id": 468564862,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725801453
    },
    {
        "content": "<p>It's interesting to note that <code>example : 2 + 2 = 4 := @foo (ehomeo := ehomeo) (elinear := elinear) τR _ _ _ _ _ _ _ he</code> also works, but adding any more <code>_</code> it fails</p>",
        "id": 468572708,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725804078
    },
    {
        "content": "<p>Yeah and in my actual application it was really hard to work out which of the <code>_</code>s I wanted to fill in manually because they didn't seem to be showing the right types.</p>",
        "id": 468573780,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725804474
    },
    {
        "content": "<p>A quick first observation: hovering over the <code>_</code> in the second example shows only the text \"A placeholder term, to be synthesized by unification.\" Normally, it would show more information like in</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n</code></pre></div>\n<p>where the hover for <code>_</code> also has <code>Nat : Type</code>. The lack of a type indicates that <code>_</code> is not even being elaborated — somehow it's being skipped.</p>",
        "id": 468600053,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725814690
    },
    {
        "content": "<p>Never mind about that evidence. That could be from a small bug where the elaborator doesn't register any info for the <code>_</code> if it's an instance implicit argument. In the following, the first <code>_</code> has type information and the second doesn't.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">ite</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n</code></pre></div>",
        "id": 468601501,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725815287
    },
    {
        "content": "<p>Regarding named arguments and <code>@</code>, something I didn't know is that a certain named argument feature is activated even in explicit mode. Namely, for each named argument, every argument the named argument depends on becomes implicit. It's a bit odd that this is used by explicit mode as well.</p>",
        "id": 468602390,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725815767
    },
    {
        "content": "<p>Assuming that should be the way it works, then one surprise with the example is that the <code>[TopologicalSpace A]</code> argument needs to be supplied at all.</p>",
        "id": 468602642,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725815915
    },
    {
        "content": "<p>Got to the bottom of it in <a href=\"https://github.com/leanprover/lean4/pull/5283\">lean4#5283</a> <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>.</p>\n<p>I'm still not sure what the correct solution is — my first reaction would be that named arguments shouldn't affect which arguments are implicit when in <code>@</code> mode — but it looks like you're profitably using the feature to avoid needing to supply redundant <code>_</code>s. Do you find it easy to predict which arguments need to be supplied? Do you just look at the type errors to work out what the next argument is?</p>",
        "id": 468610490,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725820366
    },
    {
        "content": "<p>A workaround for now is to write <code>(_)</code> or <code>inferInstance</code> (whichever is appropriate) rather than <code>_</code> when you are using <code>@</code> and named arguments together.</p>",
        "id": 468612838,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725821578
    },
    {
        "content": "<p>IMO there should not be any implicitification in this situation, it should only remove the named argument from the list and leave the others as is</p>",
        "id": 468620687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1725825762
    },
    {
        "content": "<p>\"this situation\" being \"explicit mode\" or something else?</p>",
        "id": 468621308,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725826043
    },
    {
        "content": "<p>Mario: Yes this is what I was expecting ((A := x) removes precisely one hole) and I was surprised and pleased that in fact it was doing something more clever because this worked well for my use case. Kyle -- thanks! Yes I was just using the type errors to work out what was going on, and when my code broke because of <code>variable</code> changes was when I realised that this was not behaving as I expected.</p>",
        "id": 468621490,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725826115
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> \"this situation\" meaning when there is a <code>@</code> enabling explicit mode, having named parameters re-impliciting things is not good as it defeats the purpose of the <code>@</code> - what if you still want to give the missing argument, and can't or don't want to use named parameters?</p>",
        "id": 468626103,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1725829221
    },
    {
        "content": "<p>Yeah, I agree, I just wanted to make sure there wasn't something else you could mean.</p>\n<p>My approach with this PR is to be conservative and make the current behavior work correctly, but even though Kevin's example is an interesting application of this named argument feature, it seems like an oversight. (My feeling is that this named argument feature needs to be reworked. The main application seems to be to make dot notation work better, and it might be better only being enabled for dot notation.)</p>",
        "id": 468626953,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725829517
    },
    {
        "content": "<p>Perhaps worth remarking here that in my work on topologies for modules, my API lemmas have named variables for  topology instances, meaning that I can use <code>foo (inst_2 := myTopology_not_the_synthesized_one)</code></p>",
        "id": 468644830,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725841392
    },
    {
        "content": "<p>(in fact they're called <code>[τR: TopologicalSpace R]</code> etc)</p>",
        "id": 468644888,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725841435
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/5386\">lean4#5386</a> is an RFC for disabling this feature that causes named arguments to suppress parameters it depends on while in explicit mode.</p>\n<p>We decided it would be best to go through the RFC process to document the potential change to elaboration.</p>",
        "id": 471348069,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1726693380
    },
    {
        "content": "<p>Many thanks for such a detailed explanation and analysis!</p>",
        "id": 471360716,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1726699326
    },
    {
        "content": "<p>This behavior is a special case of <a href=\"https://github.com/leanprover/lean4/pull/1867\">lean4#1867</a>. I would <a href=\"#narrow/stream/270676-lean4/topic/named.20arguments.20of.20dependent.20functions/near/463694160\">strongly prefer</a> to just remove argument suppression via named arguments in general, not just in explicit mode.</p>\n<p>You claim that this feature \"make[s] projection notation more convenient.\" Can you elaborate on that? I don't see it. Do you have a compelling example where you have a projection where</p>\n<ul>\n<li>it is convenient to have a dependent argument suppressed in projection notation;</li>\n<li>you do want to have the dependent argument explicit when not using projection notation?</li>\n</ul>\n<p>Even if this is more convenient in some cases, I don't think this obscure edge case warrants the confusion it repeatedly causes.</p>",
        "id": 471429168,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1726733274
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> Thanks for pushing back on that claim. What do you think about instead if projection notation suppresses structure parameters only? I believe this is the motivation for the feature in the first place, to make projection notation not be sensitive to details about which structure parameters are implicit/explicit. This would be like how Lean 3 worked, if I remember correctly (in particular, <code>x.f</code> with no additional arguments would do <code>@X.f _ ... _ x</code> with one placeholder per structure parameter).</p>",
        "id": 471446304,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1726738630
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/.40foo.20.28A.20.3A.3D.20bar.29.20_.20_/near/471446304\">said</a>:</p>\n<blockquote>\n<p>What do you think about instead if projection notation suppresses structure parameters only? </p>\n</blockquote>\n<p>I can live with that, but I'm worried that this will still lead to confusion. <br>\nI do now see the rationale for it: the projections of a class should have the parameters explicit (since you're not typically giving the class instance), but when using projection notation you are giving the class explicit, so the parameters can be implicit.</p>\n<p>Personally, I would prefer requiring the superfluous underscores even with the projection notation, since that would simplify the behavior of Lean's elaborator. The user can still avoid the underscores by making an alias of the projection with an implicit argument. We're using these aliases that only differ by argument explicitness regularly.</p>",
        "id": 471487970,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1726752830
    },
    {
        "content": "<p>A new day, a new RFC: <a href=\"https://github.com/leanprover/lean4/pull/5397\">lean4#5397</a></p>\n<p>This is for making the feature only apply to structure parameters in instance projections.</p>",
        "id": 471537535,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1726768564
    }
]