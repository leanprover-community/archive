[
    {
        "content": "<p>Is this the right syntax for breaking out the sub-parts of the existential?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fn</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n  <span class=\"mi\">123</span>\n</code></pre></div>\n<p>it gives an error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic</span> <span class=\"bp\">'</span><span class=\"n\">cases'</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">nested</span> <span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">tactic</span> <span class=\"bp\">'</span><span class=\"n\">induction'</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">recursor</span> <span class=\"bp\">'</span><span class=\"n\">Exists.casesOn'</span> <span class=\"n\">can</span> <span class=\"n\">only</span> <span class=\"n\">eliminate</span> <span class=\"n\">into</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"bp\">?</span><span class=\"n\">u.1347</span>\n<span class=\"n\">h_1</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"n\">h</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">motive</span> <span class=\"n\">h</span><span class=\"bp\">✝</span> <span class=\"n\">after</span> <span class=\"n\">processing</span>\n  <span class=\"n\">_</span>\n<span class=\"n\">the</span> <span class=\"n\">dependent</span> <span class=\"n\">pattern</span> <span class=\"n\">matcher</span> <span class=\"n\">can</span> <span class=\"n\">solve</span> <span class=\"n\">the</span> <span class=\"n\">following</span> <span class=\"n\">kinds</span> <span class=\"n\">of</span> <span class=\"n\">equations</span>\n<span class=\"bp\">-</span> <span class=\"bp\">&lt;</span><span class=\"n\">var</span><span class=\"bp\">&gt;</span> <span class=\"bp\">=</span> <span class=\"bp\">&lt;</span><span class=\"n\">term</span><span class=\"bp\">&gt;</span> <span class=\"n\">and</span> <span class=\"bp\">&lt;</span><span class=\"n\">term</span><span class=\"bp\">&gt;</span> <span class=\"bp\">=</span> <span class=\"bp\">&lt;</span><span class=\"n\">var</span><span class=\"bp\">&gt;</span>\n<span class=\"bp\">-</span> <span class=\"bp\">&lt;</span><span class=\"n\">term</span><span class=\"bp\">&gt;</span> <span class=\"bp\">=</span> <span class=\"bp\">&lt;</span><span class=\"n\">term</span><span class=\"bp\">&gt;</span> <span class=\"n\">where</span> <span class=\"n\">the</span> <span class=\"n\">terms</span> <span class=\"n\">are</span> <span class=\"n\">definitionally</span> <span class=\"n\">equal</span>\n<span class=\"bp\">-</span> <span class=\"bp\">&lt;</span><span class=\"n\">constructor</span><span class=\"bp\">&gt;</span> <span class=\"bp\">=</span> <span class=\"bp\">&lt;</span><span class=\"n\">constructor</span><span class=\"bp\">&gt;</span><span class=\"o\">,</span> <span class=\"n\">examples</span><span class=\"o\">:</span> <span class=\"n\">List.cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">=</span> <span class=\"n\">List.cons</span> <span class=\"n\">y</span> <span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">and</span> <span class=\"n\">List.cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">=</span> <span class=\"n\">List.nil</span>\n</code></pre></div>",
        "id": 338434390,
        "sender_full_name": "Mark Wilhelm",
        "timestamp": 1677526996
    },
    {
        "content": "<p>Not in a <code>def</code></p>",
        "id": 338434709,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1677527072
    },
    {
        "content": "<p>That would allow you to extract a witness, which would cause trouble</p>",
        "id": 338434878,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1677527126
    },
    {
        "content": "<p>hm ok, so you can only do that in tactics then or something?</p>",
        "id": 338435188,
        "sender_full_name": "Mark Wilhelm",
        "timestamp": 1677527214
    },
    {
        "content": "<p>You could do it in a theorem</p>",
        "id": 338435341,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1677527262
    },
    {
        "content": "<p>ah ok that is what i need here, theorem instead of function, thank you</p>",
        "id": 338435614,
        "sender_full_name": "Mark Wilhelm",
        "timestamp": 1677527328
    },
    {
        "content": "<p>You can use <code>classical.some</code> but then your definition would be noncomputable</p>",
        "id": 338465059,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1677537895
    },
    {
        "content": "<p>Note that the error you get is <code>recursor 'Exists.casesOn' can only eliminate into Prop</code>; your syntax is totally fine, but the type theory says \"you can't produce data (aka not <code>Prop</code>) by taking apart an <code>Exists</code>\".</p>",
        "id": 338465411,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677538078
    },
    {
        "content": "<p>I think you want <code>Subtype</code></p>",
        "id": 338495158,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1677555839
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I'm getting the same error when trying to follow <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span>'s suggestion of moving <a href=\"https://github.com/leanprover-community/mathlib4/pull/6648\">#6648</a> to <code>GroupTheory.OrderOfElement</code>. But in defining the inverse I really need the <code>n</code> from the <code>((isOfFinOrder_iff_pow_eq_one x).1 hx) : ∃ n, 0 &lt; n ∧ x ^ n = 1</code>. Is there a way I can preserve computability?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">IsOfFinOrder.groupPowers</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">IsOfFinOrder</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">Submonoid.powers</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">inv</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">isOfFinOrder_iff_pow_eq_one</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hx</span><span class=\"o\">)</span>\n    <span class=\"n\">exact</span> <span class=\"n\">z</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 387027650,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692868661
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"598052\">@Jeremy Tan</span> don't worry about computability, we're doing classical maths. E.g., use <code>Classical.choose</code> if you need it.</p>",
        "id": 387028811,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1692868965
    },
    {
        "content": "<p>But then I'm getting another headache.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Submonoid</span> <span class=\"k\">in</span>\n<span class=\"sd\">/-- The submonoid generated by an element is a group if that element has finite order. -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"n\">abbrev</span> <span class=\"n\">IsOfFinOrder.groupPowers</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">IsOfFinOrder</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">inv</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">z</span> <span class=\"bp\">^</span> <span class=\"o\">(((</span><span class=\"n\">isOfFinOrder_iff_pow_eq_one</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"n\">mul_left_inv</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">Subtype.ext</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">y</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">coe_one</span><span class=\"o\">,</span> <span class=\"n\">coe_mul</span><span class=\"o\">,</span> <span class=\"n\">SubmonoidClass.coe_pow</span><span class=\"o\">]</span>\n    <span class=\"c1\">-- here</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">_root_.pow_succ'</span><span class=\"o\">,</span> <span class=\"n\">Nat.sub_add_cancel</span> <span class=\"n\">hpos</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">pow_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">pow_mul</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">one_pow</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>The goal state at the comment is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span>\n<span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span>\n<span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_4</span>\n<span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_5</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">:</span> <span class=\"n\">Monoid</span> <span class=\"n\">G</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">AddMonoid</span> <span class=\"n\">A</span>\n<span class=\"n\">xy</span><span class=\"o\">:</span> <span class=\"n\">G</span>\n<span class=\"n\">ab</span><span class=\"o\">:</span> <span class=\"n\">A</span>\n<span class=\"n\">nm</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">hx</span><span class=\"o\">:</span> <span class=\"n\">IsOfFinOrder</span> <span class=\"n\">x</span>\n<span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">Exists.choose</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>I want to ensure that the noncomputably-chosen <code>n</code> in the <code>inv</code> field is the <em>same</em> as the result of the <code>Exists.choose</code> in this goal. How would that go?</p>",
        "id": 387031740,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692869957
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> I'm really feeling that even with classical logic porting the abbrev to <code>GroupTheory.OrderOfElement</code> is simply impossible</p>",
        "id": 387032879,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692870340
    },
    {
        "content": "<p>Don't use <code>obtain</code>, just apply <code>Exists.choose</code> and <code>Exists.choose_spec</code> directly</p>",
        "id": 387033135,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1692870415
    },
    {
        "content": "<p>actually maybe it's fine, but you are missing <code>((isOfFinOrder_iff_pow_eq_one x).1 hx).choose_spec</code> in the proof</p>",
        "id": 387033431,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1692870498
    },
    {
        "content": "<blockquote>\n<p>I want to ensure that the noncomputably-chosen <code>n</code> in the <code>inv</code> field is the <em>same</em> as the result of the <code>Exists.choose</code> in this goal. How would that go?</p>\n</blockquote>\n<p>This sentence is a bit confusing to me because the noncomputably-chosen <code>n</code> in the <code>inv</code> field <em>is</em> the <code>Exists.choose</code> in that goal</p>",
        "id": 387033839,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1692870624
    },
    {
        "content": "<p>I would be inclined to revert this definition to the original version, with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">groupOfPowers</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hpos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n</code></pre></div>\n<p>and then define </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"n\">abbrev</span> <span class=\"n\">IsOfFinOrder.groupPowers</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">IsOfFinOrder</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n</code></pre></div>\n<p>by using <code>choose</code> to select the <code>n</code> and then call the other function</p>",
        "id": 387034436,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1692870837
    },
    {
        "content": "<p>because different witnesses yield different groups, at least as defined here</p>",
        "id": 387034559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1692870887
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I managed to complete the move anyway</p>",
        "id": 387035984,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692871401
    },
    {
        "content": "<p>It looks a bit uglier with all the <code>choose_spec</code>s though</p>",
        "id": 387036167,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692871465
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/270676-lean4/topic/Getting.20values.20from.20an.20existential.20with.20a.20.22let.22/near/387028811\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"598052\">Jeremy Tan</span> don't worry about computability, we're doing classical maths. E.g., use <code>Classical.choose</code> if you need it.</p>\n</blockquote>\n<p>I don't agree with this. Since it costs almost nothing, I think we should split this into two definitions:</p>\n<ul>\n<li>A computable one that takes <code>n</code> explicitly</li>\n<li>A non-computable one that takes <code>IsOfFinOrder x</code></li>\n</ul>",
        "id": 387038802,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692872331
    },
    {
        "content": "<p>The former is pretty much just a subexpression of the latter</p>",
        "id": 387038847,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692872345
    },
    {
        "content": "<p>I have no objection to making this split, though of course I stand by my original remark :-)</p>",
        "id": 387038920,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1692872377
    },
    {
        "content": "<p>Oh, I now see Mario made exactly the same comment as me</p>",
        "id": 387039497,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692872554
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I responded to your comment about the abstruseness of the computable abbrev</p>",
        "id": 387044067,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692874160
    }
]