[
    {
        "content": "<p>Is there a way to prove this in term mode?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n</code></pre></div>\n<p>e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">of_decide_eq_true</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but this is very long compared to the tactic proof</p>",
        "id": 500962880,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1740083044
    },
    {
        "content": "<p>The tactic proof is short because it does more work with fewer key strokes. Each tactic can summon an entire algorithm that's defined via metaprogramming. Whereas the term mode proof has to be a precise term of the type you want to inhabit.</p>\n<p>This is the general way to think around it, but in practice nothing is stopping you from doing</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">of_decide_eq_true</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span>\n</code></pre></div>",
        "id": 500963732,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1740083376
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/channel/270676-lean4/topic/Decidability.20proof.20in.20term.20mode/near/500963732\">said</a>:</p>\n<blockquote>\n<p>The tactic proof is short because it does more work with fewer key strokes. Each tactic can summon an entire algorithm that's defined via metaprogramming. Whereas the term mode proof has to be a precise term of the type you want to inhabit.</p>\n<p>This is the general way to think around it, but in practice nothing is stopping you from doing</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">of_decide_eq_true</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Is there a shorter version of <code>of_decide_eq_true (Eq.refl true)</code>?</p>",
        "id": 500963781,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1740083399
    },
    {
        "content": "<p>What's the constraint? Are you paying for bytes?</p>",
        "id": 500963799,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740083402
    },
    {
        "content": "<p><code>of_decide_eq_true (Eq.refl true)</code> works wherever <code>by decide</code> would, so it's a small constant factor on a constant</p>",
        "id": 500963870,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740083418
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Decidability.20proof.20in.20term.20mode/near/500963799\">said</a>:</p>\n<blockquote>\n<p>What's the constraint? Are you paying for bytes?</p>\n</blockquote>\n<p>Im just curious about this because decidability seems to be one problem where there is not an obvious solution in term mode</p>",
        "id": 500963914,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1740083438
    },
    {
        "content": "<p>Here's a possibility:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">decide_true</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">of_decide_eq_true</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">decide_true</span>\n</code></pre></div>",
        "id": 500964285,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740083557
    },
    {
        "content": "<p>It's worse than <code>by decide</code> though, since <code>by decide</code> can cache a proof of <code>decide p = true</code> and save a kernel rechecking.</p>",
        "id": 500964531,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740083659
    },
    {
        "content": "<p>What's your rule for what counts as \"term mode\"? Is <code>(by decide)</code> term mode? Is a custom <code>macro \"decide%\" : term =&gt; `(by decide)</code> term mode?</p>",
        "id": 500964881,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740083809
    },
    {
        "content": "<p>If you rule out custom notation running nontrivial code, then you have to ban the <code>+</code> operator notation too :)</p>",
        "id": 500964922,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740083826
    },
    {
        "content": "<p>(Lean 3 had a term-mode decide, and I too wondered about Lean 4 not having one a couple years ago. I chalked it up to <code>by decide</code> being easy enough to type, and it's not heavy weight. As of a few months ago, it has this caching behavior too, which makes the case even stronger for not needing a theorem like <code>decide_true</code>.)</p>",
        "id": 500965101,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740083894
    },
    {
        "content": "<p>this also works but I don't know why.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">nofun</span>\n</code></pre></div>",
        "id": 500965225,
        "sender_full_name": "Derek Rhodes",
        "timestamp": 1740083959
    },
    {
        "content": "<p>That's the same as <code>fun h =&gt; nomatch h</code>, where <code>nomatch h</code> is \"<code>match h with</code>\" with no cases (no cases isn't syntactically valid, hence the <code>no</code> variant)</p>",
        "id": 500965346,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740084004
    },
    {
        "content": "<p>And that boils down to noConfusion (check the xena blog for details)</p>",
        "id": 500965482,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1740084070
    },
    {
        "content": "<p><code>match</code> can reason about constructors. The constructor for <code>Eq</code> is <code>rfl</code>, which forces both indices to be definitionally equal. Given <code>0</code> and <code>2</code>, the first is <code>Nat.zero</code> and the second is <code>Nat.succ _</code>, so it eliminates the possibility (using noConfusion, as Ruben says)</p>",
        "id": 500965625,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740084129
    },
    {
        "content": "<p>The tactic version of <code>nofun</code> is <code>by intro h; cases h</code>. \"Dependent elimination\" succeeds. (The thing we only ever hear about from <code>cases</code> when it fails.)</p>",
        "id": 500965709,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740084169
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> has marked this topic as resolved.</p>",
        "id": 501015401,
        "sender_full_name": "Notification Bot",
        "timestamp": 1740109731
    }
]