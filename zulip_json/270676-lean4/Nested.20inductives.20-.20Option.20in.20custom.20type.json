[
    {
        "content": "<p>The following (which I think is a MWE) doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I get this message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">kernel</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">invalid</span><span class=\"w\"> </span><span class=\"n\">nested</span><span class=\"w\"> </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">datatype</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Option'</span><span class=\"o\">,</span>\n<span class=\"n\">nested</span><span class=\"w\"> </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">datatypes</span><span class=\"w\"> </span><span class=\"n\">parameters</span>\n<span class=\"n\">cannot</span><span class=\"w\"> </span><span class=\"n\">contain</span><span class=\"w\"> </span><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"n\">variables</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>This seems reasonable enough: is there a way of modifying my definition to achieve this?</p>",
        "id": 482656167,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731690158
    },
    {
        "content": "<p>Oho: this seems to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 482658640,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731690989
    },
    {
        "content": "<p>i think it will be easier to have the <code>Nat</code> not be a parameter, but rather a result of a function, similar to <code>Vector</code> compared to <code>List</code>. (it will help you keep out of dependent type hell).</p>",
        "id": 482658767,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731691031
    },
    {
        "content": "<p>Hmm - I see why I'd want that, but I do wantto restrict \"node\" in this way... I think? Though perhaps I can simply avoid it.</p>",
        "id": 482658906,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731691077
    },
    {
        "content": "<p>Hmm... I do think it would be much trickier to get some of the other properties I want without that.</p>",
        "id": 482659186,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731691158
    },
    {
        "content": "<p>i'd like to point out that you will be able to construct empty <code>node</code>s with arbitrary depths with the type as-is... is this what you want?</p>",
        "id": 482659450,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731691227
    },
    {
        "content": "<p>Yep.</p>",
        "id": 482659492,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731691240
    },
    {
        "content": "<p>huh</p>",
        "id": 482659528,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731691252
    },
    {
        "content": "<p>what's your application, if i may ask?</p>",
        "id": 482659599,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731691275
    },
    {
        "content": "<p>I am trying to prove something about the <code>treeHash</code> function used in XMSS.</p>",
        "id": 482659652,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731691296
    },
    {
        "content": "<p><a href=\"https://www.rfc-editor.org/rfc/rfc8391#section-4.1.6\">https://www.rfc-editor.org/rfc/rfc8391#section-4.1.6</a></p>",
        "id": 482659702,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731691311
    },
    {
        "content": "<p>What you want is a nested indexed datatype. Lean currently doesn't manage those. One solution would be to (manually) convert your nested inductive type into a mutual type such as this one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">mutual</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">OptionBTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OptionBTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">OptionBTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OptionBTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">OptionBTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 482659882,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1731691359
    },
    {
        "content": "<p>lean does manage it tho? you may have previously come across versions with <code>List</code>s, for that matter.</p>",
        "id": 482660015,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731691405
    },
    {
        "content": "<p>Yeah my second version above works :)</p>",
        "id": 482660092,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731691435
    },
    {
        "content": "<p>i seem to recall it was a special implementation for only a few basic inductive types tho, but <code>Option</code> is among them</p>",
        "id": 482660187,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731691456
    },
    {
        "content": "<p>(i could be wrong)</p>",
        "id": 482660220,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731691468
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/270676-lean4/topic/Nested.20inductives.20-.20Option.20in.20custom.20type/near/482660092\">said</a>:</p>\n<blockquote>\n<p>Yeah my second version above works :)</p>\n</blockquote>\n<p>I get the following error on your second version (running on nightly):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span><span class=\"cm\">(kernel) invalid nested inductive datatype 'Option', nested inductive datatypes parameters cannot contain local variables.-/</span>\n</code></pre></div>",
        "id": 482660345,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1731691516
    },
    {
        "content": "<p>Odd. I do get it in a fresh file, but I don't in my other one, but I really thought I wasn't using any imports</p>",
        "id": 482660520,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731691571
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/270676-lean4/topic/Nested.20inductives.20-.20Option.20in.20custom.20type/near/482660015\">said</a>:</p>\n<blockquote>\n<p>lean does manage it tho? you may have previously come across versions with <code>List</code>s, for that matter.</p>\n</blockquote>\n<p>Lean manages nested inductive types, and managed indexed inductive types, but it does not manage nested indexed inductive types. For example, the following fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"kn\">inductive</span><span class=\"bp\">.</span><span class=\"n\">autoPromoteIndices</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>",
        "id": 482660650,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1731691620
    },
    {
        "content": "<p>Ah, this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 482660931,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731691707
    },
    {
        "content": "<p>I had a <code>variable</code> somewhere that was introducing the <code>{n : ℕ}</code></p>",
        "id": 482660969,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731691721
    },
    {
        "content": "<p>So that's not really what I want, certainly.</p>",
        "id": 482661007,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731691735
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/270676-lean4/topic/Nested.20inductives.20-.20Option.20in.20custom.20type/near/482660520\">said</a>:</p>\n<blockquote>\n<p>Odd. I do get it in a fresh file, but I don't in my other one, but I really thought I wasn't using any imports</p>\n</blockquote>\n<p><del>No imports can solve this. Are you sure you sent the \"right\" definition ? something like this would pass, because <code>Nat</code> would be promoted to a parameter instead of an index.</del></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"c1\">--used to be BTree β (n+1)</span>\n</code></pre></div>\n<p>Nevermind, you answered already</p>",
        "id": 482661128,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1731691777
    },
    {
        "content": "<p>As I say, I had <code>variable {n : Nat}</code> much further above, and that was causing it to \"work\" (but you can see why actually it doesn't so much work)</p>",
        "id": 482661292,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731691814
    },
    {
        "content": "<p>out of curiosity, why does removing the <code>Nat</code> parameter fix this issue?</p>",
        "id": 482661338,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731691829
    },
    {
        "content": "<p>Well, it makes my above example <em>not</em> work, so it doesn't so much fix it as reveal that my \"fix\" was not.</p>",
        "id": 482661473,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731691873
    },
    {
        "content": "<p>The mutual definition above does work, but might be somewhat unwieldy.</p>",
        "id": 482661591,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731691911
    },
    {
        "content": "<p>it turns out i just need to read through your message more carefully: because <code>Nat</code> is an index here, and as you said, lean doesn't manage nested indexed inductives.</p>",
        "id": 482661598,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731691915
    },
    {
        "content": "<p>Essentially the issue arises because I am constructing the tree \"downwards\" rather than upwards.</p>\n<p>In the application, I am trying to prove that calculating the hash of a tree with 2^n leaf nodes in the \"natural\" recursive way (if n = 0, done, otherwise split into two halves, calculate their hashes, find hash of the result) is the same as using a \"stack\" (as the reference implementation of treeHash does).</p>",
        "id": 482662262,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731692133
    },
    {
        "content": "<p>The difference essentially is that you massively save on storage space, because you only actually need to store ~ n things at once, rather than 2^n things.</p>",
        "id": 482662377,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731692164
    },
    {
        "content": "<p>Basically you calculate hashes \"when you need them\", adding a leaf at a time.</p>",
        "id": 482662417,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731692182
    },
    {
        "content": "<p>I mean, to be clearer, Lean does manage <em>some</em> instances of nested indexed inductive types. Namely, as long as the indices appearing in the nested occurences do not contain free variables (read: variables introduced in the constructor itself), then it's all good, but it won't manage it if free variables are appearing in the indices. Since in <span class=\"user-mention\" data-user-id=\"330967\">@Wrenna Robson</span>'s example, the <code>n</code> appearing in the index is introduced as a parameter, Lean doesn't complain, despite the fact that it is indeed a nested indexed inductive types.</p>",
        "id": 482662566,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1731692241
    },
    {
        "content": "<p>This turns out to sort of be analogous to binary number succession (you can model your stack as a list of Option types and basically adding a new leaf and calculating any new hashes is analogous to adding 1 to the binary number and doing the carries).</p>",
        "id": 482662585,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731692248
    },
    {
        "content": "<p>And it's really surprisingly hard to prove them equivalent despite the fact it's \"obviously\" true.</p>",
        "id": 482662668,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731692278
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/270676-lean4/topic/Nested.20inductives.20-.20Option.20in.20custom.20type/near/482662262\">said</a>:</p>\n<blockquote>\n<p>Essentially the issue arises because I am constructing the tree \"downwards\" rather than upwards.</p>\n</blockquote>\n<p>in that case, i still don't get why you want the \"depth\" value to be constant over the construction?</p>",
        "id": 482662729,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731692285
    },
    {
        "content": "<p>I don't, I want it to descend.</p>",
        "id": 482662790,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731692306
    },
    {
        "content": "<p>Hence the <code>n + 1</code>. But it may not be the right choice.</p>",
        "id": 482662851,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731692324
    },
    {
        "content": "<p>If you're expected to work with 2^n leaves, wouldn't you want your <code>node</code> to be of type <code>BTree β n → BTree β n → BTree β (n + 1)</code> ?</p>",
        "id": 482662852,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1731692324
    },
    {
        "content": "<p>Yeah so obviously that does work (and is what I had before) - the thing is that I want to allow for \"truncated\" trees, or unknown trees - basically to represent when I've not loaded in all the leaves.</p>",
        "id": 482662977,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731692382
    },
    {
        "content": "<p>Essentially it doesn't seem like induction on n is ever quite enough - I would like to be able to construct my tree by adding a leaf at a time and performing cancellations as appropriate (if I have two leaves with a value specified at a node, I can replace that node with a leaf of height + 1 whose value is the hash of the other two).</p>",
        "id": 482663206,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731692447
    },
    {
        "content": "<p>But that means I need to be able to work with, essentially, any number of leaves from 0 to 2^n (inclusive).</p>",
        "id": 482663313,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731692473
    },
    {
        "content": "<p>I could just do something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 482663534,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731692539
    },
    {
        "content": "<p>This has proven fairly fruitful, but I'm not sure it's quite right.</p>",
        "id": 482663653,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731692580
    },
    {
        "content": "<p>i'd recommend the following (to avoid dependent type hell):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Util</span><span class=\"bp\">.</span><span class=\"n\">CompileInductive</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span>\n\n<span class=\"n\">compile_inductive</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">BTree</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"bp\">.</span><span class=\"n\">depth</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">BTree'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">depth</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 482664313,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731692767
    },
    {
        "content": "<p>Oho</p>",
        "id": 482664392,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731692797
    },
    {
        "content": "<p>note that this doesn't enforce the 2^n stuff, the shape can be weird. but it should at least give you a way out of having to rewrite inside the type of things</p>",
        "id": 482664742,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731692916
    },
    {
        "content": "<p>Yeah that is always Bad.</p>",
        "id": 482664777,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731692928
    },
    {
        "content": "<p>It does mean that if <code>t = node l r</code>, you know that the depth of l and r are less than the depth of t, but no more than that I think?</p>",
        "id": 482664868,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731692963
    },
    {
        "content": "<p>exactly that, yes</p>",
        "id": 482664912,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731692983
    },
    {
        "content": "<p>Well, I suppose one of them at least has to have depth one less than it.</p>",
        "id": 482664917,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731692986
    },
    {
        "content": "<p>no, both</p>",
        "id": 482664931,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731692996
    },
    {
        "content": "<p>Well, l could have depth 0, say, no?</p>",
        "id": 482665009,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731693011
    },
    {
        "content": "<p>And then the depth of <code>t</code> will be <code>r.depth + 1</code></p>",
        "id": 482665079,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731693040
    },
    {
        "content": "<p>the depth of a <code>.node</code> is the maximum of the depths of subtrees plus 1. so it is always larger than both depths.</p>",
        "id": 482665285,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731693110
    },
    {
        "content": "<p>No I get that</p>",
        "id": 482665318,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731693121
    },
    {
        "content": "<p>I'm just saying that the one with the larger depth (if they have different depths) will obviously be equal to the maxmimum, one less than it.</p>",
        "id": 482665438,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731693149
    },
    {
        "content": "<p>Wheras the other can range anywhere inbetween.</p>",
        "id": 482665464,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1731693156
    }
]