[
    {
        "content": "<p>I'm trying to map a symbolic type to a Lean type and define a default value through a function, but I often run into instances where the unification algorithm does not reduce the <code>eval</code> function in each branch. Here is a MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">int</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span>\n  <span class=\"bp\">|</span> <span class=\"n\">tuple</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">T.eval</span><span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">T.int</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Int</span>\n  <span class=\"bp\">|</span> <span class=\"n\">T.tuple</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Unit</span>\n  <span class=\"bp\">|</span> <span class=\"n\">T.tuple</span> <span class=\"o\">(</span><span class=\"n\">τ</span><span class=\"o\">::</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">τ.eval</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">T.default</span> <span class=\"o\">(</span><span class=\"n\">τ</span><span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">):</span> <span class=\"n\">τ.eval</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">τ</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">T.int</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">Int</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">T.tuple</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">()</span>\n  <span class=\"bp\">|</span> <span class=\"n\">T.tuple</span> <span class=\"o\">(</span><span class=\"n\">τ</span><span class=\"o\">::</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">τ.default</span>\n</code></pre></div>\n<p>For instance I get an error on <code>(0:Int)</code> saying it expects an <code>eval (int x✝)</code>. I'm not sure what influences this result; removing the parameter to <code>T.int</code>, getting rid of <code>T.tuple</code>, or returning <code>Int</code> rather than <code>τ.eval</code> for the third matching case of <code>T.eval</code> all cause this error to go away on the first case.</p>\n<p>I'd think there is some function attribute to indicate that <code>T.eval</code> should be reduced, but neither <code>@[simp]</code> or <code>@[reducible]</code> work. The best I can get currently is with <code>@[simp]</code>, by replacing the terms with <code>cast (by simp) _</code>, but it's inconvenient.</p>",
        "id": 276038801,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1647863606
    },
    {
        "content": "<p>The problem is that <code>T</code> is a nested inductive datatype, and in the current implementation, every recursive function defined on this kind of type uses well-founded recursion.  You can use </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"n\">T.eval</span>\n</code></pre></div>\n<p>to see how <code>T.eval</code> was compiled before being sent to the kernel. <br>\nMoreover, well-founded recursion requires theorems to be unfolded to reduce, and by default, the Lean elaborator does not unfold theorems. <br>\nThe current workaround is to define <code>T.eval</code> using the primitive <code>T.rec</code> recursor. It is painful, but it is doable for a simple function like <code>T.eval</code>.  In the future, we want to be able to show definitions such as <code>T.eval</code> terminate using <code>T.rec</code> instead of well-founded recursion, but it will not happen in the near future. Here is your example with <code>T.rec</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">int</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span>\n  <span class=\"bp\">|</span> <span class=\"n\">tuple</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">T</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">T.eval</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">T.rec</span>\n    <span class=\"o\">(</span><span class=\"n\">motive_1</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">motive_2</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Int</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ih</span><span class=\"o\">)</span>\n    <span class=\"n\">Unit</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">ih₁</span> <span class=\"n\">ih₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ih₁</span><span class=\"o\">)</span>\n    <span class=\"n\">t</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">T.default</span> <span class=\"o\">(</span><span class=\"n\">τ</span><span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">):</span> <span class=\"n\">τ.eval</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">τ</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">T.int</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">Int</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">T.tuple</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">()</span>\n  <span class=\"bp\">|</span> <span class=\"n\">T.tuple</span> <span class=\"o\">(</span><span class=\"n\">τ</span><span class=\"o\">::</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">τ.default</span>\n</code></pre></div>",
        "id": 276044057,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647866578
    },
    {
        "content": "<p>I pushed your example to our test suite as a reminder that we need to add support for nested and mutual inductive types to the structural recursion module. <br>\n<a href=\"https://github.com/leanprover/lean4/blob/master/tests/lean/run/nestedInductiveRecType.lean\">https://github.com/leanprover/lean4/blob/master/tests/lean/run/nestedInductiveRecType.lean</a></p>",
        "id": 276046506,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647867677
    },
    {
        "content": "<p>BTW, file above also uses the recursor <code>T.rec_1</code>that takes <code>List T</code> as a major premise. We need it if want <code>eval</code> to return a <code>Prod</code> for <code>T.tuple</code>.</p>",
        "id": 276047544,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647868101
    },
    {
        "content": "<p>Thank you very much, this is all very informative. I managed to get it to work, fortunately the real type doesn't have any other instance of nesting. (It did come with a needlessly mutual group and 20 motives initially, which scared me quite a bit.) I'm glad you anticipated the <code>Prod</code> version of <code>T.tuple</code> as well.</p>\n<p>I would still like to get rid of the integer cast is possible, which is not trivial since apparently typeclass resolution reduces less eagerly (?):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"kd\">instance</span>\n  <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"n\">T.eval</span> <span class=\"o\">(</span><span class=\"n\">T.int</span> <span class=\"mi\">32</span><span class=\"o\">))</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>I could hack my way around it by defining such an instance, but I wonder if there's a cleaner way to do it?</p>",
        "id": 276059420,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1647873413
    },
    {
        "content": "<p>Typeclass resolution will only unfold definitions marked as <code>@[reducible]</code>. The motivation is performance. <br>\nSo, when trying to synthesize a value for the instance <code>OfNat (T.eval (T.int 32)) 0</code>, it will not reduce it <code>OfNat Int 0</code>.<br>\nI updated the example above with the <code>@[reducible]</code> annotations and removed the <code>( ... : Int)</code> annotations.</p>",
        "id": 276060395,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647873806
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/blob/master/tests/lean/run/nestedInductiveRecType.lean#L27-L37\">https://github.com/leanprover/lean4/blob/master/tests/lean/run/nestedInductiveRecType.lean#L27-L37</a></p>",
        "id": 276060448,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1647873828
    },
    {
        "content": "<p>Aha so that's what <code>@[reducible]</code> does. Excellent. Everything's working as expected now, thanks again for your time.</p>",
        "id": 276062253,
        "sender_full_name": "Sébastien Michelland",
        "timestamp": 1647874446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"484617\">Sébastien Michelland</span> has marked this topic as resolved.</p>",
        "id": 276062275,
        "sender_full_name": "Notification Bot",
        "timestamp": 1647874454
    }
]