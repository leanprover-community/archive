[
    {
        "content": "<p>I'm really confused on what <code>outParam</code> is actually doing. To my limited understanding, you can use it to prevent for example an instance to be polymorphic in certain argument.</p>\n<p>I would like to understand the following code that runs into an infinite loop exactly because of <code>outParam</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Vec</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">ℝ</span> <span class=\"n\">where</span>\n  <span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">Float</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">SemiHilbert</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">outParam</span> <span class=\"bp\">$</span> <span class=\"n\">Vec</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">Vec</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SemiHilbert</span> <span class=\"n\">X</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">SemiHilbert</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">SemiHilbert</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">synthInstance.maxHeartbeats</span> <span class=\"mi\">15</span> <span class=\"k\">in</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.synthInstance</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">SemiHilbert</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>It works fine if you change <code>(R : outParam $ Type u)</code> to <code>(R : Type u)</code> in the definition of <code>SemiHilbert</code> class.</p>\n<p>What I do not understand is why the last subgoal</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.synthInstance.newSubgoal</span><span class=\"o\">]</span> <span class=\"n\">Vec</span> <span class=\"n\">_tc.0</span>\n</code></pre></div>\n<p>causes TC to going into an insane infinite loop producing longer and longer instances of <code>Vec (ℝ × ... × ℝ)</code>.</p>",
        "id": 269483919,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1643231959
    },
    {
        "content": "<p>I don't mean this to sound flippant (\"read the manual\"), but there is a small section in there which is the best description I've found of what it actually does (adjusts the starting point for TC synthesis). <a href=\"https://leanprover.github.io/lean4/doc/typeclass.html?highlight=outParam#output-parameters\">https://leanprover.github.io/lean4/doc/typeclass.html?highlight=outParam#output-parameters</a>.</p>",
        "id": 269585449,
        "sender_full_name": "Chris B",
        "timestamp": 1643295936
    },
    {
        "content": "<p>Yes to that extent as described there I understand it, but I'm utterly confused what is Lean trying to do in the code I have posted.</p>",
        "id": 269628381,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1643313230
    },
    {
        "content": "<p>I have just noticed that the use of <code>outParam</code> in <code>HMul</code> makes the following example typecheck</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HMul</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HMul</span><span class=\"bp\">.</span><span class=\"n\">hMul</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>but not the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HMul</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HMul</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HMul</span><span class=\"bp\">.</span><span class=\"n\">hMul</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"c1\">--type mismatch</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HMul</span><span class=\"bp\">.</span><span class=\"n\">hMul</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- it works</span>\n</code></pre></div>\n<p>because due to the second instance, the <code>outParam</code> is set to <code>Bool</code> instead of <code>ℕ</code>. I understand that this is to be expected, according to <a href=\"https://lean-lang.org/doc/reference/latest/Type-Classes/Instance-Synthesis/#class-output-parameters\">the explanation in the manual</a>, in particular when it says </p>\n<blockquote>\n<p>When a class parameter is an <em>output parameter</em>, instance synthesis will not require that it be known; in fact, any existing value is ignored completely. The first instance that matches the input parameters is selected, and that instance's assignment of the output parameter becomes its value. If there was a pre-existing value, then it is compared with the assignment after synthesis is complete, and it is an error if they do not match.</p>\n</blockquote>\n<p>My questions:</p>\n<ol>\n<li>In the above quotation, what is a \"pre-existing value\"? If TC is launched, it might or not find the instance it is looking for, but I do not understand what is meant by \"pre-existing\".</li>\n<li>By \"first instance\" do we mean the latest that has been defined?</li>\n<li>Overall, are the above features (forgetting pre-existing values and picking the first instance) sought for, or are they forced upon us by the implementation of the <code>outParam</code> class, but in principle not needed? I still cannot understand why one cannot hope for a <code>outParam</code> behaviour that allows for treating parameters as outputs, and yet in my example compares the final term <code>0 : Nat</code> with the two instances it has <code>HMul ℝ ℝ Bool</code> and <code>HMul ℝ ℝ ℕ</code> and realizes by unification that it is after the second, not the first.</li>\n</ol>\n<p>PS: Of course changing <code>outParam</code> to a normal parameter (or even a <code>semiOutParam</code>) solves <em>this</em> issue, but not the \"true\" one for which <code>outParam</code> was chosen in <code>HMul</code> in the first place, so these are not viable options.</p>",
        "id": 489980836,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1734620146
    },
    {
        "content": "<ol>\n<li>If Lean knows it's looking for <code>HMul ℝ ℝ Bool</code> then <code>Bool</code> is the pre-existing value for the argument (and thus, is ignored when searching for an instance).</li>\n</ol>",
        "id": 489986640,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1734621795
    },
    {
        "content": "<ol start=\"2\">\n<li>It means the one with the highest priority. So if you don't specify priorities, it is indeed the last one that has been defined (or imported).</li>\n</ol>",
        "id": 489986705,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1734621818
    },
    {
        "content": "<ol start=\"3\">\n<li>is above my pay-grade. Probably has something to do with making the elaborator more reliable. I think the heuristic for <code>outParam</code> should be that there is (up to defeq) at most one instance matching a pattern, ignoring the outParams. If you want a binary operation on a type that takes different types depending on the context, maybe don't use <code>*</code> but a binary operation you define yourself.</li>\n</ol>",
        "id": 489987226,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1734621959
    },
    {
        "content": "<p>Thanks ! 1. and 2. are crystal clear <span aria-label=\"crystal\" class=\"emoji emoji-1f48e\" role=\"img\" title=\"crystal\">:crystal:</span> , as usual <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 489988416,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1734622238
    },
    {
        "content": "<p>For 3, I was not looking to define a binary operator, I stumbled upon this example and ended up in the rabbit hole <span aria-label=\"rabbit\" class=\"emoji emoji-1f407\" role=\"img\" title=\"rabbit\">:rabbit:</span> .</p>",
        "id": 489988556,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1734622280
    },
    {
        "content": "<p>At any rate I take home the message \"for <code>outParam</code> we expect a unique instance\".</p>",
        "id": 489988746,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1734622331
    }
]