[
    {
        "content": "<p>I'm trying to encode a simple little category like so --</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Obj</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Manager</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Employee</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Department</span>\n<span class=\"kn\">open</span> <span class=\"n\">Obj</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Hom</span><span class=\"o\">:</span> <span class=\"n\">Obj</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Obj</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">idt</span> <span class=\"o\">(</span><span class=\"n\">o</span><span class=\"o\">:</span> <span class=\"n\">Obj</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Hom</span> <span class=\"n\">o</span> <span class=\"n\">o</span>\n  <span class=\"bp\">|</span> <span class=\"n\">com</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">Obj</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">Hom</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">Hom</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Hom</span> <span class=\"n\">a</span> <span class=\"n\">c</span>\n  <span class=\"bp\">|</span> <span class=\"n\">managedBy</span><span class=\"o\">:</span> <span class=\"n\">Hom</span> <span class=\"n\">Employee</span> <span class=\"n\">Manager</span>\n  <span class=\"bp\">|</span> <span class=\"n\">managesIn</span><span class=\"o\">:</span> <span class=\"n\">Hom</span> <span class=\"n\">Manager</span> <span class=\"n\">Department</span>\n  <span class=\"bp\">|</span> <span class=\"n\">worksIn</span><span class=\"o\">:</span> <span class=\"n\">Hom</span> <span class=\"n\">Employee</span> <span class=\"n\">Department</span>\n<span class=\"kn\">open</span> <span class=\"n\">Hom</span>\n<span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"s2\">\" ; \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">com</span>\n</code></pre></div>\n<p>...now if I want to say something like managedBy ; managesIn = worksIn, seems like I could:</p>\n<ol>\n<li>use axioms</li>\n<li>have a new function that takes two elements of Hom a b and gives back a Prop</li>\n<li>provide an instance of the Eq typeclass for Hom a b</li>\n<li>some other option</li>\n</ol>\n<p>(and I think I would also use this method for having associativity and identity properties be true \"by definition\"). I was not able to find syntax that works for option 3, although it seemed like that would be the right choice. Any advice? thanks</p>",
        "id": 339652341,
        "sender_full_name": "Mark Wilhelm",
        "timestamp": 1677999689
    },
    {
        "content": "<p>Option 1 would be unsound as it is provably the case that <code>com ... ≠ worksIn ...</code> if they are both constructors</p>",
        "id": 339653265,
        "sender_full_name": "Horațiu Cheval",
        "timestamp": 1678000492
    },
    {
        "content": "<p>There's no Eq type class. <code>=</code> is the actual propositional equality, and the equations that you want don't hold of course.<br>\nOptions are to put an equivalence relation on each <code>Hom a b</code>, and form the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quotient#doc\">docs4#Quotient</a>; or, in this case, just don't introduce the redundant representations of what you want to be the \"same\" morphism in the first place.</p>",
        "id": 339653314,
        "sender_full_name": "Reid Barton",
        "timestamp": 1678000554
    },
    {
        "content": "<p>Ok then it looks like to do the quotient approach, I define an instance of the Setoid typeclass for Hom a b, which I then use to define a Quotient, and then I would use that quotient instead of using Hom a b directly?</p>",
        "id": 339654276,
        "sender_full_name": "Mark Wilhelm",
        "timestamp": 1678001364
    },
    {
        "content": "<p>You can also try 4: Instead of making <code>idt</code> and <code>com</code> constructors, you define <code>Arrow</code> to be the rest of the constructors, and define <code>ListOfArrowsThatAreComposable</code> inductively, almost like a list. So then the empty list is <code>idt</code>, and concatenation of lists serve as the composition. Note that in this way no quotienting is required, and everything is computable. I'm sure this is already done in mathlib, search for \"free category generated by quivers\"</p>",
        "id": 339688918,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1678019873
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/quiver.path\">docs#quiver.path</a></p>",
        "id": 339689288,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1678020035
    }
]