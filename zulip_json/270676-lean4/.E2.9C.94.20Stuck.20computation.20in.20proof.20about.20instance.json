[
    {
        "content": "<p>I'm stuck in a proof, which leads me to two questions:</p>\n<ol>\n<li>When I do a proof about some instance of a class with a concrete carrier type, do I get to assume that the instance implementation will be my given instance, or do I need to think of it as a proof that should work for all instances?</li>\n<li>If the answer to the former is \"the proof needs to be instance-agnostic\", how would I go about stating that a property holds \"for a given instance specifically\".</li>\n</ol>\n<p>In practice, this comes up in me trying to finish this proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Types</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Magma</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">obj</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Magma</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">assoc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">id_elt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">obj</span>\n<span class=\"w\">  </span><span class=\"n\">id_l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">id_elt</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"n\">id_r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">id_elt</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">e</span>\n\n<span class=\"c1\">-- Unit type with a top hat and a mustache.</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Proxy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">MkProxy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Proxy</span><span class=\"w\"> </span><span class=\"n\">obj</span>\n\n<span class=\"c1\">-- A monoid can be viewed as a category, with a single object (using `Proxy obj` to stand for the</span>\n<span class=\"c1\">-- singular object corresponding to `obj`).</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">monoidAsCategory</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Proxy</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">MkProxy</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">MkProxy</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">obj</span>\n<span class=\"w\">  </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">MkProxy</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Monoid</span><span class=\"bp\">.</span><span class=\"n\">id_elt</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Magma</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">id_comp</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"bp\">.</span><span class=\"n\">id_l</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">comp_id</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"bp\">.</span><span class=\"n\">id_r</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">assoc</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- First version of finite state machine, with just an alphabet, a state space, and a `next`</span>\n<span class=\"c1\">-- function.  Might add a start state, and maybe accept states, later.</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">FSM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Alphabet</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">next_state</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Alphabet</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">State</span>\n\n<span class=\"c1\">-- Building towards viewing a FSM as a functor from the free monoid over its alphabet to the types</span>\n<span class=\"c1\">-- category.  For this, we first need to define the free monoid construction.</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">freeMonoid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">append</span>\n<span class=\"w\">  </span><span class=\"n\">id_elt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">nil</span>\n<span class=\"w\">  </span><span class=\"n\">assoc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">id_l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">id_r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n\n<span class=\"c1\">-- Iterated `next_state` over a string from `Alphabet`.</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nexts_state</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FSM</span><span class=\"w\"> </span><span class=\"n\">Alphabet</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">string</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Alphabet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">string</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">nexts_state</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">FSM</span><span class=\"bp\">.</span><span class=\"n\">next_state</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"c1\">-- Now we can finally view a FSM as a functor from the free monoid.</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fsmAsFunctor</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FSM</span><span class=\"w\"> </span><span class=\"n\">Alphabet</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Functor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Proxy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Alphabet</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"c1\">-- I also tried being much more explicit about the Category instance, still stuck:</span>\n<span class=\"w\">  </span><span class=\"c1\">-- : @CategoryTheory.Functor</span>\n<span class=\"w\">  </span><span class=\"c1\">--     (Proxy (List Alphabet))</span>\n<span class=\"w\">  </span><span class=\"c1\">--     (@monoidAsCategory _ (freeMonoid Alphabet))</span>\n<span class=\"w\">  </span><span class=\"c1\">--     Type _ where</span>\n<span class=\"w\">  </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">nexts_state</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"w\">  </span><span class=\"n\">map_id</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">nexts_state</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">types_id</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">map_comp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">types_comp</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I don't know how to get <code>nexts_state (CategoryTheory.CategoryStruct.comp f g)</code> to reduce, and my guess is this might indicate that this proof does not work on \"any\" instance, but really on the one instance I care about.<br>\nFor the instance I care about, <code>comp</code> should be <code>List.append</code>, but how do I convince Lean?</p>\n<p>Thanks!</p>",
        "id": 509541915,
        "sender_full_name": "Valentin Robert",
        "timestamp": 1743539305
    },
    {
        "content": "<p>I tried <code>unfold_projs</code> to see what needed to be proved concretely, and that led to the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">nexts_state_append</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FSM</span><span class=\"w\"> </span><span class=\"n\">Alphabet</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">str1</span><span class=\"w\"> </span><span class=\"n\">str2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Alphabet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">nexts_state</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">str1</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">str2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">nexts_state</span><span class=\"w\"> </span><span class=\"n\">str2</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">nexts_state</span><span class=\"w\"> </span><span class=\"n\">str1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- Now we can finally view a FSM as a functor from the free monoid.</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fsmAsFunctor</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FSM</span><span class=\"w\"> </span><span class=\"n\">Alphabet</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Functor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Proxy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Alphabet</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">nexts_state</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"w\">  </span><span class=\"n\">map_id</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">nexts_state</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">types_id</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">map_comp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">nexts_state_append</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">    </span><span class=\"c1\">-- or these two lines could be</span>\n<span class=\"w\">    </span><span class=\"c1\">-- intros _ _ _</span>\n<span class=\"w\">    </span><span class=\"c1\">-- exact nexts_state_append</span>\n</code></pre></div>\n<p>The <code>sorry</code> seems like it would be easy to fill with a simple induction proof.</p>",
        "id": 509543618,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743539944
    },
    {
        "content": "<p>To answer your question, yes, the definition of an instance can be used. The only thing you were running into here was that you were seeing some indirection, since you were only seeing the category projection functions.</p>",
        "id": 509544020,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743540096
    },
    {
        "content": "<p>You can also set up some theorems for doing controlled rewrites, to turn the category theory version of something into the concrete version. (<code>open scoped CategoryTheory</code> is to get the category theory notation for composition)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Proxy_list_comp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Proxy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Obj</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- Now we can finally view a FSM as a functor from the free monoid.</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fsmAsFunctor</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FSM</span><span class=\"w\"> </span><span class=\"n\">Alphabet</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Functor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Proxy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Alphabet</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">nexts_state</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"w\">  </span><span class=\"n\">map_id</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">nexts_state</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">types_id</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">map_comp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Proxy_list_comp</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">nexts_state_append</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span>\n</code></pre></div>",
        "id": 509544875,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743540456
    },
    {
        "content": "<p>By the way, you can write <code>map_id x := rfl</code> since it's by definition.</p>",
        "id": 509545017,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743540502
    },
    {
        "content": "<p>Ah perfect, I did not know about <code>unfold_projs</code>, and my attempts at manually unfolding led to things I did not know about (some seemingly generated projection terms like <code>toBlah.3</code>). I know how to finish the proof now, thanks!</p>",
        "id": 509564577,
        "sender_full_name": "Valentin Robert",
        "timestamp": 1743549448
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"432680\">Valentin Robert</span> has marked this topic as resolved.</p>",
        "id": 509564583,
        "sender_full_name": "Notification Bot",
        "timestamp": 1743549452
    }
]