[
    {
        "content": "<p>Semantic syntax highlighting provided by the LSP is great, but is a bit slow for my taste.  Hence, I like to also turn on the \"regular\" syntax highlighting of my text editor, which is incomplete (ie. it doesn't know about modifications brought to the parser implemented with meta programming) but instantaneous.  The result I'm aiming for is that I have mostly correct instantaneous syntax highlighting, and when the LSP finally outputs the correct highlighting, if it differs, it gets applied.  However, the regular syntax highlighter is getting old, in the sense that many keywords have been added to the \"builtin\" syntax of Lean over the time, and so many of them are missing from the syntax highlighting table in the Lean plugin for the text editor.  I walked through the documentation to collect every keyword I could find, to add them, but this is both time consuming and error prone, and would add a large burden on maintenance.</p>\n<p>Hence, I would like to know if it were possible to retrieve this information directly from Lean itself.  AFAIK, Lean's parser is scannerless, and is not built on an inspectable grammar, but rather on parser combinators, so I'm not sure this is possible.</p>",
        "id": 570814065,
        "sender_full_name": "jthulhu",
        "timestamp": 1769697806
    },
    {
        "content": "<p>This approach should give you most of the reserved and nonreserved keywords:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Parser</span>\n\n<span class=\"n\">run_meta</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">parserExtension</span><span class=\"bp\">.</span><span class=\"n\">getState</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">getEnv</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">keywords</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">Token</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">ofArray</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"bp\">.</span><span class=\"n\">tokens</span><span class=\"bp\">.</span><span class=\"n\">values</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">cats</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"bp\">.</span><span class=\"n\">categories</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">cat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">cats</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">keywords</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">keywords</span><span class=\"bp\">.</span><span class=\"n\">insertMany</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">cat</span><span class=\"bp\">.</span><span class=\"n\">tables</span><span class=\"bp\">.</span><span class=\"n\">leadingTable</span><span class=\"bp\">.</span><span class=\"n\">keys</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">toString</span>\n<span class=\"w\">    </span><span class=\"n\">keywords</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">keywords</span><span class=\"bp\">.</span><span class=\"n\">insertMany</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">cat</span><span class=\"bp\">.</span><span class=\"n\">tables</span><span class=\"bp\">.</span><span class=\"n\">trailingTable</span><span class=\"bp\">.</span><span class=\"n\">keys</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">toString</span>\n\n<span class=\"w\">  </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{keywords.toArray.insertionSort}\"</span>\n</code></pre></div>\n<p>It will miss any nonreserved keywords that are not used to index a parser.</p>",
        "id": 570844390,
        "sender_full_name": "Eric Paul",
        "timestamp": 1769704940
    },
    {
        "content": "<p>Note that many of these are only keywords in some contexts, so you may want to be a bit judicious. <a href=\"https://live.lean-lang.org/#codez=C4Cwpg9gTmC2AEAzeAuegAIngCgJYDtgoJ4BzKfAE1XgDkBDYASgBp59DiBqU8vKgXh6V43dkVSCARgE8AUPDYEi8oXyA\">Here</a>, <code>intro</code> and <code>grind</code> are both identifiers in the theorem statement and keywords in the proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n</code></pre></div>",
        "id": 571053982,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1769785775
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"354934\">David Thrane Christiansen</span> <a href=\"#narrow/channel/270676-lean4/topic/Retrieve.20tokens.20from.20the.20Lean.20parser/near/571053982\">said</a>:</p>\n<blockquote>\n<p>Note that many of these are only keywords in some contexts, so you may want to be a bit judicious. <a href=\"https://live.lean-lang.org/#codez=C4Cwpg9gTmC2AEAzeAuegAIngCgJYDtgoJ4BzKfAE1XgDkBDYASgBp59DiBqU8vKgXh6V43dkVSCARgE8AUPDYEi8oXyA\">Here</a>, <code>intro</code> and <code>grind</code> are both identifiers in the theorem statement and keywords in the proof:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Yes of course, this is why I need both syntax highlighters.  I'm not trying to re-implement Lean's parser in the syntax highlighter of my text editor, this is what the LSP is for.</p>",
        "id": 571056422,
        "sender_full_name": "jthulhu",
        "timestamp": 1769786329
    },
    {
        "content": "<p>I'd like to have a tree-sitter parser that instead of using a pre-defined list of keywords, uses the surrounding indentation to guess what should be a command/tactic/etc, with special cases for more complex forms such as <code>have</code>, <code>show</code>. I had a semi-working prototype, but I got stuck making it work efficiently with certain syntax like records <code>{ f1 := ..., f2 := ... }</code>, that mix indentation and \"items separated by commas\" in a somewhat cursed way.</p>",
        "id": 571139347,
        "sender_full_name": "Lua Viana Reis",
        "timestamp": 1769814474
    },
    {
        "content": "<p>I think it's possible, but presently for me it was hard to justify the effort</p>",
        "id": 571139471,
        "sender_full_name": "Lua Viana Reis",
        "timestamp": 1769814558
    }
]