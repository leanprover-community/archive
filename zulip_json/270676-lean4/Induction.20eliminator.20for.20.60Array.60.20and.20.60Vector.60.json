[
    {
        "content": "<p>I quite often find myself wanting to do inductive reasoning on Array and Vector without breaking into the way they are internally constructed.</p>\n<p>Could we have something like the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">--- We don't have this for some reason.</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">eq_push_pop_back_of_size_ne_zero</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">â‰ </span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">pop</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">back</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">pos_of_ne_zero</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">induction_eliminator</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[])</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">hxs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">eq_empty_of_size_eq_zero</span><span class=\"w\"> </span><span class=\"n\">hxs</span><span class=\"w\"> </span><span class=\"bp\">â–¸</span><span class=\"w\"> </span><span class=\"n\">empty</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">eq_push_pop_back_of_size_ne_zero</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hxs</span><span class=\"w\"> </span><span class=\"bp\">â–¸</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ_ne_zero</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â–¸</span><span class=\"w\"> </span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">pop</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">size</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">induction_eliminator</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">v</span><span class=\"o\">[])</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">eq_empty</span><span class=\"w\"> </span><span class=\"bp\">â–¸</span><span class=\"w\"> </span><span class=\"n\">empty</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">push_pop_back</span><span class=\"w\"> </span><span class=\"bp\">â–¸</span><span class=\"w\"> </span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Note that it is hard to do reasoning like this in core by reducing an Array  or Vector to a List because core lacks a suitable backwards inductive principle for List (and using pop/push is more natural for Array/Vector).</p>\n<p>I don't know if these are efficient for programming purposes, but clearly they do eliminate to <code>Sort*</code>, so in principle I think you could use them to programmatically define things. If <code>getElem</code> syntax is preferred instead of <code>back</code> I think that would be also fine. I would be interested in people's thoughts: am I the only one who often finds herself wanting this kind of thing?</p>",
        "id": 564972277,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766398380
    },
    {
        "content": "<p>Relatedly by the way: I think <code>Array.pop_push</code> and <code>Vector.pop_push</code> (and probably <code>Vector.push_pop_back</code> and some suitable version for <code>Array</code>) should have the <code>grind</code> attribute.</p>",
        "id": 564972538,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766398467
    },
    {
        "content": "<p>Obviously these could also have a cases eliminator as well if you so wanted.</p>",
        "id": 564972663,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766398505
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> I'm tagging you here because I know you have an interest in ongoing efforts to achieve feature parity between <code>Array</code>, <code>Vector</code> and <code>List</code>.</p>",
        "id": 564972751,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766398533
    },
    {
        "content": "<p>(For <code>List</code>, I think this would probably want to look something like </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">reverseRec</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">append_singleton</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">nil</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dropLast_concat_getLast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cons_ne_nil</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">â–¸</span>\n<span class=\"w\">    </span><span class=\"n\">append_singleton</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">dropLast</span><span class=\"bp\">.</span><span class=\"n\">reverseRec</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"n\">append_singleton</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n</code></pre></div>\n<p>Which is a different approach than that which Mathlib's <code>List.reverseRecOn</code> uses but IMO also a better one.)</p>",
        "id": 564974821,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766399286
    },
    {
        "content": "<p>(For whatever reason, <code>l ++ [a]</code> is preferred over <code>l.concat a</code> I believe.)</p>",
        "id": 564975474,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766399556
    },
    {
        "content": "<p>This API is intentionally absent as my experience so far suggests that wanting it indicates an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> problem. Happy to be convinced otherwise.</p>",
        "id": 565096400,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1766463220
    },
    {
        "content": "<p>Yeah, I agree with Kim. I think you can use Array for storing data when you wish to gain performance benefit, but any properties about the elements should be stated in terms of <code>a.toList</code>, not <code>a</code> itself. Because <code>List</code> is a logical model of <code>Array</code>. And if you need to do induction on array, it indicates you made an error of not using <code>a.toList</code>.</p>",
        "id": 565096790,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766463637
    },
    {
        "content": "<p>It might be potentially useful to maybe use induction when the motive is not Prop? But I think all reasonable cases should be covered by other API, like iterators, fold etc.</p>",
        "id": 565097062,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766463937
    },
    {
        "content": "<p>This was also discussed in <a class=\"message-link\" href=\"/#narrow/channel/113488-general/topic/Alternative.20induction.20principle.20for.20Arrays/near/527744607\">#general &gt; Alternative induction principle for Arrays @ ðŸ’¬</a></p>",
        "id": 565104889,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1766471855
    },
    {
        "content": "<p>And <a class=\"message-link\" href=\"/#narrow/channel/113489-new-members/topic/MapM.20for.20List.2EVector/near/564788785\">#new members &gt; MapM for List.Vector @ ðŸ’¬</a></p>",
        "id": 565104910,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1766471871
    },
    {
        "content": "<p>I'd lean towards saying that we should have the <code>Array.induction</code> API to prevent wasted time discussing this repeatedly, but the docstring should say something like</p>\n<blockquote>\n<p>Note that using this to construct data is very inefficient, consider using ... instead.</p>\n</blockquote>\n<p>My guess is also that this is still a handy thing to have as an induction principle to construct proofs.</p>",
        "id": 565104999,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1766471942
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/270676-lean4/topic/Induction.20eliminator.20for.20.60Array.60.20and.20.60Vector.60/near/565096400\">said</a>:</p>\n<blockquote>\n<p>This API is intentionally absent as my experience so far suggests that wanting it indicates an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> problem. Happy to be convinced otherwise.</p>\n</blockquote>\n<p>What do you mean by an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> problem?</p>\n<p>I think what I would say is that I've found it to be needed very naturally when proving things about a program that uses Vector. Specifically reducing down to List would have just confused the situation: what I wanted was to prove properties about operators on Vectors that took a Vector and performed an operation on another Vector (of a different length). I suppose it's hard to convince you that this was natural: but please believe me when I say that I tried doing it the decomposition way and it was really annoying.</p>\n<p>I am less sure about the need here for Array. The main reason you would want it is, as I say, because outside of Mathlib the tools for nicely doing proofs from the right on Lists do not exist. I don't actually think List and Array have the same logical model for this reason: the natural way to construct an Array is from the right (by pushing new elements), whereas the natural way to construct a list is from the left (by cons-ing new elements).</p>\n<p>I will say that all of this is about proofs. I think Eric is right that using this to construct data would be an obvious trap and so it's possible we should <em>only</em> have this for Prop as deliberate design. I do think it's worth people understanding that it's also wrong to construct an Array using a List, or rather you can do so but it has an O(n) cost.</p>",
        "id": 565110103,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766475285
    },
    {
        "content": "<p>(I will say, and this is a parenthetical remark deliberately, that the fact that Array appears to just be a wrapper around List, and this is true logically but NOT true computationally, I do regard as a much more perilous foot gun. It gives you the property that xs[k] = xs.toList[k], but as I say I think this is the trap: Array has the property that finding its size is O(1) (I think?), and adding and removing elements from the end is cheap and adding and removing elements further from the end is more expensive because you have to move memory. But that is the opposite of how List works, where cons-ing adds to the start, and appending elements to the end are expensive.</p>\n<p>Personally I would love a world in which Array was much more tightly sealed, and it was clear that extracting it to a List, performing to toList operation, would give you a list that was the <em>reverse</em> of the list that the type is logically constructed from - because that is I think closer to the computational behaviour (it is O(n) to convert to/from a list to an array). But obviously this would constitute a major design change, and I did not wake up this morning and find myself transformed into Leo de Moura, so I don't expect that change to happen.)</p>",
        "id": 565110840,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766475706
    },
    {
        "content": "<p>Oh: I will say that I have found using the above principle on Vector more well-behaved than inducting on the length (which you would think would behave much the same, but essentially lemmas that give the behaviour of operations on Vectors of the form xs.push x tend to be a bit nicer in practice than operations on Vectors of length <code>n + 1</code>).</p>",
        "id": 565111080,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766475821
    },
    {
        "content": "<p>Having fairly long-term experience with working with Vectors down in the armpit if where maths meets computation, I think that's shaped my views here: I will say I was perfectly fine without these principles for some time, but recently adding them during a refactor to grind-ify a lot of my proofs saved me a frankly hilarious amount of proof lines when proving something about a somewhat tricky fold.</p>",
        "id": 565111387,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766475964
    },
    {
        "content": "<p>Hm, I've just noticed that we have e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Array/Bootstrap.html#Array.foldl_toList\">Array.foldl_toList</a> as a simp lemma. If we want to go via the route of proving properties on array by reducing to list, than that simp lemma should be in the other direction.</p>",
        "id": 565111884,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766476270
    },
    {
        "content": "<p>That might be one reason, why you find it easier to prove things directly on Array?</p>",
        "id": 565111957,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766476303
    },
    {
        "content": "<p>I don't think that's a lemma I used but it does look pretty weird to me.</p>",
        "id": 565112013,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766476333
    },
    {
        "content": "<p>Oh no it's just how it's appearing on my phone. No I didn't use that, but it is an example of the way the library points you away from breaking down to List. Which is consistent with the general principle that breaking something down into its construction is a code smell (and I believe this quite strongly): if you've defined a type made up of another, you probably did that for a good reason, so if that was a good reason don't break it up. If you have a program about Arrays, and you are reasoning on it using Arrays, why break it down? As I've already said, it'll be backwards anyway, and because Core lacks useful facility to reason backwards on a List you might just get yourself into a pickle. Why do it?</p>",
        "id": 565112454,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766476555
    },
    {
        "content": "<p>Would you like to share one of the tricky theorems you had, for testing?</p>",
        "id": 565112510,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766476582
    },
    {
        "content": "<p>Well currently I'm on the way to work - so I can't get easily. I would be happy to but I'm a bit concerned it might be quite difficult to extract it from the context!</p>",
        "id": 565112593,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766476624
    },
    {
        "content": "<p>I will say that having looked up <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> problems, I don't think I believe in them - but I think that might be my bias against ESR in all forms showing.</p>",
        "id": 565112732,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766476683
    },
    {
        "content": "<p>If it's not a problem you can share a link to repo or whole file.</p>",
        "id": 565112756,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766476692
    },
    {
        "content": "<p>Oh, very happy to do that.</p>",
        "id": 565112796,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766476711
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/270676-lean4/topic/Induction.20eliminator.20for.20.60Array.60.20and.20.60Vector.60/near/565112454\">said</a>:</p>\n<blockquote>\n<p>Oh no it's just how it's appearing on my phone. No I didn't use that, but it is an example of the way the library points you away from breaking down to List. Which is consistent with the general principle that breaking something down into its construction is a code smell (and I believe this quite strongly): if you've defined a type made up of another, you probably did that for a good reason, so if that was a good reason don't break it up. If you have a program about Arrays, and you are reasoning on it using Arrays, why break it down? As I've already said, it'll be backwards anyway, and because Core lacks useful facility to reason backwards on a List you might just get yourself into a pickle. Why do it?</p>\n</blockquote>\n<p>If you're reasoning about Array you should break it down to List, because List is meant to be a semantical model of an Array.</p>",
        "id": 565112860,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766476732
    },
    {
        "content": "<p>Right - but as I explained above because reasoning on List naturally happens on the left but you probably aren't wanting to reason about Array on the left, in practice I do not find that to be true.</p>",
        "id": 565113023,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766476789
    },
    {
        "content": "<p>Also, I'm more likely to be working on Vector, and that's frankly two steps removed from an ordinary List.</p>",
        "id": 565113401,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766476944
    },
    {
        "content": "<p>I don't feel it's overstating things to say that if the intent is that you never prove things about Array and only prove things about List, then I think there's many lemmas and hints and simplifications which feel constructed wrong as a joke.</p>",
        "id": 565113579,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766477050
    },
    {
        "content": "<p><a href=\"https://github.com/linesthatinterlace/controlbits/tree/master/CBConcrete\">https://github.com/linesthatinterlace/controlbits/tree/master/CBConcrete</a></p>",
        "id": 565113602,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766477070
    },
    {
        "content": "<p>This would be my repo</p>",
        "id": 565113643,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766477082
    },
    {
        "content": "<p>Hm, maybe <code>toList</code> should return the reverse of an array, so thus <code>push</code> is translated directly to <code>cons</code>. Or we should improve List API so that it can work well backwards too. There's a lot of symmetry between <code>List.cons</code> and <code>List.concat</code>, but iirc there are lemmas about cons that are missing an equivalent statement about concat.</p>",
        "id": 565113655,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766477086
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/270676-lean4/topic/Induction.20eliminator.20for.20.60Array.60.20and.20.60Vector.60/near/565113655\">said</a>:</p>\n<blockquote>\n<p>Hm, maybe <code>toList</code> should return the reverse of an array, so thus <code>push</code> is translated directly to <code>cons</code>. Or we should improve List API so that it can work well backwards too. There's a lot of symmetry between List.cons and List.concat, but iirc there are lemmas about cons that are missing an equivalent statement about concat.</p>\n</blockquote>\n<p>The former is what I feel should be the case, yes - but as I say it seems such a major change that I don't expect it to ever happen. </p>\n<p>There is a lot of symmetry between List.cons and List.concat, although note that the preferred spelling of xs.concat x is xs ++ [x] - as in, that is what it simplifies to. Now I disagree with that too but I've long accepted that's not an argument I can win.</p>",
        "id": 565113825,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766477182
    },
    {
        "content": "<p>I think it would be nicer to use List.concat because passing to append can often lead to bringing in a bunch of append-logic that you may not actually want - like notably we do not automatically simplify as.push x to as ++ [x] for Arrays.</p>",
        "id": 565114019,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766477269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/270676-lean4/topic/Induction.20eliminator.20for.20.60Array.60.20and.20.60Vector.60/near/565113579\">said</a>:</p>\n<blockquote>\n<p>I don't feel it's overstating things to say that if the intent is that you never prove things about Array and only prove things about List, then I think there's many lemmas and hints and simplifications which feel constructed wrong as a joke.</p>\n</blockquote>\n<p>I see that now too. Tbh, it looks like what I wrote here <a href=\"#narrow/channel/270676-lean4/topic/Induction.20eliminator.20for.20.60Array.60.20and.20.60Vector.60/near/565096790\">#lean4 &gt; Induction eliminator for &#96;Array&#96; and &#96;Vector&#96; @ ðŸ’¬</a> is completely wrong, and the intention of the API is to use Array for proofs as well. In which case, we should go full commitment in this direction, and we should have induction principle for Array. Maybe <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> could shed more light on this, because now, I don't understand why he believes that API should be absent.</p>",
        "id": 565114180,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766477357
    },
    {
        "content": "<p>I'm trying not to be too prescriptive in my opinions here - I don't pretend that my way is the best way or anything. But I am not new to this either and my control bits work has been a pretty extensive exercise in trying to produce a theory on a thing - and while I'm not sure there's a place for that work in the libraries, I have generated a bunch of opinions and lemmas which I am slowly trying to filter out and suggest for inclusion into the libraries where appropriate.</p>",
        "id": 565114286,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766477427
    },
    {
        "content": "<p>Kim uses she/her, I thought?</p>",
        "id": 565114307,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766477439
    },
    {
        "content": "<p>Apologies if I have that wrong.</p>",
        "id": 565114333,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766477453
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/270676-lean4/topic/Induction.20eliminator.20for.20.60Array.60.20and.20.60Vector.60/near/565114180\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/270676-lean4/topic/Induction.20eliminator.20for.20.60Array.60.20and.20.60Vector.60/near/565113579\">said</a>:</p>\n<blockquote>\n<p>I don't feel it's overstating things to say that if the intent is that you never prove things about Array and only prove things about List, then I think there's many lemmas and hints and simplifications which feel constructed wrong as a joke.</p>\n</blockquote>\n<p>I see that now too. Tbh, it looks like what I wrote here <a href=\"#narrow/channel/270676-lean4/topic/Induction.20eliminator.20for.20.60Array.60.20and.20.60Vector.60/near/565096790\">#lean4 &gt; Induction eliminator for &#96;Array&#96; and &#96;Vector&#96; @ ðŸ’¬</a> is completely wrong, and the intention of the API is to use Array for proofs as well. In which case, we should go full commitment in this direction, and we should have induction principle for Array. Maybe <span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> could shed more light on this, because now, I don't understand why he believes that API should be absent.</p>\n</blockquote>\n<p>I think to be fair to you what the API is is ambivalent. Which arguably is a perfectly fine approach - it's nice to give people different ways of doing things - but necessarily does create more surface area.</p>",
        "id": 565114457,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766477523
    },
    {
        "content": "<p>Incidentally, while I am in general not a fan of Mathlib's List.Vector, it does fill a semantic niche: if you think of List as representing a fundamentally static value (whereas Vector and Array are dynamic), then actually the context I was using Vector (you want to look for condFlipBit in my repo) is more static than dynamic (I'm operating on a Vector - it's definitely dynamic - but using values in a Vector that is relatively more static - though because that vector could result from a dynamic process I have stored it that way). I might have used List.Vector there I suppose, because that's I think the only tool that semantically represents static arrays of a fixed size?</p>\n<p>As it is, I did very much want to make sure things were as performant as I could manage (and I still have ways I could improve that) so I did use Vector to avoid any hidden List traps, anyway.</p>",
        "id": 565115408,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766478047
    },
    {
        "content": "<p>The context, very shortly, is that you have some vector of values xs, and some vector of bits bs, which might be half the length but that isn't strictly necessary. You fold along bs, and for every bit in bs, you conditionally swap two values in xs, based on the index you are at. In this way the vector of bits acts to permute the members of the vector of values xs, but desirable for suitable types of value (specifically unsigned integers!) you can construct this swap operation in a way that doesn't branch on the value of the bits (not in Lean, I don't think we have a way to model that, but this motivates the construction). This means that you perform the permutation of the value vector in constant time.</p>",
        "id": 565115846,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766478279
    },
    {
        "content": "<p>Essentially this work is about the algorithm/formula that lets you decompose an arbitrary permutation into a sequence of such twiddles</p>",
        "id": 565115925,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766478308
    },
    {
        "content": "<p>And hence lets you permute arbitrary value vectors in constant time.</p>",
        "id": 565115970,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766478331
    },
    {
        "content": "<p>Don't get distracted by this though, I just thought a little context might help. This is something I've been working on on and off for a good while, it was from my thesis, but I'm currently working with a PhD student to finally publish our work on some speed improvements to the algorithm that also happily make the verification elements easier to work with by removing a very much complex recursion in favour of a straightforward iterative loop.</p>",
        "id": 565116246,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766478452
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/270676-lean4/topic/Induction.20eliminator.20for.20.60Array.60.20and.20.60Vector.60/near/565115408\">said</a>:</p>\n<blockquote>\n<p>I might have used List.Vector there I suppose, because that's I think the only tool that semantically represents static arrays of a fixed size?</p>\n</blockquote>\n<p>Well, semantically <code>List.Vector</code> and <code>Vector</code> are the same. Just like <code>List</code> and <code>Array</code> are. The difference is mainly (and in ideal world should be the only) in compiled program. <code>List.Vector</code> doesn't have a constant time arbitrary access I think? So depending on how you use it, <code>Vector</code> can be significantly faster.</p>",
        "id": 565116961,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766478814
    },
    {
        "content": "<p>I think essentially I regard the compiled behaviour as part of the semantics. I realise that might not be the technical definition.</p>",
        "id": 565117094,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766478884
    },
    {
        "content": "<p>But like, if one thing represents \"dynamic C-style arrays\" and one thing represents \"functional-programming style inductive lists\", then these are to me different things that I should think about as different. The fact that they are naturally equivalent to each other notwithstanding.</p>",
        "id": 565117259,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766478946
    },
    {
        "content": "<p>I should probably call it logical model, instead of semantics, to be more clear.</p>",
        "id": 565117280,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766478956
    },
    {
        "content": "<p>And by which, I mean the kernel representation.</p>",
        "id": 565117352,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766478994
    },
    {
        "content": "<p>Right, for sure.</p>",
        "id": 565117400,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766479022
    },
    {
        "content": "<p>When you get down to the kernel representation I agree there's no distinction between Array and List, but we do care about the difference. That's why, for instance, Array.cons does not, I think, exist? It is a natural operation on the underlying list but not on the Array it represents.</p>",
        "id": 565117517,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766479070
    },
    {
        "content": "<p><code>Array.cons</code> isn't useful in programming, because it would have bad performance, and the fact that if someone uses <code>Array</code> they already care about performance. And because as you said, most reasoning on Array happens backward, there was no need for it in proofs either.</p>",
        "id": 565118011,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766479333
    },
    {
        "content": "<p>Yeah 100% - I think it's good that it doesn't exist for that reason!</p>",
        "id": 565118142,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766479387
    },
    {
        "content": "<p>And that's why I think I'm persuaded that the eliminators under discussion would not be good as general-purpose eliminators - because I don't think you'd want people to use them in programming.</p>",
        "id": 565118273,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766479457
    },
    {
        "content": "<p>Oh, wait, there's <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Array/Bootstrap.html#Array.toList_push\">Array.toList_push</a>, which rewrites <code>(xs.push x).toList = xs.toList ++ [x]</code>. This is the direction I would want, it replaces array operation <code>Array.push</code> with list operation <code>++</code>. On the other hand there's <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Array/Bootstrap.html#Array.foldr_toList\">Array.foldr_toList</a> which rewrites <code>List.foldr f init xs.toList = foldr f init xs</code>, and this is completely opposite. It replaces list operation<code>List.foldr</code> with array operation <code>Array.foldr</code>. I don't see what is the reasoning behind this.</p>",
        "id": 565126572,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766483312
    },
    {
        "content": "<p><code>toList_push</code> makes sense to me though: at the stage you have applied <code>toList</code>, that is the conversion you want to make (as xs ++ [a] is the simp-normal form of concat on Lists). But the latter one <em>also</em> makes sense to me - if you are folding over an array converted to a list, you could have just folded over the Array.</p>",
        "id": 565126765,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766483397
    },
    {
        "content": "<p>I don't see that these are contradictory - <em>if</em> you convert to List, you should use the former, but if you have converted to List and are folding, really you should just have folded over the Array.</p>",
        "id": 565126924,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766483471
    },
    {
        "content": "<p>I have a question for you: which do you consider the better extension lemma for <code>Array</code>, <code>Array.ext</code> or <code>Array.ext'</code>?</p>",
        "id": 565126968,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766483494
    },
    {
        "content": "<p>Well, any direction can make sense in some context. But for simp we should simplify in the direction where there's more useful lemmas to be found. That's why I think we should always simplify to list operations.</p>",
        "id": 565126970,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766483495
    },
    {
        "content": "<p>But there are a host of useful lemmas to be found for folding on Arrays!</p>",
        "id": 565127000,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766483513
    },
    {
        "content": "<p>Consider <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Array/Lemmas.html#Array.foldr_push\">Array.foldr_push</a></p>",
        "id": 565127078,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766483550
    },
    {
        "content": "<p>Or indeed even something more exotic like <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Array/Lemmas.html#Array.foldl_induction\">Array.foldl_induction</a></p>",
        "id": 565127110,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766483568
    },
    {
        "content": "<p>(Sorry if my replies are a little slow - I am finding the docs website very slow this morning.)</p>",
        "id": 565127459,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766483725
    },
    {
        "content": "<p>But if you replace <code>a.push</code> with <code>a.toList.concat</code> than you can apply <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/List/Basic.html#List.foldr_concat\">List.foldr_concat</a> instead of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Array/Lemmas.html#Array.foldr_push\">Array.foldr_push</a>.</p>\n<p>If we have an API for Array as complete as for List, than we shouldn't simplify Array operations to List operations. But, we could also choose to not have any lemmas for Array at all, and prove everything via lists. This might make proving things about Arrays slightly harder in some cases, but I think in most cases this wouldn't make a difference, as long as you make sure to start your proofs with <code>dsimp</code> to rewrite all arrays to lists. Though I'm not too sure about how much of \"slightly harder\" this would be. And the important question is whether it's worth further working on and maintaining API for Array.</p>",
        "id": 565128239,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766484051
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/270676-lean4/topic/Induction.20eliminator.20for.20.60Array.60.20and.20.60Vector.60/near/565128239\">said</a>:</p>\n<blockquote>\n<p>But if you replace <code>a.push</code> with <code>a.toList.concat</code> than you can apply <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/List/Basic.html#List.foldr_concat\">List.foldr_concat</a> instead of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Array/Lemmas.html#Array.foldr_push\">Array.foldr_push</a>.</p>\n<p>If we have an API for Array as complete as for List, than we shouldn't simplify Array operations to List operations. But, we could also choose to not have any lemmas for Array at all, and prove everything via lists. This might make proving things about Arrays slightly harder in some cases, but I think in most cases this wouldn't make a difference, as long as you make sure to start your proofs with <code>dsimp</code> to rewrite all arrays to lists. Though I'm not too sure about how much of \"slightly harder\" this would be. And the important question is whether it's worth further working on and maintaining API for Array.</p>\n</blockquote>\n<p>Remember, we don't use <code>List.concat</code>, despite calling it that in theorem names <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 565128417,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766484124
    },
    {
        "content": "<p>You would have to replace <code>a.push</code> with <code>(a.toList ++ [Â·])</code> as that is the normal form.</p>",
        "id": 565128512,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766484165
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/270676-lean4/topic/Induction.20eliminator.20for.20.60Array.60.20and.20.60Vector.60/near/565126968\">said</a>:</p>\n<blockquote>\n<p>I have a question for you: which do you consider the better extension lemma for <code>Array</code>, <code>Array.ext</code> or <code>Array.ext'</code>?</p>\n</blockquote>\n<p>I would say <code>Array.ext'</code>.</p>",
        "id": 565128906,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766484322
    },
    {
        "content": "<p>That makes sense given your stated perspective! It is a little strange then that it is <code>ext'</code> and not <code>ext</code>. And it is <code>Array.ext</code> that is tagged as an ext lemma by... somewhere in the libraries, it might be a choice Mathlib makes.</p>",
        "id": 565129095,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766484408
    },
    {
        "content": "<p>Moreover I would argue that most of the time it is the one that is more useful...</p>",
        "id": 565129170,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766484434
    },
    {
        "content": "<p>Yeah, most of the API suggests, that it is what mathlib choses. In which case, I think we should have induction eliminator.</p>",
        "id": 565129248,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766484476
    },
    {
        "content": "<p>You could reasonably argue it should only be in mathlib - I would make a case for Batteries at least (though I will admit I am not clear on the borderline).</p>",
        "id": 565129335,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766484510
    },
    {
        "content": "<p>But I think it is a natural thing you would want to do <em>in programming</em> - at least sometimes.</p>",
        "id": 565129375,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766484528
    },
    {
        "content": "<p>I should say, that my perspective might come from my software verification background. In software verification there's usually clear distinction between data, and the logical model of it.</p>",
        "id": 565129497,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766484578
    },
    {
        "content": "<p>My background is... a whole mess of things. Which probably reflects my tendency to have a whole mess of approaches :)</p>",
        "id": 565129552,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766484607
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/270676-lean4/topic/Induction.20eliminator.20for.20.60Array.60.20and.20.60Vector.60/near/565126572\">said</a>:</p>\n<blockquote>\n<p>Oh, wait, there's <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Array/Bootstrap.html#Array.toList_push\">Array.toList_push</a>, which rewrites <code>(xs.push x).toList = xs.toList ++ [x]</code>. This is the direction I would want, it replaces array operation <code>Array.push</code> with list operation <code>++</code>. On the other hand there's <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Array/Bootstrap.html#Array.foldr_toList\">Array.foldr_toList</a> which rewrites <code>List.foldr f init xs.toList = foldr f init xs</code>, and this is completely opposite. It replaces list operation<code>List.foldr</code> with array operation <code>Array.foldr</code>. I don't see what is the reasoning behind this.</p>\n</blockquote>\n<p>Yeah, I see the reasoning now. The point is, that if you explicitly use <code>Array.toList</code>, only than will simplifier simplify array operations to list operations.</p>",
        "id": 565130674,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766485112
    },
    {
        "content": "<p>Yeah I totally agree - but <em>only</em> when you do that, you have to make that choice.</p>",
        "id": 565130736,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766485145
    },
    {
        "content": "<p>For <code>Vector</code>, I would argue that Vector.ext is the only sensible extensionality lemma, myself - it just makes very little sense to me to drop that back to Lists.</p>",
        "id": 565130892,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766485197
    },
    {
        "content": "<p>essentially, I prefer to argue that two vectors or arrays are equal by saying \"well they have the same length\" (don't need this for vectors) and \"the element at each index is the same\".</p>",
        "id": 565130987,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766485235
    },
    {
        "content": "<p>Because if I argue instead \"they are the same because the two lists are the same\", how will I argue the two lists are the same? Almost certainly by... comparing the lengths and the value at indexes!</p>",
        "id": 565131105,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766485273
    },
    {
        "content": "<p>I agree with you. I think my only point towards my approach is that almost all of Array API is duplicated code from List. Ideally, I would want for this duplication to not be necessary. But, unfortunately, it does make API easier for its consumers. I do hope that as the Lean languages gets better, notably automation tactics like <code>grind</code>, this duplication would end up not having any benefit. I'll still try to use your repo to check how much of an benefit it actually is.</p>",
        "id": 565131834,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766485597
    },
    {
        "content": "<p>I can't say that all the code is there is definitely my best :) - I try to keep it up to date and improve it but it has grown over time.</p>",
        "id": 565131926,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766485630
    },
    {
        "content": "<p>When I started this repo, <code>Vector</code> didn't exist - indeed at that stage I defined it for myself and had to remove it when it was officially added, but happily I had named all my lemmas the sensible thing so I could mostly strip out with no pain.</p>",
        "id": 565132014,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766485672
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/270676-lean4/topic/Induction.20eliminator.20for.20.60Array.60.20and.20.60Vector.60/near/565129095\">said</a>:</p>\n<blockquote>\n<p>That makes sense given your stated perspective! It is a little strange then that it is <code>ext'</code> and not <code>ext</code>. And it is <code>Array.ext</code> that is tagged as an ext lemma by... somewhere in the libraries, it might be a choice Mathlib makes.</p>\n</blockquote>\n<p>We made a mistake here, namely, Array it not in Mathlib. It's in Std.</p>",
        "id": 565151791,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766494463
    },
    {
        "content": "<p>Yes, but I am not sure where the @[ext] attribute is :)</p>",
        "id": 565151834,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766494484
    },
    {
        "content": "<p><code>@[ext]</code> is also core (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.Attr.ext#doc\">docs#Lean.Parser.Attr.ext</a> in Init.Ext)</p>",
        "id": 565152069,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1766494569
    },
    {
        "content": "<p>Yes, what I mean is I don't know where the @ext] attribute gets attached to Array.ext</p>",
        "id": 565152186,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766494610
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Init/Ext.lean#L85-L85\">https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Init/Ext.lean#L85-L85</a></p>",
        "id": 565152244,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766494630
    },
    {
        "content": "<p>However the answer is indeed Std!</p>",
        "id": 565152266,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766494636
    },
    {
        "content": "<p>It is in Init.Ext</p>",
        "id": 565152284,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766494643
    },
    {
        "content": "<p>Thanks for that, that is a sensible place to look.</p>",
        "id": 565152357,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1766494671
    }
]