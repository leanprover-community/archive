[
    {
        "content": "<p>I have been messing around with for loops and trying to get them as fast as possible. I went a bit too far as I'm matching C++ speed which I find a bit suspicious.</p>\n<p>The test is to compute triangular number the dumb way:  <code>T(n) = ∑ i∈[0:n], ∑ j∈[0:i], 1</code>.</p>\n<p>The naive way, using Lean's built in for loop: (the <code>IO</code> monad is there to prevent compile from computing it at compile time)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">triangularNumberNaive</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">USize</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">USize</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"bp\">$</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">sum</span> <span class=\"o\">:</span> <span class=\"n\">USize</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">n.toNat</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n    <span class=\"n\">for</span> <span class=\"n\">_</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n      <span class=\"n\">sum</span> <span class=\"o\">:=</span> <span class=\"n\">sum</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n  <span class=\"n\">pure</span> <span class=\"n\">sum</span>\n</code></pre></div>\n<p>Computing <code>T(100 000)</code> takes  <code>~10s</code> which is not great.</p>\n<p>So I have decided to implemented my own version of for loop which does not use big integers but <code>USize</code> instead. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">triangularNumberForIn</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">USize</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">USize</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"bp\">$</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">sum</span> <span class=\"o\">:</span> <span class=\"n\">USize</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">fullRange</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n    <span class=\"n\">for</span> <span class=\"n\">_</span> <span class=\"k\">in</span> <span class=\"n\">fullRange</span> <span class=\"n\">i.1</span> <span class=\"k\">do</span>\n      <span class=\"n\">sum</span> <span class=\"o\">:=</span> <span class=\"n\">sum</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n  <span class=\"n\">pure</span> <span class=\"n\">sum</span>\n</code></pre></div>\n<p>Where <code>fullRange n</code> just indicates the range <code>[0:n]</code> for some <code>n : USize</code>. </p>\n<p>This version can compute <code>T(1 000 000 000)</code> in <code>~250ms</code>. Which is surprisingly fast, identical implementation in C++ takes <code>~700ms</code>(with <code>g++</code>) or <code>~150ms</code>(with clang). </p>\n<p>I have also implemented fold operation over a range on <code>USize</code> to see if I can squeeze even more speed by not allowing early return from the for loop, but I didn't get any significant speed up. In fact, monadic version of the fold takes double the time for some reason.</p>\n<p>If you want to mess around with it, I have set up a github repo: <a href=\"https://github.com/lecopivo/ForLoopSpeed\">https://github.com/lecopivo/ForLoopSpeed</a></p>\n<p>I'm just sharing it as I find it interesting that you can go that fast.</p>",
        "id": 351207036,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1681966428
    },
    {
        "content": "<p>FYI compilers know the formula for the sum of triangular numbers, so you can get some really impossible looking speedups if you aren't careful</p>",
        "id": 351207586,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681966744
    },
    {
        "content": "<p>Ahh I was a bit worried about hitting some crazy optimization. Maybe I should make it a bit more complicated.</p>",
        "id": 351207644,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1681966800
    },
    {
        "content": "<p>the easiest way to find out if this happened is to look at the generated assembly to see if it still has a loop in it</p>",
        "id": 351207647,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681966801
    },
    {
        "content": "<p>I think it optimizes away one of the for loops <a href=\"https://godbolt.org/z/51d9c37o5\">https://godbolt.org/z/51d9c37o5</a>. But the lean code must be doing the same thing, which is nice.</p>",
        "id": 351208328,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1681967183
    },
    {
        "content": "<p>When I change the inner loop computation to something more complicated like <code>sum += sin(i) + cos(j)</code> then I'm getting the exact same speed as C++.</p>",
        "id": 351209977,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1681967888
    },
    {
        "content": "<p>I would expect that for loop code to produce much the same result as C++ (after optimizing) so I take the similar speeds as a good sign. Well-written low-level Lean can easily match C/C++.</p>",
        "id": 352102181,
        "sender_full_name": "Mac Malone",
        "timestamp": 1682271469
    },
    {
        "content": "<p>I agree with @mac but I think the key in this case is using USize instead of Nat. Small Nat are conveniently represented the same as USize 2*n+1, which never conflicts with a big num pointer because of pointer alignment. But that translation has a cost that shows most for simple operations. (For example, adding two raw small nats has an unwanted carry from the unit bits which must be corrected either before or after.) Compilers will try to do a great job optimizing these details, but they can only do so much.</p>",
        "id": 352122003,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1682283687
    },
    {
        "content": "<p>Yes, using <code>USize</code> did it and I had to mark few things with inline, but unfortunately it was more or less trial and error. I found it hard to predict what needs to be inlined or not.</p>",
        "id": 352124255,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1682285748
    }
]