[
    {
        "content": "<p>For any function <code>f : (x : A) → B x</code>, lambda abstraction <code>fun x =&gt; f x</code> and <code>f</code> are equal.</p>\n<p>This equality does not require function extensionality and appears to follow from the definition.</p>\n<p>But <code>f</code> and <code>fun x =&gt; f x</code> are both normal-form.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">f</span>\n<span class=\"cm\">-/</span>\n<span class=\"k\">#reduce</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">fun x =&gt; f x</span>\n<span class=\"cm\">-/</span>\n<span class=\"k\">#reduce</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Why are these equal?</p>",
        "id": 463400770,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1724073104
    },
    {
        "content": "<p>eta reduction</p>",
        "id": 463403807,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724074039
    },
    {
        "content": "<p>they are equal if your system accepts the eta rule</p>",
        "id": 463403910,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724074056
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/why.20function.20and.20its.20lambda.20abstraction.20are.20equal.3F/near/463403807\">said</a>:</p>\n<blockquote>\n<p>eta reduction</p>\n</blockquote>\n<p>in other words, they're definitionally equal according to Lean's underlying core language, so you're right, it follows from definition! (that's what the core does, check these kinds of equalities)</p>",
        "id": 463404450,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1724074188
    },
    {
        "content": "<p>Thank you!!!</p>",
        "id": 463451669,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1724085039
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"626349\">Asei Inoue</span> has marked this topic as resolved.</p>",
        "id": 463451679,
        "sender_full_name": "Notification Bot",
        "timestamp": 1724085042
    },
    {
        "content": "<p>Eta doesn't show up in Lean's reduction (in particular, its whnf algorithm), but it shows up in the defeq algorithm. It has a step where if it sees the unification problem <code>(fun x =&gt; e) =?= g</code> then it turns it into <code>(fun x =&gt; e) =?= (fun x =&gt; g x)</code>, and then from there it creates a local variable <code>x</code> and continues with <code>e =?= g x</code>.</p>\n<p>If for example it's <code>(fun x =&gt; f x) =?= f</code>, then in that intermediate step it's <code>(fun x =&gt; f x) =?= (fun x =&gt; f x)</code>, and both sides are the same, so it judges it as being definitional equal.</p>",
        "id": 463464622,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724088439
    }
]