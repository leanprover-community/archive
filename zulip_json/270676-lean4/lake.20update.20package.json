[
    {
        "content": "<p>Is it possible to use lake to update a specific dependency? <code>lake update</code> updates everything. Of course, I could <code>git pull</code> in the correct folder and manually change the lake manifest, but this can't be the preferred workflow.</p>",
        "id": 364606627,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1686238979
    },
    {
        "content": "<p>You can specify exact commits in your lakefile <code>require</code> statement if you do not want the package updating. This feature is also on the TODO list as <a href=\"https://github.com/leanprover/lake/issues/148\">lake#148</a> (feel free to give it an upvote).</p>",
        "id": 364640385,
        "sender_full_name": "Mac Malone",
        "timestamp": 1686247172
    },
    {
        "content": "<p>Fwiw I strongly disliked this behaviour of Lake originally but as Mac says, lakefiles should really be pointing at a specific version of a dependency rather than <code>master</code>. The only missing feature, I think, is a versioning scheme so we can point at a range of semver-compatible versions rather than a particular commit or git tag.</p>",
        "id": 364676668,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1686257713
    },
    {
        "content": "<p>well doing that would basically make <code>lake update</code> impossible unless it starts rewriting lean files</p>",
        "id": 364676787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686257763
    },
    {
        "content": "<p>Sorry, I don't understand <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> .</p>",
        "id": 364676904,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1686257802
    },
    {
        "content": "<p>if you have <code>require foo from git \"bla\" @ \"1234abcd\"</code>, then in order for an automated \"update\" action to work it would have to replace the text <code>\"1234abcd\"</code> in the lakefile with the new version</p>",
        "id": 364677080,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686257875
    },
    {
        "content": "<p>I assumed that was the point of having a json manifest in the first place, since lake can rewrite it</p>",
        "id": 364677243,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686257928
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Even in NPM, which has Json package configuration, <code>npm update</code> does not rewrite the configuration.</p>",
        "id": 364677385,
        "sender_full_name": "Mac Malone",
        "timestamp": 1686257983
    },
    {
        "content": "<p>(It only updates the package lockfile within the range of specified permitted versions in the configuration.)</p>",
        "id": 364677519,
        "sender_full_name": "Mac Malone",
        "timestamp": 1686258018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/lake.20update.20package/near/364677080\">said</a>:</p>\n<blockquote>\n<p>if you have <code>require foo from git \"bla\" @ \"1234abcd\"</code>, then in order for an automated \"update\" action to work it would have to replace the text <code>\"1234abcd\"</code> in the lakefile with the new version</p>\n</blockquote>\n<p>Yes exactly, if you have <code>require foo from git \"bla\" @ \"0.2.*\"</code> then <code>lake update</code> can rewrite <code>lake-manifest</code> to any new version of <code>bla</code> within the range <code>0.2.*</code>. Also you are guaranteed no breaking changes (assuming semver correctness etc) on <code>lake update</code> in that case, which would be better than the current case of 'anything goes because we point at <code>master</code>'.</p>",
        "id": 364677553,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1686258028
    },
    {
        "content": "<p>Then if you want to bump in a breaking way, you edit the <code>lakefile</code> to <code>0.3.*</code> or something and manually fix your files.</p>",
        "id": 364677673,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1686258082
    },
    {
        "content": "<p>right, so that would suggest that the current way we are doing it is correct</p>",
        "id": 364677732,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686258103
    },
    {
        "content": "<p>Lake also already sort of supports this, the project just needs to make <code>0.2.*</code>a branch (potentially using the more standard branch name of <code>v0.2.x</code>).</p>",
        "id": 364677804,
        "sender_full_name": "Mac Malone",
        "timestamp": 1686258121
    },
    {
        "content": "<p>It's correct insofar as there is no semver that we could use instead of the current approach, sure.</p>",
        "id": 364677855,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1686258124
    },
    {
        "content": "<p>with <code>\"master\"</code> in the lakefile and <code>lake update</code> determining the exact commit</p>",
        "id": 364677870,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686258127
    },
    {
        "content": "<p>because we have no semver</p>",
        "id": 364677884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686258131
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/270676-lean4/topic/lake.20update.20package/near/364677804\">said</a>:</p>\n<blockquote>\n<p>Lake also already sort of supports this, the project just needs to make <code>0.2.*</code>a branch (potentially using the more standard branch name of <code>v0.2.x</code>).</p>\n</blockquote>\n<p>Is this anything more than a purely syntactic match against a branch name? Because with semver you can specify all kinds of constraints.</p>",
        "id": 364678023,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1686258185
    },
    {
        "content": "<p>and by that token you could read <code>\"master\"</code> as another way to spell <code>vx.y.z</code></p>",
        "id": 364678082,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686258214
    },
    {
        "content": "<blockquote>\n<p>Is this anything more than a purely syntactic match against a branch name? Because with semver you can specify all kinds of constraints.</p>\n</blockquote>\n<p>it's just a syntactic match, but mac is pointing out that you can encode semver in branch update policies</p>",
        "id": 364678234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686258261
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128280\">@Wojciech Nawrocki</span> Yeah, it is just using the branch as a semver channel. While it is true semver supports many more constraints, <code>^x.y</code> and exact versions are definitely the most common (both of which Lake can currently support via branchs, tags, and/or exact commits).</p>",
        "id": 364678279,
        "sender_full_name": "Mac Malone",
        "timestamp": 1686258275
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/lake.20update.20package/near/364678082\">said</a>:</p>\n<blockquote>\n<p>and by that token you could read <code>\"master\"</code> as another way to spell <code>vx.y.z</code></p>\n</blockquote>\n<p>The key difference is that it does not differentiated between significant breaking changes and backwards-compatible patches (which some level of semvar in the later would provide).</p>",
        "id": 364678671,
        "sender_full_name": "Mac Malone",
        "timestamp": 1686258409
    }
]