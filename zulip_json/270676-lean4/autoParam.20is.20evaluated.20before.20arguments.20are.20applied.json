[
    {
        "content": "<p>I find this behaviour very strange. It caused problems here <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/choose.20and.20autoparams/with/564211379\">#general &gt; choose and autoparams</a>. Why Lean expands autoParam so eagerly, even before any argument was applied? Or is this a bug?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">error: could not synthesize default value for parameter 'x._@.test.2021293395._hygCtx._hyg.5' using tactics</span>\n<span class=\"sd\">---</span>\n<span class=\"sd\">error: `grind` failed</span>\n<span class=\"sd\">case grind</span>\n<span class=\"sd\">h : ∀ (k : Nat), True</span>\n<span class=\"sd\">k : Nat</span>\n<span class=\"sd\">⊢ False</span>\n<span class=\"sd\">[grind] Goal diagnostics</span>\n<span class=\"sd\">  [facts] Asserted facts</span>\n<span class=\"sd\">    [prop] ∀ (k : Nat), True</span>\n<span class=\"sd\">  [eqc] True propositions</span>\n<span class=\"sd\">    [prop] ∀ (k : Nat), True</span>\n<span class=\"sd\">---</span>\n<span class=\"sd\">error: unsolved goals</span>\n<span class=\"sd\">h : ∀ (k : Nat), autoParam (k &lt; 0) _auto✝ → True</span>\n<span class=\"sd\">h' : ∀ (k : Nat), True</span>\n<span class=\"sd\">⊢ True</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">error: could not synthesize default value for parameter 'x._@.test.2021293396._hygCtx._hyg.7' using tactics</span>\n<span class=\"sd\">---</span>\n<span class=\"sd\">error: `grind` failed</span>\n<span class=\"sd\">case grind</span>\n<span class=\"sd\">h : ∀ (k k' : Nat), True</span>\n<span class=\"sd\">k k' : Nat</span>\n<span class=\"sd\">⊢ False</span>\n<span class=\"sd\">[grind] Goal diagnostics</span>\n<span class=\"sd\">  [facts] Asserted facts</span>\n<span class=\"sd\">    [prop] ∀ (k k' : Nat), True</span>\n<span class=\"sd\">  [eqc] True propositions</span>\n<span class=\"sd\">    [prop] ∀ (k k' : Nat), True</span>\n<span class=\"sd\">---</span>\n<span class=\"sd\">error: unsolved goals</span>\n<span class=\"sd\">h : ∀ (k k' : Nat), autoParam (k &lt; 0) _auto✝ → True</span>\n<span class=\"sd\">h' : ∀ (k k' : Nat), True</span>\n<span class=\"sd\">⊢ True</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"c1\">-- this works</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">k'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>",
        "id": 564216464,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765967140
    },
    {
        "content": "<p>Currently both opt-params and auto-params are filled in eagerly. You should be able to write <code>have h' := @h</code> to suppress it.</p>\n<p>I agree that it's a little weird for it to apply auto-params if the type depends on one of the regular parameters... Right now the way the logic works is that it elaborates <code>h</code> as <code>fun k =&gt; h k (by grind)</code>, using an \"eta argument\" (by constructing this <code>fun</code>) to get to the auto-param.</p>\n<p>I think this logic makes sense for opt-params, and for consistency it's nice if opt-params and auto-params have the same rule for when they apply. Maybe there's a case for having opt-params delay elaboration if they've got a dependency on a regular parameter, not sure. I'd guess almost all uses of opt-params have a type that depends on nothing, or at most on some implicit parameters. (If you think it's worth trying to change, I'd be very happy if someone analyzed opt-params across Lean, Batteries, Mathlib, and CSLib, to see if my guess is correct!)</p>",
        "id": 564282953,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765986268
    },
    {
        "content": "<p>I think you might be correct about opt-params, but it's hard to imagine auto-param that doesn't have a dependency on arguments.</p>",
        "id": 564355050,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766011266
    },
    {
        "content": "<p>One use case for evaluating eagerly could be this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Here, in the call <code>foo 0</code>, <code>h : 0 ≤ m := by grind</code> is instantiated before <code>m</code>. If it weren't, then it wouldn't have a correct type to pass to <code>List.map</code>.</p>",
        "id": 564355637,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766011602
    },
    {
        "content": "<p>But I think that autoParam without all it's dependencies instantiated is likely to be unprovable in most cases.</p>",
        "id": 564355753,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766011693
    },
    {
        "content": "<p>One thing we could do, is to look at the expected type of partial function application, and decide to instantiate autoParam if the expected type requires it. Otherwise, only instantiate autoParam if either all previous arguments were instantiated, or all dependant arguments were instantiated.</p>",
        "id": 564355880,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766011803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/270676-lean4/topic/autoParam.20is.20evaluated.20before.20arguments.20are.20applied/near/564355050\">said</a>:</p>\n<blockquote>\n<p>I think you might be correct about opt-params, but it's hard to image auto-param that doesn't have a dependency on arguments.</p>\n</blockquote>\n<p>Yeah, I left that part unsaid. The thought is (1) it would be confusing if opt-params and auto-params had different elaboration rules but (2) potentially we can change the rules for opt-params at the same time, if it does not affect anyone.</p>\n<p>Looking at the expected type seems reasonable... but that also feels like an uneasy compromise. It's a big difference in elaboration between whether eta arguments are used or not used. Plus, auto-params are generally for proof arguments, so proof irrelevance means the expected type won't meaningfully depend on them. That said, sometimes people use them for supplying a default value that can't be elaborated ahead of time (e.g. <code>(v : t := by exact default)</code>, if you don't want an <code>[Inhabited t]</code> instance in the type signature).</p>",
        "id": 564356892,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1766012534
    },
    {
        "content": "<p>By expected type, I really only meant to look at, whether the type can be a function or not. So you just instantiate the argument, if the expected type cannot be a function. In this example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The expected type of <code>foo 0</code> is <code>?m.0 → ?m.1</code>, while the type of <code>foo 0</code> is <code>(m : Nat) → (_ : 0 ≤ m := by grind) → Nat</code>. Hm, I guess it's still hard, because the type checker would need to realize that <code>?m.1</code> cannot a function, but that's only because there's no instance of <code>OfNat</code> for function.</p>",
        "id": 564357357,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766012844
    },
    {
        "content": "<p>If we choose an approach of instantiating optParam and autoParam as soon as all dependant arguments are instantiated, and your assumption that optParams are usually non-dependant, then optParams won't be affected in this usual cases.</p>",
        "id": 564357563,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766012976
    },
    {
        "content": "<p>Maybe that could be a valid example of optParam that depends on the arguments?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">error: typeclass instance problem is stuck</span>\n<span class=\"sd\">  Inhabited ?m.3</span>\n\n<span class=\"sd\">Note: Lean will not try to resolve this typeclass instance problem because the type argument to `Inhabited` is a metavariable. This argument must be fully determined before Lean will try to resolve the typeclass.</span>\n\n<span class=\"sd\">Hint: Adding type annotations and supplying implicit arguments to functions can give Lean more information for typeclass resolution. For example, if you have a variable `x` that you intend to be a `Nat`, but Lean reports it as having an unresolved type like `?m`, replacing `x` with `(x : Nat)` can get typeclass resolution un-stuck.</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>But in this case you do only want to instantiate the optParam, after <code>α</code> and <code>_ : Inhabited α</code> are instantiated. Otherwise, you get the error above.</p>",
        "id": 564358018,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766013294
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/autoParam.20is.20evaluated.20before.20arguments.20are.20applied/near/564282953\">said</a>:</p>\n<blockquote>\n<p>(If you think it's worth trying to change, I'd be very happy if someone analyzed opt-params across Lean, Batteries, Mathlib, and CSLib, to see if my guess is correct!)</p>\n</blockquote>\n<p>Do you think there's still a need to analyze this, with the proposal of only expanding opt-param/auto-param, when all other dependant arguments that the type of an param depends on are (syntactically) instantiated, and function term doesn't use <code>@</code> to explicitly disable this?</p>",
        "id": 564378627,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766031713
    }
]