[
    {
        "content": "<p>I want to add <code>cases'</code> and <code>induction'</code> to the technical debt counter at <a href=\"https://github.com/leanprover-community/mathlib4/pull/21820\">#21820</a>, but <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> is getting in the way by saying that removing <code>induction' h : f x</code> (which <code>induction</code> currently does not support) makes mathlib worse.</p>\n<p>I am countering this by saying that that functionality should be added to plain <code>induction</code>, but I don't know how to do this myself.</p>",
        "id": 499482173,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1739455708
    },
    {
        "content": "<p>that aside, is there a reason why <code>cases'</code> should not be added?</p>",
        "id": 499482612,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1739455820
    },
    {
        "content": "<p>because i seem to recall that the <code>cases h : x</code> syntax does exist?</p>",
        "id": 499482723,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1739455849
    },
    {
        "content": "<p><code>rcases</code> supports that syntax as well</p>",
        "id": 499482778,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1739455865
    },
    {
        "content": "<p>The point with <code>cases'</code> and <code>induction'</code> is that the variables you write after their <code>withs</code> are all on one line. When there are many inductors or many introduced variables per inductor it gets hard to tell which variable goes to which inductor</p>",
        "id": 499483202,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1739455978
    },
    {
        "content": "<p><code>induction</code>, <code>cases</code>, <code>rcases</code> and <code>obtain</code> force you to separate the variables by inductor</p>",
        "id": 499483402,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1739456021
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"598052\">Jeremy Tan</span> <a href=\"#narrow/channel/270676-lean4/topic/To.20replace.20.60induction'.20h.20.3A.20f.20x.60/near/499482173\">said</a>:</p>\n<blockquote>\n<p>I am countering this by saying that that functionality should be added to plain <code>induction</code></p>\n</blockquote>\n<p>I agree with this suggestion; with the comment that we should wait for this to happen (or be firmly ruled against) before trying to clean up <code>induction' h :</code>s</p>",
        "id": 499485119,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739456403
    },
    {
        "content": "<p><code>cases'</code> and other forms of <code>induction'</code> are indeed fair game to eliminate</p>",
        "id": 499485250,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739456439
    },
    {
        "content": "<p>I agree with Eric that we should not be removing <code>induction' h : f x</code> until that functionality has been implemented in the <code>induction</code> tactic. Is there already a Lean RFC for this feature?</p>",
        "id": 499494179,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1739458560
    },
    {
        "content": "<p>File indicating all current uses of <code>cases'</code> and <code>induction'</code>:</p>\n<p><a href=\"/user_uploads/3121/xvmQmafHEBNklVdQ48qco4Jx/cases-induction-uses\">cases-induction-uses</a></p>",
        "id": 499499358,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1739459732
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/channel/270676-lean4/topic/To.20replace.20.60induction'.20h.20.3A.20f.20x.60/near/499494179\">said</a>:</p>\n<blockquote>\n<p>I agree with Eric that we should not be removing <code>induction' h : f x</code> until that functionality has been implemented in the <code>induction</code> tactic. Is there already a Lean RFC for this feature?</p>\n</blockquote>\n<p>I don't think so</p>",
        "id": 499519119,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1739463794
    },
    {
        "content": "<p>I don't remember an RFC for it, and I didn't find one with a quick search.</p>\n<p>I've been wanting to see <code>induction h : f x</code> syntax. In theory it shouldn't be hard since <code>cases</code> already has it and both tactics share the same framework.</p>",
        "id": 499519832,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739463944
    },
    {
        "content": "<p>For posterity: What does <code>induction' h : f x</code> do?</p>",
        "id": 499610562,
        "sender_full_name": "Chris Wong",
        "timestamp": 1739492209
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"294142\">Chris Wong</span> <a href=\"#narrow/channel/270676-lean4/topic/To.20replace.20.60induction'.20h.20.3A.20f.20x.60/near/499610562\">said</a>:</p>\n<blockquote>\n<p>For posterity: What does <code>induction' h : f x</code> do?</p>\n</blockquote>\n<p>It inducts over <code>f x</code>, which is at the same time named <code>h</code></p>",
        "id": 499611773,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1739492869
    },
    {
        "content": "<p>Currently plain <code>induction</code> can only induct over an existing variable</p>",
        "id": 499612217,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1739493110
    },
    {
        "content": "<p>It creates a new variable <code>y</code> and an equality <code>h : f x = y</code> (or <code>h : y = f x</code>, I don't recall) and then inducts on <code>y</code>.</p>",
        "id": 499670293,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1739521519
    },
    {
        "content": "<p>Can someone review my open depriming PRs</p>",
        "id": 499757586,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1739543381
    },
    {
        "content": "<p>There are 1200 open PRs right now, I'm sure people will get to you in the end.</p>",
        "id": 499759038,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739543766
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/channel/270676-lean4/topic/To.20replace.20.60induction'.20h.20.3A.20f.20x.60/near/499670293\">said</a>:</p>\n<blockquote>\n<p>It creates a new variable <code>y</code> and an equality <code>h : f x = y</code> (or <code>h : y = f x</code>, I don't recall) and then inducts on <code>y</code>.</p>\n</blockquote>\n<p>That’s essentially</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>\n<p>right? Or maybe is it?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">generalizing</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>I was just looking at the induction code in lean, and indeed the code paths between <code>cases</code> and `induction are quite similar.</p>\n<p>(And the mathlib tactics prevented me from refactoring that module without breaking the mathlib builds, so getting rid of the primed tactics would be beneficial.)</p>",
        "id": 499759833,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739544020
    },
    {
        "content": "<p>Joachim, that's a chicken-or-egg problem: if we first remove the primed tactics, then we have to remove all the places they were used, but then we're losing the uses of the functionality you would be implementing in the <code>induction</code> tactic.</p>",
        "id": 499777442,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1739549072
    },
    {
        "content": "<p>We can remove all the uses of <code>cases'</code> first</p>",
        "id": 499777500,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739549099
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"598052\">@Jeremy Tan</span> if you want an action item, split off the part of your PRs that handle remove uses of <code>cases'</code>. These can be merged more easily.</p>",
        "id": 499777641,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1739549146
    },
    {
        "content": "<p>My computer is tied up right now training a text classifying model, but I'll get to that</p>",
        "id": 499777958,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1739549242
    },
    {
        "content": "<p>It still has 14 hours or so to go</p>",
        "id": 499778004,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1739549259
    },
    {
        "content": "<p>I strongly suggest not depriming <code>induction'</code> at the moment. I've been wanting to implement the major premise naming feature for awhile, so assuming the feature will appear at some point, removing uses of <code>induction'</code> is unnecessary and ties up review time. Presence of <code>induction'</code> is not actively harmful (while <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> makes a good point about them appearing in mathlib makes changing <code>induction</code> harder, my thought here is that no matter what changes we make, we should deprecate <code>induction'</code> instead of outright removing it, so we're going to have to fix the mathlib tactic anyway).</p>",
        "id": 499789794,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739553052
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/270676-lean4/topic/To.20replace.20.60induction'.20h.20.3A.20f.20x.60/near/499777442\">said</a>:</p>\n<blockquote>\n<p>Joachim, that's a chicken-or-egg problem: if we first remove the primed tactics, then we have to remove all the places they were used, but then we're losing the uses of the functionality you would be implementing in the <code>induction</code> tactic.</p>\n</blockquote>\n<p>Sorry, I wasn’t trying to imply that that  having <code>induction'</code>code in mathlib would stop me or anyone from extending lean’s <code>induction</code>.</p>",
        "id": 499792509,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739554006
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/To.20replace.20.60induction'.20h.20.3A.20f.20x.60/near/499789794\">said</a>:</p>\n<blockquote>\n<p>I've been wanting to implement the major premise naming feature for awhile</p>\n</blockquote>\n<p>Nice! Shouldn’t be hard.™<br>\nIf you happen to do it soon, please wait for <a href=\"https://github.com/leanprover/lean4/pull/7069\">https://github.com/leanprover/lean4/pull/7069</a> to be merged or build on top of of it to avoid merge conflicts.</p>",
        "id": 499792688,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739554073
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> the above PR has been merged</p>",
        "id": 500002835,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1739705164
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/270676-lean4/topic/To.20replace.20.60induction'.20h.20.3A.20f.20x.60/near/499759833\">said</a>:</p>\n<blockquote>\n<p>Or maybe is it?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">generalizing</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I believe it's this one. I use this pattern quite often in practice, so I find this improvement to <code>induction</code> really valuable.</p>",
        "id": 500043401,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1739738548
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> I checked <code>induction'</code>, and it doesn't do that generalization:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction'</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">case zero</span>\n<span class=\"cm\">xs : List ℕ</span>\n<span class=\"cm\">h : xs.length = 0</span>\n<span class=\"cm\">⊢ 0 ≥ 0</span>\n\n<span class=\"cm\">case succ</span>\n<span class=\"cm\">xs : List ℕ</span>\n<span class=\"cm\">n✝ : ℕ</span>\n<span class=\"cm\">a✝ : xs.length = n✝ → n✝ ≥ 0</span>\n<span class=\"cm\">h : xs.length = n✝ + 1</span>\n<span class=\"cm\">⊢ n✝ + 1 ≥ 0</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>I'm not sure having it generalize everything that the target depends on is something we'd want in general. That could potentially generalize the entire local context...</p>",
        "id": 500055196,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739748975
    },
    {
        "content": "<p>Oof, put that way I agree that could be pretty painful in general. As long as there's an option to generalise more (ie <code>generalizing</code> still works) I'm just as happy with the first of Joachim's suggestions</p>",
        "id": 500055505,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1739749243
    },
    {
        "content": "<p>Great, since I think I have it working that way :-)</p>",
        "id": 500055537,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739749279
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/7103\">lean4#7103</a></p>\n<p>(<span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> I forgot to heed your advice, and there's definitely a merge conflict. I'll get to fixing that once I get mathlib building...)</p>",
        "id": 500057902,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739751050
    },
    {
        "content": "<p>I'm looking forward to fixing up <code>generalize ... induction</code>'s in core. I've tested the feature on this one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">forIn'_yield_eq_foldlM'</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulMonad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">forIn'</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">yield</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">      </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">attach</span><span class=\"bp\">.</span><span class=\"n\">foldlM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">forIn'_eq_foldlM</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">attach</span><span class=\"w\"> </span><span class=\"n\">generalizing</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp_all</span>\n</code></pre></div>",
        "id": 500057968,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739751121
    },
    {
        "content": "<p>It's merged.</p>\n<p>Part of the change was to modify how <code>induction</code> processes its targets, to follow how <code>cases</code> has already been doing it. It used to be that if any of the targets wasn't a free variable, it would generalize all of them indiscriminately — this causes free variables to become \"detached\" from any hypotheses about them that happen to be in the local context. Using multi-target induction principles is somewhat rare, so I'm not surprised that no one noticed.</p>\n<p>The first theorem that ran into the issue was <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=natCast_eq_one#doc\">docs#natCast_eq_one</a>, which uses a multi-target induction principle:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">natCast_eq_one</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nezero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">one_le_iff_ne_zero</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"n\">nezero</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_induction</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">base</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">cast_one</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">cast_add</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">cast_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_idem</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>The second target is <code>Nat.one_le_iff_ne_zero.mpr nezero</code>, which is not a free variable, so this causes <code>induction</code> to introduce a new variable <code>n'</code> that replaces <code>n</code> in the goal, and induction is done on <em>that</em>. This means the pre-existing <code>nezero</code> hypothesis (which is still in terms of <code>n</code>) isn't automatically added to the <code>generalizing</code> set, and so the induction hypothesis doesn't depend on proving <code>nezero</code>.</p>\n<p>After the change, <code>n</code> is not generalized, so <code>nezero</code> <em>does</em> get added to the <code>generalizing</code> set, and the induction hypothesis has a surprising extra <code>x ≠ 0</code> requirement, with <code>nezero</code> transformed to <code>x + 1 ≠ 0</code>.</p>\n<p>Fixing it was straightforward: rewrite <code>nezero</code> in place. This way there's no lingering hypothesis in the context.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">natCast_eq_one</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nezero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">one_le_iff_ne_zero</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">nezero</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nezero</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_induction</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">base</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">cast_one</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">cast_add</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">cast_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_idem</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>The only mathlib fixes needed were of this type, where some code golf had been done inside the induction targets.</p>",
        "id": 500323611,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739857936
    },
    {
        "content": "<p>Yeah, those changes seem unproblematic</p>",
        "id": 500337406,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1739865221
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/To.20replace.20.60induction'.20h.20.3A.20f.20x.60/near/500323611\">said</a>:</p>\n<blockquote>\n<p>After the change, <code>n</code> is not generalized, so <code>nezero</code> <em>does</em> get added to the <code>generalizing</code> set, and the induction hypothesis has a surprising extra <code>x ≠ 0</code> requirement, with <code>nezero</code> transformed to <code>x + 1 ≠ 0</code>.<br>\n</p>\n</blockquote>\n<p>I guess something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">one_le_iff_ne_zero</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">clear</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">nezero</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_induction</span><span class=\"w\"> </span><span class=\"k\">with</span>\n</code></pre></div>\n<p>would work too, assuming <code>clear%</code> is possibly to implement?</p>",
        "id": 500349250,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739869214
    },
    {
        "content": "<p>Term elaboration can only locally affect the local context, which is some Reader state, so that's not possible.</p>",
        "id": 500349828,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739869421
    },
    {
        "content": "<p>And if it was possible, I'm not sure I'd want to see it in mathlib :)</p>",
        "id": 500350711,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1739869709
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> do I understand correctly that <a href=\"https://github.com/leanprover/lean4/pull/7103\">lean4#7103</a> addresses all of the existing issues with <code>induction</code> so that it is feature-complete with respect to <code>induction'</code>? And therefore the only remaining issue is whether we want to leave the syntax for <code>induction'</code> available / used in Mathlib?</p>",
        "id": 508295230,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1742999863
    },
    {
        "content": "<p>Yeah, that's my understanding, though with the caveat that some people might want a more convenient-looking one-line <code>induction</code> than <code>induction x with | c1 a b c =&gt; ?_ | c2 d e =&gt; ?_</code></p>",
        "id": 508342755,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743010821
    }
]