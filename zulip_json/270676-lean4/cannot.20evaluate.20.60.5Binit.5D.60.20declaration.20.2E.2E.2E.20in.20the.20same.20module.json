[
    {
        "content": "<p>Hello. I'm trying to cache the file context of a given theorem, so that in multiple REPL evaluations of this theorem, I can just load the context (by context, i mean file contents up to the theorem start) rather than recompiling it every time.</p>\n<p>For example, here's a lemma from the Carleson project:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Carleson</span><span class=\"bp\">.</span><span class=\"n\">CoverByBalls</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">StarOrdered</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">MeasureTheory</span><span class=\"bp\">.</span><span class=\"n\">Measure</span><span class=\"bp\">.</span><span class=\"n\">Lebesgue</span><span class=\"bp\">.</span><span class=\"n\">VolumeOfBalls</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">CompletePartialOrder</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">MeasureTheory</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">NNReal</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"w\"> </span><span class=\"n\">Metric</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">Topology</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">MeasureTheory</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"bp\">.</span><span class=\"n\">IsDoubling</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PseudoMetricSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">measure_ball_two_le_same</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ball</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ball</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"kn\">export</span><span class=\"w\"> </span><span class=\"n\">IsDoubling</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">measure_ball_two_le_same</span><span class=\"o\">)</span>\n\n<span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">PseudoMetric</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PseudoMetricSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">ball_subset_ball_of_le</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">r'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">r'</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ball</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"n\">r'</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">ball</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">calc</span><span class=\"w\"> </span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">dist_triangle</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">        </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">r'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">gcongr</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">mem_ball'</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">        </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hr</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">mem_ball'</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n</code></pre></div>\n<p>I need to run <code>ball_subset_ball_of_le</code> many times via the repl in order to verify correctness (between different AI-generated proofs, but the same declaration &amp; context).  However, it's quite inefficient to be having to also send the file context, which could include many imports, theorems, definitions, etc. through every single time I evaluate this one theorem (especially if the target theorem is near the end of the file). So, I've been trying to pickle the file contents up until the start of the theorem, and load them when needed:</p>\n<p>Store:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"s2\">\"cmd\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"import Carleson.CoverByBalls</span><span class=\"se\">\\n</span><span class=\"s2\">[...]}</span>\n\n<span class=\"s2\">{\"</span><span class=\"n\">pickleTo</span><span class=\"s2\">\":\"</span><span class=\"n\">temp</span><span class=\"bp\">.</span><span class=\"n\">o</span><span class=\"s2\">\",\"</span><span class=\"n\">env</span><span class=\"s2\">\":0}</span>\n</code></pre></div>\n<p>Load:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"s2\">\"unpickleEnvFrom\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"temp.o\"</span><span class=\"o\">}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"cmd\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"lemma ball_subset_ball_of_le {x x' : X} {r r' : </span><span class=\"err\">\\</span><span class=\"s2\">u211d}</span><span class=\"se\">\\n</span><span class=\"s2\">    (hr : dist x x' + r' </span><span class=\"err\">\\</span><span class=\"s2\">u2264 r) : ball x' r' </span><span class=\"err\">\\</span><span class=\"s2\">u2286 ball x r := by</span><span class=\"se\">\\n</span><span class=\"s2\">  intro y h</span><span class=\"se\">\\n</span><span class=\"s2\">  have h1 : dist x y &lt; r := by [...]\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"allTactics\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"s2\">\"env\"</span><span class=\"o\">:</span><span class=\"mi\">0</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>If I ran these together without the pickling (so compile all the context, and then load the theorem into that environment), everything works great. However, when I add the pickling, the storing step is fine, but when attempting to load the environment, I get:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">stdout</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"s2\">\"env\"</span><span class=\"o\">:</span><span class=\"mi\">0</span><span class=\"o\">}</span>\n\n<span class=\"n\">stderr</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">libc</span><span class=\"bp\">++</span><span class=\"n\">abi</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">terminating</span><span class=\"w\"> </span><span class=\"n\">due</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">uncaught</span><span class=\"w\"> </span><span class=\"n\">exception</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">lean</span><span class=\"bp\">::</span><span class=\"n\">exception</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">cannot</span><span class=\"w\"> </span><span class=\"n\">evaluate</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">init</span><span class=\"o\">]</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">declaration</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">GCongr</span><span class=\"bp\">.</span><span class=\"n\">forwardExt'</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">same</span><span class=\"w\"> </span><span class=\"n\">module</span>\n</code></pre></div>\n<p>It seems that the <code>gcongr</code> tactic is what causes this issue. Notably, in different examples, I have gotten the same error in the same REPL commands, but for <code>norm_num</code>. Does anyone know why this is happening, and how to fix it? </p>\n<p>Any help is greatly appreciated, thanks!!</p>",
        "id": 498622295,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1739125697
    },
    {
        "content": "<p>I don't know the answer to your question, sadly, but could you confirm you're doing all this on <code>v4.17.0-rc1</code>?</p>",
        "id": 498653353,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1739150716
    },
    {
        "content": "<p>The above example was on the older v4.15.0, but here is a simpler MWE with the same error message on v4.17.0-rc1 (about linarith this time, instead of gcongr!)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">two</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">two</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">two</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">linarith</span>\n</code></pre></div>\n<p>The storing REPL command:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"s2\">\"cmd\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"import Mathlib.Tactic</span><span class=\"se\">\\n\\n</span><span class=\"s2\">def two : </span><span class=\"err\">\\</span><span class=\"s2\">u211d := 2\"</span><span class=\"o\">}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"pickleTo\"</span><span class=\"o\">:</span><span class=\"s2\">\"temp.o\"</span><span class=\"o\">,</span><span class=\"s2\">\"env\"</span><span class=\"o\">:</span><span class=\"mi\">0</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>The load command:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"s2\">\"unpickleEnvFrom\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"temp.o\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"env\"</span><span class=\"o\">:</span><span class=\"mi\">0</span><span class=\"o\">}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"cmd\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"example (x:</span><span class=\"err\">\\</span><span class=\"s2\">u211d) : 1+x = two </span><span class=\"err\">\\</span><span class=\"s2\">u2192 x = 1 := by</span><span class=\"se\">\\n</span><span class=\"s2\">  intro h</span><span class=\"se\">\\n</span><span class=\"s2\">  unfold two at h</span><span class=\"se\">\\n</span><span class=\"s2\">  linarith\"</span><span class=\"o\">,</span><span class=\"s2\">\"env\"</span><span class=\"o\">:</span><span class=\"mi\">0</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>And the error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"s2\">\"env\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span>\n\n<span class=\"n\">libc</span><span class=\"bp\">++</span><span class=\"n\">abi</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">terminating</span><span class=\"w\"> </span><span class=\"n\">due</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">uncaught</span><span class=\"w\"> </span><span class=\"n\">exception</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">lean</span><span class=\"bp\">::</span><span class=\"n\">exception</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">cannot</span><span class=\"w\"> </span><span class=\"n\">evaluate</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">init</span><span class=\"o\">]</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">declaration</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">NormNum</span><span class=\"bp\">.</span><span class=\"n\">normNumExt'</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">same</span><span class=\"w\"> </span><span class=\"n\">module</span>\n</code></pre></div>",
        "id": 498673375,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1739165123
    },
    {
        "content": "<p>Seems like something weird is happening when attempting to pickle/unpickle tactics defined outside of the core lean library. Perhaps the unpickling process sees the loading of such an externally defined tactic like <code>linarith</code> as a new declaration in the current module, which is why it gets angry when you try using it in the same module?</p>",
        "id": 498673627,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1739165289
    },
    {
        "content": "<p>(Just spitballing, I have little experience in how tactic declarations/initializations work, especially when pickled or loaded)</p>",
        "id": 498673694,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1739165347
    },
    {
        "content": "<p>Also, I've recreated this error on v4.9.0 and v4.14.0 in addition to the above v4.15.0 and v4.17.0-rc1</p>",
        "id": 498673758,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1739165402
    },
    {
        "content": "<p>I believe pickling the environment is fundamentally incompatible with some metaprogramming features.</p>\n<blockquote>\n<p>I need to run <code>ball_subset_ball_of_le</code> many times via the repl in order to verify correctness (between different AI-generated proofs, but the same declaration &amp; context). However, it's quite inefficient to be having to also send the file context, which could include many imports, theorems, definitions, etc. through every single time I evaluate this one theorem (especially if the target theorem is near the end of the file).</p>\n</blockquote>\n<p>I don't understand this part though, REPL (and even more so Pantograph) should allow you to continue from the point just before the theorem? Or are you talking about multiple machines?</p>",
        "id": 498697851,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1739176821
    },
    {
        "content": "<p>Not necessarily multiple machines, but different REPL/pantograph instances. This is because my proof optimization agent is running an iterative refinement process, each step of which depends on the correctness/error messages of the previous step. So, I’ve been calling out to the repl binary to evaluate each batch of theorems for each step of the refinement. However, if pickling won’t be possible, I suppose the smarter strategy is to have a persistent repl instance (this is handled by pantograph nicely, so I’d probably use that instead). Alternatively, I can preprocess the theorem so that the proofs of all of its preceding theorems are simply sorry, which is picklable. </p>\n<p>There is probably a much smarter way to handle this, but all this iterative refinement is really just being used to collect training data for a more effective model, which will be able to slot into pantograph’s interface much more easily.</p>",
        "id": 498754237,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1739192287
    },
    {
        "content": "<p>Yes, this should just work with a single Pantograph instance</p>",
        "id": 498814240,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1739206748
    }
]