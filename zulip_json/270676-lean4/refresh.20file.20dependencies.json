[
    {
        "content": "<p>Is there a way to enable automatic file dependency checking? That is, make it so that it is not necessary to run <code>refresh file dependencies</code> when an imported file changes?</p>",
        "id": 363879506,
        "sender_full_name": "Kayla Thomas",
        "timestamp": 1686022545
    },
    {
        "content": "<p>That is, to set the behavior to what it was in Lean 3.</p>",
        "id": 363880864,
        "sender_full_name": "Kayla Thomas",
        "timestamp": 1686023609
    },
    {
        "content": "<p>There's a significant change under the hood between Lean 3 and Lean 4 here: when VSCode rebuilds dependencies in Lean 3, it is <em>not</em> writing oleans to disk, but in Lean 4 it is.</p>\n<p>This makes it a bit \"scarier\" to automatically refresh dependencies.</p>",
        "id": 363890232,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686029145
    },
    {
        "content": "<p>In fact, what I'd like is \"more of the same\". Even when you first open a file in VSCode, I don't want the extension to write to oleans --- only when I run <code>refresh file dependencies</code> explicitly.</p>",
        "id": 363890370,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686029192
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"139442\">@Kayla Thomas</span>, you know there is a keyboard shortcut (option-R on a mac) for this refresh. I barely notice doing it now.</p>",
        "id": 363890422,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686029223
    },
    {
        "content": "<p>I see.</p>",
        "id": 363890701,
        "sender_full_name": "Kayla Thomas",
        "timestamp": 1686029357
    },
    {
        "content": "<p>i wonder if we could detect when dependencies are out of date and then have some sort of suggestion/warning at the top saying \"dependencies out of date; CTRL+SHIFT+x to refresh\"</p>",
        "id": 364952602,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1686339231
    },
    {
        "content": "<p>since that's the best way to teach people to do it</p>",
        "id": 364952732,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1686339258
    },
    {
        "content": "<p>Yes please! I would <em>really</em> like to turn off the automatic \"let me mess with the oleans on your disk without asking you\" feature. It is a constant productivity drain.</p>",
        "id": 364987602,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686352961
    },
    {
        "content": "<p>I know I <em>should</em>:</p>\n<ul>\n<li>close VSCode</li>\n<li>run <code>lake exe cache get</code></li>\n<li>(possibly run <code>lake build</code> to check that it actually worked and isn't in some error 139 state)</li>\n<li>reopen VSCode</li>\n</ul>\n<p>every single time I want to switch a branch.</p>\n<p>But too often it is tempting to say\"oh, maybe I won't actually need live Lean to do the inspection / fix I want, I'll just run <code>lake exe cache get</code> from inside VSCode while I get started\", and then half then time find myself in the state of VSCode and <code>lake exe cache get</code> having fought over the oleans.</p>",
        "id": 364987652,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686352986
    },
    {
        "content": "<p>Worst of all is when VSCode automatically building oleans goes berserk, and manages to launch 50 or more lake processes, grinding the machine to a halt until I <code>sudo pkill lake lean</code>.</p>",
        "id": 364987716,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686353035
    },
    {
        "content": "<p>A related productivity killer is not being able to restart the Lean4 server if you don't have any Lean4 files open! I'm frequently in the bind that I want to kill the server, but opening a lean file will start overwriting my nice oleans with bad ones, so the only way to restart the server is to quit VSCode and restart. (Which is often painful for other reasons, particularly reseting other terminals I have open.)</p>",
        "id": 364987901,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686353145
    },
    {
        "content": "<p>I wholeheartedly support the proposal (see also <a href=\"https://github.com/leanprover/lean4/pull/2154\">lean4#2154</a>), but I don't have any time to implement it.</p>",
        "id": 364989203,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1686353979
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/270676-lean4/topic/refresh.20file.20dependencies/near/364987652\">said</a>:</p>\n<blockquote>\n<p>I know I <em>should</em>:</p>\n<ul>\n<li>close VSCode</li>\n<li>run <code>lake exe cache get</code></li>\n<li>(possibly run <code>lake build</code> to check that it actually worked and isn't in some error 139 state)</li>\n<li>reopen VSCode</li>\n</ul>\n<p>every single time I want to switch a branch.</p>\n</blockquote>\n<p>You forgot step (1.5) terminate any running Lake process.  Closing VS Code is not enough to kill Lake's zombie minions.</p>",
        "id": 364989429,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1686354119
    },
    {
        "content": "<p>At the end of the discussion in <a href=\"https://github.com/leanprover/lean4/pull/2154\">lean4#2154</a>, it seems there's not a decision between:</p>\n<ul>\n<li>have <code>lake print-paths</code> <em>never</em> build, but instead return an error and suggested command line invocation if building is required</li>\n<li>have <code>lake print-paths</code> by default error if a rebuild is required, but have <code>lake print-paths --rebuild</code> actually proceed with the build.</li>\n</ul>\n<p>The second option seems easier to implement, so if it's at all satisfactory I hope we can go with that, at least initially to get to a usable system.</p>",
        "id": 364991372,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686355294
    },
    {
        "content": "<p>Would the steps in that case be:</p>\n<ol>\n<li>add the <code>--rebuild</code> flag for <code>print-paths</code></li>\n<li>adjust the VSCode extension to detect the error from <code>lake print-paths</code>, and offer a GUI button to re-run <code>lake print-paths --rebuild</code>.</li>\n</ol>\n<p>and then optional extras:</p>\n<ul>\n<li>provide a VSCode user setting that enables <code>lake print-paths --rebuild</code> always?</li>\n</ul>",
        "id": 364991557,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686355395
    },
    {
        "content": "<p>I have never tried modifying the Lake code, but if this description is all that would be required I could probably try. :-)</p>",
        "id": 364991680,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686355459
    },
    {
        "content": "<p>My objection to the <code>--rebuild</code> flag was that it's hard to script from the editor.  \"Rebuild file dependencies\" should work even if the server is not started / the file has crashed / the file hasn't been restarted yet after the dependencies were modified, i.e., the editor should know how to rebuild a file's dependencies w/o having to ask Lean.</p>",
        "id": 364991973,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1686355649
    },
    {
        "content": "<p>Practically speaking, I think the MVP would be:</p>\n<ol>\n<li>Add an environment variable <code>LAKE_AUTO_BUILD_DEPS</code> ( <span aria-label=\"bike\" class=\"emoji emoji-1f6b2\" role=\"img\" title=\"bike\">:bike:</span> <span aria-label=\"house\" class=\"emoji emoji-1f3e0\" role=\"img\" title=\"house\">:house:</span>)  that allows VS Code to enable/disable automatic dependency building (I think that's the most straightforward way to make it configurable).</li>\n<li>Change <code>lake print-path</code> so that when the environment variable is not set, it prints an error message when it would need to rebuild anything.</li>\n<li><del>Make the Lean server ignore this message, i.e., you can work on a file with outdated deps.</del></li>\n</ol>",
        "id": 364992404,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1686355869
    },
    {
        "content": "<p>Okay, that sounds even easier to implement. :-)</p>",
        "id": 364992568,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686355936
    },
    {
        "content": "<p>From what I can tell, the hardest part here is figuring out if Lake needs to rebuild anything.  Lake doesn't have an equivalent of <code>make --dry-run</code> that we could reuse.</p>",
        "id": 364992571,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1686355937
    },
    {
        "content": "<p>And where would <code>--dry-run</code> be used from VSCode? (If I understand right, you're now talking about something post-MVP?)</p>",
        "id": 364992728,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686356026
    },
    {
        "content": "<p>No, <code>--dry-run</code> is what we need for the MVP already.  We want to show the error message (please run <code>lake print-paths</code> manually) if and only if <code>--dry-run</code> would print something.</p>",
        "id": 364992841,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1686356073
    },
    {
        "content": "<p>What if instead of step 3. we just show the error message, and expect users to hit <code>alt-r</code> to rebuild? Maybe I'm misunderstand what <code>alt-r</code> does.</p>",
        "id": 364993125,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686356227
    },
    {
        "content": "<p>What does alt-r do on your machine?  I think we've got different keybindings. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 364993188,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1686356269
    },
    {
        "content": "<p>Rebuilds all dependencies.</p>",
        "id": 364993192,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686356278
    },
    {
        "content": "<p>(shft+ctrl+x i assume <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span>)</p>",
        "id": 364993250,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1686356286
    },
    {
        "content": "<p>And I guess it is <code>option-r</code> on my machine. :-)</p>",
        "id": 364993253,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686356287
    },
    {
        "content": "<p>To be clear (3) is not strictly necessary.</p>",
        "id": 364993276,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1686356304
    },
    {
        "content": "<p>My preference for UX would be:</p>\n<ul>\n<li>when opening a new file, if all dependent oleans already exist and are up to date, the current file is processed as usual</li>\n<li>otherwise, there is a red squiggle on the first line (I don't really care what it says?)</li>\n<li>and hitting <code>shift+ctrl+x</code> / <code>alt+r</code> results in rebuilding (i.e. so I then get a blue squiggle on the first line showing progress)</li>\n</ul>\n<p>In particular I don't think there's any particular need for pop-ups or banners, and in particular no buttons to press: Lean4 users are going to have <code>shift+ctrl+x</code> burnt into their brains anyway, we don't need to be afraid of asking them to use it.</p>",
        "id": 364993611,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686356521
    },
    {
        "content": "<p>Is this what would result from your proposed 2 step MVP above?</p>",
        "id": 364993722,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686356568
    },
    {
        "content": "<p>That's harder to implement, because the server doesn't know whether you opened a file or pressed ctrl-shift-x.  (ctrl-shift-x is implemented as close+open)</p>",
        "id": 364993896,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1686356655
    },
    {
        "content": "<p>The MVP would mainly allow you to call <code>lake build</code> manually without having vscode interfere.</p>",
        "id": 364994027,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1686356717
    },
    {
        "content": "<p>Okay, even that would be an improvement over what we have today. Obviously sad that it then necessitates using the command line, but presumably later we could modify <code>shift+ctrl+x</code> to be:</p>\n<ol>\n<li>close</li>\n<li>run <code>lake build File</code> in a terminal</li>\n<li>open</li>\n</ol>",
        "id": 364994263,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686356863
    },
    {
        "content": "<p>that actually has the advantage of being much more explicit about what happens when you hit <code>shift+ctrl+x</code> in multiple windows at once (i.e. competing builds start that will overwrite each other).</p>",
        "id": 364994353,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686356901
    },
    {
        "content": "<p>In fact, changing the behaviour of <code>shift+ctrl+x</code> could be done independently of touching <code>lake</code>. That's purely a change in the VSCode extension.</p>",
        "id": 364998840,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686359556
    },
    {
        "content": "<p>Only once we can disable the auto-build of course.  It's Lean itself that calls <code>lake print-paths</code> right now, not VS Code.</p>",
        "id": 364999009,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1686359643
    },
    {
        "content": "<p>I mean: the change to <code>shift+ctrl+x</code> by itself wouldn't solve the underlying problem (of opening a new file overwriting oleans). But having it run <code>lake build</code> can be done now, and if nothing else solves the explicitness problem of users not seeing what multiple <code>shift+ctrl+x</code>s are doing. By the time the file is reopened in the server <code>lake build</code> will have already run, at which point it doesn't matter whether <code>lake print-paths</code> is still auto-building.</p>",
        "id": 364999324,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686359847
    },
    {
        "content": "<p>Would the introduction of a lockfile to keep parts from trampling over each other be a simpler first change? I understand that eventually we want both though.</p>",
        "id": 365029766,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1686378671
    },
    {
        "content": "<p>And then there is the also somewhat orthogonal issue of how to reliably abort Lake builds</p>",
        "id": 365029843,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1686378716
    },
    {
        "content": "<p>Another thing I have been thinking about is adding checksums to oleans, because it's pretty ballsy to just mmap and start jumping around in an arbitrary file downloaded from somewhere even without assuming ill will</p>",
        "id": 365030650,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686379024
    },
    {
        "content": "<p>I'm pretty sure error 139 is a segfault (EDIT: it is, SIGSEGV)</p>",
        "id": 365030725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686379062
    },
    {
        "content": "<p>or at least a length check, if we suppose the main failure mode is a process dying in the middle of writing an olean</p>",
        "id": 365030966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686379175
    },
    {
        "content": "<p>This should be covered by the lockfile as well</p>",
        "id": 365038626,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1686382091
    },
    {
        "content": "<p>do we have a way to atomically get rw access to a filename? my impression was that we needed a primitive for making unnamed temp files, which can then be atomically moved to a specific filename</p>",
        "id": 365045660,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1686384232
    },
    {
        "content": "<blockquote>\n<p>Would the introduction of a lockfile to keep parts from trampling over each other be a simpler first change? I understand that eventually we want both though.</p>\n</blockquote>\n<p>The immediate issue is that Lake starts building when you don't want it to, and it continues to build even after you've closed everything.  That's why people close VS Code before switching branches.  I don't see how a lockfile would help with that, although locking seems like a good idea eventually.</p>",
        "id": 365170923,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1686419765
    },
    {
        "content": "<p>I'm not sure I understand the scenario yet. Is the action of switching branches itself triggering Lake? Because an open file may have had its imports changed by automatic reload?</p>",
        "id": 365198299,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1686432602
    },
    {
        "content": "<p>Okay, let me see if I can describe the problematic scenario.</p>",
        "id": 365214056,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686443163
    },
    {
        "content": "<ol>\n<li>I've been working on a branch, editing multiple files. Without having checked via a <code>lake build</code> that everything works, I'm nevertheless satisfied enough with the condition of the branch that I'm ready to commit and send everything off to CI.</li>\n<li>I now want to switch to a new branch and begin work, so I:<br>\n  a. run <code>git checkout blah</code> in a terminal<br>\n  b. run <code>lake exe cache get</code> in that terminal<br>\n  c. possibly before b. has finished, open a file to begin looking at the issue (deciding that I don't really need live compilation to begin reading)</li>\n</ol>",
        "id": 365214072,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686443171
    },
    {
        "content": "<p>At least, that is the dream! It is not at all possible today.</p>",
        "id": 365214078,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686443177
    },
    {
        "content": "<p>The problems are:</p>\n<ol>\n<li>Because I was opening and closing multiple files while editing the initial branch, there may be hidden lake processes still compiling oleans for files that aren't even open in the editor, and I have no way of knowing if these are still running (without <code>ps</code> or equivalent). These processes will continue overwriting oleans that are being produced by <code>lake exe cache get</code>.</li>\n<li>If I proceed to step 2c above (opening a file in the new branch to begin reading) before confirming that 2b is finished, VSCode will begin compiling the file, and overwriting the oleans being produced by <code>lake exe cache get</code>.</li>\n</ol>",
        "id": 365214085,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686443185
    },
    {
        "content": "<p>To avoid these problems today, I need to:</p>\n<ul>\n<li>when I'm finished working on a branch, quit VSCode and run <code>sudo pkill lake lean</code> to kill off any stray processes. (This is of course incompatible with a very common workflow --- I often have 2 or 3 branches of mathlib4 checked out in different directories, jumping between them to avoid having to wait on compilation. I understand that this is less common.) <em>Sometimes</em> just killing the server from VSCode is enough at this step, but regularly processes seem to survive this.</li>\n<li>carefully avoid opening any new files in VSCode until <code>lake exe cache get</code> has finished running, leaving me with nothing to do but <span aria-label=\"fencing\" class=\"emoji emoji-1f93a\" role=\"img\" title=\"fencing\">:fencing:</span> (particularly because the previous bullet point makes it hard to just switch to a different checked out copy of mathlib and work there for a moment).</li>\n</ul>",
        "id": 365214098,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686443197
    },
    {
        "content": "<p>Directly addressing <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span>'s question, switching branches itself is not triggering Lake --- VSCode does not (thankfully) trigger recompilation of any already open file just because its upstream dependencies have changed on disk. For this we need to hit <code>ctrl+shift+x</code>.</p>",
        "id": 365214102,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686443205
    },
    {
        "content": "<p>The suggestions higher up in this thread are:</p>\n<ol>\n<li>When VSCode opens a file, if dependencies are not already built it should simply error, rather than starting building upstream oleans. This allows us to start opening files and looking around even while oleans are still being retrieved (or we haven't even started retrieving them).</li>\n<li>When we hit <code>ctrl+shift+x</code>, instead of the current behaviour of \"close in the server, then open in server\" (relying on the automatic building of upstream oleans when we open in the server), change to \"close in the server, run <code>lake build Foo</code> in a VSCode terminal, open in the server). This means that there are no hidden processes that may continue writing oleans even after we close editor windows: every (long running) lake process is tied to a terminal window in VSCode, so if those are closed, you know there are no zombie processes.</li>\n</ol>",
        "id": 365214111,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686443213
    },
    {
        "content": "<p>Both of these fixes seem like they are very doable right now.</p>",
        "id": 365214122,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686443219
    },
    {
        "content": "<p>A harder thing to do, which we really need to do at some point, is:</p>\n<ul>\n<li>when there are multiple <code>lake build Foo</code> and <code>lake build Bar</code> processes running on the same directory, they should coordinate at least minimally, to avoid crashing when they both write the same file. Ideally they would coordinate even more, and not duplicate work.</li>\n</ul>",
        "id": 365214136,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686443224
    },
    {
        "content": "<p>A related problem to all of this is that I can not kill the server if no Lean 4 files are open (just because this command palette option is only available if a Lean4 file is open), so I either need to close VSCode and kill lake/lean processes on the command line (disruptive!) or open a Lean 4 file (thereby triggering automatically building oleans, even if there weren't already any processes doing this, and thus corrupting my oleans again). Again, this one should have a really easy fix in the VSCode extension.</p>",
        "id": 365214139,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686443226
    },
    {
        "content": "<blockquote>\n<p>A related problem to all of this is that I can not kill the server if no Lean 4 files are open</p>\n</blockquote>\n<p>I'm pretty sure that merely restarting the server doesn't kill Lake.</p>",
        "id": 365216961,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1686445083
    },
    {
        "content": "<p>How often do we actually want multiple <code>lake build</code>s running simultaneously for the same project? Could we circumvent some of the conflicts by having some lockfile mechanism in place?</p>",
        "id": 365273880,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1686476233
    },
    {
        "content": "<p>That would allow both the current seamless experience of just opening a file and working on it, without having to manually trigger the dependency build, and, if some other process is currently holding the lock, vscode knows to wait until the lock is released before trying a build</p>",
        "id": 365274373,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1686476397
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/270676-lean4/topic/refresh.20file.20dependencies/near/365214085\">said</a>:</p>\n<blockquote>\n<p>Because I was opening and closing multiple files while editing the initial branch, there may be hidden lake processes still compiling oleans for files that aren't even open in the editor, and I have no way of knowing if these are still running</p>\n</blockquote>\n<p>With a lockfile shared by Lake and Cache, you will know. cache get will block until the Lake processes are finished building (which of course still shouldn't happen invisibly in the background).</p>\n<blockquote>\n<p>If I proceed to step 2c above (opening a file in the new branch to begin reading) before confirming that 2b is finished, VSCode will begin compiling the file, and overwriting the oleans being produced by <code>lake exe cache get</code>.</p>\n</blockquote>\n<p>Analogously, with a lockfile, here the language server will wait for cache get to finish before compiling any remaining missing dependencies, if any.</p>",
        "id": 365317543,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1686489485
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/270676-lean4/topic/refresh.20file.20dependencies/near/365214111\">said</a>:</p>\n<blockquote>\n<ol>\n<li>When VSCode opens a file, if dependencies are not already built it should simply error, rather than starting building upstream oleans.</li>\n</ol>\n</blockquote>\n<p>I'd be in favor of this change -- opening a file shouldn't automatically trigger an expensive (and sometimes a little destructive) process.</p>\n<p>This would also help improve usability in Gitpod, where files are automatically saved as you edit them, so if you want to open a file that imports an edited one to consult it (since you might be wanting to see how something is used while refactoring), you're faced with a potentially large recompilation unless you remember to turn off the server manually -- and then when you turn the server back on you have to wait for your file to re-typecheck up to the place you're editing.</p>\n<p>Lockfiles might solve some problems (while also introducing an extra piece of state to have to manually clear when things go wrong), but they won't solve the \"I just want to see the contents of a file that's hundreds of imports away\" problem</p>",
        "id": 365352746,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1686500452
    },
    {
        "content": "<p>I believe all three parts will be essential to make the process really robust, now we just have to implement them</p>",
        "id": 365391778,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1686516677
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/refresh.20file.20dependencies/near/365391778\">said</a>:</p>\n<blockquote>\n<p>I believe all three parts will be essential to make the process really robust, now we just have to implement them</p>\n</blockquote>\n<p>Does the above discusssion cover the following scenario : Someone opens vscode without starting <code>cache</code>. So the extension acquires the lock and starts building files, and then the user runs <code>cache</code> inside vscode's terminal, which will wait for the build to finish before starting the cache process. The ideal behaviour is that the extension acquire that lock and ask the user if it should search for cached oleans, get them, and then build . Or ideally before running build, caches are always fetched first (with an option to turn it off if a user wants that).</p>",
        "id": 365393086,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686517355
    },
    {
        "content": "<p>Integrating the cache into the extension and/or Lake is yet another orthogonal but welcome improvement</p>",
        "id": 365393704,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1686517705
    },
    {
        "content": "<p>One of the three parts mentioned is that vscode should <em>not</em> automatically start building upon opening a file. Instead, if dependencies are outdated vscode should display some kind of prompt \"Please press {hotkey} to build dependencies\". But, indeed, it would be nice if <code>lake build</code> would transparently consult the cache</p>",
        "id": 365393790,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1686517778
    },
    {
        "content": "<p>Does the extension use lake to build?</p>",
        "id": 365394045,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686517931
    },
    {
        "content": "<p>If yes, then making <code>lake build</code> cache aware and coordinated at the project level by a lockfile, would solve the problem all around.</p>",
        "id": 365394127,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686518018
    },
    {
        "content": "<p>If no, then maybe eventually it should be using lake build. Separation and isolation of concerns and all that.</p>",
        "id": 365394327,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686518161
    },
    {
        "content": "<p>Note that integrate <code>cache</code> into <code>lake build</code> does not require a Lake change, it can be done by using the existing <code>extraDepTargets</code> feature in the mathlib configuration file.</p>",
        "id": 365938951,
        "sender_full_name": "Mac Malone",
        "timestamp": 1686676393
    },
    {
        "content": "<p>Oh my, I just learned/rediscovered how <code>elan</code> makes sure your Lean build processes actually die on Ctrl-C on Windows: <a href=\"https://github.com/leanprover/elan/blob/master/src/elan-cli/job.rs#L3-L18\">https://github.com/leanprover/elan/blob/master/src/elan-cli/job.rs#L3-L18</a><br>\nThat's a lot of platform specific code!</p>",
        "id": 370123758,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1687882172
    },
    {
        "content": "<p>So perhaps we want to keep that logic in elan and add a Unix analogue as well. Then we would only have to make sure that we start worker processes through elan</p>",
        "id": 370125677,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1687882550
    },
    {
        "content": "<p>This should mean that on Windows, restarting the entire server already kills runaway lake/lean processes. Could anyone confirm that?</p>",
        "id": 370125885,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1687882592
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/refresh.20file.20dependencies/near/370125885\">said</a>:</p>\n<blockquote>\n<p>This should mean that on Windows, restarting the entire server already kills runaway lake/lean processes. Could anyone confirm that?</p>\n</blockquote>\n<p>I think so, yes. I did the following to test:</p>\n<ul>\n<li>Update mathlib, do not get cache</li>\n<li>Open random deep mathlib file in VSCode -&gt; many <code>lean.exe</code> processes start (and keep starting and ending)</li>\n<li>Close file, open empty <code>.lean</code> file. -&gt; processes still continue and new processes continue to spawn</li>\n<li>Run <code>Lean 4: Restart Server</code> -&gt; server restarts, Lean processes this file, but no <code>lean.exe</code> process that uses <code>&gt;=1%</code> CPU remains, and no new <code>lean.exe</code> processes are spawned.</li>\n</ul>",
        "id": 370450429,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1687962218
    },
    {
        "content": "<p>So it seems like it is already mostly working correctly on Windows. It would be nice if closing a file would also stop the runaway lean processes.</p>",
        "id": 370451080,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1687962313
    },
    {
        "content": "<p>That's great to hear! And making sure the file worker is started through Lean as well would exactly take care of that last issue, yes!</p>",
        "id": 370460399,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1687963847
    },
    {
        "content": "<p>The rare scenario that actually works better on Windows than on all other platforms</p>",
        "id": 370460608,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1687963883
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/refresh.20file.20dependencies/near/370125677\">said</a>:</p>\n<blockquote>\n<p>So perhaps we want to keep that logic in elan and add a Unix analogue as well. Then we would only have to make sure that we start worker processes through elan</p>\n</blockquote>\n<p>I think the logic makes a lot of sense for <code>lake serve</code>.  But not at all for <code>lake env bash</code>.  IMHO this logic belongs in the file worker, not in elan.</p>",
        "id": 370512356,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1687972656
    },
    {
        "content": "<p>It might be more appropriate to solve in lake/lean than in elan, but now it also looks so much easier to solve in Rust than in Lean</p>",
        "id": 370517555,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1687973657
    },
    {
        "content": "<p>I want to address this issue this week, but I am undecided between the two approaches of where to handle the build discussed above:</p>\n<p>Keep building in the file worker:</p>\n<ul>\n<li>The issue of build process orphans is not affecting Windows and I know how to solve it on POSIX</li>\n<li>An option for preventing building when opening a file could be smuggled in as an extension of the <code>didOpen</code> request so that the editor can decide which actions should trigger a build</li>\n<li>Gabriel mentioned it would be nice to trigger dependency builds without depending on a running server, though I'm not sure what the use case for that is. In the end running the file worker is usually what we want to build the dependencies for. There is also a potential issue in racing server creation and Lake building when run as elan wrappers as elan toolchain installation is not safe to do concurrently.</li>\n<li>We should change the build progress message to include the entire log, with sufficient debouncing</li>\n</ul>\n<p>Move building to the editor:</p>\n<ul>\n<li>Needs to be reimplemented in each editor. If we make the new behavior opt-in, we can start with changing vscode-lean4 only, but also that is one of the parts of Lean that I know least about.</li>\n<li>Does it make sense not to reuse the info view for reporting progress on dependency builds? I feel an automatically popping up terminal window might be annoying, especially when having auto-build enabled. Though perhaps we can debounce that as well.</li>\n<li>How do we synchronize starting the file worker with building when auto-build is enabled? Is delaying <code>didOpen</code> in the middleware indefinitely safe?</li>\n</ul>",
        "id": 371960928,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1688382322
    },
    {
        "content": "<p>There are technical limitations as noted above, but I would also be interested in what people think would be the ideal interface longer term (tl;dr of technical message: should dependency building happen in the info view or in an editor terminal?). Note that in an ideal system, building also isn't destructive: build results would go into a user-wide cache that merely destructs your free filesystem space</p>",
        "id": 371968145,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1688383718
    },
    {
        "content": "<p>The info view would also be the correct approach if we want to eventually make dependency build message structured instead of plain text, even if they will never be interactive like message from the current file</p>",
        "id": 371984565,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1688386937
    },
    {
        "content": "<p>On the other hand, decoupling building and serving means that you do not lose the open file's state if building its dependencies fails. Oh dear...</p>",
        "id": 371985108,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1688387032
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> One other option for handling this would be to integrate the server watchdog with Lake and have it determine whether to build dependencies prior to opening a file worker on a <code>didOpen</code> request. I know we discussed integrated the watchdog with Lake previously and <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span>  was for the idea. This would also eliminate possible race conditions, as we would no longer be spawning multiple instances of Lake and remove start-up overhead (e.g., loading the workspace).</p>",
        "id": 372006896,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688390970
    },
    {
        "content": "<p>Though, admittedly, this may be more of a long-term solution, and maybe a shorter-term quick fix is more desirable.</p>",
        "id": 372007506,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688391075
    },
    {
        "content": "<p>I'm not sure I understand the significance of calling a Lake API in the watchdog vs calling a Lake cmdline in the file worker in this context</p>",
        "id": 372009616,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1688391459
    },
    {
        "content": "<p>I.e. what part this is meant to solve/improve</p>",
        "id": 372010092,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1688391537
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> The idea is to integrate watchdog code into <code>lake serve</code>, not the other way around. <a href=\"#narrow/stream/147302-lean4-maintainers/topic/LeanPaths/near/289386295\">Here</a> is the old thread, for reference. This would prevent races between multiple lakes, and inconsistencies that may result. It would also allow more configuration of how the server works through lakefile options (which may be useful for toggling <code>didOpen</code> builds or other such features).</p>",
        "id": 372013642,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688392161
    },
    {
        "content": "<p>It would also potentially allow for smart import processing , tagging modules with failed builds or falling back to old oleans if a build fails and tagging a warning on the module.</p>",
        "id": 372014352,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688392296
    },
    {
        "content": "<p>Oh I see, that direction. To be honest, I am not immediately concerned about any of these in the context of this thread. As for consistency, we still need process lock files if we want server and cmdline invocations (such as <code>cache get</code>) to coexist.</p>",
        "id": 372017485,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1688392834
    },
    {
        "content": "<p>I'm not too concerned about the \"lose the open file's state if building its dependencies fails\" issue.</p>\n<p>It seems like keeping things in the infoview is nicer to the user than opening terminal windows for them. I think I'd been in favour of terminal windows previously, but only to make it really obvious to the user where builds were actively happening. If we are confident that builds terminate when the relevant editor pane closes, and that builds initiated from different editor panes correctly wait for each other, then the terminal is clunky and the infoview is preferred.</p>\n<p>It sounds from what you say above that this is also easier, or at least less editor specific! It would be great to have these changes, so easy is good. :-)</p>",
        "id": 372210243,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1688456591
    },
    {
        "content": "<p>Thanks Scott, that is exactly what I wanted to hear <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span> . It is at the very least the approach I am personally more comfortable with implementing, yes.</p>",
        "id": 372211558,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1688456925
    },
    {
        "content": "<p>Step 1: <a href=\"https://github.com/leanprover/lean4/pull/2307\">lean4#2307</a></p>",
        "id": 372245692,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1688464536
    },
    {
        "content": "<p>Just tested locally, works great!</p>",
        "id": 372250292,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1688465393
    },
    {
        "content": "<p>Thanks for testing, we should have all platforms covered then!</p>",
        "id": 372253343,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1688466028
    }
]