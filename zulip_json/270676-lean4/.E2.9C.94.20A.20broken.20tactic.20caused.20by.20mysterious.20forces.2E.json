[
    {
        "content": "<p>Hi all, I'm trying to debug a tactic that stopped working after a certain commit in mathlib between mathlib v4.4.0 and v.4.5.0 (last year), specifically, going from mathlib git <code>132e5112a46</code> to <code>d3a6c9f3bd1</code>, where something that changed in <code>d3a6c9f3bd1</code> causes the break.  Here is the <a href=\"https://github.com/leanprover-community/mathlib4/commit/d3a6c9f3bd17193b002fdc5e540789c883605cc3?diff=split\">diff on github</a></p>\n<p>And, here is an example of the tactic in  proof that no longer works.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">numbers</span>\n</code></pre></div>\n<p>The <code>numbers</code> tactic is a nerfed <code>norm_num</code> and includes additional lemmas for clearing goals with Product types, but for some reason, the supporting code appears to be no longer applying the provided lemmas. By inspecting the trace output from <code>set_option trace.Tactic.norm_num true</code>, I see what looks like well managed infinite recursion with no progress:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">norm_num</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">NormNum</span><span class=\"bp\">.</span><span class=\"n\">evalFalse</span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"bp\">==&gt;</span><span class=\"w\"> </span><span class=\"n\">isFalse</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">not_false</span><span class=\"o\">)</span>\n\n<span class=\"o\">[</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">norm_num</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">NormNum</span><span class=\"bp\">.</span><span class=\"n\">evalFalse</span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"bp\">==&gt;</span><span class=\"w\"> </span><span class=\"n\">isFalse</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">not_false</span><span class=\"o\">)</span>\n\n<span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"bp\">&gt;...</span>\n</code></pre></div>\n<p>But, at least it's nice about it and fails quickly. So it looks like something changed with how the lemmas are traversed and chosen, or both, or not, I don't know. </p>\n<p>Here is the tactic code<br>\n<a href=\"https://github.com/drhodes/math2001/blob/main/Library/Tactic/Numbers/Basic.lean\">https://github.com/drhodes/math2001/blob/main/Library/Tactic/Numbers/Basic.lean</a></p>\n<p><a href=\"https://github.com/drhodes/math2001/blob/e660f42b13ddcb6d12b52ba036d6bd071a0cfb9b/Library/Tactic/Numbers/Basic.lean#L62\">Line 62</a> is where the lemmas are prepared:<br>\n<code>let lemmas := Library.Tactic.numbersProdLemmas.map (liftM &lt;| mkConstWithFreshMVarLevels ·)</code></p>\n<p>I suspect that line 62 might contain an error packed up in its monadic context (whatever that looks like for <code>TermElabM</code>), but line 63 is where it bails.</p>\n<p>A stack trace, or some way to step through the tactic execution would be really nice to have.</p>",
        "id": 512670341,
        "sender_full_name": "Derek Rhodes",
        "timestamp": 1744832739
    },
    {
        "content": "<p>I don't think norm_num is looping, this is a bad interaction of solve_by_elim and norm_num</p>",
        "id": 512677151,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744833998
    },
    {
        "content": "<p>norm_num seems to only ever be called on <code>False</code> and metavariables so it never does anything</p>",
        "id": 512677200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744834020
    },
    {
        "content": "<p>my guess is that what changed is that <code>solve_by_elim</code> now unfolds <code>a ≠ b</code> goals to <code>a = b |- False</code>, and in this setting a theorem like <code>Prod.ne_left</code> only makes things worse because it applies to any <code>False</code> goal and generates new metavariables</p>",
        "id": 512677496,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744834111
    },
    {
        "content": "<p>Here's an updated version of your tactic, including the tracing settings I used to debug it</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> Copyright (c) Heather Macbeth, 2023.  All rights reserved. -/</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Rat</span><span class=\"bp\">.</span><span class=\"n\">Cast</span><span class=\"bp\">.</span><span class=\"n\">Order</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">NormNum</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">NormNum</span><span class=\"bp\">.</span><span class=\"n\">OfScientific</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">NormNum</span><span class=\"bp\">.</span><span class=\"n\">Eq</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">NormNum</span><span class=\"bp\">.</span><span class=\"n\">Ineq</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">NormNum</span><span class=\"bp\">.</span><span class=\"n\">Pow</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">NormNum</span><span class=\"bp\">.</span><span class=\"n\">Inv</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">autoImplicit</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! # `numbers` tactic</span>\n\n<span class=\"cm\">The `numbers` tactic is a light modification of the Mathlib `norm_num1` tactic, to</span>\n<span class=\"cm\">(1) be finishing-only (it does not carry out normalizations mid-proof); the motivation for this is</span>\n<span class=\"cm\">    that such \"normalization\" proof steps are awkward to translate to prose proofs, so learning to</span>\n<span class=\"cm\">    work around them leads to better writing style;</span>\n<span class=\"cm\">(2) handle equalities and disequalities in product types;</span>\n<span class=\"cm\">(3) have a cleaner name (the `norm_num1` tactic is a variant of the more cleanly named `norm_num`,</span>\n<span class=\"cm\">    but that tactic, which incorporates `simp` calls, can confuse students by solving goals which</span>\n<span class=\"cm\">    seem to have nothing to do with the core \"numbers\" remit).</span>\n\n<span class=\"cm\">It is often convenient for teaching to further modify `norm_num1`/`numbers` by disabling some of the</span>\n<span class=\"cm\">`norm_num` extensions, when they perform calculations you wish your students to carry out by hand.</span>\n<span class=\"cm\">This can be done via an initializion command which is run in each file; for example, the</span>\n<span class=\"cm\">`math2001_init` command in this repository disables the `norm_num` extensions</span>\n<span class=\"cm\">`Mathlib.Meta.NormNum.evalNatDvd` and `Mathlib.Meta.NormNum.evalIntDvd`. -/</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">NormNum</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Library</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">numbersDischarger</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MVarId</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">MVarId</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">TermElabM</span><span class=\"bp\">.</span><span class=\"n\">run'</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">withTraceNode</span><span class=\"w\"> </span><span class=\"ss\">`Meta.debug</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"trying {← g.getType}\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">    </span><span class=\"n\">elabNormNum</span><span class=\"w\"> </span><span class=\"n\">mkNullNode</span><span class=\"w\"> </span><span class=\"n\">mkNullNode</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"bp\">.</span><span class=\"n\">missing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simpOnly</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">useSimp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">debug</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"s2\">\"failed\"</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">failure</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">ne_left</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a1</span><span class=\"w\"> </span><span class=\"n\">a2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b1</span><span class=\"w\"> </span><span class=\"n\">b2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a1</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">a2</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mt</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">mk_inj</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">left</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">ne_right</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a1</span><span class=\"w\"> </span><span class=\"n\">a2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b1</span><span class=\"w\"> </span><span class=\"n\">b2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b1</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">b2</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mt</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">mk_inj</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">right</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">ext'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a1</span><span class=\"w\"> </span><span class=\"n\">a2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b1</span><span class=\"w\"> </span><span class=\"n\">b2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Library</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">numbersProdLemmas</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">``Prod.ne_left</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">``Prod.ne_right</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">``Prod.ext'</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Normalize numerical expressions. Supports the operations `+` `-` `*` `/` `⁻¹` and `^`</span>\n<span class=\"sd\">over numerical types such as `ℕ`, `ℤ`, `ℚ`, `ℝ`, `ℂ` and some general algebraic types,</span>\n<span class=\"sd\">and can prove goals of the form `A = B`, `A ≠ B`, `A &lt; B` and `A ≤ B`, where `A` and `B` are</span>\n<span class=\"sd\">numerical expressions.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">numbers</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"numbers\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">liftMetaTactic</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">cfg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SolveByElim</span><span class=\"bp\">.</span><span class=\"n\">SolveByElimConfig</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">      </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">maxDepth</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">discharge</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Library</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">numbersDischarger</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">exfalso</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">,</span>\n<span class=\"w\">        </span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">lemmas</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Library</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">numbersProdLemmas</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">liftM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">mkConstWithFreshMVarLevels</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">SolveByElim</span><span class=\"bp\">.</span><span class=\"n\">solveByElim</span><span class=\"w\"> </span><span class=\"n\">cfg</span><span class=\"w\"> </span><span class=\"n\">lemmas</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">g</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"bp\">&lt;|&gt;</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"Numbers tactic failed. Maybe the goal is not in scope for the tactic (i.e. the goal is not a pure numeric statement), or maybe the goal is false?\"</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">numbersCore</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"numbers_core\"</span><span class=\"w\"> </span><span class=\"n\">loc</span><span class=\"o\">:(</span><span class=\"n\">location</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">elabNormNum</span><span class=\"w\"> </span><span class=\"n\">mkNullNode</span><span class=\"w\"> </span><span class=\"n\">mkNullNode</span><span class=\"w\"> </span><span class=\"n\">loc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simpOnly</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">useSimp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">done</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span><span class=\"w\"> </span><span class=\"n\">numbers</span><span class=\"kd\">]</span>\n<span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">numbersAt</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"numbers\"</span><span class=\"w\"> </span><span class=\"n\">loc</span><span class=\"o\">:</span><span class=\"n\">location</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">numbers_core</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">loc</span><span class=\"o\">)</span>\n\n<span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">normNumCmd</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"#numbers\"</span><span class=\"w\"> </span><span class=\"n\">ppSpace</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">conv</span><span class=\"w\"> </span><span class=\"n\">norm_num1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Tactic</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span><span class=\"w\"> </span><span class=\"n\">numbers</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">numbersConv</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"numbers\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">conv</span>\n\n<span class=\"sd\">/-- Elaborator for `numbers` conv tactic. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"n\">numbersConv</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">elabNormNum1Conv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">withMainContext</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getSimpContext</span><span class=\"w\"> </span><span class=\"n\">mkNullNode</span><span class=\"w\"> </span><span class=\"n\">mkNullNode</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"n\">Conv</span><span class=\"bp\">.</span><span class=\"n\">applySimpResult</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">deriveSimp</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Conv</span><span class=\"bp\">.</span><span class=\"n\">getLhs</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">useSimp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">))</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">solveByElim</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">debug</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">numbers</span>\n</code></pre></div>",
        "id": 512677719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744834195
    },
    {
        "content": "<p>adding <code>intro := false</code> to the <code>SolveByElimConfig</code> fixes the issue</p>",
        "id": 512680083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744835158
    },
    {
        "content": "<p>Thank you, may I ask which version of the toolchain you're using for this?</p>\n<p>I'm using  <code>leanprover/lean4:v4.5.0-rc1</code>. Why? I'm bisecting mathlib versions and running <code>lake update mathlib</code> <del>which overwrites the <code>lean-toolchain</code> file</del> <em>(edit: this does not seem to be true)</em>, so I assumed this is the version I should be using.</p>",
        "id": 512681122,
        "sender_full_name": "Derek Rhodes",
        "timestamp": 1744835532
    },
    {
        "content": "<p>I'm using the latest version</p>",
        "id": 512681163,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744835551
    },
    {
        "content": "<p>Ok, thank you.  I'll try using your suggestions to make some more progress.</p>",
        "id": 512681303,
        "sender_full_name": "Derek Rhodes",
        "timestamp": 1744835610
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"317929\">Derek Rhodes</span> has marked this topic as resolved.</p>",
        "id": 512681311,
        "sender_full_name": "Notification Bot",
        "timestamp": 1744835616
    }
]