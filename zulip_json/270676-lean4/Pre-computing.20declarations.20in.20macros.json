[
    {
        "content": "<p>My hope is to be able define a macro that does some expensive computations at the time a data structure is declared, involving some complicated data types (in particular, the outputs are not <code>Nat</code>s or <code>String</code>s, and so on) and expands to declarations with the results of the calculations. A simple MWE of a strategy that doesn't work is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Bit</span> <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"c1\">-- Stand-in for some complicated data type</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">getBits</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Bit</span> <span class=\"o\">:=</span> <span class=\"c1\">-- Stand-in for some expensive calculation</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">loop</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">acc</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Bit</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Bit</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">acc.push</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">acc.push</span> <span class=\"bp\">.</span><span class=\"n\">one</span>\n    <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">bitwise_rec_lemma</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">succ_ne_zero</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n      <span class=\"n\">loop</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">acc.push</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">if</span> <span class=\"n\">m</span> <span class=\"bp\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">==</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"k\">else</span> <span class=\"bp\">.</span><span class=\"n\">one</span><span class=\"o\">)</span>\n  <span class=\"n\">loop</span> <span class=\"n\">a</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"k\">in</span>\n<span class=\"n\">macro</span> <span class=\"s2\">\"new_data\"</span> <span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"s2\">\"with data: \"</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">num</span>\n  <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">bits</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">getBits</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span>\n      <span class=\"kn\">namespace</span> <span class=\"bp\">$</span><span class=\"n\">id</span>\n      <span class=\"kd\">def</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"bp\">`</span><span class=\"n\">bits</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Bit</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">bits</span>\n      <span class=\"kd\">end</span> <span class=\"bp\">$</span><span class=\"n\">id</span>\n    <span class=\"o\">)</span>\n</code></pre></div>\n<p>If I understand things correctly: right now if I declare <code>new_data blah with data: 10</code> then the macro basically expands to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">blah</span>\n<span class=\"kd\">def</span> <span class=\"n\">bits</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Bit</span> <span class=\"o\">:=</span> <span class=\"n\">getBits</span> <span class=\"mi\">10</span>\n<span class=\"kd\">end</span> <span class=\"n\">blah</span>\n</code></pre></div>\n<p>So if I ever call <code>blah.bits</code> it has to re-compute the <code>getBits</code> function which is not something I want to have repeated every time it's called.</p>\n<p>My hope was that I would be able to replace the macro with something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"k\">in</span>\n<span class=\"n\">macro</span> <span class=\"s2\">\"new_data\"</span> <span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"s2\">\"with data: \"</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">num</span>\n  <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">pNat</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">p.getNat</span>\n    <span class=\"k\">let</span> <span class=\"n\">bits</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Bit</span> <span class=\"o\">:=</span> <span class=\"n\">getBits</span> <span class=\"n\">pNat</span>\n    <span class=\"k\">let</span> <span class=\"n\">bitsSyntax</span> <span class=\"o\">:</span> <span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">term</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"c1\">-- Do something with `bits` to extract its syntax</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span>\n      <span class=\"kn\">namespace</span> <span class=\"bp\">$</span><span class=\"n\">id</span>\n\n      <span class=\"kd\">def</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"bp\">`</span><span class=\"n\">bits</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Bit</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">bitsSyntax</span>\n\n      <span class=\"kd\">end</span> <span class=\"bp\">$</span><span class=\"n\">id</span>\n    <span class=\"o\">)</span>\n</code></pre></div>\n<p>I know roughly that such a thing should be possible, because if the computations return <code>Nats</code> I can use <code>Lean.Syntax.mkNumLit</code>, and I get the behavior that I desired in those cases.</p>\n<p>Alternatively, if I have some fundamental misunderstanding of how Lean works and there's actually an easier way of doing this I'd be happy to hear any suggestions.</p>",
        "id": 325240902,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1675277281
    },
    {
        "content": "<blockquote>\n<p>So if I ever call blah.bits it has to re-compute the getBits function which is not something I want to have repeated every time it's called.</p>\n</blockquote>\n<p>This is not what's happening though.  Top-level declarations are only evaluated once:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bits</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">dbg_trace</span> <span class=\"s2\">\"expensive\"</span><span class=\"bp\">;</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n<span class=\"kd\">@[noinline]</span> <span class=\"kd\">def</span> <span class=\"n\">bigFunctionUsingBits</span> <span class=\"o\">:=</span> <span class=\"n\">bits</span>\n<span class=\"k\">#eval</span> <span class=\"n\">bits</span> <span class=\"bp\">++</span> <span class=\"n\">bigFunctionUsingBits</span> <span class=\"c1\">-- prints expensive once</span>\n</code></pre></div>\n<p>(You actually need to be really careful with this feature.  If you compile the Lean code into a native executable, then <code>bits</code> will be evaluated at initialization time, i.e., before <code>main</code>.  So make sure <code>bits</code> is not <em>too</em> expensive either.)</p>",
        "id": 325242748,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1675277743
    },
    {
        "content": "<p>Ok, this is great to know! I will see if I run into anything else with this, but I think I now have a sense of what to do going forward!</p>",
        "id": 325246226,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1675278699
    },
    {
        "content": "<p>If you actually want to evaluate at elaboration time, you should look into the <code>Quote</code> (<code>α → Syntax</code>, but has incorrect <code>Quote Syntax</code> instance!!!) and the <code>ToExpr</code> (<code>α → Expr</code>) classes.</p>",
        "id": 325247320,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1675279028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/270676-lean4/topic/Pre-computing.20declarations.20in.20macros/near/325242748\">said</a>:</p>\n<blockquote>\n<p>(You actually need to be really careful with this feature.  If you compile the Lean code into a native executable, then <code>bits</code> will be evaluated at initialization time, i.e., before <code>main</code>.  So make sure <code>bits</code> is not <em>too</em> expensive either.)</p>\n</blockquote>\n<p>is it possible to eliminate dead top-level decls from the initialization sequence? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 325256075,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1675281550
    },
    {
        "content": "<p>that is difficult because they are separately compiled</p>",
        "id": 325257406,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1675281908
    },
    {
        "content": "<p>each module produces an <code>initialize_Foo()</code> function which calls all the initializers in the file</p>",
        "id": 325257479,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1675281931
    },
    {
        "content": "<p>and at that point you don't know which of them will be used in the final executable</p>",
        "id": 325257516,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1675281946
    },
    {
        "content": "<p>Btw, if you have a dangling <code>def foo : Nat := sorry</code> that's not called, it will make your code panic everytime its compiled binary is executed.</p>\n<p>I understand why it happens, but the error message is not very insightful <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span><br>\nIIRC, it doesn't say where the panic is coming from</p>",
        "id": 325258321,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1675282219
    },
    {
        "content": "<p>Yeah that makes sense its a closed term so it gets extractedand closed terms are evaluated at the beginning</p>",
        "id": 325258869,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1675282427
    },
    {
        "content": "<p>And generally you can find the panics by using GDB and backtracing if you want to, I guess we could also just check if a certain decl has sorry (we already track sorryDep in the compiler) and just...not extract it if that is the case?</p>",
        "id": 325260238,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1675282889
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/Pre-computing.20declarations.20in.20macros/near/325260238\">said</a>:</p>\n<blockquote>\n<p>I guess we could also just check if a certain decl has sorry (we already track sorryDep in the compiler) and just...not extract it if that is the case?</p>\n</blockquote>\n<p>That's what I was about to suggest but having a <code>sorry</code> doesn't mean that such <code>sorry</code> will be hit</p>",
        "id": 325260643,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1675283005
    },
    {
        "content": "<p>You should also be aware of <a href=\"https://github.com/leanprover/lean4/pull/1965\">lean4#1965</a>, which is another unexpected way that code can be run on initialization.</p>",
        "id": 325260904,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1675283096
    },
    {
        "content": "<p>Another idea: catch panics from <code>sorry</code> during initialization and just skip that declaration. There might be an error later that will look like <code>unknown identifier blah</code>, but I think it's better than the current message.</p>\n<p>Is there some blocker that doesn't allow the initialization routine to see where that panic is coming from? (file name and line)</p>",
        "id": 325261530,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1675283283
    }
]