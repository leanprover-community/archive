[
    {
        "content": "<p>There is something wrong with either the synthesization order check, or the projection instance binder info. In <a href=\"https://github.com/leanprover/lean4/pull/5376\">lean#5376</a> a change was made to the projection instance binder info to be implicit.</p>\n<p>But in the following, if I try to define an instance exactly like the projection instance, Lean complains</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsSimpleGroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">IsSimpleGroup.toNontrivial {G : Type} {inst✝ : Group G} [self : IsSimpleGroup G] : Nontrivial G</span>\n<span class=\"cm\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">IsSimpleGroup</span><span class=\"bp\">.</span><span class=\"n\">toNontrivial</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">cannot find synthesization order for instance @instNontrivialOfIsSimpleGroup with type</span>\n<span class=\"cm\">  ∀ {G : Type} {x : Group G} [self : IsSimpleGroup G], Nontrivial G</span>\n<span class=\"cm\">all remaining arguments have metavariables:</span>\n<span class=\"cm\">  @IsSimpleGroup G ?x✝</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSimpleGroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 505859872,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742053698
    },
    {
        "content": "<p>The <code>Group G</code> argument is not determined exactly.</p>",
        "id": 505859922,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742053750
    },
    {
        "content": "<p>Since it is implicit now, it won't be solved for by typeclass.</p>",
        "id": 505859931,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742053765
    },
    {
        "content": "<p>I agree, and this means that the automatically generated <code>IsSimpleGroup.toNontrivial</code> is problematic.</p>",
        "id": 505860058,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742053841
    },
    {
        "content": "<p>I just noticed this issue last week, and I have some ideas for fixes that I hope will land by the end of the quarter.</p>",
        "id": 505860504,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742054165
    },
    {
        "content": "<p>It came up when trying to give all parent instances (even non-subobject parents) the same implicit argument rules for the type's parameters. These are basically user-defined instances.</p>",
        "id": 505860548,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742054212
    },
    {
        "content": "<p>Note that <code>IsSimpleGroup.toNontrivial</code> is not problematic since the synth order algorithm has special support for direct projections.</p>",
        "id": 505860596,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742054258
    },
    {
        "content": "<p>Edit: no, I read too quickly and misremembered the current algorithm, it's problematic.</p>",
        "id": 505860732,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742054351
    },
    {
        "content": "<p>I haven't run the proposal by anyone yet, since I wanted to test it first and see if it causes a performance impact, but here it is for your consideration:</p>\n<p>The rough idea:</p>\n<ul>\n<li>The synth order algorithm will see every implicit argument that's an instance as a true instance implicit argument. This allows projections to be used as instances, without needing to special case projections in the algorithm. Rationale: With projections, you don't want to resynthesize the type's parameters, since they're all determined by the <code>self</code> argument and should be solved for by unification. Rationale: non-subobject parents are not true projections, but they should be handled in the same way.</li>\n<li>If an instance argument has \"mixin arguments\" (which I am loosely defining as any instance arguments that appear anywhere in its type), then those mixin arguments will be synthesized after that argument. Heuristic: instances are supposed to be canonical, and the observation of <a href=\"https://github.com/leanprover/lean4/pull/5376\">lean#5376</a> was that most of the time they seem to be solved for by unification anyway. Heuristic: the argument's mixins give much less information about whether the instance will succeed than the argument itself.</li>\n</ul>",
        "id": 505861385,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742054802
    },
    {
        "content": "<p>I like this idea. How do you plan to deal with the more awkward cases where a \"mixin argument\" can't be determined by unification? For example in</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">NoMaxOrder</span><span class=\"bp\">.</span><span class=\"n\">infinite</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NoMaxOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Infinite</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>The parameter <code>Preorder α</code> appears in the parameter <code>NoMaxOrder α</code>, but only as a <code>LT</code> argument. This is annoying because it means that to failing to synthesize <code>Infinite _</code> (or <code>Nontrivial _</code>, <code>Nonempty _</code>) requires traversing the entire <code>Preorder</code> hierarchy.</p>",
        "id": 505890337,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742076767
    },
    {
        "content": "<p>I think what could happen is:</p>\n<p>We first synthesize <code>NoMaxOrder α</code>, and either this gives us as <code>LT</code> instance based on a <code>Preorder</code> instance, in which case we are happy because unification gives us the result.</p>\n<p>Or, unification gets stuck, which forces unification to resolve the stuck metavariable of type <code>Preorder α</code> using a nested type class search.</p>",
        "id": 505890737,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742077119
    },
    {
        "content": "<p>I also like that the synth order treats implicit/instance implicit binders the same. In the status quo, there are a bunch of instances that can be optimized by replacing the <code>[..]</code> binder by <code>{_ : ..}</code>, but that isn't nice to write or look at. I presume that the projection instance binder annotations can then go back to what they were before <a href=\"https://github.com/leanprover/lean4/pull/5376\">lean#5376</a>, because the difference doesn't really matter anymore.</p>",
        "id": 505893050,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742079146
    },
    {
        "content": "<p>For this example, the proposed algorithm would say the synth order is <code>Nonempty α</code>, <code>NoMaxOrder α</code>, and then <code>Preorder α</code>. Suppose we've found a <code>Nonempty</code> instance. My rough understanding then is:</p>\n<ul>\n<li>If there's obviously no <code>NoMaxOrder</code> that can apply, we are done.</li>\n<li>Otherwise, if there is a possible <code>NoMaxOrder</code>, it will try unifying the LT arguments. In this case it's <code>@Preorder.toLT α ?preorderInst</code>. Unifying against that is indeed a case of a stuck metavariable. However, class projections are special, and this does <em>not</em> trigger a nested type class search (see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.getStuckMVar%3F#doc\">docs#Lean.Meta.getStuckMVar?</a>).</li>\n<li>It then goes on to try to synthesize the <code>Preorder α</code> instance.</li>\n</ul>",
        "id": 505894730,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742080501
    },
    {
        "content": "<p>Actually looking at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meat.getStuckMVar%3F#doc\">docs#Lean.Meat.getStuckMVar?</a>, I see that it specifically <em>does</em> trigger a nested type class search \"if <code>e</code> is a type class projection that is stuck because the instance has not been synthesized yet.\"</p>",
        "id": 506008066,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742166372
    },
    {
        "content": "<p>Huh, you're right, I read it backwards. Earlier I tried making a example from <code>NoMaxOrder.infinite</code> that would trigger a nested type class search but I was having some trouble.</p>\n<p>Would you be interested in trying to verify whether it does or doesn't actually trigger a nested typeclass search with this example? You may need to turn off the synthOrder error and then override the synth order. I think it should be possible to do without modifying Lean; just some attributes and a <code>set_option</code>.</p>",
        "id": 506011421,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742167844
    },
    {
        "content": "<p>Yes, in this example setting the synthOrder to be #[2,3] does indeed trigger a nested type class search</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># Specify the synthesization order for instances</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Meta</span>\n\n<span class=\"sd\">/-- Specify the synthesization order for instances. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Instances</span><span class=\"bp\">.</span><span class=\"n\">setSynthOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">declName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">synthOrder</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoreM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">entry</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">instanceExtension</span><span class=\"bp\">.</span><span class=\"n\">getState</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">instanceNames</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"n\">declName</span><span class=\"w\"> </span><span class=\"bp\">|</span>\n<span class=\"w\">    </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"'{declName}' does not have [instance] attribute\"</span>\n<span class=\"w\">  </span><span class=\"n\">instanceExtension</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">entry</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">synthOrder</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">entry</span><span class=\"bp\">.</span><span class=\"n\">attrKind</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Meta</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Meta</span>\n\n<span class=\"sd\">/-- Specify the synthesization order for instances. -/</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"set_synth_order \"</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"n\">synthOrder</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">MatchExpr</span><span class=\"bp\">.</span><span class=\"n\">toDoubleQuotedName</span><span class=\"w\"> </span><span class=\"n\">name</span>\n<span class=\"w\">  </span><span class=\"n\">elabCommand</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">run_meta</span><span class=\"w\"> </span><span class=\"n\">Instances</span><span class=\"bp\">.</span><span class=\"n\">setSynthOrder</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">synthOrder</span><span class=\"o\">))</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">high</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">NoMaxOrder</span><span class=\"bp\">.</span><span class=\"n\">infinite</span>\n<span class=\"n\">set_synth_order</span><span class=\"w\"> </span><span class=\"n\">NoMaxOrder</span><span class=\"bp\">.</span><span class=\"n\">infinite</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">]</span>\n\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NoMaxOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">synthInstance</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Infinite</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">[Meta.synthInstance] ✅️ Infinite α ▼</span>\n<span class=\"cm\">  [] new goal Infinite α ▶</span>\n<span class=\"cm\">  [] ✅️ apply @NoMaxOrder.infinite to Infinite α ▶</span>\n<span class=\"cm\">  [] ✅️ apply inst✝¹ to Nonempty α ▶</span>\n<span class=\"cm\">  [resume] propagating Nonempty α to subgoal Nonempty α of Infinite α ▶</span>\n<span class=\"cm\">  [] ✅️ apply inst✝ to NoMaxOrder α ▼</span>\n<span class=\"cm\">    [tryResolve] ✅️ NoMaxOrder α ≟ NoMaxOrder α ▼</span>\n<span class=\"cm\">      [] ✅️ Preorder α ▼</span>\n<span class=\"cm\">        [] new goal Preorder α ▶</span>\n<span class=\"cm\">        [] ✅️ apply inst✝² to Preorder α ▶</span>\n<span class=\"cm\">        [] result inst✝²</span>\n<span class=\"cm\">    [answer] ✅️ NoMaxOrder α</span>\n<span class=\"cm\">  [] ✅️ Preorder α ▶</span>\n<span class=\"cm\">  [resume] propagating NoMaxOrder α to subgoal NoMaxOrder α of Infinite α ▶</span>\n<span class=\"cm\">  [] result NoMaxOrder.infinite</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 506115681,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742209345
    },
    {
        "content": "<p>Looking more closely, I am confused why the nested type class search is triggered</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">isDefEq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">NoMaxOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLT</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">52464</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">NoMaxOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLT</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">✝²</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">synthInstance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLT</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">✝²</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLT</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">✝²</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n</code></pre></div>\n<p>Because this unification problem is perfectly solvable with simple unification.</p>",
        "id": 506118781,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742210136
    },
    {
        "content": "<p>So I think that a fix to the unification algorithm is required, so that it only tries nested type class search when this is actually necessary.</p>",
        "id": 506119254,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742210244
    },
    {
        "content": "<p>Another bad instance that was recently added is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">HasCardinalFilteredColimits</span><span class=\"bp\">.</span><span class=\"n\">hasColimitsOfShape</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u₁</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u₁</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u₁</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">κ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cardinal</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fact</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"bp\">.</span><span class=\"n\">IsRegular</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasCardinalFilteredColimits</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SmallCategory</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">IsCardinalFiltered</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">HasColimitsOfShape</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"n\">C</span>\n</code></pre></div>\n<p>Where lean should complain that there is no way of determining <code>κ</code>. But I guess it doesn't complain because this function is a class projection.</p>",
        "id": 506246421,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742240777
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover/lean4/pull/9582\">lean#9582</a> I made an attempt at implementing the synth order algorithm that you hinted at. But CI keeps running forever, so it doesn't give me a mathlib testing branch. Does anyone know what's going on?</p>",
        "id": 531326093,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1753697062
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/9582\">lean#9582</a></p>",
        "id": 531356385,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1753705686
    },
    {
        "content": "<p>I've cancelled and restarted, but sorry, no, I don't know what's happening.</p>",
        "id": 531356936,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1753705843
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, I've now tried this, in a new PR where CI did work (<a href=\"https://github.com/leanprover/lean4/pull/9638\">lean#9638</a>).</p>\n<ul>\n<li>I reverted the binderInfo of projection instances back to what they should be</li>\n<li>\n<p>I changed the synthOrder algorithm to skip instances that appear as direct arguments in other instances. In the case of projection instances, which are of the form <code>A.toB {x₁ x₂ ... xₙ} [self : @A x₁ x₂ ... xₙ] : B</code>, all of the <code>x₁, x₂, ... xₙ</code> are direct arguments to the <code>self</code> instance, so we only need to synthesize <code>self</code>.<br>\nBut the same principle applies to other instances such as <code>[Group G] [IsKleinFour G] : IsAddKleinFour (Additive G)</code>, where the instance of <code>Group G</code> is a direct argument to <code>IsKleinFour G</code>, so we don't need to bother synthesizing <code>Group G</code>.</p>\n</li>\n<li>\n<p>An exception is made for instances that have <code>outParam</code>s. We don't skip synthesizing them because we need to make sure that the synthesized <code>outParam</code> is correct (and some other things went wrong too with such instances)</p>\n</li>\n</ul>\n<p>I encountered some issues</p>\n<ol>\n<li>Due to the special handling of projection instances, there are some cases that (in old versions of Lean) used to give a warning, but now don't. A few of these bad uses of <code>extends</code> have appeared since then. In particular <a href=\"https://github.com/leanprover-community/batteries/pull/1359\">batteries#1359</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/27941\">#27941</a> and <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/IsModuleFiltration/with/532031341\">#mathlib4 &gt; IsModuleFiltration</a>.</li>\n<li>The premise for the optimization in the synthOrder (either just in projection instances, or in general) is that instance arguments of type classes act like <code>semiOutParam</code>s, in the sense that they are allowed to be left as metavariables in type class search goals, and that they will be filled in by the type class search.<br>\nFor this reason, I also added a check to verify that instances satisfy this property. But unfortunately there are some instances in mathlib that rely on an instance argument being given. Some examples are <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Monoidal.fromInducedMonoidal#doc\">docs#CategoryTheory.Monoidal.fromInducedMonoidal</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Functor.Linear#doc\">docs#CategoryTheory.Functor.Linear</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SMul.comp.isScalarTower#doc\">docs#SMul.comp.isScalarTower</a> (which is added as a <code>local instance</code> somewhere) and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.BundledHom.hasForget#doc\">docs#CategoryTheory.BundledHom.hasForget</a> . Do you think it makes sense to check for this, and to fix breakages with <code>set_option synthInstance.checkSynthOrder false</code>? Or should we accept that the above premise simply doesn't always hold? (Or maybe we can have some kind of exensible mechanism to determine for which classes the optimization is allowed; currently it just isn't allowed for classes with outParams)</li>\n</ol>",
        "id": 532784449,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1754335523
    },
    {
        "content": "<p>I have now also made two issues for the problems I'm trying to solve: <a href=\"https://github.com/leanprover/lean4/pull/9727\">lean#9727</a> and <a href=\"https://github.com/leanprover/lean4/pull/9726\">lean#9726</a></p>",
        "id": 532887599,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1754390487
    }
]