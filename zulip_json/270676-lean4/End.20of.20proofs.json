[
    {
        "content": "<p>Are we really really sure we don't want to bring back the good old battle-tested <code>begin</code>/<code>end</code>? I just spent at least 10 minutes fighting a more sophisticated version of </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">calc</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>What do you expect as an error message here? The answer is an error on line 5 saying <code>expected ':='</code>. In my real example I used a tactic that was not <code>rfl</code> and giving it a list of arguments was plausible.</p>\n<p>A much simpler version not involving <code>calc</code> is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">assumption</span> <span class=\"n\">P</span>\n</code></pre></div>\n<p>Say I mixed up <code>exact</code> and <code>assumption</code>. Guess the error message? Of course it is <code>expected command</code>, and I understand why. The proof is over after <code>assumption</code> and Lean tries to process whatever comes after this proof. </p>\n<p>In both cases there is an error but the error message and/or its location are extremely confusing because nobody told Lean: here the proof should be over, and whatever comes next isn't part of it.</p>\n<p>This will be a nightmare for teaching but honestly I think we should also not do this in mathlib.</p>",
        "id": 355252973,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1683057353
    },
    {
        "content": "<p>I agree ... I opened <a href=\"https://github.com/leanprover/lean4/pull/1971\">lean4#1971</a> a while ago for a similar thing, do you want to add some comments there with these examples?</p>",
        "id": 355255612,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683058247
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355252973\">said</a>:</p>\n<blockquote>\n<p>This will be a nightmare for teaching</p>\n</blockquote>\n<p>and yes ... it does arise regularly in teaching.</p>",
        "id": 355255693,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683058282
    },
    {
        "content": "<p>Done.</p>",
        "id": 355256964,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1683058727
    },
    {
        "content": "<p>Can't Lean use the indent-based heuristics of python here?</p>",
        "id": 355257098,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683058784
    },
    {
        "content": "<p>We've already made the language indentation-sensitive, it seems like the worst of both worlds if you still can't deduce the program structure from the indentation alone</p>",
        "id": 355257261,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683058832
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355256964\">said</a>:</p>\n<blockquote>\n<p>Done.</p>\n</blockquote>\n<p>Yeah I've been using <code>done</code> too. It's a great substitute for <code>end</code>!</p>",
        "id": 355265560,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683061600
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355257261\">said</a>:</p>\n<blockquote>\n<p>We've already made the language indentation-sensitive, it seems like the worst of both worlds if you still can't deduce the program structure from the indentation alone</p>\n</blockquote>\n<p>If lean can't deduce structure by indentation, wouldn't  this problem just reappear in the form of confusion between section endings, namespace endings, and proof endings (for example which end should be followed by a namespace name)? I had this experience with  vhdl, which uses a bunch of different \"begins\" and \"ends\" with all sorts of variations in what is required after which sort of \"end\" like lean with namespaces.</p>",
        "id": 355282528,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683069377
    },
    {
        "content": "<p>At the very least we should give projects the option of enabling <code>begin ... end</code> (and disabling <code>by ...</code>?)</p>",
        "id": 355287771,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1683072841
    },
    {
        "content": "<p>If you add <code>begin...end</code> you would have an error on <code>end</code>, like it happens now with <code>done</code> right?</p>",
        "id": 355288457,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683073235
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>  I found two ways </p>\n<ol>\n<li>Using semicolons to delimit the end of a tactic:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">calc</span>\n    <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n      <span class=\"kd\">by</span> <span class=\"n\">rfl</span><span class=\"bp\">;</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"c1\">--  error shows at the semicolon</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"bp\">;</span>\n</code></pre></div>\n<ol start=\"2\">\n<li>Using <code>done</code> at the end as @Kevin suggests. </li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">calc</span>\n    <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n      <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"n\">done</span>                   <span class=\"c1\">-- Error shows here</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span>\n  <span class=\"n\">done</span>  <span class=\"c1\">-- Error shows here</span>\n</code></pre></div>",
        "id": 355294280,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683076543
    },
    {
        "content": "<p>Further as the following example shows, the issue is not with detecting the end of the proof itself. It is about detecting the end of the tactic line. Lean just puts the error at the beginning of the next line when the previous tactic line ends with a newline character. This issue won't be solved by adding <code>begin</code> and <code>end</code>. The solution is to use semicolons</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">calc</span>\n    <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rfl</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- changed here</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"c1\">-- error shows at the beginning of this line</span>\n      <span class=\"n\">rfl</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">assumption</span>\n</code></pre></div>\n<p>Semicolon solution:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">calc</span>\n    <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rfl</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"bp\">-</span> <span class=\"bp\">-</span> <span class=\"n\">error</span> <span class=\"n\">shows</span> <span class=\"n\">here</span> <span class=\"n\">now</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rfl</span><span class=\"bp\">;</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 355295207,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683077071
    },
    {
        "content": "<p>Somehow even though tpil says that tactics can be separated by either semicolons or newlines, maybe because of the way newlines are parsed, the errors show at the end of the last newline in the newline sequence.</p>",
        "id": 355295290,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683077126
    },
    {
        "content": "<p>Shreyas, of course you are right that the core issue is detecting the end of a tactic. My claim is that it becomes really super confusing when this issue infects the next declaration. I'm mostly thinking of my teaching where I give students a Lean file full of <code>sorry</code> that need to be replaced with a proof. In the current setup it's clear many students will think they solved an exercise because they see no error there and move to the next one and be utterly confused.</p>",
        "id": 355344507,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1683099010
    },
    {
        "content": "<p>Stupid idea: What about you insert <code>example : True := trivial</code> after each exercise? Then at least the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>-st exercise after is protected from errors propagating from the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>-th one.</p>",
        "id": 355344891,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1683099133
    },
    {
        "content": "<p>And it's true that semicolons fix a lot of things, but spending hours running around the computer labs to tell students they should put semicolons at the end of lines if no fun at all. I know that by insisting Lean shouldn't need semi-colons and still never get confused is basically asking Lean to read students' minds (or discard student input and automatically write the correct answer). But somehow python manages to do that. I remember that when we switch from Maple to Sage I feared that running around telling students to add semicolons would be replaced by running around telling student to fix their indentation, but this didn't happen. And I still run to tell students to add colons at the end of <code>if</code> and <code>for</code> lines...</p>",
        "id": 355345316,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1683099228
    },
    {
        "content": "<p>Does <code>done</code> also break it for teaching? I have found it a great replacement for <code>goals accomplished</code>. Plus it fills the role of writing <code>QED</code> at the end of the proof.  The error shows on the <code>done</code> line. </p>\n<p>I can't imagine it gets any better with <code>begin...end</code> because we will still have the problem of detecting the end of tactics inside the block. This would only be fully fixed a la lean 3 if the commas (equivalent to semicolons) are also reintroduced.  Until then the error will appear at <code>end</code> instead. Same as it does with <code>done</code> now. </p>\n<p>In case this is actually adopted , I would hope that we at least don't make it essential. Syntax-wise, the current syntax is consistent with the rest of the language. I intend to continue using it with <code>done</code>. Changing it everywhere will be very tedious. Further the parsing of the tactic block is done  by the parser at present. Changing this will mean making changes at the level of the parser. I just dug it up last night. So I don't know how well it works to offer an option</p>",
        "id": 355355745,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683102002
    },
    {
        "content": "<p>If we're worried at all about the multiple uses of <code>end</code> and Lean being happy to incorrectly use <code>end</code> as a synchronization point, we could choose new keywords for tactic blocks, like say <code>proof ... qed</code>.</p>\n<p>I wonder if we could also make a much stricter parser for <code>proof ... qed</code> blocks that only accepts reasonably-indented input and outputs reasonable errors if it's not indented correctly. I think it'd be fair to say that there must be a newline after <code>proof</code>, and then until the <code>qed</code> the way it could work is it reads in blocks of lines, broken up according to indentation, and then each of these blocks is parsed as a single complete tactic.</p>",
        "id": 355358148,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683102639
    },
    {
        "content": "<p>Basically, if <code>proof ... qed</code> blocks took the indentation as a <em>very</em> strong hint for resynchonization when there are parser errors (and for parsing too! a line break without extra indentation should end the tactic!), I think this would greatly reduce confusion for students writing tactic proofs.</p>",
        "id": 355359027,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683102852
    },
    {
        "content": "<p>The issue comes from somewhere around this line : <a href=\"https://github.com/leanprover/lean4/blob/f9da1d8b55ca6989297fb952985b7d8d6c77e14b/src/Lean/Parser/Term.lean#L74\">https://github.com/leanprover/lean4/blob/f9da1d8b55ca6989297fb952985b7d8d6c77e14b/src/Lean/Parser/Term.lean#L74</a></p>",
        "id": 355359235,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683102908
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355359027\">said</a>:</p>\n<blockquote>\n<p>Basically, if <code>proof ... qed</code> blocks took the indentation as a <em>very</em> strong hint for resynchonization when there are parser errors (and for parsing too! a line break should end the tactic!), I think this would greatly reduce confusion for students writing tactic proofs.</p>\n</blockquote>\n<p>That would also solve the original problem without the block</p>",
        "id": 355359414,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683102949
    },
    {
        "content": "<p>Part of the original problem is that there's not a good place for the error that the proof is not yet completed. Right now, it's a tiny red squiggle under \"by\", at the beginning of the proof, far away from your focus of attention when you're trying to finish a proof.</p>\n<p>I know you suggested <code>done</code>, but I'm not sure you can rely on anyone including something that's optional.</p>",
        "id": 355360555,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683103212
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355359027\">said</a>:</p>\n<blockquote>\n<p>Basically, if <code>proof ... qed</code> blocks took the indentation as a <em>very</em> strong hint for resynchonization when there are parser errors (and for parsing too! a line break without extra indentation should end the tactic!), I think this would greatly reduce confusion for students writing tactic proofs.</p>\n</blockquote>\n<p>also, currently if you use <code>done</code>,  <code>by...done</code> already does what I suspect would be the behaviour of <code>begin...end</code> (some speculation on my part here).</p>",
        "id": 355360565,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683103214
    },
    {
        "content": "<p>okay, so making <code>done</code> or <code>qed</code> a requirement to be the last tactic in a tactic block might do the trick perhaps?</p>",
        "id": 355360985,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683103311
    },
    {
        "content": "<p>I'm also not sure of what I'm saying is a good general solution for how to parse multi-line constructs. I just think it would be good for safe parsing to keep people from getting confused. Or maybe people would like it as scaffolding when writing proofs, then they take the scaffolding down at the end.</p>",
        "id": 355360991,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683103312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355360565\">said</a>:</p>\n<blockquote>\n<p>also, currently if you use <code>done</code>,  <code>by...done</code> already does what I suspect would be the behaviour of <code>begin...end</code> (some speculation on my part here).</p>\n</blockquote>\n<p>I think you need more parser support for <code>done</code> to be reliable. Tactics that accept a list of subsequent tactics can gobble this up if you get the indentation wrong.</p>",
        "id": 355361660,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683103464
    },
    {
        "content": "<p>Something that needs more thought still with <code>proof ... qed</code> is making sure that nested proofs also parse reliably. The bullet for focusing on a subgoal has a similar issue that you don't see the error that you're not done at the end of the sub-block (since there's nothing at the end).</p>",
        "id": 355362297,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683103617
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355361660\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355360565\">said</a>:</p>\n<blockquote>\n<p>also, currently if you use <code>done</code>,  <code>by...done</code> already does what I suspect would be the behaviour of <code>begin...end</code> (some speculation on my part here).</p>\n</blockquote>\n<p>I think you need more parser support for <code>done</code> to be reliable. Tactics that accept a list of subsequent tactics can gobble this up if you get the indentation wrong.</p>\n</blockquote>\n<p>\"If you get the indentation wrong\" =&gt; I think that's an issue with any indentation based language. python. haskell. ocaml.<br>\nThe support might be relatively simple to add here : <a href=\"https://github.com/leanprover/lean4/blob/f9da1d8b55ca6989297fb952985b7d8d6c77e14b/src/Lean/Parser/Term.lean#L64\">https://github.com/leanprover/lean4/blob/f9da1d8b55ca6989297fb952985b7d8d6c77e14b/src/Lean/Parser/Term.lean#L64</a></p>",
        "id": 355362318,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683103620
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355362297\">said</a>:</p>\n<blockquote>\n<p>Something that needs more thought still with <code>proof ... qed</code> is making sure that nested proofs also parse reliably. The bullet for focusing on a subgoal has a similar issue that you don't see the error that you're not done at the end of the sub-block (since there's nothing at the end).</p>\n</blockquote>\n<p>Currently, if you do change to something like <code>proof...qed</code> for the tactic block, wouldn't it also be used for all <code>have</code> and <code>let</code> proof blocks?</p>",
        "id": 355362751,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683103726
    },
    {
        "content": "<blockquote>\n<p>I think that's an issue with any indentation based language. python. haskell. ocaml.</p>\n</blockquote>\n<p>I should have given an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">by</span>\n  <span class=\"n\">classical</span>\n  <span class=\"n\">done</span>\n</code></pre></div>\n<p>The <code>classical</code> tactic is actually the start of a tactic block. If you don't indent after a tactic that starts a tactic block, then all the tactics after it are given to it.</p>\n<p>It's basically a tautology that in an indentation-based language if you get indentation wrong you have a problem, but this can be a fairly confusing way to get it wrong.</p>",
        "id": 355362943,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683103775
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355362943\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think that's an issue with any indentation based language. python. haskell. ocaml.</p>\n</blockquote>\n<p>I should have given an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">by</span>\n  <span class=\"n\">classical</span>\n  <span class=\"n\">done</span>\n</code></pre></div>\n<p>The <code>classical</code> tactic is actually the start of a tactic block. If you don't indent after a tactic that starts a tactic block, then all the tactics after it are given to it.</p>\n<p>It's basically a tautology that in an indentation-based language if you get indentation wrong you have a problem, but this can be a fairly confusing way to get it wrong.</p>\n</blockquote>\n<p>This seems like an incorrect way to get tactics into <code>classical</code>. Ideally the tactics that go with classical as a block should have an extra indent.</p>",
        "id": 355363497,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683103893
    },
    {
        "content": "<blockquote>\n<p>wouldn't it also be used for all have and let proof blocks?</p>\n</blockquote>\n<p>Sure, ideally, but I think you might need the <code>proof ... qed</code> parser to be aware of <code>proof ... qed</code> blocks to get the parsing right, and to be robust against accidental mistakes. For example, the <code>qed</code> probably would be lined up with <code>proof</code>, so the basic rule I suggested earlier wouldn't support sub-blocks.</p>",
        "id": 355363522,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683103897
    },
    {
        "content": "<p>by<br>\n  classical<br>\n      classical1<br>\n      classical2<br>\n      ...<br>\n     done<br>\n  done</p>",
        "id": 355363854,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683103959
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355363497\">said</a>:</p>\n<blockquote>\n<p>This seems like an incorrect way to get tactics into <code>classical</code>. Ideally the tactics that go with classical as a block should have an extra indent.</p>\n</blockquote>\n<p>Why is that the ideal? In a <code>classical</code> proof, generally you want to switch to classical mode and give a proof, so why should the entire proof have extra indentation on account of it using classical reasoning? (I actually prefer it without the indent.)</p>",
        "id": 355364156,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683104011
    },
    {
        "content": "<p>Here's another kind of example that shows up in mathlib:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">x</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">ctor</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">cases</span> <span class=\"n\">y</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">ctor</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span>\n</code></pre></div>",
        "id": 355364441,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683104068
    },
    {
        "content": "<p>Maybe we'll decide this is bad style eventually, but it can be thought of as being a simple destructuring assignment, so why should succeeding lines need to be intented?</p>",
        "id": 355364696,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683104132
    },
    {
        "content": "<p>Anyway, the point is that some people like this style, and they're examples where any <code>done</code> at the end gets consumed by a tactic.</p>",
        "id": 355364881,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683104169
    },
    {
        "content": "<p>For parsing synchronization's sake, having a special ending keyword that the beginning of a tactic block knows about would help avoid needing to worry about this issue.</p>",
        "id": 355365035,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683104202
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355364156\">said</a>:</p>\n<blockquote>\n<p>Why is that the ideal? In a <code>classical</code> proof, generally you want to switch to classical mode and give a proof, so why should the entire proof have extra indentation on account of it using classical reasoning? (I actually prefer it without the indent.)</p>\n</blockquote>\n<p>Because of the way the tactic actually behaves. If all it did was change some mode or add some hypothesis or something this would be fine. But it is reading the entire block of tactics that follows, as some argument(s), and executing them within it. This needs to be clear by syntax. At least that is my opinion</p>",
        "id": 355365126,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683104219
    },
    {
        "content": "<p>Arguably the fact that <code>classical</code> is a block scoping tactic in the first place is an implementation detail. It did not used to be</p>",
        "id": 355365932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683104414
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355365035\">said</a>:</p>\n<blockquote>\n<p>For parsing synchronization's sake, having a special ending keyword that the beginning of a tactic block knows about would help avoid needing to worry about this issue.</p>\n</blockquote>\n<p>As far as I can see, that is already the case with <code>by</code>. If you add a requirement for <code>done</code> or <code>qed</code>  there will be an end-marker too. That is why the request for <code>begin...end</code> confuses me. At present it wouldn't do anything substantially different from <code>by.... done</code>.  Maybe you have a more complex idea in mind</p>",
        "id": 355366006,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683104433
    },
    {
        "content": "<p>To really make the error message precise like in <code>lean 3</code> you would need a tactic delimiter that is not whitespace. Like <code>;</code>. This also exists.</p>",
        "id": 355366199,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683104476
    },
    {
        "content": "<p>I don't know that it is <em>required</em> to have a non-whitespace token after the proof to report errors there. You could report errors at the end of the last line, or the start of the next line, or the start of the line + indent if there is  any</p>",
        "id": 355366930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683104645
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355366930\">said</a>:</p>\n<blockquote>\n<p>I don't know that it is <em>required</em> to have a non-whitespace token after the proof to report errors there. You could report errors at the end of the last line, or the start of the next line, or the start of the line + indent if there is  any</p>\n</blockquote>\n<p>Right now, it seems to happening at after the line, at the end of the first separator. Hence my suspicion at line 78 above. Perhaps someone who knows the parser better than me could help.</p>",
        "id": 355367139,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683104698
    },
    {
        "content": "<p>line 78 of what?</p>",
        "id": 355367556,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683104812
    },
    {
        "content": "<p>but also I'm not talking about the current parser, I am aware it doesn't do this now but it could, at least when there is no parse error. The parse error examples are harder; I don't think lean has a good way to specify parser fallback behavior so it is not so configurable</p>",
        "id": 355368314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683104989
    },
    {
        "content": "<p>This line : <a href=\"https://github.com/leanprover/lean4/blob/f9da1d8b55ca6989297fb952985b7d8d6c77e14b/src/Lean/Parser/Term.lean#L64\">https://github.com/leanprover/lean4/blob/f9da1d8b55ca6989297fb952985b7d8d6c77e14b/src/Lean/Parser/Term.lean#L64</a></p>\n<p>The issue is explained in the example below. With the newline separator, we have the issue described where error appears at the next line on which there is code. With the  semicolon separator, the error appears on the semicolon after the line containing the error. <br>\n<span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355295207\">said</a>:</p>\n<blockquote>\n<p>Further as the following example shows, the issue is not with detecting the end of the proof itself. It is about detecting the end of the tactic line. Lean just puts the error at the beginning of the next line when the previous tactic line ends with a newline character. This issue won't be solved by adding <code>begin</code> and <code>end</code>. The solution is to use semicolons</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">calc</span>\n    <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rfl</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- changed here</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"c1\">-- error shows at the beginning of this line</span>\n      <span class=\"n\">rfl</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">assumption</span>\n</code></pre></div>\n<p>Semicolon solution:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">calc</span>\n    <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rfl</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"bp\">-</span> <span class=\"bp\">-</span> <span class=\"n\">error</span> <span class=\"n\">shows</span> <span class=\"n\">here</span> <span class=\"n\">now</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rfl</span><span class=\"bp\">;</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">assumption</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 355369709,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683105344
    },
    {
        "content": "<p>So what's happening here is that lean is ignoring (or bunching together) any extra linebreaks. and then reporting the error after the end of one tactic in the tactic sequence. At the end of the proof this happens when the next def or theorem line begins. But you can see this even within a proof. Take the first example above. But insert a few new lines after the error.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">calc</span>\n    <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rfl</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- changed here</span>\n\n\n\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"c1\">-- error shows at the beginning of this line</span>\n      <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 355370389,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683105499
    },
    {
        "content": "<p>This does not happen with the semicolon example</p>",
        "id": 355370494,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683105527
    },
    {
        "content": "<p>This is why I think what is happening is that here :<a href=\"https://github.com/leanprover/lean4/blob/f9da1d8b55ca6989297fb952985b7d8d6c77e14b/src/Lean/Parser/Term.lean#L74\">https://github.com/leanprover/lean4/blob/f9da1d8b55ca6989297fb952985b7d8d6c77e14b/src/Lean/Parser/Term.lean#L74</a><br>\nsomehow <code>checkNewLineBreak</code> doesn't care about one or more linebreaks. just that the last character was a line break.</p>",
        "id": 355370831,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683105604
    },
    {
        "content": "<p>this <code>checkLineBreak</code> function is defined here : <a href=\"https://github.com/leanprover/lean4/blob/f9da1d8b55ca6989297fb952985b7d8d6c77e14b/src/Lean/Parser/Basic.lean#L951\">https://github.com/leanprover/lean4/blob/f9da1d8b55ca6989297fb952985b7d8d6c77e14b/src/Lean/Parser/Basic.lean#L951</a></p>",
        "id": 355371157,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683105671
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355366006\">said</a>:</p>\n<blockquote>\n<p>At present it wouldn't do anything substantially different from <code>by.... done</code>.  Maybe you have a more complex idea in mind</p>\n</blockquote>\n<p>The algorithm I outlined in one of my first messages is substantially different from how <code>by ... done</code> parses. You could think of it as a change of the precedence level of certain kinds of whitespace.</p>\n<p>Think about how Python works for a moment: there is the statement level, which has knowledge of line indentation rules and a little bit about parentheses to handle line continuations (to avoid needing to always put <code>\\</code> at the end of a line continuation), and then there is the expression level. Roughly speaking, you can parse Python by first breaking everything up according to the statement level, and then you can parse the expressions later. This causes statement-breaking newlines to have a sort of change to the precedence level so that it tends toward being an \"operator\" between statements. Lean 4 is very different from Python in that it tries to solve the embedding-statements-in-expressions problem; Python has intentionally avoided this, and they just call code that would want this feature to be \"unpythonic\" (no multi-line statements inside <code>lambda</code>s for you).</p>\n<p>My suggestion is essentially to have a construct that switches to statement-level parsing rules.</p>\n<p>I want each \"statement\" in the block to be parsed individually <em>after</em> the block is segmented into statements. This prevents Lean from being creative in finding a way to continue parsing. (But it also allows the parser to continue to check whether succeeding statements parse, even if a preceding one has a parse error.)</p>\n<p>Consider this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"o\">(</span>\n  <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I want an error to be reported right after the <code>(</code>. It should be \"unexpected end of tactic; expected ')', ',' or ':'\". Right now, if this is at the end of a file, it reports the error after <code>rfl</code> and says \"unexpected end of input; expected ')', ',' or ':'\".</p>",
        "id": 355376323,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683106788
    },
    {
        "content": "<p>I don't think tweaking how whitespace is parsed could make this happen. It needs something more substantial to get the parser to commit to parsing individual statements.</p>",
        "id": 355377350,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683106961
    },
    {
        "content": "<p>This wouldn't be exactly how I would implement it (since it's somewhat leaky), but one could imagine that the parsing is done as if</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"n\">proof</span>\n  <span class=\"n\">cases</span> <span class=\"o\">(</span>\n  <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n<span class=\"n\">qed</span>\n</code></pre></div>\n<p>is written as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"o\">(</span> <span class=\"o\">}</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>but imagine for the moment that <code>{ ... }</code> doesn't focus and doesn't require that the goal be solved.</p>",
        "id": 355380005,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683107462
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355376323\">said</a>:</p>\n<blockquote>\n<p>My suggestion is essentially to have a construct that switches to statement-level parsing rules. I want each \"statement\" in the block to be parsed individually <em>after</em> the block is segmented into statements.</p>\n</blockquote>\n<p>As far as I know, the current parser is a top down recursive descent parser.  so if what you are suggesting is that the statements be parsed after they are all separated. I am not sure how this can be implemented in a parsec style parser.</p>\n<blockquote>\n<p>This prevents Lean from being creative in finding a way to continue parsing. (But it also allows the parser to continue to check whether succeeding statements parse, even if a preceding one has a parse error.)</p>\n<p>Consider this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"o\">(</span>\n  <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I want an error to be reported right after the <code>(</code>. It should be \"unexpected end of tactic; expected ')', ',' or ':'\". Right now, if this is at the end of a file, it reports the error after <code>rfl</code> and says \"unexpected end of input; expected ')', ',' or ':'\".</p>\n</blockquote>\n<p>Semicolon does this already. The problem is the way the newline tactic separator seems to work.  It seems to read until the next line with code begins and puts an error just before that. The semicolon parser is much simpler. It essentially says \"look there's a semicolon. this tactic line is over\"</p>",
        "id": 355381139,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683107753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355381139\">said</a>:</p>\n<blockquote>\n<p>As far as I know, the current parser is a top down recursive descent parser.  so if what you are suggesting is that the statements be parsed after they are all separated. I am not sure how this can be implemented in a parsec style parser.</p>\n</blockquote>\n<p>You make a special <code>proof ... qed</code> parser that is <code>proof...qed</code>-aware, sort of like how nested comments are parsed, then you split it up, then run the whole tactic parser on each segmented statement. This causes the parser to commit. In principle this is doable, which is why I was suggesting it.</p>",
        "id": 355382275,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683108033
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355381139\">said</a>:</p>\n<blockquote>\n<p>Semicolon does this already.</p>\n</blockquote>\n<p>Don't forget one of the design requirements: Patrick doesn't want to run around the computer lab reminding people to insert semicolons <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 355382442,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683108076
    },
    {
        "content": "<p>The fix for this is to change where the error is reported (I think elaborator). If the errors were to be reported at the beginning of the line in which an error is found instead of right after it, or just before the tactic separator rather than after, that might fix the issue as @Mario says.</p>",
        "id": 355383028,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683108227
    },
    {
        "content": "<p>I don't think that sort of thing is a full fix though -- I believe we want parser errors to be <em>completely</em> localized to individual tactics. Making changes to preceding lines in a tactic block shouldn't affect whether later lines parse correctly.</p>",
        "id": 355383441,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683108331
    },
    {
        "content": "<p>I have never tried to mix two different kinds of parsers before. It sounds very risky. Maybe the parsec experts can shed more light on this.</p>",
        "id": 355383728,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683108391
    },
    {
        "content": "<p>I'm not sure what the issue is here -- you can definitely do this with a Parsec-style parser.</p>",
        "id": 355384349,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683108539
    },
    {
        "content": "<p>If you're worried about memoization in the packrat parser, that's not an issue since this would be getting it to commit to a particular high-level parse.</p>",
        "id": 355384788,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683108646
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355384788\">said</a>:</p>\n<blockquote>\n<p>If you're worried about memoization in the packrat parser, that's not an issue since this would be getting it to commit to a particular high-level parse.</p>\n</blockquote>\n<p>how would you do the high level parse with a recursive descent parser without going to lower levels?</p>",
        "id": 355385056,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683108701
    },
    {
        "content": "<p>would it look like \"parse until you meet this character and call it a tactic\"? what happens if this character appears unstructurally inside the tactic line (say inside some string literal  or part of some other operator). More generally, how does the demarcation of where to use the high level parser and where to use the low level parser work?</p>",
        "id": 355385442,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683108782
    },
    {
        "content": "<p>When does the high level parser know that it has to call the low level parser? <br>\nEither </p>\n<ol>\n<li>It doesn't run inside the tactic blocks because that's the lower level parser's job. It can only tell apart these blocks by lexemes. </li>\n<li>It does parse the tactic block just to identify it and then calls the lower level parser for tactic blocks on this same block.  So it wastes effort and doesn't solve our problem because it misidentifies the end of the block, which is the problem we started with.</li>\n</ol>",
        "id": 355389610,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683109628
    },
    {
        "content": "<p>Further, if as Patrick says it is plausible for a list of arguments to exist in the non-simplified version of his example, then how would you detect the end of a tactic without explicit separation characters like the semicolon if you are not looking inside the tactic lines anyway.</p>",
        "id": 355394616,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683110797
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355376323\">said</a>:</p>\n<blockquote>\n<p>Consider this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"o\">(</span>\n  <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I want an error to be reported right after the <code>(</code>. It should be \"unexpected end of tactic; expected ')', ',' or ':'\". Right now, if this is at the end of a file, it reports the error after <code>rfl</code> and says \"unexpected end of input; expected ')', ',' or ':'\".</p>\n</blockquote>\n<p>AFAIK this is a deliberate design choice. When you open a parenthesis it clears all the state regarding whitespace sensitivity so that it is legal to write e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"kd\">by</span>\n <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n  <span class=\"o\">)</span>\n</code></pre></div>",
        "id": 355395523,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683111034
    },
    {
        "content": "<p>you don't know that the <code>exact rfl</code> is part of the outer <code>by</code> block in your example, and the <code>(</code> is a strong signal that it isn't</p>",
        "id": 355395832,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683111109
    },
    {
        "content": "<p>and for examples like the unindented <code>classical</code> it really isn't</p>",
        "id": 355395934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683111126
    },
    {
        "content": "<p>so this behavior can only be considered as a fallback behavior, because it will give the wrong answers for successful parses</p>",
        "id": 355396183,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683111175
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355382442\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355381139\">said</a>:</p>\n<blockquote>\n<p>Semicolon does this already.</p>\n</blockquote>\n<p>Don't forget one of the design requirements: Patrick doesn't want to run around the computer lab reminding people to insert semicolons <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n</blockquote>\n<p>So why don't we just make the semicolons mandatory? Then the compiler will do the job of reminding people to insert semicolons.</p>\n<p>This discussion reminds me a bit of javascript, which does automatic insertion of semicolons in some cases, but the consensus seems to be that the errors are just too confusing when it guesses wrong, so people advocate for just always using a semicolon to end a statement. JS can't go back to mandating semicolons for backwards compatibility reasons, but we still can. And I'd argue that the benefit of clearer errors far outweighs the extra effort/noise in having to write some explicit tactic terminator (whether that is a comma or a semicolon).</p>",
        "id": 355396915,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1683111342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355396915\">said</a>:</p>\n<blockquote>\n<p>JS can't go back to mandating semicolons for backwards compatibility reasons</p>\n</blockquote>\n<p>At this point we would also have \"backward compatibility\" problems since mathlib4 already has some thousand odd files, and then there is Aesop, Std, and all the docs and tutorial materials.</p>",
        "id": 355397944,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683111617
    },
    {
        "content": "<p>Adding a compiler warning might be a nice tradeoff, if the respective CIs can be configured to ignore it</p>",
        "id": 355398226,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683111670
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355397944\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355396915\">said</a>:</p>\n<blockquote>\n<p>JS can't go back to mandating semicolons for backwards compatibility reasons</p>\n</blockquote>\n<p>At this point we would also have \"backward compatibility\" problems since mathlib4 already has some thousand odd files, and then there is Aesop, Std, and all the docs and tutorial materials.</p>\n</blockquote>\n<p>Nope, those are quite explicitly not blockers to syntax changes. We promised as much to the devs. We will need to make conversion scripts or something if it is a really invasive change, but I don't think this is a major concern.</p>",
        "id": 355398849,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683111858
    },
    {
        "content": "<p>(that is not to say that I agree with a syntax change in this area)</p>",
        "id": 355399268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683111971
    },
    {
        "content": "<p>I would definitely prefer this to be limited to an error reporting change, or a change to the parsing of expressions that already contain a syntax error. I think that for completed code the current syntax of lean 4 is quite good</p>",
        "id": 355399522,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683112033
    },
    {
        "content": "<p>Kyle's example is difficult because</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"o\">(</span>\n  <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n  <span class=\"o\">)</span>\n</code></pre></div>\n<p>is actually correct code (well it's not a syntax error at least). So you need to make it all the way to the end, get a parse error somewhere, then backtrack to the <code>(</code> and auto-close it, report a syntax error there, and then continue parsing the rest of the block</p>",
        "id": 355400682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683112343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355399522\">said</a>:</p>\n<blockquote>\n<p>I would definitely prefer this to be limited to an error reporting change, or a change to the parsing of expressions that already contain a syntax error. I think that for completed code the current syntax of lean 4 is quite good</p>\n</blockquote>\n<p>Does this mean that you support keeping the current <code>by</code> syntax for tactic blocks, at least as one way to write tactics?</p>",
        "id": 355401561,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683112578
    },
    {
        "content": "<p>yes I haven't seen any issue where <code>by</code> is the root cause rather than one component in an issue caused by the interaction of several features</p>",
        "id": 355402822,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683112913
    },
    {
        "content": "<p>Of course, we should keep existing code in mind and not break it needlessly. We could introduce an <code>autoSemicolon</code> option to control this behaviour. Then existing code can opt-out of strict semicolons, while new projects can benefit from it. Or, we keep the default as-is, but teaching projects can opt-in to the stricter syntax so that students can avoid the confusing errors.</p>",
        "id": 355403572,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1683113094
    },
    {
        "content": "<p>From a pure \"code aesthetics\" perspective, I'd find a python-like approach (i.e. without semicolons) better, since it's less clutter. We already have whitespace-sensitivity, so let's go with that. Also if I read <code>exact h x;</code> and don't know much about Lean syntax, my eyes might parse it as <code>exact (h) (x;)</code> which is obviously wrong. But I don't know enough nitty-gritty details to weigh in more than this.</p>",
        "id": 355403631,
        "sender_full_name": "Max Nowak 🐉",
        "timestamp": 1683113103
    },
    {
        "content": "<p>I'll freely admit that I'm more of a fan of explicit delimiters and having a formatter figure out indentation for me. But this is of course mostly a matter of taste / whatever someone is used to.</p>",
        "id": 355404217,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1683113254
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355400682\">said</a>:</p>\n<blockquote>\n<p>Kyle's example is difficult because</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"o\">(</span>\n  <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n  <span class=\"o\">)</span>\n</code></pre></div>\n<p>is actually correct code (well it's not a syntax error at least). So you need to make it all the way to the end, get a parse error somewhere, then backtrack to the <code>(</code> and auto-close it, report a syntax error there, and then continue parsing the rest of the block</p>\n</blockquote>\n<p>My understanding of Kyle's proposal is that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"n\">proof</span>\n  <span class=\"n\">cases</span> <span class=\"o\">(</span>\n  <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n  <span class=\"o\">)</span>\n<span class=\"n\">qed</span>\n</code></pre></div>\n<p>should be incorrect code.</p>\n<p>But maybe I completely misunderstood...</p>",
        "id": 355405253,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1683113484
    },
    {
        "content": "<p>Yes, it'd be incorrect code because it would parse roughly as if it were</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">focus</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"o\">(</span> <span class=\"o\">}</span>\n  <span class=\"n\">focus</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span> <span class=\"o\">}</span>\n  <span class=\"n\">focus</span> <span class=\"o\">{</span> <span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>where again <code>focus { ... }</code> means <code>focus ...</code> rather than using <code>{ ... }</code>.</p>\n<p>If you want the other parse, I'm suggesting that you have to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"n\">proof</span>\n  <span class=\"n\">cases</span> <span class=\"o\">(</span>\n    <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n    <span class=\"o\">)</span>\n<span class=\"n\">qed</span>\n</code></pre></div>\n<p>instead, where indentation is what is used to segment into statements.</p>",
        "id": 355407000,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683113807
    },
    {
        "content": "<p>yes, I would be opposed to that. I want to be able to <em>turn off whitespace sensitivity</em> locally by <em>some</em> syntax, because it might not always be reasonable to just keep indenting</p>",
        "id": 355407350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683113871
    },
    {
        "content": "<p>(Not a response to mario) I'm suggesting something that's somewhat different from Python: it would not be aware of <code>(</code> and <code>)</code>, and it would rely on indentation. This seems like a reasonable compromise since in Python you use <code>f(x,y,z)</code> notation for functions rather than <code>f x y z</code>, so it avoids needing end-of-line <code>\\</code>'s.</p>",
        "id": 355407437,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683113884
    },
    {
        "content": "<blockquote>\n<p>it avoids needing end-of-line <code>\\</code>'s.</p>\n</blockquote>\n<p>I'm not sure it does, because in your setup the line reigns supreme regarding how the sequence parses, so if you need to indicate that two lines are to be treated as one...?</p>",
        "id": 355408247,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683114057
    },
    {
        "content": "<p>Use more identation for continuation lines. It's not perfect, but for the purpose of making a sane environment for teaching, it seems easy to explain and understand.</p>",
        "id": 355408562,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683114122
    },
    {
        "content": "<p>I'm not suggesting that this design ever make it into mathlib code, to be clear.</p>",
        "id": 355408735,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683114166
    },
    {
        "content": "<p>for example, let's say you want to refer to an expression containing some long identifiers and stay within line limits. In that case you might use parentheses and newlines, and quite possibly break indentation</p>",
        "id": 355408766,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683114174
    },
    {
        "content": "<p>I know there are some examples of string literals that break indentation in mathlib</p>",
        "id": 355408898,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683114212
    },
    {
        "content": "<p>Then, sure, there could be <code>\\</code>'s to help with that. Not every such problem can be solved with parentheses, so these would be needed at some point to solve that problem.</p>",
        "id": 355408982,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683114232
    },
    {
        "content": "<p>(Re string literals: I wish we had something like the Haskell-style string continuation syntax:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"s2\">\"I am a</span><span class=\"err\">\\</span>\n<span class=\"s2\">     </span><span class=\"err\">\\</span><span class=\"s2\"> string.\"</span>\n<span class=\"c1\">--&gt;</span>\n    <span class=\"s2\">\"I am a string.\"</span>\n</code></pre></div>\n<p>All the whitespace between <code>\\</code> and <code>\\</code> is deleted.)</p>",
        "id": 355409371,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683114315
    },
    {
        "content": "<p>yeah this seems like an oversight</p>",
        "id": 355409448,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683114343
    },
    {
        "content": "<p>I'm very much in favour of creating a fool-proof proof-environment for teaching purposes. It doesn't need to be power-user-friendly.</p>",
        "id": 355409456,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1683114344
    },
    {
        "content": "<p>I agree that Kyle's proposal would work well in that setting, since complex tactics generally don't arise</p>",
        "id": 355410045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683114499
    },
    {
        "content": "<p>I don't know whether it is possible to literally segment the text and give fragments to the inner parsers so that they don't bleed into each other</p>",
        "id": 355410150,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683114527
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355410150\">said</a>:</p>\n<blockquote>\n<p>I don't know whether it is possible to literally segment the text and give fragments to the inner parsers so that they don't bleed into each other</p>\n</blockquote>\n<p>How would it be done reliably?</p>",
        "id": 355410595,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683114635
    },
    {
        "content": "<p>If you have to do it with raw text then how do you distinguish real segmenting characters from spurious occurrences. If you do use the outer parser, and then all the issues in the outer-parser could be a problem (i.e. bleed into the inner parser) in the segmentation.</p>",
        "id": 355411452,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683114827
    },
    {
        "content": "<p>Ah, here's what you could do:</p>\n<ul>\n<li>First, pre-parse the text using the outer parser (line / indent segmentation) to get regions for the inner parser</li>\n<li>Then use the inner parser (tactic item parser) to parse the text<ul>\n<li>If it returns a parse error, but the position of the error is outside its region, adjust the location of the error to the end of the region</li>\n<li>If it succeeds but the end position is outside the region, report an error at the end of the region</li>\n<li>If it succeeds inside the region, proceed</li>\n</ul>\n</li>\n</ul>",
        "id": 355411625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683114860
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355389610\">said</a>:</p>\n<blockquote>\n<p>When does the high level parser know that it has to call the low level parser? <br>\nEither </p>\n<ol>\n<li>It doesn't run inside the tactic blocks because that's the lower level parser's job. It can only tell apart these blocks by lexemes. </li>\n<li>It does parse the tactic block just to identify it and then calls the lower level parser for tactic blocks on this same block.  So it wastes effort and doesn't solve our problem because it misidentifies the end of the block, which is the problem we started with.</li>\n</ol>\n</blockquote>\n<p>you mean point 2 here?</p>",
        "id": 355411738,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683114886
    },
    {
        "content": "<p>The bad part is that you get subpar error messages if you have to stop the parse early. If you could modify the input text then you could call the inner parser where the end of the region is actually EOF</p>",
        "id": 355411898,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683114924
    },
    {
        "content": "<p>The outer parser is not calling the inner parser during the pre-parse stage. It is just looking at lines and indentation</p>",
        "id": 355412388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683115015
    },
    {
        "content": "<p>it can't rely on the inner parser because the line could have a typo like <code>assumption h</code></p>",
        "id": 355412544,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683115053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355412388\">said</a>:</p>\n<blockquote>\n<p>The outer parser is not calling the inner parser during the pre-parse stage. It is just looking at lines and indentation</p>\n</blockquote>\n<p>how does this outer parser / inner parser thing work when you have nested proof blocks? such as Kyle's <code>classical</code> block?</p>",
        "id": 355412612,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683115066
    },
    {
        "content": "<p>Simple algorithm that works even without Lean having a lexer:</p>\n<ol>\n<li>The <code>proof</code> keyword triggers the proof block parser. For the following, assume comments count as whitespace.</li>\n<li>Ensure that there is only whitespace for the rest of the line after <code>proof</code>.</li>\n<li>Read lines one at a time, ensuring that they all have at least as much indentation as <code>proof</code>. Use indentation and <code>\\</code>'s to combine lines into statements. Rule: all succesive lines with more indentation than the current line get combined into the statement. If any of these lines start with the keyword <code>qed</code>, then fail.</li>\n<li>If a line starts with the <code>proof</code> keyword, then recurse.</li>\n<li>Parse a <code>qed</code> and make sure it has the same indentation level as <code>proof</code>.</li>\n</ol>\n<p>Now that these are segmented, give the statement text (and only the statement text) to the tactic parser. Maybe Mario's tricks might be needed, but ideally the errors can be reported as-is, or at least their positions can be translated to a position in the original source file.</p>",
        "id": 355412649,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683115078
    },
    {
        "content": "<blockquote>\n<p>If any of these lines start with the keyword qed, then fail.</p>\n</blockquote>\n<p>Not sure about this one, it means you can't have nested proof blocks at all. I would rather say that the <code>qed</code> has to have the same indent as the <code>proof</code></p>",
        "id": 355413127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683115189
    },
    {
        "content": "<p>This is meant to be covered by \"recurse\" in step 4. Step 5 is to find that <code>qed</code>. Maybe my steps aren't perfectly accurate as written, but it sounds like you know what I'm trying to say.</p>",
        "id": 355413504,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683115281
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355412649\">said</a>:</p>\n<blockquote>\n<p>Simple algorithm that works even without Lean having a lexer:</p>\n<ol>\n<li>The <code>proof</code> keyword triggers the proof block parser. For the following, assume comments count as whitespace.</li>\n</ol>\n</blockquote>\n<p>So if I write a comment outside the proof block that contains the word proof, I am doomed.</p>\n<blockquote>\n<ol start=\"2\">\n<li>Ensure that there is only whitespace for the rest of the line after <code>proof</code>.</li>\n</ol>\n</blockquote>\n<p>A single careless whitespace by a student wold trip them up and they would have trouble finding it.  Further how would this work with nested statements and <code>have</code>s and let`s</p>\n<blockquote>\n<ol start=\"3\">\n<li>Read lines one at a time, ensuring that they all have at least as much indentation as <code>proof</code>. Use indentation and <code>\\</code>'s to combine lines into statements. Rule: all succesive lines with more indentation than the current line get combined into the statement. If any of these lines start with the keyword <code>qed</code>, then fail.</li>\n</ol>\n</blockquote>\n<p>What <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  says, and proof blocks.</p>\n<blockquote>\n<ol start=\"4\">\n<li>Parse a <code>qed</code> and make sure it has th esame indentation level as <code>proof</code>.</li>\n<li>Now that these are segmented, give the statement text (and only the statement text) to the tactic parser. Maybe Mario's tricks might be needed, but ideally the errors can be reported as-is, or at least their positions can be translated to a position in the original source file.</li>\n</ol>\n</blockquote>",
        "id": 355413612,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683115311
    },
    {
        "content": "<p>No I mean in step 3 you will see an inner <code>qed</code> and fail while segmenting the outer <code>proof</code></p>",
        "id": 355413699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683115325
    },
    {
        "content": "<p>I don't think it is necessary to reinvent the indentation parsing, and TBH it would go against lean's architecture a bit. It is easier just to let the lexer do its work</p>",
        "id": 355414050,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683115418
    },
    {
        "content": "<p>the only tricky part, as I mentioned, is that you have to actually modify the input text when calling the inner parser, because nothing short of EOF will stop these parsers for sure</p>",
        "id": 355414347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683115478
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> What's your high-level argument here? I have to admit I'm baffled why you seem to be so opposed to this design. The only thing that I can really think of is that you think <code>by ... done</code> and requiring semicolons should be sufficient, so proving that this design could never work is what you think you need to do.</p>",
        "id": 355414348,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683115478
    },
    {
        "content": "<p>also if you do just pull out a bit of text then the reported positions will be wrong, although that seems fixable</p>",
        "id": 355414539,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683115524
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355414348\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> What's your high-level argument here? I have to admit I'm baffled why you seem to be so opposed to this design. The only thing that I can really think of is that you think <code>by ... done</code> and requiring semicolons should be sufficient, so proving that this design could never work is what you think you need to do.</p>\n</blockquote>\n<p>I am opposed because switching between two different parsers based on segmentation is a highly error prone way to do things. Especially when you start including nested proof blocks, statements, some term language stuff and so on, so you have to keep track of state and switch outer-parser -&gt; inner-parser -&gt; outer-parser -&gt; inner-parser and so on. And since this would be in the parser, there could be a huge number of downstream errors this causes.</p>",
        "id": 355414871,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683115606
    },
    {
        "content": "<p>Kyle's description should probably be paired with mine, there is no switching of parsers here. He described the behavior of the outer pre-parser (my step 1) and I described how it interacts with the inner parser</p>",
        "id": 355415459,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683115746
    },
    {
        "content": "<p>Actually I would leave off Kyle's step 4, the pre-parser isn't doing any recursion</p>",
        "id": 355415606,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683115791
    },
    {
        "content": "<p>the recursion would happen when the inner parser is called on a block that happens to call into the <code>proof</code> parser</p>",
        "id": 355415926,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683115858
    },
    {
        "content": "<p>I think there are two possible implementations here. I was thinking the <code>proof</code> parser could keep track of a tree of <code>proof ... qed</code> blocks, so that way the <code>qed</code> is allowed to violate the indentation continuation rule, but I don't really care about what the specific implementation is so long as you get localized errors.</p>",
        "id": 355416345,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683115953
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> But Lean is designed to have all sorts of DSL's. I don't see why this is so different...</p>",
        "id": 355416413,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1683115970
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355416413\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> But Lean is designed to have all sorts of DSL's. I don't see why this is so different...</p>\n</blockquote>\n<p>As I understand it, Kyle proposes to change the parser and not write a DSL on top of the existing language</p>",
        "id": 355416970,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683116112
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355413612\">said</a>:</p>\n<blockquote>\n<p>So if I write a comment outside the proof block that contains the word proof, I am doomed.</p>\n</blockquote>\n<p>No, this is impossible with the design I've been describing.</p>\n<blockquote>\n<p>switching between two different parsers based on segmentation is a highly error prone way to do things</p>\n</blockquote>\n<p>That may be your opinion, but I'm not sure what to say, this is roughly how Python works. <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 355417030,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683116129
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355417030\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>switching between two different parsers based on segmentation is a highly error prone way to do things</p>\n</blockquote>\n<p>That may be your opinion, but I'm not sure what to say, this is roughly how Python works. <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>\n</blockquote>\n<p>I don't get that from here : <a href=\"https://devguide.python.org/internals/parser/\">https://devguide.python.org/internals/parser/</a><br>\nPython's syntax is defined by its grammar and the parser generator generates the parser. So if you propose a syntax change, it would have to be in the grammar, not in the parser internals.</p>",
        "id": 355418879,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683116493
    },
    {
        "content": "<p>this is not a change to \"parser internals\"</p>",
        "id": 355421641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683117089
    },
    {
        "content": "<p>this is just a fancy plugin parser like Johan says</p>",
        "id": 355421719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683117115
    },
    {
        "content": "<p>okay... then does it in anyway change the validity of existing proofs in the current syntax? Will the current syntax remain usable? If it is a parser plug in, I can imagine this plugin being triggered only if the relevant identifiers are used, while everything else that worked before works as it is.</p>",
        "id": 355425817,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683117906
    },
    {
        "content": "<p>Some tweaks still necessary, but here's a prototype:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Lean.Parser.Term</span>\n<span class=\"kn\">open</span> <span class=\"n\">PrettyPrinter</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">proofQedFn</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ParserFn</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ParserFn</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">c</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">let</span> <span class=\"n\">start</span> <span class=\"o\">:=</span> <span class=\"n\">s.pos</span>\n  <span class=\"k\">let</span> <span class=\"n\">proofCol</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">c.fileMap.toPosition</span> <span class=\"n\">start</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">column</span>\n  <span class=\"k\">let</span> <span class=\"n\">iniSz</span> <span class=\"o\">:=</span> <span class=\"n\">s.stackSize</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">symbolFn</span> <span class=\"s2\">\"proof\"</span> <span class=\"n\">c</span> <span class=\"n\">s</span>\n  <span class=\"k\">let</span> <span class=\"n\">prev</span> <span class=\"o\">:=</span> <span class=\"n\">s.stxStack.back</span>\n  <span class=\"k\">if</span> <span class=\"bp\">!</span><span class=\"n\">checkTailLinebreak</span> <span class=\"n\">prev</span> <span class=\"k\">then</span> <span class=\"n\">s.mkErrorAt</span> <span class=\"s2\">\"newline\"</span> <span class=\"n\">start</span> <span class=\"k\">else</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">line</span><span class=\"o\">,</span> <span class=\"n\">bodyCol</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">c.fileMap.toPosition</span> <span class=\"n\">s.pos</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">bodyCol</span> <span class=\"bp\">&gt;</span> <span class=\"n\">proofCol</span> <span class=\"k\">then</span>\n    <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">readLines</span> <span class=\"n\">s</span> <span class=\"n\">line</span> <span class=\"o\">:=</span>\n      <span class=\"k\">let</span> <span class=\"n\">iniSz</span>  <span class=\"o\">:=</span> <span class=\"n\">s.stackSize</span>\n      <span class=\"k\">let</span> <span class=\"n\">iniPos</span> <span class=\"o\">:=</span> <span class=\"n\">s.pos</span>\n      <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">readLine</span> <span class=\"n\">s</span> <span class=\"n\">line</span> <span class=\"o\">:=</span>\n        <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">tokenFn</span> <span class=\"o\">[]</span> <span class=\"n\">c</span> <span class=\"n\">s</span>\n        <span class=\"k\">if</span> <span class=\"n\">s.hasError</span> <span class=\"k\">then</span> <span class=\"n\">s</span> <span class=\"k\">else</span>\n        <span class=\"k\">let</span> <span class=\"n\">pos</span> <span class=\"o\">:=</span> <span class=\"n\">c.fileMap.toPosition</span> <span class=\"n\">s.pos</span>\n        <span class=\"k\">if</span> <span class=\"n\">pos.line</span> <span class=\"bp\">≠</span> <span class=\"n\">line</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">pos.column</span> <span class=\"bp\">≤</span> <span class=\"n\">bodyCol</span> <span class=\"k\">then</span> <span class=\"n\">s</span> <span class=\"k\">else</span>\n        <span class=\"n\">readLine</span> <span class=\"n\">s</span> <span class=\"n\">pos.line</span>\n      <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">readLine</span> <span class=\"n\">s</span> <span class=\"n\">line</span>\n      <span class=\"k\">if</span> <span class=\"n\">s.hasError</span> <span class=\"k\">then</span> <span class=\"n\">s</span> <span class=\"k\">else</span>\n      <span class=\"k\">let</span> <span class=\"n\">endPos</span> <span class=\"o\">:=</span> <span class=\"n\">s.pos</span>\n      <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">s.restore</span> <span class=\"n\">iniSz</span> <span class=\"n\">iniPos</span>\n      <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">adaptUncacheableContextFn</span>\n        <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">c</span> <span class=\"k\">with</span> <span class=\"n\">input</span> <span class=\"o\">:=</span> <span class=\"n\">c.input.extract</span> <span class=\"n\">iniPos</span> <span class=\"n\">endPos</span> <span class=\"o\">})</span> <span class=\"n\">p</span> <span class=\"n\">c</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">pos</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"o\">}</span>\n      <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">pos</span> <span class=\"o\">:=</span> <span class=\"n\">s.pos</span> <span class=\"bp\">+</span> <span class=\"n\">iniPos</span> <span class=\"o\">}</span>\n      <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">s.errorMsg</span> <span class=\"k\">then</span>\n        <span class=\"k\">if</span> <span class=\"n\">e.unexpected</span> <span class=\"bp\">==</span> <span class=\"s2\">\"unexpected end of input\"</span> <span class=\"k\">then</span>\n          <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">errorMsg</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"o\">{</span> <span class=\"n\">e</span> <span class=\"k\">with</span> <span class=\"n\">unexpected</span> <span class=\"o\">:=</span> <span class=\"s2\">\"unexpected newline\"</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n        <span class=\"k\">else</span>\n          <span class=\"n\">s</span>\n      <span class=\"k\">else</span>\n        <span class=\"k\">if</span> <span class=\"n\">s.pos</span> <span class=\"bp\">≠</span> <span class=\"n\">endPos</span> <span class=\"k\">then</span> <span class=\"n\">s.mkErrorAt</span> <span class=\"s2\">\"newline\"</span> <span class=\"n\">s.pos</span> <span class=\"k\">else</span>\n        <span class=\"k\">let</span> <span class=\"n\">pos</span> <span class=\"o\">:=</span> <span class=\"n\">c.fileMap.toPosition</span> <span class=\"n\">s.pos</span>\n        <span class=\"k\">if</span> <span class=\"n\">pos.column</span> <span class=\"bp\">&lt;</span> <span class=\"n\">bodyCol</span> <span class=\"k\">then</span> <span class=\"n\">s</span> <span class=\"k\">else</span>\n        <span class=\"n\">readLines</span> <span class=\"n\">s</span> <span class=\"n\">pos.line</span>\n    <span class=\"n\">readLines</span> <span class=\"n\">s</span> <span class=\"n\">line</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">s</span>\n  <span class=\"k\">if</span> <span class=\"n\">s.hasError</span> <span class=\"k\">then</span> <span class=\"n\">s</span> <span class=\"k\">else</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">s.mkNode</span> <span class=\"n\">nullKind</span> <span class=\"o\">(</span><span class=\"n\">iniSz</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">pos</span> <span class=\"o\">:=</span> <span class=\"n\">c.fileMap.toPosition</span> <span class=\"n\">s.pos</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">symbolFn</span> <span class=\"s2\">\"qed\"</span> <span class=\"n\">c</span> <span class=\"n\">s</span>\n  <span class=\"k\">if</span> <span class=\"n\">s.hasError</span> <span class=\"k\">then</span> <span class=\"n\">s</span> <span class=\"k\">else</span>\n  <span class=\"k\">if</span> <span class=\"n\">pos.column</span> <span class=\"bp\">≠</span> <span class=\"n\">proofCol</span> <span class=\"k\">then</span> <span class=\"n\">s.mkErrorAt</span> <span class=\"s2\">\"the 'qed' should line up with 'proof'\"</span> <span class=\"n\">s.pos</span> <span class=\"k\">else</span>\n  <span class=\"n\">s.mkNode</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Term.proofQed</span> <span class=\"n\">iniSz</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">proofQedG</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Parser</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Parser</span> <span class=\"n\">where</span>\n  <span class=\"n\">info</span> <span class=\"o\">:=</span> <span class=\"n\">nodeInfo</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Term.proofQed</span> <span class=\"bp\">&lt;|</span>\n    <span class=\"n\">andthenInfo</span> <span class=\"o\">(</span><span class=\"n\">symbol</span> <span class=\"s2\">\"proof\"</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">info</span> <span class=\"o\">(</span><span class=\"n\">andthenInfo</span> <span class=\"n\">p.info</span> <span class=\"o\">(</span><span class=\"n\">symbol</span> <span class=\"s2\">\"qed\"</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">info</span><span class=\"o\">)</span>\n  <span class=\"n\">fn</span> <span class=\"o\">:=</span> <span class=\"n\">proofQedFn</span> <span class=\"n\">p.fn</span>\n\n<span class=\"kd\">@[combinator_formatter proofQedG]</span> <span class=\"kd\">def</span> <span class=\"n\">proofQedG.formatter</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Formatter</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Formatter</span> <span class=\"o\">:=</span> <span class=\"n\">p</span>\n<span class=\"kd\">@[combinator_parenthesizer proofQedG]</span> <span class=\"kd\">def</span> <span class=\"n\">proofQedG.parenthesizer</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Parenthesizer</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Parenthesizer</span> <span class=\"o\">:=</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">@[term_parser]</span> <span class=\"kd\">def</span> <span class=\"n\">proofQed</span> <span class=\"o\">:</span> <span class=\"n\">Parser</span> <span class=\"o\">:=</span> <span class=\"n\">proofQedG</span> <span class=\"n\">tacticParser</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Parser.Term</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span> <span class=\"n\">TSyntax.Compat</span>\n<span class=\"kd\">@[term_elab Parser.Term.proofQed]</span> <span class=\"kd\">def</span> <span class=\"n\">elabProofQed</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">tk</span> <span class=\"o\">:=</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">qed'</span> <span class=\"o\">:=</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">tacs</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Syntax</span> <span class=\"o\">:=</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">getArgs</span>\n  <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"bp\">%$</span><span class=\"n\">tk</span> <span class=\"o\">{</span><span class=\"bp\">%$</span><span class=\"n\">tk</span> <span class=\"bp\">$</span><span class=\"n\">tacs</span><span class=\"bp\">*</span> <span class=\"o\">}</span><span class=\"bp\">%$</span><span class=\"n\">qed'</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span>\n<span class=\"n\">proof</span>\n  <span class=\"n\">skip</span>\n  <span class=\"n\">trivial</span>\n<span class=\"n\">qed</span>\n</code></pre></div>",
        "id": 355440550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683120908
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355425817\">said</a>:</p>\n<blockquote>\n<p>okay... then does it in anyway change the validity of existing proofs in the current syntax? Will the current syntax remain usable? If it is a parser plug in, I can imagine this plugin being triggered only if the relevant identifiers are used, while everything else that worked before works as it is.</p>\n</blockquote>\n<p>It's just a file that you use to get the syntax, like any other. The only effect of this parser on unrelated code is that <code>proof</code> and <code>qed</code> are now keywords</p>",
        "id": 355445979,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683121194
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355440550\">said</a>:</p>\n<blockquote>\n<p>Some tweaks still necessary, but here's a prototype:<br>\n</p>\n</blockquote>\n<p>Should we use this thread to debug this code? I have a simple example where something strange happens</p>",
        "id": 355550578,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683131384
    },
    {
        "content": "<p>For now I will post the example here. It can be moved later to another thread if required. This is the corrected version of Patrick's original example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">T1</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">calc</span>\n    <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span><span class=\"bp\">;</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span><span class=\"bp\">;</span>\n  <span class=\"n\">done</span><span class=\"bp\">;</span>\n<span class=\"c1\">-- No errors above. Also works without any semicolons</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">T2</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"n\">proof</span>\n  <span class=\"k\">calc</span>\n    <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- error : expected '{' or indented tactic sequence</span>\n<span class=\"n\">qed</span>\n</code></pre></div>",
        "id": 355551683,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683131629
    },
    {
        "content": "<p>A small variation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"n\">proof</span>\n  <span class=\"k\">calc</span>\n    <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n    <span class=\"n\">proof</span>\n      <span class=\"n\">rfl</span> <span class=\"c1\">-- error : expected 'qed'</span>\n    <span class=\"n\">qed</span>\n<span class=\"n\">qed</span>\n</code></pre></div>",
        "id": 355559227,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1683133605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> has marked this topic as resolved.</p>",
        "id": 355630539,
        "sender_full_name": "Notification Bot",
        "timestamp": 1683160396
    },
    {
        "content": "<p>I have proposed a UI fix for the specific \"incompleteness of current declaration reported at next declaration\" issue at <a href=\"https://github.com/leanprover/lean4/pull/2393\">lean4#2393</a></p>",
        "id": 382962535,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1691502260
    },
    {
        "content": "<p>Though now I see that this thread has been marked as resolved so I guess there was no need!</p>",
        "id": 382962685,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1691502286
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20End.20of.20proofs/near/382962685\">said</a>:</p>\n<blockquote>\n<p>Though now I see that this thread has been marked as resolved so I guess there was no need!</p>\n</blockquote>\n<p>I don't think it was quite resolved.</p>",
        "id": 382964792,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1691502678
    },
    {
        "content": "<blockquote>\n<p>it will include all preceding whitespace in the error message range as the expected token could be inserted at any of these places to fix the error.</p>\n</blockquote>\n<p>What happens if there is no whitespace, for instance in the example for <code>f3</code>, <code>def f3 :=def f4</code>?</p>",
        "id": 382965455,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1691502789
    },
    {
        "content": "<p>What is your concern about this case? I don't see it being problematic even now</p>",
        "id": 382966463,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1691502962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20End.20of.20proofs/near/382966463\">said</a>:</p>\n<blockquote>\n<p>What is your concern about this case? I don't see it being problematic even now</p>\n</blockquote>\n<p>Not concern. Trying to understand how the error highlighting will work</p>",
        "id": 382966679,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1691502994
    },
    {
        "content": "<p>specifically where the red squiggly line will appear in the event of no whitespace.</p>",
        "id": 382967138,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1691503070
    },
    {
        "content": "<p>If there is no whitespace then logically there is no change</p>",
        "id": 382967718,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1691503175
    },
    {
        "content": "<p>okay. thanks :)</p>",
        "id": 382968741,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1691503327
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20End.20of.20proofs/near/382962535\">said</a>:</p>\n<blockquote>\n<p>I have proposed a UI fix for the specific \"incompleteness of current declaration reported at next declaration\" issue at <a href=\"https://github.com/leanprover/lean4/pull/2393\">lean4#2393</a></p>\n</blockquote>\n<p>If you care about this issue, it would be great if you could give the finished PR a try: <a href=\"https://github.com/leanprover/lean4/pull/2393#issuecomment-1706058179\">https://github.com/leanprover/lean4/pull/2393#issuecomment-1706058179</a><br>\n<code>leanprover/lean4-pr-releases:pr-release-2393</code></p>",
        "id": 389373782,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1693991982
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> has marked this topic as unresolved.</p>",
        "id": 389373813,
        "sender_full_name": "Notification Bot",
        "timestamp": 1693991994
    },
    {
        "content": "<p>When I tried <code>leanprover/lean4-pr-releases:pr-release-2393</code>, the first test I did was</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>which seems to work as expected: it puts red squiggles on all blank lines between the theorems. But if I move to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">show</span> <span class=\"n\">P</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>then only th <code>by</code> gets squiggled. Is that a bug <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span>?</p>",
        "id": 389905175,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694187379
    },
    {
        "content": "<p><del>Yes</del> That is not covered by the PR, because this is a syntactically valid tactic proof. \"Where exactly should 'unsolved goals' be displayed\" is strictly speaking a separate issue.</p>",
        "id": 389906408,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1694187805
    },
    {
        "content": "<p>So let's solve the parser one first and continue from there</p>",
        "id": 389906570,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1694187855
    },
    {
        "content": "<p>I'm sorry, I don't understand this answer. I asked \"Is that a bug?\" and you answer Yes but then the following explanation seems to say this is intended behavior.</p>",
        "id": 389906823,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694187955
    },
    {
        "content": "<p>I need to go teaching (teaching Lean 4 of course!).</p>",
        "id": 389907092,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694188046
    },
    {
        "content": "<p>Then I wouldn't call it an issue! It was intentional at one point but I can see that it's not optimal, so let's continue that discussion in a separate thread/GH issue</p>",
        "id": 389907418,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1694188163
    },
    {
        "content": "<p>I did misread your question though, oops!</p>",
        "id": 389907636,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1694188237
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 389913031,
        "sender_full_name": "Sven Nilsen",
        "timestamp": 1694190314
    },
    {
        "content": "<p>I feel like I no longer understand what is the topic of this discussion <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 389957383,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694211531
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Sorry for the confusion. I see now that various related issues have been discussed in this thread that will need to be addressed in the implementation in different ways. My PR aims to address the specific issue of the error message of a <em>syntactically incomplete</em> proof (or other declaration) only being shown at the subsequent declaration, i.e. the main issue of <a href=\"https://github.com/leanprover/lean4/pull/1971\">lean4#1971</a></p>",
        "id": 390343357,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1694448031
    },
    {
        "content": "<p>Thanks Sebastian. It is indeed already a nice improvement.</p>",
        "id": 390361179,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694454712
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Your specific example of </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">assumption</span> <span class=\"n\">P</span>\n</code></pre></div>\n<p>could be resolved by simply checking for a linebreak after or at the end of a <code>tacticSeq1Indented</code>. To demonstrate:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Parser.Extra</span>\n\n<span class=\"kd\">@[run_parser_attribute_hooks]</span> <span class=\"kd\">def</span> <span class=\"n\">byEnd</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.Parser.checkLinebreakBefore</span>\n  <span class=\"s2\">\"line break; `by` block is finished\"</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"by'\"</span> <span class=\"n\">ts</span><span class=\"o\">:</span><span class=\"n\">sepBy1IndentSemicolon</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"o\">)</span> <span class=\"n\">byEnd</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"bp\">$</span><span class=\"o\">(⟨</span><span class=\"n\">ts.raw.getArgs</span><span class=\"o\">⟩)</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span><span class=\"bp\">'</span>\n  <span class=\"n\">assumption</span> <span class=\"n\">P</span> <span class=\"c1\">-- expected line break; `by` block is finished</span>\n</code></pre></div>",
        "id": 390364843,
        "sender_full_name": "Mac Malone",
        "timestamp": 1694456176
    },
    {
        "content": "<p>Here is a complete adaption of the <code>by</code> syntax:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Parser.Tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Parser</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">tacticSeqEnd</span> <span class=\"o\">:=</span> <span class=\"n\">checkLinebreakBefore</span>\n  <span class=\"s2\">\"line break; tactic sequence is over; did you mean to separate tactics with a `;`?\"</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Tactic</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">tacticSeqIndentGt</span> <span class=\"o\">:=</span> <span class=\"n\">withAntiquot</span> <span class=\"o\">(</span><span class=\"n\">mkAntiquot</span> <span class=\"s2\">\"tacticSeq\"</span> <span class=\"bp\">``</span><span class=\"n\">tacticSeq</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">node</span> <span class=\"bp\">``</span><span class=\"n\">tacticSeq</span> <span class=\"bp\">&lt;|</span>\n  <span class=\"n\">tacticSeqBracketed</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"o\">(</span><span class=\"n\">checkColGt</span> <span class=\"s2\">\"indented tactic sequence\"</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">tacticSeq1Indented</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">tacticSeqEnd</span><span class=\"o\">)</span>\n\n<span class=\"n\">macro</span><span class=\"o\">:</span><span class=\"n\">lead</span> <span class=\"n\">ppAllowUngrouped</span> <span class=\"s2\">\"by' \"</span> <span class=\"n\">ts</span><span class=\"o\">:</span><span class=\"n\">tacticSeqIndentGt</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"bp\">$</span><span class=\"o\">(⟨</span><span class=\"n\">ts.raw.getArgs</span><span class=\"o\">⟩)</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span><span class=\"bp\">'</span>\n  <span class=\"n\">assumption</span> <span class=\"n\">P</span>\n          <span class=\"c1\">-- ^ expected line break; tactic sequence is over; did you mean to separate tactics with a `;`?</span>\n</code></pre></div>",
        "id": 390365751,
        "sender_full_name": "Mac Malone",
        "timestamp": 1694456563
    },
    {
        "content": "<p>Indeed this looks nice in this example. It remains to test using it on many examples.</p>",
        "id": 390365954,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694456662
    },
    {
        "content": "<p>For casual readers: this is all about a different kind of failure, specifically the first example in <a href=\"https://github.com/leanprover/lean4/issues/1971#issuecomment-1532094266\">https://github.com/leanprover/lean4/issues/1971#issuecomment-1532094266</a></p>",
        "id": 390365990,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694456688
    },
    {
        "content": "<p>Unfortunately I don't think this works in practice as <code>(by assumption)</code> is a perfectly fine subterm</p>",
        "id": 390366039,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1694456712
    },
    {
        "content": "<p>Indeed.</p>",
        "id": 390366096,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694456740
    },
    {
        "content": "<p>Oh, good point. This is why Patrick is correct that many examples would be needed to test this.</p>",
        "id": 390366191,
        "sender_full_name": "Mac Malone",
        "timestamp": 1694456775
    },
    {
        "content": "<p>However, I do think some like this is possible to give a cleaner error.</p>",
        "id": 390366449,
        "sender_full_name": "Mac Malone",
        "timestamp": 1694456884
    },
    {
        "content": "<p>A quick fix for the <code>)</code> case would be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Parser.Tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Parser</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">tacticSeqEnd</span> <span class=\"o\">:=</span> <span class=\"n\">lookahead</span> <span class=\"s2\">\")\"</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">checkLinebreakBefore</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Tactic</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">tacticSeqIndentGt</span> <span class=\"o\">:=</span> <span class=\"n\">withAntiquot</span> <span class=\"o\">(</span><span class=\"n\">mkAntiquot</span> <span class=\"s2\">\"tacticSeq\"</span> <span class=\"bp\">``</span><span class=\"n\">tacticSeq</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">node</span> <span class=\"bp\">``</span><span class=\"n\">tacticSeq</span> <span class=\"bp\">&lt;|</span>\n  <span class=\"n\">tacticSeqBracketed</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"o\">(</span><span class=\"n\">checkColGt</span> <span class=\"s2\">\"indented tactic sequence\"</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">tacticSeq1Indented</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">tacticSeqEnd</span><span class=\"o\">)</span>\n\n<span class=\"n\">macro</span><span class=\"o\">:</span><span class=\"n\">lead</span> <span class=\"n\">ppAllowUngrouped</span> <span class=\"s2\">\"by' \"</span> <span class=\"n\">ts</span><span class=\"o\">:</span><span class=\"n\">tacticSeqIndentGt</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"bp\">$</span><span class=\"o\">(⟨</span><span class=\"n\">ts.raw.getArgs</span><span class=\"o\">⟩)</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"bp\">'</span> <span class=\"n\">assumption</span><span class=\"o\">)</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span><span class=\"bp\">'</span>\n  <span class=\"n\">assumption</span> <span class=\"n\">P</span>\n          <span class=\"c1\">-- ^ expected ')' or line break</span>\n</code></pre></div>",
        "id": 390367139,
        "sender_full_name": "Mac Malone",
        "timestamp": 1694457190
    },
    {
        "content": "<p>I do not believe there is a builtin parser combinator to overwrite the <code>tacticSeqEnd</code> error with something smarter, but it could be easily written.</p>",
        "id": 390367227,
        "sender_full_name": "Mac Malone",
        "timestamp": 1694457229
    },
    {
        "content": "<p>Like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Parser.Tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Parser</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">withErrorFn</span> <span class=\"o\">(</span><span class=\"n\">errorMsg</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ParserFn</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ParserFn</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">c</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">if</span> <span class=\"n\">p</span> <span class=\"n\">c</span> <span class=\"n\">s</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">hasError</span> <span class=\"k\">then</span> <span class=\"n\">s.mkUnexpectedError</span> <span class=\"n\">errorMsg</span> <span class=\"k\">else</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">withError</span> <span class=\"o\">(</span><span class=\"n\">errorMsg</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Parser</span> <span class=\"bp\">→</span> <span class=\"n\">Parser</span> <span class=\"o\">:=</span>\n  <span class=\"n\">withFn</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">withErrorFn</span> <span class=\"n\">errorMsg</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">finisher</span> <span class=\"o\">:=</span>\n  <span class=\"s2\">\"⟩\"</span> <span class=\"bp\">&lt;|&gt;</span>  <span class=\"s2\">\")\"</span>  <span class=\"bp\">&lt;|&gt;</span> <span class=\"s2\">\"}\"</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"s2\">\"]\"</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"s2\">\",\"</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">checkLinebreakBefore</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">tacticSeqEnd</span> <span class=\"o\">:=</span> <span class=\"n\">lookahead</span> <span class=\"n\">finisher</span> <span class=\"bp\">|&gt;</span>\n  <span class=\"n\">withError</span> <span class=\"s2\">\"tactic sequence is over; did you mean to separate tactics with a `;`?\"</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Tactic</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">tacticSeqIndentGt</span> <span class=\"o\">:=</span> <span class=\"n\">withAntiquot</span> <span class=\"o\">(</span><span class=\"n\">mkAntiquot</span> <span class=\"s2\">\"tacticSeq\"</span> <span class=\"bp\">``</span><span class=\"n\">tacticSeq</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">node</span> <span class=\"bp\">``</span><span class=\"n\">tacticSeq</span> <span class=\"bp\">&lt;|</span>\n  <span class=\"n\">tacticSeqBracketed</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"o\">(</span><span class=\"n\">checkColGt</span> <span class=\"s2\">\"indented tactic sequence\"</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">tacticSeq1Indented</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">tacticSeqEnd</span><span class=\"o\">)</span>\n\n<span class=\"n\">macro</span><span class=\"o\">:</span><span class=\"n\">lead</span> <span class=\"n\">ppAllowUngrouped</span> <span class=\"s2\">\"by' \"</span> <span class=\"n\">ts</span><span class=\"o\">:</span><span class=\"n\">tacticSeqIndentGt</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"bp\">$</span><span class=\"o\">(⟨</span><span class=\"n\">ts.raw.getArgs</span><span class=\"o\">⟩)</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"bp\">'</span> <span class=\"n\">assumption</span><span class=\"o\">)</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">PLift</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">up</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span><span class=\"bp\">'</span> <span class=\"n\">assumption</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">up</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span><span class=\"bp\">'</span> <span class=\"n\">assumption</span><span class=\"o\">]</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">PProd</span> <span class=\"n\">P</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"kd\">by</span><span class=\"bp\">'</span> <span class=\"n\">assumption</span><span class=\"o\">,</span> <span class=\"kd\">by</span><span class=\"bp\">'</span> <span class=\"n\">assumption</span><span class=\"o\">⟩</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">PProd</span> <span class=\"n\">P</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">fst</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span><span class=\"bp\">'</span> <span class=\"n\">assumption</span><span class=\"o\">,</span> <span class=\"n\">snd</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span><span class=\"bp\">'</span> <span class=\"n\">assumption</span><span class=\"o\">}</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>  <span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"bp\">'</span> <span class=\"n\">assumption</span> <span class=\"n\">P</span><span class=\"o\">)</span>\n                                                <span class=\"c1\">-- ^ tactic sequence is over...</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span><span class=\"bp\">'</span>\n  <span class=\"n\">assumption</span> <span class=\"n\">P</span>\n          <span class=\"c1\">-- ^ tactic sequence is over; did you mean to separate tactics with a `;`?</span>\n</code></pre></div>\n<p>The parentheses are probably enough since any other finisher can be avoided by wrapping the by in parentheses, but this is more convenient.</p>",
        "id": 390368409,
        "sender_full_name": "Mac Malone",
        "timestamp": 1694457684
    },
    {
        "content": "<p>Another more complex but general solution would be to have some kind of \"conditional error\" that sets the error message that will be thrown if the next parser encounters an error.</p>",
        "id": 390371950,
        "sender_full_name": "Mac Malone",
        "timestamp": 1694459138
    },
    {
        "content": "<p>It could also be solved by changing <code>tacticSeq1Indent</code> to behave differently based on whether the <code>by</code> state covers more than one line.</p>",
        "id": 390372948,
        "sender_full_name": "Mac Malone",
        "timestamp": 1694459561
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355252973\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">assumption</span> <span class=\"n\">P</span>\n</code></pre></div>\n<p>Say I mixed up <code>exact</code> and <code>assumption</code>. Guess the error message? Of course it is <code>expected command</code>, and I understand why. The proof is over after <code>assumption</code> and Lean tries to process whatever comes after this proof. </p>\n</blockquote>\n<p>Note that now that the PR is merged, the error message changed to \"unexpected identifier; expected command\". I would argue this is at least a slight improvement: it first complains about something unexpected, i.e. hints that maybe you have simply given too much input.</p>",
        "id": 390484962,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1694512624
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/270676-lean4/topic/End.20of.20proofs/near/355252973\">said</a>:</p>\n<blockquote>\n<p>Are we really really sure we don't want to bring back the good old battle-tested <code>begin</code>/<code>end</code>? I just spent at least 10 minutes fighting a more sophisticated version of </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">calc</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>What do you expect as an error message here? The answer is an error on line 5 saying <code>expected ':='</code>. In my real example I used a tactic that was not <code>rfl</code> and giving it a list of arguments was plausible.</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover/lean4/pull/2532\">lean4#2532</a> fixes the error position. The message now is \"no worse\" than with <code>assumption P</code> above</p>",
        "id": 390511912,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1694522619
    }
]