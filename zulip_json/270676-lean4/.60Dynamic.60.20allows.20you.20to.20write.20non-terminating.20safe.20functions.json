[
    {
        "content": "<p>Is this a problem? Are safe functions supposed to be guaranteed to terminate?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Dynamic</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Dynamic</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fallback</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TypeName</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Dynamic</span><span class=\"bp\">.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">fallback</span>\n\n<span class=\"c1\">-- `Dynamic` allows us to circumvent positivity requirements in the definitions of inductive types.</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Cantor</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Dynamic</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">TypeName</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">diag</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Dynamic</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Dynamic</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"n\">Cantor</span><span class=\"w\"> </span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"n\">any</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">diagCantor</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cantor</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">diag</span><span class=\"bp\">⟩</span>\n\n<span class=\"c1\">-- diagCantor witnesses that `Dynamic.Get? ∘ Dynamic.mk` does not restrict to the identity on the type `Cantor`.</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">DynamicWoe</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Dynamic</span><span class=\"bp\">.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"n\">Cantor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Dynamic</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">diagCantor</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">diagCantor</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Dynamic</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">diagCantor</span><span class=\"bp\">.</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">diag</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cantor</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">diag</span><span class=\"w\"> </span><span class=\"n\">Dynamic</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Dynamic</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">diagCantor</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">eq_not_self</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">diagBool</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">diag</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Dynamic</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">diagCantor</span>\n\n<span class=\"c1\">-- Evaluating `diagBool` results in a stack overflow.</span>\n<span class=\"c1\">-- #eval diagBool</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Server process for file:///MathlibDemo/MathlibDemo.lean crashed, likely due to a stack overflow or a bug.</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 571072748,
        "sender_full_name": "James E Hanson",
        "timestamp": 1769790411
    },
    {
        "content": "<p>In general it's pretty easy to build safe functions that don't terminate</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">while</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>This case is really not much different from <code>while true</code>. Both are based on an implemented by to an extern <code>opaque</code> under the hood.</p>",
        "id": 571074118,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1769790747
    },
    {
        "content": "<p><del>Where is the implementation of <code>while</code> documented? It's pretty hard to search for.</del> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/While.html\">I found it.</a></p>",
        "id": 571077356,
        "sender_full_name": "James E Hanson",
        "timestamp": 1769791640
    },
    {
        "content": "<p>Also, I guess on some level I find this surprising because I feel like it's claimed in some places that safe functions are supposed to terminate. <a href=\"https://github.com/leanprover/lean4/blob/3b0f2862196c6a8af9eb0025ee650252694013dd/src/Lean/Compiler/LCNF/Basic.lean#L608\">For instance, here in the comments in some of the compiler code:</a></p>\n<blockquote>\n<p>This information affects how static analyzers treat function applications of this kind. See <code>DefinitionSafety</code>. <code>partial</code> and <code>unsafe</code> functions may not be terminating, but Lean functions terminate, and some static analyzers exploit this fact.</p>\n</blockquote>",
        "id": 571079999,
        "sender_full_name": "James E Hanson",
        "timestamp": 1769792339
    },
    {
        "content": "<p>I understand that it's trivial to write a safe function that doesn't using <code>implemented_by</code>, but I guess I was assuming that there's an expectation that the safe standard library functions terminate.</p>",
        "id": 571080287,
        "sender_full_name": "James E Hanson",
        "timestamp": 1769792406
    },
    {
        "content": "<p>Is there documentation of what safety in Lean is supposed to guarantee?</p>",
        "id": 571080442,
        "sender_full_name": "James E Hanson",
        "timestamp": 1769792447
    },
    {
        "content": "<p>You don't need <code>implemented_by</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">loopy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">loopy</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">epicfail</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">loopy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 571137295,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1769813304
    },
    {
        "content": "<p><code>partial</code> desugars to an <code>implemented_by</code>.</p>",
        "id": 571139407,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1769814516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/270676-lean4/topic/.60Dynamic.60.20allows.20you.20to.20write.20non-terminating.20safe.20functions/near/571080442\">said</a>:</p>\n<blockquote>\n<p>Is there documentation of what safety in Lean is supposed to guarantee?</p>\n</blockquote>\n<p>there is no explicit formulation but at the very least it should be memory safe</p>",
        "id": 571139476,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1769814562
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/270676-lean4/topic/.60Dynamic.60.20allows.20you.20to.20write.20non-terminating.20safe.20functions/near/571139407\">said</a>:</p>\n<blockquote>\n<p><code>partial</code> desugars to an <code>implemented_by</code>.</p>\n</blockquote>\n<p>Doesn't almost everything though? For example, <code>Nat.add</code> is <code>extern</code> (and <code>implemented_by</code> is approximately a combo of <code>export</code> and <code>extern</code>).</p>",
        "id": 571140775,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1769815402
    },
    {
        "content": "<p>I really like <span class=\"user-mention\" data-user-id=\"1006649\">@cmlsharp</span>'s approach in <a href=\"https://github.com/leanprover-community/batteries/pull/1589\">batteries#1589</a> where they isolate the unsafe assumption and do everything else cleanly. That really helps investigating what <span class=\"user-mention\" data-user-id=\"904624\">@James E Hanson</span> is worried about.</p>",
        "id": 571141567,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1769815970
    },
    {
        "content": "<p>As a side note if this is indeed a useful pattern in general, I think it would be neat if this was facilitated by somehow by a version of csimp that takes these assumptions as arguments. Right now you have to do something akin to this little dance where you define e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f_impl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h_assumption</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">..</span>\n<span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f_unsafe</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f_impl</span><span class=\"w\"> </span><span class=\"n\">lcProof</span><span class=\"w\">  </span><span class=\"bp\">..</span>\n<span class=\"kd\">@[</span><span class=\"n\">implemented_by</span><span class=\"w\"> </span><span class=\"n\">f_unsafe</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">..</span>\n</code></pre></div>\n<p>(and then some theorem where you say that given h_assumption, f is equivalent to f_impl. f_impl needn’t always take the assumption as an argument but sometimes it needs to)</p>\n<p>But you could imagine syntax that let you write just f_impl and f and then let you write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">csimp_assuming</span><span class=\"o\">(</span><span class=\"n\">h_assumption</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h_assumption</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">..</span>\n</code></pre></div>\n<p>Perhaps I could try something like this as a PR to Batteries</p>",
        "id": 571142937,
        "sender_full_name": "cmlsharp",
        "timestamp": 1769816948
    },
    {
        "content": "<p>The additional assumptions required for these sort of csimp's are frequently unsound though so proving a theorem with them doesn't really mean much.</p>",
        "id": 571143815,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1769817562
    },
    {
        "content": "<p>I agree that they mean less (you could use a degenerate proof  that used False.elim somewhere), but I think they give you better assurances than implemented_by</p>",
        "id": 571143961,
        "sender_full_name": "cmlsharp",
        "timestamp": 1769817652
    },
    {
        "content": "<p>(And regardless even if the theorem isn’t useful, this pattern is still useful to factor out e.g. the assumptions necessary to make array indexing sound, see e.g. Array.foldl)</p>",
        "id": 571144025,
        "sender_full_name": "cmlsharp",
        "timestamp": 1769817701
    },
    {
        "content": "<p>Also I think a theorem that says “as long as the size of an array is less than USize.size, this equivalence holds” is still a meaningful theorem in isolation. There’s a level of unsafety when you then say “always substitute in this implementation” but that unsafety was already there with implemented_by</p>",
        "id": 571144330,
        "sender_full_name": "cmlsharp",
        "timestamp": 1769817849
    },
    {
        "content": "<blockquote>\n<p>(you could use a degenerate proof that used False.elim somewhere),</p>\n</blockquote>\n<p>It's not going to be you that does that but one of the heavy automation tools.</p>",
        "id": 571144353,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1769817863
    },
    {
        "content": "<p>That’s fair, you have to be more careful. But at least in the specific example cited, the assumption itself (the size of this array is less than USize.size) is not unsound. The proof itself is still meaningful.</p>",
        "id": 571144605,
        "sender_full_name": "cmlsharp",
        "timestamp": 1769818001
    },
    {
        "content": "<p>It would be unsound to assume “this is true of all arrays” but that isn’t what the theorem statement says.</p>",
        "id": 571144674,
        "sender_full_name": "cmlsharp",
        "timestamp": 1769818036
    }
]