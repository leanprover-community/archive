[
    {
        "content": "<p>I have an unusual inductive(-inductive) type for which I have implemented my own recursor. This eliminator is not a Lean recursor, it is \"just\" a <code>def</code>. As a result, I can't use it with the existing <code>match</code> pattern compiler that exists in Lean as of today, as far as I know.</p>\n<p>So as far as I can tell, I can either use the eliminator directly, or implement some (minimal) version of a match compiler myself. It does not need to be super capable, and it only needs to match on my one datatype that I have defined. It does not need to intermingle with other types (although that would be nice, if it's not too much extra work). So here I am, trying to understand how difficult it would be and whether I want to pursue that.</p>\n<p>The datatype is something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Con</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Con</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Con</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Con</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"bp\">.</span><span class=\"n\">Pi</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œì</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"bp\">...</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"bp\">.</span><span class=\"n\">rec</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">ConMotive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Con</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">TyMotive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Con</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">usual</span><span class=\"bp\">...</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>And then I want to be able to do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">isNil</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Con</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">myMatch</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div>",
        "id": 555334985,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1763034835
    },
    {
        "content": "<p>You could use <code>induction using</code> instead</p>",
        "id": 555338072,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1763035723
    },
    {
        "content": "<p>Probably you don't need the rec you just want the casesOn</p>",
        "id": 555341961,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763036914
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/270676-lean4/topic/Custom.20.60match.60/near/555338072\">said</a>:</p>\n<blockquote>\n<p>You could use <code>induction using</code> instead</p>\n</blockquote>\n<p>I think this is for defs.</p>",
        "id": 555356569,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1763040789
    },
    {
        "content": "<p>Afaik, <code>induction</code> doesn't allow for mutual inductive types. At least it didn't last time I tried. Since the type is an inductive-inductive type, the motives are also extra weird, so I am not sure whether relying on <code>induction</code> figuring it out is a good idea.</p>",
        "id": 555357012,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1763040904
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/270676-lean4/topic/Custom.20.60match.60/near/555341961\">said</a>:</p>\n<blockquote>\n<p>Probably you don't need the rec you just want the casesOn</p>\n</blockquote>\n<p>Not sure I understand. If I only have a casesOn for my data type, that is not powerful enough. Even if I want to get the length of a <code>Con</code> (which works roughly like <code>List</code>), I'll need the recursor, and not just casesOn?</p>",
        "id": 555357549,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1763041040
    },
    {
        "content": "<p>The manual way is to tag it with <code>@[elab_as_elim]</code> (hopefully that works) and then just use something like <code>refine Ty.rec ?_ ?_ ?_ Œì</code> (assuming <code>TyMotive</code> occurs in the conclusion)</p>",
        "id": 555357882,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1763041132
    },
    {
        "content": "<p>To make my own <code>match</code>, I would have to define some new syntax, and an elaborator which translates the match patterns (LHS) and match arms (RHS) into invocations of my custom eliminator. My question is, how do I do this, in a Lean-y way? How much effort would it be?</p>",
        "id": 555357934,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1763041153
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/channel/270676-lean4/topic/Custom.20.60match.60/near/555357882\">said</a>:</p>\n<blockquote>\n<p>The manual way is to tag it with <code>@[elab_as_elim]</code> (hopefully that works) and then just use something like <code>refine Ty.rec ?_ ?_ ?_ Œì</code> (assuming <code>TyMotive</code> occurs in the conclusion)</p>\n</blockquote>\n<p>I just tried this, and while I can tag my eliminator with <code>@[elab_as_elim]</code>, using it breaks with \"invalid patterns, <code>A</code> is an explicit pattern variable, but it only occurs in positions that are inaccessible to pattern matching\". This is probably because my constructors are <code>def</code>s as well, which internally are <code>Subtype.mk ...</code>.</p>",
        "id": 555359219,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1763041494
    },
    {
        "content": "<p>I am unfortunately fairly certain I will have to reinvent the wheel here.</p>",
        "id": 555359434,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1763041541
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"416280\">Max Nowak üêâ</span> <a href=\"#narrow/channel/270676-lean4/topic/Custom.20.60match.60/near/555357012\">said</a>:</p>\n<blockquote>\n<p>Afaik, <code>induction</code> doesn't allow for mutual inductive types. At least it didn't last time I tried. Since the type is an inductive-inductive type, the motives are also extra weird, so I am not sure whether relying on <code>induction</code> figuring it out is a good idea.</p>\n</blockquote>\n<p>There is some discussion (and an implementation) of a mutual induction tactic at <a class=\"message-link\" href=\"/#narrow/channel/239415-metaprogramming-.2F-tactics/topic/mutual.20induction.20tactic/near/504318250\">#metaprogramming / tactics &gt; mutual induction tactic @ üí¨</a> if you would like to experiment with it</p>",
        "id": 555361591,
        "sender_full_name": "Chris Henson",
        "timestamp": 1763042111
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/270676-lean4/topic/Custom.20.60match.60/near/555356569\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/270676-lean4/topic/Custom.20.60match.60/near/555338072\">said</a>:</p>\n<blockquote>\n<p>You could use <code>induction using</code> instead</p>\n</blockquote>\n<p>I think this is for defs.</p>\n</blockquote>\n<p>Tactics work for both defs and theorems</p>",
        "id": 555365063,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1763042947
    },
    {
        "content": "<p>yes but I recall advice that one should avoid doing this.</p>",
        "id": 555365400,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1763043023
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"416280\">Max Nowak üêâ</span> <a href=\"#narrow/channel/270676-lean4/topic/Custom.20.60match.60/near/555357549\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/270676-lean4/topic/Custom.20.60match.60/near/555341961\">said</a>:</p>\n<blockquote>\n<p>Probably you don't need the rec you just want the casesOn</p>\n</blockquote>\n<p>Not sure I understand. If I only have a casesOn for my data type, that is not powerful enough. Even if I want to get the length of a <code>Con</code> (which works roughly like <code>List</code>), I'll need the recursor, and not just casesOn?</p>\n</blockquote>\n<p>Well if it's recursive then it becomes complicated I thought you just wanted the matching</p>",
        "id": 555388662,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763048033
    },
    {
        "content": "<p>Yes I do want to be able to write recursive functions. I am aware this is not an easy task.</p>",
        "id": 555388889,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1763048094
    }
]