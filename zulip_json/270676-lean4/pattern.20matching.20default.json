[
    {
        "content": "<p>I am working on the <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html\">Induction and Recursion</a> exercises. I am stuck on concisely proving <code>simpConst_eq</code>. Specifically, I want the pattern match (where I have <code>sorry</code> right now) to be proved with a simple refl considering that the <code>plus</code> and <code>times</code> case has already been pattern matched. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">simpConst</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span>\n  <span class=\"bp\">|</span> <span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">n₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">n₂</span><span class=\"o\">)</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">const</span> <span class=\"o\">(</span><span class=\"n\">n₁</span> <span class=\"bp\">+</span> <span class=\"n\">n₂</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">times</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">n₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">n₂</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">const</span> <span class=\"o\">(</span><span class=\"n\">n₁</span> <span class=\"bp\">*</span> <span class=\"n\">n₂</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">e</span>                           <span class=\"bp\">=&gt;</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">simpConst_eq</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n        <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">,</span> <span class=\"n\">eval</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">simpConst</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">eval</span> <span class=\"n\">v</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">e</span>\n    <span class=\"c1\">-- apply simpConst_eq_exp</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">simpConst</span><span class=\"o\">,</span> <span class=\"n\">eval</span><span class=\"o\">]</span>\n    <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">plus</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">n₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">n₂</span><span class=\"o\">)</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"n\">times</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">n₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">n₂</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 362136776,
        "sender_full_name": "Lev Stambler",
        "timestamp": 1685442331
    },
    {
        "content": "<p>There is nothing in the type theory to directly express that <code>e</code> is of any shape but the first two cases, especially not one that would make the match reduce. So you have to exhaustively list all cases, though if you want tactics to do that for you, you could try something like <code>unfold simpConst; split</code> instead of the <code>match</code></p>",
        "id": 362145681,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1685444449
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/270676-lean4/topic/pattern.20matching.20default/near/362145681\">said</a>:</p>\n<blockquote>\n<p>There is nothing in the type theory to directly express that <code>e</code> is of any shape but the first two cases, especially not one that would make the match reduce. So you have to exhaustively list all cases, though if you want tactics to do that for you, you could try something like <code>unfold simpConst; split</code> instead of the <code>match</code></p>\n</blockquote>\n<p>Thank you! This was exactly what I was looking for.</p>",
        "id": 362266585,
        "sender_full_name": "Lev Stambler",
        "timestamp": 1685470770
    }
]