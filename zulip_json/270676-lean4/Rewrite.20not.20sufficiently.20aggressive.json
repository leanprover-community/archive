[
    {
        "content": "<p>There is a clause in the code for <code>rewrite</code> such that it will skip over possible sites if the head index doesn't match. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rewrite</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_add</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>does not work, while replacing <code>rewrite</code> by <code>apply</code> does.</p>\n<p>In this simple example, we can replace <code>rewrite</code> by <code>apply</code>. What if the rewrite occurs inside a larger expression? In which case the insufficiently aggressive rewrite could not make progress. Is there a general way to handle this type of issue?</p>",
        "id": 536354563,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756276237
    },
    {
        "content": "<p>Best approach: make sure you don't end up with <code>Nat.add</code> in your state from the start</p>\n<p>Second best: use the library theorem that probably exists that <code>Nat.add a b = a + b</code></p>\n<p>Worst: use the <code>erw</code> tactic instead</p>",
        "id": 536356843,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1756277458
    },
    {
        "content": "<p>Note that <code>rewrite</code> uses the <code>reducible</code> transparency setting, meaning that the rewrite wouldn't go through anyways. Similarly <code>with_reducible apply</code> also doesn't work here.</p>\n<p>The <code>erw</code> tactic bumps up the transparency to <code>default</code>. But its use is discouraged in mathlib.</p>",
        "id": 536368502,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1756282403
    },
    {
        "content": "<p><code>erw</code> also uses head index matching, so it doesn't work here either</p>",
        "id": 536368703,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756282496
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536368703\">said</a>:</p>\n<blockquote>\n<p><code>erw</code> also uses head index matching, so it doesn't work here either</p>\n</blockquote>\n<p>Is there a reason other than performance about why rewrite uses index matching?</p>",
        "id": 536441630,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756307170
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536356843\">said</a>:</p>\n<blockquote>\n<p>Best approach: make sure you don't end up with <code>Nat.add</code> in your state from the start</p>\n<p>Second best: use the library theorem that probably exists that <code>Nat.add a b = a + b</code></p>\n<p>Worst: use the <code>erw</code> tactic instead</p>\n</blockquote>\n<p>Not generating <code>.add</code> seems difficult. Even <code>conv</code> with <code>whnf</code> creates <code>.add</code>s from the normal <code>+</code> for natural numbers.</p>",
        "id": 536442824,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756307539
    },
    {
        "content": "<p>Why would you use <code>conv</code> with <code>whnf</code>?</p>",
        "id": 536447259,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1756308754
    },
    {
        "content": "<p>I only use <code>whnf</code> as an \"exploring\" tactic and it never makes it into my final proof</p>",
        "id": 536447450,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756308820
    },
    {
        "content": "<p>I have to <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>: why are you using <code>whnf</code>? As you see, it puts expressions into a form that basic tactic do not support.</p>\n<p>There are comments inside the Lean source code about normal forms it expects. One of them is using functions like <code>HAdd.hAdd</code> instead of the underlying instance definitions. That also includes <code>OfNat.ofNat</code>, which similarly is denormalized by <code>whnf</code>.</p>",
        "id": 536447462,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756308822
    },
    {
        "content": "<p>instead of <code>whnf</code> you can usually just <code>change</code> to the type you want</p>",
        "id": 536447633,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756308873
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> This is likely for something programmatic, so<code>change</code> is unlikely to be helpful)</p>",
        "id": 536447793,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756308916
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536447259\">said</a>:</p>\n<blockquote>\n<p>Why would you use <code>conv</code> with <code>whnf</code>?</p>\n</blockquote>\n<p>Sometimes a <code>rewrite</code> cannot proceed because it could not find the rewriting pattern in the target, and this could only be rectified with <code>whnf</code>. I've asked this question before. e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rewrite</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I just want to explain that entirely avoiding <code>Nat.add</code> is unlikely</p>",
        "id": 536447923,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756308955
    },
    {
        "content": "<p>example comment: <a href=\"https://github.com/leanprover/lean4/blob/655a39ceb8c7123dc14a064e0d4e4ae292a3b436/src/Lean/Meta/Tactic/Simp/Main.lean#L105\">https://github.com/leanprover/lean4/blob/655a39ceb8c7123dc14a064e0d4e4ae292a3b436/src/Lean/Meta/Tactic/Simp/Main.lean#L105</a></p>",
        "id": 536448077,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756308999
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536447793\">said</a>:</p>\n<blockquote>\n<p>(<span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> This is likely for something programmatic, so<code>change</code> is unlikely to be helpful)</p>\n</blockquote>\n<p>I'll use <code>change</code> as a last resort</p>",
        "id": 536448117,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756309010
    },
    {
        "content": "<p>You could call <code>whnf</code> on the lhs of the rewriting theorem too</p>",
        "id": 536448444,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756309125
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536447923\">said</a>:</p>\n<blockquote>\n<p>I've asked this question before.</p>\n</blockquote>\n<p>I <a href=\"#narrow/channel/270676-lean4/topic/Unfolding.20during.20unification/near/530200031\">asked</a> about a spec for what you're actually trying to do, and I didn't get any understanding of how you are in this situation that you need to rewrite using terms that are not in the right form to rewrite. Using <code>whnf</code>/<code>unfold_projs</code> seems like a hack papering over something missing to the story.</p>",
        "id": 536448788,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756309218
    },
    {
        "content": "<p>I agree with the others that <code>whnf</code> is not the way to go. In your last example, you should just perform rewrites with multiple lemmas (some of which are definitional reductions)</p>",
        "id": 536448878,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1756309243
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536448788\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536447923\">said</a>:</p>\n<blockquote>\n<p>I've asked this question before.</p>\n</blockquote>\n<p>I <a href=\"#narrow/channel/270676-lean4/topic/Unfolding.20during.20unification/near/530200031\">asked</a> about a spec for what you're actually trying to do, and I didn't get any understanding of how you are in this situation that you need to rewrite using terms that are not in the right form to rewrite. Using <code>whnf</code>/<code>unfold_projs</code> seems like a hack papering over something missing to the story.</p>\n</blockquote>\n<p>I'm developing a tactic or function that normalizes the current goal into a form, where no more subterms can be reduced, and where <code>rewrite</code>s are not blocked because of differing head elements. For example, in the <code>x.succ + n.succ = (x + n.succ).succ</code> example, the <code>(x + n.succ).succ</code> part should be normalized into <code>(x + n).succ.succ</code>. Currently I'm using <code>whnf</code> to achieve this, but <code>whnf</code> keeps generating <code>Nat.add</code> so I'm asking how to deal with this problem.</p>",
        "id": 536450565,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756309720
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536448878\">said</a>:</p>\n<blockquote>\n<p>I agree with the others that <code>whnf</code> is not the way to go. In your last example, you should just perform rewrites with multiple lemmas (some of which are definitional reductions)</p>\n</blockquote>\n<p>Which lemmas are those? <code>Nat.add.eq_def</code>?</p>",
        "id": 536450609,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756309732
    },
    {
        "content": "<p>In this case, you need the lemma <code>Nat.add_succ : n + m.succ = (n + m).succ</code></p>",
        "id": 536450955,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1756309842
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536450955\">said</a>:</p>\n<blockquote>\n<p>In this case, you need the lemma <code>Nat.add_succ : n + m.succ = (n + m).succ</code></p>\n</blockquote>\n<p>I have explained in the original question that the use case is general and such lemmas may not be available. The <code>x.succ + n.succ</code> example was extracted from the proof of <code>Nat.add_succ</code> and using <code>Nat.add_succ</code> to prove it would be circular reasoning.</p>",
        "id": 536451129,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756309898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536450565\">said</a>:</p>\n<blockquote>\n<p>I'm developing a tactic or function that normalizes the current goal into a form, where no more subterms can be reduced, and where <code>rewrite</code>s are not blocked because of differing head elements.</p>\n</blockquote>\n<p>What does \"reduced\" mean?</p>",
        "id": 536451511,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756310034
    },
    {
        "content": "<p><code>Nat.add_succ</code> will always exist when working with Lean. So maybe give an example that is \"general\"?</p>",
        "id": 536451629,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1756310075
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536451511\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536450565\">said</a>:</p>\n<blockquote>\n<p>I'm developing a tactic or function that normalizes the current goal into a form, where no more subterms can be reduced, and where <code>rewrite</code>s are not blocked because of differing head elements.</p>\n</blockquote>\n<p>What does \"reduced\" mean?</p>\n</blockquote>\n<p>Where no more computation can happen even when you unfold definitions. For example, <code>[].length</code> should be reduced to <code>0</code>.</p>",
        "id": 536451739,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756310112
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536451629\">said</a>:</p>\n<blockquote>\n<p><code>Nat.add_succ</code> will always exist when working with Lean. So maybe give an example that is \"general\"?</p>\n</blockquote>\n<p>Suppose I created a new <code>Nat</code> type that has the same <code>add_succ</code> lemma as <code>Nat</code>.</p>",
        "id": 536451856,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756310157
    },
    {
        "content": "<p>How do you determine what to reduce? Should it reduce <code>List.length l</code> to </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">brecOn</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">below</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">f</span>\n</code></pre></div>\n<p>?</p>",
        "id": 536452038,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756310219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536452038\">said</a>:</p>\n<blockquote>\n<p>How do you determine what to reduce? Should it reduce <code>List.length l</code> to </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">brecOn</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">below</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">f</span>\n</code></pre></div>\n<p>?</p>\n</blockquote>\n<p>Currently it just reduces everything possible. Eventually, I want the tactic to accept rewrite lemmas, and reduce the target/lctx to the point where these lemmas can execute, so the question about whether <code>List.length l</code> should be reduced is dependent on the forms of these lemmas.</p>\n<p>For example, in this case</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>the only way I know to make the rewrite <code>h</code> executable on the target is via <code>whnf</code></p>",
        "id": 536452897,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756310483
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536451129\">said</a>:</p>\n<blockquote>\n<p>I have explained in the original question that the use case is general and such lemmas may not be available.</p>\n</blockquote>\n<p>I read that, but I think you might be underestimating the amount of context that I'd need to understand that. I am sure there are specific constraints to your general problem, given that you do not like the general advice we're giving that you need to develop the theory around each type's definitions. It's solid advice, and it needs strong motivation for why that is unacceptable. Using whnf is known to be an antipattern for normal proofs.</p>\n<p>You've mentioned the idea \"what if we make our own Nat type\": if it's the same as Nat, why are you not using Nat, which has all the lemmas already available?</p>\n<p>Where is this example coming from in the first place?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>You may have answered this, but I'm not certain yet that taking a step back then forward again would put you into a better position.</p>",
        "id": 536454782,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756311131
    },
    {
        "content": "<p>You're free to reduce everything in sight of course, but then you need to be on your own and develop a fully-reduced set of lemmas and follow the design patterns of keeping normal forms in mind. The <code>rw</code> tactic is not going to help you avoid thinking about normal forms. The head-index key matching is both for performance and for normal form considerations.</p>",
        "id": 536455365,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756311330
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536454782\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536451129\">said</a>:</p>\n<blockquote>\n<p>I have explained in the original question that the use case is general and such lemmas may not be available.</p>\n</blockquote>\n<p>I read that, but I think you might be underestimating the amount of context that I'd need to understand that. I am sure there are specific constraints to your general problem, given that you do not like the general advice we're giving that you need to develop the theory around each type's definitions. It's solid advice, and it needs strong motivation for why that is unacceptable. Using whnf is known to be an antipattern for normal proofs.</p>\n<p>You've mentioned the idea \"what if we make our own Nat type\": if it's the same as Nat, why are you not using Nat, which has all the lemmas already available?</p>\n<p>Where is this example coming from in the first place?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>You may have answered this, but I'm not certain yet that taking a step back then forward again would put you into a better position.</p>\n</blockquote>\n<p>Suppose we create a new data type, equipped with its own set of arithmetic operations (i.e. implementing <code>Add</code> or <code>Mul</code>, etc.). Then we need to prove properties about these operations without built-in <code>add_comm</code> and other lemmas. I want to develop a tactic that can help with this use case.</p>\n<p>Another way of thinking about this is I want to make a tactic version of the proof of <code>Nat.add_comm</code> and other lemmas in Lean's <code>Init</code> library.</p>",
        "id": 536455481,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756311370
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536455481\">said</a>:</p>\n<blockquote>\n<p>I want to develop a tactic that can help with this use case. </p>\n</blockquote>\n<p>Ok, what I am hearing is that you want to take the equation lemmas for the operations and automatically rephrase them in terms of the HAdd/HMul, etc. classes.</p>\n<p>Then, maybe, there's an automated theorem prover angle after this, to prove properties like <code>add_comm</code>.</p>\n<p>The important thing is defining the right lemmas first. That <code>example</code> doesn't look like any of the lemmas you'd want to generate. You want <code>Nat.add_zero</code> and <code>Nat.add_succ</code>, which require unfolding definitions, and follow the structure of the equation lemmas. That's it, and everything else about addition follows from those.</p>",
        "id": 536456649,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756311738
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536456649\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536455481\">said</a>:</p>\n<blockquote>\n<p>I want to develop a tactic that can help with this use case. </p>\n</blockquote>\n<p>Ok, what I am hearing is that you want to take the equation lemmas for the operations and automatically rephrase them in terms of the HAdd/HMul, etc. classes.</p>\n<p>Then, maybe, there's an automated theorem prover angle after this, to prove properties like <code>add_comm</code>.</p>\n<p>The important thing is defining the right lemmas first. That <code>example</code> doesn't look like any of the lemmas you'd want to generate. You want <code>Nat.add_zero</code> and <code>Nat.add_succ</code>, which require unfolding definitions. That's it, and everything else about addition follows from those.</p>\n</blockquote>\n<p>The <code>example</code> is the last <code>congrArg</code> operation from <code>Nat.add_succ</code>, structured in tactic form</p>",
        "id": 536456841,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756311806
    },
    {
        "content": "<p>I don't understand: <code>Nat.add_succ</code> is proved with <code>rfl</code>. Both of the basic lemmas are definitional equalities. The special thing about <code>Nat.add_succ</code> is purely that it's written in terms of <code>+</code> instead of <code>Nat.add</code>.</p>",
        "id": 536458678,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756312427
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536458678\">said</a>:</p>\n<blockquote>\n<p>I don't understand: <code>Nat.add_succ</code> is proved with <code>rfl</code>. Both of the basic lemmas are definitional equalities. The special thing about <code>Nat.add_succ</code> is purely that it's written in terms of <code>+</code> instead of <code>Nat.add</code>.</p>\n</blockquote>\n<p>sorry, I meant <code>succ_add</code>, not <code>add_succ</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">succ_add</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\">   </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">succ_add</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 536458782,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756312471
    },
    {
        "content": "<p>Right, and so <code>succ_add</code> should be proved using your generated \"<code>add_succ</code>\"</p>",
        "id": 536458824,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756312491
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Rewrite.20not.20sufficiently.20aggressive/near/536458824\">said</a>:</p>\n<blockquote>\n<p>Right, and so <code>succ_add</code> should be proved using your generated \"<code>add_succ</code>\"</p>\n</blockquote>\n<p>but <code>succ_add</code> is not proven using <code>add_succ</code> in <code>`Init.Data.Nat.Basic</code>?</p>",
        "id": 536458945,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756312530
    },
    {
        "content": "<p>In any case, thanks for the explanation. I think I've a way to handle this.</p>",
        "id": 536460123,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756312985
    },
    {
        "content": "<p>Sorry, had to step away for a bit. The <code>Init</code> proof is proving it from scratch for some reason, possibly because it's more convenient when no tactics are available yet.</p>\n<p>Here's a model using the <code>Nat.add_zero</code>/<code>Nat.add_succ</code> restatements of the equation lemmas, and using <code>rewrite</code> instead of <code>rw</code> to verify that the lemmas do the job:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ_add'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rewrite</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_succ</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rewrite</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_succ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_succ</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I use <code>using Nat.rec</code> to avoid using the custom induction principle that <code>Nat</code> uses, whose purpose is to put things in terms of notation. There's also a small complexity here that Lean sometimes normalizes Nat literals to use OfNat, so you can see a <code>1</code> instead of <code>Nat.zero.succ</code> in one of the goal states.</p>",
        "id": 536467350,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756315634
    }
]