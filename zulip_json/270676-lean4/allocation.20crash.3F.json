[
    {
        "content": "<p>I'm getting a weird crash in a mathlib file, that is very susceptible to any changes in the file: the error disappears or re-appears semi-randomly when removing or changing unrelated definitions or certain doc comments in the file. This means that it is hard to minimize, but the crash does consistently happen when running the same file repeatedly (both in VSCode and from the command line). I managed to semi-minimize it to the code here:<br>\n<a href=\"https://gist.github.com/fpvandoorn/9d21b9530e22bb49ca4adc23484f8402\">https://gist.github.com/fpvandoorn/9d21b9530e22bb49ca4adc23484f8402</a><br>\nIt depends on mathlib, but gives an error on commit 4d0921d2 of mathlib4 (i.e. current <code>master</code>).</p>\n<p>On several versions of the crash I ran <code>gdb</code> together with the help of <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> and looked at the stack trace. Each time, the error is <code>Program received signal SIGSEGV, Segmentation fault.</code> and the top line of the backtrace is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"mi\">0</span>  <span class=\"mi\">0x00007ffff7ebd7c2</span> <span class=\"k\">in</span> <span class=\"n\">lean_alloc_small</span> <span class=\"o\">()</span> <span class=\"k\">from</span> <span class=\"bp\">/</span><span class=\"n\">home</span><span class=\"bp\">/</span><span class=\"n\">vandoorn</span><span class=\"bp\">/.</span><span class=\"n\">elan</span><span class=\"bp\">/</span><span class=\"n\">toolchains</span><span class=\"bp\">/</span><span class=\"n\">leanprover</span><span class=\"c1\">--lean4---nightly-2023-02-03/bin/../lib/lean/libleanshared.so</span>\n</code></pre></div>\n<p>The rest of the lines of the backtrace vary wildly depending on small changes in the file.</p>",
        "id": 326201043,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1675705406
    },
    {
        "content": "<p>Remark: the file only executes lines 217-237, and that definition doesn't refer to any previous definitions in the same file (only some structures).</p>",
        "id": 326202243,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1675705780
    },
    {
        "content": "<p>It's hard to know if the error is due to <code>lean_alloc_small</code> or if it's from multiple interacting errors, but two places that could cause a segmentation fault are <a href=\"https://github.com/leanprover/lean4/blob/f4d005e86d0ca248adf8119cfec0a4c0f6f79a89/src/runtime/alloc.cpp#L385\">this line</a> in case <code>g_heap</code> is null or <a href=\"https://github.com/leanprover/lean4/blob/f4d005e86d0ca248adf8119cfec0a4c0f6f79a89/src/runtime/alloc.cpp#L387\">this line</a> in case the page for the given object size for some reason hasn't been allocated yet.</p>\n<p>One thing I noticed is that the small deallocation functions check for <code>g_heap</code> being null, but it's possible to avoid this check if you go through <code>lean_alloc_small_object</code></p>",
        "id": 326202458,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675705838
    },
    {
        "content": "<p>(FWIW I can reproduce, so well done for minimising!)</p>",
        "id": 326208667,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1675707709
    },
    {
        "content": "<p>Floris and I got as far as finding that this code causes <a href=\"https://github.com/leanprover/lean4/blob/f4d005e86d0ca248adf8119cfec0a4c0f6f79a89/src/library/compiler/ir_interpreter.cpp#L949\"><code>interpreter::~interpreter()</code></a> to do reference count decrementing for dead objects.</p>\n<p>My best guess at the moment is that <a href=\"https://github.com/leanprover/lean4/blob/f4d005e86d0ca248adf8119cfec0a4c0f6f79a89/src/library/compiler/ir_interpreter.cpp#L829\">this line of <code>interpreter::load()</code></a> might be the issue. It is trusting that <code>t</code> is the actual type of the returned value -- if that's wrong, then if the result is an object it won't increment the reference count.</p>",
        "id": 326450659,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675801412
    },
    {
        "content": "<p>The way we found this was by adding <code>lean_assert((uintptr_t)get_next_obj(r) % 8 == 0);</code> right before <code>p-&gt;m_header.m_free_list = get_next_obj(r);</code> in <code>lean_alloc_small</code>, which revealed an object <code>r</code> in a free list that had a bad next pointer (an in particular, one whose pointer was one less than what it was supposed to be). Then we added a watch in gdb for when that next pointer got decremented to that value, and that happened to be right in <code>interpreter::~interpreter()</code>.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>lean_asserts in context</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gh\">diff --git a/src/runtime/alloc.cpp b/src/runtime/alloc.cpp</span>\n<span class=\"gh\">index 958afa4d1b..fc2d437a57 100644</span>\n<span class=\"gd\">--- a/src/runtime/alloc.cpp</span>\n<span class=\"gi\">+++ b/src/runtime/alloc.cpp</span>\n<span class=\"gu\">@@ -203,6 +203,9 @@ static inline page * page_list_pop(page * &amp; head) {</span>\n\n<span class=\"w\"> </span>void page::push_free_obj(void * o) {\n<span class=\"w\"> </span>    lean_assert(get_page_of(o) == this);\n<span class=\"gi\">+    uintptr_t diff = (uintptr_t)o - (uintptr_t)get_page_of(o);</span>\n<span class=\"gi\">+    lean_assert(diff == (diff - sizeof(page_header))/m_header.m_obj_size * m_header.m_obj_size + sizeof(page_header));</span>\n<span class=\"gi\">+    lean_assert((uintptr_t)o % 8 == 0);</span>\n<span class=\"w\"> </span>    set_next_obj(o, m_header.m_free_list);\n<span class=\"w\"> </span>    m_header.m_free_list = o;\n<span class=\"w\"> </span>    m_header.m_num_free++;\n<span class=\"gu\">@@ -374,7 +377,9 @@ void * lean_alloc_small_cold(unsigned sz, unsigned slot_idx, page * p) {</span>\n<span class=\"w\"> </span>        page_list_insert(g_heap-&gt;m_curr_page[slot_idx], p);\n<span class=\"w\"> </span>    }\n<span class=\"w\"> </span>    void * r = p-&gt;m_header.m_free_list;\n<span class=\"gi\">+    lean_assert((uintptr_t)r % 8 == 0);</span>\n<span class=\"w\"> </span>    lean_assert(r);\n<span class=\"gi\">+    lean_assert((uintptr_t)get_next_obj(r) % 8 == 0);</span>\n<span class=\"w\"> </span>    p-&gt;m_header.m_free_list = get_next_obj(r);\n<span class=\"w\"> </span>    p-&gt;m_header.m_num_free--;\n<span class=\"w\"> </span>    lean_assert(get_page_of(r) == p);\n<span class=\"gu\">@@ -382,12 +387,20 @@ void * lean_alloc_small_cold(unsigned sz, unsigned slot_idx, page * p) {</span>\n<span class=\"w\"> </span>}\n\n<span class=\"w\"> </span>extern \"C\" LEAN_EXPORT void * lean_alloc_small(unsigned sz, unsigned slot_idx) {\n<span class=\"gi\">+    lean_assert(g_heap != nullptr);</span>\n<span class=\"gi\">+    if (LEAN_UNLIKELY(g_heap == nullptr)) {</span>\n<span class=\"gi\">+        init_heap(false);</span>\n<span class=\"gi\">+    }</span>\n<span class=\"w\"> </span>    page * p = g_heap-&gt;m_curr_page[slot_idx];\n<span class=\"w\"> </span>    g_heap-&gt;m_heartbeat++;\n<span class=\"w\"> </span>    void * r = p-&gt;m_header.m_free_list;\n<span class=\"w\"> </span>    if (LEAN_UNLIKELY(r == nullptr)) {\n<span class=\"w\"> </span>        return lean_alloc_small_cold(sz, slot_idx, p);\n<span class=\"w\"> </span>    }\n<span class=\"gi\">+    lean_assert((uintptr_t)r % 8 == 0);</span>\n<span class=\"gi\">+    uintptr_t diff = (uintptr_t)r - (uintptr_t)p-&gt;m_data;</span>\n<span class=\"gi\">+    lean_assert(diff == diff/p-&gt;m_header.m_obj_size * p-&gt;m_header.m_obj_size);</span>\n<span class=\"gi\">+    lean_assert((uintptr_t)get_next_obj(r) % 8 == 0);</span>\n<span class=\"w\"> </span>    p-&gt;m_header.m_free_list = get_next_obj(r);\n<span class=\"w\"> </span>    p-&gt;m_header.m_num_free--;\n<span class=\"w\"> </span>    lean_assert(get_page_of(r) == p);\n</code></pre></div>\n</div></div>",
        "id": 326451823,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675801828
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/allocation.20crash.3F/near/326450659\">said</a>:</p>\n<blockquote>\n<p>My best guess at the moment is that <a href=\"https://github.com/leanprover/lean4/blob/f4d005e86d0ca248adf8119cfec0a4c0f6f79a89/src/library/compiler/ir_interpreter.cpp#L829\">this line of <code>interpreter::load()</code></a> might be the issue. It is trusting that <code>t</code> is the actual type of the returned value -- if that's wrong, then if the result is an object it won't increment the reference count.</p>\n</blockquote>\n<p>That should be easy to check.  Can you add an assert there?</p>",
        "id": 326452517,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1675802081
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>gdb stack trace part one</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>#0  lean_dec_ref (o=0x5555563db268)\n    at /home/kmill/projects/lean4/build/stage1/include/lean/lean.h:448\n#1  0x00007ffff78ecb4a in lean_dec (o=0x5555563db268)\n    at /home/kmill/projects/lean4/build/stage1/include/lean/lean.h:451\n#2  0x00007ffff78ed067 in lean::dec (o=0x5555563db268)\n    at /home/kmill/projects/lean4/src/runtime/object.h:56\n#3  0x00007ffff7a356a8 in lean::ir::interpreter::~interpreter()::{lambda(lean::name const&amp;, lean::ir::interpreter::constant_cache_entry const&amp;)#1}::operator()(lean::name const&amp;, lean::ir::interpreter::constant_cache_entry const&amp;) const (\n    __closure=0x7fffffffc0d7, e=...)\n    at /home/kmill/projects/lean4/src/library/compiler/ir_interpreter.cpp:952\n#4  0x00007ffff7a39390 in lean::rb_map&lt;lean::name, lean::ir::interpreter::constant_cache_entry, lean::name_quick_cmp&gt;::for_each&lt;lean::ir::interpreter::~for_each()::{lambda(lean::name const&amp;, lean::ir::interpreter::constant_cache_entry const&amp;)#1}&amp;&gt;(lean::ir::interpreter::~for_each()::{lambda(lean::name const&amp;, lean::ir::interpreter::constant_cache_entry const&amp;)#1}&amp;) const::{lambda(std::pair&lt;lean::name, lean::ir::interpreter::constant_cache_entry&gt; const&amp;)#1}::operator()(std::pair&lt;lean::name, lean::ir::interpreter::constant_cache_entry&gt; const&amp;) const (\n    __closure=0x7fffffffc080, e={...})\n    at /home/kmill/projects/lean4/src/util/rb_map.h:78\n#5  0x00007ffff7a3d965 in lean::rb_tree&lt;std::pair&lt;lean::name, lean::ir::interpreter::constant_cache_entry&gt;, lean::rb_map&lt;lean::name, lean::ir::interpreter::constant_cache_entry, lean::name_quick_cmp&gt;::entry_cmp&gt;::for_each&lt;lean::rb_map&lt;lean:--Type &lt;RET&gt; for more, q to quit, c to continue without paging--\n:name, lean::ir::interpreter::constant_cache_entry, lean::name_quick_cmp&gt;::for_each&lt;lean::ir::interpreter::~for_each()::{lambda(lean::name const&amp;, lean::ir::interpreter::constant_cache_entry const&amp;)#1}&amp;&gt;(lean::ir::interpreter::~for_each()::{lambda(lean::name const&amp;, lean::ir::interpreter::constant_cache_entry const&amp;)#1}&amp;) const::{lambda(std::pair&lt;lean::name, lean::ir::interpreter::constant_cache_entry&gt; const&amp;)#1}&amp;&gt;(lean::ir::interpreter::~for_each()::{lambda(lean::name const&amp;, lean::ir::interpreter::constant_cache_entry const&amp;)#1}&amp;, lean::rb_tree&lt;std::pair&lt;lean::name, lean::ir::interpreter::constant_cache_entry&gt;, lean::rb_map&lt;lean::name, lean::ir::interpreter::constant_cache_entry, lean::name_quick_cmp&gt;::entry_cmp&gt;::node_cell const*) (f=..., n=0x5555555f1c40)\n    at /home/kmill/projects/lean4/src/util/rb_tree.h:253\n#6  0x00007ffff7a3d97c in lean::rb_tree&lt;std::pair&lt;lean::name, lean::ir::interpreter::constant_cache_entry&gt;, lean::rb_map&lt;lean::name, lean::ir::interpreter::constant_cache_entry, lean::name_quick_cmp&gt;::entry_cmp&gt;::for_each&lt;lean::rb_map&lt;lean::name, lean::ir::interpreter::constant_cache_entry, lean::name_quick_cmp&gt;::for_each&lt;lean::ir::interpreter::~for_each()::{lambda(lean::name const&amp;, lean::ir::interpreter::constant_cache_entry const&amp;)#1}&amp;&gt;(lean::ir::interpreter::~for_each()::{lambda(lean::name const&amp;, lean::ir::interpreter::constant_cache_entry const&amp;)#1}&amp;) const::{lambda(std::pair&lt;lean::name, lean::ir::interpreter::constant_cache_entry&gt; const&amp;)#1}&amp;&gt;(lean::ir::interpreter::~for_each()::{lambda(lean::name const&amp;, lean::ir::interpreter::constant_cache_entry const&amp;)#1}&amp;, lean::rb_tree&lt;std::pair&lt;lean::name, lean::ir::interpreter::constant_cache_entry&gt;, lean::rb_map&lt;lean::name, lean::ir::interpreter::constant_cache_entry, lean::name_quick_cmp&gt;::entry_\ncmp&gt;::node_cell const*) (f=..., n=0x555555600660)\n    at /home/kmill/projects/lean4/src/util/rb_tree.h:254\n#7  0x00007ffff7a3d94e in lean::rb_tree&lt;std::pair&lt;lean::name, lean::ir::interpreter::constant_cache_entry&gt;, lean::rb_map&lt;lean::name, lean::ir::interpreter::constant_cache_entry, lean::name_quick_cmp&gt;::entry_cmp&gt;::for_each&lt;lean::rb_map&lt;lean::name, lean::ir::interpreter::constant_cache_entry, lean::name_quick_cmp&gt;::for_each&lt;lean::ir::interpreter::~for_each()::{lambda(lean::name const&amp;, lean::ir::interpreter::constant_cache_entry const&amp;)#1}&amp;&gt;(lean::ir::interpreter::~for_each()::{lambda(lean::name const&amp;, lean::ir::interpreter::constant_cache_entry const&amp;)#1}&amp;) const::{lambda(std::pair&lt;lean::name, lean::ir::interpreter::constant_cache_entry&gt; const&amp;)#1}&amp;&gt;(lean::ir::interpreter::~for_each()::{lambda(lean::name const&amp;, lean::ir::interpreter::constant_cache_entry const&amp;)#1}&amp;, lean::rb_tree&lt;std::pair&lt;lean::name, lean::ir::interpreter::constant_cache_entry&gt;, lean::rb_map&lt;lean::name, lean::ir::interpreter::constant_cache_entry, lean::name_quick_cmp&gt;::entry_cmp&gt;::node_cell const*) (f=..., n=0x5555556e4c90)\n    at /home/kmill/projects/lean4/src/util/rb_tree.h:252\n#8  0x00007ffff7a3b440 in lean::rb_tree&lt;std::pair&lt;lean::name, lean::ir::interpreter::constant_cache_entry&gt;, lean::rb_map&lt;lean::name, lean::ir::interpreter::constant_cache_entry, lean::name_quick_cmp&gt;::entry_cmp&gt;::for_each&lt;lean::rb_map&lt;lean::name, lean::ir::interpreter::constant_cache_entry, lean::name_quick_cmp&gt;::for_each&lt;lean::ir::interpreter::~for_each()::{lambda(lean::name const&amp;, lean::ir::interpreter::constant_cache_entry const&amp;)#1}&amp;&gt;(lean::ir::interpreter::~for_each()::{lambda(lean::name const&amp;, lean::ir::interpreter::constant_cache_entry const&amp;)#1--Type &lt;RET&gt; for more, q to quit, c to continue without paging--\n}&amp;) const::{lambda(std::pair&lt;lean::name, lean::ir::interpreter::constant_cache_entry&gt; const&amp;)#1}&amp;&gt;(lean::ir::interpreter::~for_each()::{lambda(lean::name const&amp;, lean::ir::interpreter::constant_cache_entry const&amp;)#1}&amp;) const (\n    this=0x7fffffffc1b0, f=...)\n    at /home/kmill/projects/lean4/src/util/rb_tree.h:449\n#9  0x00007ffff7a393d2 in lean::rb_map&lt;lean::name, lean::ir::interpreter::constant_cache_entry, lean::name_quick_cmp&gt;::for_each&lt;lean::ir::interpreter::~for_each()::{lambda(lean::name const&amp;, lean::ir::interpreter::constant_cache_entry const&amp;)#1}&amp;&gt;(lean::ir::interpreter::~for_each()::{lambda(lean::name const&amp;, lean::ir::interpreter::constant_cache_entry const&amp;)#1}&amp;) const (this=0x7fffffffc1b0,\n    f=...) at /home/kmill/projects/lean4/src/util/rb_map.h:79\n#10 0x00007ffff7a37573 in lean::for_each&lt;lean::name, lean::ir::interpreter::constant_cache_entry, lean::name_quick_cmp, lean::ir::interpreter::~name_quick_cmp()::{lambda(lean::name const&amp;, lean::ir::interpreter::constant_cache_entry const&amp;)#1}&gt;(lean::rb_map&lt;lean::name, lean::ir::interpreter::constant_cache_entry, lean::name_quick_cmp&gt; const&amp;, lean::ir::interpreter::~name_quick_cmp()::{lambda(lean::name const&amp;, lean::ir::interpreter::constant_cache_entry const&amp;)#1}&amp;&amp;) (\n    m=..., f=...) at /home/kmill/projects/lean4/src/util/rb_map.h:143\n</code></pre></div>\n</div></div>",
        "id": 326452607,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675802117
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>gdb stack trace part two</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>#11 0x00007ffff7a356e2 in lean::ir::interpreter::~interpreter (\n    this=0x7fffffffc150, __in_chrg=&lt;optimized out&gt;)\n    at /home/kmill/projects/lean4/src/library/compiler/ir_interpreter.cpp:950\n#12 0x00007ffff7a3707b in lean::ir::interpreter::with_interpreter&lt;lean_object*&gt;(lean::environment const&amp;, lean::options const&amp;, lean::name const&amp;, std::function--Type &lt;RET&gt; for more, q to quit, c to continue without paging--\n&lt;lean_object* (lean::ir::interpreter&amp;)&gt; const&amp;) (env=..., opts=..., fn=...,\n    f=...)\n    at /home/kmill/projects/lean4/src/library/compiler/ir_interpreter.cpp:388\n#13 0x00007ffff7a344a9 in lean::ir::interpreter::stub_m_aux (\n    args=0x7fffffffc320)\n    at /home/kmill/projects/lean4/src/library/compiler/ir_interpreter.cpp:899\n#14 0x00007ffff7a3477a in lean::ir::interpreter::stub_6_aux (\n    x_1=0x5555563b7388, x_2=0x55555645b778, x_3=0x555556275da8,\n    x_4=0x555556679820, x_5=0x555556523c38, x_6=0x1)\n    at /home/kmill/projects/lean4/src/library/compiler/ir_interpreter.cpp:910\n#15 0x00007ffff7a64ab0 in lean::lean_apply_3 (f=0x555556275928,\n    a1=0x555556679820, a2=0x555556523c38, a3=0x1)\n    at /home/kmill/projects/lean4/src/runtime/apply.cpp:232\n#16 0x00007ffff7a64997 in lean::lean_apply_3 (f=0x5555562bc1b8,\n    a1=0x555556679820, a2=0x555556523c38, a3=0x1)\n    at /home/kmill/projects/lean4/src/runtime/apply.cpp:230\n#17 0x00007ffff5b7bace in l_Lean_Elab_withInfoTreeContext___at_Lean_Elab_Command_withMacroExpansion___spec__1___rarg ()\n   from /home/kmill/projects/lean4/build/stage1/bin/../lib/lean/libleanshared.so\n#18 0x00007ffff5b7d0b2 in l___private_Lean_Elab_Command_0__Lean_Elab_Command_elabCommandUsing ()\n   from /home/kmill/projects/lean4/build/stage1/bin/../lib/lean/libleanshared.so\n#19 0x00007ffff7a64ab0 in lean::lean_apply_3 (f=0x5555562c4278,\n    a1=0x555556679820, a2=0x555556523c38, a3=0x1)\n    at /home/kmill/projects/lean4/src/runtime/apply.cpp:232\n#20 0x00007ffff7a64a14 in lean::lean_apply_3 (f=0x555556266588,\n    a1=0x555556679790, a2=0x555556523c38, a3=0x1)\n    at /home/kmill/projects/lean4/src/runtime/apply.cpp:231\n#21 0x00007ffff5b869c7 in l_Lean_Elab_withLogging___at_Lean_Elab_Command_elabCommand___spec__2 ()\n   from /home/kmill/projects/lean4/build/stage1/bin/../lib/lean/libleanshared.so\n#22 0x00007ffff5b938b0 in l_Lean_Elab_Command_elabCommandTopLevel___lambda__2\n    ()\n   from /home/kmill/projects/lean4/build/stage1/bin/../lib/lean/libleanshared.so\n#23 0x00007ffff5c58d65 in l_Lean_Elab_Frontend_elabCommandAtFrontend ()\n   from /home/kmill/projects/lean4/build/stage1/bin/../lib/lean/libleanshared.so\n#24 0x00007ffff5c59856 in l_Lean_Elab_Frontend_elabCommandAtFrontend___boxed ()\n   from /home/kmill/projects/lean4/build/stage1/bin/../lib/lean/libleanshared.so\n#25 0x00007ffff7a5e35f in lean::lean_apply_1 (f=0x5555562c5bf8, a1=0x1)\n    at /home/kmill/projects/lean4/src/runtime/apply.cpp:111\n--Type &lt;RET&gt; for more, q to quit, c to continue without paging--\n#26 0x00007ffff6086cb4 in l_Lean_profileitIOUnsafe___rarg___lambda__1 ()\n   from /home/kmill/projects/lean4/build/stage1/bin/../lib/lean/libleanshared.so\n#27 0x00007ffff6086e01 in l_Lean_profileitIOUnsafe___rarg___lambda__1___boxed\n    ()\n   from /home/kmill/projects/lean4/build/stage1/bin/../lib/lean/libleanshared.so\n#28 0x00007ffff7a5e26b in lean::lean_apply_1 (f=0x5555562bc618, a1=0x1)\n    at /home/kmill/projects/lean4/src/runtime/apply.cpp:109\n#29 0x00007ffff7989018 in lean::apply_1 (f=0x5555562bc618, a1=0x1)\n    at /home/kmill/projects/lean4/src/runtime/object.h:134\n#30 0x00007ffff7988823 in lean::lean_profileit (category=0x7ffff3fec788,\n    opts=0x55555645b778, fn=0x5555562bc618)\n    at /home/kmill/projects/lean4/src/library/time_task.cpp:69\n#31 0x00007ffff6086e99 in l_Lean_profileitIOUnsafe___rarg ()\n   from /home/kmill/projects/lean4/build/stage1/bin/../lib/lean/libleanshared.so\n#32 0x00007ffff5c5c2d0 in l_Lean_Elab_Frontend_processCommand ()\n   from /home/kmill/projects/lean4/build/stage1/bin/../lib/lean/libleanshared.so\n#33 0x00007ffff5c5d07e in l_Lean_Elab_Frontend_processCommands ()\n   from /home/kmill/projects/lean4/build/stage1/bin/../lib/lean/libleanshared.so\n--Type &lt;RET&gt; for more, q to quit, c to continue without paging--\n#34 0x00007ffff5c5d5a6 in l_Lean_Elab_IO_processCommands ()\n   from /home/kmill/projects/lean4/build/stage1/bin/../lib/lean/libleanshared.so\n#35 0x00007ffff5c5e9f3 in l_Lean_Elab_runFrontend___lambda__2 ()\n   from /home/kmill/projects/lean4/build/stage1/bin/../lib/lean/libleanshared.so\n#36 0x00007ffff5c5fe2e in lean_run_frontend ()\n   from /home/kmill/projects/lean4/build/stage1/bin/../lib/lean/libleanshared.so\n#37 0x00007ffff79002fc in lean::run_new_frontend (\n    input=\"/-\\nCopyright (c) 2022 Floris van Doorn. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthors: Floris van Doorn\\n-/\\n\\nimport Mathlib.Init.Data.Nat.Notation\\nimp\"..., opts=...,\n    file_name=\"./././Mathlib/buggg.lean\", main_module_name=...,\n    trust_level=1025, ilean_file_name=...)\n    at /home/kmill/projects/lean4/src/util/shell.cpp:372\n#38 0x00007ffff79020bd in lean_main (argc=12, argv=0x7fffffffded8)\n    at /home/kmill/projects/lean4/src/util/shell.cpp:726\n#39 0x000055555555516d in main (argc=12, argv=0x7fffffffded8)\n    at /home/kmill/projects/lean4/src/shell/lean.cpp:15\n</code></pre></div>\n</div></div>\n<p>(this one has <code>interpreter::~interpreter</code>)</p>",
        "id": 326452762,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675802164
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> I'm not sure what the assert should be exactly since <code>value</code> is a union, but there's something I could try here to at least test the theory.</p>",
        "id": 326452934,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675802213
    },
    {
        "content": "<p>Ah, I see what you mean.  I got a bit confused by the name <code>type_is_scalar</code> and thought it referred to scalars stored using pointer tagging.</p>",
        "id": 326453651,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1675802451
    },
    {
        "content": "<p>I don't have much time for Lean right now, but it would not be the first bug resulting from an interpreter/compiler ABI mismatch</p>",
        "id": 326455512,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1675803121
    },
    {
        "content": "<p>rr (reverse debugger) on a debug+sanitized build without custom allocator is my favored setup for debugging runtime bugs btw</p>",
        "id": 326456038,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1675803277
    },
    {
        "content": "<p>So far it looks like my theory is wrong -- the <code>interpreter::load()</code> function increments the reference count just fine, so there must be something somewhere else double decrementing.</p>",
        "id": 326456141,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675803312
    },
    {
        "content": "<p>If anyone wants to pick this up, here's how to get to something that seems close to the problem.</p>\n<p>First, using a breakpoint or an assert like the following, the lean file ends up failing the following assert:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>static inline void lean_dec_ref(lean_object * o) {\n     if (LEAN_LIKELY(o-&gt;m_rc &gt; 1)) {\n+        assert(o-&gt;m_rc &lt; 100000);\n         o-&gt;m_rc--;\n</code></pre></div>\n<p>This gives you the address of an object <code>o</code> that is being double freed. On my system it is reliably at <code>0x5555563db268</code> (which I'll use below).</p>\n<p>I then set a breakpoint for <code>src/library/compiler/ir_interpreter.cpp:832</code> conditioned on <code>r.m_obj == 0x5555563db268</code> and ran Lean until I reached the breakpoint. Then I added a watchpoint for <code>*0x5555563db268</code> conditioned on <code>*(uint32_t*)0x5555563db268 == 1</code> and continued execution. This leads you into the middle of the deallocation routines. From within <code>lean_del_core</code>, you can see that there is a 4-argument constructor that is being deallocated, and the first two elements are 0x5555563db268.</p>\n<p>So somehow this object appears twice without the reference count being incremented properly, leading to it being marked as free even though it's still in <code>m_constant_cache</code>.</p>",
        "id": 326461940,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675805416
    },
    {
        "content": "<p>Here is a little bit further. You can get the name of the <code>m_constant_cache</code> object that's double freed.</p>\n<p>If you then do <code>set_option trace.complier true</code>, you can identify it as what gets assigned to <code>_x_2</code>. I think it's very likely it's the object assigned to <code>_x_8</code> that ends up with <code>_x_2</code> as its first two arguments where the reference count for <code>_x_2</code> doesn't get incremented correctly.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">compiler.lambda_pure</span><span class=\"o\">]</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">_tmp._</span><span class=\"bp\">@.</span><span class=\"n\">Mathlib.buggg._hyg.3840._closed_4</span> <span class=\"o\">:=</span> <span class=\"k\">let</span> <span class=\"n\">_x_1</span> <span class=\"o\">:=</span> <span class=\"n\">Option._cnstr.0.0.0</span><span class=\"bp\">;</span>\n<span class=\"k\">let</span> <span class=\"n\">_x_2</span> <span class=\"o\">:=</span> <span class=\"n\">_tmp.</span><span class=\"bp\">«</span><span class=\"n\">_</span><span class=\"bp\">@».</span><span class=\"n\">Mathlib.buggg._hyg.3840._closed_3</span><span class=\"bp\">;</span>\n<span class=\"k\">let</span> <span class=\"n\">_x_3</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">;</span>\n<span class=\"k\">let</span> <span class=\"n\">_x_4</span> <span class=\"o\">:=</span> <span class=\"n\">_x_3</span><span class=\"bp\">;</span>\n<span class=\"k\">let</span> <span class=\"n\">_x_5</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"bp\">;</span>\n<span class=\"k\">let</span> <span class=\"n\">_x_6</span> <span class=\"o\">:=</span> <span class=\"n\">_x_5</span><span class=\"bp\">;</span>\n<span class=\"k\">let</span> <span class=\"n\">_x_7</span> <span class=\"o\">:=</span> <span class=\"n\">Simps.ParsedProjectionData.projNrs._default._closed_1</span><span class=\"bp\">;</span>\n<span class=\"k\">let</span> <span class=\"n\">_x_8</span> <span class=\"o\">:=</span> <span class=\"n\">Simps.ParsedProjectionData._cnstr.0.0.3</span> <span class=\"n\">_x_2</span> <span class=\"n\">_x_2</span> <span class=\"n\">_x_1</span> <span class=\"n\">_x_7</span><span class=\"bp\">;</span>\n<span class=\"k\">let</span> <span class=\"n\">_x_9</span> <span class=\"o\">:=</span> <span class=\"n\">_sset.1.4.0</span> <span class=\"n\">_x_8</span> <span class=\"n\">_x_4</span><span class=\"bp\">;</span>\n<span class=\"k\">let</span> <span class=\"n\">_x_10</span> <span class=\"o\">:=</span> <span class=\"n\">_sset.1.4.1</span> <span class=\"n\">_x_9</span> <span class=\"n\">_x_6</span><span class=\"bp\">;</span>\n<span class=\"k\">let</span> <span class=\"n\">_x_11</span> <span class=\"o\">:=</span> <span class=\"n\">_sset.1.4.2</span> <span class=\"n\">_x_10</span> <span class=\"n\">_x_6</span><span class=\"bp\">;</span>\n<span class=\"k\">let</span> <span class=\"n\">_x_12</span> <span class=\"o\">:=</span> <span class=\"n\">_x_11</span><span class=\"bp\">;</span>\n<span class=\"n\">_x_12</span>\n</code></pre></div>",
        "id": 326464691,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675806502
    },
    {
        "content": "<p>What's responsible for processing the <code>_x_2</code> arguments for <code>_x_8</code> and incrementing the reference counts? I'm not very familiar with the IR interpreter.</p>",
        "id": 326464816,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675806563
    },
    {
        "content": "<p>What does <code>set_option compiler.ir.result true</code> show?  λ-pure is the phase before refcounting, I believe.</p>",
        "id": 326465412,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1675806848
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">_tmp.</span><span class=\"bp\">«</span><span class=\"n\">_</span><span class=\"bp\">@».</span><span class=\"n\">Mathlib.buggg._hyg.3840._closed_4</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_1</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">ctor_0</span><span class=\"o\">[</span><span class=\"n\">Option.none</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_2</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">_tmp.</span><span class=\"bp\">«</span><span class=\"n\">_</span><span class=\"bp\">@».</span><span class=\"n\">Mathlib.buggg._hyg.3840._closed_3</span><span class=\"bp\">;</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_3</span> <span class=\"o\">:</span> <span class=\"n\">u8</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"bp\">;</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_4</span> <span class=\"o\">:</span> <span class=\"n\">u8</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"bp\">;</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_5</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">Simps.ParsedProjectionData.projNrs._default._closed_1</span><span class=\"bp\">;</span>\n  <span class=\"n\">inc</span> <span class=\"n\">x_2</span><span class=\"bp\">;</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_6</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">ctor_0.0.3</span><span class=\"o\">[</span><span class=\"n\">Simps.ParsedProjectionData.mk</span><span class=\"o\">]</span> <span class=\"n\">x_2</span> <span class=\"n\">x_2</span> <span class=\"n\">x_1</span> <span class=\"n\">x_5</span><span class=\"bp\">;</span>\n  <span class=\"n\">sset</span> <span class=\"n\">x_6</span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">u8</span> <span class=\"o\">:=</span> <span class=\"n\">x_3</span><span class=\"bp\">;</span>\n  <span class=\"n\">sset</span> <span class=\"n\">x_6</span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">u8</span> <span class=\"o\">:=</span> <span class=\"n\">x_4</span><span class=\"bp\">;</span>\n  <span class=\"n\">sset</span> <span class=\"n\">x_6</span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">u8</span> <span class=\"o\">:=</span> <span class=\"n\">x_4</span><span class=\"bp\">;</span>\n  <span class=\"n\">ret</span> <span class=\"n\">x_6</span>\n</code></pre></div>",
        "id": 326465906,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675807065
    },
    {
        "content": "<p>That <code>inc x_2</code> there should be enough right?</p>",
        "id": 326465994,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675807088
    },
    {
        "content": "<p>I thought the interpreter does the other increment in <code>load</code>?</p>",
        "id": 326466681,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1675807317
    }
]