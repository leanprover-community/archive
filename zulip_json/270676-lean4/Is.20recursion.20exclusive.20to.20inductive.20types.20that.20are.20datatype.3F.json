[
    {
        "content": "<p>I could not fit the plural of datatypes in the title hehe. From <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/Are.20all.20recursive.20functions.20implemented.20with.20.2EbrecOn.3F\">#lean4 &gt; Are all recursive functions implemented with .brecOn?</a>  and reading the new manual's section on structural recursion, I just wanted to confirm: it seems to me that there is a distinction between recursion and induction, where induction is something that can happen on dataless types. Would it be correct to say that the Lean kernel or compiler only needs to support/involve recursion (or derecursification) when eliminating inductive types that contain data? I think maybe the following question captures the essence of what I'm trying to ask:</p>\n<p>Is recursion in Lean exclusively a phenomenon that occurs when eliminating a type that is not in <code>Prop</code>?</p>",
        "id": 491891557,
        "sender_full_name": "nrs",
        "timestamp": 1736010385
    },
    {
        "content": "<p>A stricter definition of datatype could be an <code>Encodable</code> type (maybe?)</p>",
        "id": 491891801,
        "sender_full_name": "nrs",
        "timestamp": 1736010610
    },
    {
        "content": "<p>I'm not sure what you mean about a difference between recursion and induction, or what you mean precisely by a dataless type (do you mean a type that's <code>Prop</code>-valued? a type that only eliminates to <code>Prop</code>? a type that contains no computationally relevant fields?)</p>\n<p>The following is a theorem proved using recursion, and you can see it uses <code>P.brecOn</code> like any other structural recursion.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">le_refl</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_step</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>",
        "id": 491892753,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1736011605
    },
    {
        "content": "<p>hm right... that does generate a <code>brecOn</code> definition</p>",
        "id": 491893038,
        "sender_full_name": "nrs",
        "timestamp": 1736011891
    },
    {
        "content": "<p>I'm trying to determine whether recursion is exclusively something that occurs wrt types that contain as you say \"computationally relevant fields\", but I don't have a very good definition of what this might mean. I just infer there must be such a difference because <code>.rec</code> can be used to eliminate values without at times seemingly needing to perform any sort of recursive computation</p>",
        "id": 491893188,
        "sender_full_name": "nrs",
        "timestamp": 1736011980
    },
    {
        "content": "<p>Also from that fact that in sources about type theory there is always a disclaimer that the name \"recursor\" might be confusing as there may not be recursion involved at all (understandably so, as a type's \"recursor\"  is just the name for the eliminator of the values/terms for a particular type)</p>",
        "id": 491893320,
        "sender_full_name": "nrs",
        "timestamp": 1736012079
    },
    {
        "content": "<p>Where do you see a distinction between recursion and induction in Lean?</p>",
        "id": 491893846,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1736012526
    },
    {
        "content": "<p>I am not sure I can pinpoint it, but it seems to me it would explain the need for explicitly needing to compile <code>.rec</code> to use it in a definition, and the insufficiency of <code>.rec</code> to define functions that use instead <code>.brecOn</code></p>",
        "id": 491894003,
        "sender_full_name": "nrs",
        "timestamp": 1736012700
    },
    {
        "content": "<p>that is, if the distinction between recursion and induction is one of \"dataful\" vs \"dataless\" elimination</p>",
        "id": 491894110,
        "sender_full_name": "nrs",
        "timestamp": 1736012783
    },
    {
        "content": "<p>Needing to explicitly compile <code>.rec</code> is just that the compiler doesn't compile it by default. The runtime semantics of recursors is also a bit unclear, since naively you might always evaluate the base case. They're not like normal functions.</p>",
        "id": 491894119,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1736012791
    },
    {
        "content": "<p>This is not any sort of fundamental theory about recursors. My understanding is that the next code generator will handle them.</p>",
        "id": 491894178,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1736012855
    },
    {
        "content": "<p>It's a design decision to have the compiler consume elaborated <code>match</code> expressions rather than recursors. In fact, the code generator does not support brecOn either.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">brecOn</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">))</span>\n<span class=\"c\">/-</span><span class=\"cm\">  ~</span>\n<span class=\"cm\">code generator does not support recursor 'MyNat.brecOn' yet,</span>\n<span class=\"cm\">consider using 'match ... with' and/or structural recursion</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 491894406,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1736013064
    },
    {
        "content": "<p>hm I will be thinking about your comments, tyvm for taking the time!</p>",
        "id": 491895588,
        "sender_full_name": "nrs",
        "timestamp": 1736013924
    }
]