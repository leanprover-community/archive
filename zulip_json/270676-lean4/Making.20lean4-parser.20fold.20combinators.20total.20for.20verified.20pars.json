[
    {
        "content": "<p>I'm working on a verified parser for YAML 1.2.2 built on top ofÂ <a href=\"https://github.com/fgdorais/lean4-parser\">lean4-parser</a>Â and ran into a fundamental barrier: the core fold combinators (<code>efoldlPAux</code>,Â <code>foldr</code>,Â <code>takeUntil</code>,Â <code>dropUntil</code>,Â <code>count</code>,Â <code>countUntil</code>) are allÂ <code>partial def</code>, which makes them opaque to Lean's kernel and blocks proving any properties about parsers that use repetition.</p>\n<p>The root cause is thatÂ <code>ParserT</code>Â is polymorphic in the monadÂ <code>m</code>, so insideÂ <code>p s &gt;&gt;= fun | .ok s' x =&gt; ...</code>Â we can't extract the new stream stateÂ <code>s'</code>Â for aÂ <code>termination_by</code>Â clause â€” we're inside a monadic bind over an arbitraryÂ <code>m</code>.</p>\n<p>With the help of Github Copilot + Claude Code Opus 4.6, I wrote up an issue exploring four strategies and proposing one:</p>\n<p><strong>Issue:</strong> <a href=\"https://github.com/fgdorais/lean4-parser/issues/95\">https://github.com/fgdorais/lean4-parser/issues/95</a><br>\n<strong>PR:</strong> <a href=\"https://github.com/fgdorais/lean4-parser/pull/96\">https://github.com/fgdorais/lean4-parser/pull/96</a></p>\n<p>The short version: add aÂ <code>remaining : Ïƒ â†’ Nat</code>Â field toÂ <code>Parser.Stream</code>Â that provides an upper bound on tokens left, then use it as fuel for structural recursion onÂ <code>Nat</code>. The fold combinators become total while preserving their semantics â€” existing call sites are unchanged sinceÂ <code>fuel</code>Â defaults toÂ <code>Stream.remaining s</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">Stream</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ïƒ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ï„</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Stream</span><span class=\"w\"> </span><span class=\"n\">Ïƒ</span><span class=\"w\"> </span><span class=\"n\">Ï„</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Position</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">  </span><span class=\"n\">getPosition</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ïƒ</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Position</span>\n<span class=\"w\">  </span><span class=\"n\">setPosition</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ïƒ</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Position</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Ïƒ</span>\n<span class=\"w\">  </span><span class=\"n\">remaining</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ïƒ</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">  </span><span class=\"c1\">-- new: upper bound, must decrease when next? returns some</span>\n</code></pre></div>\n<p>The key insight is that this is the only approach (of the four analyzed) that works inside the monadic bind for arbitraryÂ <code>m</code>Â â€” specializing toÂ <code>Id</code>, requiringÂ <code>Consuming</code>Â proofs per-parser, or redesigning the fold API all have significant tradeoffs detailed in the issue.</p>\n<p>The PR includes a reference implementation with all 6Â <code>partial def</code>s replaced and all existing stream instances updated. It builds cleanly, and I've confirmed my downstream verified YAML parser project builds against it with only a one-line addition to itsÂ <code>Parser.Stream</code>Â instance.</p>\n<p>I'd welcome constructive feedback on:</p>\n<ul>\n<li>TheÂ <code>remaining</code>Â contract and whether the field belongs inÂ <code>Parser.Stream</code>Â vs. a separate typeclass</li>\n<li>The fuel-based termination approach vs. alternatives I may not have considered</li>\n<li>Any concerns about backward compatibility (everyÂ <code>Parser.Stream</code>Â instance must now implementÂ <code>remaining</code>)</li>\n</ul>",
        "id": 575106169,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1771699403
    },
    {
        "content": "<p>There is an interesting approach at <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/Extrinsic.20termination.20proofs.20for.20well-founded.20recursion/near/564822906\">#lean4 &gt; Extrinsic termination proofs for well-founded recursion @ ðŸ’¬</a> , could it work in your case? The trick is to define the function together with proven guarantees about its value in case it terminates. Then, it is possible to have both original partial function, as well as the backing by logic on terminating values, without even needing extra level of trust.</p>",
        "id": 575113300,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1771707643
    },
    {
        "content": "<p>Yes, lean4-parser needs to be adapted to Std.Iterators. That's on my (long) todo list. Contributions are welcome but please consult me about details.</p>",
        "id": 575119222,
        "sender_full_name": "FranÃ§ois G. Dorais",
        "timestamp": 1771715020
    },
    {
        "content": "<p>Thanks for the constructive comments!</p>\n<p><span class=\"user-mention\" data-user-id=\"133339\">@Mirek OlÅ¡Ã¡k</span>'s extrinsic termination proofs for well-founded recursion with library support like <span class=\"user-mention\" data-user-id=\"221653\">@Paul Reichert</span> 's s Myopic,is a fantastic idea; however, it would require a complex refactoring of the lean4-parser's fold API.</p>\n<p><span class=\"user-mention\" data-user-id=\"119741\">@FranÃ§ois G. Dorais</span>'s suggestion to use the Batteries' <code>Std.Iterators</code> effectively standardizes and generalizes what the <code>remaining</code> field does: An iterator that implements <code>Finite</code> carries a proof that it will eventually exhaust, which yields the termination argument fold combinators need.</p>\n<p>I took a first pass at this inÂ <a href=\"https://github.com/fgdorais/lean4-parser/pull/97\">PR #97</a>. The key ideas:</p>\n<ul>\n<li>AÂ <strong><code>LawfulParserStream</code></strong>Â typeclass (opt-in,Â <code>Prop</code>-valued) that requires provingÂ <code>remaining</code>Â strictly decreases on eachÂ <code>next?</code>Â yieldingÂ <code>some</code></li>\n<li>AÂ <strong><code>StreamIterator</code></strong>Â bridge that gives everyÂ <code>Parser.Stream</code>Â anÂ <code>Iterator</code>Â instance, and everyÂ <code>LawfulParserStream</code>Â aÂ <code>Finite</code>Â +Â <code>IteratorLoop</code>Â instance (enablingÂ <code>for</code>Â loops)</li>\n<li>All fuel-based fold combinators (<code>efoldlPAux</code>,Â <code>foldr</code>,Â <code>takeUntil</code>,Â <code>dropUntil</code>,Â <code>countUntil</code>) replaced withÂ <strong>well-founded recursion</strong>Â viaÂ <code>termination_by Stream.remaining</code></li>\n<li><code>mkDefault</code>Â remainsÂ <code>partial</code>Â â€” noÂ <code>LawfulParserStream</code>Â instance, so existing users are unaffected</li>\n</ul>\n<p>TheÂ <code>LawfulParserStream</code>Â proofs are done forÂ <code>Subarray</code>Â andÂ <code>OfList</code>; theÂ <code>String.Slice</code>,Â <code>Substring.Raw</code>, andÂ <code>ByteSlice</code>Â instances still haveÂ <code>sorry</code>Â (they need simp lemmas for byte-index arithmetic that I haven't found in stdlib/Batteries yet).</p>\n<p>Is this along the lines of what you were thinking, <span class=\"user-mention\" data-user-id=\"119741\">@FranÃ§ois G. Dorais</span>?</p>",
        "id": 575127816,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1771725729
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"362579\">Nicolas Rouquette</span> <a href=\"#narrow/channel/270676-lean4/topic/Making.20lean4-parser.20fold.20combinators.20total.20for.20verified.20pars/near/575127816\">said</a>:</p>\n<blockquote>\n<p>Myopic,is a fantastic idea; however, it would require a complex refactoring of the lean4-parser's fold API</p>\n</blockquote>\n<p>I don't understand. The very idea of an extrinsic termination proof is that you don't change the API at all, but provide option to prove facts about it ex-post (which is not possible with current <code>partial</code>)</p>",
        "id": 575171032,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1771775617
    },
    {
        "content": "<p>You're right, I misspoke â€” extrinsic termination proofs by definition don't change the API, that's the whole point. Sorry for the confusion.</p>\n<p>What I should have said: the obstacle today is that Lean 4'sÂ <code>partial</code>Â compiles toÂ <code>opaque</code>, which blocks reasoning about the function body entirely. So to prove termination of lean4-parser's fold combinatorsÂ <em>right now</em>, we can't do it extrinsically against the existingÂ <code>partial def</code>s â€” we'd need something like Myopic to make the implementation available for reasoning, and I wasn't sure about its maturity/applicability to monadic well-founded recursion likeÂ <code>efoldlPAux</code>Â (which recurses throughÂ <code>&gt;&gt;=</code>Â inÂ <code>ParserT</code>).</p>\n<p>The PR takes the intrinsic route instead: replaceÂ <code>partial def</code>Â with totalÂ <code>def</code>Â +Â <code>termination_by Stream.remaining</code>, which makes the functions directly usable in proofs without any extra tooling. But I agree that if/when extrinsic proofs forÂ <code>partial</code>Â become well-supported in Lean, that would be a cleaner separation â€” keep the simpleÂ <code>partial</code>Â implementations and prove termination on the side.</p>",
        "id": 575181461,
        "sender_full_name": "Nicolas Rouquette",
        "timestamp": 1771785201
    },
    {
        "content": "<p>To me the worry is if inserting termination guarantees inside do not create extra annoyance to users of the parser who don't care about logic (because they just need some parsing on meta-programming level). But I have to admit I don't know the parser too much.</p>",
        "id": 575252143,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1771837502
    }
]