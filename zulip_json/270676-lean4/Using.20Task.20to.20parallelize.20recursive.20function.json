[
    {
        "content": "<p>Hey there.</p>\n<p>I have a recursive function that follows the structure of a tree in a DFS manner.</p>\n<p>I'd like to make that parallel, while keeping a proof of its correctness (which I already have, so if the changes are somewhat minimal, I'll take it).</p>\n<p>Is it possible to use <code>Task.spawn</code> on the recursive call to make it parallel or would I need to make a custom task list setup?</p>",
        "id": 471626634,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1726811777
    },
    {
        "content": "<p>I tried something but it seems I that I am getting a deadlock for some reason</p>",
        "id": 471642472,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1726816559
    },
    {
        "content": "<p>Are you blocking on tasks? You should only do that once on the top level of your function</p>",
        "id": 471715502,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1726835143
    },
    {
        "content": "<p>Thanks for the advice ! I ended up writing something along the lines of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">loop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Task</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"w\">  </span><span class=\"n\">loop</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">get</span>\n</code></pre></div>\n<p>And that worked !</p>",
        "id": 471903531,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1726906696
    },
    {
        "content": "<p>Related to that: in my implementation I have a parameter to set the \"depth\" at which I split into multiple tasks.</p>\n<p>Unfortunately, the complexity of the subtasks in each branch is not uniform, so at some point I have only one task remanining for a very long time, which could probably be broken into subtasks.</p>\n<p>Would it be possible to have a function of <code>Task</code>, like <code>Task.has_inactive_core</code>, that evaluates to true if there are inactive cores and false otherwise ?</p>",
        "id": 472173557,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1727082907
    },
    {
        "content": "<p>Something along the lines of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">Task</span><span class=\"bp\">.</span><span class=\"n\">inactiveCores</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n</code></pre></div>",
        "id": 472173924,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1727083007
    },
    {
        "content": "<p>That function wouldn't be pure, so I think it has to be <code>unsafe</code></p>",
        "id": 472174103,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727083065
    },
    {
        "content": "<p>It would be a problem for me because it would require marking the enclosing function <code>unsafe</code> too, which prevents me from proving anything about it</p>",
        "id": 472174316,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1727083118
    },
    {
        "content": "<p>Perhaps something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=withPtrAddr#doc\">docs#withPtrAddr</a> could be done, then, although I'm not sure</p>",
        "id": 472177650,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727084044
    },
    {
        "content": "<p>That's what I thought too<br>\nAnother thing I am thinking about is making bindings into openmp and adding a bunch of lemmas about the correctness of openmp</p>",
        "id": 472177910,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1727084124
    }
]