[
    {
        "content": "<p>Was there already discussion about a feature like this? Or maybe is it already implemented, but I couldn't find it? Basically, I would want to have a <code>@[cache]</code> attribute, kinda like <code>@functools.cache</code> in python3. By example, given:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">cache</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>the meta semantics of <code>fib</code> should not change. <code>[cache]</code> should only be reflected in a compiled program. This should create a global lock-free <code>HashMap Nat Nat</code>, and every call to <code>fib</code> (including recursive calls) would first check if the value was previously computed in this map, otherwise call <code>fib</code> implementation and store new value in cache map.</p>",
        "id": 564176179,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765950161
    },
    {
        "content": "<p>I would suggest we figure out how to do a lock free HashMap in lean before we do stuff like this :)</p>",
        "id": 564201141,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1765962311
    },
    {
        "content": "<p>Well, we don't have to write it in Lean. We can write in C. And using lock-free HashMap is optimization. We could start by implementing this with one mutex.</p>",
        "id": 564221974,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765968795
    },
    {
        "content": "<p>Here's what <code>[cached]</code> should do for <code>fib</code>. I'm not too good with meta-programming in Lean, so maybe someone else could write implementation that can do this automatically for any function?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">BaseMutex</span><span class=\"o\">)</span>\n\n<span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fib_cache_mutex</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BaseMutex</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">unsafeBaseIO</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">BaseMutex</span><span class=\"bp\">.</span><span class=\"n\">new</span>\n\n<span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fib_cache_ref</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">Ref</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Condvar</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">unsafeBaseIO</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">mkRef</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">emptyWithCapacity</span>\n\n<span class=\"kn\">mutual</span>\n\n<span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fib_impl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BaseIO</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">fib_cache_mutex</span><span class=\"bp\">.</span><span class=\"n\">lock</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">fib_cache_ref</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"o\">)[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">fib_cache_mutex</span><span class=\"bp\">.</span><span class=\"n\">unlock</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">res</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">condvar</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">condvar</span><span class=\"bp\">.</span><span class=\"n\">waitUntil</span><span class=\"w\"> </span><span class=\"n\">fib_cache_mutex</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">fib_cache_ref</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"o\">)[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">fib_cache_ref</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"o\">)[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">    </span><span class=\"n\">fib_cache_mutex</span><span class=\"bp\">.</span><span class=\"n\">unlock</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">res</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">condvar</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Condvar</span><span class=\"bp\">.</span><span class=\"n\">new</span>\n<span class=\"w\">    </span><span class=\"n\">fib_cache_ref</span><span class=\"bp\">.</span><span class=\"n\">modify</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">condvar</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"n\">fib_cache_mutex</span><span class=\"bp\">.</span><span class=\"n\">unlock</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">fib_impl_calc</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"n\">fib_cache_mutex</span><span class=\"bp\">.</span><span class=\"n\">lock</span>\n<span class=\"w\">    </span><span class=\"n\">fib_cache_ref</span><span class=\"bp\">.</span><span class=\"n\">modify</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"n\">condvar</span><span class=\"bp\">.</span><span class=\"n\">notifyAll</span>\n<span class=\"w\">    </span><span class=\"n\">fib_cache_mutex</span><span class=\"bp\">.</span><span class=\"n\">unlock</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">res</span>\n\n<span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fib_impl_calc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BaseIO</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">fib_impl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">fib_impl</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span>\n\n<span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fib_impl_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">unsafeBaseIO</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">fib_impl</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">implemented_by</span><span class=\"w\"> </span><span class=\"n\">fib_impl_</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"mi\">5000</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">foldr</span><span class=\"w\"> </span><span class=\"mi\">5000</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"c1\">-- This doesn't work. Maybe because of stack overflow?</span>\n<span class=\"c1\">--#eval fib 6000</span>\n</code></pre></div>",
        "id": 564250568,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765977921
    },
    {
        "content": "<p>Storing a HashMap in a global Lean Mutex or IO.Ref is not a good idea at the moment, when an Array is marked mt it will always be used non linearly so your implementation makes a copy of the cache on every write access.</p>",
        "id": 564251041,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1765978060
    },
    {
        "content": "<p>I don't understand at all. Which Array is marked mutable? What, and how marks it as mutable? Why is it used non linearly?</p>",
        "id": 564252737,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765978493
    },
    {
        "content": "<p>The array is marked as multi threaded not mutable.</p>",
        "id": 564254210,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1765978907
    },
    {
        "content": "<p>When you stuff an Array or an Array based structure like a HashMap into an IO Ref that is used across threads it is marked mt and thus always used non-linearly in the current implementation.</p>",
        "id": 564254453,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1765978976
    },
    {
        "content": "<p>I see. Is there some workaround to have a non-resizable linear array in Lean atm, or do we need to use <code>[extern ..]</code>?</p>",
        "id": 564256450,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765979446
    },
    {
        "content": "<p>You can use a TreeMap instead, though I'm still not convinced that the cache for this should be global, carrying one per invocation seems like a much more predictable approach.</p>",
        "id": 564288181,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1765987584
    },
    {
        "content": "<p>This topic may help you:<br>\n<a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/memoziation.20of.20strong.20recursion.20on.20nat/with/397948793\">#lean4 &gt; memoziation of strong recursion on nat</a></p>",
        "id": 564320554,
        "sender_full_name": "Miyahara Kō",
        "timestamp": 1765996882
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/270676-lean4/topic/.5Bcache.5D.20attribute/near/564288181\">said</a>:</p>\n<blockquote>\n<p>You can use a TreeMap instead, though I'm still not convinced that the cache for this should be global, carrying one per invocation seems like a much more predictable approach.</p>\n</blockquote>\n<p>But that's the point for it to be global. I've used recursive function to check if it works. But recursive functions are probably a bad use-case anyway, because of heavy performance cost of using map. Better use-case is when you have a plain non-recursive function, that takes very long to compute, and you want to not compute it multiple times across your program.</p>",
        "id": 564353130,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766010501
    },
    {
        "content": "<p>Sorry to revive a (relatively) old thread, <span class=\"user-mention\" data-user-id=\"870257\">@Jakub Nowak</span> <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> .  I'm trying to do something similar to what is being discussed above: putting a hashmap behind a mutex and using it as a cache with multiple threads. Is this still an issue? Is there a solution at this point?</p>",
        "id": 576090586,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1772129006
    },
    {
        "content": "<p>Yes still an issue and the solution is still to use something like a TreeMap in the general case.</p>\n<p>In particular situations some special solutions might be possible. for example in the implementation of Std.Sync.Channel, i used a <code>Vector (ST.Ref a) n</code>. One could also envision a more golang style solution where you have a thread that has the HashMap locally in its memory and gets communicated with through a channel etc. It depends on what you want to do in particular.</p>\n<p>Could you describe your situation in more detail?</p>",
        "id": 576091551,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1772129300
    },
    {
        "content": "<p>Sure, I'm doing some processing of (possibly very large) Lean environments, where the input to a computation is the name of a constant in the environment (and the computation takes place in CoreM). At some point the computation becomes recursive on the structure of terms of <code>Lean.Expr</code>, and we need to use the computation for <code>nm</code> when we encounter a <code>Lean.Expr.const nm ..</code>. I would like to do the whole computation with multiple threads to make it sufficiently fast, and I want to cache results.</p>",
        "id": 576092122,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1772129511
    },
    {
        "content": "<p>Right, in that case your key is a name right? names can be efficiently looked up in a TreeMap (use Name.quickCmp as a compare function). That together with a Std.SharedMutex for parallel read access should be pretty good. If its still too slow one could consider things like sharding the cache maybe? But thats thinking a few steps ahead.</p>",
        "id": 576093078,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1772129840
    },
    {
        "content": "<p>Yes, the key is a <code>Lean.Name</code>. I'll try using a TreeMap for now, and if that's too slow I'll look into sharding, or the the idea you mentioned of communicating via a channel.</p>",
        "id": 576093252,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1772129908
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 576093260,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1772129910
    },
    {
        "content": "<p>Unless the computation really heavily hammers the cache the TreeMap vs HashMap difference should not be too noticeable in my experience.</p>",
        "id": 576093718,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1772130059
    }
]