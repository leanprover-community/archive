[
    {
        "content": "<p>Is there a way that I can automatically generate an Equiv between a finite inductive enum with n elements and Fin n? For example :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">c</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">αEquiv</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">λ</span> <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n      <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n      <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span>\n\n  <span class=\"n\">invFun</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">λ</span> <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n      <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">b</span>\n      <span class=\"bp\">|</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">c</span>\n\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">Function.LeftInverse</span>\n    <span class=\"n\">aesop</span>\n\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">Function.RightInverse</span> <span class=\"n\">Function.LeftInverse</span>\n    <span class=\"n\">aesop</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>The goal is to be able to create any finite inductive type and then automatically generate the obvious equivalence so that I can index a vector by meaningful names.</p>\n<p>I would also be open to some other way of indexing a vector by meaningful names, this is just the first idea I came up with to achieve that.</p>",
        "id": 347235978,
        "sender_full_name": "Jesse Slater",
        "timestamp": 1680722232
    },
    {
        "content": "<p>It's not the most efficient approach here, but <a href=\"https://github.com/leanprover-community/mathlib4/pull/3198\">mathlib4#3198</a> has a term elaborator named <code>proxy_equiv%</code> that generates an equivalence between a non-recursive inductive type (like your enum type) and some simple type. There should be enough <code>FinEnum</code> instances in mathlib to use this to derive a likely-not-efficient equivalence to <code>Fin 3</code>.</p>",
        "id": 347237366,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680722707
    },
    {
        "content": "<p>I can also point you to the <code>DecidableEq</code> derive handler <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Deriving/DecEq.lean\">in Lean 4</a>, which for enum types generates the <code>invFun</code> for you. The <code>toFun</code> is already called <code>toCtorIdx</code> and is generated by Lean automatically.</p>",
        "id": 347237648,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680722795
    },
    {
        "content": "<p>That derive handler generates <code>ofNat</code> and <code>ofNat_toCtorIdx</code>, which you can make use of if you add <code>deriving DecidableEq</code> after your inductive type.</p>",
        "id": 347237825,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680722864
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FinEnum#doc\">docs4#FinEnum</a> is the class for precisely this, right? (Though you'd need to implement the instance for it)</p>",
        "id": 347265259,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680734425
    },
    {
        "content": "<p>Why do you need <code>Fin 3</code> at all though if your intent is to index with meaningful names? You can just use <code> α →ℝ</code> directly</p>",
        "id": 347265441,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680734570
    },
    {
        "content": "<p>Thanks, FinEnum looks great. When you say use <code>α →ℝ</code> directly, is the idea to get rid of the vectors entirely?  I might be able to do that, but I am using some vector functions which I don't know how to replace. How would I do <a href=\"http://Vector.map\">Vector.map</a> and Vector.toList if I was working with functions instead of vectors?</p>",
        "id": 347272444,
        "sender_full_name": "Jesse Slater",
        "timestamp": 1680738760
    },
    {
        "content": "<p>What do you mean by \"vector\"? I assumed you mean <code>Fin 3 → ℝ</code>...</p>",
        "id": 347274606,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680740084
    },
    {
        "content": "<p><code>Vector.map</code> is just composition</p>",
        "id": 347274652,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680740115
    },
    {
        "content": "<p><code>toList</code> requires the equivalence you asked for because you need to choose an order for your elements</p>",
        "id": 347274677,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680740139
    },
    {
        "content": "<p>By vector, I mean Mathlib.Data.Vector. I am using vectors of nats. I probably should have made that more clear. It is possible that I could just use <code>Fin n -&gt; Nat</code>, or <code>α -&gt; Nat</code> but this seemed more intuitive to me. The reason I am using vectors is that I am doing entry wise operations with multiple vectors, so I need to make sure they have the same number of elements. <br>\nHere are all of the operations I think I need:</p>\n<p>Entry wise operations on multiple vectors<br>\nAppending vectors together to get longer ones, but maintaining my useful names<br>\nIterating over the elements of a vector, as in foldl</p>\n<p>It is not immediately obvious to me how I would do those using the <code>α -&gt; Nat</code> strategy, but I am sure there is a way.</p>",
        "id": 347556714,
        "sender_full_name": "Jesse Slater",
        "timestamp": 1680836243
    },
    {
        "content": "<p>Aren't most of those operations already implemented over <code>Fin n -&gt; A</code> vectors? It is used for vectors / matrices</p>",
        "id": 347556834,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1680836341
    },
    {
        "content": "<p><code>Mathlib.Data.Vector</code> is not used much in mathlib</p>",
        "id": 347556940,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1680836407
    },
    {
        "content": "<p>Where should I look for the functions for <code>Fin n -&gt; A</code>? My problem is that I am very new to Lean, and everything I know is from reading the books and searching mathlib, so I never know if I am missing something. Mathlib.Data.Vector is just the first thing that came up when I was searching for a vector.</p>",
        "id": 347557732,
        "sender_full_name": "Jesse Slater",
        "timestamp": 1680836848
    },
    {
        "content": "<p>Vector3 is used more IIRC, but it is still being ported in mathlib4 (there is an open PR about it)</p>",
        "id": 347557858,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1680836895
    },
    {
        "content": "<p>it will be easier to peruse the state of things in mathlib3</p>",
        "id": 347557876,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1680836918
    },
    {
        "content": "<p>As a related thing, what about automatically generating Equiv from structures to nested Sigma types?</p>",
        "id": 347567156,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1680842980
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"404479\">@Trebor Huang</span> Take a look at <a href=\"https://github.com/leanprover-community/mathlib4/pull/3198\">mathlib4#3198</a>, which gives a term elaborator (<code>proxy_equiv%</code>) for exactly that.</p>",
        "id": 347569369,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680844116
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Automatically.20generate.20Equiv.20from.20enum.20to.20Fin.20n/near/347265259\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FinEnum#doc\">docs4#FinEnum</a> is the class for precisely this, right? (Though you'd need to implement the instance for it)</p>\n</blockquote>\n<p>That was what I was suggesting with using <code>proxy_equiv%</code> and relying on <code>FinEnum</code> instances, since it'd be a way to implement that instance automatically.</p>\n<p>Just to show what I meant with the other suggestion, I'll post the code here (although it looks like this might not be useful for Jesse).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Logic.Equiv.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.IntervalCases</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.FinEnum</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">c</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">αEquiv</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">α.toCtorIdx</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n  <span class=\"n\">invFun</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">α.ofNat</span> <span class=\"n\">x</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"n\">α.ofNat_toCtorIdx</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n    <span class=\"n\">interval_cases</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">FinEnum</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">card</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n  <span class=\"n\">Equiv</span> <span class=\"o\">:=</span> <span class=\"n\">αEquiv</span>\n</code></pre></div>",
        "id": 347571938,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680845403
    }
]