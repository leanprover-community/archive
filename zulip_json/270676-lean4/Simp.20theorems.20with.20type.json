[
    {
        "content": "<p>Is there some way to efficiently obtain all simp theorems whose equality matches a given type? So for example, <code>simpThmsMatchingType (mkConst `Nat)</code> would return all simp theorems of the form <code>∀ xs..., t₁ = t₂</code> where <code>t₁</code> and <code>t₂</code> are of type <code>Nat</code>. <br>\nI have very little understanding of how the discrimination tree for simp theorems works, so I'm not sure if this question even makes sense.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p><a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a></p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>Perhaps it would also help to <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> here: I'm trying to pass an equality expression and a set of equational lemmas to an external equality saturation solver in hopes of it finding a sequence of rewrites that proves the equality. But as I don't want to pass all of Mathlib's 50000 simp lemmas, I'm trying to prune the set of lemmas first by keeping only those whose type even matches the equality. So, for example, if the goal equality is <code>2 * (x : Nat) = x + x</code>, I don't want to provide simp theorems about <code>Bool</code>.</p>\n</div></div>",
        "id": 404627620,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1701175494
    },
    {
        "content": "<p>I don't think the discrimination tree structure provides much help here unless you know ahead of time all of the constants of type <code>Nat</code>. E.g. the LHS of a simp lemma <code>fib 2 = 1</code> will be keyed by the path <code>[.const `fib, .lit 2]</code></p>",
        "id": 404654142,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1701183709
    }
]