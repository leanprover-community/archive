[
    {
        "content": "<p><code>attachWithImpl</code> is used to implement e.g. <code>Vector.attachWith</code> as a no-op. However, I don't think this works for Vectors of <code>Fin k</code>, because <code>Fin k</code> isn't actually a subtype (even if it is much like one in many ways). I think however <code>Fin k</code> and <code>Nat</code> have the same representation in data, so would it be possible to have a no-op that can send a vector/array/list of <code>Fin k</code> to <code>Nat</code> or vice versa when all the Nat are in range?</p>",
        "id": 562081334,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1764935103
    },
    {
        "content": "<p>I suppose for <code>List</code> it might look like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">List</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inline</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toFinsImpl</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"n\">l</span>\n\n<span class=\"sd\">/-- `O(1)`. \"Attach\" a proof `x &lt; m` that holds for all the elements of `xs` to produce a new list</span>\n<span class=\"sd\">  with the same elements but in the type `Fin m`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">implemented_by</span><span class=\"w\"> </span><span class=\"n\">toFinsImpl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">expose</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toFins</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">pmap</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">H</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">List</span>\n</code></pre></div>",
        "id": 562083085,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1764935679
    },
    {
        "content": "<p>I think actually because e.g. <code>Vector.pmap</code> is proven to be implemented by <code>Vector.pmapImpl</code> you could directly use <code>Vector.pmap</code> to define this for that. But that doesn't work for List I think.</p>",
        "id": 562084409,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1764936076
    },
    {
        "content": "<p>Or - hm. It might do actually because List also has a <code>List.pmapImpl</code>. Just feels oddly circuitous because <code>attachWith</code> is defined using <code>pmap</code>.</p>",
        "id": 562084706,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1764936184
    },
    {
        "content": "<p>I guess the point is that <code>attachWith</code> has an <code>implemented_by</code> but everything else has a <code>csimp</code>, i.e. the connection is proven.</p>",
        "id": 562084804,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1764936210
    },
    {
        "content": "<p>Hmm! But <code>List.pmapImpl</code> uses <code>List.map</code>... so I think it must still be O(n) rather than O(1).</p>",
        "id": 562085205,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1764936336
    },
    {
        "content": "<p>So yeah, not sure there's an O(1) way to move to Fin.</p>",
        "id": 562085256,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1764936354
    },
    {
        "content": "<p>What's your question, and why isn't your code snippet above the answer to it?</p>",
        "id": 562295046,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1765097411
    },
    {
        "content": "<p>I suppose it might be \"is this the right way to do this or is there a better way\"?</p>",
        "id": 562297123,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765099743
    }
]