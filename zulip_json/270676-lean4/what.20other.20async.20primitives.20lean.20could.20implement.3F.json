[
    {
        "content": "<p>I have asked chatgpt</p>\n<div class=\"codehilite\" data-code-language=\"Markdown\"><pre><span></span><code>what other std primitives lean could implement except already implemented\n\nusing std::thread;\nusing std::mutex;\nusing std::recursive_mutex;\nusing std::shared_timed_mutex;\nusing std::atomic;\nusing std::atomic_bool;\nusing std::atomic_ushort;\nusing std::atomic_uint;\nusing std::atomic_uchar;\nusing std::condition_variable;\nusing std::lock_guard;\nusing std::unique_lock;\nusing std::atomic_load;\nusing std::atomic_load_explicit;\nusing std::atomic_fetch_add_explicit;\nusing std::atomic_fetch_sub_explicit;\nusing std::memory_order_relaxed;\nusing std::memory_order_release;\nusing std::memory_order_acquire;\nusing std::memory_order_acq_rel;\nusing std::memory_order_seq_cst;\nusing std::atomic_thread_fence;\n</code></pre></div>\n<p>and he answered</p>\n<div class=\"codehilite\" data-code-language=\"Markdown\"><pre><span></span><code>Nice question! Lean 4’s runtime currently wraps a solid core of C++11 concurrency primitives, as you listed — mostly the essentials for thread creation, locking, atomics, and condition variables.\n\nHere are some <span class=\"gs\">**additional std library concurrency primitives**</span> that Lean <span class=\"ge\">*could*</span> wrap/implement if there was a use case, but currently don’t seem to be exposed explicitly in the runtime:\n<span class=\"k\">*</span><span class=\"w\"> </span>* *\n\n<span class=\"gu\">### Other useful `std` concurrency primitives Lean could consider implementing/wrapping</span>\n\nPrimitive\n\nDescription / Use case\n<span class=\"gs\">**`std::shared_mutex`**</span>\n\nMore modern shared mutex (reader-writer lock) — <span class=\"sb\">`shared_timed_mutex`</span> is older, deprecated since C++17 in favor of <span class=\"sb\">`shared_mutex`</span>. Could update to this.\n<span class=\"gs\">**`std::shared_lock`**</span>\n\nRAII lock for <span class=\"sb\">`shared_mutex`</span> to hold a shared (reader) lock, complements unique_lock for shared mutexes.\n<span class=\"gs\">**`std::future` and `std::promise`**</span>\n\nFor async task/result passing without explicit thread management; Lean’s task system could interop or reimplement with futures.\n<span class=\"gs\">**`std::packaged_task`**</span>\n\nWraps a callable for deferred execution with future results; useful in thread pools and async task scheduling.\n<span class=\"gs\">**`std::jthread`**</span>\n\nC++20 cooperative cancellation-aware thread wrapper (auto joins on destruction), simplifying thread lifecycle.\n<span class=\"gs\">**`std::barrier`**</span>\n\nC++20 synchronization primitive to block threads until a certain point. Useful for complex parallel computations.\n<span class=\"gs\">**`std::latch`**</span>\n\nSimilar to barrier but one-time use, good for thread startup synchronization.\n<span class=\"gs\">**`std::semaphore`**</span>\n\nCounting semaphore to control access to limited resources.\n<span class=\"gs\">**`std::atomic_flag`**</span>\n\nSimple atomic boolean flag, useful for spinlocks or lightweight synchronization.\n<span class=\"gs\">**`std::condition_variable_any`**</span>\n\nMore general condition variable that can work with any BasicLockable (not just std::unique_lockstd::mutex), can improve flexibility.\n<span class=\"gs\">**`std::scoped_lock`**</span>\n\nVariadic RAII lock guard to lock multiple mutexes at once without deadlock risk.\n<span class=\"gs\">**`std::spinlock` (not in std, but often implemented)**</span>\n\nSpinlocks for very low-level synchronization, sometimes used in runtimes.\n<span class=\"gs\">**`std::call_once` and `std::once_flag`**</span>\n\nFor one-time initialization in a thread-safe way (singleton patterns, etc).\n<span class=\"k\">*</span><span class=\"w\"> </span>* *\n\n<span class=\"gu\">### Why Lean might not yet wrap these?</span>\n<span class=\"k\">*</span><span class=\"w\"> </span>The Lean runtime focuses on the <span class=\"gs\">**minimum primitives needed**</span> for their task scheduling and synchronization models.\n\n<span class=\"k\">*</span><span class=\"w\"> </span>Some newer features (like <span class=\"sb\">`std::jthread`</span>, barriers, semaphores) require C++20 and might reduce portability or require updating build toolchains.\n\n<span class=\"k\">*</span><span class=\"w\"> </span>Some constructs like futures/promises might be redundant with Lean’s own <span class=\"sb\">`Task`</span> and async runtime abstractions.\n\n<span class=\"k\">*</span><span class=\"w\"> </span>Others, like <span class=\"sb\">`shared_lock`</span> or <span class=\"sb\">`scoped_lock`</span>, are convenience wrappers but can be implemented on top of existing primitives.\n\n<span class=\"k\">*</span><span class=\"w\"> </span>* *\n\n<span class=\"gu\">### Could Lean benefit from these?</span>\n<span class=\"k\">*</span><span class=\"w\"> </span>Possibly — especially things like <span class=\"sb\">`shared_lock`</span>, <span class=\"sb\">`scoped_lock`</span>, or <span class=\"sb\">`call_once`</span> could clean up code and improve correctness.\n\n<span class=\"k\">*</span><span class=\"w\"> </span>Semaphores and barriers would help if Lean runtime adds more complex thread coordination.\n\n<span class=\"k\">*</span><span class=\"w\"> </span><span class=\"sb\">`jthread`</span> could simplify thread lifetime management.\n\n<span class=\"k\">*</span><span class=\"w\"> </span>Using <span class=\"sb\">`condition_variable_any`</span> would allow waiting on custom mutex types or locks.\n\n<span class=\"k\">*</span><span class=\"w\"> </span>* *\n\n<span class=\"gu\">### TL;DR</span>\n\nLean currently wraps core primitives (threads, mutexes, condition variables, atomics, locks). It could also add support for:\n<span class=\"k\">*</span><span class=\"w\"> </span>Shared locks: <span class=\"sb\">`std::shared_mutex`</span>, <span class=\"sb\">`std::shared_lock`</span>\n\n<span class=\"k\">*</span><span class=\"w\"> </span>More advanced synchronization: <span class=\"sb\">`std::barrier`</span>, <span class=\"sb\">`std::latch`</span>, <span class=\"sb\">`std::semaphore`</span>\n\n<span class=\"k\">*</span><span class=\"w\"> </span>Thread lifetime helpers: <span class=\"sb\">`std::jthread`</span>, <span class=\"sb\">`std::call_once`</span>\n\n<span class=\"k\">*</span><span class=\"w\"> </span>Concurrency abstractions: <span class=\"sb\">`std::future`</span>, <span class=\"sb\">`std::promise`</span>\n</code></pre></div>\n<p>Q: How lean async api will evolve? will <code> `std::future`/`std::promise` </code> be added?</p>",
        "id": 532696143,
        "sender_full_name": "Serhii Khoma (srghma)",
        "timestamp": 1754303013
    },
    {
        "content": "<p>Please don't dump random llm slop in here</p>",
        "id": 532701994,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1754304985
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> </p>\n<p>I asked a question:</p>\n<ol>\n<li>How lean async api will evolve? </li>\n<li>will  <code>std::future</code>/<code>std::promise</code>  be added?</li>\n<li>what else can be added / improved in lean async api?</li>\n</ol>",
        "id": 532708417,
        "sender_full_name": "Serhii Khoma (srghma)",
        "timestamp": 1754307411
    },
    {
        "content": "<p>We actually did quite a bit of work on async primitives this year. Besides <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Task#doc\">docs#Task</a> (which is like <code>std::future</code>) and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IO.Promise#doc\">docs#IO.Promise</a> (which is like <code>std::promise</code>) which have been around for a long time, there are many new things that were added this year: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Barrier#doc\">docs#Std.Barrier</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Channel#doc\">docs#Std.Channel</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Mutex#doc\">docs#Std.Mutex</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.RecursiveMutex#doc\">docs#Std.RecursiveMutex</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.SharedMutex#doc\">docs#Std.SharedMutex</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Internal.Async.Selectable#doc\">docs#Std.Internal.Async.Selectable</a> and probably more that I'm forgetting right now. At the moment we're looking more at hardening the existing APIs and don't have anything new on our immediate roadmap, but if you have a use case that is not covered by the existing API, you should let us know.</p>",
        "id": 532711135,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1754308369
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> I don't have an immediate need, but I've occasionally wanted async IO.</p>\n<p>Is this being built with <code>libuv</code> (or another async library) compatibility in mind?</p>",
        "id": 532756633,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1754323345
    },
    {
        "content": "<p>It's built with <code>libuv</code> :-) See <a href=\"https://github.com/leanprover/lean4/tree/master/src/Std/Internal/UV\">https://github.com/leanprover/lean4/tree/master/src/Std/Internal/UV</a></p>",
        "id": 532761297,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754325097
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> </p>\n<p>Tokio has different flavours of Channels:</p>\n<ol>\n<li><em>mpsc</em>: multi-producer, single-consumer channel. Many values can be sent.</li>\n<li><em>oneshot</em>: single-producer, single consumer channel. A single value can be sent.</li>\n<li><em>broadcast</em>: multi-producer, multi-consumer. Many values can be sent. Each receiver sees every value.</li>\n<li><em>watch</em>: multi-producer, multi-consumer. Many values can be sent, but no history is kept. Receivers only see the most recent value.</li>\n</ol>\n<p>And in lean?</p>\n<p>how to create them? If already possible - then which flavour should be used (unbounded, zero, bounded)?</p>\n<ol>\n<li>multi-producer, single-consumer channel.</li>\n<li>single-producer, single consumer channel.</li>\n<li>multi-producer, multi-consumer, with history</li>\n<li>multi-producer, multi-consumer, without history</li>\n</ol>",
        "id": 532815338,
        "sender_full_name": "Serhii Khoma (srghma)",
        "timestamp": 1754354599
    },
    {
        "content": "<p>If you want a Rust analogy, Lean channels work like <code>crossbeam</code>/<code>async_channel</code> channels, not like Tokio channels.  You can create one using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Channel.new#doc\">docs#Std.Channel.new</a>.</p>",
        "id": 532833942,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1754369668
    }
]