[
    {
        "content": "<p>I have this lemma  I want to use that involves a <code>Finset.sdiff</code> of natural numbers. I'm running into the issue that it automatically uses that constructive Nat equality decidability instance. Is there some magic incantation I can write to make sure it uses the classical instance?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.NumberTheory.ArithmeticFunction</span>\n<span class=\"kn\">open</span> <span class=\"n\">Classical</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Classical</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">prod_compl_factors</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">Squarefree</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">⊆</span> <span class=\"n\">n.factors.toFinset</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∏</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">n.factors.toFinset</span> <span class=\"bp\">\\</span> <span class=\"n\">t</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 373989631,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1689000921
    },
    {
        "content": "<p>Normally, you should let Lean use the decidability instance it likes. Why is it an issue for you if it uses the Nat one?</p>",
        "id": 373992767,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1689001444
    },
    {
        "content": "<p>I'm using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.prod_add#doc\">docs#Finset.prod_add</a>, which holds in more generality and hence uses the classical instance, and I can't make the two results fit together because of the different instances. Specifically, the only difference between those two expressions at the end are decidibility instances, as far as I can tell.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.NumberTheory.ArithmeticFunction</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Nat.ArithmeticFunction</span> <span class=\"n\">Classical</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">BigOperators</span> <span class=\"n\">Classical</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">divisors_filter_squarefree_of_squarefree</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">Squarefree</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">n.divisors.filter</span> <span class=\"n\">Squarefree</span> <span class=\"bp\">=</span> <span class=\"n\">n.divisors</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">prod_subset_factors_of_mult</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat.ArithmeticFunction</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_mult</span> <span class=\"o\">:</span> <span class=\"n\">Nat.ArithmeticFunction.IsMultiplicative</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">⊆</span> <span class=\"n\">l.factors.toFinset</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∏</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"k\">in</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">prod_compl_factors</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">Squarefree</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">⊆</span> <span class=\"n\">n.factors.toFinset</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∏</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">n.factors.toFinset</span> <span class=\"bp\">\\</span> <span class=\"n\">t</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mul_eq_mul</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">b</span><span class=\"bp\">=</span><span class=\"n\">c</span><span class=\"bp\">*</span><span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h0</span><span class=\"o\">,</span> <span class=\"n\">h1</span><span class=\"o\">]</span>\n\n<span class=\"c1\">--Nat.sum_divisors_filter_squarefree</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">prod_add_mult'</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Nat.ArithmeticFunction</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">IsMultiplicative</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">IsMultiplicative</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">Squarefree</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∏</span> <span class=\"n\">p</span> <span class=\"k\">in</span> <span class=\"n\">n.factors.toFinset</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">p</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finset.prod_add</span><span class=\"o\">,</span> <span class=\"n\">mul_apply</span><span class=\"o\">,</span> <span class=\"n\">Nat.sum_divisorsAntidiagonal</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"n\">y</span><span class=\"o\">),</span>\n    <span class=\"bp\">←</span><span class=\"n\">divisors_filter_squarefree_of_squarefree</span> <span class=\"n\">_</span> <span class=\"n\">hn</span><span class=\"o\">,</span> <span class=\"n\">Nat.sum_divisors_filter_squarefree</span> <span class=\"bp\">$</span> <span class=\"n\">Squarefree.ne_zero</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n    <span class=\"n\">Nat.factors_eq</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Finset.sum_congr</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">intro</span> <span class=\"n\">t</span> <span class=\"n\">ht</span>\n  <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">Finset.prod_val</span><span class=\"o\">]</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">_root_.id</span>\n  <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">prod_compl_factors</span> <span class=\"n\">hn</span> <span class=\"o\">(</span><span class=\"n\">Finset.mem_powerset.mp</span> <span class=\"n\">ht</span><span class=\"o\">),</span>\n    <span class=\"n\">prod_subset_factors_of_mult</span> <span class=\"n\">_</span> <span class=\"n\">hf</span> <span class=\"n\">n</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">Finset.mem_powerset.mp</span> <span class=\"n\">ht</span><span class=\"o\">),</span>\n    <span class=\"bp\">←</span><span class=\"n\">prod_subset_factors_of_mult</span> <span class=\"n\">_</span> <span class=\"n\">hg</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">\\</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Finset.sdiff_subset</span> <span class=\"n\">_</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">]</span>\n\n  <span class=\"n\">apply</span> <span class=\"n\">mul_eq_mul</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Finset.prod_congr</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  type mismatch</span>\n<span class=\"cm\">    HEq.rfl</span>\n<span class=\"cm\">  has type</span>\n<span class=\"cm\">    HEq ?m.6889 ?m.6889 : Prop</span>\n<span class=\"cm\">  but is expected to have type</span>\n<span class=\"cm\">    List.toFinset (Nat.factors n) \\ t = List.toFinset (Nat.factors n) \\ t : Prop</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 373996695,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1689002134
    },
    {
        "content": "<p>That means <code>Finset.prod_add</code> is miswritten. It should be about any decidability instance, not just the classical one.</p>",
        "id": 374012763,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1689005010
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.prod_add#doc\">docs#Finset.prod_add</a></p>",
        "id": 374014133,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1689005244
    },
    {
        "content": "<p>Yeah Yaël is right. If you look at the source then there's an <code>open Classical</code> just before it</p>",
        "id": 374015016,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1689005442
    },
    {
        "content": "<p>There was a time when the community had not properly understood how to handle these sorts of issues and perhaps this is left over from that time.</p>",
        "id": 374015200,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1689005493
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/5798\">#5798</a></p>",
        "id": 374044412,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1689012017
    },
    {
        "content": "<p>This'll have to wait until after the port</p>",
        "id": 374044517,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1689012039
    }
]