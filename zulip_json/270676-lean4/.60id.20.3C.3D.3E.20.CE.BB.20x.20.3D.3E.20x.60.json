[
    {
        "content": "<p>I have a proof I want to apply Function.left_id and Function.right_id in. Those take an <code>id</code> instead of a <code>λ x =&gt; x </code>, which is what occurs in my term, however, <code>simp Function.left_id</code> doesn't succeed, I have to explicitly rewrite with an self-defined <code>id_def</code>. I feel like this should have occurred elsewhere already, what am I doing wrong? (i.e. where to find the equivalent of <code>id_def</code>, perhaps?)</p>",
        "id": 386365746,
        "sender_full_name": "MangoIV",
        "timestamp": 1692616649
    },
    {
        "content": "<p>Could you post a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> of your proof?</p>",
        "id": 386367034,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1692617161
    },
    {
        "content": "<p>it basically immediately comes up when starting to proof this <br>\n<a href=\"https://git.sr.ht/~mangoiv/leff/tree/4945e83c0d40965f3c756e8271c6cdaaffd448aa/item/src/Leff/Control/Algebra.lean#L47\">https://git.sr.ht/~mangoiv/leff/tree/4945e83c0d40965f3c756e8271c6cdaaffd448aa/item/src/Leff/Control/Algebra.lean#L47</a></p>\n<p>i.e. intro alpha k x,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span>\n          <span class=\"o\">[</span> <span class=\"n\">Functor.Comp.mk</span>\n          <span class=\"o\">,</span> <span class=\"n\">Functor.Comp.run</span>\n          <span class=\"o\">,</span> <span class=\"n\">funext</span> <span class=\"n\">id_map'</span>\n          <span class=\"o\">]</span>\n<span class=\"bp\">```</span> <span class=\"n\">and</span> <span class=\"n\">you</span> <span class=\"n\">should</span> <span class=\"n\">see</span> <span class=\"n\">the</span> <span class=\"n\">goal</span> <span class=\"n\">didn't</span> <span class=\"n\">simplify</span> <span class=\"n\">the</span> <span class=\"bp\">`</span><span class=\"n\">lambda</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span><span class=\"bp\">`</span>\n<span class=\"n\">when</span> <span class=\"n\">trying</span>\n</code></pre></div>\n<div class=\"codehilite\"><pre><span></span><code>    simp\n      [ Function.left_id\n      , Function.right_id\n      ]\n</code></pre></div>\n\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">I</span> <span class=\"k\">have</span> <span class=\"n\">to</span> <span class=\"bp\">`</span><span class=\"n\">repeat</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">id_def</span><span class=\"o\">]</span><span class=\"bp\">`</span> <span class=\"n\">which</span> <span class=\"n\">is</span> <span class=\"n\">rather</span> <span class=\"n\">ugly</span>\n</code></pre></div>",
        "id": 386367614,
        "sender_full_name": "MangoIV",
        "timestamp": 1692617396
    },
    {
        "content": "<p>what I gather from my experiements is that lean4 agressively dislikes pointfree style, eh</p>",
        "id": 386369049,
        "sender_full_name": "MangoIV",
        "timestamp": 1692617912
    },
    {
        "content": "<p>Could you post a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ?</p>",
        "id": 386374834,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1692619984
    },
    {
        "content": "<p>I'm very sorry, I'm new to lean and I some things around tactics are very magic to me, I don't quite know how to get a minimal example as described on the page, I hope this <code>diff</code> is more helpful: </p>\n<p><a href=\"https://git.sr.ht/~mangoiv/leff/commit/04b4b32641a366fe3bcb79b6eaf7d37e1909c2a4\">https://git.sr.ht/~mangoiv/leff/commit/04b4b32641a366fe3bcb79b6eaf7d37e1909c2a4</a></p>",
        "id": 386377695,
        "sender_full_name": "MangoIV",
        "timestamp": 1692620936
    },
    {
        "content": "<p>afaiu, it is even the case that as soon as I import <code>Mathlib.Init.Function</code>, I should be able to get away with the <code>simp</code>.</p>",
        "id": 386377951,
        "sender_full_name": "MangoIV",
        "timestamp": 1692621017
    },
    {
        "content": "<p>Basically it's much easier to help other people if they say \"just cut and paste this code and you can see my problem\" than if they start asking questions about code which nobody else can run without putting in some effort and clicking on links etc</p>",
        "id": 386378186,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1692621120
    },
    {
        "content": "<p>This file is reasonably minimal, and you can just cut-and-paste it here<br>\n<span class=\"user-mention silent\" data-user-id=\"586938\">MangoIV</span> <a href=\"#narrow/stream/270676-lean4/topic/.60id.20.3C.3D.3E.20.CE.BB.20x.20.3D.3E.20x.60/near/386367614\">said</a>:</p>\n<blockquote>\n<p>it basically immediately comes up when starting to proof this <br>\n<a href=\"https://git.sr.ht/~mangoiv/leff/tree/4945e83c0d40965f3c756e8271c6cdaaffd448aa/item/src/Leff/Control/Algebra.lean#L47\">https://git.sr.ht/~mangoiv/leff/tree/4945e83c0d40965f3c756e8271c6cdaaffd448aa/item/src/Leff/Control/Algebra.lean#L47</a></p>\n</blockquote>",
        "id": 386378541,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1692621235
    },
    {
        "content": "<p>Here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Control.Functor</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Find</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Handler</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  A Handler takes in a context σ, an action m, and returns an action in n.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Handler</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">handler</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"n\">distrib_pure</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">handler</span> <span class=\"n\">α</span> <span class=\"bp\">∘</span> <span class=\"n\">Functor.map</span> <span class=\"n\">pure</span> <span class=\"bp\">=</span> <span class=\"n\">pure</span>\n  <span class=\"n\">distrib_bind</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">handler</span> <span class=\"n\">α</span> <span class=\"bp\">∘</span> <span class=\"n\">Functor.map</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">=&lt;&lt;</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">handler</span> <span class=\"n\">α</span> <span class=\"bp\">∘</span> <span class=\"n\">Functor.map</span> <span class=\"n\">k</span> <span class=\"bp\">&lt;=&lt;</span> <span class=\"n\">handler</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">instance</span>\n  <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">n</span><span class=\"o\">]</span>\n  <span class=\"o\">:</span> <span class=\"n\">CoeFun</span> <span class=\"o\">(</span><span class=\"n\">Handler</span> <span class=\"n\">σ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n    <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">Handler.handler</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  composition of handlers</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">comp</span>\n  <span class=\"o\">{</span><span class=\"n\">σ₁</span> <span class=\"n\">σ₂</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">σ₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">σ₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">l</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">LawfulFunctor</span> <span class=\"n\">σ₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LawfulFunctor</span> <span class=\"n\">σ₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LawfulMonad</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LawfulMonad</span> <span class=\"n\">l</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">handler₁</span> <span class=\"o\">:</span> <span class=\"n\">Handler</span> <span class=\"n\">σ₁</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">handler₂</span> <span class=\"o\">:</span> <span class=\"n\">Handler</span> <span class=\"n\">σ₂</span> <span class=\"n\">l</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Handler</span> <span class=\"o\">(</span><span class=\"n\">Functor.Comp</span> <span class=\"n\">σ₁</span> <span class=\"n\">σ₂</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">handler</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">Functor.map</span> <span class=\"n\">Functor.Comp.mk</span> <span class=\"bp\">∘</span> <span class=\"n\">handler₁</span> <span class=\"o\">(</span><span class=\"n\">σ₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">Functor.map</span> <span class=\"o\">(</span><span class=\"n\">handler₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">Functor.Comp.run</span>\n      <span class=\"n\">distrib_pure</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">intro</span> <span class=\"n\">α</span>\n        <span class=\"n\">funext</span> <span class=\"n\">p</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span>\n          <span class=\"o\">[</span> <span class=\"n\">Functor.Comp.mk</span>\n          <span class=\"o\">,</span> <span class=\"n\">Functor.Comp.run</span>\n          <span class=\"o\">,</span> <span class=\"n\">Function.comp_apply</span>\n          <span class=\"o\">,</span> <span class=\"n\">id_map'</span>\n          <span class=\"o\">]</span>\n        <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:=</span> <span class=\"n\">congrFun</span> <span class=\"o\">(</span><span class=\"n\">handler₁.distrib_pure</span> <span class=\"o\">(</span><span class=\"n\">σ₂</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n        <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:=</span> <span class=\"n\">congrFun</span> <span class=\"o\">(</span><span class=\"n\">handler₂.distrib_pure</span> <span class=\"o\">(</span><span class=\"n\">Functor.Comp</span> <span class=\"n\">σ₁</span> <span class=\"n\">σ₂</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span> <span class=\"n\">Function.comp</span> <span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span> <span class=\"n\">Function.comp</span> <span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₂</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span> <span class=\"bp\">←</span> <span class=\"n\">h₁</span> <span class=\"o\">]</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span> <span class=\"bp\">←</span> <span class=\"n\">handler₂.distrib_pure</span> <span class=\"o\">]</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span> <span class=\"n\">LawfulFunctor.comp_map</span> <span class=\"o\">]</span>\n        <span class=\"n\">rfl</span>\n\n      <span class=\"n\">distrib_bind</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"o\">}</span>\n\n<span class=\"kd\">@[inherit_doc]</span> <span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">90</span> <span class=\"s2\">\" ∘ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">comp</span>\n\n\n<span class=\"kd\">end</span> <span class=\"n\">Handler</span>\n</code></pre></div>",
        "id": 386378671,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1692621274
    },
    {
        "content": "<p>yes, here is also the more up to date link as well as file: <br>\n<a href=\"https://git.sr.ht/~mangoiv/leff/tree/04b4b32641a366fe3bcb79b6eaf7d37e1909c2a4/item/src/Leff/Control/Algebra.lean\">https://git.sr.ht/~mangoiv/leff/tree/04b4b32641a366fe3bcb79b6eaf7d37e1909c2a4/item/src/Leff/Control/Algebra.lean</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Control.Functor</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Find</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Init.Function</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Handler</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  A Handler takes in a context σ, an action m, and returns an action in n.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Handler</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">handler</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"n\">distrib_pure</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">handler</span> <span class=\"n\">α</span> <span class=\"bp\">∘</span> <span class=\"n\">Functor.map</span> <span class=\"n\">pure</span> <span class=\"bp\">=</span> <span class=\"n\">pure</span>\n  <span class=\"n\">distrib_bind</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">handler</span> <span class=\"n\">α</span> <span class=\"bp\">∘</span> <span class=\"n\">Functor.map</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">=&lt;&lt;</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">handler</span> <span class=\"n\">α</span> <span class=\"bp\">∘</span> <span class=\"n\">Functor.map</span> <span class=\"n\">k</span> <span class=\"bp\">&lt;=&lt;</span> <span class=\"n\">handler</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">instance</span>\n  <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">n</span><span class=\"o\">]</span>\n  <span class=\"o\">:</span> <span class=\"n\">CoeFun</span> <span class=\"o\">(</span><span class=\"n\">Handler</span> <span class=\"n\">σ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n    <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">Handler.handler</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  composition of handlers</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">comp</span>\n  <span class=\"o\">{</span><span class=\"n\">σ₁</span> <span class=\"n\">σ₂</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">σ₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">σ₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">l</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">LawfulFunctor</span> <span class=\"n\">σ₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LawfulFunctor</span> <span class=\"n\">σ₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LawfulMonad</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LawfulMonad</span> <span class=\"n\">l</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">handler₁</span> <span class=\"o\">:</span> <span class=\"n\">Handler</span> <span class=\"n\">σ₁</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">handler₂</span> <span class=\"o\">:</span> <span class=\"n\">Handler</span> <span class=\"n\">σ₂</span> <span class=\"n\">l</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Handler</span> <span class=\"o\">(</span><span class=\"n\">Functor.Comp</span> <span class=\"n\">σ₁</span> <span class=\"n\">σ₂</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">handler</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">Functor.map</span> <span class=\"n\">Functor.Comp.mk</span> <span class=\"bp\">∘</span> <span class=\"n\">handler₁</span> <span class=\"o\">(</span><span class=\"n\">σ₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">Functor.map</span> <span class=\"o\">(</span><span class=\"n\">handler₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">Functor.Comp.run</span>\n      <span class=\"n\">distrib_pure</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">intro</span> <span class=\"n\">α</span>\n        <span class=\"n\">funext</span> <span class=\"n\">p</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span>\n          <span class=\"o\">[</span> <span class=\"n\">Functor.Comp.mk</span>\n          <span class=\"o\">,</span> <span class=\"n\">Functor.Comp.run</span>\n          <span class=\"o\">,</span> <span class=\"n\">Function.comp_apply</span>\n          <span class=\"o\">,</span> <span class=\"n\">id_map'</span>\n          <span class=\"o\">]</span>\n        <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:=</span> <span class=\"n\">congrFun</span> <span class=\"o\">(</span><span class=\"n\">handler₁.distrib_pure</span> <span class=\"o\">(</span><span class=\"n\">σ₂</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n        <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:=</span> <span class=\"n\">congrFun</span> <span class=\"o\">(</span><span class=\"n\">handler₂.distrib_pure</span> <span class=\"o\">(</span><span class=\"n\">Functor.Comp</span> <span class=\"n\">σ₁</span> <span class=\"n\">σ₂</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span> <span class=\"n\">Function.comp</span> <span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span> <span class=\"n\">Function.comp</span> <span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₂</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span> <span class=\"bp\">←</span> <span class=\"n\">h₁</span> <span class=\"o\">]</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span> <span class=\"bp\">←</span> <span class=\"n\">handler₂.distrib_pure</span> <span class=\"o\">]</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span> <span class=\"n\">LawfulFunctor.comp_map</span> <span class=\"o\">]</span>\n        <span class=\"n\">rfl</span>\n\n      <span class=\"n\">distrib_bind</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">intro</span> <span class=\"n\">α</span> <span class=\"n\">k</span>\n        <span class=\"k\">have</span> <span class=\"n\">id_def</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n        <span class=\"c1\">-- if I remove this ^</span>\n        <span class=\"n\">simp</span>\n          <span class=\"o\">[</span> <span class=\"n\">Functor.Comp.mk</span>\n          <span class=\"o\">,</span> <span class=\"n\">Functor.Comp.run</span>\n          <span class=\"o\">,</span> <span class=\"n\">funext</span> <span class=\"n\">id_map'</span>\n          <span class=\"o\">]</span>\n        <span class=\"n\">repeat</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">id_def</span><span class=\"o\">]</span>\n        <span class=\"c1\">-- and this ^</span>\n        <span class=\"n\">simp</span>\n          <span class=\"o\">[</span> <span class=\"n\">Function.left_id</span>\n          <span class=\"o\">,</span> <span class=\"n\">Function.right_id</span>\n          <span class=\"o\">]</span>\n        <span class=\"c1\">-- I cannot apply those ^</span>\n        <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:=</span> <span class=\"n\">handler₁.distrib_bind</span> <span class=\"o\">(</span><span class=\"n\">σ₂</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n        <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:=</span> <span class=\"n\">handler₂.distrib_bind</span> <span class=\"o\">(</span><span class=\"n\">Functor.Comp</span> <span class=\"n\">σ₁</span> <span class=\"n\">σ₂</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span> <span class=\"n\">Function.comp</span> <span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span> <span class=\"n\">Function.comp</span> <span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₂</span>\n        <span class=\"gr\">sorry</span>\n    <span class=\"o\">}</span>\n\n<span class=\"kd\">@[inherit_doc]</span> <span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">90</span> <span class=\"s2\">\" ∘ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">comp</span>\n\n\n<span class=\"kd\">end</span> <span class=\"n\">Handler</span>\n</code></pre></div>",
        "id": 386378957,
        "sender_full_name": "MangoIV",
        "timestamp": 1692621369
    },
    {
        "content": "<p>Regarding point-free: you'll find you run into \"impedance mismatches\" when you go back and forth between different ways of expressing something using different \"languages\" (in this case point-free versus applied functions). Many times what you want is versions of lemmas in both styles so you can stick to a particular language.</p>\n<p>There's even a metaprogram in <code>Mathlib.Tactic.HigherOrder</code> that tries to derive a point-free version of a lemma from the applied version, in some simple cases.</p>",
        "id": 386379514,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1692621554
    },
    {
        "content": "<p>For category theory, there's another metaprogram in <code>Mathlib.Tactic.CategoryTheory.Elementwise</code> that takes \"point-free\" lemmas (i.e., ones about compositions of morphisms) and creates the applied version of a lemma when you have a concrete category.</p>",
        "id": 386379761,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1692621634
    },
    {
        "content": "<p>wow, that's really cool, I will have a look at those! Sounds like a tactic that can do <code>pointfree.io</code> :D</p>",
        "id": 386379836,
        "sender_full_name": "MangoIV",
        "timestamp": 1692621655
    },
    {
        "content": "<p>They're very simple though -- <code>@[higher_order]</code> just handles <code>f1 (f2 ... (fn x))</code>, and <code>@[elementwise]</code> just applies both sides and uses some simp lemmas.</p>\n<p>I've wondered about a <code>pointfree.io</code> metaprogram though! It could be useful for things like \"given this lambda expression, prove it's a continuous function\" or \"given this lambda expression on objects of a category, derive a functor that extends it\"</p>",
        "id": 386380631,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1692621910
    },
    {
        "content": "<p>Way long ago, before category theory even came to mathlib, I wrote at macro for <code>ƛ</code> that let you define a functor using lambda notation, just very aggressively using <code>tidy</code> and <code>solve_by_elim</code> to try to prove functoriality. It didn't scale at all, but I'd love to see this done properly! :-)</p>",
        "id": 386382614,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1692622403
    },
    {
        "content": "<p><code>ƛ</code> is an awesome unicode character for \"like a lambda pure function, but better\" that I really hope is claimed for such a metaprogram. I guess a pity that we've mostly abandoned <code>\\lambda</code>.</p>",
        "id": 386384396,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1692622833
    }
]