[
    {
        "content": "<p>Hi all, I'm following <a href=\"https://arxiv.org/pdf/2404.16321\">this paper</a> and I'd like to run the examples at the end, so I'm taking a stab at implementing free monads and cofree comonads. I'm using the <a href=\"https://github.com/ToposInstitute/lean-poly\">code here for polynomial functors</a>, but the gist of it is this: polynomial functors are sigma types:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Poly</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"n\">dir</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span>\n</code></pre></div>\n<p>and the free monad is defined for all natural numbers and limit ordinals. <br>\n<a href=\"/user_uploads/3121/EIfruMoGD5vZ3Bxeu0LA2rnS/Sk&auml;rmavbild-2024-07-26-kl.-22.43.28.png\">Sk&auml;rmavbild-2024-07-26-kl.-22.43.28.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/EIfruMoGD5vZ3Bxeu0LA2rnS/Sk&auml;rmavbild-2024-07-26-kl.-22.43.28.png\" title=\"Sk&auml;rmavbild-2024-07-26-kl.-22.43.28.png\"><img data-original-dimensions=\"803x747\" src=\"/user_uploads/thumbnail/3121/EIfruMoGD5vZ3Bxeu0LA2rnS/Sk&auml;rmavbild-2024-07-26-kl.-22.43.28.png/840x560.webp\"></a></div><p>I'm stuck on all avenues I tried to implement this.</p>\n<p>First I don't know how to represent limit ordinals or how to pattern match on them, or to get the cardinality of the direction sets (the target types of the field <code>dir</code>), which stops me here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Free monad</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">p_aux</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">&naturals;</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Poly</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Poly</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">◁</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p_aux</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"c1\">--| &omega; =&gt; colim (a' &lt; a) p -- I could figure out how to compute limits of p as a functor later</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">&naturals;</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Poly</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p_aux</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&xrarr;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p_aux</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">onPos</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">&lambda;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&mapsto;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">onDir</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">&lambda;</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&mapsto;</span><span class=\"w\"> </span><span class=\"o\">()}</span><span class=\"w\"> </span><span class=\"c1\">-- y &xrarr; y + p</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">coproduct</span><span class=\"bp\">.</span><span class=\"n\">whiskerLeft</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">subst</span><span class=\"bp\">.</span><span class=\"n\">whiskerLeft</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">))</span><span class=\"w\">   </span><span class=\"c1\">-- y + p ◁ (p_aux n p) &xrarr; y + p ◁ (p_aux (1 + n) p)</span>\n<span class=\"c1\">--| &omega; =&gt;  forall a &lt; &omega;, this is the \"natural inclusion\" -- no idea how to do thhis</span>\n\n<span class=\"c1\">-- Remark A.2. A polynomial  : Poly is &kappa;-small if and only if all of its direction-sets have cardinality</span>\n<span class=\"c1\">-- less than &kappa;. It is called finitary if and only if it is &omega;-small.</span>\n<span class=\"c1\">-- Here I could _assume_ that p is finitary, i.e. all its direction sets are finite, but then</span>\n<span class=\"c1\">-- how do I \"iterate\" over all positions to get their cardinality?</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">smallness</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Poly</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">&naturals;</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">10</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">freeMonad</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Poly</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Poly</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p_aux</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">smallness</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div>\n<p>The same goes for the cofree comonad.</p>\n<p>Second, I tried to do it in a na&iuml;ve way, which is just writing down their recursive expressions, which would require the <code>partial</code> keyword:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">free2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Poly</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Poly</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">free2</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div>\n<p>But this complains that </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">compile</span><span class=\"w\"> </span><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"n\">definition</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Poly</span><span class=\"bp\">.</span><span class=\"n\">free2'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">inhabited</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">non</span><span class=\"w\"> </span><span class=\"n\">empty</span>\n</code></pre></div>\n<p>Which is fair enough, because we'd be able to prove <code>False</code> otherwise. But which type needs the instance <code>[Inhabited]</code>? I've tried giving it to p, Poly, y, basically everything that is mentioned in the body:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">free2</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">Poly</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Poly</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Poly</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">   </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">free2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"n\">p</span>\n</code></pre></div>\n<p>but nothing works.</p>\n<p>Third, I tried to copy <a href=\"https://stackoverflow.com/questions/78274957/how-to-define-free-monads-and-cofree-comonads-in-lean4\">this solution on my question in stackoverflow</a>, but I'd need the inductive definition to produce a <code>Poly</code>, not a <code>Type</code>, so that doesn't help me.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Free</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Poly</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">&alpha;</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"c1\">-- Free p should be of type Poly, not Type -&gt; Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">&alpha;</span><span class=\"w\"> </span><span class=\"bp\">&rarr;</span><span class=\"w\"> </span><span class=\"n\">Free</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">&alpha;</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">free</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">&forall;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">applyFunctor</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Free</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">&alpha;</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&rarr;</span><span class=\"w\"> </span><span class=\"n\">Free</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">&alpha;</span><span class=\"w\"> </span><span class=\"c1\">-- applyFunctor : Poly -&gt; Type -&gt; Type</span>\n</code></pre></div>\n<p>Help please?</p>",
        "id": 454371440,
        "sender_full_name": "André Muricy Santos",
        "timestamp": 1722026976
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 454372248,
        "sender_full_name": "André Muricy Santos",
        "timestamp": 1722027393
    },
    {
        "content": "<p>Feel free to correct me if I am wrong, but I believe it is the return type of a partial function which needs to be inhabited, hence the error message you're seeing. If I had to guess at a solution, perhaps try actually writing an instance for <code>Poly</code> instead of just adding it as a parameter?</p>",
        "id": 462162748,
        "sender_full_name": "Malcolm Langfield",
        "timestamp": 1723567612
    },
    {
        "content": "<p>I actually fixed the compilation error by writing a different expression on the body of free2 which is just as recursive, but Lean won't reduce a partial expression no matter what it seems, so I can never pattern match on a value of this type :(</p>",
        "id": 462528880,
        "sender_full_name": "André Muricy Santos",
        "timestamp": 1723720446
    },
    {
        "content": "<p>Yes, also you'll never be able to unfold such a definition, which makes it somewhat useless for reasoning <span aria-label=\"woman shrugging\" class=\"emoji emoji-1f937-200d-2640\" role=\"img\" title=\"woman shrugging\">:woman_shrugging:</span></p>",
        "id": 462567343,
        "sender_full_name": "Malcolm Langfield",
        "timestamp": 1723733543
    }
]