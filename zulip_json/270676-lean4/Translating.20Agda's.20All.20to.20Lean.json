[
    {
        "content": "<p><a href=\"/user_uploads/3121/jAKFiLkdIWwdchsBQW2LBnxI/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/jAKFiLkdIWwdchsBQW2LBnxI/image.png\" title=\"image.png\"><img data-original-dimensions=\"769x138\" src=\"/user_uploads/thumbnail/3121/jAKFiLkdIWwdchsBQW2LBnxI/image.png/840x560.webp\"></a></div><p>Would you say the following Lean definition is the correct translation of the Agda type above?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">All</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mkAll</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">list</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">All</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">mkAll</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">All</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I was trying to otherwise think whether there was some way to pattern match during an inductive definition. Or maybe there is a more idiomatic translation (that is nevertheless non-Prop)? I want to keep it as a non-Prop type to be able to use it to construct other types.</p>",
        "id": 476885783,
        "sender_full_name": "nrs",
        "timestamp": 1728962023
    },
    {
        "content": "<p>I would rather expect something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">All</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">All</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">All</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">All</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">All</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\">  </span><span class=\"c1\">-- @All.nil : {I : Type} → {P : I → Type} → All P []</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">All</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"c1\">-- @All.cons : {I : Type} → {P : I → Type} → {i : I} → {xs : List I} → P i → All P xs → All P (i :: xs)</span>\n</code></pre></div>",
        "id": 476891675,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1728964591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/270676-lean4/topic/Translating.20Agda's.20All.20to.20Lean/near/476891675\">said</a>:</p>\n<blockquote>\n<p>I would rather expect something like</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">All</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">All</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">All</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">All</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">All</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\">  </span><span class=\"c1\">-- @All.nil : {I : Type} → {P : I → Type} → All P []</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">All</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"c1\">-- @All.cons : {I : Type} → {P : I → Type} → {i : I} → {xs : List I} → P i → All P xs → All P (i :: xs)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Very cool I have never seen this!! <code>{i xs}</code> is sort of an analogue to pattern matching on <code>List I</code> right?</p>",
        "id": 476892053,
        "sender_full_name": "nrs",
        "timestamp": 1728964766
    },
    {
        "content": "<p>is there any way to make this implicit pattern match explicit?</p>",
        "id": 476892266,
        "sender_full_name": "nrs",
        "timestamp": 1728964854
    },
    {
        "content": "<p>just <code>(i : I) (xs : List I)</code> before semicolon I guess, not exactly a pattern match but it would be how the make the above explicit. Edit: hm but making them explicit this way doesn't necessarily guarantee we're making use of the <code>List I</code> in our dependent parameters in the inductive header right? Edit2: it does if we pass <code>(.cons i xs)</code> at the end! Very cool approach thank you!</p>",
        "id": 476893193,
        "sender_full_name": "nrs",
        "timestamp": 1728965252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"749978\">nrs</span> <a href=\"#narrow/stream/270676-lean4/topic/Translating.20Agda's.20All.20to.20Lean/near/476892053\">said</a>:</p>\n<blockquote>\n<p><code>{i xs}</code> is sort of an analogue to pattern matching on <code>List I</code> right?</p>\n</blockquote>\n<p>Not exactly. In fact, you can leave it out. But you'll notice that Lean then swaps the order that these implicit arguments appear in, in the type of <code>All.cons</code>.</p>",
        "id": 476911334,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1728974453
    },
    {
        "content": "<p>Note that you never told Lean that <code>I</code> is a type. This is the autoImplicit functionality kicking in.</p>",
        "id": 476911471,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1728974497
    },
    {
        "content": "<p>You wrote <code>i</code> and <code>xs</code> in the signature, so Lean figured out, aah those must be some implicit arguments that I should add.</p>",
        "id": 476911591,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1728974526
    },
    {
        "content": "<p>Thanks for the answer! I will be thinking about this</p>",
        "id": 476914683,
        "sender_full_name": "nrs",
        "timestamp": 1728975435
    },
    {
        "content": "<p>It's worth using <code>#print</code> (or hovering over the constructors, or doing the <code>#check</code> commands that Johan did) to see the types of the constructors, to understand what <code>{i xs}</code> expands to.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">All</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">inductive All : {I : Type} → (I → Type) → List I → Type</span>\n<span class=\"cm\">number of parameters: 2</span>\n<span class=\"cm\">constructors:</span>\n<span class=\"cm\">All.nil : {I : Type} → {P : I → Type} → All P []</span>\n<span class=\"cm\">All.cons : {I : Type} → {P : I → Type} → {i : I} → {xs : List I} → P i → All P xs → All P (i :: xs)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 476919582,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1728976690
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Translating.20Agda's.20All.20to.20Lean/near/476919582\">said</a>:</p>\n<blockquote>\n<p>It's worth using <code>#print</code> (or hovering over the constructors, or doing the <code>#check</code> commands that Johan did) to see the types of the constructors, to understand what <code>{i xs}</code> expands to.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">All</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">inductive All : {I : Type} → (I → Type) → List I → Type</span>\n<span class=\"cm\">number of parameters: 2</span>\n<span class=\"cm\">constructors:</span>\n<span class=\"cm\">All.nil : {I : Type} → {P : I → Type} → All P []</span>\n<span class=\"cm\">All.cons : {I : Type} → {P : I → Type} → {i : I} → {xs : List I} → P i → All P xs → All P (i :: xs)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>very useful tyvm!!</p>",
        "id": 476920903,
        "sender_full_name": "nrs",
        "timestamp": 1728977033
    }
]