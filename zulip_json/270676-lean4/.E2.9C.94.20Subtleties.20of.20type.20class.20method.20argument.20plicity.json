[
    {
        "content": "<p>I'm trying to discern exactly what causes some type class methods to get different plicities than others, and I have a theory that I'd appreciate confirmation or correction of. I couldn't find a description in <em>TPiL4</em> or in the manual.</p>\n<p>My theory: if a class <code>C</code> has a telescope <code>(x1 : A1) ... (xn : An)</code> at the top, then a method <code>m : B</code> will result in an accessor <code>C.m</code> that takes all <code>xk : Ak</code> arguments to <code>C</code> implicitly if they're mentioned in <code>B</code>, and explicitly if they are not, prior to the instance implicit <code>[self : C x1 ... xn]</code>.</p>\n<p>This seems to make sense to me, because the arguments that are not mentioned in <code>m</code>'s type will not generally be solvable via unification, while those that are probably will be. This also matches some observations:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">OfNat.ofNat</span> <span class=\"c1\">-- @OfNat.ofNat : {α : Type u_1} → (x : Nat) → [self : OfNat α x] → α</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">A.a</span> <span class=\"c1\">-- @A.a : {α : Type u_1} → (b : Nat) → [self : A α b] → α</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">B.b</span> <span class=\"c1\">-- @B.b : {α : Type u_1} → (b : Nat) → (β : Type u_2) → [self : B α b β] → α</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">C.c</span> <span class=\"c1\">-- @C.c : {α : Type u_1} → (b : Nat) → {β : Type u_2} → [self : C α b β] → α → β</span>\n</code></pre></div>",
        "id": 292041725,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1659633484
    },
    {
        "content": "<p>Your theory is correct.</p>",
        "id": 292044422,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1659634650
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 292045164,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1659634967
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"354934\">David Thrane Christiansen</span> has marked this topic as resolved.</p>",
        "id": 292045166,
        "sender_full_name": "Notification Bot",
        "timestamp": 1659634970
    },
    {
        "content": "<blockquote>\n<p>plicities</p>\n</blockquote>\n<p>Note: in Lean this is called \"binder info\" (or rarely \"binder annotation\").  I'm not saying that's a better name, but we should be using uniform terminology.</p>",
        "id": 292048800,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1659636667
    },
    {
        "content": "<p>Thanks for the terminology pointer. I think \"plicity\" is probably an Idris-ism.</p>",
        "id": 292065600,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1659644875
    }
]