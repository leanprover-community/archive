[
    {
        "content": "<p>I have the following declaration and function which uses <code>Nat</code>. With it I can prove a theorem using <code>rfl</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">MyInt</span> <span class=\"n\">where</span>\n  <span class=\"n\">right</span><span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">left</span><span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">condition</span><span class=\"o\">:</span> <span class=\"n\">right</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">∨</span> <span class=\"n\">left</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">normalize</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">MyInt</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">normalize</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MyInt.mk</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"o\">(</span><span class=\"n\">Or.inr</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MyInt.mk</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MyInt.mk</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">normalize.left_zero</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">normalize</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">MyInt.mk</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 393671255,
        "sender_full_name": "Ben",
        "timestamp": 1695896027
    },
    {
        "content": "<p>However when I instead use <code>Nat2</code> (which has an identical definition to <code>Nat</code>). The <code>rfl</code> in the theorem fails</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Nat2</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat2</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">MyInt2</span> <span class=\"n\">where</span>\n  <span class=\"n\">right</span><span class=\"o\">:</span> <span class=\"n\">Nat2</span>\n  <span class=\"n\">left</span><span class=\"o\">:</span> <span class=\"n\">Nat2</span>\n  <span class=\"n\">condition</span><span class=\"o\">:</span> <span class=\"n\">right</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">∨</span> <span class=\"n\">left</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">normalize2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Nat2</span> <span class=\"bp\">×</span> <span class=\"n\">Nat2</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">MyInt2</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">normalize2</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MyInt2.mk</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"o\">(</span><span class=\"n\">Or.inr</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MyInt2.mk</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MyInt2.mk</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">normalize2.left_zero</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">Nat2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">normalize2</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">MyInt2.mk</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 393671462,
        "sender_full_name": "Ben",
        "timestamp": 1695896090
    },
    {
        "content": "<p>Any ideas why?</p>",
        "id": 393671513,
        "sender_full_name": "Ben",
        "timestamp": 1695896113
    },
    {
        "content": "<p>If anything, I'm surprised the first example type-checks.<br>\nBoth definitions of <code>normalize</code> are reduced by the elaborator to well-founded functions, because the elaborator didn't manage to turn them into your usual <code>Nat(2).rec</code> recursors. For type-theoretic (and performance) reasons, well-founded functions don't reduce by default. As such, neither theorem should type-check. Since <code>Nat</code> is handled in a special way in lean, it might have somehow bypassed the check which ensures that <code>WellFounded.fix</code> doesn't reduce.</p>",
        "id": 393678610,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1695898145
    },
    {
        "content": "<p>Looking into this again. Interestingly <code>'normalize.left_zero' depends on axioms: [Classical.choice, Quot.sound, propext]</code>. I understand why <code>propext</code> is there, not sure whether <code>Classical.choice, Quot.sound</code> have special implementations for Lean's own <code>Nat</code></p>",
        "id": 394422506,
        "sender_full_name": "Ben",
        "timestamp": 1696251490
    },
    {
        "content": "<p>Still don't quite understand why <code>normalize2.left_zero</code> will not pass. Surely it can see looking at the matchers, there isn't any <em>wildcards</em> (or whatever they are called?) so surely it can simply pick out the matchers value.</p>",
        "id": 394422890,
        "sender_full_name": "Ben",
        "timestamp": 1696251583
    },
    {
        "content": "<p>Especially confusing as the following works for <code>Nat2</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Nat2.add</span> <span class=\"o\">:</span> <span class=\"n\">Nat2</span> <span class=\"bp\">→</span> <span class=\"n\">Nat2</span> <span class=\"bp\">→</span> <span class=\"n\">Nat2</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">m</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">n.add</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">add_zero</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">Nat2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat2.zero.add</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 394423071,
        "sender_full_name": "Ben",
        "timestamp": 1696251610
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"432410\">Arthur Adjedj</span> <a href=\"#narrow/stream/270676-lean4/topic/rfl.20doesn't.20work.20for.20specific.20structure/near/393678610\">said</a>:</p>\n<blockquote>\n<p>Since <code>Nat</code> is handled in a special way in lean, it might have somehow bypassed the check which ensures that <code>WellFounded.fix</code> doesn't reduce.</p>\n</blockquote>\n<p><del>This is precisely the case. The kernel has special support for <code>Nat</code> and can reduces many definitions using it computationally, whereas a Nat-like type will be reduced term-wise which will get caught up on <code>WellFounded.fix</code> in this case.</del> (I am very wrong, see Sebastian's answer below.)</p>",
        "id": 394455762,
        "sender_full_name": "Mac Malone",
        "timestamp": 1696259216
    },
    {
        "content": "<p>No, this has nothing to do with <code>Nat</code> being special in the kernel, which should not lead to terms being reducible that were not before. Apparently the autogenerated <code>SizeOf</code> instance for <code>Nat2</code> does not reduce as nicely as that for <code>Nat</code> (which is the identity function). Reduction of wf recursion is fraught for these kinds of reasons and subject to change; you should not rely on it.</p>",
        "id": 394468337,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1696263086
    },
    {
        "content": "<p>Interesting, I will have to look more into well founded ness</p>",
        "id": 394595062,
        "sender_full_name": "Ben",
        "timestamp": 1696325621
    },
    {
        "content": "<p>Either way if anyone else is stuck on getting these trivial things to check, I found that  <code>by cases n &lt;;&gt; rfl</code> can help (in bashing out the cases). If that doesn't work you can try <code>unfold func</code> and additionally <code>simp</code>. Not efficient ways, but good in cases when it gets stuck.</p>",
        "id": 394595513,
        "sender_full_name": "Ben",
        "timestamp": 1696325768
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"457144\">Ben</span> has marked this topic as resolved.</p>",
        "id": 394595525,
        "sender_full_name": "Notification Bot",
        "timestamp": 1696325773
    }
]