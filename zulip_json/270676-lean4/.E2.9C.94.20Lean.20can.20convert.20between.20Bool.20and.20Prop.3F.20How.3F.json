[
    {
        "content": "<p>Hi all, I've noticed in a couple of places that Lean has some ability to convert between Bool and Prop, but I don't really understand what's going on.</p>\n<p>Here's one place where Lean can convert a <code>Prop</code> to a <code>Bool</code>. This fails type-checking, as I would expect:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo1</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.le</span> <span class=\"mi\">3</span> <span class=\"mi\">4</span>\n</code></pre></div>\n<p>(It fails because it cannot unify Bool with Prop.) But then if I write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo2</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">LE.le</span> <span class=\"mi\">3</span> <span class=\"mi\">4</span>\n</code></pre></div>\n<p>This type-checks! Even though <code>LE.le: α → α → Prop</code>, and is defined to be <code>Nat.le</code> on <code>Nat</code>. So ... is there something special about <code>LE</code> that lets Lean do this?</p>\n<p>In the other direction, it seems <code>Bool</code> can sometimes be converted to <code>Prop</code>. For example I can write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">three_is_three</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">==</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span> <span class=\"n\">hn</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hn</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>\n<p>Here, <code>n == 3</code> is somehow converted to <code>(n == 3) = true</code>. Again, I'm not sure what rules are being followed to allow this.</p>\n<p>Sorry - I don't know what to call this feature, so I haven't been able to find out more about it ...</p>",
        "id": 315789279,
        "sender_full_name": "Jim Fisher",
        "timestamp": 1671015630
    },
    {
        "content": "<p>There's a type class <code>Decidable</code> which is responsible for making this kind of coercion work, and there's probably no instance for <code>Nat.le</code> because you're not really supposed to ever write <code>Nat.le</code>.</p>",
        "id": 315789597,
        "sender_full_name": "Reid Barton",
        "timestamp": 1671015736
    },
    {
        "content": "<p>For <code>Bool</code> to <code>Prop</code> the coercion is just <code>b = true</code>, and doesn't depend on anything.</p>",
        "id": 315789828,
        "sender_full_name": "Reid Barton",
        "timestamp": 1671015828
    },
    {
        "content": "<p>Aha! That makes sense. And the search term I was missing is \"coercion\", of course ... I now see it in the docs. Thank you!</p>",
        "id": 315790316,
        "sender_full_name": "Jim Fisher",
        "timestamp": 1671015973
    },
    {
        "content": "<p>(And the dependency on <code>Decidable</code> clears up my concerns about \"how on earth is this safe\" ...)</p>",
        "id": 315790464,
        "sender_full_name": "Jim Fisher",
        "timestamp": 1671016028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"570070\">jim</span> has marked this topic as resolved.</p>",
        "id": 315791075,
        "sender_full_name": "Notification Bot",
        "timestamp": 1671016231
    }
]