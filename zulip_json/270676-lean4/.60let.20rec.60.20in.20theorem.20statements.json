[
    {
        "content": "<p>Is this theorem provable?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">let_rec_in_theorem</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">countOnes</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">countOnes</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">countOnes</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">;</span>\n<span class=\"w\">    </span><span class=\"n\">countOnes</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>In the goal state, the recursive definition is shown as a metavariable, and it doesn't seem possible to unfold it.</p>",
        "id": 488697253,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734029209
    },
    {
        "content": "<p>Oh no, it's provable even when it shouldn't be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"w\">  </span><span class=\"c1\">-- for `recover`</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">let_rec_in_theorem</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">countOnes</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">countOnes</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">countOnes</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">;</span>\n<span class=\"w\">    </span><span class=\"n\">countOnes</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">37</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">recover</span><span class=\"w\"> </span><span class=\"n\">skip</span>\n<span class=\"w\">  </span><span class=\"n\">swap</span>\n<span class=\"w\">  </span><span class=\"c1\">-- I reject your auxiliary definition and substitute my own</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">37</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 488698002,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734029473
    },
    {
        "content": "<p>What does <code>#check let_rec_in_theorem</code> print?</p>",
        "id": 488698983,
        "sender_full_name": "Niels Voss",
        "timestamp": 1734029838
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">let_rec_in_theorem</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">definitelyOne</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">definitelyOne</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">37</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">recover</span><span class=\"w\"> </span><span class=\"n\">skip</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"mi\">37</span>\n\n<span class=\"c1\">-- let_rec_in_theorem : (fun definitelyOne =&gt; definitelyOne = 37) 37</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">let_rec_in_theorem</span>\n</code></pre></div>",
        "id": 488699125,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734029885
    },
    {
        "content": "<p>This seems very scary, as proofs of theorems are not supposed to be able to change their statement!</p>",
        "id": 488699252,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734029930
    },
    {
        "content": "<p>At least it isn't a proof of <code>False</code> though</p>",
        "id": 488699342,
        "sender_full_name": "Niels Voss",
        "timestamp": 1734029968
    },
    {
        "content": "<p>I wouldn't expect it to be, since <code>let rec</code> is an elaborator construction not a kernel one</p>",
        "id": 488699422,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734029999
    },
    {
        "content": "<p>Apparently the <code>recover skip</code> is unneeded: <code>theorem let_rec_in_theorem : let rec definitelyOne := 1; definitelyOne = 37 := by exact .refl 37</code></p>",
        "id": 488700004,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1734030202
    },
    {
        "content": "<p>And I suppose if you replace the proof with sorry, it goes back to the correct definition?</p>",
        "id": 488700009,
        "sender_full_name": "Niels Voss",
        "timestamp": 1734030204
    },
    {
        "content": "<p>It seems to require tactic mode: <code>by exact Eq.refl 37</code> works while <code>Eq.refl 37</code> doesn't even though the former produces the latter as a proof</p>",
        "id": 488701106,
        "sender_full_name": "Niels Voss",
        "timestamp": 1734030589
    },
    {
        "content": "<p>Sounds like someone should file an issue on github :)</p>",
        "id": 488701495,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1734030749
    },
    {
        "content": "<p>Also interestingly, <code>#print let_rec_in_theorem.definitelyOne</code> still returns <code>1</code> despite this not being used</p>",
        "id": 488701639,
        "sender_full_name": "Niels Voss",
        "timestamp": 1734030824
    },
    {
        "content": "<p><code>let rec</code> doesn't get resolved until the body of a declaration elaborates. It's a shorthand for a <code>mutual ... end</code> block.</p>\n<p>The bug here seems to be that <code>let rec</code> is not warning that its metavariable has been assigned? The <code>exact</code> tactic is able to assign synthetic opaque metavariables when unifying the type of the provided term with the goal type, and the <code>let rec</code> metavariable is a synthetic opaque metavariable.</p>",
        "id": 488711079,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734034612
    },
    {
        "content": "<p>How am I supposed to prove things with a <code>let rec</code> <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">xxx</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">ℤ</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∅</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)}</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- invalid argument, variable is not a proposition or let-declaration</span>\n</code></pre></div>",
        "id": 505555015,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1741913654
    },
    {
        "content": "<p>You can't</p>",
        "id": 505555114,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741913730
    },
    {
        "content": "<p>But what if I really have to include the definition inside the theorem?</p>",
        "id": 505555283,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1741913817
    },
    {
        "content": "<p>Why would you have to do that?</p>",
        "id": 505555361,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741913859
    },
    {
        "content": "<p>You could do something terrible like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">xxx</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">run_tac</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">liftCommandElabM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">      </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">elabCommandTopLevel</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span>\n<span class=\"w\">        </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">ℤ</span>\n<span class=\"w\">          </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∅</span>\n<span class=\"w\">          </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)})</span>\n<span class=\"w\">    </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">evalTactic</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`a</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">P</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 505556167,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741914301
    },
    {
        "content": "<p>Maybe tactic-mode <code>let rec</code> should always have semantics along those lines...</p>",
        "id": 505556244,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741914352
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/270676-lean4/topic/.60let.20rec.60.20in.20theorem.20statements/near/505556244\">said</a>:</p>\n<blockquote>\n<p>Maybe tactic-mode <code>let rec</code> should always have semantics along those lines...</p>\n</blockquote>\n<p>That would not let it be mutual recursive with the theorem being proven.</p>",
        "id": 505556444,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741914443
    },
    {
        "content": "<p>I don't think <code>let rec</code> is ever used that way in a proof in practice</p>",
        "id": 505556584,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741914511
    },
    {
        "content": "<p>Though now I'm curious to see a proof that replaces <code>induction</code> with <code>let rec</code></p>",
        "id": 505556703,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741914589
    }
]