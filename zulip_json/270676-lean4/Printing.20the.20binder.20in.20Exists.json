[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/270676-lean4/topic/Error.20messages.20suggestions/near/566696464\">said</a>:</p>\n<blockquote>\n<p>It would be nice if <code>∃</code> and <code>∀</code> printed the same. Currently, only <code>∀</code>shows the binder types (which can be turned off using <code>pp.piBinderTypes</code>).</p>\n</blockquote>\n<p>This is something I think about trying to solve periodically.</p>\n<p>Here's an overview of the situation:</p>\n<ul>\n<li>The forall notation is from a raw pi type. There's a delaborator responsible for pretty printing, since there are a number of calculations it needs to do (e.g. to decide between forall and <code>(x : a) -&gt; b x</code> notation).</li>\n<li>The exists notation uses an app unexpander.<ul>\n<li>App unexpanders are syntax transformers that are applied inside the app delaborator. The sequence goes: delaborate the function and arguments for an application (skipping implicit arguments), create the application, then try applying unexpanders if the function is a constant.</li>\n<li>The Exists unexpander sees an expression of the form <code>Exists fun ... =&gt; ...</code>, where <code>fun ... =&gt; ...</code> is a predicate.</li>\n<li>Depending on the value of <code>pp.funBinderTypes</code>, this <code>fun</code> might or might not have a binder type. If it doesn't, the unexpander doesn't have access to the existential's domain at all. Unexpanders do not have any access to the underlying expression, just the pretty printed results.</li>\n<li>Even if an unexpander had a way to re-pretty-print an argument with additional options, it would be best to avoid re-pretty-printing. Delaboration doesn't have any memoization, which would lead to O(n^2) pretty printing calls for an exists chain of length n.</li>\n</ul>\n</li>\n</ul>\n<p>A couple potential directions I've thought about:</p>\n<ol>\n<li>Add a system where you can tag a specific constant with pretty printer option rules. For example, on <code>Exists</code> we could add the rule \"set <code>pp.funBinderTypes</code> on argument 1\". This way the unexpander has the domain to work with. Downside: this will <em>always</em> show the existential's domain unless the system can also be made conditional on option(s).</li>\n<li>Switch to using a delaborator. This gives up on a general solution, but it does address the pain point with <code>Exists</code>. I think Mathlib tends to use <code>notation3</code> instead of trying to write app unexpanders for notations with binders.</li>\n</ol>\n<p>A virtue of app unexpanders is that they let you define how to pretty print notation without needing to import anything in <code>Lean</code>.</p>\n<p>For <code>Exists</code> though, in core it's possible to create a \"builtin\" delaborator. These can be defined after the prelude, but are already pre-loaded in the prelude. That means you'd still see <code>Exists</code> pretty printed even without importing anything.</p>",
        "id": 566756290,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1767798758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/270676-lean4/topic/Error.20messages.20suggestions/near/566696464\">said</a>:</p>\n<blockquote>\n<p>It would be nice if <code>∃</code> and <code>∀</code> printed the same. Currently, only <code>∀</code>shows the binder types (which can be turned off using <code>pp.piBinderTypes</code>).</p>\n</blockquote>\n<p>You can turn on binder types for <code>∃</code> with <code>pp.funBinderTypes</code></p>",
        "id": 566830640,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767823081
    },
    {
        "content": "<p>Here's another related issue.</p>\n<p>If I click on <code>∃ a &gt; 4, a = a</code> in the infoview, it shows me that the term is secretly <code>@Exists ℕ fun a =&gt; a &gt; 4 ∧ a = a</code>, which is nice to know.</p>\n<p>But if I click on <code>∀ a &gt; 4, a = a</code>, it still shows me <code>∀ a &gt; 4, a = a</code>, and I have no way to see what is actually there.</p>",
        "id": 568536822,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1768604052
    },
    {
        "content": "<p>Yeah I guess that's especially bad for not allowing you to investigate the <code>a &gt; 4</code> expression itself and e.g. look at the instance. The solution would be to prevent the delaborator that turns <code>∀ a, a &gt; 4 → a = a</code> into <code>∀ a &gt; 4, a = a</code> when <code>pp.explicit</code> is true (which is used among others when you hover over an expression). This is a mathlib thing though, so we can fix it directly in mathlib.</p>",
        "id": 568537462,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1768604565
    },
    {
        "content": "<p>probably <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PiNotation.delabPi#doc\">docs#PiNotation.delabPi</a></p>",
        "id": 568538890,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768605748
    }
]