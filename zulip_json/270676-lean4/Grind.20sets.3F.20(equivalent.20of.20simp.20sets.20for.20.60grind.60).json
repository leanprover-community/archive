[
    {
        "content": "<p>Hello! I have a bunch of theorems I would like to use with <code>grind</code>'s e-matching feature, but only in some specific scenarios, therefore I would like <code>grind</code> to refrain from instantiating them unless I configure it to do so. Does this feature exists? I found the function <code>registerGrindAttr</code> which shares a similar name with <code>registerSimpAttr</code>, but it is private and does not seem to do something similar.</p>\n<p>I the meantime I have a workaround using a trick I also employ in other SMT-based verifiers, it emulates having grind sets although it is a bit hacky (<a href=\"https://live.lean-lang.org/#codez=CYUwZgBGD6A2IFsEEMDO0QDtkCN7AgApoAuCAVUwEsAXASjIAUAnAewAcISBeCAFWYBXEACgaACxCtmiCFlzxoMeEjRlliFOnl4QBQnS68cATwioqCTgG0Nq7dl3AAuiJHIAHlVYIoZAHLINBAAtAB8EIE07l4+UNBU6FT6mAFBhoTAgkgmZJS0DFAQmBC8mG4A5sxUmMDQ7EE0IMwlMIkJBNwRkJgANPEqWhiO+BBZOW4gHshW8ESpkenqRD2GZUYQpiIQUMhUsAkwqIIAxicgqKgQVTUEISHx7ckQicWswTWoNMiYNFRBem2EHEyAAbiANjpFHYtECbrUREA\">see on Lean 4 Web</a>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f_lemmas_enabled</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">enable_f_lemmas</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f_lemmas_enabled</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">f_lemmas_enabled</span><span class=\"o\">]</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">f_is_id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dummy</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"n\">grind_pattern</span><span class=\"w\"> </span><span class=\"n\">f_is_id</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f_lemmas_enabled</span><span class=\"w\"> </span><span class=\"n\">dummy</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">fail_if_success</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"c1\">-- f_is_id is not instantiated</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">enable_f_lemmas</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n</code></pre></div>",
        "id": 532925745,
        "sender_full_name": "Théophile",
        "timestamp": 1754403106
    },
    {
        "content": "<p>You can used <code>scoped</code>.</p>",
        "id": 533006918,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1754440828
    },
    {
        "content": "<p>Thanks, I was not familiar with this attribute. I looked through the documentation, however it seems that we can't use scoped grind patterns outside the namespace they are scoped in (this is somewhat expected from <code>scoped</code> I guess)? How can we use the scoped grind pattern outside the corresponding namespace? See example below.</p>\n<p>My usecase is that I have grind patterns associated to some theorems that would in general be instantiated a lot, but in practice they are useful only in some specific proofs, so I want to enable them only in that case. I relied the trick I've shown above in other SMT-based program verifiers with success in the past, but wondered if there was a cleaner option in Lean (otherwise if there is no cleaner option, the trick is good enough for me).</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Test</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">scoped</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"kd\">]</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">f_is_id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"c1\">-- `grind` works here</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Test</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- how to make `grind` work here?</span>\n<span class=\"w\">  </span><span class=\"n\">fail_if_success</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- we need to reopen the namespace to prove our theorem</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Test</span>\n\n<span class=\"c1\">-- `grind` works here again</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Test</span>\n\n<span class=\"c1\">-- also works</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"bp\">.</span><span class=\"n\">toto</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n</code></pre></div>",
        "id": 533042934,
        "sender_full_name": "Théophile",
        "timestamp": 1754466177
    },
    {
        "content": "<p>You can use <code>open scoped Test</code> in any other section, and then they'll be available there. You can also run <code>open scoped Test in theorem foo :...</code>to have it open just for that one theorem!</p>",
        "id": 533043184,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1754466283
    },
    {
        "content": "<p>Ah, but then all grinds in the proof will instantiate the theorem. I hoped to be able to do something such as annotating lemmas with e.g. <code>@[grind f_lemma]</code> and use such theorems only when using e.g. <code>grind [f_lemmas]</code> (which I can do with the trick in the first post).</p>\n<p>Anyway, thank you for your answers, I now have a better picture of the different ways to achieve my goal!</p>",
        "id": 533145323,
        "sender_full_name": "Théophile",
        "timestamp": 1754499164
    },
    {
        "content": "<p>You can break your proof into lemmas (always a good idea, as soon as the proof is more than 10 lines! :-) and use <code>open scoped ... in ...</code> only for those lemmas that need the additional grind annotations.</p>",
        "id": 533210802,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1754537620
    },
    {
        "content": "<p>If I'm not mistaken, using <code>open scoped ... in grind</code> at the tactic level should work too.</p>",
        "id": 533334608,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754587455
    },
    {
        "content": "<p>Thanks, indeed! (MWE at the end for posterity)<br>\nThis is more convincing and doesn't have drawbacks compared to the initial hack I've shown.</p>\n<p>For my own curiosity, I am wondering: if this is the official way to implement grind sets, it should also work to implement simp sets, so why does <code>simp</code> has built-in support for simp sets and not grind?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">scoped</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"kd\">]</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"bp\">.</span><span class=\"n\">f_is_id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">fail_if_success</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n<span class=\"w\">  </span><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n</code></pre></div>",
        "id": 533336342,
        "sender_full_name": "Théophile",
        "timestamp": 1754588101
    },
    {
        "content": "<p>Some speculation on simp sets:</p>\n<ul>\n<li>Simp sets are a fairly old feature (I remember them in Lean 3). Possibly in Lean 4 they were implemented even before <code>open scoped</code>.</li>\n<li>Simp sets seem to be more efficient than <code>open scoped</code> (though I didn't measure) since simp doesn't merge simp sets into a single simp set during its operation; each simp set is queried one at a time to see if they apply.</li>\n<li>There are no grind sets because they are not implemented, and <code>open scoped</code> works. I don't know if there's a reason they weren't implemented beyond the fact it would take more engineering time.</li>\n</ul>",
        "id": 533349346,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754593727
    },
    {
        "content": "<p>Ok, thanks! I realize I have one last question about this: in my usecase I call <code>grind</code> from a custom tactic (i.e. code in <code>TacticM</code>) I am writing, how do I implement the <code>open</code> trick in the <code>TacticM</code> world? I don't know what to do because <code>open ... in</code> seems to be primarily for elaboration and doesn't change the proof term.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"c1\">-- how to do add `open Test in` here for auxGoal?</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"n\">auxGoal</span><span class=\"w\"> </span><span class=\"o\">{}</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">())</span>\n</code></pre></div>\n<p>(with the hack I've shown in the first post, it's just a matter of doing <code>auxGoal.assert</code> on <code>enable_f_lemmas</code>)<br>\nNote: I use <code>grind</code> to solve automatically auxiliary goals generated by my tactic, probably not recommended, but for a first proof-of-concept it's good enough, and much easier than writing a full-blown tactic for these specific auxiliary goals (and they all should be straightforward for <code>grind</code>)</p>",
        "id": 533355342,
        "sender_full_name": "Théophile",
        "timestamp": 1754596698
    },
    {
        "content": "<p>If you \"go to definition\" on <code>open ... in</code> it will bring you to the elaborator, and I suppose you could copy how it does it.</p>\n<p>Alternatively, rather than use the meta interface, you could <code>evalTactic</code> some syntax. There's also <code>Lean.Elab.Term.runTactic</code>, which is more straightforward. For both of these you create a metavariable whose type is <code>auxGoal</code>.</p>",
        "id": 533355930,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754596952
    },
    {
        "content": "<p>Are you wanting grind sets because you want it to be user-extensible?</p>\n<p><code>Lean.Elab.Tactic.grind</code> lets you pass in grind parameters directly if not.</p>",
        "id": 533356353,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754597137
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">try</span>\n<span class=\"w\">  </span><span class=\"n\">pushScope</span>\n<span class=\"w\">  </span><span class=\"n\">activateScoped</span><span class=\"w\"> </span><span class=\"ss\">`myNamespace</span>\n<span class=\"n\">finally</span>\n<span class=\"w\">  </span><span class=\"n\">popScope</span>\n</code></pre></div>\n<p>should do the trick</p>",
        "id": 533357581,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754597663
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"873547\">@Robin Arnez</span> yes that works, thanks!<br>\n<span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> indeed I want it to be user-extensible, this is why I want grind sets</p>",
        "id": 533358823,
        "sender_full_name": "Théophile",
        "timestamp": 1754598346
    },
    {
        "content": "<p>I've also recently wanted to run <code>open ... in tac</code> in <code>TacticM</code>. Having an out of the box solution for this would be nice.</p>",
        "id": 533376260,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1754609222
    },
    {
        "content": "<p>In case it is useful to anyone, I wrote the following utility function in my project</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">  Opens a namespace (similarly to `open ... in` in tactics).</span>\n<span class=\"sd\">  Useful to enable scoped lemmas (e.g. for `grind` or `simp`).</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">withOpenIn</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadEnv</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadLiftT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ST</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">RealWorld</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadFinally</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">namespaceName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">try</span>\n<span class=\"w\">      </span><span class=\"n\">pushScope</span>\n<span class=\"w\">      </span><span class=\"n\">activateScoped</span><span class=\"w\"> </span><span class=\"n\">namespaceName</span>\n<span class=\"w\">      </span><span class=\"n\">k</span>\n<span class=\"w\">    </span><span class=\"n\">finally</span>\n<span class=\"w\">      </span><span class=\"n\">popScope</span>\n</code></pre></div>",
        "id": 533417097,
        "sender_full_name": "Théophile",
        "timestamp": 1754640573
    },
    {
        "content": "<p>And to conclude if someone has the same problem as me and reads this thread in the future, when working in a namespace: I first found it annoying to have to close it in order to add my lemma in the correct namespace, but discovered that we can simply use <code>_root_</code> like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Test</span>\n\n<span class=\"c1\">-- ...</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">scoped</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"kd\">]</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">Bla</span><span class=\"bp\">.</span><span class=\"n\">GrindNamespace</span><span class=\"bp\">.</span><span class=\"n\">f_is_id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"c1\">-- ...</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Test</span>\n</code></pre></div>\n<p>instead of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Test</span>\n\n<span class=\"c1\">-- ...</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"c1\">-- ugh</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">scoped</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"kd\">]</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Bla</span><span class=\"bp\">.</span><span class=\"n\">GrindNamespace</span><span class=\"bp\">.</span><span class=\"n\">f_is_id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"c1\">-- ugh</span>\n\n<span class=\"c1\">-- ...</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Test</span>\n</code></pre></div>",
        "id": 533418345,
        "sender_full_name": "Théophile",
        "timestamp": 1754641020
    },
    {
        "content": "<p>Update: grind sets were implemented in <a href=\"https://github.com/leanprover/lean4/pull/11765\">lean4#11765</a> and <a href=\"https://github.com/leanprover/lean4/pull/11770\">lean4#11770</a></p>",
        "id": 565144062,
        "sender_full_name": "Théophile",
        "timestamp": 1766491215
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"897795\">Théophile</span> <a href=\"#narrow/channel/270676-lean4/topic/Grind.20sets.3F.20.28equivalent.20of.20simp.20sets.20for.20.60grind.60.29/near/565144062\">said</a>:</p>\n<blockquote>\n<p>Update: grind sets were implemented in <a href=\"https://github.com/leanprover/lean4/pull/11765\">lean4#11765</a> and <a href=\"https://github.com/leanprover/lean4/pull/11770\">lean4#11770</a></p>\n</blockquote>\n<p>Has anyone been using this feature? I think it is an improvement over <code>scoped</code> in some aspects but am curious about the ergonomics in practice. For instance, is there an equivalent of <code>open scoped</code> or do you always have to specify the set to use it?</p>",
        "id": 571228060,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769890963
    },
    {
        "content": "<p>If you want to use a particular set always we usually define a tactic alias for that. E.g. <code>aesop_cat</code> in mathlib</p>",
        "id": 571228451,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1769891348
    },
    {
        "content": "<p>Yes, but this doesn't compose very well. The context here is that in CSLib we scoped almost all <code>grind</code> annotations. This works well, but is a bit messy navigating around namespaces. I was thinking of organizing them instead into a number of broader sets with this feature.</p>",
        "id": 571229074,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769891925
    }
]