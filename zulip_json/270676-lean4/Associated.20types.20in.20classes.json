[
    {
        "content": "<p>I wonder if there is any way to write <a href=\"https://doc.rust-lang.org/reference/items/associated-items.html#associated-types\">Rust like associated types</a> in Lean classes?</p>\n<p>Imagine I have a class for monadic file system operations <code>MonadFS</code> and a class for file read operations <code>MonadFileRead</code>.<br>\nThen I could write the file system class like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">MonadFS</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"c1\">-- Some file system related methods like:</span>\n  <span class=\"n\">ls</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">dir</span> <span class=\"o\">:</span> <span class=\"n\">FilePath</span> <span class=\"o\">:=</span> <span class=\"s2\">\".\"</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">IO.FS.DirEntry</span><span class=\"o\">)</span>\n  <span class=\"bp\">...</span>\n  <span class=\"c1\">-- Type of monad for reading files.</span>\n  <span class=\"n\">mf</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span>\n  <span class=\"n\">monadInst</span> <span class=\"o\">:</span> <span class=\"n\">Monad</span> <span class=\"n\">mf</span>\n  <span class=\"n\">readInst</span> <span class=\"o\">:</span> <span class=\"n\">MonadFileRead</span> <span class=\"n\">mf</span>\n  <span class=\"c1\">-- Perform file reading on a specific file.</span>\n  <span class=\"n\">readFile</span> <span class=\"o\">:</span> <span class=\"n\">FilePath</span> <span class=\"bp\">→</span> <span class=\"n\">mf</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>The problem is that I want <code>Monad m</code> and <code>MonadFileRead m</code> to be instances and not explicit members of the class. The user of the class should not need to refer to <code>monadInst</code> and <code>readInst</code> when using the <code>mf</code> monad.</p>\n<p>I could make <code>mf</code> as an outParam, and it works, but the class head gets really large and I will have to repeat it in every subclass of <code>MonadFS</code>.</p>\n<p>The problem is how to specify that <code>mf</code> should have some instances. In Rust like syntax an associated type could be written:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>        <span class=\"n\">type</span> <span class=\"n\">MF</span><span class=\"o\">:</span> <span class=\"n\">Monad</span> <span class=\"bp\">+</span> <span class=\"n\">MonadFileRead</span><span class=\"bp\">;</span>\n</code></pre></div>\n<p>But I don't know if this is possible in Lean?</p>",
        "id": 350460611,
        "sender_full_name": "Tage Johansson",
        "timestamp": 1681725019
    },
    {
        "content": "<p>I haven't run this, but in principle I believe this might implement what you're asking:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">MonadFS</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"c1\">-- Some file system related methods like:</span>\n  <span class=\"n\">ls</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">dir</span> <span class=\"o\">:</span> <span class=\"n\">FilePath</span> <span class=\"o\">:=</span> <span class=\"s2\">\".\"</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">IO.FS.DirEntry</span><span class=\"o\">)</span>\n  <span class=\"bp\">...</span>\n  <span class=\"c1\">-- Type of monad for reading files.</span>\n  <span class=\"n\">mf</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span>\n  <span class=\"o\">[</span><span class=\"n\">monadInst</span> <span class=\"o\">:</span> <span class=\"n\">Monad</span> <span class=\"n\">mf</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">readInst</span> <span class=\"o\">:</span> <span class=\"n\">MonadFileRead</span> <span class=\"n\">mf</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- Perform file reading on a specific file.</span>\n  <span class=\"n\">readFile</span> <span class=\"o\">:</span> <span class=\"n\">FilePath</span> <span class=\"bp\">→</span> <span class=\"n\">mf</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">MonadFS.monadInst</span> <span class=\"n\">MonadFS.readInst</span>\n</code></pre></div>\n<p>The square brackets in the <code>MonadFS</code> declaration may or may not be correct; what these do is make it so that when you construct a <code>MonadFS</code> then it will try to use typeclass inference to fill in <code>monadInst</code> and <code>readInst</code> automatically given <code>mf</code>.</p>\n<p>Setting the <code>instance</code> attributes makes it so that you can use <code>MonadFS.mf m</code> as a monad, for example. (Assuming I got the implicit/explicit arguments correct here of the top of my head.)</p>",
        "id": 350471320,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681727558
    },
    {
        "content": "<p>I think <code>outParam</code> is probably the answer here in general</p>",
        "id": 350473867,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681728216
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">MonadFS</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mf</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">$</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">mf</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadFileRead</span> <span class=\"n\">mf</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"c1\">-- Some file system related methods like:</span>\n  <span class=\"n\">ls</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">dir</span> <span class=\"o\">:</span> <span class=\"n\">FilePath</span> <span class=\"o\">:=</span> <span class=\"s2\">\".\"</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">IO.FS.DirEntry</span><span class=\"o\">)</span>\n  <span class=\"bp\">...</span>\n  <span class=\"c1\">-- Perform file reading on a specific file.</span>\n  <span class=\"n\">readFile</span> <span class=\"o\">:</span> <span class=\"n\">FilePath</span> <span class=\"bp\">→</span> <span class=\"n\">mf</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 350474088,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681728273
    },
    {
        "content": "<p>Then the caller just writes <code>[Monad mf] [MonadFileRead mf] [MonadFS m mf]</code> if they're writing generic code</p>",
        "id": 350474348,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681728332
    },
    {
        "content": "<p>Miller's solution works. The only annoying thing is that I have to write <code>MonadFS.mf m</code> instead of <code>m.mf</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">[</span><span class=\"n\">MonadFS</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">MonadFileRead</span> <span class=\"o\">(</span><span class=\"n\">m.mf</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n</code></pre></div>",
        "id": 350476403,
        "sender_full_name": "Tage Johansson",
        "timestamp": 1681728865
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Associated.20types.20in.20classes/near/350474348\">said</a>:</p>\n<blockquote>\n<p>Then the caller just writes <code>[Monad mf] [MonadFileRead mf] [MonadFS m mf]</code> if they're writing generic code</p>\n</blockquote>\n<p>Sweeping tradeoffs under the rug using the word \"just\" makes lots of things easy <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> Tage was asking how to avoid that (\"I could make mf as an outParam, and it works, but the class head gets really large and I will have to repeat it in every subclass of MonadFS.\") Outparams have the following nice properties: they make it more likely that <code>mf</code> has the canonical instances (having  a <code>monadInst</code> field allows users to override the instance), they make it so one can refer to whatever <code>mf</code> is directly (when it's a field, you generally have to refer to <code>MonadFS.mf m</code> otherwise typeclass inference might not work), and subclass diamonds don't have any special considerations at all since the class doesn't actually hold a copy of the instances.  I think for both it's fairly straightforward to add additional typeclass constraints to <code>mf</code> in either subclasses or by users of <code>MonadFS</code>.</p>",
        "id": 350477407,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681729151
    },
    {
        "content": "<p>Apologies, I totally missed the outParam sentence :(</p>",
        "id": 350477514,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681729177
    },
    {
        "content": "<p>Still, outparams are a very strong alternative, with the downside of being rather verbose.</p>",
        "id": 350477750,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681729230
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"544752\">@Tage Johansson</span> With the way name resolution works, <code>m.mf</code> can't work because it doesn't know that it should look at <code>MonadFS</code> to resolve the <code>mf</code> function. <code>m</code> is merely a value that has an associated <code>MonadFS</code> instance. The name resolver would have to go out of its way to see that there's an instance involving <code>m</code> that has an <code>mf</code> defined.</p>\n<p>I think I remember some discussions about how to eventually support this though. There are at least a few places in mathlib where this feature would really help.</p>",
        "id": 350477964,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681729293
    },
    {
        "content": "<p>If I export <code>mf</code> I can write <code>m |&gt; mf</code> though, so I think that's very acceptable.<br>\nThanks for the help.</p>",
        "id": 350478273,
        "sender_full_name": "Tage Johansson",
        "timestamp": 1681729372
    },
    {
        "content": "<p>I don't think this \"square-bracket\"-syntax in classes/structures and the instance attribute thing is documented anywhere though. At least I couldn't find it.</p>",
        "id": 350480230,
        "sender_full_name": "Tage Johansson",
        "timestamp": 1681729965
    },
    {
        "content": "<p>it should surely have some documentation, typeclasses are a rather core part of lean</p>",
        "id": 350484525,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681731217
    },
    {
        "content": "<p>the manual has <a href=\"https://leanprover.github.io/lean4/doc/typeclass.html\">https://leanprover.github.io/lean4/doc/typeclass.html</a>, although it's not particularly fleshed out</p>",
        "id": 350484834,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681731295
    },
    {
        "content": "<p>I guess your point was about using square brackets in class declarations; this falls out of the fact that class declarations consist of binders and <code>[inst : MyClass A]</code> is a binder</p>",
        "id": 350485026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681731347
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Associated.20types.20in.20classes/near/350485026\">said</a>:</p>\n<blockquote>\n<p>[..] class declarations consist of binders [..]</p>\n</blockquote>\n<p>I think it's this point that is not super clear, especially when writing the binders (as is idiomatic) like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Point</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>I know I didn't make the connection between <code>x : α</code> syntax and binder syntax until I saw a structure defining its field with bracketed binders, like <code>(x : α)</code>. Once that connection is made, trying out implicit and instance binders becomes more natural.</p>",
        "id": 350488637,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1681732299
    },
    {
        "content": "<p>I think the key realization is probably that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Point</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>is roughly short for</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Point</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>where now not only are the binders visible, but so is the function <code>Point.mk</code> that they're being used for</p>",
        "id": 350503739,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681735824
    }
]