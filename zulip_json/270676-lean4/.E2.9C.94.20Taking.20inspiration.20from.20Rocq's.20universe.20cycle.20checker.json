[
    {
        "content": "<p>Not being a huge fan of the \"stuck at solving universe constraint\" errors that appear as soon as one juggles multiple universes, I took a look at how Rocq is doing this and found <a href=\"https://sozeau.gitlabpages.inria.fr/www/research/publications/drafts/univpoly.pdf\">this paper from 2014</a> when Rocq got universe polymorphism that is comparable to Lean's.</p>\n<p>My takeaways are:</p>\n<ul>\n<li>Rocq is different from Lean in that (a) universes are cumulative and (b) Rocq has not <code>Sort u</code>, just separate universes <code>(S)Prop</code> and <code>Type u</code>, and their universe polymorphism seems only to work with <code>Type</code>.</li>\n<li>Instead of unifying universe level expressions like Lean does, Rocq collects constraints that relate universe variables with <code>&lt;</code> or <code>&lt;=</code> and checks for cycles. (In detail, they have universe variables that are assumed to be fixed/given from outside and others that need to be assigned, so this is similar to Lean.)</li>\n</ul>\n<p>While I haven't tried Rocq, the cycle-checking approach seems a bit more robust to me in principle than Lean's unification mechanism that easily fails even though a universe assignment would be possible. On the other hand, Rocq solves an easier problem because by excluding <code>Prop</code> from the polymorphism, it does not need to handle <code>imax</code> terms. Lean is more powerful in this regard.</p>\n<p>Touching Lean's universe system is a delicate undertaking and I'm not the one with the expertise in this regard, <strong>so I'm not advocating doing that.</strong> However, I'd like to outline my thoughts regarding how Lean is different from Rocq. This is meant more as an idea-generating post.</p>\n<p>There are some complications:</p>\n<ul>\n<li>I don't think there's a reliable algorithm resolving universe constraints involving <code>imax</code>. However, I think many use cases would profit from a more specialized, more efficient algorithm that could be used when there are only non-<code>Prop</code> universe variables -- or only a few for which it would be safe to make case distinctions whether they are <code>Prop</code>.</li>\n<li>Lean allowing equations like <code>max a b = max c d</code> makes it impossible to encode them as inequalities (<code>a &lt;= b</code>, <code>a &lt;= b + 1</code>, ...) and thus preventing us from using Rocq's simple, robust cycle-checking approach. We can hardly avoid such constraints because all the basic type formers use <code>max</code>, e.g. <code>Prod.{u, v} (α : Type u) (β : Type v) : Type (max u v)</code>. (In Rocq, the signature is in fact the same, but they can get away with nice inequalities because of their cumulative universes!)</li>\n</ul>\n<p>The most noninvasive approach I can come up with is to have special handling for \"inequality-shaped situations\". What I mean by that is that the constraints, although being formulated with <code>max</code>, encode a set of inequalities. All this could be handled in the elaborator (which might turn out to be completely unrealistic and ugly, I'm not an expert in that!) without touching the kernel. For example, the following declaration is \"inequality-shaped\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- encodes \" u &lt;= w' and v &lt;= w' \", where w' = max u v w</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">AltProd</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Prod</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>If all of the constraints are of such a more tractable form, universes can be assigned just as reliably like in Rocq. Perhapse one could use a heuristic that does this as long as most constraints are of the nice form so that we avoid a weird performance cliff. (Cumulative universes could help to make this work for the built-in <code>Prod</code>, but that seems like a rather invasive change.)</p>\n<p>An added benefit of a cycle checker would be that it becomes easier to explain the problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Universes</span><span class=\"w\"> </span><span class=\"n\">cannot</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">assigned</span><span class=\"w\"> </span><span class=\"n\">because</span><span class=\"w\"> </span><span class=\"n\">there</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">cycle</span><span class=\"o\">:</span>\n\n<span class=\"o\">(</span><span class=\"mf\">1.</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">expression</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"bp\">`</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"ss\">`a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"ss\">`b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">`</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">requires</span><span class=\"w\"> </span><span class=\"ss\">`v</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"bp\">`.</span>\n<span class=\"o\">(</span><span class=\"mf\">2.</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Since</span><span class=\"w\"> </span><span class=\"ss\">`a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">`</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"ss\">`a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"ss\">`α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">`</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">follows</span><span class=\"w\"> </span><span class=\"ss\">`v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">`.</span>\n<span class=\"o\">(</span><span class=\"mf\">3.</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">expression</span><span class=\"w\"> </span><span class=\"ss\">`f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">`</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"ss\">`a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"bp\">`</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">requires</span><span class=\"w\"> </span><span class=\"ss\">`w</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"bp\">`.</span>\n\n<span class=\"n\">Combined</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">these</span><span class=\"w\"> </span><span class=\"n\">constraints</span><span class=\"w\"> </span><span class=\"n\">would</span><span class=\"w\"> </span><span class=\"n\">imply</span><span class=\"w\"> </span><span class=\"ss\">`u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"bp\">`</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">which</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">permitted</span><span class=\"w\"> </span><span class=\"n\">because</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">could</span><span class=\"w\"> </span><span class=\"n\">lead</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">inconsistencies</span><span class=\"bp\">.</span>\n</code></pre></div>",
        "id": 522918657,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1749330100
    },
    {
        "content": "<p>While I am confident that lean's unification algorithm for universes could be improved, I do not think encoding <code>&lt;=</code> and doing cycle checking is the way to go, for a few reasons. </p>\n<p>First, one big reasons why Rocq's approach works so well is that their system is cumulative, this makes their proof system \"stronger\" to Lean's in some limited ways. In particular, their (implicit) Universe lifts <code>ULift</code>s are injective in the sense that <code>ULift A = ULift B</code> implies <code>A = B</code> in Rocq, which is not the case in Lean. As such, having <code>AltProd</code>s everywhere in pieces of code could quickly become very limiting (Note: I would be all for having some flavour of observational equality in Lean, and thus allowing for the injectivity of such type constructors, but this is a far-fetched dream and irrelevant to the discussion).</p>\n<p>Secondly, one important aspect of Rocq's universes is that their cycle checker does not assign universe variables at the end of a declaration. Even though AFAIK some local universe variables inside declarations get smartly erased here and there when finishing the type-checking of particular decls, a global state of constraints is still kept around at all times, meaning that potential \"assignations\" of past universe variables may change and get bumped over time. As such, by not ever producing solution to the constraint graph, Rocqavoids the issue of assigning universe variables entirely. </p>\n<p>Lastly, and more importantly, Rocq, while having many different type of universe variables, does not have any flavour of universe meta-variable ! All Rocq cares about is being able to give a model of its (global) constraint graph in Nat, whereas Lean needs to assign only the metavariables, and not the variables themselves. This makes the model space much more complex, and thus any \"solving\" algorithm more complex as well.</p>",
        "id": 522953591,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1749369860
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"221653\">Paul Reichert</span> <a href=\"#narrow/channel/270676-lean4/topic/Taking.20inspiration.20from.20Rocq's.20universe.20cycle.20checker/near/522918657\">said</a>:</p>\n<blockquote>\n<ul>\n<li>I don't think there's a reliable algorithm resolving universe constraints involving <code>imax</code>.</li>\n</ul>\n</blockquote>\n<p>There is, it's just not the one that is implemented. The decision procedure for terms involving <code>imax</code> is not that hard, you just branch on the zeroness of any universe variables on the right of an <code>imax</code> until all of the subterms there are either definitely-zero or definitely-nonzero. This is worst case exponential in the number of universe variables involved in <code>Sort u</code> expressions, but this is never really all that large, &gt;4 would be very rare.</p>",
        "id": 522998261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1749413532
    },
    {
        "content": "<p>Also I just want to say that I do not at all consider Rocq's universe checking algorithm as a model to follow, and would much rather have Rocq borrow from lean and ditch the global universe constants, which cause massive buildup of hidden universes in expressions and turn every definition into a linear dependency (modifying global state) which leaks even through opaque definitions, limiting parallelism.</p>",
        "id": 522998443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1749413763
    },
    {
        "content": "<p>Thank you both for taking the time to explain the issues with Rocq's approach. Having a global constraint graph indeed does not sound like a good idea to copy, and a localized form of such a cycle checker, that needs to cope with polymorphic universe parameters, might be more difficult and inefficient than a global one.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/270676-lean4/topic/Taking.20inspiration.20from.20Rocq's.20universe.20cycle.20checker/near/522998261\">said</a>:</p>\n<blockquote>\n<p>There is, it's just not the one that is implemented. The decision procedure for terms involving <code>imax</code> is not that hard, you just branch on the zeroness of any universe variables on the right of an <code>imax</code> until all of the subterms there are either definitely-zero or definitely-nonzero. This is worst case exponential in the number of universe variables involved in <code>Sort u</code> expressions, but this is never really all that large, &gt;4 would be very rare.</p>\n</blockquote>\n<p>That didn't seem (practically) reliable to me because I expected potentially more <code>Sort</code>s, but if there are usually only a few per declaration (including its body), you're certainly right that <code>imax</code> doesn't complicate matters except for some branching.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"432410\">Arthur Adjedj</span> <a href=\"#narrow/channel/270676-lean4/topic/Taking.20inspiration.20from.20Rocq's.20universe.20cycle.20checker/near/522953591\">said</a>:</p>\n<blockquote>\n<p>In particular, their (implicit) Universe lifts <code>ULift</code>s are injective in the sense that <code>ULift A = ULift B</code> implies <code>A = B</code> in their Rocq, which is not the case in Lean.</p>\n</blockquote>\n<p>Hoping not to open this can of worms too much, I thought that already the <code>Prod</code> type former can't be proven injective (<a href=\"#narrow/channel/113488-general/topic/Inequality.20of.20Types\">related</a>), so that the added non-injectivity of <code>ULift</code> wouldn't be a problem. Anyways, point taken that it is a bad omen for a universe inference mechanism if it needs modification of <code>Prod</code> and other basic type formers.</p>",
        "id": 523060921,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1749463536
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"221653\">Paul Reichert</span> has marked this topic as resolved.</p>",
        "id": 523067282,
        "sender_full_name": "Notification Bot",
        "timestamp": 1749466102
    }
]