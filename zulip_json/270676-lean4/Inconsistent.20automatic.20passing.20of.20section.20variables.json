[
    {
        "content": "<p>I am very confused about the way section variables are passed.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">}</span>\n<span class=\"n\">include</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">mutual</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"c1\">-- error: don't know how to synthesize implicit argument 'x'</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">S</span>\n</code></pre></div>\n<p>Here, the recursive calls to <code>g</code> and <code>f</code> in the body of <code>f</code> resp. <code>g</code> do not require the argument <code>x</code> to be passed explicitly. However, when <code>h</code> calls <code>f</code>, Lean seems to be trying (and failing) to find an appropriate <code>x</code> by implicit argument resolution instead of using the section variable.</p>\n<p>To add to my confusion, the above code works without an error if the definition of <code>h</code> is moved inside the mutual block or if the section variable <code>x</code> is defined with regular binders <code>(x: Unit)</code>.</p>\n<p>Here is another example which behaves slightly differently:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">S</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">H</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span>\n<span class=\"n\">include</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">H</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">notone</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span>\n<span class=\"w\">  </span><span class=\"n\">rewrite</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">H</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">  </span><span class=\"n\">contradiction</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">False</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">notone</span><span class=\"w\"> </span><span class=\"n\">H'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- error: don't know how to synthesize implicit argument 'H'</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">S</span>\n</code></pre></div>\n<p>Here, changing the binders of the section variables from implicit to regular does not solve the error, but wrapping <code>notone</code> and <code>f</code> inside a mutual block does allow <code>f</code> to call <code>notone</code> without explicitly specifying the parameter <code>H</code>.</p>\n<p>What is going on in these two examples? Why is it the case that the section variables sometimes need to be passed explicitly and sometimes are inserted automatically at function calls?<br>\nThe <a href=\"https://lean-lang.org/doc/reference/latest/Namespaces-and-Sections/#section-variables\">relevant section of the reference manual</a> does not address this.</p>",
        "id": 554275712,
        "sender_full_name": "Simon Dima",
        "timestamp": 1762508094
    },
    {
        "content": "<p>I don't know how mutual def really works, but as f is defined in the same as g it does not surprise me that lean is able to infer x from the definition of f. In your definition of h however, how is lean supposed to infer what x is? Implicit variables can only be inferred if they are referred to by explicitly provided variables, which is not the case here. Note that when you make x explicit, what happens in the definition of h is that n is interpreted as a unit element and f n as a function from Nat to Nat. I think it would be easier to see what's going on if you declared all your variables and their types, as well as the types of your defs.</p>",
        "id": 554278577,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1762509002
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"703970\">Etienne Marion</span> <a href=\"#narrow/channel/270676-lean4/topic/Inconsistent.20automatic.20passing.20of.20section.20variables/near/554278577\">said</a>:</p>\n<blockquote>\n<p>Note that when you make x explicit, what happens in the definition of h is that n is interpreted as a unit element and f n as a function from Nat to Nat.</p>\n</blockquote>\n<p>Ah, thanks, that does explain what was going on with the binders.</p>\n<p>I'm still quite curious about what's going on in the <code>mutual</code> blocks, I don't see why that would change the way section variables are passed.</p>",
        "id": 554282594,
        "sender_full_name": "Simon Dima",
        "timestamp": 1762510193
    },
    {
        "content": "<p>Mutual blocks are weird, sometimes I have a recursive call to a mutual function that doesn't typecheck but when I make all the implicit arguments explicitly by filling them in with <code>_</code> then it typechecks</p>",
        "id": 554308029,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762517714
    }
]