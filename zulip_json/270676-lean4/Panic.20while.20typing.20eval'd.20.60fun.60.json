[
    {
        "content": "<p>I have a temporary convenience command <code>local_linter</code> which allows me to declare a linter locally via e.g. <code>local_linter foo := fun stx =&gt; do ...</code> which will run on the file. However, in the middle of typing, at <code>local_linter foo := fun</code>, Lean panics. Here's why:</p>\n<p>Although we have a parse error at this location, lean still attempts to elaborate <code>fun</code>, and this yields a <code>sorry</code> in the resulting <code>nomatch</code> from <a href=\"https://github.com/leanprover/lean4/blob/e2617903f81f2f9ffc6c0b7a06cc91678c546305/src/Lean/Meta/Match/Match.lean#L430\">this MVarId.admit</a> during match elaboration (despite <code>withoutErrToSorry</code> being present, since the elaboration happens in <code>MetaM</code>). Then, my subsequent <code>evalExpr</code> panics on the sorry when trying evaluate it.</p>\n<p>I think there are three things to examine here:</p>\n<ol>\n<li>Should elaboration proceed even though we have a parse error here? In general it makes sense to elaborate as much as possible, but I'm not sure about elaborating a lone <code>fun</code> in these circumstances specifically.</li>\n<li>Should match elaboration insert a <code>sorry</code> here? I would have maybe expected an error, and a sorry up in <code>TermElabM</code> when <code>errToSorry</code> is <code>true</code>; though perhaps that would mean throwing an error for the entire match (which we don't want)?</li>\n<li>Should <code>evalExpr</code> (or something it calls) be robustified against <code>sorry</code>? It's easy enough to <code>collectAxioms</code> myself and check for <code>sorry</code> like <code>#eval</code> does, but I wonder if <code>evalExpr</code> should do this too.</li>\n</ol>\n<p>All in all this is not so much a \"how do I work around this\" thread, but a \"should we change these behaviors that it brought to light\" thread. :)</p>\n<p>And here's an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">module</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Command</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"#huh \"</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">withoutErrToSorry</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">withSynthesize</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Bool</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">getUsedConstants</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"n\">collectAxioms</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">hasSorry</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"bp\">.</span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"ss\">``sorryAx</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- note: logInfo's message is obliterated in this circumstance, so trace instead</span>\n<span class=\"w\">  </span><span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">debug</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"s2\">\"{e} has sorry := {hasSorry}\"</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">debug</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"sd\">/-- trace: [debug] nomatch has sorry := true -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">huh</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"c1\">-- unexpected end of input; expected '[', '{', '|' or '⦃'</span>\n</code></pre></div>",
        "id": 564143298,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1765923845
    },
    {
        "content": "<ol>\n<li>If you don't want to do anything when there is partial syntax, you can abort elaboration if you see that <code>t</code> has a <code>missing</code> node. You can assume <code>missing</code> means a parse error was emitted.</li>\n<li>The <code>#eval</code> command uses <code>collectAxioms</code> for the stronger check that there is no <code>sorry</code> at all. To detect elaborator errors, it suffices to check for a synthetic sorry in the term. I'm not sure why <code>withoutErrToSorry</code> doesn't suffice here. Possibly it's not hitting an elaboration error, despite the <code>sorry</code> inside the term. Or possibly there's some interaction with <code>missing</code> I'm not sure about. Or there's something about <code>match</code> that's not respecting it.</li>\n<li>This <code>collectAxioms</code> check is making sure you're not getting away with using <code>sorry</code>  for empty terms (e.g. false propositions). There's nothing inherently <em>wrong</em> with having <code>sorry</code> in a term. If you try <code>#eval! (sorry : Nat)</code> you can see there's an error despite turning off the the sorry check, not a panic.</li>\n</ol>",
        "id": 564155178,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765931731
    },
    {
        "content": "<p>Thanks! :) </p>\n<ol>\n<li>Good to know; though I was wondering more about whether the current behavior makes sense, than about what I could do! I.e. I'm skeptical it makes sense for elaboration of a lone <code>fun</code> itself to proceed when those <code>.missing</code> nodes are present.</li>\n<li>a. re: synthetic sorry checking: makes sense; though, do you happen to know if there's API for that? Note that this sorry is hidden in the value of an autogenerated <code>match_n</code> decl, so <code>hasSyntheticSorry</code> returns false. (<code>collectAxioms</code> therefore seems more convenient than e.g. <code>ImportGraph</code>'s <code>transitivelyUsedConstants</code>.)</li>\n<li>b. Does something during term elaboration check for synthetic sorries, and error if it finds them? I thought that because no error is logged (by <code>mkLabeledSorry</code>, <code>MVarId.admit</code>, or <code>match</code> when admitting), <code>withoutErrToSorry</code> is not relevant in the first place—the sorry is directly constructed. (Perhaps one of these should log an error; <code>mkLabeledSorry</code> says it's the caller's responsibility.)</li>\n<li>Ah, right, thanks for pointing that out. The \"unreachable code\" panic (which now that I look at it closely, might not be a <code>panic!</code> per se?) doesn't come from <code>evalExpr</code>; it seems like it comes from actually trying to run the resulting <code>CommandElab</code> on syntax (whether in the <code>elab</code>immediately or through the <code>lintersRef</code> as intended).</li>\n</ol>",
        "id": 564158239,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1765934110
    },
    {
        "content": "<p>(Here’s an updated panicking mwe for completeness!)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">module</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">BoolToBool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"#huh \"</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">withoutErrToSorry</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">withSynthesize</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">getUsedConstants</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"n\">collectAxioms</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">hasSorry</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"bp\">.</span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"ss\">``sorryAx</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- note: logInfo's message is obliterated in this circumstance, so trace instead</span>\n<span class=\"w\">  </span><span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">debug</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"s2\">\"{e} has sorry := {hasSorry}\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">evalExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{e true}\"</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">debug</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"sd\">/-- trace: [debug] nomatch has sorry := true -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">huh</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"c1\">-- panic; unexpected end of input; expected '[', '{', '|' or '⦃'</span>\n</code></pre></div>",
        "id": 564161916,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1765937497
    },
    {
        "content": "<ol>\n<li>I don't mean this as a workaround, but rather it's intended that elaboration proceed even if there are missing nodes. This is how term info (hovers) for partial terms works.</li>\n<li>a. Yes, <code>Expr.hasSyntheticSorry</code>. However, if there's already been a parse error, it's unclear to me whether you can rely on the presence of a synthetic sorry. b. There's already a parse error logged, so further errors aren't shown. Log messages also have some interface for reporting whether they contain an expression containing synthetic sorries, which is used somehow for further error suppression.</li>\n<li>It might be worth trying to figure out where the panic is coming from more precisely. Maybe try <code>set_option showPartialSyntaxErrors true</code> (to disable the <code>.missing</code> elaboration error suppression) or otherwise create the partial <code>Syntax</code> yourself.</li>\n</ol>",
        "id": 564172620,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765947114
    },
    {
        "content": "<ol>\n<li>Thanks for clarifying; that makes sense, but perhaps we are trying to make different points :) For my part, I believe that the core elaboration for <code>fun</code> or <code>match</code> specifically could be polished a little when <code>.missing</code> nodes are present; the hover for <code>fun</code> becomes <code>nomatch</code> in this case, which is unhelpful. Perhaps a more deliberate <code>sorry</code> of function type might be ideal—but this is polishing. :)</li>\n<li>a. As I mentioned, though, <code>hasSyntheticSorry</code> is insufficient here; though there is indeed a sorry (and it is synthetic), it's locked behind an autogenerated <code>match</code> decl, and <code>hasSyntheticSorry</code> does not unfold constants like <code>collectAxioms</code> does (and thus misses that sorry). The hypothetical API I'm asking about would therefore unfold constants; I suspect it doesn't exist.</li>\n<li>b. Hmm, interesting!</li>\n<li>I don't believe the panic has to do with syntax directly (though is of course downstream of the sorry produced by the missing syntax); rather, a declaration shaped like the autogenerated <code>match</code> (with <code>sorry : False</code> in the given position) is sufficient. <code>eval!</code> errors with \"<code>'unreachable' code was reached</code>\" but does not panic; <code>let _ := r true</code> in the <code>elab</code> does not panic; but <code>IO.println &lt;| r true</code> panics. So perhaps this is a clue as to what is actually reaching the unreachable code—the language server? But I'm not sufficiently familiar with the structure there to diagnose it precisely.</li>\n</ol>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>syntax-free mwe</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">module</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">match_foo</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n\n<span class=\"sd\">/-- error: 'unreachable' code was reached -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"k\">#eval</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"n\">match_foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kd\">set_option</span><span class=\"w\"> </span><span class=\"n\">showPartialSyntaxErrors</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"n\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"#panic\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">evalExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">    </span><span class=\"n\">mkAppN</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Expr.const</span><span class=\"w\"> </span><span class=\"ss\">``match_foo</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">IO.println</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"c1\">-- #panic</span>\n</code></pre></div>\n<div class=\"codehilite\"><pre><span></span><code>\n</code></pre></div>\n</div></div>",
        "id": 564347507,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1766007731
    }
]