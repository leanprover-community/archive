[
    {
        "content": "<p>I'm trying to write the Haskell <code>forever</code> function in Lean, defined in Haskell as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">forever</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">Applicative</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span>\n<span class=\"n\">forever</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"k\">let</span> <span class=\"n\">a'</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*&gt;</span> <span class=\"n\">a'</span> <span class=\"k\">in</span> <span class=\"n\">a'</span>\n</code></pre></div>\n<p>this function doesn't generally terminate and so can only be a partial function in Lean. However, the docs are not very explicit about how to prove the type implemented by such a function is inhabited and nonempty. I tried</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">forever</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Applicative</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">*&gt;</span> <span class=\"n\">a'</span><span class=\"bp\">;</span> <span class=\"n\">a'</span>\n</code></pre></div>\n<p>thinking that, since the function is meant to not terminate but take whatever applicative type, that type should be inhabited, right? How to make this work?</p>",
        "id": 387271450,
        "sender_full_name": "Sterea Stefan Octavian",
        "timestamp": 1692968269
    },
    {
        "content": "<p>This seems like a bad error message:</p>\n<blockquote>\n<p>failed to compile partial definition 'forever.a'', failed to show that type is inhabited and non empty</p>\n</blockquote>\n<p>It would be good if it actually showed the type in question in the message.</p>",
        "id": 387272183,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692968535
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Not safe as a global instance, conflicts with `(default : List Nat) = []` elsewhere -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Pure.toInhabited</span> <span class=\"o\">[</span><span class=\"n\">Pure</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"n\">default</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">Pure.toInhabited</span> <span class=\"k\">in</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">forever</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Applicative</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"n\">a</span> <span class=\"bp\">*&gt;</span> <span class=\"n\">forever</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 387272588,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692968688
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Safe-ish as a global instance because it is in Prop, but the `f α` might match more than it should</span>\n<span class=\"kd\">instance</span> <span class=\"n\">Pure.toNonempty</span> <span class=\"o\">[</span><span class=\"n\">Pure</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">Nonempty</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">pure</span> <span class=\"n\">a</span><span class=\"o\">⟩</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">forever</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Applicative</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"n\">a</span> <span class=\"bp\">*&gt;</span> <span class=\"n\">forever</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 387306739,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1692980529
    },
    {
        "content": "<p>it's still a bit odd to me that the nonempty can only be supplied by typeclass, instead of typeclass being a fallback for some optional syntax on <code>def</code>s...</p>",
        "id": 387343465,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1692997301
    }
]