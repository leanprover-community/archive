[
    {
        "content": "<p>I'd like to define the second one of these inductive types, but I'm blocked by the listed error. Is there an easy way to work around the error?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">-- This one works, but the function it takes doesn't know the lists have the same size</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">GoodTower</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Run a subcomputation, then sample an answer based on the results -/</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">sub</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">GoodTower</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">GoodTower</span>\n\n<span class=\"c1\">-- This one doesn't work, because</span>\n<span class=\"c1\">--   (kernel) invalid nested inductive datatype 'Vector', nested inductive datatypes</span>\n<span class=\"c1\">--   parameters cannot contain local variables.</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">BadTower</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Run a subcomputation, then sample an answer based on the results -/</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">sub</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">BadTower</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BadTower</span>\n</code></pre></div>",
        "id": 499911066,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1739623220
    },
    {
        "content": "<p>Aha, this works and is cleaner anyways:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Recursive computations that can run subcomputations -/</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Tower</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Run some subcomputations, then produce an answer based on the results -/</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">subs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Tower</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Tower</span>\n</code></pre></div>",
        "id": 499911653,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1739623773
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"514145\">Geoffrey Irving</span> has marked this topic as resolved.</p>",
        "id": 499951430,
        "sender_full_name": "Notification Bot",
        "timestamp": 1739654431
    },
    {
        "content": "<p>One could also redesign Mathlib's <code>List.Vector</code> so that it isn't just a wrapper around <code>List</code>, but itself an inductive type. <code>List.Vector</code> is rarely used in Mathlib, so it would feasible, but possibly un-rewarding, to do this.</p>",
        "id": 499951814,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1739654809
    },
    {
        "content": "<p>I was wondering if the problem had anything to do with the argument order to <code>Eq</code>, and it seems like I just ran into a bug:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">BadTower</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">sub</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">BadTower</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BadTower</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">application type mismatch</span>\n<span class=\"cm\">  List.length v</span>\n<span class=\"cm\">argument has type</span>\n<span class=\"cm\">  _nested.List_1</span>\n<span class=\"cm\">but function has type</span>\n<span class=\"cm\">  List BadTower → ℕ</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 499959664,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739662498
    },
    {
        "content": "<p>(The other argument order gives \"invalid nested inductive datatype 'Eq', nested inductive datatypes parameters cannot contain local variables.\")</p>",
        "id": 499959703,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739662551
    },
    {
        "content": "<p>Hate to suggest touching the kernel, but I wonder if there's some property of Eq that could be taken advantage of when eliminating nested inductives? Could the original BadTower Just Work?</p>",
        "id": 499959809,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739662643
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"514145\">Geoffrey Irving</span> has marked this topic as unresolved.</p>",
        "id": 499962161,
        "sender_full_name": "Notification Bot",
        "timestamp": 1739664842
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/270676-lean4/topic/Defining.20an.20inductive.20type.20using.20Vector/near/499959809\">said</a>:</p>\n<blockquote>\n<p>Hate to suggest touching the kernel, but I wonder if there's some property of Eq that could be taken advantage of when eliminating nested inductives? Could the original BadTower Just Work?</p>\n</blockquote>\n<p>The issue doesn't have to do with equality, but instead with the fact that you're trying to rely on a function over <code>List</code>s that uses the nested appearance. Since the kernel does not also translate the function <code>List.length</code>  into a new/temporary <code>_nested.List_1.length</code>, it instead produces a type error. The following code triggers the same error without the use of equality:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">BadTower</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">sub</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">BadTower</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\">  </span><span class=\"n\">BadTower</span>\n</code></pre></div>",
        "id": 499964389,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1739666978
    },
    {
        "content": "<p>As for the original error presented by <span class=\"user-mention\" data-user-id=\"514145\">@Geoffrey Irving</span> , it is twofolds:</p>\n<ul>\n<li>First, the kernel currently does not currently manage nested indexed inductives types, and nested inductives types for which nested appearances may contain variables that are not parameters. I should get around to polishing a RFC for <a href=\"https://github.com/arthur-adjedj/lean4/tree/free_vars_nested\">this</a> at some point...</li>\n<li>Even if the kernel did manage such types, it would still encounter the issue of functions relying on nested appearances being present in some constructor (as pointed out by Kyle). Indeed, the translation of nested appearances into auxiliary inductive types would lead to the  appearance of <code>List.length</code> in a field of the translation of <code>Vector</code>.</li>\n</ul>",
        "id": 499964863,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1739667428
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/270676-lean4/topic/Defining.20an.20inductive.20type.20using.20Vector/near/499951814\">said</a>:</p>\n<blockquote>\n<p>One could also redesign Mathlib's <code>List.Vector</code> so that it isn't just a wrapper around <code>List</code>, but itself an inductive type. <code>List.Vector</code> is rarely used in Mathlib, so it would feasible, but possibly un-rewarding, to do this.</p>\n</blockquote>\n<p>Does  <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Vector3#doc\">docs#Vector3</a> work?</p>",
        "id": 499967374,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739669659
    },
    {
        "content": "<p>Only for rather unusual interpretations of \"works\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- use `#guard_msgs` to silence an internal error we don't care about</span>\n<span class=\"sd\">/--</span>\n<span class=\"sd\">error: application type mismatch</span>\n<span class=\"sd\">  BadTower.rec fun {n} a a_1 a_ih =&gt; ((a_2 : Fin2 n) → motive (a a_2)) ×' ((a : Fin2 n) → a_ih a)</span>\n<span class=\"sd\">argument has type</span>\n<span class=\"sd\">  {n : ℕ} → Vector3 BadTower n → (Vector3 Bool n → Bool) → (Fin2 n → Sort (max 1 u)) → Sort (max (max 1 (imax 1 u)) 1 u)</span>\n<span class=\"sd\">but function has type</span>\n<span class=\"sd\">  ({n : ℕ} →</span>\n<span class=\"sd\">      (a : Vector3 BadTower n) →</span>\n<span class=\"sd\">        (a_1 : Vector3 Bool n → Bool) →</span>\n<span class=\"sd\">          ((a_2 : Fin2 n) → (fun t =&gt; Sort (max 1 u)) (a a_2)) → (fun t =&gt; Sort (max 1 u)) (BadTower.sub a a_1)) →</span>\n<span class=\"sd\">    (t : BadTower) → (fun t =&gt; Sort (max 1 u)) t</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">BadTower</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Run a subcomputation, then sample an answer based on the results -/</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">sub</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Vector3</span><span class=\"w\"> </span><span class=\"n\">BadTower</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Vector3</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BadTower</span>\n</code></pre></div>",
        "id": 499967509,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739669827
    },
    {
        "content": "<p>The good news is, this is not a kernel error, and the inductive type, as well as its recursor/constructors are available in the environment after the error. At first glance, it looks like Lean fails to generate the auxiliary definition <code>BadTower.below</code>, used to do course-by-value recursion. This is worth reporting in an issue.</p>",
        "id": 499968179,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1739670504
    },
    {
        "content": "<p>MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">sub</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bar</span>\n</code></pre></div>",
        "id": 499968226,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1739670596
    },
    {
        "content": "<p>In the MWE, the problem seems to be that Lean cannot unify <code>(max (max 1 (imax 1 u)) 1 u)</code> and <code>max 1 u</code>. The core problem here is that Lean does not know that <code>imax 1 u</code> can reduce to <code>u</code>. The normalisation procedure for universes already normalises <code>imax 0 u</code> to <code>u</code>, perhaps adding another special-case for <code>imax 1 u</code> could be <a href=\"https://github.com/leanprover/lean4/commit/f833c79175f945e61457f16ee5a9147ae51dda2e\">worth it ?</a></p>",
        "id": 499968478,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1739670885
    },
    {
        "content": "<p>Since you've made the MWE, mind filing the issue?</p>",
        "id": 499969121,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739671486
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/7096\">lean4#7096</a></p>",
        "id": 499969985,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1739672405
    }
]