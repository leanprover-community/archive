[
    {
        "content": "<p>There is a limited way in which <code>simp</code> will behave like <code>auto</code> from Coq. i.e.,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Q</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">P</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n <span class=\"kd\">by</span> <span class=\"n\">intros</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>My understanding of how (or why) this works is that it treats <code>P -&gt; Q -&gt; R</code> as something like <code>P -&gt; Q -&gt; R = True</code>, it then rewrites <code>R</code> to <code>True</code> (which it can prove), and then tries to do the same for the newly generated obligations (<code>P</code> and <code>Q</code>). </p>\n<p>But, I don't quite understand the extent to which this happens. e.g., I had a proof where it was completed by:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">apply</span> <span class=\"n\">constr1</span>\n<span class=\"n\">apply</span> <span class=\"n\">constr2</span>\n<span class=\"n\">assumption</span>\n<span class=\"n\">assumption</span>\n</code></pre></div>\n<p>I would _think_, based on my (very flawed) understanding above, that I should be able to replace the above sequence with <code>simp [*, constr1, constr2]</code>, and the conditional rewriting would complete the goal, but it doesn't (at least, in that case). So clearly, it doesn't always behave like <code>auto</code>, even in some pretty small cases. Perhaps the issue is that <code>apply</code> is solving for variables, and <code>simp</code> won't do that? </p>\n<p>Regardless, I'm wondering if there is anywhere where this behavior is documented. I'm happy with anything -- blog posts, well-commented code, research papers -- but trying to reverse engineer is challenging.</p>",
        "id": 342947858,
        "sender_full_name": "Daniel Patterson",
        "timestamp": 1679237656
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"494227\">Daniel Patterson</span> <a href=\"#narrow/stream/270676-lean4/topic/Documentation.20of.20simp.20behavior.20on.20.22conditional.22.20rewrites/near/342947858\">said</a>:</p>\n<blockquote>\n<p>My understanding of how (or why) this works is that it treats <code>P -&gt; Q -&gt; R</code> as something like <code>P -&gt; Q -&gt; R = True</code>, it then rewrites <code>R</code> to <code>True</code> (which it can prove), and then tries to do the same for the newly generated obligations (<code>P</code> and <code>Q</code>). </p>\n</blockquote>\n<p>No. It treats <code>P -&gt; Q -&gt; R</code> as <code>(P -&gt; Q -&gt; R) = True</code>, i.e. it rewrites the entirety of the expression to true, it is not treated as a conditional rewrite</p>",
        "id": 342954345,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679239864
    },
    {
        "content": "<p>The reason this proof works is because the last hypothesis is <code>P = True</code>, which is used to simplify <code>P -&gt; Q</code> to <code>True -&gt; Q</code> and then <code>Q</code>, whereupon we get <code>Q = True</code> and can simplify the first hypothesis to <code>True -&gt; True -&gt; R</code> and then <code>R</code></p>",
        "id": 342954529,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679239927
    },
    {
        "content": "<p>So it's not really doing <code>apply_rules</code>-like reasoning, which is what you seem to be expecting</p>",
        "id": 342954614,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679239967
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <br>\nIs <code>apply_rules</code> a Lean3 tactic not yet ported (or is it somewhere in mathlib4?)</p>\n<p>So my mental model for this should be is that it is rewriting arguments (trying to replace them with True), and it will then also drop arguments if they are trivial (i.e., (True -&gt; P) = P). </p>\n<p>In the end, doesn't this have the same effect as doing search with <code>apply</code>, but without being willing to fill in arguments?</p>\n<p>i.e., <code>forall x, x -&gt; P x</code> would never be used, even if <code>R</code> exists and the goal is <code>P R</code> (because <code>simp</code> won't try replacing <code>x</code> with <code>R</code>), but <code>Q -&gt; P</code> could be (if <code>Q</code> exists)</p>",
        "id": 342960180,
        "sender_full_name": "Daniel Patterson",
        "timestamp": 1679242478
    },
    {
        "content": "<p>it's a mathlib / mathlib4 tactic which is at the core of several other tactics. <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#apply_rules\">tactic#apply_rules</a></p>",
        "id": 342960388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679242569
    },
    {
        "content": "<p>Yes, <code>simp</code> will not be able to use a hypothesis which says <code>forall x, x -&gt; P x</code> in most cases</p>",
        "id": 342960549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679242634
    },
    {
        "content": "<p>if you use it as a global rewrite rule it will be treated as a conditional rewrite lemma</p>",
        "id": 342960634,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679242679
    },
    {
        "content": "<p>ultimately this is not what <code>simp</code> is intended for, <code>simp</code> is not <code>auto</code>. A much closer approximation of <code>auto</code> is <code>aesop</code></p>",
        "id": 342960813,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679242755
    },
    {
        "content": "<blockquote>\n<p>In the end, doesn't this have the same effect as doing search with <code>apply</code>, but without being willing to fill in arguments?</p>\n</blockquote>\n<p>That's a bit of a strange hypothetical since filling in arguments is basically all <code>apply</code> does. The case where simp can have apply-like behavior is when there is a hypothesis which is itself an implication, and the antecedents can be proved by <code>simp</code>. This is a relatively uncommon situation, although your propositional logic example is one</p>",
        "id": 342961382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679243030
    },
    {
        "content": "<p>In the case <code>h : forall x : A, x -&gt; P x</code>, this can't be simplified since neither <code>A</code> nor <code>x : A</code> can be simplified to <code>True</code> (presumably)</p>",
        "id": 342961551,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679243109
    },
    {
        "content": "<p>This strategy clearly won't work if the hypothesis doesn't have a proposition in the antecedent (since you can't prove e.g. <code>Nat = True</code>), which means forall statements are almost never going to be simplified</p>",
        "id": 342961823,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679243233
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> </p>\n<p>Thanks for the explanations! I've looked at aesop, but at this point (I'm teaching a class of a couple hundred students), depending on anything that's not in the core distribution is pretty much off the table. It would really be nice in a few cases though -- I have examples (simulation arguments for compilers) where one cases is 25 applys in a row: essentially stepping through small-step semantics for a language (in the Coq proof I translated this from, it was a single call to <code>eauto</code> :(...). They aren't hard, but they are tedious.</p>",
        "id": 342962036,
        "sender_full_name": "Daniel Patterson",
        "timestamp": 1679243327
    },
    {
        "content": "<p>I wouldn't really recommend using core alone, especially when teaching a class</p>",
        "id": 342962228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679243414
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> We're a couple weeks from the end, and it's gone quite well... Lean is already _bigger_ than is completely ideal (for understandable reasons); not really clear that having large libraries available would actually help the students (they really need to do things for themselves if they are to learn: these are undergrads, some quite young).  Tbh, the proof automation stuff is not a deal-breaker: they may be better off avoiding it, at the stage they're in. Obviously avoiding some tedium is nice, but it's not the end of the world.</p>",
        "id": 342962896,
        "sender_full_name": "Daniel Patterson",
        "timestamp": 1679243801
    },
    {
        "content": "<p>of course you wouldn't be using most of the library, and you would probably carefully curate what is usable. But having the tactics and support framework of mathlib4 seems like it would be useful when you don't want to deal with dependency management nightmares that inevitably appear when you install lean on 100 computers. At least, that's the impression I have gotten from people who teach with lean like <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> (who went to some effort to make an all-in-one mathlib + lean + vscode install package to solve this issue)</p>",
        "id": 342963439,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679244075
    },
    {
        "content": "<p>In math there is no such debate, you cannot do anything without mathlib. However the scale difference will certainly be a big problem when I'll switch to Lean 4. In Lean 3 I could distribute Lean+the relevant part of mathlib in less than 100MB. With Lean 4 and its gigantic oleans it seems it will be ten times bigger.</p>",
        "id": 342969356,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1679247322
    },
    {
        "content": "<p>If I were teaching math, I'm sure I'd feel the same way. But I'm not: this is a course about specification and logic for computer science students.  </p>\n<p>And there were a few things from Lean 4 that I did want (e.g., much more pleasant way to deal with termination arguments). With Lean 4, not sure how installing just Lean would be more complicated than Lean + mathlib (which currently is quite unstable).</p>",
        "id": 342970545,
        "sender_full_name": "Daniel Patterson",
        "timestamp": 1679247880
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"494227\">Daniel Patterson</span> has marked this topic as resolved.</p>",
        "id": 342970555,
        "sender_full_name": "Notification Bot",
        "timestamp": 1679247884
    }
]